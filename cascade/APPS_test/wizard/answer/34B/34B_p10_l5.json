[
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, u, v):\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n        if u_root == v_root:\n            return False\n        parent[v_root] = u_root\n        return True\n\n    def is_ancestor(parent, u, v):\n        while v != parent[v]:\n            v = parent[v]\n        while u != parent[u]:\n            u = parent[u]\n        return u == v\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n    parent = [i for i in range(n + 1)]\n    for u, v in edges:\n        union(parent, u, v)\n\n    res = 0\n    a, b, c = 0, 0, 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if not is_ancestor(parent, i, j):\n                for k in range(j + 1, n + 1):\n                    if not is_ancestor(parent, i, k) and not is_ancestor(parent, j, k):\n                        candidate = len(set(edges) & {(min(u, v), max(u, v)) for u, v in {(i, j), (j, k), (i, k)}})\n                        if candidate > res:\n                            res = candidate\n                            a, b, c = i, j, k\n\n    return f'{res}\\n{a} {b} {c}\\n'"
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split()[0])\n    edges = [tuple(map(int, line.strip().split())) for line in stdin.strip().split('\\n')[1:]]\n\n    # Create adjacency list\n    adj_list = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Depth first search to find all possible paths\n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path)\n        path.pop()\n        visited.remove(node)\n\n    paths = []\n    for node in range(1, n + 1):\n        for neighbor in adj_list[node]:\n            visited = {node, neighbor}\n            path = []\n            dfs(node, visited, path)\n            paths.extend(path)\n\n    # Find the maximum number of edges on the paths\n    res = 0\n    for u in range(1, n):\n        for v in range(u + 1, n + 1):\n            edges_count = sum(1 for path in paths if u in path and v in path)\n            if edges_count > res:\n                res = edges_count\n                a, b, c = u, v, [i for i in range(1, n + 1) if i != u and i != v][0]\n\n    return f\"{res}\\n{a} {b} {c}\""
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(u, v):\n        path = []\n        path.append(u)\n        while u != v:\n            u = L[u]\n            path.append(u)\n        return path\n\n    def lca(u, v):\n        if u == v:\n            return u\n        path1 = find_path(u, root)\n        path2 = find_path(v, root)\n        i = 0\n        while i < len(path1) and i < len(path2) and path1[i] == path2[i]:\n            i += 1\n        return path1[i - 1]\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    L = [0] * (n + 1)\n    root = 1\n    max_edges = 0\n    a, b, c = 0, 0, 0\n\n    for u, v in edges:\n        L[v] = u\n\n    for i in range(1, n + 1):\n        for j in range(1, i):\n            k = lca(i, j)\n            path_ij = len(find_path(i, j)) - 1\n            path_ik = len(find_path(i, k)) - 1\n            path_kj = len(find_path(k, j)) - 1\n            edges_count = path_ij + path_ik + path_kj - 2\n            if edges_count > max_edges:\n                max_edges = edges_count\n                a, b, c = i, j, k\n\n    return f\"{max_edges}\\n{a} {b} {c}\\n\""
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        if parent[u] == -1:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u = find(parent, u)\n        v = find(parent, v)\n        if u == v:\n            return False\n        if rank[u] < rank[v]:\n            parent[u] = v\n        elif rank[u] > rank[v]:\n            parent[v] = u\n        else:\n            parent[v] = u\n            rank[u] += 1\n        return True\n\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    edges = input_list[1:]\n\n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n\n    for u, v in edges:\n        union(parent, rank, u, v)\n\n    max_edges = 0\n    max_vertices = None\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if find(parent, u) != find(parent, v):\n                num_edges = 0\n                for a, b in edges:\n                    if (find(parent, a) == find(parent, u) and find(parent, b) == find(parent, v)) or (find(parent, a) == find(parent, v) and find(parent, b) == find(parent, u)):\n                        num_edges += 1\n                if num_edges > max_edges:\n                    max_edges = num_edges\n                    max_vertices = (u, v)\n\n    res = max_edges\n    a, b = max_vertices\n    c = 1\n    for i in range(1, n + 1):\n        if i != a and i != b:\n            c = i\n            break\n\n    return f\"{res}\\n{a} {b} {c}\""
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, p):\n        vis[v] = True\n        for u in G[v]:\n            if u != p and not vis[u]:\n                dfs(u, v)\n                for x in G[v]:\n                    if x != p:\n                        path[v].add(x)\n                for x in G[u]:\n                    if x != v:\n                        path[u].add(x)\n\n    def max_edges(a, b, c):\n        return len(path[a] & path[b]) + len(path[b] & path[c]) + len(path[a] & path[c])\n\n    n, edges = map(int, stdin.split('\\n', 1)[0].split())\n    G = [[] for _ in range(n + 1)]\n    for e in stdin.split('\\n')[1:]:\n        a, b = map(int, e.split())\n        G[a].append(b)\n        G[b].append(a)\n\n    vis = [False] * (n + 1)\n    path = [set() for _ in range(n + 1)]\n\n    dfs(1, -1)\n\n    res = 0\n    ans = (0, 0, 0)\n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            if a == b:\n                continue\n            for c in range(1, n + 1):\n                if c == a or c == b:\n                    continue\n                e = max_edges(a, b, c)\n                if e > res:\n                    res = e\n                    ans = (a, b, c)\n\n    return f\"{res}\\n{ans[0]} {ans[1]} {ans[2]}\" "
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        n = int(stdin.readline().strip())\n        edges = []\n        for i in range(n - 1):\n            a, b = map(int, stdin.readline().strip().split())\n            edges.append((a, b))\n        return n, edges\n\n    def find_max_edges(n, edges) -> int:\n        max_edges = 0\n        for a in range(1, n + 1):\n            for b in range(1, n + 1):\n                if a != b:\n                    for c in range(1, n + 1):\n                        if c not in (a, b):\n                            paths = [set(), set(), set()]\n                            for i, (u, v) in enumerate(edges):\n                                if u == a and v == b:\n                                    paths[0].add(i)\n                                elif u == b and v == c:\n                                    paths[1].add(i)\n                                elif u == a and v == c:\n                                    paths[2].add(i)\n                            max_edges = max(max_edges, len(paths[0] | paths[1] | paths[2]))\n        return max_edges\n\n    def find_vertices(n, edges, max_edges) -> tuple:\n        for a in range(1, n + 1):\n            for b in range(1, n + 1):\n                if a != b:\n                    for c in range(1, n + 1):\n                        if c not in (a, b):\n                            paths = [set(), set(), set()]\n                            for i, (u, v) in enumerate(edges):\n                                if u == a and v == b:\n                                    paths[0].add(i)\n                                elif u == b and v == c:\n                                    paths[1].add(i)\n                                elif u == a and v == c:\n                                    paths[2].add(i)\n                            if len(paths[0] | paths[1] | paths[2])) == max_edges:\n                                return a, b, c\n\n    n, edges = read_input()\n    max_edges = find_max_edges(n, edges)\n    a, b, c = find_vertices(n, edges, max_edges)\n    return f\"{max_edges}\\n{a} {b} {c}\""
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, parent):\n        sz = 1\n        for u in tree[v]:\n            if u != parent:\n                sz += dfs(u, v)\n        return sz\n\n    def is_ancestor(u, v):\n        while v != -1:\n            if v == u:\n                return True\n            v = path[v]\n        return False\n\n    def find_lca(u, v):\n        while v != -1:\n            if is_ancestor(u, v):\n                return v\n            v = path[v]\n        return -1\n\n    n = int(stdin.readline().strip())\n    tree = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n\n    size = [0] * n\n    parent = [-1] * n\n    depth = [0] * n\n    stack = [0]\n    while stack:\n        v = stack.pop()\n        for u in tree[v]:\n            if u != parent[v]:\n                parent[u] = v\n                stack.append(u)\n                depth[u] = depth[v] + 1\n                size[v] += size[u] + 1\n\n    path = [-1] * n\n    for i in range(n):\n        if size[i] > n // 2:\n            u = i\n            while path[u] != -1:\n                path[u] = -1\n                u = parent[u]\n\n    res = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and is_ancestor(i, j):\n                res += 1\n\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_ancestor(i, j):\n                lca = find_lca(i, j)\n                ans = max(ans, size[i] + size[j] - size[lca] + 1)\n\n    if ans > res:\n        res = ans\n\n    return f\"{res}\\n1 1 1\""
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    edges = [tuple(map(int, edge.split())) for edge in input_list[1:]]\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    for a, b in edges:\n        union(parent, rank, a, b)\n\n    res = 0\n    a, b, c = 0, 0, 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if find(parent, i) != find(parent, j):\n                res += 1\n                if a == 0:\n                    a, b, c = i, j, 0\n                elif b == 0:\n                    b, c = i, j\n                else:\n                    c = i\n\n    return f\"{res}\\n{a} {b} {c}\" "
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited):\n        visited[start] = True\n        for v in graph[start]:\n            if not visited[v]:\n                dfs(graph, v, visited)\n\n    def build_tree(n, edges):\n        graph = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return graph\n\n    def max_edges(graph, n):\n        visited = [False] * (n + 1)\n        dfs(graph, 1, visited)\n        vertices = [i for i in range(1, n + 1) if not visited[i]]\n        if len(vertices) != 3:\n            return -1, None\n        a, b, c = vertices\n        path_ab = set(graph[a]) | set(graph[b])\n        path_ac = set(graph[a]) | set(graph[c])\n        path_bc = set(graph[b]) | set(graph[c])\n        res = len(path_ab & path_bc & path_ac)\n        return res, (a, b, c)\n\n    n, edges = map(int, stdin.split())\n    graph = build_tree(n, edges)\n    res, vertices = max_edges(graph, n)\n    return f\"{res}\\n{vertices[0]} {vertices[1]} {vertices[2]}\" "
    },
    {
        "number": 4000,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n = int(input_data[0])\n    edges = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Create adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Find the maximum number of edges which belong to at least one of the simple paths between a and b, b and c, or a and c\n    max_edges = 0\n    for a in range(1, n - 1):\n        for b in range(a + 1, n):\n            if b in adj[a]:\n                continue\n            visited = [False] * (n + 1)\n            stack = [(a, 0)]\n            while stack:\n                u, depth = stack.pop()\n                visited[u] = True\n                for v in adj[u]:\n                    if not visited[v]:\n                        stack.append((v, depth + 1))\n                        if v == b:\n                            max_edges = max(max_edges, depth)\n                            break\n\n    # Find three distinct vertices a, b, c\n    for a in range(1, n - 2):\n        for b in range(a + 1, n - 1):\n            if b in adj[a]:\n                continue\n            visited = [False] * (n + 1)\n            stack = [(a, 0)]\n            while stack:\n                u, depth = stack.pop()\n                visited[u] = True\n                for v in adj[u]:\n                    if not visited[v]:\n                        stack.append((v, depth + 1))\n                        if v == b:\n                            for c in range(b + 1, n):\n                                if c not in adj[a] and c not in adj[b]:\n                                    print(max_edges)\n                                    print(a, c, b)\n                                    return \"\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_divisors(n):\n        divisors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    x_divisors = set()\n    y_divisors = set()\n\n    for number in numbers:\n        if number in x_divisors:\n            y_divisors.add(number)\n        elif number in y_divisors:\n            x_divisors.add(number)\n        else:\n            if len(x_divisors) <= len(y_divisors):\n                x_divisors.add(number)\n            else:\n                y_divisors.add(number)\n\n    x = 1\n    for divisor in x_divisors:\n        x *= divisor\n\n    y = 1\n    for divisor in y_divisors:\n        y *= divisor\n\n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    divisors = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    x_divisors = []\n    y_divisors = []\n\n    for i in range(n):\n        if i % 2 == 0:\n            x_divisors.append(divisors[i])\n        else:\n            y_divisors.append(divisors[i])\n\n    x = 1\n    y = 1\n\n    for d in x_divisors:\n        x *= d\n\n    for d in y_divisors:\n        y *= d\n\n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    divisors = list(map(int, stdin.readline().split()))\n\n    x_divisors = []\n    y_divisors = []\n\n    for i in range(n):\n        if i % 2 == 0:\n            x_divisors.append(divisors[i])\n        else:\n            y_divisors.append(divisors[i])\n\n    x = 1\n    y = 1\n\n    for div in x_divisors:\n        x *= div\n\n    for div in y_divisors:\n        y *= div\n\n    return str(x) + \" \" + str(y)"
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    divisors = [int(x) for x in stdin.readline().split()]\n    divisors.sort()\n    \n    x_divisors = []\n    y_divisors = []\n    \n    for i in range(n):\n        if i % 2 == 0:\n            x_divisors.append(divisors[i])\n        else:\n            y_divisors.append(divisors[i])\n    \n    x = 1\n    y = 1\n    \n    for d in x_divisors:\n        x *= d\n        \n    for d in y_divisors:\n        y *= d\n    \n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    divisors = [int(x) for x in stdin.readline().strip().split()]\n\n    x_divisors = []\n    y_divisors = []\n\n    for d in divisors:\n        if d not in x_divisors:\n            x_divisors.append(d)\n        if d not in y_divisors:\n            y_divisors.append(d)\n\n    x = 1\n    for d in x_divisors:\n        x *= d\n\n    y = 1\n    for d in y_divisors:\n        y *= d\n\n    return f\"{x} {y}\"\n"
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    divisors = list(map(int, stdin.readline().strip().split()))\n    \n    x_divisors = set()\n    y_divisors = set()\n    \n    for d in divisors:\n        if d not in x_divisors:\n            x_divisors.add(d)\n        else:\n            y_divisors.add(d)\n    \n    x = 1\n    y = 1\n    \n    for d in x_divisors:\n        x *= d\n        \n    for d in y_divisors:\n        y *= d\n        \n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_divisors(n):\n        divisors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    def merge_divisors(divisors_x, divisors_y):\n        merged_divisors = []\n        for divisor in divisors_x:\n            if divisor in divisors_y:\n                merged_divisors.append(divisor)\n        return merged_divisors\n\n    n = int(stdin.readline().strip())\n    input_list = [int(x) for x in stdin.readline().strip().split()]\n\n    divisors_x = []\n    divisors_y = []\n\n    for i in range(n):\n        if i % 2 == 0:\n            divisors_x.append(input_list[i])\n        else:\n            divisors_y.append(input_list[i])\n\n    x = max(divisors_x)\n    y = max(divisors_y)\n\n    while True:\n        if merge_divisors(find_divisors(x), find_divisors(y)) == input_list:\n            break\n        x += 1\n        y += 1\n\n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    divisors = list(map(int, stdin.split('\\n')[1].split()))\n    divisors.sort()\n\n    x = []\n    y = []\n\n    for i in range(n // 2):\n        x.append(divisors[i * 2])\n        y.append(divisors[i * 2 + 1])\n\n    x.sort()\n    y.sort()\n\n    x = int(''.join(map(str, x)))\n    y = int(''.join(map(str, y)))\n\n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    divisors = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    x_divisors = []\n    y_divisors = []\n    \n    for i in range(n):\n        if i % 2 == 0:\n            x_divisors.append(divisors[i])\n        else:\n            y_divisors.append(divisors[i])\n    \n    x = 1\n    y = 1\n    \n    for divisor in x_divisors:\n        x *= divisor\n    \n    for divisor in y_divisors:\n        y *= divisor\n    \n    return f\"{x} {y}\""
    },
    {
        "number": 4001,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    divisors = list(map(int, stdin.split('\\n')[1].split()))\n    divisors.sort()\n\n    x_divisors = []\n    y_divisors = []\n\n    for i in range(n // 2):\n        if divisors[i] == divisors[i * 2]:\n            x_divisors.append(divisors[i])\n            y_divisors.append(divisors[i * 2])\n        else:\n            x_divisors.append(divisors[i])\n            y_divisors.append(divisors[i * 2])\n\n    x = 1\n    y = 1\n\n    for divisor in x_divisors:\n        x *= divisor\n\n    for divisor in y_divisors:\n        y *= divisor\n\n    return f\"{x} {y}\""
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    a = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n\n    def is_divisible_by_k(s: int) -> bool:\n        return s % k == 0\n\n    def count_elements_to_choose(row: List[int]) -> int:\n        return min(len(row) // 2, len([x for x in row if is_divisible_by_k(x)]))\n\n    def sum_row_with_max_divisible_by_k(row: List[int]) -> int:\n        row_sum = sum(row)\n        if is_divisible_by_k(row_sum):\n            return row_sum\n\n        elements_to_choose = count_elements_to_choose(row)\n        if elements_to_choose == 0:\n            return 0\n\n        row = sorted(row, reverse=True)\n        max_sum = float('-inf')\n        for i in range(1, elements_to_choose + 1):\n            for combo in itertools.combinations(row, i):\n                if is_divisible_by_k(sum(combo)):\n                    max_sum = max(max_sum, sum(combo))\n\n        return max_sum\n\n    max_sum = 0\n    for row in a:\n        max_sum += sum_row_with_max_divisible_by_k(row)\n\n    return str(max_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    a = [[int(x) for x in stdin.split('\\n')[i + 1].split()] for i in range(n)]\n\n    def is_divisible(k, total):\n        return total % k == 0\n\n    def find_max_sum(a, n, m, k):\n        max_sum = 0\n        for i in range(n):\n            row_sum = 0\n            for j in range(m):\n                row_sum += a[i][j]\n            max_sum += row_sum\n        return max_sum\n\n    max_sum = find_max_sum(a, n, m, k)\n\n    for i in range(n):\n        for j in range(1, m // 2 + 1):\n            for subset in itertools.combinations(a[i], j):\n                subset_sum = sum(subset)\n                if is_divisible(k, subset_sum) and subset_sum > max_sum:\n                    max_sum = subset_sum\n\n    return str(max_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    max_sum = 0\n\n    for row in a:\n        row.sort()\n        row_sum = 0\n\n        for i in range(len(row)):\n            if i > m // 2:\n                break\n\n            row_sum += row[i]\n\n        if row_sum % k == 0:\n            max_sum = max(max_sum, row_sum)\n\n    return str(max_sum)\n"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_divisible(row, selected_indices):\n        total = sum(a[row][i] for i in selected_indices)\n        return total % k == 0\n\n    def helper(row, selected_indices):\n        if row == n:\n            return 0\n\n        max_sum = helper(row + 1, selected_indices)\n        for i in range(len(a[row])):\n            new_selected_indices = selected_indices + [i]\n            new_selected_indices.sort()\n            if len(new_selected_indices) <= m // 2 and is_divisible(row, new_selected_indices):\n                max_sum = max(max_sum, helper(row + 1, new_selected_indices))\n\n        return max_sum\n\n    return str(helper(0, []))"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = [list(map(int, stdin.split()[3 + i * m:3 + i * m + m])) for i in range(n)]\n\n    max_sum = 0\n    for i in range(n):\n        row_sum = 0\n        for j in range(m):\n            row_sum += a[i][j]\n        max_sum += row_sum\n\n    for i in range(n):\n        row_sum = 0\n        for j in range(m):\n            row_sum += a[i][j]\n        for j in range(m):\n            for l in range(j + 1, m):\n                temp_sum = row_sum - a[i][j] - a[i][l]\n                if temp_sum % k == 0 and temp_sum > max_sum:\n                    max_sum = temp_sum\n\n    return str(max_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n\n    max_sum = 0\n\n    for row in matrix:\n        row.sort(reverse=True)\n        current_sum = 0\n        for i in range(len(row)):\n            if i >= (m // 2) or current_sum % k != 0:\n                break\n            current_sum += row[i]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = []\n    for i in range(n):\n        a.append(list(map(int, stdin.split()[3 + i * m:3 + i * m + m])))\n\n    def is_divisible(arr, k):\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if (arr[i] + arr[j]) % k == 0:\n                    return True\n        return False\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(1, len(a[i]) // 2 + 1):\n            for comb in combinations(a[i], j):\n                if is_divisible(list(comb), k):\n                    max_sum = max(max_sum, sum(comb))\n\n    return str(max_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n\n    max_sum = 0\n\n    for row in matrix:\n        elements = sorted(row, reverse=True)\n        half_length = (len(elements) + 1) // 2\n        current_sum = sum(elements[:half_length])\n\n        if current_sum % k == 0 and current_sum > max_sum:\n            max_sum = current_sum\n\n    return str(max_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    matrix = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n\n    total_sum = 0\n    for row in matrix:\n        row.sort()\n        elements_to_choose = min(len(row) // 2, k - total_sum % k)\n        total_sum += sum(row[-elements_to_choose:])\n\n    return str(total_sum)"
    },
    {
        "number": 4002,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = [list(map(int, row.split())) for row in stdin.split()[3:]]\n\n    def is_divisible_by_k(sum: int) -> bool:\n        return sum % k == 0\n\n    def backtrack(row: int, current_sum: int, remaining_elements: int) -> int:\n        if row == n:\n            return current_sum if is_divisible_by_k(current_sum) else 0\n\n        choose_elements = backtrack(row + 1, current_sum + remaining_elements, remaining_elements // 2)\n        skip_elements = backtrack(row + 1, current_sum, remaining_elements // 2)\n\n        return max(choose_elements, skip_elements)\n\n    max_sum = backtrack(0, 0, m)\n    return str(max_sum)"
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    moves = []\n    while a:\n        if a[0] < a[-1]:\n            moves.append('R')\n            a.pop()\n        else:\n            moves.append('L')\n            a.pop(0)\n\n    return f\"{len(moves)}\\n{''.join(moves)}\\n\""
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    if len(set(a)) != len(a):\n        raise ValueError(\"All values in input must be distinct.\")\n\n    def is_increasing_subsequence(sequence):\n        return all(sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1))\n\n    l = []\n    r = []\n    for i in range(n):\n        if not l or a[i] < l[-1]:\n            l.append(a[i])\n    for i in range(n - 1, -1, -1):\n        if not r or a[i] < r[-1]:\n            r.append(a[i])\n\n    l_seq = []\n    r_seq = []\n    for i in range(len(l) - 1):\n        l_seq.append(l[i + 1] - l[i])\n    for i in range(len(r) - 1):\n        r_seq.append(r[i + 1] - r[i])\n\n    if len(l_seq) <= len(r_seq):\n        seq = l\n        increasing_seq = is_increasing_subsequence(seq)\n        if increasing_seq:\n            return f\"{len(seq)}\\n{'L' * len(seq)}\"\n        else:\n            return f\"{len(seq) - 1}\\n{'R' + 'L' * (len(seq) - 2)}\"\n    else:\n        seq = r\n        increasing_seq = is_increasing_subsequence(seq)\n        if increasing_seq:\n            return f\"{len(seq)}\\n{'R' * len(seq)}\"\n        else:\n            return f\"{len(seq) - 1}\\n{'R' * (len(seq) - 1) + 'L'}\""
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_increasing(sequence: List[int]) -> bool:\n        return all(sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1))\n\n    def find_longest_increasing_sequence(sequence: List[int]) -> Tuple[int, str]:\n        longest_length = 0\n        longest_sequence = \"\"\n\n        for move in [\"L\", \"R\"]:\n            current_sequence = [sequence[0]]\n            if move == \"L\":\n                sequence_copy = sequence.copy()\n            else:\n                sequence_copy = sequence[::-1]\n\n            for _ in range(len(sequence) - 1):\n                if move == \"L\":\n                    current_element = sequence_copy.pop(0)\n                else:\n                    current_element = sequence_copy.pop()\n\n                if current_element > current_sequence[-1]:\n                    current_sequence.append(current_element)\n\n            if is_increasing(current_sequence) and len(current_sequence) > longest_length:\n                longest_length = len(current_sequence)\n                longest_sequence = move * len(current_sequence)\n\n        return longest_length, longest_sequence\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n\n    longest_length, longest_sequence = find_longest_increasing_sequence(a)\n\n    return f\"{longest_length}\\n{longest_sequence}\""
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n    stack = []\n    for i in range(n):\n        if not stack or a[i] > stack[-1]:\n            stack.append(a[i])\n    \n    k = len(stack)\n    s = ['R'] * k\n    \n    for i in range(n):\n        if binary_search(stack, a[i]):\n            s[stack.index(a[i])] = 'L'\n        else:\n            stack.append(a[i])\n            s.append('R')\n            k += 1\n    \n    return f\"{k}\\n{''.join(s)}\""
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    l = [0] * n\n    r = [0] * n\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if a[i] < a[i + 1]:\n            r[i] = r[i + 1] + 1\n\n    k = 0\n    s = ''\n    for i in range(n):\n        k = max(k, l[i] + r[i] + 1)\n\n    for i in range(n - 1, -1, -1):\n        if l[i] == k - 1:\n            s = 'L' + s\n            k -= 1\n            continue\n\n        if r[i] == k - 1:\n            s = 'R' + s\n            k -= 1\n            continue\n\n        if l[i] + r[i] + 1 == k:\n            if i == n - 1 or (i < n - 1 and a[i] < a[i + 1]):\n                s = 'R' + s\n            else:\n                s = 'L' + s\n            k -= 1\n\n    return f'{k}\\n{s}'"
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    increasing_sequence = []\n    i, j = 0, n - 1\n\n    while i <= j:\n        if not increasing_sequence or a[i] > increasing_sequence[-1]:\n            increasing_sequence.append(a[i])\n            i += 1\n        else:\n            increasing_sequence.append(a[j])\n            j -= 1\n\n    k = len(increasing_sequence)\n    s = ''\n    i, j = 0, n - 1\n\n    for _ in range(k):\n        if a[i] == increasing_sequence[k - 1 - _]:\n            s = 'L' + s\n            i += 1\n        else:\n            s = 'R' + s\n            j -= 1\n\n    return f'{k}\\n{s}\\n'"
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def increasing_sequence(left, right, direction):\n        if left < right:\n            return increasing_sequence(left + 1, right, 'R') + direction\n        return direction\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    a.sort()\n    answer = increasing_sequence(0, n - 1, '')\n\n    print(len(answer))\n    print(answer)\n"
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_increasing_sequence(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    k = find_longest_increasing_sequence(arr)\n    s = \"\"\n    for i in range(k):\n        if arr[0] < arr[-1]:\n            s += \"L\" if arr[0] < arr[1] else \"R\"\n            arr.pop(0) if arr[0] < arr[1] else arr.pop()\n        else:\n            s += \"R\" if arr[0] > arr[-1] else \"L\"\n            arr.pop(0) if arr[0] > arr[-1] else arr.pop()\n\n    return f\"{k}\\n{s}\\n\""
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_increasing_sequence(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] >= arr[i + 1]:\n                return False\n        return True\n\n    def find_sequence(arr):\n        sequences = []\n        for i in range(len(arr)):\n            sequence = [arr[i]]\n            arr.pop(i)\n            while arr:\n                if arr[0] > sequence[-1]:\n                    sequence.append(arr[0])\n                    arr.pop(0)\n                elif arr[-1] > sequence[-1]:\n                    sequence.append(arr[-1])\n                    arr.pop(-1)\n                else:\n                    break\n            if len(sequence) == len(arr) + 1:\n                return len(sequence), sequence\n            sequences.append(sequence)\n        return max(sequences, key=len)\n\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(set(arr)) == len(arr):\n        sequence = find_sequence(arr)\n        return str(len(sequence)), ''.join(['L' if x == sequence[0] else 'R' for x in sequence])\n    else:\n        leftmost = [arr[0]]\n        rightmost = [arr[-1]]\n        arr.pop(0)\n        arr.pop(-1)\n\n        while arr:\n            if arr[0] > leftmost[-1]:\n                leftmost.append(arr[0])\n                arr.pop(0)\n            elif arr[-1] > rightmost[-1]:\n                rightmost.append(arr[-1])\n                arr.pop(-1)\n\n        if len(leftmost) > len(rightmost):\n            return str(len(leftmost)), 'L' * len(leftmost)\n        else:\n            return str(len(rightmost)), 'R' * len(rightmost)"
    },
    {
        "number": 4003,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    dp = [1] * n\n    prev = [None] * n\n\n    for i in range(n):\n        for j in range(i):\n            if a[i] > a[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    k = max(dp)\n    ans = ['R'] * k\n    i = dp.index(k)\n    while i is not None:\n        if prev[i] is not None and dp[i] == dp[prev[i]] + 1:\n            ans[dp[i] - 1] = 'L'\n        i = prev[i]\n\n    return f'{k}\\n' + ''.join(reversed(ans))"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    a.sort()\n    D = 0\n    \n    for i in range(1, n):\n        diff = a[i] - a[i-1]\n        if diff > D:\n            D = diff\n    \n    if a[0] + D > a[-1]:\n        return \"-1\"\n    \n    return str(D)"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    min_d = float('inf')\n    max_a = max(a)\n\n    for i in range(1, max_a + 1):\n        if all(x % i == 0 for x in a):\n            if i < min_d:\n                min_d = i\n\n    return str(min_d) if min_d != float('inf') else '-1'"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    \n    if len(set(a)) == 1:\n        return 0\n    \n    a_min = min(a)\n    a_max = max(a)\n    \n    if a_min == a_max:\n        return 0\n    \n    D = a_max - a_min\n    \n    for i in range(n):\n        if a[i] - D < 0:\n            return -1\n    \n    return D"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_d(a: List[int]) -> int:\n        a.sort()\n        min_d = float('inf')\n        for i in range(len(a) - 1):\n            min_d = min(min_d, a[i + 1] - a[i])\n        return min_d\n\n    def check_equal(a: List[int], d: int) -> bool:\n        for i in range(len(a)):\n            if a[i] + d < a[0] + d:\n                return False\n        return True\n\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    min_d = find_min_d(a)\n\n    if check_equal(a, min_d):\n        return str(min_d)\n    else:\n        return \"-1\""
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    min_d = float(\"inf\")\n    d_exists = False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = abs(a[i] - a[j])\n            if d < min_d:\n                min_d = d\n                d_exists = True\n\n    for i in range(n):\n        if a[i] < min_d:\n            d = min_d - a[i]\n            if d < min_d:\n                min_d = d\n                d_exists = True\n\n    if d_exists:\n        return str(min_d)\n    else:\n        return \"-1\""
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    \n    a_min = min(a)\n    a_max = max(a)\n    a_sum = sum(a)\n    \n    if a_min == a_max:\n        return 0\n    \n    if a_sum % n != 0:\n        return -1\n    \n    avg = a_sum // n\n    \n    if avg < a_min:\n        return -1\n    \n    D = avg - a_min\n    \n    return D"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    a_min = min(a)\n    a_max = max(a)\n\n    if a_min == a_max:\n        return \"-1\"\n\n    d = a_max - a_min\n\n    return str(d)"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    min_d = float('inf')\n    found = False\n\n    for d in range(101):\n        equal = True\n        for i in range(n):\n            if a[i] + d not in a or a[i] - d not in a:\n                equal = False\n                break\n        if equal:\n            found = True\n            min_d = min(min_d, d)\n\n    return str(min_d if found else -1)"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_D(arr, n):\n        arr.sort()\n        D = 0\n        for i in range(n - 1):\n            if arr[i + 1] - arr[i] > D:\n                D = arr[i + 1] - arr[i]\n        return D\n\n    def find_min_D_helper(arr, n, i, D):\n        if i == n:\n            return D\n        D = min(D, arr[i] - (arr[0] + D))\n        return find_min_D_helper(arr, n, i + 1, D)\n\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    min_D = find_min_D(arr, n)\n    min_D = find_min_D_helper(arr, n, 0, min_D)\n\n    if min_D < 0:\n        return \"-1\"\n    else:\n        return str(min_D)"
    },
    {
        "number": 4004,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = sorted(a)\n    min_diff = float('inf')\n    D = -1\n\n    for i in range(1, n):\n        diff = a[i] - a[0]\n        if diff < min_diff:\n            min_diff = diff\n            D = diff\n\n    if D == 0:\n        return str(D)\n\n    for i in range(1, n):\n        diff = a[i] - a[0]\n        if diff == min_diff:\n            continue\n        elif diff < min_diff:\n            min_diff = diff\n            D = diff\n        else:\n            return str(-1)\n\n    return str(D)"
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[0].split())\n    x3, y3, x4, y4 = map(int, stdin.split()[1].split())\n    x5, y5, x6, y6 = map(int, stdin.split()[2].split())\n\n    if (x1 < x3 or x1 > x4) and (x2 < x3 or x2 > x4) and (y1 < y3 or y1 > y4) and (y2 < y3 or y2 > y4):\n        return \"YES\"\n\n    if (x1 < x5 or x1 > x6) and (x2 < x5 or x2 > x6) and (y1 < y5 or y1 > y6) and (y2 < y5 or y2 > y6):\n        return \"YES\"\n\n    if (x3 < x1 and x3 > x2) and (x4 < x1 and x4 > x2) and (y3 < y1 and y3 > y2) and (y4 < y1 and y4 > y2):\n        return \"YES\"\n\n    if (x5 < x1 and x5 > x2) and (x6 < x1 and x6 > x2) and (y5 < y1 and y5 > y2) and (y6 < y1 and y6 > y2):\n        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    coords = [int(x) for x in stdin.split()]\n    x1, y1, x2, y2 = coords[:4]\n    x3, y3, x4, y4 = coords[4:8]\n    x5, y5, x6, y6 = coords[8:]\n\n    if x1 > x3 and x1 > x5:\n        return \"YES\" if x2 < x4 or x2 < x6 else \"NO\"\n    elif x2 < x4 and x2 < x6:\n        return \"YES\"\n    elif x3 > x1 and x3 > x5:\n        return \"YES\" if x4 < x2 or x4 < x6 else \"NO\"\n    elif x4 < x2 and x4 < x6:\n        return \"YES\"\n    elif y1 > y3 and y1 > y5:\n        return \"YES\" if y2 < y4 or y2 < y6 else \"NO\"\n    elif y2 < y4 and y2 < y6:\n        return \"YES\"\n    elif y3 > y1 and y3 > y5:\n        return \"YES\" if y4 < y2 or y4 < y6 else \"NO\"\n    elif y4 < y2 and y4 < y6:\n        return \"YES\"\n    else:\n        return \"NO\" "
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[0].split())\n    x3, y3, x4, y4 = map(int, stdin.split()[1].split())\n    x5, y5, x6, y6 = map(int, stdin.split()[2].split())\n\n    def is_inside(x, y, x_min, y_min, x_max, y_max):\n        return x_min <= x <= x_max and y_min <= y <= y_max\n\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            if not (is_inside(x, y, x3, y3, x4, y4) or is_inside(x, y, x5, y5, x6, y6)):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    x3, y3, x4, y4 = map(int, stdin.readline().split())\n    x5, y5, x6, y6 = map(int, stdin.readline().split())\n\n    # Check if some part of the white sheet can be seen\n    if x1 < x3 and x2 > x4 and y1 < y3 and y2 > y4:\n        if x1 < x5 and x2 > x6 and y1 < y5 and y2 > y6:\n            return \"NO\"\n        else:\n            return \"YES\"\n    elif x1 < x5 and x2 > x6 and y1 < y5 and y2 > y6:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[0].split())\n    x3, y3, x4, y4 = map(int, stdin.split()[1].split())\n    x5, y5, x6, y6 = map(int, stdin.split()[2].split())\n\n    if (x1 <= x3 <= x2 <= x4 and y1 <= y3 <= y2 <= y4) or (x1 <= x5 <= x2 <= x6 and y1 <= y5 <= y2 <= y6):\n        return \"NO\"\n    elif (x1 < x3 < x2 or x1 < x4 < x2) and (y1 < y3 < y2 or y1 < y4 < y2):\n        return \"YES\"\n    elif (x1 < x5 < x2 or x1 < x6 < x2) and (y1 < y5 < y2 or y1 < y6 < y2):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(point: tuple, rect: tuple) -> bool:\n        x, y = point\n        x1, y1, x2, y2 = rect\n        return x1 <= x <= x2 and y1 <= y <= y2\n\n    def is_outside(point: tuple, rects: list) -> bool:\n        return all(not is_inside(point, rect) for rect in rects)\n\n    white, black1, black2 = (tuple(map(int, line.split())) for line in stdin.split('\\n'))\n\n    # Check if some point is not inside white and outside both blacks\n    for x in range(white[0] + 1, white[2]):\n        for y in range(white[1] + 1, white[3]):\n            if is_outside((x, y), [black1, black2]):\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    coordinates = [int(x) for x in stdin.split()]\n    x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, x_5, y_5, x_6, y_6 = coordinates\n    \n    # Check if any point of the white sheet is visible after placing the two black sheets\n    if x_1 > x_3 and x_1 < x_4 and y_1 > y_3 and y_1 < y_4:\n        return \"YES\"\n    if x_1 > x_5 and x_1 < x_6 and y_1 > y_5 and y_1 < y_6:\n        return \"YES\"\n    if x_2 > x_3 and x_2 < x_4 and y_2 > y_3 and y_2 < y_4:\n        return \"YES\"\n    if x_2 > x_5 and x_2 < x_6 and y_2 > y_5 and y_2 < y_6:\n        return \"YES\"\n    \n    # Check if any point of the white sheet is visible after placing the two black sheets\n    for x in range(x_1, x_2+1):\n        for y in range(y_1, y_2+1):\n            if x > x_3 and x < x_4 and y > y_3 and y < y_4:\n                continue\n            if x > x_5 and x < x_6 and y > y_5 and y < y_6:\n                continue\n            return \"YES\"\n    \n    return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[0].split())\n    x3, y3, x4, y4 = map(int, stdin.split()[1].split())\n    x5, y5, x6, y6 = map(int, stdin.split()[2].split())\n\n    # Check if the white sheet is completely covered by the black sheets\n    if (x3 <= x1 and x2 <= x4) or (x5 <= x1 and x2 <= x6):\n        if (y3 <= y1 and y2 <= y4) or (y5 <= y1 and y2 <= y6):\n            return \"NO\"\n\n    # Check if some part of the white sheet is visible\n    if x1 < x3:\n        if y1 < y3:\n            return \"YES\"\n        elif y4 < y2:\n            return \"YES\"\n        else:\n            for y in range(y3, y4):\n                if x1 <= x3 and x2 <= x4:\n                    return \"YES\"\n            return \"NO\"\n    elif x6 < x1:\n        if y1 < y5:\n            return \"YES\"\n        elif y6 < y2:\n            return \"YES\"\n        else:\n            for y in range(y5, y6):\n                if x1 <= x5 and x2 <= x6:\n                    return \"YES\"\n            return \"NO\"\n    else:\n        if y1 < y3 and y2 > y4:\n            return \"YES\"\n        elif y1 > y3 and y2 < y4:\n            return \"YES\"\n        elif y5 < y1 and y6 > y2:\n            return \"YES\"\n        elif y5 > y1 and y6 < y2:\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    x3, y3, x4, y4 = map(int, stdin.readline().split())\n    x5, y5, x6, y6 = map(int, stdin.readline().split())\n\n    # Check if the white sheet can be seen\n    if (x1 <= x3 <= x2 <= x4 or x1 <= x5 <= x2 <= x6 or\n        y1 <= y3 <= y2 <= y4 or y1 <= y5 <= y2 <= y6):\n        return \"YES\"\n\n    # Check if there is a point not inside the white sheet and outside of both black sheets\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            if not (x3 <= x <= x4 and y3 <= y <= y4) and not (x5 <= x <= x6 and y5 <= y <= y6):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 4005,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    x3, y3, x4, y4 = map(int, stdin.readline().split())\n    x5, y5, x6, y6 = map(int, stdin.readline().split())\n\n    white_sheet = set()\n    black_sheet1 = set()\n    black_sheet2 = set()\n\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            white_sheet.add((x, y))\n\n    for x in range(x3, x4 + 1):\n        for y in range(y3, y4 + 1):\n            black_sheet1.add((x, y))\n\n    for x in range(x5, x6 + 1):\n        for y in range(y5, y6 + 1):\n            black_sheet2.add((x, y))\n\n    for point in white_sheet:\n        if point not in black_sheet1 and point not in black_sheet2:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    reachable = set()\n\n    def f(x):\n        while x % 10 == 0:\n            x //= 10\n        return x + 1\n\n    reachable.add(n)\n    for _ in range(10):\n        n = f(n)\n        reachable.add(n)\n\n    return str(len(reachable))"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    reachable_numbers = set([n])\n    \n    def f(x: int) -> int:\n        while x % 10 == 0:\n            x //= 10\n        return x + 1\n\n    for i in range(n + 1, 10**9 + 1):\n        reachable_numbers.add(i)\n        candidate = i\n        while candidate not in reachable_numbers:\n            candidate = f(candidate)\n        if candidate == i:\n            continue\n        while candidate != i:\n            reachable_numbers.add(candidate)\n            candidate = f(candidate)\n\n    return str(len(reachable_numbers) - 1)"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def f(x: int) -> int:\n        while x % 10 == 0:\n            x //= 10\n        return x\n\n    n = int(stdin)\n    reachable_numbers = {n}\n    current_number = n\n    while True:\n        current_number = f(current_number + 1)\n        if current_number in reachable_numbers:\n            break\n        reachable_numbers.add(current_number)\n\n    return str(len(reachable_numbers) - 1)\n"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    count = 0\n    for i in range(1, n+1):\n        x = i\n        while True:\n            x += 1\n            if x % 10 == 0:\n                x //= 10\n            else:\n                break\n        if x == n:\n            count += 1\n    return str(count)"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    reachable = set()\n    stack = [(n, 0)]\n\n    while stack:\n        x, depth = stack.pop()\n        reachable.add(x)\n        fx = x + 1\n        while fx % 10 == 0:\n            fx //= 10\n        if fx not in reachable:\n            stack.append((fx, depth + 1))\n\n    return str(len(reachable) - 1)"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n\n    def next_number(x: int) -> int:\n        x += 1\n        while x % 10 == 0:\n            x //= 10\n        return x\n\n    visited = set()\n    queue = [n]\n\n    while queue:\n        x = queue.pop(0)\n        if x not in visited:\n            count += 1\n            visited.add(x)\n            y = next_number(x)\n            if x != y:\n                queue.append(y)\n\n    return str(count - 1)  # Exclude the starting number n\n"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n\n    while n <= 1000000000:\n        if n % 10 == 0:\n            n += 1\n            while n % 10 == 0:\n                n //= 10\n        else:\n            n += 1\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    reachable = set()\n\n    for i in range(1, 10):\n        x = n + i\n        while x % 10 == 0:\n            x //= 10\n        reachable.add(x)\n\n    return str(len(reachable))\n"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    reachable = set()\n\n    def f(x: int) -> int:\n        while x % 10 == 0:\n            x //= 10\n        return x\n\n    def is_reachable(x: int, y: int) -> bool:\n        while x != y:\n            if x < y:\n                x = f(x + 1)\n            else:\n                y = f(y + 1)\n        return True\n\n    for i in range(1, n + 1):\n        reachable.add(i)\n        for j in range(1, i):\n            if is_reachable(j, i):\n                reachable.add(j)\n\n    return str(len(reachable))"
    },
    {
        "number": 4006,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n\n    def f(x):\n        while x % 10 == 0:\n            x //= 10\n        return x + 1\n\n    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current = f(current)\n\n    return str(len(reachable) - 1)"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    f = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def find_cycle(start):\n        cycle = [start]\n        while True:\n            if cycle[-1] == start:\n                break\n            cycle.append(f[cycle[-1] - 1])\n        return cycle\n\n    def fill_cycle(cycle):\n        n = len(cycle)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if cycle[i] in f and cycle[i] != cycle[j]:\n                    f[cycle[i] - 1] = cycle[j]\n                if cycle[j] in f and cycle[j] != cycle[i]:\n                    f[cycle[j] - 1] = cycle[i]\n\n    cycles = []\n    for i in range(n):\n        if f[i] == 0:\n            cycle = find_cycle(i + 1)\n            cycles.append(cycle)\n\n    for cycle in cycles:\n        fill_cycle(cycle)\n\n    return \" \".join(map(str, [n * (x - 1) if x != 0 else n * (y - 1) for x, y in zip(f, [i + 1 for i in range(n)]) if x != i + 1]))"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    for i in range(n):\n        if f[i] == 0:\n            for j in range(n):\n                if j != i and f[j] != j + 1 and f[j] != 0:\n                    f[i] = j + 1\n                    break\n\n    return ' '.join(str(x) for x in f)"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(i, friend_list):\n        visited = [False] * n\n        cycle = [0] * n\n        for j in range(n):\n            if not visited[j]:\n                current = j\n                k = 0\n                while not visited[current]:\n                    visited[current] = True\n                    cycle[k] = current\n                    k += 1\n                    current = friend_list[current]\n                if current == j:\n                    return cycle[k - 1::-1] + cycle[:k - 1]\n        return []\n\n    def fill_cycle(cycle, friend_list):\n        for i in range(len(cycle) // 2):\n            f1, f2 = cycle[i], cycle[-i - 1]\n            friend_list[f1] = f2\n            friend_list[f2] = f1\n\n    def assign_unknown_values(friend_list):\n        for i in range(n):\n            if friend_list[i] == 0:\n                for j in range(n):\n                    if j not in friend_list and j != i:\n                        friend_list[i] = j\n                        break\n\n    n = int(stdin.readline().strip())\n    friend_list = list(map(int, stdin.readline().strip().split()))\n\n    assign_unknown_values(friend_list)\n\n    cycle = find_cycle(0, friend_list)\n    while cycle:\n        fill_cycle(cycle, friend_list)\n        cycle = find_cycle(0, friend_list)\n\n    return \" \".join(map(str, friend_list)) + \"\\n\""
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arr):\n        for i in range(len(arr)):\n            if arr[i] != 0 and arr[i] != i + 1:\n                return False\n        return True\n\n    def find_cycle(start, friends):\n        cycle = [start]\n        while friends[start] not in cycle:\n            start = friends[start]\n            cycle.append(start)\n        return cycle\n\n    def find_cycle_start(cycle):\n        for i in range(1, len(cycle)):\n            if cycle[i] < cycle[i - 1]:\n                return i\n        return 0\n\n    def find_new_start(cycle, start_index):\n        new_start = cycle[start_index - 1]\n        next_friend = cycle[start_index]\n        if next_friend != new_start:\n            for i in range(start_index + 1, len(cycle)):\n                if cycle[i] == new_start:\n                    cycle.insert(i + 1, next_friend)\n                    break\n        return new_start\n\n    def solve(friends):\n        for i in range(len(friends)):\n            if friends[i] == 0:\n                for j in range(len(friends)):\n                    if friends[j] == i + 1:\n                        friends[i] = j + 1\n                        friends[j] = i + 1\n                        break\n\n        if is_valid(friends):\n            return friends\n\n        for i in range(len(friends)):\n            if friends[i] == 0:\n                for j in range(len(friends)):\n                    if friends[j] == 0 and friends[j] != i + 1:\n                        friends[i] = j + 1\n                        friends[j] = i + 1\n                        break\n\n        if is_valid(friends):\n            return friends\n\n        cycle = find_cycle(0, friends)\n        start_index = find_cycle_start(cycle)\n        new_start = find_new_start(cycle, start_index)\n\n        for i in range(len(friends)):\n            if friends[i] == 0:\n                friends[i] = new_start\n\n        return friends\n\n    n, friends = map(int, stdin.split())\n    friends = list(map(int, friends.split()))\n\n    result = solve(friends)\n\n    return \" \".join(map(str, result)) "
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(u, graph):\n        visited[u] = True\n        parent[u] = -1\n        for v in range(len(graph)):\n            if not visited[v] and graph[u][v] == 1:\n                parent[v] = u\n                if find_cycle(v, graph):\n                    return True\n        return False\n\n    def dfs(u, graph, stack):\n        visited[u] = True\n        for v in range(len(graph)):\n            if not visited[v] and graph[u][v] == 1:\n                parent[v] = u\n                dfs(v, graph, stack)\n        stack.append(u)\n\n    def topological_sort(graph, stack):\n        visited = [False] * len(graph)\n        for v in range(len(graph)):\n            if not visited[v]:\n                dfs(v, graph, stack)\n\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    graph = [[0] * n for _ in range(n)]\n    for i in range(n):\n        if f[i] != 0:\n            graph[i][f[i] - 1] = 1\n\n    stack = []\n    visited = [False] * n\n    for v in range(n):\n        if not visited[v]:\n            cycle = find_cycle(v, graph)\n            if cycle:\n                return \"IMPOSSIBLE\"\n\n    topological_sort(graph, stack)\n\n    for i in range(n):\n        if f[i] == 0:\n            f[i] = stack.pop() + 1\n\n    return ' '.join(map(str, f))"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph):\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                cycle = set()\n                while i not in cycle:\n                    cycle.add(i)\n                    i = graph[i]\n                return cycle\n        return set()\n\n    def dfs(start, graph, visited, ans):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, graph, visited, ans)\n        ans.append(start)\n\n    def topological_sort(graph):\n        visited = [False] * n\n        ans = []\n        for i in range(n):\n            if not visited[i]:\n                dfs(i, graph, visited, ans)\n        return ans[::-1]\n\n    n = int(stdin.readline().strip())\n    f = list(map(int, stdin.readline().strip().split()))\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        if f[i] != 0:\n            graph[i].append(f[i] - 1)\n            graph[f[i] - 1].append(i)\n\n    cycle = find_cycle(graph)\n    if len(cycle) == 0:\n        f = topological_sort(graph)\n    else:\n        f = list(cycle)\n        for i in range(n):\n            if i not in cycle:\n                f.append(i)\n\n    return \" \".join(map(str, [n * (x + 1) for x in f])) + \"\\n\""
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    f_new = [0] * n\n    for i in range(n):\n        if f[i] == 0:\n            for j in range(1, n + 1):\n                if j not in f and j != i:\n                    f[i] = j\n                    break\n\n    for i in range(n):\n        if f[i] == 0:\n            for j in range(1, n + 1):\n                if j not in f and j != i:\n                    f[i] = j\n                    break\n\n    for i in range(n):\n        f_new[i] = f[i]\n\n    return ' '.join(str(x) for x in f_new)"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start):\n        cycle = set()\n        visited = set()\n        def dfs(vertex):\n            if vertex in visited:\n                return False\n            visited.add(vertex)\n            cycle.add(vertex)\n            for neighbor in graph[vertex]:\n                if neighbor in visited or dfs(neighbor):\n                    return True\n            cycle.remove(vertex)\n            return False\n        return dfs(start), cycle\n    \n    def build_graph(f):\n        graph = {i: set() for i in range(1, n + 1)}\n        for i in range(1, n + 1):\n            if f[i] != 0:\n                graph[f[i]].add(i)\n        return graph\n    \n    def update_f(f, cycle):\n        for i in cycle:\n            f[i] = next(iter(cycle - {i}))\n        return f\n    \n    def find_ans(f):\n        ans = [0] * n\n        for i in range(1, n + 1):\n            if f[i] == 0:\n                for j in range(1, n + 1):\n                    if j not in f and j != i:\n                        f[i] = j\n                        break\n            ans[i - 1] = f[i]\n        return ans\n    \n    n, f = map(int, stdin.split())\n    f = list(map(int, f))\n    \n    graph = build_graph(f)\n    has_cycle, cycle = find_cycle(graph, 1)\n    \n    if has_cycle:\n        f = update_f(f, cycle)\n        ans = find_ans(f)\n    else:\n        ans = f\n    \n    return ' '.join(map(str, ans)) "
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    f = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(n):\n        if f[i] == 0:\n            for j in range(n):\n                if j != i and f[j] == 0:\n                    f[i] = j + 1\n                    f[j] = i + 1\n                    break\n\n    return \" \".join(map(str, [i + 1 if f[i] == 0 else f[i] for i in range(n)]))"
    },
    {
        "number": 4007,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i, f):\n        if f[i] != 0:\n            return f[i]\n        for j in range(1, n + 1):\n            if f[j] == 0 or j == i:\n                continue\n            f[j] = j\n            if dfs(f[j], f) == j:\n                return j\n        return 0\n\n    n = int(stdin.split('\\n')[0])\n    f = [0] * (n + 1)\n    for i, x in enumerate(map(int, stdin.split('\\n')[1].split())):\n        if x == 0:\n            continue\n        f[i + 1] = x\n\n    for i in range(1, n + 1):\n        if f[i] == 0:\n            dfs(i, f)\n\n    return ' '.join(map(str, [f[i] for i in range(1, n + 1)]))"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    \n    if k < n:\n        return \"NO\"\n    \n    colors = [0] * k\n    color_map = {}\n    for i in range(n):\n        possible_colors = set(range(1, k + 1))\n        for j in range(i):\n            if a[i] == a[j]:\n                possible_colors.discard(color_map[a[j]])\n        if not possible_colors:\n            return \"NO\"\n        color = min(possible_colors)\n        color_map[a[i]] = color\n        colors[color - 1] += 1\n    \n    output = \"YES\\n\"\n    for i in range(n):\n        output += str(color_map[a[i]]) + \" \"\n    return output"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(coloring):\n        for i in range(1, k + 1):\n            if not any(color == i for color in coloring):\n                return False\n        for i in range(1, k + 1):\n            colors = set()\n            for j, color in enumerate(coloring):\n                if color == i:\n                    colors.add(a[j])\n            if len(colors) != len(colors):\n                return False\n        return True\n\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    a.sort()\n\n    if k < n:\n        return \"NO\"\n\n    coloring = [0] * n\n    for i in range(n):\n        coloring[i] = a[i] % k + 1\n\n    if is_valid(coloring):\n        return \"YES\" + \"\\n\" + \" \".join(map(str, coloring))\n    else:\n        return \"NO\""
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(colors):\n        for i in range(1, k + 1):\n            if not any(c == i for c in colors):\n                return False\n        for i in range(n):\n            if colors[i] == colors[i - 1] and a[i] == a[i - 1]:\n                return False\n        return True\n\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n > k * (n // k):\n        return \"NO\"\n\n    colors = [i // (n // k) + 1 for i in range(n)]\n    if is_valid(colors):\n        return \"YES \" + \" \".join(map(str, colors))\n\n    for i in range(n):\n        for c in range(1, k + 1):\n            colors[i] = c\n            if is_valid(colors):\n                return \"YES \" + \" \".join(map(str, colors))\n\n    return \"NO\""
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    # check if coloring is possible\n    freq = [0] * (k + 1)\n    for i in range(n):\n        freq[a[i]] += 1\n\n    if any(freq[i] < k for i in range(1, k + 1)):\n        return \"NO\"\n\n    # create coloring\n    coloring = [0] * n\n    for i in range(n):\n        for j in range(1, k + 1):\n            if freq[j] > 0:\n                coloring[i] = j\n                freq[j] -= 1\n                break\n\n    # print coloring\n    return \"YES\\n\" + \" \".join(map(str, coloring))"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check_conditions(colors: List[int], n: int, k: int) -> bool:\n        for i in range(1, k + 1):\n            if not any(c == i for c in colors):\n                return False\n        for i in range(1, k + 1):\n            if not any(colors[j] == i for j in range(n) if a[j] == a[j - 1]):\n                return False\n        return True\n\n    def color_array(colors: List[int], n: int, k: int, index: int) -> Optional[List[int]]:\n        if index == n:\n            return colors\n        for i in range(1, k + 1):\n            colors[index] = i\n            if check_conditions(colors, n, k):\n                result = color_array(colors, n, k, index + 1)\n                if result is not None:\n                    return result\n        return None\n\n    lines = stdin.splitlines()\n    n, k = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n\n    if n < k:\n        return \"NO\"\n\n    colors = [0] * n\n    result = color_array(colors, n, k, 0)\n\n    if result is None:\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    colors = [0] * k\n    used_colors = [False] * k\n    coloring = [0] * n\n\n    for i in range(n):\n        for j in range(k):\n            if not used_colors[j]:\n                colors[j] = a[i]\n                used_colors[j] = True\n                coloring[i] = j + 1\n                break\n        else:\n            return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, coloring))\n"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    colors = [[] for _ in range(k)]\n\n    for i in range(n):\n        colors[a[i] % k].append(i)\n\n    coloring = [0] * n\n\n    for i in range(k):\n        if not colors[i]:\n            return \"NO\"\n\n        color = i + 1\n        for j in colors[i]:\n            coloring[j] = color\n\n    return \"YES\\n\" + \" \".join(map(str, coloring))\n"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_colors(start, color_map, colors, used_colors):\n        if start == n:\n            return True\n        for i in range(1, k + 1):\n            if i not in used_colors:\n                color_map[start] = i\n                used_colors.add(i)\n                if find_colors(start + 1, color_map, colors, used_colors):\n                    return True\n                used_colors.remove(i)\n                color_map[start] = 0\n        return False\n\n    n, k = map(int, stdin.readline().strip().split())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    a.sort()\n    color_map = [0] * n\n    used_colors = set()\n\n    if n > k or a[0] > k:\n        return \"NO\"\n\n    if find_colors(0, color_map, a, used_colors):\n        return \"YES \" + \" \".join(map(str, color_map))\n    else:\n        return \"NO\""
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    \n    coloring = {}\n    for i in range(1, k + 1):\n        coloring[i] = []\n    \n    for i in range(n):\n        for j in range(1, k + 1):\n            if a[i] not in coloring[j]:\n                coloring[j].append(a[i])\n                break\n        else:\n            return \"NO\"\n    \n    for i in range(1, k + 1):\n        if not coloring[i]:\n            return \"NO\"\n    \n    result = [0] * n\n    for i in range(n):\n        for j in range(1, k + 1):\n            if a[i] in coloring[j]:\n                result[i] = j\n                coloring[j].remove(a[i])\n                break\n    \n    return \"YES\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 4008,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    # Check if it's possible to color the array with k colors\n    colors_count = len(set(a))\n    if colors_count > k:\n        return \"NO\"\n\n    # Create a coloring for the array\n    coloring = [0] * n\n    colors = [i for i in range(1, k + 1)]\n\n    for i in range(n):\n        for color in colors:\n            if color not in coloring[:i] and a[i] != color:\n                coloring[i] = color\n                break\n\n    # Check if the coloring satisfies the conditions\n    colors_used = set(coloring)\n    if len(colors_used) != k or any(coloring.count(color) == 1 for color in colors_used):\n        return \"NO\"\n\n    return \"YES\" + \" \" + \" \".join(map(str, coloring))"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[0].split())\n    number = stdin.split()[1]\n    remainder = int(number[-y:], 2)\n    desired_remainder = 10 ** y\n\n    if remainder == desired_remainder:\n        return \"0\"\n\n    operations = 0\n    for i in range(y, x):\n        if int(number[i]) == 0:\n            operations += 1\n        else:\n            operations += 2\n\n    return str(operations)"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input()))\n\n    def get_remainder(num: List[int]) -> int:\n        return int(\"\".join(map(str, num))) % (10 ** x)\n\n    def perform_operation(num: List[int], pos: int) -> None:\n        num[pos] = (num[pos] + 1) % 2\n\n    def binary_search(num: List[int], target: int) -> int:\n        left, right = 0, n - x\n        while left < right:\n            mid = (left + right) // 2\n            perform_operation(num, mid)\n            if get_remainder(num) <= target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    return str(binary_search(number, 10 ** y))"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input()))\n    modulo = 10 ** x\n\n    def get_remainder(num: List[int]) -> int:\n        remainder = 0\n        for i in range(x):\n            remainder = (remainder * 2 + num[i]) % modulo\n        return remainder\n\n    def set_digit(num: List[int], i: int) -> None:\n        num[i] ^= 1\n\n    def minimize_operations(num: List[int]) -> int:\n        operations = 0\n        for i in range(y):\n            if num[i] == 0:\n                set_digit(num, i)\n                operations += 1\n        return operations\n\n    remainder = get_remainder(number)\n    if remainder == 10 ** y:\n        return str(minimize_operations(number))\n\n    for i in range(y, x):\n        if number[i] == 0:\n            set_digit(number, i)\n            new_remainder = get_remainder(number)\n            if new_remainder == 10 ** y:\n                return str(minimize_operations(number) + i - y + 1)\n            if new_remainder % 2 == 1:\n                set_digit(number, i)\n\n    return \"Impossible\"\n"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    num = list(map(int, input()))\n\n    def count_trailing_zeros(num: List[int]) -> int:\n        count = 0\n        for digit in reversed(num):\n            if digit == 0:\n                count += 1\n            else:\n                break\n        return count\n\n    def min_operations(num: List[int], x: int, y: int) -> int:\n        trailing_zeros = count_trailing_zeros(num)\n        if trailing_zeros >= y:\n            return 0\n        else:\n            return (x - y - trailing_zeros) // x\n\n    return str(min_operations(num, x, y))"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input()))\n\n    def get_remainder(num: list, x: int, y: int) -> int:\n        remainder = 0\n        for i in range(len(num)):\n            if i >= y:\n                break\n            remainder = (remainder * 10 + num[i]) % (10 ** x)\n        return remainder\n\n    def get_min_operations(num: list, x: int, y: int) -> int:\n        remainder = get_remainder(num, x, y)\n        if remainder == 10 ** y:\n            return 0\n\n        for i in range(len(num) - 1, -1, -1):\n            if i < y:\n                break\n            if num[i] == 0:\n                num[i] = 1\n                remainder = (remainder * 10 + 1) % (10 ** x)\n                if remainder == 10 ** y:\n                    return len(num) - i - 1\n            else:\n                num[i] = 0\n                remainder = (remainder - 1) % (10 ** x)\n                if remainder == 10 ** y:\n                    return len(num) - i - 1\n        return len(num)\n\n    return str(get_min_operations(number, x, y))"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input()))\n    \n    def get_remainder(num: list) -> int:\n        return int(\"\".join(map(str, num)), 2) % (10 ** x)\n    \n    def find_min_operations(num: list) -> int:\n        min_operations = float('inf')\n        for i in range(len(num)):\n            if num[i] == 0:\n                num[i] = 1\n                operations = find_min_operations(num)\n                if operations != float('inf'):\n                    min_operations = min(min_operations, operations + 1)\n                num[i] = 0\n        return min_operations\n    \n    remainder = get_remainder(number)\n    if remainder == 10 ** y:\n        return 0\n    \n    number.reverse()\n    min_operations = find_min_operations(number)\n    \n    return str(min_operations)"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[0:3])\n    number = list(stdin.split()[1])\n\n    # Calculate the target number\n    target = 10 ** y\n\n    # Calculate the mask for the last x digits\n    mask = (1 << x) - 1\n\n    # Calculate the current number modulo 2^x\n    current_mod = int(\"\".join(number[-x:]), 2)\n\n    # Calculate the difference between the target and the current number modulo 2^x\n    diff = target - current_mod\n\n    # If the difference is 0, we don't need to perform any operations\n    if diff == 0:\n        return 0\n\n    # Calculate the position of the least significant bit of the difference\n    lsb = diff & -diff\n\n    # Calculate the position of the corresponding bit in the number\n    pos = x - (lsb.bit_length() - 1)\n\n    # If the position is outside the number, we need to perform x operations\n    if pos < 1:\n        return x\n\n    # If the position is inside the number, we need to perform at most x - pos + 1 operations\n    return x - pos + 1"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, list(input())))\n\n    for i in range(n - x):\n        if number[i] == 1:\n            number[i] = 0\n            break\n\n    return \"\".join(map(str, number))\n\nn, x, y = map(int, input().split())\nnumber = list(map(int, list(input())))\n\nmin_operations = 0\nfor i in range(n - x):\n    if number[i] == 1:\n        number[i] = 0\n        min_operations += 1\n        break\n\nprint(min_operations) "
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input()))\n\n    def get_remainder(num: List[int]) -> int:\n        remainder = 0\n        for i in range(len(num)):\n            remainder = (remainder * 2 + num[i]) % (10 ** x)\n        return remainder\n\n    def change_digit(num: List[int], index: int) -> List[int]:\n        num[index] = 1 - num[index]\n        for i in range(index + 1, len(num)):\n            if num[i] == num[i - 1]:\n                num[i] = 1 - num[i]\n            else:\n                break\n        return num\n\n    min_operations = float(\"inf\")\n    for i in range(n):\n        if number[i] == 1 - (y // (10 ** (x - i)) % 2):\n            new_number = change_digit(number.copy(), i)\n            operations = 1 + i\n            if get_remainder(new_number) == 10 ** y:\n                min_operations = min(min_operations, operations)\n\n    return min_operations if min_operations != float(\"inf\") else -1\n"
    },
    {
        "number": 4009,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    number = list(map(int, input().strip()))\n\n    # Check if the last y digits are all zeros\n    if all(digit == 0 for digit in number[-y:]):\n        return \"0\"\n\n    # Calculate the number of operations needed\n    operations = 0\n    for digit in number[-y:]:\n        if digit == 0:\n            operations += 1\n        else:\n            break\n\n    return str(operations)\n"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def has_palindrome_subsequence(a: list, n: int) -> bool:\n        for i in range(n - 2):\n            for j in range(i + 2, n):\n                if is_palindrome(str(a[i:j + 1])):\n                    return True\n        return False\n\n    test_cases = int(stdin.split('\\n')[0])\n    stdin = stdin.split('\\n')[1:]\n\n    result = []\n    for i in range(test_cases):\n        n = int(stdin[i * 2])\n        a = [int(x) for x in stdin[i * 2 + 1].split()]\n        if has_palindrome_subsequence(a, n):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr: list) -> bool:\n        return arr == arr[::-1]\n\n    def subsequence_palindrome(a: list, n: int) -> bool:\n        for i in range(n - 2):\n            for j in range(i + 3, n + 1):\n                if is_palindrome(a[i:j]):\n                    return True\n        return False\n\n    test_cases = stdin.split('\\n')\n    t = int(test_cases[0])\n    i = 1\n    result = []\n\n    while i < len(test_cases):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i + 1].split()))\n        if subsequence_palindrome(a, n):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n        i += 2\n\n    return '\\n'.join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(seq: List[int]) -> bool:\n        for i in range(len(seq) // 2):\n            if seq[i] != seq[-i - 1]:\n                return False\n        return True\n\n    def subsequence_palindrome(a: List[int]) -> bool:\n        for length in range(3, len(a) + 1):\n            for subseq in itertools.combinations(a, length):\n                if is_palindrome(list(subseq)):\n                    return True\n        return False\n\n    t = int(stdin.readline().strip())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        if subsequence_palindrome(a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr: list) -> bool:\n        return arr == arr[::-1]\n\n    def subsequence_palindrome(arr: list) -> bool:\n        for i in range(len(arr) - 2):\n            for j in range(i + 3, len(arr) + 1):\n                subseq = arr[i:j]\n                if is_palindrome(subseq):\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    i = 1\n    result = []\n\n    while i < len(lines):\n        n = int(lines[i])\n        arr = [int(x) for x in lines[i + 1].split()]\n        if subsequence_palindrome(arr):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n        i += 2\n\n    return '\\n'.join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr: List[int]) -> bool:\n        return arr == arr[::-1]\n\n    def is_subsequence(a: List[int], b: List[int]) -> bool:\n        i = 0\n        for x in a:\n            if x == b[i]:\n                i += 1\n            if i == len(b):\n                return True\n        return False\n\n    t = int(stdin.split('\\n', 1)[0])\n    it = 1\n    while it <= t:\n        n = int(stdin.split('\\n', 2)[1])\n        a = list(map(int, stdin.split('\\n', 2)[2].split()))\n\n        for i in range(n - 2):\n            for j in range(i + 3, n - 1):\n                subseq = a[i:j + 1]\n                for k in range(j + 2, n):\n                    if is_subsequence(subseq, a[j:k + 1]):\n                        if is_palindrome(a[i:j + 1]):\n                            print(\"YES\")\n                            it += 1\n                            break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n        else:\n            print(\"NO\")\n            it += 1\n\n        stdin = stdin.split('\\n', 2)[-1]"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(seq):\n        return seq == seq[::-1]\n\n    def has_palindrome_subseq(a, n):\n        for i in range(n):\n            for j in range(i + 2, n):\n                if is_palindrome(a[i:j + 1]):\n                    return True\n        return False\n\n    lines = stdin.splitlines()\n    t = int(lines[0])\n    i = 1\n    result = []\n\n    while i < len(lines):\n        n = int(lines[i])\n        a = list(map(int, lines[i + 1].split()))\n        if has_palindrome_subseq(a, n):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n        i += 2\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr):\n        n = len(arr)\n        for i in range(n // 2):\n            if arr[i] != arr[n - i - 1]:\n                return False\n        return True\n\n    def find_subsequences(arr, start, subseq, n, result):\n        if len(subseq) >= 3 and is_palindrome(subseq):\n            result.add(True)\n\n        for i in range(start, n):\n            find_subsequences(arr, i + 1, subseq + [arr[i]], n, result)\n\n    t = int(stdin.readline().strip())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        subsequences = set()\n        find_subsequences(a, 0, [], n, subsequences)\n        result.append(\"YES\" if True in subsequences else \"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr: list) -> bool:\n        return arr == arr[::-1]\n\n    def has_palindrome_subsequence(arr: list, n: int) -> bool:\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if is_palindrome(arr[i:j + 1]):\n                    return True\n        return False\n\n    test_cases = int(stdin.splitlines()[0])\n    stdin = stdin.splitlines()[1:]\n\n    result = []\n    for i in range(test_cases):\n        n = int(stdin[i * 2])\n        arr = list(map(int, stdin[i * 2 + 1].split()))\n\n        if has_palindrome_subsequence(arr, n):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(arr: list) -> bool:\n        for i in range(len(arr) // 2):\n            if arr[i] != arr[-(i + 1)]:\n                return False\n        return True\n\n    def check_subsequence(arr: list, n: int) -> bool:\n        for i in range(len(arr) - n + 1):\n            if is_palindrome(arr[i:i + n]):\n                return True\n        return False\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    while t > 0:\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n\n        if n < 3:\n            result.append(\"NO\")\n        else:\n            for i in range(3, n + 1):\n                if check_subsequence(a, i):\n                    result.append(\"YES\")\n                    break\n            else:\n                result.append(\"NO\")\n\n        t -= 1\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4010,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(seq: List[int]) -> bool:\n        return seq == seq[::-1]\n\n    def has_palindrome_subseq(seq: List[int]) -> bool:\n        for i in range(len(seq) - 2):\n            for j in range(i + 3, len(seq) + 1):\n                if is_palindrome(seq[i:j]):\n                    return True\n        return False\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if has_palindrome_subseq(a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    f = list(map(int, stdin.readline().strip().split()))\n\n    def is_valid(segment: str) -> bool:\n        for i in range(1, len(segment)):\n            if segment[i] < segment[0]:\n                return False\n        return True\n\n    def get_max_segment(a: str) -> str:\n        max_segment = a[0]\n        for i in range(1, len(a)):\n            if a[i] >= a[0]:\n                max_segment += a[i]\n            else:\n                break\n        return max_segment\n\n    max_segment = get_max_segment(a)\n    if is_valid(max_segment):\n        return max_segment\n\n    for i in range(1, len(a) - 1):\n        segment = a[:i] + a[i + 1:]\n        max_segment = get_max_segment(segment)\n        if is_valid(max_segment):\n            return max_segment\n\n    return a\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\nprint(solution(n, a, f)) "
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    f_map = {i + 1: int(x) for i, x in enumerate(stdin.readline().strip().split())}\n\n    max_number = -1\n\n    for i in range(n):\n        for j in range(i, n):\n            segment = a[i:j + 1]\n            replaced_segment = ''.join([str(f_map[int(x)]) for x in segment])\n            new_number = a[:i] + replaced_segment + a[j + 1:]\n            max_number = max(max_number, int(new_number))\n\n    return str(max_number)"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = stdin.readline().rstrip()\n    f = [int(i) for i in stdin.readline().split()]\n\n    max_segment = a\n    max_result = int(a)\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment = a[i:j]\n            result = int(segment)\n            for digit in segment:\n                result = f[int(digit) - 1] * (result // 10) + f[int(digit) - 1] % 10\n\n            if result > max_result:\n                max_segment = segment\n                max_result = result\n\n    start = a.index(max_segment)\n    end = start + len(max_segment)\n\n    if start == 0:\n        result = str(max_result) + a[end:]\n    elif end == n:\n        result = a[:start] + str(max_result)\n    else:\n        result = a[:start] + str(max_result) + a[end:]\n\n    return str(result)"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = stdin.readline().strip()\n    f = list(map(int, stdin.readline().split()))\n\n    def segment_sum(start: int, end: int) -> int:\n        return sum(int(a[i]) for i in range(start, end))\n\n    left, right = 0, n - 1\n    while left < right:\n        if f[int(a[left]) - 1] <= f[int(a[right]) - 1]:\n            if segment_sum(left + 1, right + 1) > segment_sum(left, right):\n                left += 1\n            else:\n                right -= 1\n        else:\n            if segment_sum(left, right) > segment_sum(left + 1, right + 1):\n                right -= 1\n            else:\n                left += 1\n\n    result = list(a)\n    for i in range(left, right + 1):\n        result[i] = str(f[int(a[i]) - 1])\n\n    return \"\".join(result)\n"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    f = [int(x) for x in stdin.readline().strip().split()]\n\n    max_digit = max(f)\n    min_digit = min(f)\n\n    if max_digit == 9:\n        return a\n\n    if min_digit == 1:\n        return a.replace('1', '9')\n\n    max_num = a.replace('1', str(max_digit))\n    min_num = a.replace('1', str(min_digit))\n\n    return max(max_num, min_num)\n\ndef"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    f = list(map(int, stdin.readline().strip().split()))\n\n    # Find the maximum possible number by replacing each segment with f(x)\n    max_segment = -1\n    for i in range(n):\n        for j in range(i, n):\n            segment = a[i:j + 1]\n            if segment == ''.join([str(f[int(x) - 1]) for x in segment]):\n                max_segment = max(max_segment, int(segment))\n\n    return str(max_segment)"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = stdin.readline()[:-1]\n    f = list(map(int, stdin.readline().split()))\n\n    def get_max_segment(segment: str) -> int:\n        return int(segment) if f[int(segment[0]) - 1] <= 1 else int(str(f[int(segment[0]) - 1]) + segment[1:])\n\n    max_segment = get_max_segment(a)\n    for i in range(n - 1):\n        max_segment = max(max_segment, get_max_segment(a[i:]))\n\n    return str(max_segment)"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, f = stdin.split(\"\\n\")\n    n = int(n)\n    a = list(a)\n    f = [int(x) for x in f.split()]\n\n    def replace_segment(start: int, end: int) -> str:\n        return a[:start] + [str(f[int(x)]) for x in a[start:end]] + a[end:]\n\n    max_result = a\n    for i in range(1, n):\n        max_segment = replace_segment(0, i)\n        for j in range(i, n):\n            segment = replace_segment(i, j + 1)\n            if segment > max_segment:\n                max_segment = segment\n        if max_segment > max_result:\n            max_result = max_segment\n\n    return \"\".join(max_result) "
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip()\n    f = [int(x) for x in stdin.readline().split()]\n\n    def get_max(segment: str, f: list) -> int:\n        max_digit = max(f)\n        return int(segment.replace(str(max_digit), '9'))\n\n    max_number = get_max(a, f)\n\n    for i in range(n - 1):\n        segment = a[i:]\n        max_segment = get_max(segment, f)\n        max_number = max(max_number, max_segment)\n\n    return str(max_number)\n"
    },
    {
        "number": 4011,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a, f = map(int, stdin.split())\n    a = str(a)\n    f = [int(x) for x in f]\n    max_num = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            subsegment = a[i:j+1]\n            modified_subsegment = [str(f[int(x)-1]) for x in subsegment]\n            modified_number = int(\"\".join(modified_subsegment))\n            max_num = max(max_num, modified_number)\n\n    return max_num"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(t):\n        a, b, c = map(int, stdin.split('\\n')[i + 1].split())\n        A = a\n        B = lcm(a, b)\n        C = lcm(B, c)\n        res = 0\n        if A != a:\n            res += abs(A - a) - 1\n        if B != b:\n            res += abs(B - b) - 1\n        if C != c:\n            res += abs(C - c) - 1\n        output.append(f\"{res}\\n{A} {B} {C}\")\n    return \"\\n\".join(output)"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: int, b: int, c: int) -> bool:\n        return a > 0 and b > 0 and c > 0 and b % a == 0 and c % b == 0\n\n    def find_solution(a: int, b: int, c: int) -> tuple:\n        res = 0\n        while not is_valid(a, b, c):\n            res += 1\n            if b % a != 0:\n                b += 1 if b < c else -1\n            if c % b != 0:\n                c += 1 if c < 10000 else -1\n        return res, a, b, c\n\n    test_cases = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    results = []\n\n    for a, b, c in test_cases:\n        res, A, B, C = find_solution(a, b, c)\n        results.append(f\"{res}\\n{A} {B} {C}\")\n\n    return \"\\n\".join(results)\n"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_ops(a, b, c):\n        ops = 0\n        A, B, C = a, b, c\n\n        while C % B != 0:\n            C += 1\n            ops += 1\n        ops += B - A\n        return ops\n\n    t = int(stdin.split(\"\\n\", 1)[0])\n    test_cases = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    output = []\n\n    for a, b, c in test_cases:\n        min_ops = find_min_ops(a, b, c)\n        output.append(f\"{min_ops}\\n{a} {b} {c}\\n\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_result(a, b, c):\n        res = 0\n        A, B, C = a, b, c\n        while B % A != 0:\n            B += 1\n            res += 1\n        while C % B != 0:\n            C += 1\n            res += 1\n        return res, A, B, C\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n\n    for i in range(1, t + 1):\n        a, b, c = map(int, stdin.split('\\n')[i].split())\n        res, A, B, C = find_result(a, b, c)\n        output.append(f\"{res}\\n{A} {B} {C}\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_operations(a, b, c):\n        A, B, C = a, b, c\n        operations = 0\n\n        while A != B and B != C and C != A:\n            if A == 1 or B == 1 or C == 1:\n                break\n\n            if B % A == 0:\n                C -= A\n                operations += 1\n            else:\n                B -= A\n                operations += 1\n\n            if B == C:\n                break\n\n            if B % C == 0:\n                A -= C\n                operations += 1\n            else:\n                A -= B\n                operations += 1\n\n            if A == B:\n                break\n\n            if A % B == 0:\n                C -= B\n                operations += 1\n            else:\n                C -= A\n                operations += 1\n\n        return operations, A, B, C\n\n    test_cases = list(map(lambda x: list(map(int, x.split())), stdin.strip().split('\\n')[1:]))\n    result = []\n\n    for a, b, c in test_cases:\n        min_operations, A, B, C = find_min_operations(a, b, c)\n        result.append(f\"{min_operations}\\n{A} {B} {C}\")\n\n    return '\\n\\n'.join(result)\n"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_operations(a, b, c):\n        count = 0\n        while a != b and b != c:\n            if a == 1 or b == c:\n                break\n            if b % a == 0:\n                b //= a\n                count += 1\n            elif c % b == 0:\n                c //= b\n                count += 1\n            else:\n                break\n        return count\n\n    def find_result(a, b, c):\n        count = find_operations(a, b, c)\n        a, b, c = sorted([a, b, c])\n        return f\"{count}\\n{a} {b} {c}\"\n\n    t = int(stdin.strip().split(\"\\n\")[0])\n    test_cases = [list(map(int, line.strip().split())) for line in stdin.strip().split(\"\\n\")[1:t+1]]\n    results = [find_result(a, b, c) for a, b, c in test_cases]\n    return \"\\n\\n\".join(results)"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_lcm(a, b):\n        return a * b // find_gcd(a, b)\n\n    def count_ops(a, b, c):\n        count = 0\n        while c % b != 0:\n            c += a\n            count += 1\n        return count\n\n    t = int(stdin.strip().split('\\n')[0])\n    res = []\n    for i in range(1, t + 1):\n        a, b, c = [int(x) for x in stdin.strip().split('\\n')[i].split()]\n        A = a\n        B = find_lcm(a, b)\n        C = find_lcm(b, c)\n        res.append(f\"{count_ops(a, b, c)}\\n{A} {B} {C}\")\n    return \"\\n\".join(res)"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_operations(a, b, c):\n        A, B, C = a, b, c\n        operations = 0\n\n        # Ensure that A <= B <= C\n        if B < C:\n            B, C = C, B\n            operations += 1\n        if A > B:\n            A, B = B, A\n            operations += 1\n        if C < B:\n            C, B = B, C\n            operations += 1\n\n        # Ensure that B is divisible by A\n        while B % A != 0:\n            B += 1\n            operations += 1\n\n        # Ensure that C is divisible by B\n        while C % B != 0:\n            C += 1\n            operations += 1\n\n        return operations, A, B, C\n\n    def process_input(line):\n        a, b, c = map(int, line.split())\n        operations, A, B, C = find_operations(a, b, c)\n        return f\"{operations}\\n{A} {B} {C}\\n\"\n\n    stdin_list = stdin.split(\"\\n\")\n    t = int(stdin_list[0])\n    output = \"\"\n\n    for i in range(1, t + 1):\n        output += process_input(stdin_list[i])\n\n    return output.strip()"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_result(a, b, c):\n        res = 0\n        A, B, C = a, b, c\n        while B % A != 0:\n            B += 1\n            res += 1\n        while C % B != 0:\n            C += 1\n            res += 1\n        return res, A, B, C\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        a, b, c = map(int, stdin.readline().split())\n        res, A, B, C = find_result(a, b, c)\n        output.append(f\"{res}\\n{A} {B} {C}\\n\")\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4012,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_operations(a, b, c):\n        res = 0\n        A, B, C = a, b, c\n        while B % A != 0:\n            B += 1\n            res += 1\n        res += (A - 1) + (B - A)\n        while C % B != 0:\n            C += 1\n            res += 1\n        res += (B - 1) + (C - B)\n        return res, A, B, C\n\n    t = int(stdin.split('\\n', 1)[0])\n    inputs = stdin.split('\\n')[1:]\n    outputs = []\n\n    for a, b, c in [list(map(int, line.split())) for line in inputs]:\n        res, A, B, C = find_operations(a, b, c)\n        outputs.append(f\"{res}\\n{A} {B} {C}\\n\")\n\n    return '\\n'.join(outputs)\n"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(i) for i in stdin.split('\\n')[1].split()]\n    instability = max(a) - min(a)\n    for i in range(n):\n        new_a = a[:i] + a[i+1:]\n        new_instability = max(new_a) - min(new_a)\n        if new_instability < instability:\n            instability = new_instability\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n    for i in range(n):\n        instability_new = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        instability = min(instability, instability_new)\n\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n\n    for i in range(n):\n        instability_new = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        instability = min(instability, instability_new)\n\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n    min_instability = instability\n\n    for i in range(n):\n        instability_new = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        min_instability = min(min_instability, instability_new)\n\n    return str(min_instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = [int(x) for x in stdin.split(\"\\n\")[1].split(\" \")]\n\n    instability = max(arr) - min(arr)\n    min_instability = instability\n\n    for i in range(n):\n        new_arr = arr[:i] + arr[i+1:]\n        new_instability = max(new_arr) - min(new_arr)\n        min_instability = min(min_instability, new_instability)\n\n    return str(min_instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return str(abs(arr[1] - arr[0]))\n    else:\n        instability = arr[-1] - arr[0]\n        for i in range(1, n - 1):\n            new_instability = max(arr[-1 - i] - arr[i], arr[-1] - arr[i - 1])\n            instability = min(instability, new_instability)\n\n        return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(i) for i in stdin.split('\\n')[1].split()]\n\n    instability = max(a) - min(a)\n\n    for i in range(n):\n        instability_new = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        instability = min(instability, instability_new)\n\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n    for i in range(n):\n        instability_new = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        instability = min(instability, instability_new)\n\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    instability = max(a) - min(a)\n    for i in range(n):\n        instability_i = max(a[:i] + a[i+1:]) - min(a[:i] + a[i+1:])\n        instability = min(instability, instability_i)\n\n    return str(instability)"
    },
    {
        "number": 4013,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n\n    for i in range(n):\n        new_a = a[:i] + a[i+1:]\n        new_instability = max(new_a) - min(new_a)\n        instability = min(instability, new_instability)\n\n    return str(instability)"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_exam(exam: int, day: int) -> bool:\n        return s[exam] <= day < d[exam]\n\n    def check_preparation(exam: int, day: int) -> bool:\n        return s[exam] <= day < d[exam] - 1\n\n    n, m = map(int, stdin.split())\n    s, d, c = [0] * m, [0] * m, [0] * m\n\n    for i in range(m):\n        s[i], d[i], c[i] = map(int, input().split())\n\n    plan = [0] * n\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            if check_exam(j, i):\n                plan[i - 1] = j + 1\n            elif check_preparation(j, i):\n                plan[i - 1] = j + 1\n\n        if plan[i - 1] == 0 and i not in d:\n            plan[i - 1] = 1\n        elif plan[i - 1] == 0:\n            plan[i - 1] = -1\n\n    if -1 in plan:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, plan))"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def prepare_schedule(exams, n):\n        schedule = [0] * n\n        for exam in exams:\n            s, d, c = exam\n            for i in range(s - 1, d):\n                if schedule[i] == 0:\n                    schedule[i] = exam\n        return schedule\n\n    def pass_exams(schedule, m):\n        exam_days = sorted([(exam[1], i) for i, exam in enumerate(schedule, 1)])\n        passed_exams = [0] * m\n        current_exam = 0\n        for day, exam_id in exam_days:\n            if passed_exams[exam_id - 1] == 0:\n                passed_exams[exam_id - 1] = 1\n                current_exam += 1\n            if current_exam == m:\n                return True\n        return False\n\n    def find_schedule(exams, n, m):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    exams[i][1], exams[j][1] = exams[j][1], exams[i][1]\n                    schedule = prepare_schedule(exams, n)\n                    if pass_exams(schedule, m):\n                        return schedule\n                    exams[i][1], exams[j][1] = exams[j][1], exams[i][1]\n        return None\n\n    n, m = map(int, stdin.readline().split())\n    exams = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    schedule = find_schedule(exams, n, m)\n    if schedule:\n        return \" \".join(map(str, schedule))\n    else:\n        return \"-1\""
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def can_schedule(exams, n):\n        schedule = [0] * (n + 1)\n        for exam in exams:\n            s, d, c = exam\n            for i in range(s, d):\n                if schedule[i] == 0:\n                    schedule[i] = 1\n                else:\n                    return False\n            for i in range(d, d + c):\n                if schedule[i] == 1:\n                    schedule[i] = 2\n                else:\n                    return False\n        return True\n\n    def find_exam_day(exams, n):\n        schedule = [0] * (n + 1)\n        for i, exam in enumerate(exams):\n            s, d, c = exam\n            for j in range(s, d):\n                if schedule[j] == 0:\n                    schedule[j] = i + 1\n                    break\n            for j in range(d, d + c):\n                if schedule[j] == 0:\n                    schedule[j] = -(i + 1)\n                    break\n        return schedule\n\n    def find_exam_schedule(exams, n):\n        schedule = [0] * (n + 1)\n        for i, exam in enumerate(exams):\n            s, d, c = exam\n            for j in range(s, d):\n                if schedule[j] == 0:\n                    schedule[j] = i + 1\n                    break\n            for j in range(d, d + c):\n                if schedule[j] == 0:\n                    schedule[j] = -(i + 1)\n                    break\n        return schedule\n\n    n, m = map(int, stdin.split())\n    exams = [list(map(int, input().split())) for _ in range(m)]\n\n    if not can_schedule(exams, n):\n        return \"-1\"\n\n    exam_day_schedule = find_exam_day(exams, n)\n    exam_schedule = find_exam_schedule(exams, n)\n\n    result = []\n    for i in range(1, n + 1):\n        if exam_day_schedule[i] > 0:\n            result.append(exam_day_schedule[i])\n        elif exam_schedule[i] != 0:\n            result.append(abs(exam_schedule[i]))\n        else:\n            result.append(0)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    exams = []\n    for _ in range(m):\n        s, d, c = map(int, input().split())\n        exams.append((s, d, c))\n\n    # Create a dictionary to store the number of days Petya prepares for each exam\n    exam_preparation = {i + 1: 0 for i in range(m)}\n\n    # Sort exams by the day of the exam (d_i)\n    exams.sort(key=lambda x: x[1])\n\n    # Initialize the schedule\n    schedule = [0] * n\n\n    # Iterate through the exams\n    for i in range(m):\n        s, d, c = exams[i]\n\n        # Calculate the number of days Petya prepares for the exam\n        days_to_prepare = min(c, d - s - 1)\n\n        # Update the exam_preparation dictionary\n        exam_preparation[i + 1] = days_to_prepare\n\n        # Update the schedule\n        for j in range(s, s + days_to_prepare):\n            schedule[j] = i + 1\n\n    # Check if Petya can pass all exams\n    for i in range(m):\n        s, d, c = exams[i]\n\n        # Check if Petya has enough time to prepare for the exam\n        if exam_preparation[i + 1] < c:\n            return \"-1\"\n\n        # Check if Petya has enough time to pass the exam\n        if schedule[d - 1] != 0:\n            return \"-1\"\n\n    # Convert the schedule to the required format\n    for i in range(n):\n        if schedule[i] == 0:\n            schedule[i] = 1\n        else:\n            schedule[i] = (m + 1)\n\n    return \" \".join(map(str, schedule))"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n, m, exams, schedule):\n        for i in range(m):\n            s, d, c = exams[i]\n            if not (schedule[s - 1] == schedule[d - 2] == i + 1):\n                return False\n        return True\n\n    def print_schedule(n, m, exams, schedule):\n        result = []\n        for i in range(n):\n            if i + 1 in schedule:\n                result.append(schedule.index(i + 1) + 1)\n            else:\n                result.append(0)\n        return \" \".join(map(str, result))\n\n    def backtrack(n, m, exams, schedule, idx):\n        if idx == m:\n            if is_possible(n, m, exams, schedule):\n                return print_schedule(n, m, exams, schedule)\n            else:\n                return -1\n\n        for i in range(n):\n            if i + 1 not in schedule:\n                schedule[idx] = i + 1\n                result = backtrack(n, m, exams, schedule, idx + 1)\n                if result != -1:\n                    return result\n        schedule[idx] = 0\n        return backtrack(n, m, exams, schedule, idx + 1)\n\n    n, m = map(int, stdin.split()[0:2])\n    exams = [list(map(int, stdin.split()[2 * i + 2:2 * i + 5])) for i in range(m)]\n    schedule = [0] * m\n\n    return backtrack(n, m, exams, schedule, 0)"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def can_prepare(plan, day, exam):\n        if plan[day][0] != 0:\n            return False\n        for i in range(1, exam + 1):\n            if i < exam and plan[day][i] != 1:\n                return False\n            if i == exam and plan[day][i] != -1:\n                return False\n        return True\n\n    def can_pass(plan, day, exam):\n        if plan[day][0] != 0 or plan[day][exam] != 1:\n            return False\n        for i in range(1, exam + 1):\n            if plan[day][i] != 0:\n                return False\n        return True\n\n    def prepare(plan, day, exam):\n        plan[day][0] = -1\n        for i in range(1, exam + 1):\n            if i < exam:\n                plan[day][i] = 1\n            else:\n                plan[day][i] = -1\n\n    def pass_exam(plan, day, exam):\n        plan[day][0] = 1\n        plan[day][exam] = 1\n\n    def find_schedule(plan, exams):\n        for day in range(n):\n            if plan[day][0] == -1:\n                continue\n            for exam in range(1, m + 1):\n                if can_prepare(plan, day, exam):\n                    prepare(plan, day, exam)\n                    return True\n                elif can_pass(plan, day, exam):\n                    pass_exam(plan, day, exam)\n                    return True\n            return False\n\n    n, m = map(int, stdin.readline().split())\n    exams = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    plan = [[0] * (m + 1) for _ in range(n)]\n    for s, d, c in exams:\n        for i in range(s, d):\n            plan[i][0] = 1\n\n    if not find_schedule(plan, exams):\n        return \"-1\"\n\n    schedule = []\n    for day in range(n):\n        if plan[day][0] == -1:\n            schedule.append(\"0\")\n        elif plan[day][0] == 1:\n            for exam in range(1, m + 1):\n                if plan[day][exam] == 1:\n                    schedule.append(str(exam))\n                    break\n        else:\n            for exam in range(1, m + 1):\n                if plan[day][exam] == -1:\n                    schedule.append(str(exam))\n                    break\n\n    return \" \".join(schedule)"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def prepare_exam(exam, day, exam_dict):\n        for i in range(exam_dict[exam][\"s\"], exam_dict[exam][\"d\"]):\n            if schedule[i] == 0:\n                schedule[i] = exam\n                return True\n        return False\n\n    def pass_exam(exam, day, exam_dict):\n        if schedule[day] == exam:\n            for i in range(exam_dict[exam][\"s\"], exam_dict[exam][\"d\"]):\n                schedule[i] = 0\n            return True\n        return False\n\n    def can_prepare_exam(exam, day, exam_dict):\n        for i in range(exam_dict[exam][\"s\"], exam_dict[exam][\"d\"]):\n            if schedule[i] != 0:\n                return False\n        return True\n\n    def create_schedule(exam_dict):\n        for day, activity in enumerate(schedule):\n            if activity == 0:\n                for exam in range(1, m + 1):\n                    if can_prepare_exam(exam, day, exam_dict):\n                        if prepare_exam(exam, day, exam_dict):\n                            break\n            else:\n                pass_exam(activity, day, exam_dict)\n\n    def is_valid_schedule(exam_dict):\n        for exam in range(1, m + 1):\n            if not pass_exam(exam, exam_dict[exam][\"d\"], exam_dict):\n                return False\n        return True\n\n    def has_conflict(exam_dict):\n        for exam in range(1, m + 1):\n            for i in range(exam_dict[exam][\"s\"], exam_dict[exam][\"d\"]):\n                if schedule[i] != 0 and schedule[i] != exam:\n                    return True\n        return False\n\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    schedule = [0] * n\n    exam_dict = {}\n\n    for i in range(1, m + 1):\n        s, d, c = map(int, lines[i].split())\n        exam_dict[i] = {\"s\": s, \"d\": d, \"c\": c}\n\n    create_schedule(exam_dict)\n\n    if not is_valid_schedule(exam_dict) or has_conflict(exam_dict):\n        return \"-1\"\n\n    return \" \".join(map(str, schedule))"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start_day, exams, schedule, exam_days, exam_start_days, exam_end_days, exams_left):\n        if exams_left == 0:\n            return True\n        if start_day >= n:\n            return False\n        for i in range(len(exams)):\n            if exams[i]:\n                for j in range(exam_start_days[i], exam_end_days[i] + 1):\n                    schedule[j] = exams[i]\n                exams[i] = False\n                if dfs(start_day + exam_end_days[i] + exam_days[i], exams, schedule, exam_days, exam_start_days, exam_end_days, exams_left - 1):\n                    return True\n                for j in range(exam_start_days[i], exam_end_days[i] + 1):\n                    schedule[j] = 0\n                exams[i] = True\n        return False\n\n    def print_schedule(schedule):\n        for day in schedule:\n            if day != 0:\n                print(day, end=' ')\n            else:\n                print(0, end=' ')\n        print()\n\n    n, m = map(int, stdin.split())\n    exams = [i + 1 for i in range(m)]\n    exam_days = [0] * m\n    exam_start_days = [0] * m\n    exam_end_days = [0] * m\n    for i in range(m):\n        s, d, c = map(int, input().split())\n        exam_days[i] = c\n        exam_start_days[i] = s\n        exam_end_days[i] = d - 1\n\n    schedule = [0] * n\n    if dfs(1, exams, schedule, exam_days, exam_start_days, exam_end_days, m):\n        print_schedule(schedule)\n    else:\n        print(-1)"
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_schedule(exams, schedule):\n        for day, activity in enumerate(schedule):\n            if activity > 0:\n                if exams[activity - 1][1] <= day < exams[activity - 1][2]:\n                    return False\n        return True\n\n    def find_schedule(exams, schedule, day):\n        if day == n + 1:\n            if all(activity == 0 for activity in schedule):\n                return schedule\n            else:\n                return None\n\n        if day in [exam[1] for exam in exams]:\n            for i, exam in enumerate(exams):\n                if exam[1] == day:\n                    for j in range(exam[2]):\n                        if schedule[day + j] == 0:\n                            schedule[day + j] = i + 1\n                            if find_schedule(exams, schedule, day + 1):\n                                return schedule\n                            schedule[day + j] = 0\n                    return None\n\n        if schedule[day] == 0:\n            schedule[day] = -1\n            if find_schedule(exams, schedule, day + 1):\n                return schedule\n            schedule[day] = 0\n\n        return None\n\n    n, m = map(int, stdin.split())\n    exams = [list(map(int, input().split())) for _ in range(m)]\n\n    schedule = [0] * (n + 1)\n    schedule[0] = -1\n\n    result = find_schedule(exams, schedule, 1)\n\n    if result:\n        return \" \".join(map(str, result[1:]))\n    else:\n        return \"-1\" "
    },
    {
        "number": 4014,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def can_prepare(exam_list, start, end):\n        for exam in exam_list:\n            if exam[0] <= start < exam[1]:\n                return False\n            if exam[0] < end <= exam[1]:\n                return False\n        return True\n\n    def find_schedule(exam_list, n, m, current_exam):\n        if current_exam == m:\n            return [1] * m + [0] * (n - m)\n\n        for i in range(n):\n            if can_prepare(exam_list, i, i):\n                exam_list.append((i, i + 1, 0))\n                schedule = find_schedule(exam_list, n, m, current_exam + 1)\n                if schedule:\n                    return schedule\n                exam_list.pop()\n\n        return None\n\n    n, m = map(int, stdin.split())\n    exam_list = []\n\n    for _ in range(m):\n        s, d, c = map(int, input().split())\n        exam_list.append((s - 1, d, c))\n\n    exam_list.sort(key=lambda x: x[1])\n\n    schedule = find_schedule(exam_list, n, m, 0)\n\n    if not schedule:\n        return -1\n\n    for i in range(n):\n        if i == 0:\n            schedule[i] = m + 1 if exam_list and exam_list[0][0] == i else 0\n        elif i in [exam[0] for exam in exam_list]:\n            schedule[i] = m + 1\n        elif i in [exam[1] - 1 for exam in exam_list]:\n            schedule[i] = 0\n        else:\n            schedule[i] = [j for j, exam in enumerate(exam_list, 1) if exam[0] <= i < exam[1]][0]\n\n    return \" \".join(map(str, schedule))"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n    if n * 2 == m or n * 3 == m:\n        return \"1\"\n    if n % 2 == 0 and n // 2 <= m:\n        return \"2\"\n    if n % 3 == 0 and n // 3 <= m:\n        return \"2\"\n    for i in range(4, int(n**0.5) + 1, 2):\n        if n % i == 0 and n // i <= m:\n            return \"3\"\n    return \"-1\""
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    if n == m:\n        return \"0\"\n    moves = 0\n    while n != m:\n        if n > m:\n            return \"-1\"\n        if n * 2 == m or n * 3 == m:\n            moves += 1\n            break\n        elif n * 2 < m:\n            n *= 2\n            moves += 1\n        elif n * 3 < m:\n            n *= 3\n            moves += 1\n        else:\n            return \"-1\"\n    return str(moves)"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n    steps = 0\n    while n != m:\n        if n > m:\n            return \"-1\"\n        if m % n == 0:\n            steps += m // n - 1\n            m //= n\n        elif n % 2 == 0 and m % 2 == 0:\n            n //= 2\n            m //= 2\n            steps += 1\n        elif n % 3 == 0 and m % 3 == 0:\n            n //= 3\n            m //= 3\n            steps += 1\n        else:\n            return \"-1\"\n    return str(steps)"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n    queue = [(n, 0)]\n    visited = set()\n\n    while queue:\n        num, moves = queue.pop(0)\n        if num == m:\n            return str(moves)\n        if num * 2 not in visited:\n            visited.add(num * 2)\n            queue.append((num * 2, moves + 1))\n        if num * 3 not in visited:\n            visited.add(num * 3)\n            queue.append((num * 3, moves + 1))\n\n    return \"-1\""
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    def is_possible(n, m):\n        if n == m:\n            return True\n        if n > m:\n            return False\n        return is_possible(n * 2, m) or is_possible(n * 3, m)\n\n    if is_possible(n, m):\n        count = 0\n        while n != m:\n            if n > m:\n                return -1\n            if n * 2 <= m:\n                n *= 2\n                count += 1\n            else:\n                n *= 3\n                count += 1\n        return count\n    else:\n        return -1"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    moves = 0\n\n    while n != m:\n        if n > m:\n            return \"-1\"\n        if m % n == 0:\n            moves += m // n\n            m //= n\n        elif n % m == 0:\n            moves += n // m\n            n //= m\n        else:\n            return \"-1\"\n\n    return str(moves)"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    if n == m:\n        return \"0\"\n\n    def is_possible(n, m):\n        if n > m:\n            return False\n        q = [(n, 0)]\n        visited = set()\n\n        while q:\n            num, depth = q.pop(0)\n            if num == m:\n                return depth\n            if num not in visited:\n                visited.add(num)\n                q.append((num * 2, depth + 1))\n                q.append((num * 3, depth + 1))\n\n        return -1\n\n    result = is_possible(n, m)\n    return str(result)\n"
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n    q = [(n, 0)]\n    visited = set()\n    while q:\n        num, depth = q.pop(0)\n        if num == m:\n            return str(depth)\n        if num * 2 not in visited:\n            visited.add(num * 2)\n            q.append((num * 2, depth + 1))\n        if num * 3 not in visited:\n            visited.add(num * 3)\n            q.append((num * 3, depth + 1))\n    return \"-1\""
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n\n    def is_possible(n, m, memo):\n        if n == m:\n            return True\n        if n > m or n == 0:\n            return False\n        if n in memo:\n            return memo[n]\n        memo[n] = is_possible(n * 2, m, memo) or is_possible(n * 3, m, memo)\n        return memo[n]\n\n    memo = {}\n    if is_possible(n, m, memo):\n        return f\"{memo[n]}\"\n    else:\n        return \"-1\""
    },
    {
        "number": 4015,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m:\n        return \"0\"\n    moves = 0\n    while n < m:\n        if m % 2 == 0:\n            m //= 2\n        elif m % 3 == 0:\n            m //= 3\n        else:\n            return \"-1\"\n        moves += 1\n    if n == m:\n        return str(moves)\n    else:\n        return \"-1\""
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n    \n    length = (len(t) * k) + k - 1\n    s = t * k\n    s = t + s[:length - len(t)]\n    \n    return s"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n    s = t * (n + k - 1)\n    return s"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n    s = t * (k // n)\n    s += t[:k % n]\n    return s"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n    \n    s = t * (k // n) + t[:k % n]\n    \n    return s"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().strip().split())\n    t = stdin.readline().strip()\n\n    return t * (n * k // len(t)) + t[:n * k % len(t)]"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n\n    s = t * (n + 1)\n    while len(s) % (n + 1) != 0:\n        s += t\n\n    while s.count(t) > k:\n        s = s[1:]\n        if s.count(t) == k:\n            return s\n\n    return s\n"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n\n    s = t * (k // n)\n    s += t[:k % n]\n\n    return s"
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    t = stdin.readline().strip()\n\n    s = t * (n * k // len(t)) + t[:n * k % len(t)]\n\n    return s "
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    t = input()\n\n    s = \"\"\n    while k > 0:\n        s += t\n        k -= 1\n\n    if len(s) % n != 0:\n        s += t[:n - (len(s) % n)]\n\n    return s\n\nn, k = map(int, input().split())\nt = input()\n\nprint(solution(f\"{n} {k}\\n{t}\")) "
    },
    {
        "number": 4016,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    t = input()\n    s = t * (n + k - 1)\n    return s[:n * k]"
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    nice_indices = []\n\n    for j in range(n):\n        temp_sum = sum(a) - a[j]\n        if a[j] == temp_sum:\n            nice_indices.append(j + 1)\n\n    if len(nice_indices) == 0:\n        return \"0\\n\"\n    else:\n        result = str(len(nice_indices)) + \"\\n\"\n        result += \" \".join(map(str, nice_indices))\n        return result + \"\\n\""
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    nice_indices = []\n    for j in range(n):\n        if sum(a) - a[j] == a[j]:\n            nice_indices.append(j + 1)\n\n    if len(nice_indices) == 0:\n        return \"0\"\n    else:\n        return str(len(nice_indices)) + \"\\n\" + \" \".join(map(str, nice_indices))"
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    nice_indices = []\n    for j in range(n):\n        if sum(a) - a[j] == a[j]:\n            nice_indices.append(j)\n        else:\n            for i in range(n):\n                if i == j:\n                    continue\n                if sum(a) - a[i] - a[j] == a[i] + a[j]:\n                    nice_indices.append(j)\n                    break\n    if len(nice_indices) == 0:\n        return \"0\\n\"\n    else:\n        return f\"{len(nice_indices)}\\n{' '.join(str(i) for i in nice_indices)}\\n\""
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    nice_indices = []\n    for j in range(n):\n        sum_a = sum(a)\n        if sum_a - a[j] == a[j]:\n            nice_indices.append(j + 1)\n        else:\n            temp_a = a.copy()\n            temp_a.pop(j)\n            if sum(temp_a) == a[j]:\n                nice_indices.append(j + 1)\n\n    if not nice_indices:\n        return \"0\"\n    else:\n        return str(len(nice_indices)) + \"\\n\" + \" \".join(map(str, nice_indices))"
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    nice_indices = []\n\n    for i in range(n):\n        sum_without_i = sum(a[:i] + a[i+1:])\n        if sum_without_i == a[i]:\n            nice_indices.append(i+1)\n\n    if not nice_indices:\n        return \"0\\n\"\n\n    return f\"{len(nice_indices)}\\n{' '.join(map(str, nice_indices))}\\n\""
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    nice_indices = []\n    for j in range(n):\n        if sum(a) - a[j] == a[j]:\n            nice_indices.append(j + 1)\n\n    if len(nice_indices) == 0:\n        return \"0\"\n\n    return f\"{len(nice_indices)}\\n{' '.join(map(str, nice_indices))}\""
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(arr):\n        s = sum(arr)\n        for x in arr:\n            if s - x == x:\n                return True\n        return False\n\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    nice_indices = [i for i in range(1, n + 1) if is_good(a[:i - 1] + a[i:])]\n\n    if not nice_indices:\n        return '0\\n'\n    else:\n        return f'{len(nice_indices)}\\n' + ' '.join(map(str, nice_indices)) + '\\n'"
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    nice_indices = []\n\n    for j in range(n):\n        if sum(a) - a[j] == a[j]:\n            nice_indices.append(j + 1)\n\n        for i in range(j + 1, n):\n            if sum(a[:j] + a[j + 1:i] + a[i + 1:]) == a[j]:\n                nice_indices.append(j + 1)\n                break\n\n    k = len(set(nice_indices))\n\n    if k == 0:\n        return '0'\n    else:\n        return f'{k}\\n' + ' '.join(map(str, sorted(set(nice_indices))))"
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    nice_indices = []\n    for i in range(n):\n        if sum(a) - a[i] == a[i]:\n            nice_indices.append(i+1)\n\n    if len(nice_indices) == 0:\n        return \"0\\n\"\n    else:\n        return f\"{len(nice_indices)}\\n{' '.join(map(str, nice_indices))}\\n\""
    },
    {
        "number": 4017,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_array(arr: list) -> bool:\n        total_sum = sum(arr)\n        for num in arr:\n            if num == total_sum - num:\n                return True\n        return False\n\n    def find_nice_indices(a: list) -> list:\n        nice_indices = []\n        for j in range(len(a)):\n            if is_good_array(a[:j] + a[j + 1 :]):\n                nice_indices.append(j + 1)\n        return nice_indices\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    nice_indices = find_nice_indices(a)\n\n    if not nice_indices:\n        return \"0\"\n    else:\n        return f\"{len(nice_indices)}\\n{' '.join(map(str, nice_indices))}\""
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def is_subsequence(t: str) -> bool:\n        i = j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                j += 1\n            i += 1\n        return j == len(t)\n\n    def count_subsequences(t: str) -> int:\n        count = 0\n        for i in range(len(s) - len(t) + 1):\n            if is_subsequence(s[i:i + len(t)]):\n                count += 1\n        return count\n\n    total_cost = 0\n    S = set()\n\n    for i in range(1, n + 1):\n        for j in range(len(s)):\n            t = s[j:j + i]\n            if t not in S and count_subsequences(t) == k:\n                S.add(t)\n                total_cost += n - i\n                if len(S) == k:\n                    return total_cost\n    return -1\n"
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    total_cost = 0\n    S = set()\n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            if len(S) == k:\n                return total_cost\n            t = s[j:j + i]\n            if t not in S:\n                S.add(t)\n                total_cost += n - i\n    return -1\n\nn, k = map(int, input().split())\ns = input()\nprint(solution(f\"{n} {k}\\n{s}\")) "
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def is_subsequence(t: str, s: str) -> bool:\n        t_idx, s_idx = 0, 0\n        while s_idx < len(s):\n            if s[s_idx] == t[t_idx]:\n                t_idx += 1\n            if t_idx == len(t):\n                return True\n            s_idx += 1\n        return False\n\n    def min_cost(s: str, k: int) -> int:\n        cost = 0\n        for i in range(1, n):\n            for j in range(i):\n                t = s[j:i]\n                if is_subsequence(t, s):\n                    cost += n - i\n        return cost\n\n    if min_cost(s, k) > 10**12:\n        return -1\n    else:\n        return str(min_cost(s, k))\n"
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    \n    dp = [0] * (n + 1)\n    dp[1] = n\n    \n    for i in range(2, n + 1):\n        dp[i] = min(dp[i - 1] + n - i, dp[i - 1] + 1)\n    \n    cost = dp[n]\n    \n    if k * (k - 1) // 2 > n:\n        return -1\n    \n    for i in range(2, k + 1):\n        cost = min(cost, dp[n - i + 1])\n        \n    return str(cost) "
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    total_cost = 0\n    subsequences = set()\n    subseq_lengths = set()\n\n    for i in range(n):\n        for j in range(i, n):\n            subseq = s[i:j+1]\n            subseq_length = len(subseq)\n            if subseq_length not in subseq_lengths:\n                subsequences.add(subseq)\n                subseq_lengths.add(subseq_length)\n                total_cost += n - subseq_length\n\n            if len(subsequences) == k:\n                return str(total_cost)\n\n    return \"-1\"\n"
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    if k > (n * (n + 1)) // 2:\n        return \"-1\"\n\n    total_cost = 0\n    unique_subsequences = set()\n\n    for i in range(n, -1, -1):\n        for j in range(n - i + 1):\n            subsequence = s[j:j + i]\n            if subsequence not in unique_subsequences:\n                unique_subsequences.add(subsequence)\n                total_cost += (n - i)\n                if len(unique_subsequences) == k:\n                    return str(total_cost)\n\n    return \"-1\""
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def is_subsequence(t: str, s: str) -> bool:\n        t = list(t)\n        for c in s:\n            if t and t[0] == c:\n                t.pop(0)\n        return not t\n\n    subsequences = set()\n    total_cost = 0\n\n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            t = s[j:j + i]\n            if not is_subsequence(t, s):\n                continue\n            if t not in subsequences:\n                subsequences.add(t)\n                total_cost += n - i\n\n        if len(subsequences) == k:\n            return total_cost\n\n    return -1\n"
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    total_cost = 0\n    S = set()\n\n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            if len(S) == k:\n                return str(total_cost)\n            subseq = s[j:j + i]\n            if subseq not in S:\n                S.add(subseq)\n                total_cost += n - i\n\n    return str(-1)\n\n\nn, k = map(int, input().split())\ns = input()\n\nprint(solution(f\"{n} {k}\\n{s}\")) "
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    if k > (n * (n + 1)) // 2:\n        return -1\n\n    total_cost = 0\n    seen = set()\n    i = 0\n\n    while i < n:\n        j = i + 1\n        subseq = s[i]\n        cost = n - 1\n\n        while j <= n:\n            subseq += s[j - 1]\n            cost -= 1\n\n            if subseq not in seen:\n                seen.add(subseq)\n                total_cost += cost\n                k -= 1\n\n                if k == 0:\n                    return total_cost\n\n            j += 1\n\n        i += 1\n\n    return -1\n"
    },
    {
        "number": 4018,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    total_cost = 0\n    S = set()\n\n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            t = s[j:j + i]\n            if t not in S:\n                S.add(t)\n                total_cost += n - i\n                if len(S) == k:\n                    return total_cost\n\n    return -1\n"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find_parent(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, x, y):\n        xroot = find_parent(parent, x)\n        yroot = find_parent(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    lines = stdin.split('\\n')\n    n, m, D = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n\n    for u, v in edges:\n        union(parent, rank, u, v)\n\n    if find_parent(parent, 1) != find_parent(parent, D):\n        print(\"NO\")\n        return \"\"\n\n    print(\"YES\")\n\n    result = []\n    for u, v in edges:\n        if find_parent(parent, u) == find_parent(parent, D) and find_parent(parent, v) == find_parent(parent, D):\n            result.append((u, v))\n\n    for u, v in result:\n        print(u, v)\n\n    return \"\""
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_spanning_tree(graph: List[List[int]], degree: int) -> List[Tuple[int, int]]:\n        result = []\n        visited = [False] * n\n        stack = [(0, -1)]\n\n        while stack:\n            vertex, parent = stack.pop()\n            visited[vertex] = True\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    stack.append((neighbor, vertex))\n                    if len(result) < degree - 1:\n                        result.append((vertex, neighbor))\n\n            if not result and degree - len(result) == degree:\n                result.append((vertex, parent))\n\n        return result\n\n    def check_spanning_tree(graph: List[List[int]], tree: List[Tuple[int, int]]) -> bool:\n        visited = [False] * n\n        components = 0\n\n        def dfs(vertex: int) -> None:\n            nonlocal visited, components\n            visited[vertex] = True\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n\n        for vertex in range(n):\n            if not visited[vertex]:\n                dfs(vertex)\n                components += 1\n\n        return components == 1\n\n    def print_spanning_tree(tree: List[Tuple[int, int]]) -> str:\n        return \"\\n\".join(f\"{min(v, u)} {max(v, u)}\" for v, u in tree)\n\n    n, m, degree = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        v, u = map(int, stdin.readline().split())\n        v -= 1\n        u -= 1\n        graph[v].append(u)\n        graph[u].append(v)\n\n    spanning_tree = find_spanning_tree(graph, degree)\n\n    if not spanning_tree or not check_spanning_tree(graph, spanning_tree):\n        return \"NO\"\n\n    return \"YES\\n\" + print_spanning_tree(spanning_tree)"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, D = map(int, stdin.readline().split())\n    edges = []\n    for i in range(m):\n        v, u = map(int, stdin.readline().split())\n        edges.append((v, u))\n    \n    # Check if there is a valid spanning tree\n    if D >= n - 1:\n        print(\"NO\")\n        return\n    \n    # Initialize the graph\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    # Perform a Depth-First Search (DFS) to find a spanning tree\n    visited = [False] * (n + 1)\n    stack = [(1, D)]\n    while stack:\n        v, d = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            if d > 0:\n                for u in graph[v]:\n                    if not visited[u]:\n                        stack.append((u, d - 1))\n    \n    # Check if the DFS found a valid spanning tree\n    if not all(visited[1:]) or D != sum(len(graph[i]) for i in range(1, n + 1)) - n + 1:\n        print(\"NO\")\n        return\n    \n    # Output the edges of the spanning tree\n    print(\"YES\")\n    for v, u in edges:\n        if visited[v] and visited[u] and (len(graph[v]) - 1 == D or len(graph[u]) - 1 == D):\n            print(v, u)"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_edges_from_input():\n        edges = []\n        for line in input_lines[1:]:\n            v, u = map(int, line.split())\n            edges.append((v, u))\n        return edges\n\n    def is_valid_tree(tree_edges):\n        visited = [False] * (n + 1)\n        visited[1] = True\n        stack = [(1, 0)]\n\n        while stack:\n            v, parent = stack.pop()\n            visited[v] = True\n            for u in neighbors[v]:\n                if not visited[u]:\n                    if u != parent:\n                        stack.append((u, v))\n                    elif tree_edges[v - 1] == u:\n                        continue\n                    else:\n                        return False\n        return all(visited)\n\n    def print_spanning_tree(tree_edges):\n        for v, u in tree_edges:\n            print(v, u)\n\n    input_lines = stdin.split('\\n')\n    n, m, D = map(int, input_lines[0].split())\n    edges = get_edges_from_input()\n\n    neighbors = [set() for _ in range(n + 1)]\n    for v, u in edges:\n        neighbors[v].add(u)\n        neighbors[u].add(v)\n\n    tree_edges = [(1, 0)]\n    for v, u in edges:\n        if v == 1 and len(tree_edges) == D:\n            tree_edges.append((v, u))\n            if is_valid_tree(tree_edges):\n                print_spanning_tree(tree_edges)\n                return\n            tree_edges.pop()\n        elif len(tree_edges) < D:\n            tree_edges.append((v, u))\n            if is_valid_tree(tree_edges):\n                print_spanning_tree(tree_edges)\n                return\n            tree_edges.pop()\n\n    print(\"NO\")"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tree(tree, degree):\n        degrees = [0] * (n + 1)\n        for u, v in tree:\n            degrees[u] += 1\n            degrees[v] += 1\n        return degrees[1] == degree\n\n    def find_spanning_tree(edges, degree):\n        for edge in edges:\n            tree = [edge]\n            if is_valid_tree(tree, degree):\n                return tree\n        return None\n\n    def find_spanning_tree_with_backtracking(edges, degree):\n        def backtrack(tree, used_edges):\n            if is_valid_tree(tree, degree):\n                return tree\n            for i, edge in enumerate(edges):\n                if i not in used_edges:\n                    tree.append(edge)\n                    used_edges.add(i)\n                    result = backtrack(tree, used_edges)\n                    if result is not None:\n                        return result\n                    tree.pop()\n                    used_edges.remove(i)\n            return None\n\n        return backtrack([], set())\n\n    lines = stdin.splitlines()\n    n, m, degree = map(int, lines[0].split())\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    if degree > m or degree > n - 1:\n        return \"NO\"\n\n    tree = find_spanning_tree_with_backtracking(edges, degree)\n    if tree is None:\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, edge)) for edge in tree)"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, v):\n        if parent[v] == v:\n            return v\n        return find_parent(parent, parent[v])\n\n    def union(parent, rank, x, y):\n        xroot = find_parent(parent, x)\n        yroot = find_parent(parent, y)\n        if xroot == yroot:\n            return False\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def kruskal(edges):\n        parent, rank = list(range(n + 1)), [0] * (n + 1)\n        mst, available_nodes = [], set(range(1, n + 1))\n\n        for v, u in sorted(edges, key=lambda e: e[2]):\n            if union(parent, rank, v, u):\n                mst.append((v, u))\n                available_nodes.discard(v)\n                available_nodes.discard(u)\n                if len(mst) == n - 1:\n                    break\n        return mst if len(mst) == n - 1 else None\n\n    n, m, D = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) + (i,) for i in range(m)]\n\n    if D == 0 or D >= n - 1:\n        return \"NO\"\n\n    mst = kruskal(edges)\n    if mst is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(f\"{v} {u}\" for v, u, _ in mst)\n\ndef"
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, D = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        adj[v - 1].append(u - 1)\n        adj[u - 1].append(v - 1)\n        edges.append((v - 1, u - 1))\n    \n    def dfs(node, parent, tree):\n        tree.add(node)\n        for neighbor in adj[node]:\n            if neighbor != parent and neighbor not in tree:\n                dfs(neighbor, node, tree)\n    \n    def is_valid(tree):\n        return sum(len(adj[node]) for node in tree) + 1 == D\n\n    for edge in edges:\n        tree = set()\n        dfs(edge[0], -1, tree)\n        if is_valid(tree):\n            return \"YES\\n\" + \"\\n\".join(f\"{edge[0] + 1} {edge[1] + 1}\" for edge in edges if edge[0] in tree)\n    \n    return \"NO\""
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_edges(n, m, edges):\n        adj_list = [[] for _ in range(n)]\n        for edge in edges:\n            adj_list[edge[0] - 1].append(edge[1])\n            adj_list[edge[1] - 1].append(edge[0])\n        return adj_list\n\n    def dfs(start, adj_list, visited, spanning_tree):\n        visited[start] = True\n        for neighbor in adj_list[start]:\n            if not visited[neighbor - 1]:\n                spanning_tree.add((start + 1, neighbor))\n                dfs(neighbor - 1, adj_list, visited, spanning_tree)\n\n    def find_spanning_tree(n, m, D, adj_list):\n        if D > n - 1:\n            return None\n\n        spanning_tree = set()\n        visited = [False] * n\n        dfs(0, adj_list, visited, spanning_tree)\n\n        if len(spanning_tree) == n - 1:\n            return sorted(list(spanning_tree))\n        else:\n            return None\n\n    lines = stdin.split(\"\\n\")\n    n, m, D = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n\n    adj_list = get_edges(n, m, edges)\n    spanning_tree = find_spanning_tree(n, m, D, adj_list)\n\n    if spanning_tree:\n        return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, edge)) for edge in spanning_tree)\n    else:\n        return \"NO\""
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, i):\n        if parent[i] == i:\n            return i\n        return find_parent(parent, parent[i])\n\n    def union_parent(parent, rank, x, y):\n        xroot = find_parent(parent, x)\n        yroot = find_parent(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def find_spanning_tree(n, m, D):\n        edges = []\n        for i in range(m):\n            v, u = map(int, stdin.readline().split())\n            edges.append((v - 1, u - 1))\n\n        parent = list(range(n))\n        rank = [0] * n\n\n        for v, u in edges:\n            if union_parent(parent, rank, v, u):\n                if v == 0:\n                    degree_v = degree_v + 1\n                elif u == 0:\n                    degree_u = degree_u + 1\n\n            if degree_v == D or degree_u == D:\n                return True\n\n        return False\n\n    n, m, D = map(int, stdin.readline().split())\n\n    if find_spanning_tree(n, m, D):\n        print(\"YES\")\n        for i in range(m):\n            v, u = map(int, stdin.readline().split())\n            if v == 1 or u == 1:\n                print(f\"{v} {u}\")\n    else:\n        print(\"NO\") "
    },
    {
        "number": 4019,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parents, i):\n        if parents[i] == i:\n            return i\n        return find_parent(parents, parents[i])\n\n    def union_parent(parents, i, j):\n        parent_i = find_parent(parents, i)\n        parent_j = find_parent(parents, j)\n        if parent_i < parent_j:\n            parents[parent_j] = parent_i\n        else:\n            parents[parent_i] = parent_j\n\n    n, m, D = map(int, stdin.split()[:3])\n    edges = [list(map(int, stdin.split()[3:5])) for _ in range(m)]\n\n    parents = list(range(n + 1))\n    for i in range(m):\n        v, u = edges[i]\n        union_parent(parents, v, u)\n\n    degrees = [0] * (n + 1)\n    for i in range(m):\n        v, u = edges[i]\n        degrees[v] += 1\n        degrees[u] += 1\n\n    first_vertex_degree = degrees[1]\n    if first_vertex_degree != D:\n        return \"NO\"\n\n    result = [\"YES\"]\n    for i in range(m):\n        v, u = edges[i]\n        if degrees[v] == D and degrees[u] == D:\n            result.append(f\"{v} {u}\")\n            degrees[v] -= 1\n            degrees[u] -= 1\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1 = map(int, stdin.split()[0].split(':'))\n    h2, m2 = map(int, stdin.split()[1].split(':'))\n    m_diff = (h2 * 60 + m2) - (h1 * 60 + m1)\n    m_mid = m1 + m_diff // 2\n    h_mid = (h1 + (m_mid // 60)) % 24\n    m_mid %= 60\n    return f\"{h_mid:02d}:{m_mid:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    total_minutes = (h2 - h1) * 60 + (m2 - m1)\n    midpoint_minutes = total_minutes // 2\n    h3, m3 = divmod(midpoint_minutes, 60)\n    h3 += h1\n    m3 += m1\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split())\n    total_minutes = (h2 * 60 + m2) - (h1 * 60 + m1)\n    half_minutes = total_minutes // 2\n    h3 = (half_minutes // 60) + h1\n    m3 = half_minutes % 60\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1 = map(int, stdin.split()[0].split(':'))\n    h2, m2 = map(int, stdin.split()[1].split(':'))\n\n    total_minutes = (h2 * 60 + m2) - (h1 * 60 + m1)\n    midpoint_minutes = total_minutes // 2\n\n    h3 = (midpoint_minutes // 60) + h1\n    m3 = midpoint_minutes % 60\n\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    \n    # Calculate the total minutes of the contest\n    total_minutes = (h2 - h1) * 60 + (m2 - m1)\n    \n    # Calculate the midpoint of the contest\n    midpoint_minutes = total_minutes // 2\n    \n    # Calculate the hours and minutes of the midpoint\n    h3 = (h1 + midpoint_minutes // 60) % 24\n    m3 = midpoint_minutes % 60\n    \n    # Format the output\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    total_minutes = (h2 - h1) * 60 + (m2 - m1)\n    midpoint_minutes = total_minutes // 2\n    h3, m3 = divmod(midpoint_minutes, 60)\n    h3 += h1\n    m3 += m1\n    return f\"{h3:02}:{m3:02}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    m3 = (m1 + m2) // 2\n    h3 = (h1 + h2) // 2\n    \n    if m3 == 60:\n        m3 = 0\n        h3 += 1\n    elif m3 == 0 and h3 % 2 == 1:\n        h3 -= 1\n        m3 = 30\n    \n    h3 %= 24\n    m3 %= 60\n    \n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    m_total = (h2 - h1) * 60 + (m2 - m1)\n    m_mid = m_total // 2\n    h3, m3 = (h1 + m_mid // 60), (m1 + m_mid % 60)\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1 = map(int, stdin.split()[0].split(':'))\n    h2, m2 = map(int, stdin.split()[1].split(':'))\n\n    total_minutes = (h2 * 60 + m2) - (h1 * 60 + m1)\n    half_minutes = total_minutes // 2\n\n    h3 = (half_minutes // 60) + h1\n    m3 = half_minutes % 60\n\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4020,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h1, m1, h2, m2 = map(int, stdin.split(':'))\n    h_diff = h2 - h1\n    m_diff = m2 - m1\n    if m_diff < 0:\n        h_diff -= 1\n        m_diff += 60\n    m_total = (h_diff * 60 + m_diff) // 2\n    h3, m3 = m_total // 60, m_total % 60\n    h3 += h1\n    if h3 >= 24:\n        h3 -= 24\n    return f\"{h3:02d}:{m3:02d}\""
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)\n\nprint(solution(input())) "
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4021,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    count = 0\n    while a > 1:\n        a >>= 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_intersection(a, b, c, d):\n        if a > c:\n            a, b, c, d = c, d, a, b\n        if b < c:\n            return 0, 0\n        return c, min(b, d)\n\n    n = int(stdin.readline())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    max_intersection = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            l1, r1 = segments[i]\n            l2, r2 = segments[j]\n            intersection_length = get_intersection(l1, r1, l2, r2)[1] - get_intersection(l1, r1, l2, r2)[0]\n            max_intersection = max(max_intersection, intersection_length)\n\n    return str(max_intersection)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    max_len = 0\n\n    for i in range(n):\n        remaining_segments = segments[:i] + segments[i+1:]\n        intersection = intersect_segments(remaining_segments)\n        max_len = max(max_len, intersection)\n\n    return str(max_len)\n\ndef"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find_intersection(a, b):\n        if a[1] < b[0] or b[1] < a[0]:\n            return []\n        return [max(a[0], b[0]), min(a[1], b[1])]\n\n    max_length = 0\n    for i in range(n):\n        remaining_segments = segments[:i] + segments[i+1:]\n        intersection = [segments[i][0], segments[i][1]]\n        for segment in remaining_segments:\n            intersection = find_intersection(intersection, segment)\n            if not intersection:\n                break\n        if intersection:\n            max_length = max(max_length, intersection[1] - intersection[0])\n\n    return str(max_length)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    def find_max_intersection(segments):\n        segments.sort(key=lambda x: x[0])\n        max_length = 0\n        last_segment = None\n        for segment in segments:\n            if last_segment is None:\n                last_segment = segment\n                continue\n            if segment[0] <= last_segment[1]:\n                max_length = max(max_length, last_segment[1] - segment[0])\n            else:\n                last_segment = segment\n        return max_length\n\n    result = 0\n    for i in range(n):\n        max_length = find_max_intersection(segments[:i] + segments[i + 1:])\n        result = max(result, max_length)\n\n    return str(result)\n"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def intersect_segments(segments):\n        intersection = segments[0]\n        for segment in segments[1:]:\n            intersection = [max(intersection[0], segment[0]), min(intersection[1], segment[1])]\n        return intersection\n\n    def segment_length(segment):\n        return segment[1] - segment[0]\n\n    n = int(stdin.readline().strip())\n    segments = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    max_length = 0\n    for i in range(n):\n        remaining_segments = segments[:i] + segments[i + 1:]\n        intersection = intersect_segments(remaining_segments)\n        max_length = max(max_length, segment_length(intersection))\n\n    return str(max_length)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    segments = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split(\"\\n\")[1:n+1]]\n    \n    def length_of_intersection(segments):\n        intersection = [max(segments[0][0], segments[1][0]), min(segments[0][1], segments[1][1])]\n        for i in range(2, len(segments)):\n            intersection = [max(intersection[0], segments[i][0]), min(intersection[1], segments[i][1])]\n        if intersection[0] < intersection[1]:\n            return intersection[1] - intersection[0]\n        else:\n            return 0\n    \n    max_length = 0\n    for i in range(n):\n        current_segments = segments[:i] + segments[i+1:]\n        max_length = max(max_length, length_of_intersection(current_segments))\n    \n    return str(max_length)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = []\n    for i in range(1, n + 1):\n        start, end = map(int, stdin.split('\\n')[i].split())\n        segments.append((start, end))\n\n    def is_intersecting(segment1, segment2):\n        return not (segment1[0] >= segment2[1] or segment1[1] <= segment2[0])\n\n    def intersect(segment1, segment2):\n        start = max(segment1[0], segment2[0])\n        end = min(segment1[1], segment2[1])\n        return (start, end)\n\n    def length(segment):\n        return segment[1] - segment[0]\n\n    max_length = 0\n    for i in range(n):\n        segments_without_i = segments[:i] + segments[i + 1:]\n        intersection = segments[i]\n        for j in range(n - 1):\n            if is_intersecting(intersection, segments_without_i[j]):\n                intersection = intersect(intersection, segments_without_i[j])\n            else:\n                break\n        max_length = max(max_length, length(intersection))\n\n    return str(max_length)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def overlap(a, b, c, d):\n        if a <= c <= d or a <= d <= d:\n            return min(b, d) - c\n        elif c <= a <= d or c <= b <= d:\n            return b - max(a, c)\n        elif a > d:\n            return 0\n        else:\n            return b - a\n\n    n = int(stdin.readline())\n    segments = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    max_length = 0\n\n    for i in range(n):\n        remaining_segments = segments[:i] + segments[i + 1:]\n        intersection = [segments[i][0], segments[i][1]]\n\n        for segment in remaining_segments:\n            length = overlap(intersection[0], intersection[1], segment[0], segment[1])\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n            max_length = max(max_length, length)\n\n    return str(max_length)"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def intersection(segment1, segment2):\n        start, end = max(segment1[0], segment2[0]), min(segment1[1], segment2[1])\n        return (start, end) if start <= end else None\n\n    def length(segment):\n        return segment[1] - segment[0] + 1\n\n    def max_intersection(segments):\n        max_len = 0\n        for i in range(len(segments)):\n            remaining_segments = segments[:i] + segments[i + 1:]\n            intersection = segments[i]\n            for segment in remaining_segments:\n                intersection = intersection_segment(intersection, segment)\n                if intersection is None:\n                    break\n            max_len = max(max_len, length(intersection))\n        return max_len\n\n    n = int(stdin.readline().strip())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    return str(max_intersection(segments))"
    },
    {
        "number": 4022,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def intersection(a, b, c, d):\n        if a[1] < b[0] or c[1] < d[0]:\n            return 0\n        start = max(a[0], c[0])\n        end = min(a[1], c[1])\n        return end - start\n\n    n = int(stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    max_length = 0\n    for i in range(n):\n        remaining_segments = segments[:i] + segments[i + 1:]\n        intersection_length = max(intersection(segments[j], segments[j + 1], remaining_segments[k], remaining_segments[k + 1]) for j in range(len(remaining_segments) - 1) for k in range(len(remaining_segments) - 1))\n        max_length = max(max_length, intersection_length)\n\n    return str(max_length)"
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = list(map(int, stdin.split()))\n    max_height = max(a)\n    for i in range(n - 1):\n        if a[i] != a[i + 1]:\n            if a[i] != max_height and a[i + 1] == max_height:\n                a[i] = max_height\n            elif a[i] == max_height and a[i + 1] != max_height:\n                a[i + 1] = max_height\n            else:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    heights = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    max_height = max(heights)\n    min_height = min(heights)\n\n    if max_height - min_height > 1:\n        return \"NO\"\n\n    if len(set(heights)) == 1:\n        return \"YES\"\n\n    for i in range(1, n):\n        if heights[i] - heights[i - 1] > 1:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    height = a[0]\n    for i in range(1, n):\n        if a[i] < height:\n            return \"NO\"\n        elif a[i] > height:\n            height += 1\n\n    return \"YES\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            continue\n        if a[i] > a[i + 1]:\n            a[i] -= 1\n        else:\n            a[i + 1] -= 1\n\n    for i in range(1, n - 1):\n        if a[i] != a[i - 1] + 1 or a[i] != a[i + 1] - 1:\n            return \"NO\"\n\n    if a[0] != a[-1]:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    # Check if the wall is already complete\n    if all(x == a[0] for x in a) and a[0] > 1:\n        return \"YES\"\n\n    # Check if Vova can complete the wall using bricks\n    for i in range(n):\n        if i > 0 and a[i] == a[i - 1]:\n            continue\n        if i < n - 1 and a[i] == a[i + 1]:\n            continue\n        if a[i] > 1:\n            return \"YES\"\n\n    # Check if Vova can complete the wall without bricks\n    if all(x == 1 for x in a):\n        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if all(i == a[0] for i in a) or len(set(a)) == 1:\n        return \"YES\"\n\n    for i in range(1, n):\n        if a[i - 1] == a[i] or a[i - 1] == a[i] + 1 or a[i - 1] == a[i] - 1:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if len(set(a)) == 1:\n        return \"YES\"\n\n    min_height = min(a)\n    max_height = max(a)\n    height_diff = max_height - min_height\n\n    if height_diff == 0:\n        return \"YES\"\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            continue\n        if a[i] == min_height:\n            min_height = a[i + 1]\n        elif a[i + 1] == min_height:\n            min_height = a[i]\n        height_diff -= 2\n\n        if height_diff <= 0:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = [int(x) for x in stdin.split(\"\\n\")[1].split(\" \")]\n\n    if all(a[i] == a[0] for i in range(n)) and a[0] != 1:\n        return \"YES\"\n    elif a.count(1) == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a = list(map(int, stdin.split()))\n    a.sort()\n\n    if a[0] != a[-1]:\n        return \"NO\"\n\n    for i in range(1, n):\n        if abs(a[i] - a[i - 1]) > 1:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 4023,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(1, n - 1):\n        if heights[i] == heights[i - 1] and heights[i] == heights[i + 1]:\n            heights[i] += 1\n            heights[i - 1] += 1\n            heights[i + 1] += 1\n\n    return \"YES\" if len(set(heights)) == 1 else \"NO\""
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    if k > n:\n        return -1\n\n    def get_subsequences(s: str, n: int, k: int) -> int:\n        subsequences = set()\n        cost = 0\n\n        for i in range(2 ** n):\n            subseq = []\n            for j in range(n):\n                if i & (1 << j):\n                    subseq.append(s[j])\n            if len(subseq) == k:\n                subsequences.add(''.join(subseq))\n                cost += n - len(subseq)\n\n        return subsequences, cost\n\n    subsequences, total_cost = get_subsequences(s, n, k)\n\n    if len(subsequences) == k:\n        return total_cost\n    else:\n        return -1"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def is_subsequence(t, s):\n        t = iter(t)\n        return all(c in t for c in s)\n\n    def find_subsequences(s, k):\n        subsequences = set()\n        for i in range(1, len(s) + 1):\n            for subseq in itertools.combinations(s, i):\n                subseq = ''.join(subseq)\n                if is_subsequence(subseq, s) and subseq not in subsequences:\n                    subsequences.add(subseq)\n                    if len(subsequences) == k:\n                        return subsequences\n        return None\n\n    if n < k:\n        print(-1)\n        return\n\n    subsequences = find_subsequences(s, k)\n\n    if subsequences is None:\n        print(-1)\n        return\n\n    total_cost = sum(n - len(t) for t in subsequences)\n    print(total_cost)\n"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def is_subsequence(t: str, s: str) -> bool:\n        t = list(t)\n        for c in s:\n            if t and t[0] == c:\n                t.pop(0)\n        return not t\n\n    def dfs(i: int, k: int, cost: int) -> int:\n        if k == 0:\n            return cost\n        if i == n:\n            return -1\n        t = s[i:]\n        if is_subsequence(t, s):\n            new_cost = dfs(i + 1, k, cost + n - len(t))\n            if new_cost != -1:\n                return new_cost\n        return dfs(i + 1, k, cost)\n\n    result = dfs(0, k, 0)\n    return str(result) if result != -1 else \"-1\""
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    \n    if k > n:\n        return -1\n    \n    total_cost = 0\n    subsequence = set()\n    \n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            t = s[j:j + i]\n            if t not in subsequence:\n                subsequence.add(t)\n                total_cost += (n - len(t))\n                \n                if len(subsequence) == k:\n                    return total_cost\n                \n    return -1\n"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    if n < k:\n        return -1\n    else:\n        total_cost = 0\n        for i in range(k):\n            total_cost += n - (i + 1)\n        return total_cost\n\nn, k = map(int, input().split())\ns = input()\nprint(solution(f\"{n} {k}\")) "
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def is_subsequence(t: str, s: str) -> bool:\n        t = list(t)\n        for c in s:\n            if t and t[0] == c:\n                t.pop(0)\n        return not t\n\n    def subsequence_cost(t: str, s: str) -> int:\n        return n - len(t)\n\n    def min_cost_to_set_size(k: int, n: int, s: str) -> int:\n        if k == 0:\n            return 0\n        if k > 2 ** n:\n            return -1\n\n        min_cost = float('inf')\n        for t in itertools.combinations(s, k):\n            t = ''.join(t)\n            if is_subsequence(t, s):\n                cost = subsequence_cost(t, s)\n                min_cost = min(min_cost, cost + min_cost_to_set_size(k - 1, n, s))\n\n        return min_cost if min_cost != float('inf') else -1\n\n    result = min_cost_to_set_size(k, n, s)\n    return str(result)"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    \n    if k > (n * (n + 1)) // 2:\n        return -1\n\n    total_cost = 0\n    seen = set()\n\n    for i in range(n):\n        for j in range(i, n):\n            subseq = s[i:j + 1]\n            if subseq not in seen:\n                seen.add(subseq)\n                total_cost += n - len(subseq)\n\n            if len(seen) == k:\n                return total_cost\n\n    return -1"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def is_subsequence(t: str, s: str) -> bool:\n        t = list(t)\n        for c in s:\n            if t and t[0] == c:\n                t.pop(0)\n        return not t\n\n    def subsequences(s: str, n: int, k: int) -> int:\n        subsets = [set()]\n        for i in range(n):\n            new_subsets = []\n            for subset in subsets:\n                new_subsets.append(subset)\n                new_subset = subset.copy()\n                new_subset.add(s[i])\n                new_subsets.append(new_subset)\n            subsets = new_subsets\n        return [subset for subset in subsets if len(subset) == k]\n\n    min_cost = n * n\n    for subset in subsequences(s, n, k):\n        cost = n\n        for t in subset:\n            if is_subsequence(t, s):\n                cost -= len(t)\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost if min_cost < n * n else -1)"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def is_subsequence(t: str) -> bool:\n        i = j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                j += 1\n            i += 1\n        return j == len(t)\n\n    S = set()\n    total_cost = 0\n\n    for i in range(len(s), -1, -1):\n        for j in range(len(s) - i):\n            t = s[j:j + i]\n            if is_subsequence(t) and t not in S:\n                S.add(t)\n                total_cost += len(t)\n                if len(S) == k:\n                    return total_cost\n\n    return -1"
    },
    {
        "number": 4024,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().strip().split())\n    s = stdin.readline().strip()\n\n    def is_subsequence(t: str) -> bool:\n        i = 0\n        for c in s:\n            if t[i] == c:\n                i += 1\n            if i == len(t):\n                return True\n        return False\n\n    if k > n:\n        return \"-1\"\n\n    total_cost = 0\n    subsequences = set()\n    for i in range(n, 0, -1):\n        for j in range(n - i + 1):\n            t = s[j:j + i]\n            if not is_subsequence(t):\n                continue\n            if t not in subsequences:\n                subsequences.add(t)\n                total_cost += n - i\n                if len(subsequences) == k:\n                    return str(total_cost)\n    return \"-1\"\n"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    days = [a, b, c]\n    week_days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    result = 0\n    day_idx = 0\n    while days[day_idx] > 0:\n        for i in range(len(week_days)):\n            days[(day_idx + i) % len(week_days)] -= 1\n        result += 1\n    return result"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    days_in_week = 7\n    total_days = 0\n\n    for i in range(days_in_week):\n        if i % 2 == 0 or i == 2:\n            total_days += min(a, b, c)\n        else:\n            total_days += min(a, c)\n\n    return str(total_days)"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    total_days = a + b + c\n    max_days = min(a, 7) + min(b, 2) + min(c, 3)\n    return str(min(total_days, max_days))"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    fish_days = [0, 1, 3, 4]\n    rabbit_days = [1, 3, 5]\n    chicken_days = [2, 4, 5, 6]\n\n    max_days = 0\n    for i in range(7):\n        days = 0\n        days_a = 0\n        days_b = 0\n        days_c = 0\n        while days_a < a or days_b < b or days_c < c:\n            if i in fish_days and days_a < a:\n                days_a += 1\n            elif i in rabbit_days and days_b < b:\n                days_b += 1\n            elif i in chicken_days and days_c < c:\n                days_c += 1\n            else:\n                break\n            days += 1\n        if days > max_days:\n            max_days = days\n    return str(max_days)"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    total_days = a + b + c\n\n    # Calculate the number of days the cat can eat without additional food purchases, starting on Monday, Tuesday, etc.\n    days_on_weekend = min(a, b)\n    days_on_week = c\n    days_without_purchase = days_on_weekend * 2 + days_on_week\n\n    # Check if it is possible to eat all food on the first week of the trip\n    if days_without_purchase >= total_days:\n        return str(total_days)\n\n    # Check if it is possible to eat all food on the second week of the trip\n    days_left = total_days - days_without_purchase\n    days_without_purchase += min(days_left, days_on_weekend + days_on_week)\n\n    if days_without_purchase >= total_days:\n        return str(total_days)\n\n    # If it is not possible to eat all food on the first two weeks of the trip,\n    # calculate the maximum number of days the cat can eat without additional food purchases\n    days_left = total_days - days_without_purchase\n    days_on_weekend = min(a, b)\n    days_on_week = c\n\n    days_without_purchase += min(days_left, days_on_weekend + days_on_week)\n\n    return str(days_without_purchase) "
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    days_of_week = [a, 0, b, 0, a, c, 0]\n    max_days = 0\n\n    for day in days_of_week:\n        if day > 0:\n            max_days += 1\n        else:\n            break\n\n    return str(max_days)\n"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_days = min(a + b + c, 7)\n    return str(max_days)"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    # The cat can eat for 7 days if there are enough supplies for all 7 days\n    if a >= 2 and b >= 2 and c >= 2:\n        return \"7\"\n\n    # The cat can eat for 4 days if there are enough supplies for 2 days of fish food and 1 day of rabbit stew\n    if a >= 2 and b >= 1:\n        return \"4\"\n\n    # The cat can eat for 3 days if there are enough supplies for 1 day of fish food and 1 day of rabbit stew\n    if a >= 1 and b >= 1:\n        return \"3\"\n\n    # The cat can eat for 2 days if there are enough supplies for 1 day of fish food and 1 day of chicken stake\n    if a >= 1 and c >= 1:\n        return \"2\"\n\n    # The cat can eat for 1 day if there are enough supplies for 1 day of rabbit stew or 1 day of chicken stake\n    if b >= 1 or c >= 1:\n        return \"1\"\n\n    # The cat can't eat at all if there are no supplies\n    return \"0\""
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    total_days = a + b + c\n    max_days = 0\n\n    for i in range(7):\n        days = 0\n        fish_food = 0\n        rabbit_stew = 0\n        chicken_stake = 0\n\n        for j in range(i, total_days, 7):\n            if j % 7 in [0, 3, 6]:\n                fish_food += 1\n            elif j % 7 in [1, 4]:\n                rabbit_stew += 1\n            else:\n                chicken_stake += 1\n\n            if fish_food <= a and rabbit_stew <= b and chicken_stake <= c:\n                days += 1\n            else:\n                break\n\n        max_days = max(max_days, days)\n\n    return str(max_days)"
    },
    {
        "number": 4025,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    # Calculate the maximum number of days the cat can eat without additional food purchases\n    days = min(a, b + c) + min(b, c)\n    \n    return str(days)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tile, i, j):\n        if i < 0 or j < 0 or i >= len(tile) or j >= len(tile):\n            return False\n        return tile[i][j] == 0\n\n    def mark_tiles(tile, i, j):\n        tile[i][j] = -1\n        if is_valid(tile, i - 1, j) and tile[i - 1][j] != -1:\n            mark_tiles(tile, i - 1, j)\n        if is_valid(tile, i + 1, j) and tile[i + 1][j] != -1:\n            mark_tiles(tile, i + 1, j)\n        if is_valid(tile, i, j - 1) and tile[i][j - 1] != -1:\n            mark_tils(tile, i, j - 1)\n        if is_valid(tile, i, j + 1) and tile[i][j + 1] != -1:\n            mark_tiles(tile, i, j + 1)\n\n    def check_symmetric(square, i, j):\n        if square[i][j] != square[j][i]:\n            return False\n        return True\n\n    def construct_square(tiles, n, m):\n        square = [[-1] * m for _ in range(m)]\n        for i in range(m):\n            for j in range(m):\n                if i == j or i == m - j - 1:\n                    continue\n                for k in range(n):\n                    if square[i][j] != -1:\n                        break\n                    for l in range(n):\n                        if square[m - j - 1][i] != -1:\n                            break\n                        if (\n                            tiles[k][0] == tiles[l][0]\n                            and tiles[k][1] == tiles[l][2]\n                            and tiles[k][2] == tiles[l][1]\n                            and tiles[k][3] == tiles[l][3]\n                        ):\n                            square[i][j] = k\n                            square[m - j - 1][i] = l\n                            mark_tiles(tiles, k, 0)\n                            mark_tiles(tiles, l, 0)\n                            break\n        return square\n\n    def check_square(square, m):\n        for i in range(m):\n            for j in range(m):\n                if not check_symmetric(square, i, j):\n                    return False\n        return True\n\n    t = int(stdin.readline().strip())\n    result = []\n    for _ in range(t):\n        n, m = map(int, stdin.readline().strip().split())\n        tiles = []\n        for _ in range(n):\n            tiles.append(list(map(int, stdin.readline().strip().split())))\n        square = construct_square(tiles, n, m)\n        if check_square(square, m):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n        return True\n\n    def can_construct_square(tiles, n, m):\n        if n == 0:\n            return True\n\n        for i in range(len(tiles)):\n            if can_construct_square(tiles[:i] + tiles[i + 1:], n - 1, m):\n                for j in range(i, len(tiles)):\n                    if can_construct_square(tiles[:i] + tiles[i + 1:j] + tiles[j + 1:], n - 1, m):\n                        return True\n            return False\n\n    def read_input():\n        t = int(stdin.readline())\n        test_cases = []\n        for _ in range(t):\n            n, m = map(int, stdin.readline().split())\n            tiles = []\n            for _ in range(n):\n                tiles.append(list(map(int, stdin.readline().split())))\n            test_cases.append((tiles, n, m))\n        return test_cases\n\n    test_cases = read_input()\n    results = []\n\n    for tiles, n, m in test_cases:\n        if m % 2 == 0:\n            square = [[0 for _ in range(m)] for _ in range(m)]\n            for i in range(0, m, 2):\n                for j in range(0, m, 2):\n                    square[i][j] = tiles[0][0]\n                    square[i][j + 1] = tiles[0][1]\n                    square[i + 1][j] = tiles[1][0]\n                    square[i + 1][j + 1] = tiles[1][1]\n            if is_symmetric(square):\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n        else:\n            if can_construct_square(tiles, n, m):\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(matrix: List[List[int]]) -> bool:\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n        return True\n\n    def can_construct_square(n: int, m: int, tiles: List[List[List[int]]]) -> bool:\n        if m % 2 != 0:\n            return False\n\n        for tile in tiles:\n            if tile[0][0] != tile[1][1] or tile[0][1] != tile[1][0]:\n                return False\n\n        square = [[0] * m for _ in range(m)]\n\n        for i in range(0, m, 2):\n            for j in range(0, m, 2):\n                for k, tile in enumerate(tiles):\n                    if tile[0][0] == square[i][j] and tile[1][1] == square[i][j + 1] and tile[0][1] == square[i + 1][j] and tile[1][0] == square[i + 1][j + 1]:\n                        square[i][j] = square[i][j + 1] = square[i + 1][j] = square[i + 1][j + 1] = k + 1\n                        break\n                else:\n                    return False\n\n        return is_symmetric(square)\n\n    def parse_input(stdin: str) -> Iterator[Tuple[int, int, List[List[List[int]]]]]:\n        n_tests = int(stdin.split('\\n', 1)[0])\n        stdin = stdin.splitlines()[1:]\n\n        for _ in range(n_tests):\n            n, m = map(int, stdin.pop(0).split())\n            tiles = []\n\n            for _ in range(n):\n                top_left, top_right = map(int, stdin.pop(0).split())\n                bottom_left, bottom_right = map(int, stdin.pop(0).split())\n                tiles.append([[top_left, top_right], [bottom_left, bottom_right]])\n\n            yield n, m, tiles\n\n    for n, m, tiles in parse_input(stdin):\n        if can_construct_square(n, m, tiles):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tile, n, m):\n        for i in range(n):\n            for j in range(n):\n                if tile[i][j] != tile[j][i]:\n                    return False\n        return True\n\n    def construct_square(tiles, n, m):\n        if n == m:\n            for tile in tiles:\n                if is_valid(tile, n, m):\n                    return True\n        return False\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().strip().split())\n        tiles = []\n\n        for _ in range(n):\n            top_left, top_right = map(int, stdin.readline().strip().split())\n            bottom_left, bottom_right = map(int, stdin.readline().strip().split())\n            tiles.append([[top_left, top_right], [bottom_left, bottom_right]])\n\n        if construct_square(tiles, n, m):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_square(m, n, tiles):\n        if m % 2 == 1 or n % 2 == 1:\n            return False\n\n        for i in range(0, m, 2):\n            for j in range(0, n, 2):\n                if not is_valid_cell(i, j, m, n, tiles):\n                    return False\n        return True\n\n    def is_valid_cell(i, j, m, n, tiles):\n        for tile in tiles:\n            if (\n                i + 1 < m\n                and j + 1 < n\n                and tile[0] == tile[1] == tile[2] == tile[3]\n                and is_valid_placement(i, j, tile, m, n)\n            ):\n                return True\n        return False\n\n    def is_valid_placement(i, j, tile, m, n):\n        if (\n            is_inside(i, j, m, n)\n            and not is_intersecting(i, j, tile, m, n)\n            and is_parallel(i, j, tile, m, n)\n        ):\n            return True\n        return False\n\n    def is_inside(i, j, m, n):\n        return 0 <= i < m and 0 <= j < n\n\n    def is_intersecting(i, j, tile, m, n):\n        for k in range(i, i + 2):\n            for l in range(j, j + 2):\n                if tile[0] == m - 1 and l == 0:\n                    return True\n                if tile[1] == m - 1 and k == 0:\n                    return True\n                if tile[2] == n - 1 and l == n - 1:\n                    return True\n                if tile[3] == n - 1 and k == m - 1:\n                    return True\n        return False\n\n    def is_parallel(i, j, tile, m, n):\n        if i == 0 and j == 0:\n            return True\n        if i == 0 and j != 0:\n            return tile[0] == tile[2]\n        if i != 0 and j == 0:\n            return tile[1] == tile[3]\n        return False\n\n    test_cases = int(stdin.readline().strip())\n    results = []\n\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().strip().split())\n        tiles = []\n\n        for _ in range(2 * n):\n            tiles.append(list(map(int, stdin.readline().strip().split())))\n\n        if is_valid_square(m, m, tiles):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tile1, tile2, tile3, tile4):\n        return (\n            tile1[0][0] == tile2[0][1]\n            and tile1[0][1] == tile3[0][0]\n            and tile2[0][0] == tile4[0][1]\n            and tile3[0][1] == tile4[0][0]\n        )\n\n    def find_valid_tiles(tiles, n):\n        valid_tiles = []\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    if is_valid(tiles[i], tiles[j], tiles[i], tiles[j]):\n                        valid_tiles.append((i, j))\n        return valid_tiles\n\n    def construct_square(tiles, m):\n        if m % 2 != 0:\n            return False\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                if tiles[i][j] != tiles[j][i]:\n                    return False\n        return True\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().strip().split())\n        tiles = []\n        for i in range(n):\n            top_left, top_right = map(int, stdin.readline().strip().split())\n            bottom_left, bottom_right = map(int, stdin.readline().strip().split())\n            tiles.append(((top_left, top_right), (bottom_left, bottom_right)))\n\n        valid_tiles = find_valid_tiles(tiles, n)\n\n        if len(valid_tiles) == n * (n - 1) // 2:\n            if construct_square(valid_tiles, m):\n                result.append(\"YES\")\n            else:\n                result.append(\"NO\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def can_form_square(n: int, m: int, tiles: List[List[int]]) -> bool:\n        def is_symmetric(matrix: List[List[int]]) -> bool:\n            for i in range(len(matrix)):\n                for j in range(len(matrix)):\n                    if matrix[i][j] != matrix[j][i]:\n                        return False\n            return True\n\n        def helper(row: int, col: int, used_tiles: int) -> bool:\n            if row >= m:\n                return True\n            if col >= m:\n                return helper(row + 1, 0, used_tiles)\n            if used_tiles >= n:\n                return False\n\n            for i in range(n):\n                if not is_valid_placement(row, col, tiles[i]):\n                    continue\n                if i == 0:\n                    if not is_valid_placement(row + 1, col, tiles[0]):\n                        continue\n                if helper(row, col + 1, used_tiles + 1):\n                    return True\n            return False\n\n        def is_valid_placement(row: int, col: int, tile: List[int]) -> bool:\n            if row + 2 > m or col + 2 > m:\n                return False\n            for i in range(2):\n                for j in range(2):\n                    if matrix[row + i][col + j] != tile[i * 2 + j]:\n                        return False\n            return True\n\n        matrix = [[0] * m for _ in range(m)]\n        return helper(0, 0, 0) and is_symmetric(matrix)\n\n    def read_input(stdin: str) -> Iterator[Tuple[int, int, List[List[int]]]]:\n        lines = stdin.strip().split('\\n')\n        t = int(lines[0])\n        for i in range(1, t + 1):\n            n, m = map(int, lines[i].split())\n            tiles = []\n            for j in range(2 * n):\n                tiles.append(list(map(int, lines[i + j + 1].split())))\n            yield n, m, tiles\n\n    for n, m, tiles in read_input(stdin):\n        if can_form_square(n, m, tiles):\n            print(\"YES\")\n        else:\n            print(\"NO\") "
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n        return True\n\n    def can_construct_square(tiles, n, m):\n        if n == 0:\n            return True\n\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                if tiles[i][j] == 0:\n                    continue\n\n                new_tiles = [row[:] for row in tiles]\n                new_tiles[i][j] -= 1\n\n                if can_construct_square(new_tiles, n - 1, m):\n                    return True\n\n        return False\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        tiles = [list(map(int, stdin.readline().split())) for _ in range(2 * n)]\n\n        can_construct = can_construct_square(tiles, n, m)\n        if can_construct and is_symmetric(tiles):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result) "
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tiles, m):\n        for i in range(m):\n            for j in range(m):\n                if i == j:\n                    continue\n                if tiles[i][j] != tiles[j][i]:\n                    return False\n        return True\n\n    def can_construct(n, m, tiles):\n        if m % 2 != 0:\n            return False\n\n        for i in range(n):\n            for j in range(n):\n                tiles[i][j] = [tiles[i][j], tiles[n + i][j], tiles[i][n + j], tiles[n + i][n + j]]\n\n        for i in range(m):\n            for j in range(m):\n                if i == j:\n                    continue\n                if tiles[i][j] != tiles[j][i]:\n                    return False\n\n        return True\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n, m = map(int, lines[i * 2 - 1].split())\n        tiles = [[0] * (2 * n) for _ in range(2 * n)]\n\n        for j in range(n):\n            top_left, top_right = map(int, lines[i * 2 + j].split())\n            bottom_left, bottom_right = map(int, lines[i * 2 + n + j].split())\n            tiles[j][n + j] = top_left\n            tiles[j][n + j + 1] = top_right\n            tiles[j + n][n + j] = bottom_left\n            tiles[j + n][n + j + 1] = bottom_right\n\n        if can_construct(n, m, tiles):\n            result.append('YES')\n        else:\n            result.append('NO')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 4026,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n        return True\n\n    def is_valid_tile(tile, tile_type):\n        for i in range(2):\n            for j in range(2):\n                if tile[i][j] != tile_type[i][j]:\n                    return False\n        return True\n\n    def can_construct_square(tiles, n, m):\n        if m % 2 != 0:\n            return False\n\n        half_size = m // 2\n        for i in range(n):\n            if tiles[i][0] != tiles[i][1] or tiles[i][2] != tiles[i][3]:\n                return False\n\n        for i in range(half_size):\n            for j in range(half_size):\n                if not is_valid_tile(tiles[i][j], tiles[i + half_size][j]):\n                    return False\n                if not is_valid_tile(tiles[i][j], tiles[i][j + half_size]):\n                    return False\n                if not is_valid_tile(tiles[i][j], tiles[i + half_size][j + half_size]):\n                    return False\n\n        return True\n\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    i = 1\n    output = []\n\n    while i < len(test_cases):\n        n, m = list(map(int, test_cases[i].split()))\n        tiles = []\n        for j in range(i + 1, i + 2 * n + 1, 2):\n            tile = [list(map(int, test_cases[j].split())), list(map(int, test_cases[j + 1].split()))]\n            tiles.append(tile)\n        i += 2 * n + 1\n\n        if can_construct_square(tiles, n, m):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n\n    if n % 2 == 0:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n % 2 == 1:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    if n % 2 == 0:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 != 0:\n        return '0'\n    else:\n        return str(n // 2)"
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n == 1:\n        return \"0\"\n    elif n % 2 == 0:\n        return \"0\" if n // 2 % 2 == 0 else \"1\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return '0'\n    if n % 2 == 0:\n        return '0'\n    return '1'"
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 4027,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 1:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.splitlines())\n    n = int(n)\n    mod = 10**9 + 7\n\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def count_seq(s: str, n: int) -> int:\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_valid(s[i:j]):\n                    dp[j] += dp[i]\n                    dp[j] %= mod\n\n        return dp[-1]\n\n    result = count_seq(\"1\" * (2 * n - len(s)) + s, n)\n    return str(result)"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    MOD = 1000000007\n    dp = [0] * (2 * n + 1)\n    dp[0] = 1\n\n    for i in range(2 * n):\n        for j in range(i, -1, -1):\n            if dp[j] > 0 and dp[i - j] > 0:\n                if i - j == len(s) and s[j:i] == s:\n                    dp[i] += dp[j] * dp[i - j]\n                    dp[i] %= MOD\n                elif i - j >= len(s) and s[j:i] != s:\n                    dp[i] += dp[j] * dp[i - j]\n                    dp[i] %= MOD\n\n    return str(dp[-1])"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    from functools import reduce\n    from operator import mul\n\n    n, s = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_brackets(s: str) -> int:\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return 0\n        return 1 if count == 0 else 0\n\n    def regular_bracket_sequences(n: int, s: str) -> int:\n        valid_brackets = count_brackets(s)\n        if valid_brackets == 0:\n            return 0\n\n        brackets = [1, 0]\n        for _ in range(n - len(s)):\n            brackets = [sum(t) % MOD for t in zip(brackets, brackets[1:])]\n            brackets.append(reduce(mul, brackets, 1))\n\n        result = 0\n        for i in range(len(s) - 1):\n            if s[i] == '(' and s[i + 1] == ')':\n                result = (result + brackets[i + 1]) % MOD\n\n        return result\n\n    return regular_bracket_sequences(2 * n, s)"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    n, s = map(int, stdin.split())\n    dp = [0] * (2 * n + 1)\n    dp[0] = 1\n    MOD = 1000000007\n\n    for i in range(2 * n):\n        if dp[i] != 0:\n            for j in range(2 * n - i):\n                if dp[i + j + 1] != 0:\n                    if i % 2 == 0 and j % 2 == 0:\n                        dp[i + j + 2] += dp[i] * dp[j]\n                        dp[i + j + 2] %= MOD\n                    elif i % 2 == 1 and j % 2 == 1:\n                        if i == 1 and j == 1:\n                            dp[i + j + 2] += dp[i] * dp[j]\n                            dp[i + j + 2] %= MOD\n                        else:\n                            dp[i + j + 2] += dp[i] * dp[j] * 2\n                            dp[i + j + 2] %= MOD\n\n    return str(dp[2 * n])"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n    modulo = 1000000007\n    dp = [0] * (len(s) + 1)\n    dp[0] = 1\n    for i in range(n):\n        new_dp = [0] * (len(s) + 1)\n        for j in range(1, len(s) + 1):\n            if s[j - 1] == '(':\n                new_dp[j] = dp[j - 1]\n            else:\n                new_dp[j] = (dp[j - 1] + dp[j]) % modulo\n            if j >= 2 and s[j - 2] == '(' and s[j - 1] == ')':\n                new_dp[j] = (new_dp[j] + dp[j - 2]) % modulo\n        dp = new_dp\n    return str(dp[len(s)])"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split())\n    n = int(n) * 2\n\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for char in sequence:\n            if char == \"(\":\n                stack.append(char)\n            elif char == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def count_valid_sequences(index: int, current: str, sequence_count: int) -> int:\n        if index == n:\n            if is_valid(current):\n                if s in current:\n                    sequence_count += 1\n            return sequence_count\n\n        sequence_count = count_valid_sequences(index + 1, current + \"(\", sequence_count)\n        sequence_count = count_valid_sequences(index + 1, current + \")\", sequence_count)\n\n        return sequence_count\n\n    result = count_valid_sequences(0, \"\", 0)\n    return result % (10**9 + 7)"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split('\\n'))\n    n = int(n)\n    modulo = 10**9+7\n    dp = [[0]*(len(s)+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, 2*n+1):\n        for j in range(len(s)+1):\n            if i % 2 == 1:\n                if j > 0 and s[j-1] == '(':\n                    dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % modulo\n                else:\n                    dp[i][j] = dp[i][j-1]\n            else:\n                if j > 0 and s[j-1] == ')':\n                    dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % modulo\n                else:\n                    dp[i][j] = dp[i][j-1]\n    return str(dp[2*n][len(s)])"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split())\n    n = int(n)\n\n    MOD = 1000000007\n\n    def count_sequences(length, opening, closing):\n        if length == 0:\n            return 1\n        if opening < 0 or closing < 0:\n            return 0\n        return (count_sequences(length - 1, opening - 1, closing) +\n                count_sequences(length - 1, opening, closing - 1)) % MOD\n\n    def count_subsequences(length, opening, closing, substring):\n        if length == 0 and opening == closing == 0:\n            return int(substring == \"\")\n        if length == 0 or opening < 0 or closing < 0:\n            return 0\n\n        if length > len(substring):\n            with_open = count_subsequences(length - 1, opening - 1, closing, substring)\n            with_close = count_subsequences(length - 1, opening, closing - 1, substring)\n        else:\n            with_open = count_subsequences(length - 1, opening - 1, closing, substring[1:])\n            with_close = count_subsequences(length - 1, opening, closing - 1, substring[1:])\n\n        without = count_subsequences(length - 1, opening, closing, substring)\n        return (with_open + with_close + without) % MOD\n\n    result = count_subsequences(2 * n, n, n, s)\n    return str(result)"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_regular(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    n, s = map(str, stdin.split(\"\\n\"))\n    n = int(n)\n    s = s.replace(\"(\", \"\").replace(\")\", \"\")\n    MOD = 1000000007\n\n    if len(s) % 2 != 0:\n        return \"0\"\n\n    total = pow(2, len(s) // 2, MOD)\n    for i in range(len(s) // 2 + 1):\n        for left in combinations(s, i):\n            right = s.replace(\"\".join(left), \"\")\n            if is_regular(\"\".join(left)) and is_regular(\"\".join(right)):\n                total -= pow(2, len(left) // 2, MOD) * pow(2, len(right) // 2, MOD)\n\n    return str(total % MOD)\n"
    },
    {
        "number": 4028,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split('\\n'))\n    n = int(n)\n\n    MOD = 1000000007\n    dp = [0] * (2 * n + 1)\n    dp[0] = 1\n\n    for i in range(len(s)):\n        new_dp = [0] * (2 * n + 1)\n        for j in range(i, len(s), 2):\n            if s[i:j + 1] == '()' * (j - i + 1):\n                for k in range(j - i + 1, 2 * n + 1):\n                    new_dp[k] += dp[k - (j - i + 1)]\n                    new_dp[k] %= MOD\n        dp = new_dp\n\n    return dp[2 * n]"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    swaps = 0\n    \n    # Check if the number is already divisible by 25\n    if n % 25 == 0:\n        return 0\n\n    # Check if it is possible to obtain a number that is divisible by 25\n    for digit in str(n):\n        if int(digit) % 5 != 0:\n            return -1\n\n    # Perform swaps\n    digits = [int(digit) for digit in str(n)]\n    for i in range(len(digits) - 1):\n        if digits[i] != 0:\n            continue\n        j = i + 1\n        while j < len(digits) and digits[j] == 0:\n            j += 1\n        if j == len(digits):\n            return -1\n        digits[i], digits[j] = digits[j], digits[i]\n        swaps += 1\n\n        # Check if the swapped number is divisible by 25\n        if int(''.join(map(str, digits))) % 25 == 0:\n            return swaps\n\n    return -1"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    moves = 0\n    digits = [int(x) for x in str(n)]\n    zero_idx = []\n\n    for i, digit in enumerate(digits):\n        if digit == 0:\n            zero_idx.append(i)\n        if digit % 5 == 0:\n            return str(moves)\n\n    if digits[-1] % 5 != 0:\n        return \"-1\"\n\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] % 5 == 0:\n            if i in zero_idx:\n                digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                zero_idx.remove(i)\n                moves += 1\n            elif i - 1 in zero_idx:\n                digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                zero_idx.remove(i - 1)\n                moves += 1\n            elif i + 1 in zero_idx:\n                digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                zero_idx.remove(i + 1)\n                moves += 1\n        elif digits[i] % 5 != 0 and digits[i] != 0:\n            if i + 1 in zero_idx:\n                digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                zero_idx.remove(i + 1)\n                moves += 1\n            elif i - 1 in zero_idx:\n                digits[i], digits[i - 1] = digits[i - 1], digits[i]\n                zero_idx.remove(i - 1)\n                moves += 1\n\n    if digits[0] % 5 != 0 and digits[0] != 0:\n        return \"-1\"\n\n    return str(moves)"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    n_str = str(n)\n    n_len = len(n_str)\n    count = 0\n    flag = False\n\n    for i in range(n_len - 1):\n        if n_str[i] == '0' and n_str[i + 1] != '0':\n            n_str = n_str[:i] + n_str[i + 1] + n_str[i] + n_str[i + 2:]\n            count += 1\n            flag = True\n            break\n\n    if not flag:\n        for i in range(n_len - 2):\n            if n_str[i] == '0' and n_str[i + 2] != '0':\n                n_str = n_str[:i] + n_str[i + 2] + n_str[i + 1] + n_str[i] + n_str[i + 3:]\n                count += 1\n                flag = True\n                break\n\n    if not flag:\n        return -1\n\n    while True:\n        flag = False\n        for i in range(n_len - 1):\n            if n_str[i] > n_str[i + 1]:\n                n_str = n_str[:i] + n_str[i + 1] + n_str[i] + n_str[i + 2:]\n                count += 1\n                flag = True\n                break\n\n        if not flag:\n            break\n\n    if int(n_str) % 25 != 0:\n        return -1\n    else:\n        return str(count)"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 25 != 0:\n        return -1\n\n    moves = 0\n    digits = [int(d) for d in str(n)]\n    for i in range(len(digits) - 1):\n        if digits[i] == 0 and digits[i + 1] == 0:\n            return -1\n        if digits[i] == 0:\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n            moves += 1\n\n    return moves\n"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def has_leading_zero(number: str) -> bool:\n        return number[0] == \"0\"\n\n    def is_divisible_by_25(number: int) -> bool:\n        return number % 25 == 0\n\n    def is_valid_number(number: str) -> bool:\n        return not has_leading_zero(number)\n\n    def swap_adjacent_digits(number: str, index: int) -> str:\n        return number[:index] + number[index + 1] + number[index] + number[index + 2 :]\n\n    n = stdin.strip()\n    if n[-1] == \"0\" and len(n) > 1:\n        return -1\n\n    min_moves = float(\"inf\")\n    queue = [(n, 0)]\n\n    while queue:\n        number, moves = queue.pop(0)\n\n        if is_divisible_by_25(int(number)):\n            min_moves = min(min_moves, moves)\n            continue\n\n        if not is_valid_number(number):\n            continue\n\n        for i in range(len(number) - 1):\n            new_number = swap_adjacent_digits(number, i)\n            queue.append((new_number, moves + 1))\n\n    return str(min_moves) if min_moves != float(\"inf\") else -1"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    n_str = str(n)\n    if n % 25 != 0:\n        return -1\n\n    moves = 0\n    for i in range(len(n_str) - 1):\n        if n_str[i] == \"0\":\n            moves += 1\n        if n_str[i] != \"0\" and int(n_str[i]) % 5 != 0 and int(n_str[i + 1]) % 5 != 0:\n            return -1\n\n    return moves\n"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 25 != 0:\n        return -1\n\n    moves = 0\n    while n != 0:\n        last_digit = n % 10\n        first_digit = n // 10 % 10\n        if last_digit == 0:\n            return -1\n        elif last_digit % 5 == 0 and first_digit % 5 == 0:\n            n //= 10\n            moves += 1\n        else:\n            return -1\n\n    return moves"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 25 != 0:\n        return -1\n    original_n = n\n    moves = 0\n    while n % 25 != 0:\n        n = int(str(n)[::-1])\n        n = int(str(n)[:-1])\n        n = int(str(n)[::-1])\n        moves += 2\n        if n == 0:\n            return -1\n    return moves\n\ndef"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 25 != 0:\n        return -1\n\n    def is_divisible_by_25(number: int) -> bool:\n        return number % 25 == 0\n\n    def is_leading_zero(number: int) -> bool:\n        return str(number).startswith(\"0\")\n\n    def swap_adjacent_digits(number: int, index: int) -> int:\n        str_number = str(number)\n        swapped_digit = str_number[index - 1 : index + 1]\n        swapped_digit = swapped_digit[1] + swapped_digit[0]\n        return int(str_number[:index - 1] + swapped_digit + str_number[index + 1:])\n\n    moves = 0\n    while not is_divisible_by_25(n):\n        if is_leading_zero(n):\n            return -1\n        for i in range(1, len(str(n))):\n            if not is_leading_zero(swap_adjacent_digits(n, i)):\n                n = swap_adjacent_digits(n, i)\n                moves += 1\n                break\n\n    return moves"
    },
    {
        "number": 4029,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    def is_divisible_by_25(num):\n        while num >= 25:\n            if num % 25 == 0:\n                return True\n            num //= 10\n        return False\n\n    def is_valid_number(num):\n        return num >= 1 and num <= 10 ** 18 and num // 10 or num % 10 != 0\n\n    def get_adjacent_numbers(num):\n        adjacent_numbers = set()\n        str_num = str(num)\n        for i in range(len(str_num) - 1):\n            adjacent_numbers.add(int(str_num[:i] + str_num[i + 1] + str_num[i] + str_num[i + 2:]))\n        return adjacent_numbers\n\n    queue = {n}\n    visited = set()\n    move_count = 0\n\n    while queue:\n        new_queue = set()\n        for num in queue:\n            if is_divisible_by_25(num):\n                return move_count\n            for adjacent_num in get_adjacent_numbers(num):\n                if adjacent_num not in visited and is_valid_number(adjacent_num):\n                    new_queue.add(adjacent_num)\n        visited.update(queue)\n        queue = new_queue\n        move_count += 1\n\n    return -1"
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    res = 0\n    colors = [0] * n\n\n    for i in range(n):\n        colors[i] = ord(s[i]) - 96\n\n    for i in range(n):\n        colors[i] = min(colors[i], n - colors[i] + 1)\n\n    res = max(colors)\n\n    output = \"{}\".format(res) + \"\\n\"\n    output += \" \".join(str(color) for color in colors)\n\n    return output"
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    res = 0\n    c = [0] * n\n\n    freq = [0] * 26\n    for i in range(n):\n        freq[ord(s[i]) - ord('a')] += 1\n\n    while True:\n        next_freq = [0] * 26\n        for i in range(26):\n            if freq[i] > 0:\n                next_freq[i] += freq[i]\n\n        for i in range(26):\n            if next_freq[i] > 0:\n                res += 1\n                for j in range(26):\n                    if freq[j] > 0:\n                        freq[j] -= next_freq[i]\n                        break\n\n        if all(x == 0 for x in freq):\n            break\n\n    for i in range(n):\n        c[i] = (ord(s[i]) - ord('a') + 1) % res + 1\n\n    return f\"{res}\\n{' '.join(str(x) for x in c)}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_sorted(coloring):\n        for i in range(1, len(s)):\n            if coloring[i] == coloring[i - 1]:\n                continue\n            if s[i] < s[i - 1]:\n                return False\n        return True\n\n    def dfs(index, color, coloring):\n        if index == n:\n            return is_sorted(coloring)\n\n        if coloring[index] != 0:\n            return dfs(index + 1, color, coloring)\n\n        for i in range(1, color + 1):\n            coloring[index] = i\n            if dfs(index + 1, max(color, i), coloring):\n                return True\n\n        coloring[index] = 0\n        return False\n\n    coloring = [0] * n\n    for color in range(1, n + 1):\n        if dfs(0, color, coloring):\n            res = color\n            break\n\n    return f\"{res}\\n{' '.join(map(str, coloring))}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_sorted(colored_s: List[int]) -> bool:\n        for i in range(1, len(colored_s)):\n            if colored_s[i] < colored_s[i - 1]:\n                return False\n        return True\n\n    def min_colors(s: str) -> int:\n        if len(s) <= 1:\n            return len(s)\n        if s[0] == s[-1]:\n            return min_colors(s[1:-1]) + 1\n        else:\n            return min(min_colors(s[1:]), min_colors(s[:-1]))\n\n    colors = [1] * n\n    max_colors = min_colors(s)\n\n    for i in range(n - 1, 0, -1):\n        if s[i] < s[i - 1]:\n            colors[i] = colors[i - 1] + 1\n        else:\n            colors[i] = colors[i - 1]\n\n    for i in range(n):\n        if colors[i] > max_colors:\n            max_colors = colors[i]\n\n    return f\"{max_colors}\\n{' '.join(map(str, colors))}\"\n"
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    # Create a set of unique characters in the string\n    unique_chars = set(s)\n\n    # Calculate the minimum number of colors needed to color the string\n    res = len(unique_chars)\n\n    # Create a coloring for the string using the minimum number of colors\n    coloring = []\n    color = 1\n    for char in s:\n        if char not in unique_chars:\n            coloring.append(coloring[-1])\n        else:\n            coloring.append(color)\n            unique_chars.remove(char)\n            color += 1\n\n    # Return the minimum number of colors and the coloring\n    return f\"{res}\\n{' '.join(str(color) for color in coloring)}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def min_swaps(s):\n        n = len(s)\n        cnt = [0] * 26\n        for c in s:\n            cnt[ord(c) - ord('a')] += 1\n\n        sorted_cnt = sorted(enumerate(cnt), key=lambda x: x[1], reverse=True)\n        colors = 0\n        for i in range(26):\n            if sorted_cnt[i][1] > 0:\n                colors += 1\n                if colors > 1 and sorted_cnt[i - 1][1] > 0:\n                    sorted_cnt[i][1], sorted_cnt[i - 1][1] = sorted_cnt[i - 1][1], sorted_cnt[i][1]\n                for j in range(i + 1, 26):\n                    if sorted_cnt[j][1] > 0:\n                        sorted_cnt[j][1] -= 1\n                        if sorted_cnt[j][1] == 0:\n                            break\n\n        return colors\n\n    def color_string(s, colors):\n        n = len(s)\n        cnt = [0] * 26\n        for c in s:\n            cnt[ord(c) - ord('a')] += 1\n\n        sorted_cnt = sorted(enumerate(cnt), key=lambda x: x[1], reverse=True)\n        color_map = {}\n        for i in range(26):\n            if sorted_cnt[i][1] > 0:\n                color_map[sorted_cnt[i][0]] = len(color_map) + 1\n\n        coloring = [0] * n\n        for i in range(n):\n            coloring[i] = color_map[ord(s[i]) - ord('a')]\n\n        return coloring\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    s = lines[1]\n\n    min_colors = min_swaps(s)\n    coloring = color_string(s, min_colors)\n\n    return f\"{min_colors}\\n{' '.join(map(str, coloring))}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_sorted(s: str) -> bool:\n        return all(s[i] <= s[i + 1] for i in range(len(s) - 1))\n\n    def can_swap(s: str, i: int, j: int) -> bool:\n        return s[i] != s[j] and (i == 0 or s[i - 1] <= s[j]) and (j == len(s) - 1 or s[i] <= s[j + 1])\n\n    def min_colors(s: str) -> int:\n        colors = [0] * len(s)\n        for i in range(len(s)):\n            colors[i] = 1\n            for j in range(i - 1, -1, -1):\n                if can_swap(s, j, i):\n                    colors[i] = max(colors[i], colors[j] + 1)\n        return max(colors)\n\n    colors = [0] * len(s)\n    min_color = min_colors(s)\n    for i in range(len(s)):\n        colors[i] = 1\n        for j in range(i - 1, -1, -1):\n            if can_swap(s, j, i):\n                colors[i] = max(colors[i], colors[j] + 1)\n            if colors[i] >= min_color:\n                break\n\n    return f\"{min_color}\\n{' '.join(map(str, colors))}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_sorted(s: str, coloring: list) -> bool:\n        for i in range(1, n):\n            if coloring[i] != coloring[i - 1] and s[i] < s[i - 1]:\n                return False\n        return True\n\n    def dfs(s: str, coloring: list, colors_used: set, current_color: int) -> int:\n        if is_sorted(s, coloring):\n            return min(colors_used)\n\n        for i in range(n):\n            if s[i] not in coloring:\n                coloring[i] = current_color\n                colors_used.add(current_color)\n                if dfs(s, coloring, colors_used, current_color + 1):\n                    return True\n                coloring[i] = None\n                colors_used.remove(current_color)\n\n        return False\n\n    coloring = [None] * n\n    colors_used = set()\n    current_color = 1\n\n    if dfs(s, coloring, colors_used, current_color):\n        print(len(colors_used))\n        print(\" \".join(map(str, coloring)))\n    else:\n        print(\"-1\")\n\n    return \"\" "
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = dp[i - 1] + 1 if i > 0 and s[i] == s[i - 1] else 1\n\n    res = dp[-1]\n\n    if res == 1:\n        return f\"{res}\\n{1} \" * n\n\n    coloring = [1] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            coloring[i] = coloring[i - 1]\n        else:\n            coloring[i] = coloring[i - 1] + 1\n\n    return f\"{res}\\n{' '.join(map(str, coloring))}\""
    },
    {
        "number": 4030,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    res = 0\n    c = [1] * n\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            res += 1\n            c[i + 1] = res\n\n    if res == 0:\n        c = [1] * n\n\n    return f\"{res}\\n{' '.join(map(str, c))}\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(s1: str, s2: str) -> bool:\n        for i in range(len(s2) - len(s1) + 1):\n            if s2[i:i + len(s1)] == s1:\n                return True\n        return False\n\n    def check_substrings(strings: List[str]) -> bool:\n        for i in range(len(strings)):\n            for j in range(i):\n                if not is_substring(strings[i], strings[j]):\n                    return False\n        return True\n\n    def find_permutation(strings: List[str]) -> List[str]:\n        for s in strings:\n            if s not in permutation:\n                permutation.append(s)\n                for sub in sorted([x for x in strings if x != s and x not in permutation], key=len, reverse=True):\n                    if is_substring(sub, s):\n                        permutation.append(sub)\n                        if check_substrings(permutation):\n                            return permutation\n                        else:\n                            permutation.pop()\n                permutation.pop()\n        return []\n\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    permutation = find_permutation(strings)\n\n    if permutation:\n        return \"YES\\n\" + \"\\n\".join(permutation)\n    else:\n        return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(s1: str, s2: str) -> bool:\n        for i in range(len(s2) - len(s1) + 1):\n            if s1 == s2[i:i + len(s1)]:\n                return True\n        return False\n\n    def find_first_position(s: str, strings: list) -> int:\n        for i, string in enumerate(strings):\n            if is_substring(s, string):\n                return i\n        return -1\n\n    def find_next_position(s: str, strings: list, start: int) -> int:\n        for i, string in enumerate(strings[start + 1:], start + 1):\n            if is_substring(s, string):\n                return i\n        return -1\n\n    def can_reorder(n: int, strings: list) -> bool:\n        for i in range(n):\n            if find_first_position(strings[i], strings[:i]) == -1:\n                if find_next_position(strings[i], strings, i) == -1:\n                    return False\n        return True\n\n    def reorder_strings(n: int, strings: list) -> list:\n        reordered_strings = []\n        for i in range(n):\n            if find_first_position(strings[i], reordered_strings) == -1:\n                if find_next_position(strings[i], strings, i) == -1:\n                    reordered_strings.append(strings[i])\n        return reordered_strings\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    strings = lines[1:]\n\n    if can_reorder(n, strings):\n        return \"YES\\n\" + \"\\n\".join(reorder_strings(n, strings))\n    else:\n        return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(a: str, b: str) -> bool:\n        return a in b\n\n    def is_valid(strings: List[str]) -> bool:\n        for i in range(1, len(strings)):\n            if not any(is_substring(strings[i], strings[j]) for j in range(i)):\n                return False\n        return True\n\n    def find_permutation(strings: List[str]) -> Optional[List[str]]:\n        for i in range(len(strings)):\n            if all(is_substring(strings[i], strings[j]) for j in range(i)):\n                continue\n            for j in range(i + 1, len(strings)):\n                if is_substring(strings[j], strings[i]):\n                    strings[i], strings[j] = strings[j], strings[i]\n                    result = find_permutation(strings)\n                    if result is not None:\n                        return result\n                    strings[i], strings[j] = strings[j], strings[i]\n            return None\n        return strings\n\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    if not is_valid(strings):\n        return \"NO\"\n\n    permutation = find_permutation(strings)\n    if permutation is None:\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(permutation) "
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    strings = sorted(stdin.split(\"\\n\")[1:], key=lambda x: len(x))\n\n    def is_substring(a: str, b: str) -> bool:\n        return a in b\n\n    def is_valid(sorted_strings: list) -> bool:\n        for i in range(1, len(sorted_strings)):\n            if not any(is_substring(sorted_strings[i], string) for string in sorted_strings[:i]):\n                return False\n        return True\n\n    for _ in range(len(strings)):\n        if is_valid(strings):\n            return \"YES\\n\" + \"\\n\".join(strings)\n        else:\n            strings = strings[1:] + [strings[0]]\n\n    return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(s1: str, s2: str) -> bool:\n        return s1 in s2\n\n    def find_best_string(strings: list[str]) -> str:\n        best_string = \"\"\n        for s in strings:\n            if not any(is_substring(s, x) for x in strings if x != s):\n                if len(s) > len(best_string):\n                    best_string = s\n        return best_string\n\n    def reorder_strings(strings: list[str]) -> list[str]:\n        reordered = []\n        while strings:\n            best_string = find_best_string(strings)\n            if not best_string:\n                return []\n            reordered.append(best_string)\n            strings.remove(best_string)\n        return reordered\n\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    result = reorder_strings(strings)\n    if not result:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(a: str, b: str) -> bool:\n        return a in b\n\n    def find_substrings(n: int, strings: List[str]) -> List[str]:\n        substrings = [strings[0]]\n        for i in range(1, n):\n            for j in range(len(substrings)):\n                if is_substring(strings[i], substrings[j]):\n                    substrings.insert(j + 1, strings[i])\n                    break\n            else:\n                substrings.append(strings[i])\n        return substrings\n\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    if n == 1:\n        return \"YES\\n\" + strings[0]\n\n    substrings = find_substrings(n, strings)\n\n    if len(substrings) == n:\n        return \"YES\\n\" + \"\\n\".join(substrings)\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_substring(string1: str, string2: str) -> bool:\n        return string1 in string2\n\n    result = []\n    for i in range(n):\n        if not any(is_substring(strings[i], s) for s in result):\n            result.append(strings[i])\n        else:\n            for j in range(i):\n                if is_substring(strings[i], result[j]):\n                    result.insert(j, strings[i])\n                    break\n\n    if len(result) == n:\n        return \"YES\\n\" + \"\\n\".join(result)\n    else:\n        return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_substring(a: str, b: str) -> bool:\n        i = 0\n        for c in b:\n            if i < len(a) and a[i] == c:\n                i += 1\n        return i == len(a)\n\n    def generate_order(order: list, remaining: list) -> bool:\n        if not remaining:\n            return True\n        for i, s in enumerate(remaining):\n            if all(is_substring(s, order[j]) for j in range(len(order)) if j != i):\n                if generate_order(order + [s], remaining[:i] + remaining[i+1:]):\n                    return True\n        return False\n\n    order = []\n    if generate_order(order, strings):\n        return \"YES\\n\" + \"\\n\".join(order)\n    else:\n        return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strings = sorted(stdin.split('\\n')[1:])\n    result = []\n\n    for string in strings:\n        if not result or all(substring not in string for substring in result):\n            result.append(string)\n\n    if len(result) == n:\n        return \"YES\\n\" + '\\n'.join(result)\n    else:\n        return \"NO\""
    },
    {
        "number": 4031,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strings = sorted(stdin.split('\\n')[1:], key=lambda x: len(x), reverse=True)\n    result = []\n\n    for i, s in enumerate(strings):\n        if not any(s in string for string in strings[i + 1:]):\n            result.append(s)\n        else:\n            break\n\n    if len(result) == n:\n        return \"YES\\n\" + '\\n'.join(result)\n    else:\n        return \"NO\""
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    problems = list(map(int, stdin.split()[2:]))\n\n    left = 0\n    right = n - 1\n    count = 0\n\n    while left <= right:\n        if problems[left] <= k:\n            count += 1\n            problems.pop(left)\n            n -= 1\n            right -= 1\n        elif problems[right] <= k:\n            count += 1\n            problems.pop(right)\n            n -= 1\n            right -= 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n    left, right = 0, n - 1\n    count = 0\n\n    while left <= right:\n        if arr[left] <= k:\n            count += 1\n            left += 1\n        elif arr[right] <= k:\n            count += 1\n            right -= 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    difficulties = list(map(int, stdin.split('\\n')[1].split()))\n    left = 0\n    right = n - 1\n    solved = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved += 1\n            difficulties.pop(left)\n            right -= 1\n            if not difficulties:\n                break\n        else:\n            left += 1\n\n        if right == n - 1 and difficulties[right] > k:\n            break\n\n    return str(solved)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    difficulties = list(map(int, stdin.readline().split()))\n\n    left, right = 0, n - 1\n    count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            count += 1\n            difficulties.pop(left)\n            n -= 1\n            right -= 1\n        elif difficulties[right] <= k:\n            count += 1\n            difficulties.pop(right)\n            n -= 1\n            right -= 1\n        else:\n            break\n\n    return str(count)\n"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    difficulties = list(map(int, stdin.readline().split()))\n\n    left, right = 0, n - 1\n    solved_problems = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            solved_problems += 1\n            difficulties.pop(left)\n            right -= 1\n        elif difficulties[right] <= k:\n            solved_problems += 1\n            difficulties.pop(right)\n            left += 1\n        else:\n            break\n\n    return str(solved_problems)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    problems = list(map(int, stdin.split()[2:]))\n    left, right = 0, n - 1\n    count = 0\n    while left <= right:\n        if problems[left] <= k:\n            count += 1\n            problems.pop(left)\n            right -= 1\n        else:\n            left += 1\n        if right < left:\n            break\n        if problems[right] <= k:\n            count += 1\n            problems.pop(right)\n            left -= 1\n        else:\n            right -= 1\n        if right < left:\n            break\n    return str(count)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    difficulties = list(map(int, stdin.split()[1].split()))\n\n    left_index = 0\n    right_index = n - 1\n    solved_problems = 0\n\n    while left_index <= right_index:\n        if difficulties[left_index] <= k:\n            solved_problems += 1\n            difficulties.pop(left_index)\n            n -= 1\n            right_index -= 1\n        elif difficulties[right_index] <= k:\n            solved_problems += 1\n            difficulties.pop(right_index)\n            n -= 1\n            left_index += 1\n        else:\n            break\n\n    return str(solved_problems)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    left = 0\n    right = len(a) - 1\n    count = 0\n    \n    while left <= right:\n        if a[left] <= k:\n            count += 1\n            a.pop(left)\n            right -= 1\n        elif a[right] <= k:\n            count += 1\n            a.pop(right)\n            left += 1\n        else:\n            break\n    \n    return str(count)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    difficulties = list(map(int, stdin.split()[2:]))\n\n    left, right = 0, n - 1\n    count = 0\n\n    while left <= right:\n        if difficulties[left] <= k:\n            count += 1\n            difficulties.pop(left)\n            n -= 1\n            right -= 1\n        elif difficulties[right] <= k:\n            count += 1\n            difficulties.pop(right)\n            n -= 1\n            right -= 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 4032,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    arr = list(map(int, stdin.split()[2:]))\n    left, right = 0, n - 1\n    count = 0\n\n    while left <= right:\n        if arr[left] <= k:\n            count += 1\n            arr.pop(left)\n            right -= 1\n        else:\n            left += 1\n\n        if right - left > 0 and arr[right] <= k:\n            count += 1\n            arr.pop(right)\n            right -= 1\n        elif right - left == 0:\n            break\n\n    return str(count)"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    return str(2 * (a + b))"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    def is_correct_coloring(width, height):\n        return (width + height == a + b) and (\n            (width == a and height == b) or\n            (width == b and height == a)\n        )\n    \n    min_perimeter = float('inf')\n    for width in range(1, a + b + 1):\n        height = a + b - width\n        if is_correct_coloring(width, height):\n            perimeter = 2 * (width + height)\n            min_perimeter = min(min_perimeter, perimeter)\n    \n    return str(min_perimeter)"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.strip().split())\n    perimeter = 2 * (a + b)\n    return str(perimeter)"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return str(4 * a)\n    return str(4 * min(a, b))"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    p = a + b\n    gcd = math.gcd(a, b)\n    perimeter = p * gcd\n    return str(perimeter) "
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    # The minimal perimeter is the sum of the shortest and longest sides of the colored rectangle.\n    # We need to find the minimum of all possible combinations of (a, b) that form a rectangle.\n    \n    # First, we find the GCD of a and b, so we can reduce the number of cases.\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    g = gcd(a, b)\n    a //= g\n    b //= g\n    \n    # Now, we can consider only cases where a and b are coprime.\n    # For each divisor d of a, we can consider a rectangle with sides a/d and b/d.\n    # We want to find the minimum perimeter among all such rectangles.\n    def min_perimeter(a, b):\n        p = a + b\n        min_p = float('inf')\n        for d in range(1, a + 1):\n            if a % d == 0:\n                p_ = a // d + b // d\n                if p_ * d == p and p_ < min_p:\n                    min_p = p_\n        return min_p\n    \n    return str(min_perimeter(a, b) * g)"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    def is_valid(a, b, n, m):\n        return a <= n and b <= m\n\n    def min_perimeter(a, b, n, m):\n        return 2 * (a + b)\n\n    n, m = a, b\n    while not is_valid(a, b, n, m):\n        if a > b:\n            n += 1\n        else:\n            m += 1\n\n    return str(min_perimeter(a, b, n, m))"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    return str(a + b)"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if a < b:\n        a, b = b, a\n\n    perimeter = 2 * (a + b) - 4\n\n    return str(perimeter)\n"
    },
    {
        "number": 4033,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if a > b:\n        a, b = b, a\n\n    if a == 0:\n        return str(b)\n    if b == 0:\n        return str(a)\n\n    gcd = math.gcd(a, b)\n    perimeter = 2 * (a + b - gcd)\n\n    return str(perimeter)"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    coloring = ['0'] * n\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            coloring[i + 1] = '1'\n\n    if s != ''.join(['0' if c == '0' else '1' for c in coloring]):\n        return \"NO\"\n    else:\n        return \"YES\\n\" + ''.join(coloring)\n\ndef"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n\n    if sorted(s) == s:\n        return \"YES\\n\" + \"0\" * n\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(s: str) -> bool:\n        return all(s[i] <= s[i + 1] for i in range(len(s) - 1))\n\n    def can_be_sorted(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] > s[i + 1]:\n                if i == 0 or s[i - 1] <= s[i + 1]:\n                    return True\n        return False\n\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if is_sorted(s):\n        return \"YES\\n\" + \"0\" * n\n    elif can_be_sorted(s):\n        result = []\n        for i in range(n):\n            if i == 0 or s[i - 1] > s[i]:\n                result.append(\"0\")\n            else:\n                result.append(\"1\")\n        return \"YES\\n\" + \"\".join(result)\n    else:\n        return \"NO\""
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n    colors = ['0'] * n\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            colors[i] = '1'\n            colors[i + 1] = '1' if colors[i + 1] == '0' else '0'\n\n    if s[-1] < s[-2]:\n        colors[-1] = '1'\n\n    if '11' in ''.join(colors) or '00' in ''.join(colors):\n        return 'NO'\n    else:\n        return 'YES\\n' + ''.join(colors)\n"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def can_sort(s: str, color: str) -> bool:\n        for i in range(n - 1):\n            if color[i] != color[i + 1] and s[i] > s[i + 1]:\n                return False\n        return True\n\n    for i in range(2 ** n):\n        color = bin(i)[2:].zfill(n)\n        if can_sort(s, color):\n            return \"YES\\n\" + color\n\n    return \"NO\"\n"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    color = ['0'] * n\n    sorted_s = sorted(s)\n    \n    for i in range(n):\n        if s[i] != sorted_s[i]:\n            for j in range(n):\n                if s[j] == sorted_s[i]:\n                    if color[j] == color[i]:\n                        break\n                    color[i], color[j] = color[j], color[i]\n                    break\n    \n    if s == sorted_s:\n        return 'YES\\n' + ''.join(color)\n    else:\n        return 'NO'"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_sorted(s: str) -> bool:\n        return all(s[i] <= s[i + 1] for i in range(n - 1))\n\n    def is_valid_swap(s: str, i: int, j: int) -> bool:\n        return s[i] != s[j] and (i == 0 or s[i - 1] <= s[j]) and (j == n - 1 or s[i] <= s[j + 1])\n\n    for coloring in product([0, 1], repeat=n):\n        if is_sorted(s):\n            return \"YES\\n\" + \"\".join(map(str, coloring))\n\n        for i in range(n - 1):\n            if is_valid_swap(s, i, i + 1):\n                new_coloring = coloring[:i] + (coloring[i + 1], coloring[i]) + coloring[i + 2:]\n                if is_sorted(\"\".join(s[i] if coloring[i] == 0 else s[i + 1] for i in range(n))):\n                    return \"YES\\n\" + \"\".join(map(str, new_coloring))\n\n    return \"NO\"\n"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    # Check if the string is already sorted\n    if s == ''.join(sorted(s)):\n        return \"YES\\n\" + '0' * n\n\n    # Check if the string can be sorted by swapping adjacent characters\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            s = list(s)\n            s[i], s[i + 1] = s[i + 1], s[i]\n            s = ''.join(s)\n            if s == ''.join(sorted(s)):\n                coloring = ['0'] * n\n                coloring[i] = '1'\n                coloring[i + 1] = '1'\n                return \"YES\\n\" + ''.join(coloring)\n\n    return \"NO\""
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    colors = ['0'] * n\n    sorted_s = sorted(s)\n\n    for i in range(n):\n        if s[i] != sorted_s[i]:\n            colors[i] = '1'\n\n    if colors.count('1') % 2 == 0:\n        return \"YES\\n\" + \"\".join(colors)\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 4034,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    color = ['0'] * n\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            color[i] = '1'\n            color[i + 1] = '0'\n\n    if all(c == '0' for c in color):\n        return \"YES\\n\" + \"\".join(color)\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1] and color[i] == color[i + 1]:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\".join(color)"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    lowest_price = -1\n\n    for i in range(25, 101):\n        consumption_tax_8 = i * 0.08\n        consumption_tax_10 = i * 0.1\n\n        if int(consumption_tax_8) == A and int(consumption_tax_10) == B:\n            if lowest_price == -1:\n                lowest_price = i\n            else:\n                lowest_price = min(lowest_price, i)\n\n    return str(lowest_price)"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    price = -1\n    for i in range(1, B + 1):\n        if (i * 100 // 120 == A) and (i * 100 // 110 == B):\n            price = i\n            break\n    return str(price)"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n\n    for price in range(1, A + 1):\n        tax_8 = price * 0.08\n        tax_10 = price * 0.1\n\n        if int(tax_8) == A and int(tax_10) == B:\n            return str(price)\n\n    return \"-1\""
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    min_price = -1\n\n    for price in range(1, 1000):\n        tax_8 = price * 0.08\n        tax_10 = price * 0.1\n\n        if int(tax_8) == A and int(tax_10) == B:\n            if min_price == -1 or price < min_price:\n                min_price = price\n\n    return str(min_price)\n"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    tax_rate = [8, 10]\n    tax_amount = [A, B]\n\n    for i in range(1, 1001):\n        tax = [0] * len(tax_rate)\n        for j in range(len(tax_rate)):\n            tax[j] = i * tax_rate[j] // 100\n\n        if tax[0] == tax_amount[0] and tax[1] == tax_amount[1]:\n            return str(i)\n\n    return \"-1\""
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    consumption_tax = [8, 10]\n    prices = []\n\n    for tax in consumption_tax:\n        for price in range(1, B + 1):\n            if A <= round(price * (tax / 100)) <= B:\n                prices.append(price)\n                break\n\n    if not prices:\n        return \"-1\"\n    else:\n        return str(min(prices))"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    for i in range(1, 1000):\n        tax_A = int(i * 0.08)\n        tax_B = int(i * 0.1)\n        if tax_A == A and tax_B == B:\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    found = False\n    for i in range(A, B + 1):\n        tax_8 = i * 0.08\n        tax_10 = i * 0.1\n        if int(tax_8) == A and int(tax_10) == B:\n            found = True\n            lowest_price = i\n            break\n    return str(lowest_price if found else -1)"
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    min_price = -1\n    for i in range(1, 1001):\n        tax_A = i * 0.08 // 1\n        tax_B = i * 0.1 // 1\n        if tax_A == A and tax_B == B:\n            if min_price == -1 or i < min_price:\n                min_price = i\n    return str(min_price)\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 4035,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    \n    for i in range(1, 101):\n        tax_8 = i * 0.08\n        tax_10 = i * 0.1\n        \n        if int(tax_8) == A and int(tax_10) == B:\n            return str(i)\n    \n    return \"-1\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n > 2 ** k:\n        return \"NO\"\n\n    a = [1] * k\n    current_sum = k\n\n    if current_sum == n:\n        return f\"YES\\n{' '.join(map(str, a))}\"\n\n    for i in range(k - 1, 0, -1):\n        if a[i] + 1 <= 2 * a[i]:\n            a[i - 1] = a[i] + 1\n            current_sum += 1\n\n        if current_sum == n:\n            return f\"YES\\n{' '.join(map(str, a))}\"\n\n    return \"NO\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n // k < 1:\n        return \"NO\"\n\n    a = [n // k] * k\n    remaining = n % k\n\n    for i in range(remaining):\n        a[i] += 1\n\n    return \"YES\\n\" + \" \".join(map(str, a)) + \"\\n\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k < 2:\n        return \"NO\"\n    if n % (k - 1) != 0:\n        return \"NO\"\n\n    x = n // (k - 1)\n    a = [x] * (k - 1)\n    a.append(n - (k - 1) * x)\n\n    if a[-1] == 0:\n        return \"NO\"\n\n    output = \"YES\\n\" + \" \".join(map(str, a)) + \"\\n\"\n    return output"
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        if n >= 1:\n            return \"YES\\n1\"\n        else:\n            return \"NO\"\n\n    a = [1] * k\n    current_sum = 1\n    for i in range(1, k):\n        if current_sum + a[i - 1] <= n - k + i:\n            a[i] = a[i - 1] + 1\n            current_sum += a[i]\n        elif current_sum + a[i - 1] == n - k + i:\n            break\n        else:\n            return \"NO\"\n\n    if current_sum == n:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n > k or n < 2 * k:\n        return \"NO\"\n\n    a = []\n    for i in range(1, k + 1):\n        if i == k:\n            a.append(n - sum(a))\n        else:\n            a.append(min(max(1, n - sum(a) - (k - i)), a[-1] + 1), a[-1] * 2))\n\n    if sum(a) != n:\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, a))\n"
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    if n > k:\n        return \"NO\"\n    \n    a = [1] * k\n    for i in range(k - 1):\n        a[i + 1] = min(2 * a[i], n - a[i] + 1)\n        \n    if sum(a) == n:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n < k:\n        return \"NO\"\n\n    a = [1] * k\n    total = n\n\n    for i in range(k - 1, -1, -1):\n        if total - i > 0:\n            a[i] = min(2 * a[i + 1], total - i + 1)\n        else:\n            a[i] = 1\n\n    if sum(a) == n:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n // k >= 2:\n        return \"NO\"\n    if n // k == 1:\n        if k % 2 == 0:\n            return \"NO\"\n        return \"YES\\n\" + \"1\\n\" * (k // 2) + \"2\\n\" * (k // 2 + k % 2)\n    if n % k == 0:\n        return \"YES\\n\" + \"1\\n\" * k\n    return \"NO\""
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n < k or n % k != 0:\n        return \"NO\"\n\n    a = [n // k] * k\n\n    for i in range(k - 1):\n        if a[i] < a[i + 1] <= 2 * a[i]:\n            continue\n        else:\n            return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, a))"
    },
    {
        "number": 4036,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n > 2**k:\n        return \"NO\"\n    elif n < k:\n        return \"NO\"\n    elif n == k:\n        return \"YES\\n\" + \"1 \" * k\n    elif n > k:\n        ans = [1] * k\n        for i in range(1, k):\n            ans[i] = max(1, min(2 * ans[i - 1], n - (k - i)))\n            if ans[i] > n - (k - i):\n                return \"NO\"\n        return \"YES\\n\" + \" \".join(map(str, ans))\n    else:\n        return \"NO\""
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(project_list: list, index: int, rating: int) -> bool:\n        if index < 0:\n            return rating >= 0\n        if rating < 0:\n            return False\n        if rating >= project_list[index][0]:\n            return is_valid(project_list, index - 1, rating + project_list[index][1])\n        return is_valid(project_list, index - 1, rating)\n\n    input_list = list(map(int, stdin.strip().split()))\n    n, r = input_list[0], input_list[1]\n    project_list = [input_list[2 + 2 * i:4 + 2 * i] for i in range(n)]\n\n    max_size = 0\n    for i in range(n):\n        if is_valid(project_list, n - 1, r):\n            max_size = n - i\n            break\n        project_list.pop()\n\n    return str(max_size)"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\n    def max_subset_size(a, b, r):\n        a_b_pairs = [(a[i], b[i]) for i in range(len(a))]\n        a_b_pairs.sort(key=lambda x: x[0], reverse=True)\n        a_b_pairs.sort(key=lambda x: x[1])\n\n        subset_size = 0\n        for i in range(len(a_b_pairs)):\n            if r >= a_b_pairs[i][0]:\n                r += a_b_pairs[i][1]\n                subset_size += 1\n                if r < 0:\n                    return subset_size\n            else:\n                break\n        return subset_size\n\n    lines = stdin.strip().split('\\n')\n    n, r = map(int, lines[0].split())\n    a = []\n    b = []\n    for i in range(1, n + 1):\n        a_i, b_i = map(int, lines[i].split())\n        a.append(a_i)\n        b.append(b_i)\n\n    result = max_subset_size(a, b, r)\n    return str(result)"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(a, b):\n        lo, hi = 0, len(a)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if a[mid] < b:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n\n    n, r = map(int, stdin.split())\n    projects = [list(map(int, input().split())) for _ in range(n)]\n    projects.sort(key=lambda x: x[0])\n\n    selected = []\n    for _, b in projects:\n        r += b\n        if r < 0:\n            break\n        selected.append((r, b))\n\n    max_size = len(selected)\n    for i in range(len(selected) - 1, -1, -1):\n        if selected[i][0] >= selected[i][1]:\n            max_size = i + 1\n            break\n\n    return str(max_size)"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n\n    for i in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n\n    count = 0\n\n    for a, b in sorted(projects, key=lambda x: x[1]):\n        if r >= a:\n            r += b\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split()[:2])\n    projects = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    projects.sort(key=lambda x: (-x[1], -x[0]))\n    count = 0\n\n    for a, b in projects:\n        if r >= a:\n            r += b\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def can_complete_project(project, rating):\n        return project[0] <= rating\n\n    def complete_project(project, rating):\n        return rating + project[1]\n\n    n, r = map(int, stdin.readline().split())\n    projects = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    dp = [0] * (r + 1)\n    for i in range(n):\n        new_dp = [0] * (r + 1)\n        for j in range(r + 1):\n            if can_complete_project(projects[i], j):\n                new_dp[complete_project(projects[i], j)] = max(dp[j], dp[complete_project(projects[i], j)] + 1)\n            else:\n                new_dp[j] = dp[j]\n        dp = new_dp\n\n    return str(max(dp))"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    projects = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: x[1])\n    result = []\n\n    for p in projects:\n        if p[0] <= r:\n            result.append(p)\n            r += p[1]\n        if r < 0:\n            break\n\n    return len(result)"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    projects = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: (-x[1], -x[0]))\n\n    count = 0\n    for project in projects:\n        if r >= project[0]:\n            r += project[1]\n            count += 1\n        if r < 0:\n            break\n\n    return str(count)"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def can_complete_project(project_index: int, rating: int) -> bool:\n        return rating >= projects[project_index][0]\n\n    def get_next_project(project_index: int, rating: int) -> int:\n        next_project = -1\n        for i in range(project_index + 1, n):\n            if can_complete_project(i, rating):\n                next_project = i\n                break\n        return next_project\n\n    def dfs(project_index: int, rating: int, count: int) -> int:\n        if project_index == n:\n            return count\n        if not can_complete_project(project_index, rating):\n            return 0\n        new_rating = rating + projects[project_index][1]\n        next_project = get_next_project(project_index, new_rating)\n        if next_project == -1:\n            return count + 1\n        return max(dfs(project_index + 1, new_rating, count + 1), dfs(next_project, rating, count))\n\n    lines = stdin.split('\\n')\n    n, rating = map(int, lines[0].split())\n    projects = [list(map(int, line.split())) for line in lines[1:]]\n    projects.sort(key=lambda x: x[0], reverse=True)\n\n    return str(dfs(0, rating, 0))"
    },
    {
        "number": 4037,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split('\\n')[0].split())\n    projects = []\n    for i in range(n):\n        a, b = map(int, stdin.split('\\n')[i + 1].split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: x[0] - x[1], reverse=True)\n\n    subset = []\n    for p in projects:\n        if r >= p[0]:\n            subset.append(p)\n            r += p[1]\n\n    return len(subset)"
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_palindromic(matrix):\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[n - i - 1][j]:\n                    return False\n                if matrix[i][j] != matrix[i][n - j - 1]:\n                    return False\n        return True\n\n    def backtrack(matrix, used):\n        if len(used) == n * n:\n            if is_palindromic(matrix):\n                return \"YES\"\n            return \"NO\"\n\n        row = len(used) // n\n        col = len(used) % n\n\n        for num in numbers:\n            if num not in used:\n                matrix[row][col] = num\n                used.append(num)\n\n                result = backtrack(matrix, used)\n                if result != \"NO\":\n                    return result\n\n                used.pop()\n                matrix[row][col] = 0\n\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n    result = backtrack(matrix, [])\n\n    if result == \"YES\":\n        return \"YES\\n\" + \"\\n\".join(\" \".join(str(matrix[i][j]) for j in range(n)) for i in range(n))\n    return result"
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[n - 1 - i][n - 1 - j]:\n                    return False\n        return True\n\n    def find_matrix(numbers, n, matrix, row):\n        if row == n:\n            if is_palindromic(matrix):\n                return True\n            else:\n                return False\n\n        for i in range(n):\n            if numbers[i] is not None and matrix[row][i] is None:\n                matrix[row][i] = numbers[i]\n                numbers[i] = None\n\n                if find_matrix(numbers, n, matrix, row + 1):\n                    return True\n\n                numbers[i] = matrix[row][i]\n                matrix[row][i] = None\n\n        return False\n\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    matrix = [[None] * n for _ in range(n)]\n\n    if find_matrix(numbers, n, matrix, 0):\n        return \"YES\\n\" + \"\\n\".join(\" \".join(str(matrix[i][j]) for j in range(n)) for i in range(n))\n    else:\n        return \"NO\""
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        for row in matrix:\n            if row != matrix[0]:\n                return False\n        for col in range(len(matrix[0])):\n            if [row[col] for row in matrix] != [matrix[i][0] for i in range(len(matrix))]:\n                return False\n        return True\n\n    def put_numbers(matrix, nums, row, col):\n        if row == len(matrix) and col == 0:\n            return True\n        if col == len(matrix[0]):\n            col = 0\n            row += 1\n\n        for num in nums:\n            if not matrix[row] or not matrix[row][col]:\n                matrix[row][col] = num\n                nums.remove(num)\n                if put_numbers(matrix, nums, row, col + 1):\n                    return True\n                matrix[row][col] = 0\n                nums.append(num)\n        return False\n\n    def print_matrix(matrix):\n        for row in matrix:\n            print(\" \".join(map(str, row)))\n\n    n = int(stdin.readline().strip())\n    nums = list(map(int, stdin.readline().strip().split()))\n\n    if len(nums) != n * n:\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n    put_numbers(matrix, nums, 0, 0)\n\n    if is_palindromic(matrix):\n        print(\"YES\")\n        print_matrix(matrix)\n        return \"\"\n    else:\n        return \"NO\""
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[n - i - 1][j] or matrix[i][j] != matrix[i][n - j - 1]:\n                    return False\n        return True\n\n    def fill_matrix(matrix, numbers, row, col):\n        if row == n - 1 and col == n:\n            return True\n        if col == n:\n            row += 1\n            col = 0\n        for i in range(len(numbers)):\n            matrix[row][col] = numbers[i]\n            if fill_matrix(matrix, numbers[:i] + numbers[i + 1:], row, col + 1):\n                return True\n        matrix[row][col] = 0\n        return False\n\n    n, numbers = map(int, stdin.split())\n    numbers = sorted(numbers)\n    matrix = [[0] * n for _ in range(n)]\n\n    if n == 1:\n        if len(numbers) == 1:\n            matrix[0][0] = numbers[0]\n            return \"YES\\n\" + str(matrix[0][0])\n        else:\n            return \"NO\"\n\n    if n % 2 == 0:\n        for i in range(n // 2):\n            matrix[i][i] = matrix[n - i - 1][i] = numbers.pop()\n            matrix[i][n - i - 1] = matrix[n - i - 1][n - i - 1] = numbers.pop()\n\n        for i in range(n // 2 - 1):\n            matrix[n // 2][i] = matrix[n // 2][n - i - 1] = numbers.pop()\n            matrix[n - i - 1][n // 2] = matrix[i][n // 2] = numbers.pop()\n\n    else:\n        for i in range(n // 2):\n            matrix[i][i] = matrix[n - i - 1][i] = numbers.pop()\n            matrix[i][n - i - 1] = matrix[n - i - 1][n - i - 1] = numbers.pop()\n\n        matrix[n // 2][n // 2] = numbers.pop()\n\n    if not fill_matrix(matrix, numbers, 0, 0) or not is_palindromic(matrix):\n        return \"NO\"\n\n    output = \"YES\\n\"\n    for row in matrix:\n        output += \" \".join(map(str, row)) + \"\\n\"\n    return output"
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        rows_reversed = matrix[::-1]\n        columns_reversed = [row[::-1] for row in matrix]\n        return matrix == rows_reversed and matrix == columns_reversed\n\n    def backtrack(numbers, n, matrix, row):\n        if row == n:\n            if is_palindromic(matrix):\n                return matrix\n            else:\n                return None\n\n        for i in range(n):\n            if not used_columns[i] and not used_rows[row]:\n                matrix[row][i] = numbers[row * n + i]\n                used_rows[row] = True\n                used_columns[i] = True\n\n                result = backtrack(numbers, n, matrix, row + 1)\n                if result is not None:\n                    return result\n\n                matrix[row][i] = 0\n                used_rows[row] = False\n                used_columns[i] = False\n\n        return None\n\n    n = int(stdin.readline())\n    numbers = list(map(int, stdin.readline().split()))\n    if len(numbers) != n * n:\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n    used_rows = [False] * n\n    used_columns = [False] * n\n\n    result = backtrack(numbers, n, matrix, 0)\n    if result is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(\" \".join(str(x) for x in row) for row in result)"
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        return matrix == matrix[::-1] and all(matrix[i][j] == matrix[j][i] for i in range(n) for j in range(n))\n\n    def fill_matrix(matrix, numbers, row):\n        if row == n:\n            return matrix if is_palindromic(matrix) else None\n        for i in range(n):\n            if numbers[i] is not None:\n                matrix[row][i] = numbers[i]\n                numbers[i] = None\n                result = fill_matrix(matrix, numbers, row + 1)\n                if result is not None:\n                    return result\n                numbers[i] = matrix[row][i]\n                matrix[row][i] = 0\n        return None\n\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n    matrix = [[0] * n for _ in range(n)]\n\n    result = fill_matrix(matrix, numbers, 0)\n    if result is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(\" \".join(str(x) for x in row) for row in result) "
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[n - i - 1][j]:\n                    return False\n                if matrix[i][j] != matrix[i][n - j - 1]:\n                    return False\n        return True\n\n    def fill_matrix(matrix: List[List[int]], numbers: List[int]) -> bool:\n        if not numbers:\n            return True\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    matrix[i][j] = numbers[0]\n                    if fill_matrix(matrix, numbers[1:]):\n                        return True\n                    matrix[i][j] = 0\n        return False\n\n    n, numbers = map(int, stdin.split())\n    numbers = list(map(int, numbers))\n\n    if n == 1:\n        return f\"YES\\n{numbers[0]}\"\n\n    matrix = [[0] * n for _ in range(n)]\n    fill_matrix(matrix, numbers)\n\n    if is_palindromic(matrix):\n        return f\"YES\\n{' '.join(' '.join(str(x) for x in row) for row in matrix)}\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(matrix):\n        return matrix == matrix[::-1] and all(row == row[::-1] for row in matrix)\n\n    def generate_matrix(numbers, n):\n        if not numbers:\n            return [[]]\n        for i in range(len(numbers) - n + 1):\n            row = numbers[i:i + n]\n            if len(set(row)) == n:\n                for matrix in generate_matrix(numbers[:i] + numbers[i + n:], n):\n                    if len(matrix) % n == 0:\n                        yield matrix + [row]\n                    else:\n                        yield matrix\n\n    n, *numbers = map(int, stdin.split())\n    numbers.sort()\n\n    for matrix in generate_matrix(numbers, n):\n        if is_palindrome(matrix):\n            return \"YES\\n\" + \"\\n\".join(\" \".join(str(x) for x in row) for row in matrix)\n\n    return \"NO\""
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix: List[List[int]]) -> bool:\n        reversed_rows = matrix[::-1]\n        reversed_cols = [row[::-1] for row in matrix]\n        return matrix == reversed_rows and matrix == reversed_cols\n\n    def backtrack(matrix: List[List[int]], row: int, used: Set[int]) -> bool:\n        if row == n:\n            return True\n        for col in range(n):\n            if matrix[row][col] == 0 and n * row + col + 1 in used:\n                continue\n            matrix[row][col] = n * row + col + 1\n            used.add(n * row + col + 1)\n            if backtrack(matrix, row + 1, used):\n                return True\n            used.remove(n * row + col + 1)\n            matrix[row][col] = 0\n        return False\n\n    def print_matrix(matrix: List[List[int]]) -> str:\n        output = \"\"\n        for row in matrix:\n            output += \" \".join(map(str, row)) + \"\\n\"\n        return output\n\n    n, numbers = map(int, stdin.split())\n    matrix = [[0] * n for _ in range(n)]\n    used = set()\n\n    if n == 1:\n        if numbers[0] == 1:\n            return \"YES\\n1\"\n        else:\n            return \"NO\"\n\n    if n > 1 and len(numbers) != n * n:\n        return \"NO\"\n\n    if n == 2:\n        if numbers.count(1) == 2 and numbers.count(2) == 2:\n            matrix[0][0] = 1\n            matrix[0][1] = 2\n            matrix[1][0] = 2\n            matrix[1][1] = 1\n            return \"YES\\n\" + print_matrix(matrix)\n        else:\n            return \"NO\"\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                for num in numbers:\n                    if num not in used and (i * n + j + 1) * (j * n + i + 1) == num:\n                        matrix[i][j] = num\n                        used.add(num)\n                        break\n\n    if is_palindromic(matrix):\n        return \"YES\\n\" + print_matrix(matrix)\n    else:\n        return \"NO\""
    },
    {
        "number": 4038,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix):\n        return matrix == matrix[::-1] and all(matrix[i][j] == matrix[j][i] for i in range(n) for j in range(n))\n\n    n, numbers = map(int, stdin.split('\\n'))\n    numbers = numbers.split()\n    numbers = list(map(int, numbers))\n\n    if len(numbers) != n**2:\n        return \"NO\"\n\n    matrix = [numbers[i:i+n] for i in range(0, n**2, n)]\n\n    if is_palindromic(matrix):\n        return \"YES\\n\" + \"\\n\".join(\" \".join(str(x) for x in row) for row in matrix)\n    else:\n        return \"NO\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = [list(map(int, input().split())) for _ in range(n)]\n    projects.sort(key=lambda x: x[0], reverse=True)\n\n    for a, b in projects:\n        if r < a:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n    \n    for i in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n        \n    projects.sort(key=lambda x: (-x[1], x[0]))\n    \n    for a, b in projects:\n        if r >= a:\n            r += b\n        else:\n            return \"NO\"\n        \n        if r < 0:\n            return \"NO\"\n        \n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    projects = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: (-x[0], -x[1]))\n\n    for a, b in projects:\n        if r >= a:\n            r += b\n        else:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n\n    projects.sort(reverse=True, key=lambda x: x[0])\n\n    for a, b in projects:\n        if a > r:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n\n    return \"YES\"\n\nn, r = map(int, input().split())\ninputs = []\nfor _ in range(n):\n    inputs.append(input().strip())\n\nresult = solution(\"\\n\".join(inputs))\nprint(result) "
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n    projects.sort(key=lambda x: (-x[0], x[1]))\n\n    for a, b in projects:\n        if a > r:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n    \n    for i in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n    \n    projects.sort(reverse=True, key=lambda x: (x[1], -x[0]))\n    \n    for a, b in projects:\n        if a > r:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n    \n    return \"YES\"\n"
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    projects = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    projects.sort(key=lambda x: x[0])\n\n    for i in range(n):\n        required_rating, rating_change = projects[i]\n        if required_rating <= r:\n            r += rating_change\n            if r < 0:\n                return \"NO\"\n        else:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, r = map(int, input_list[0].split())\n    projects = []\n    for i in range(1, n+1):\n        a, b = map(int, input_list[i].split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: x[0])\n    for i in range(n):\n        required_rating = projects[i][0]\n        rating_change = projects[i][1]\n        if r < required_rating:\n            return \"NO\"\n        r += rating_change\n        if r < 0:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    projects = []\n\n    for i in range(n):\n        a, b = map(int, input().split())\n        projects.append((a, b))\n\n    projects.sort(key=lambda x: (-x[0], x[1]))\n\n    for a, b in projects:\n        if a > r:\n            return \"NO\"\n        r += b\n        if r < 0:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 4039,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(str, stdin.split()))\n    n, r = int(input_list[0]), int(input_list[1])\n    projects = input_list[2:]\n\n    for i in range(0, len(projects), 2):\n        a_i = int(projects[i])\n        b_i = int(projects[i + 1])\n\n        if r >= a_i:\n            r += b_i\n            if r < 0:\n                return \"NO\"\n        else:\n            return \"NO\"\n\n    return \"YES\""
    }
]