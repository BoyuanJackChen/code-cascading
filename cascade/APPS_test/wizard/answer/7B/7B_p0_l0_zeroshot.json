[
    {
        "number": 4000,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_parent(parent, u):\n        if parent[u] != u:\n            parent[u] = find_parent(parent, parent[u])\n        return parent[u]\n\n    def kruskal(edges, n):\n        parent = list(range(n + 1))\n        edges.sort(key=lambda x: x[2])\n        mst = []\n        for edge in edges:\n            u, v, w = edge\n            if find_parent(parent, u) != find_parent(parent, v):\n                mst.append(edge)\n                union(parent, u, v)\n                if len(mst) == n - 1:\n                    break\n        return mst\n\n    def union(parent, u, v):\n        parent[find_parent(parent, u)] = find_parent(parent, v)\n\n    def simple_paths(mst, a, b, c):\n        paths = []\n        for edge in mst:\n            u, v, w = edge\n            if a in (u, v) and b in (u, v) and c in (u, v):\n                paths.append(edge)\n        return paths\n\n    def max_edges(paths):\n        return len(paths)\n\n    def find_vertices(n):\n        a, b, c = random.sample(range(1, n + 1), 3)\n        while a == b or a == c or b == c:\n            a, b, c = random.sample(range(1, n + 1), 3)\n        return a, b, c\n\n    def main(n, edges):\n        mst = kruskal(edges, n)\n        a, b, c = find_vertices(n)\n        paths = simple_paths(mst, a, b, c)\n        res = max_edges(paths)\n        return res, a, b, c\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        edges = [tuple(map(int, line.split())) for line in lines[1:]]\n        return n, edges\n\n    n, edges = parse_input(stdin)\n    res, a, b, c = main(n, edges)\n    return f\"{res}\\n{a} {b} {c}\"\n"
    },
    {
        "number": 4001,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    divisors = list(map(int, input_data[1].split()))\n\n    x_divisors = []\n    y_divisors = []\n\n    for divisor in divisors:\n        if divisor % 2 == 1:\n            x_divisors.append(divisor)\n        else:\n            y_divisors.append(divisor)\n\n    x_divisors.sort()\n    y_divisors.sort()\n\n    x = 1\n    y = 1\n\n    for divisor in x_divisors:\n        x *= divisor\n\n    for divisor in y_divisors:\n        y *= divisor\n\n    return f\"{x}\\n{y}\"\n"
    },
    {
        "number": 4002,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_max_sum(row: list, k: int) -> int:\n        row.sort(reverse=True)\n        total_sum = sum(row)\n        if total_sum % k == 0:\n            return total_sum\n        max_sum = 0\n        for i in range(len(row)):\n            if row[i] % k == 0:\n                max_sum = max(max_sum, row[i])\n            else:\n                max_sum = max(max_sum, row[i] - row[i] % k)\n        return max_sum * len(row)\n\n    n, m, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        matrix.append(row)\n\n    max_sum = 0\n    for row in matrix:\n        max_sum = max(max_sum, find_max_sum(row, k))\n\n    return str(max_sum)\n"
    },
    {
        "number": 4003,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def is_increasing(sequence):\n        return all(sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1))\n\n    def find_longest_increasing_sequence(sequence):\n        longest_sequence = []\n        current_sequence = []\n        for element in sequence:\n            if not current_sequence or element > current_sequence[-1]:\n                current_sequence.append(element)\n            else:\n                longest_sequence = max(longest_sequence, current_sequence, key=len)\n                current_sequence = [element]\n        return max(longest_sequence, current_sequence, key=len)\n\n    longest_increasing_sequence = find_longest_increasing_sequence(a)\n    k = len(longest_increasing_sequence)\n    s = ''.join('L' if a[i] == longest_increasing_sequence[i] else 'R' for i in range(k))\n\n    return f\"{k}\\n{s}\" "
    },
    {
        "number": 4004,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_possible(a, D):\n        return all(a[0] + D == a[i] for i in range(1, len(a)))\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return -1\n\n    left, right = 0, max(a)\n    while left <= right:\n        mid = (left + right) // 2\n        if is_possible(a, mid):\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left > max(a):\n        return -1\n\n    return left - 1\n"
    },
    {
        "number": 4005,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    white_sheet = [int(x) for x in input_data[0].split()]\n    black_sheets = [int(x) for x in input_data[1].split()]\n\n    # Check if the white sheet can be seen\n    if white_sheet[0] < black_sheets[2] and white_sheet[1] < black_sheets[5] and white_sheet[2] > black_sheets[0] and white_sheet[3] > black_sheets[1]:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4006,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.strip())\n    def f(x):\n        while x % 10 == 0:\n            x //= 10\n            x += 1\n        return x\n\n    def dfs(x, visited):\n        if x in visited:\n            return 0\n        visited.add(x)\n        return 1 + dfs(f(x), visited)\n\n    return dfs(n, set())\n"
    },
    {
        "number": 4007,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(f):\n        for i in range(n):\n            if f[i] == 0:\n                continue\n            if f[i] == i:\n                return False\n            if f[f[i] - 1] != 0:\n                return False\n        return True\n\n    def fill_gifts(f):\n        for i in range(n):\n            if f[i] == 0:\n                for j in range(1, n + 1):\n                    if f[j - 1] == 0:\n                        f[i] = j\n                        break\n        return f\n\n    def find_solution(f):\n        if is_valid(f):\n            return f\n        for i in range(n):\n            if f[i] == 0:\n                for j in range(1, n + 1):\n                    if f[j - 1] == 0:\n                        f[i] = j\n                        if is_valid(f):\n                            return f\n                        f[i] = 0\n        return None\n\n    f = fill_gifts(f)\n    solution = find_solution(f)\n    if solution is None:\n        return \"No solution\"\n    return \" \".join(map(str, [n] * n + solution))\n"
    },
    {
        "number": 4008,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if k > n:\n        return \"NO\"\n\n    colors = [0] * k\n    for i in range(n):\n        color = a[i] % k\n        if colors[color - 1] == 0:\n            colors[color - 1] = i + 1\n        else:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 4009,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, x, y = map(int, input_data[0].split())\n    number = input_data[1]\n\n    # Convert the number to an integer\n    number_int = int(number[::-1], 2)\n\n    # Calculate the remainder\n    remainder = number_int % (10 ** x)\n\n    # Calculate the minimum number of operations\n    min_operations = 0\n    if remainder != 10 ** y:\n        min_operations = abs(remainder - 10 ** y)\n\n    return str(min_operations)\n"
    },
    {
        "number": 4010,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_palindrome(arr: list) -> bool:\n        n = len(arr)\n        for i in range(n // 2):\n            if arr[i] != arr[n - i - 1]:\n                return False\n        return True\n\n    def has_palindrome_subsequence(arr: list) -> bool:\n        n = len(arr)\n        for i in range(n):\n            for j in range(i + 2, n + 1, 2):\n                if is_palindrome(arr[i:j]):\n                    return True\n        return False\n\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        arr = list(map(int, stdin.readline().strip().split()))\n        if has_palindrome_subsequence(arr):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4011,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def f(x: int) -> int:\n        return f_dict[x]\n\n    n = int(stdin.split('\\n')[0])\n    a = stdin.split('\\n')[1]\n    f_dict = {i: int(x) for i, x in enumerate(stdin.split('\\n')[2].split(), 1)}\n\n    max_num = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            num = int(a[i:j])\n            f_num = int(''.join(map(str, map(f, map(int, str(num)))))\n            max_num = max(max_num, f_num)\n\n    return str(max_num)\n"
    },
    {
        "number": 4012,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(a, b, c):\n        return a <= b <= c and b % a == 0 and c % b == 0\n\n    def min_operations(a, b, c):\n        operations = 0\n        while a > 1:\n            a -= 1\n            operations += 1\n        while b > 1:\n            b -= 1\n            operations += 1\n        while c > 1:\n            c -= 1\n            operations += 1\n        return operations\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n\n    for i in range(1, t + 1):\n        a, b, c = map(int, stdin.split('\\n')[i].split())\n        if is_valid(a, b, c):\n            output.append(0)\n            output.append(f\"{a} {b} {c}\")\n        else:\n            operations = min_operations(a, b, c)\n            output.append(operations)\n            output.append(f\"{a} {b} {c}\")\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4013,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    instability = max(a) - min(a)\n\n    for i in range(n):\n        a_new = a.copy()\n        a_new.pop(i)\n        instability_new = max(a_new) - min(a_new)\n        if instability_new < instability:\n            instability = instability_new\n\n    return str(instability)\n"
    },
    {
        "number": 4014,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_possible(n, m, s, d, c):\n        days = [0] * n\n        for i in range(m):\n            if s[i] < d[i]:\n                for j in range(s[i], d[i] - c[i]):\n                    if days[j] == 0:\n                        days[j] = i + 1\n                    else:\n                        return False\n            else:\n                return False\n        return True\n\n    def find_schedule(n, m, s, d, c):\n        days = [0] * n\n        for i in range(m):\n            if s[i] < d[i]:\n                for j in range(s[i], d[i] - c[i]):\n                    if days[j] == 0:\n                        days[j] = i + 1\n                    else:\n                        return None\n            else:\n                return None\n        return days\n\n    n, m = map(int, stdin.split()[:2])\n    s = [0] * m\n    d = [0] * m\n    c = [0] * m\n    for i in range(m):\n        s[i], d[i], c[i] = map(int, stdin.split()[2 + 3 * i: 5 + 3 * i])\n\n    if is_possible(n, m, s, d, c):\n        schedule = find_schedule(n, m, s, d, c)\n        if schedule is None:\n            return -1\n        return schedule\n    else:\n        return -1\n"
    },
    {
        "number": 4015,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split())\n\n    if n == m:\n        return 0\n\n    if n > m:\n        return -1\n\n    moves = 0\n    while n != m:\n        if n % 2 == 0 and m % 2 == 0:\n            n //= 2\n            m //= 2\n        elif n % 3 == 0 and m % 3 == 0:\n            n //= 3\n            m //= 3\n        else:\n            return -1\n        moves += 1\n\n    return moves\n"
    },
    {
        "number": 4016,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split()[:2])\n    t = stdin.split()[2]\n\n    s = t * (k // len(t) + 1)\n    return s[:k]\n"
    },
    {
        "number": 4017,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_good(arr):\n        return any(sum(arr) == arr[i] for i in range(len(arr)))\n\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n\n    nice_indices = [i for i in range(n) if is_good(arr[:i] + arr[i+1:])]\n\n    k = len(nice_indices)\n    output = f\"{k}\\n\"\n\n    if k > 0:\n        output += \" \".join(map(str, nice_indices))\n\n    return output\n"
    },
    {
        "number": 4018,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    s = input_data[1]\n\n    if k > 2**n:\n        return -1\n\n    def is_subsequence(t: str) -> bool:\n        i = 0\n        for c in s:\n            if c == t[i]:\n                i += 1\n                if i == len(t):\n                    return True\n        return False\n\n    def count_subsequences(t: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if is_subsequence(t[:i+1]):\n                count += 1\n        return count\n\n    def binary_search(t: str) -> int:\n        left, right = 0, 2**n\n        while left < right:\n            mid = (left + right) // 2\n            if count_subsequences(t) <= mid:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    min_cost = 2**n\n    for i in range(1, n+1):\n        t = s[:i]\n        min_cost = min(min_cost, binary_search(t))\n\n    return min_cost if min_cost <= k else -1\n"
    },
    {
        "number": 4019,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_spanning_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        def dfs(v: int, visited: Set[int], parent: int) -> bool:\n            visited.add(v)\n            for u in graph[v]:\n                if u != parent and u not in visited:\n                    if dfs(u, visited, v):\n                        return True\n            return False\n\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        visited = set()\n        for i in range(1, n):\n            if i not in visited:\n                if not dfs(i, visited, -1):\n                    return []\n\n        result = []\n        for u, v in edges:\n            if u in visited and v in visited:\n                result.append((u, v))\n        return result\n\n    def check_spanning_tree(n: int, m: int, edges: List[Tuple[int, int]], D: int) -> bool:\n        spanning_tree = find_spanning_tree(n, m, edges)\n        if not spanning_tree:\n            return False\n\n        degree = [0] * n\n        for u, v in spanning_tree:\n            degree[u] += 1\n            degree[v] += 1\n\n        return degree[0] == D\n\n    def main(stdin: str) -> str:\n        n, m, D = map(int, stdin.split())\n        edges = [tuple(map(int, input().split())) for _ in range(m)]\n\n        if not check_spanning_tree(n, m, edges, D):\n            return \"NO\\n\"\n\n        spanning_tree = find_spanning_tree(n, m, edges)\n        if not spanning_tree:\n            return \"NO\\n\"\n\n        return \"YES\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), spanning_tree)) + \"\\n\"\n\n    return main(stdin)\n"
    },
    {
        "number": 4020,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    h1, m1 = map(int, input_data[0].split(':'))\n    h2, m2 = map(int, input_data[1].split(':'))\n\n    if m1 % 2 != m2 % 2:\n        raise ValueError(\"The contest lasts an even number of minutes\")\n\n    if h1 == h2 and m1 == m2:\n        raise ValueError(\"The contest lasts at least two minutes\")\n\n    if h1 == h2:\n        m3 = (m1 + m2) // 2\n        h3 = h1\n    else:\n        m3 = (m1 + m2) // 2\n        h3 = h1 + 1 if m3 == 0 else h1\n\n    return f\"{h3:02d}:{m3:02d}\"\n"
    },
    {
        "number": 4021,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a = int(stdin)\n    if a <= 64:\n        return str(a)\n    else:\n        return \"Invalid input\" "
    },
    {
        "number": 4022,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_intersection_length(segments: List[Tuple[int, int]]) -> int:\n        def segment_length(segment: Tuple[int, int]) -> int:\n            return segment[1] - segment[0] + 1\n\n        def intersection_length(segment1: Tuple[int, int], segment2: Tuple[int, int]) -> int:\n            left = max(segment1[0], segment2[0])\n            right = min(segment1[1], segment2[1])\n            return max(0, right - left + 1)\n\n        max_length = 0\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                max_length = max(max_length, intersection_length(segments[i], segments[j]))\n        return max_length\n\n    def remove_segment(segments: List[Tuple[int, int]]) -> int:\n        max_length = 0\n        for i in range(len(segments)):\n            remaining_segments = segments[:i] + segments[i + 1:]\n            max_length = max(max_length, max_intersection_length(remaining_segments))\n        return max_length\n\n    n = int(stdin)\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    return str(remove_segment(segments))\n"
    },
    {
        "number": 4023,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Check if all parts have the same height\n    if len(set(a)) == 1:\n        return \"YES\"\n\n    # Check if the wall has no empty spaces inside it\n    if max(a) - min(a) + 1 == n:\n        return \"YES\"\n\n    # Check if Vova can put bricks horizontally on the neighbouring parts of the wall\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            a[i] += 1\n            a[i - 1] += 1\n\n    # Check if all parts have the same height\n    if len(set(a)) == 1:\n        return \"YES\"\n\n    # Check if the wall has no empty spaces inside it\n    if max(a) - min(a) + 1 == n:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 4024,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    s = input_data[1]\n\n    if k > len(s):\n        return -1\n\n    def is_subsequence(t: str) -> bool:\n        i = 0\n        for char in s:\n            if char == t[i]:\n                i += 1\n                if i == len(t):\n                    return True\n        return False\n\n    def min_cost(t: str) -> int:\n        return n - len(t)\n\n    total_cost = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            t = s[i - 1:j]\n            if is_subsequence(t) and t not in S:\n                S.add(t)\n                total_cost += min_cost(t)\n                if len(S) == k:\n                    return total_cost\n    return -1\n"
    },
    {
        "number": 4025,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n\n    # Calculate the maximum number of days the cat can eat\n    max_days = min(a, b, c)\n\n    # Choose the day of the week to start the trip optimally\n    if a >= b and a >= c:\n        day = \"Monday\"\n    elif b >= a and b >= c:\n        day = \"Tuesday\"\n    else:\n        day = \"Wednesday\"\n\n    return f\"The cat can eat {max_days} days without additional food purchases, if Polycarp chooses {day} as the day of the week to start his trip.\" "
    },
    {
        "number": 4026,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_tile(tile, size):\n        for i in range(size):\n            for j in range(size):\n                if tile[i][j] != tile[size - j - 1][size - i - 1]:\n                    return False\n        return True\n\n    def is_valid_placement(tile, square, size):\n        for i in range(size):\n            for j in range(size):\n                if square[i][j] != 0 and square[i][j] != tile[0][0]:\n                    return False\n        return True\n\n    def is_valid_symmetric(square, size):\n        for i in range(size):\n            for j in range(size):\n                if square[i][j] != square[j][i]:\n                    return False\n        return True\n\n    def is_valid_placement_and_symmetric(tile, square, size):\n        return is_valid_placement(tile, square, size) and is_valid_symmetric(square, size)\n\n    def construct_square(n, m, tiles, size):\n        square = [[0] * size for _ in range(size)]\n        for i in range(size):\n            for j in range(size):\n                for tile_type in range(n):\n                    if is_valid_placement_and_symmetric(tiles[tile_type], square, size):\n                        square[i][j] = tiles[tile_type][0][0]\n                        if is_valid_tile(tiles[tile_type], size):\n                            break\n        return square\n\n    def main(stdin: str) -> str:\n        input_data = stdin.split('\\n')\n        t = int(input_data[0])\n        output = []\n        for i in range(1, len(input_data), 2 * t + 1):\n            n, m = map(int, input_data[i].split())\n            tiles = [list(map(int, input_data[j].split())) for j in range(i + 1, i + 1 + 2 * n)]\n            square = construct_square(n, m, tiles, m)\n            if is_valid_symmetric(square, m):\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n        return '\\n'.join(output)\n\n    return main(stdin) "
    },
    {
        "number": 4027,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n\n    # Calculate the sum of the first n numbers\n    total_sum = (n * (n + 1)) // 2\n\n    # Calculate the minimum possible difference between the sums of A and B\n    min_diff = abs(total_sum // 2 - (total_sum - total_sum // 2))\n\n    # Calculate the maximum possible difference between the sums of A and B\n    max_diff = abs(total_sum // 2 - (total_sum - total_sum // 2 - 1))\n\n    # Calculate the minimum possible difference between the sums of A and B\n    if min_diff > max_diff:\n        min_diff = max_diff\n\n    return str(min_diff)\n"
    },
    {
        "number": 4028,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, s = map(str, stdin.split())\n    n = int(n)\n    s = s[1:-1]\n    MOD = 10**9 + 7\n\n    def count_regular_bracket_sequences(s, n):\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 1 if s == \"(\" else 0\n        if len(s) == 2:\n            return 1 if s == \"()()\" else 0\n\n        count = 0\n        for i in range(len(s) - 2 * n + 1):\n            substring = s[i:i + 2 * n]\n            if substring.count(\"(\") == substring.count(\")\") and substring.count(\"(\") % 2 == 0:\n                count += count_regular_bracket_sequences(substring, n)\n                count %= MOD\n        return count\n\n    return str(count_regular_bracket_sequences(s, n))\n"
    },
    {
        "number": 4029,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.strip())\n    num_str = str(n)\n    num_len = len(num_str)\n\n    # Check if the number is already divisible by 25\n    if n % 25 == 0:\n        return 0\n\n    # Initialize variables\n    moves = 0\n    last_digit = num_str[-1]\n    second_last_digit = num_str[-2]\n\n    # Swap the last two digits if the second last digit is 0\n    if second_last_digit == '0':\n        num_str = num_str[:-2] + last_digit + '0'\n        moves += 1\n\n    # Swap the last digit with the second last digit if the last digit is 0\n    if last_digit == '0':\n        num_str = num_str[:-1] + second_last_digit + '0'\n        moves += 1\n\n    # Swap the last two digits if the second last digit is 0\n    if second_last_digit == '0':\n        num_str = num_str[:-2] + last_digit + '0'\n        moves += 1\n\n    # Check if the number is divisible by 25\n    if int(num_str) % 25 == 0:\n        return moves\n\n    # If the number is not divisible by 25, return -1\n    return -1\n"
    },
    {
        "number": 4030,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_sorted(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] > s[i + 1]:\n                return False\n        return True\n\n    def min_colors(s: str) -> int:\n        colors = set(s)\n        return len(colors)\n\n    def color_string(s: str, colors: int) -> List[int]:\n        color_map = {}\n        for i, c in enumerate(s):\n            if c not in color_map:\n                color_map[c] = i\n        return [color_map[c] for c in s]\n\n    def swap_colors(s: str, c: List[int], i: int, j: int) -> None:\n        c[i], c[j] = c[j], c[i]\n\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    if is_sorted(s):\n        res = 1\n        c = color_string(s, res)\n        print(res)\n        print(c)\n        return\n\n    res = min_colors(s)\n    c = color_string(s, res)\n\n    while not is_sorted(s):\n        i, j = 0, 1\n        while j < len(s) and c[i] == c[j]:\n            i += 1\n            j += 1\n        while j < len(s) and c[i] != c[j]:\n            j += 1\n        swap_colors(s, c, i, j)\n\n    print(res)\n    print(c)\n"
    },
    {
        "number": 4031,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_substring(s1: str, s2: str) -> bool:\n        for i in range(len(s2) - len(s1) + 1):\n            if s1 == s2[i:i+len(s1)]:\n                return True\n        return False\n\n    def is_valid(strings: List[str]) -> bool:\n        for i in range(len(strings)):\n            for j in range(i):\n                if is_substring(strings[i], strings[j]):\n                    return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    strings = stdin.splitlines()[1:]\n\n    if not is_valid(strings):\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(strings)\n"
    },
    {
        "number": 4032,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    left_count = 0\n    right_count = 0\n\n    for i in range(n):\n        if a[i] <= k:\n            if i == 0:\n                left_count += 1\n            elif i == n - 1:\n                right_count += 1\n            else:\n                left_count += 1\n                right_count += 1\n\n    return max(left_count, right_count)\n"
    },
    {
        "number": 4033,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    perimeter = 2 * (a + b)\n    return str(perimeter)\n"
    },
    {
        "number": 4034,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    # Check if the string is already sorted\n    if sorted(s) == list(s):\n        return \"YES\\n\" + ''.join(['0'] * n)\n\n    # Check if it's possible to color the string so that it can become sorted\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            return \"NO\"\n\n    # If the string is already sorted, return YES with all characters colored the same\n    return \"YES\\n\" + ''.join(['0'] * n)\n"
    },
    {
        "number": 4035,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    price = 0\n    while True:\n        price += 1\n        tax_8 = round(price * 0.08)\n        tax_10 = round(price * 0.10)\n        if tax_8 <= A and tax_10 <= B:\n            return price\n    return -1\n"
    },
    {
        "number": 4036,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split())\n    if n < k:\n        return \"NO\"\n\n    a = [0] * k\n    a[0] = n // k\n    for i in range(1, k):\n        a[i] = a[i - 1] // 2 + 1\n\n    if sum(a) == n and all(a[i] > 0 for i in range(k)) and all(a[i] < a[i + 1] <= 2 * a[i] for i in range(k - 1)):\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4037,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(rating: int) -> bool:\n        return 0 <= rating <= 30000\n\n    def can_complete_project(rating: int, project: tuple) -> bool:\n        required_rating, rating_change = project\n        return rating - required_rating >= 0\n\n    def update_rating(rating: int, project: tuple) -> int:\n        required_rating, rating_change = project\n        return rating - required_rating + rating_change\n\n    def find_max_subset_size(projects: list, rating: int) -> int:\n        if not projects:\n            return 0\n\n        project = projects[0]\n        if can_complete_project(rating, project):\n            updated_rating = update_rating(rating, project)\n            if is_valid(updated_rating):\n                return 1 + find_max_subset_size(projects[1:], updated_rating)\n\n        return find_max_subset_size(projects[1:], rating)\n\n    n, r = map(int, stdin.split()[:2])\n    projects = [tuple(map(int, stdin.split()[2 * i + 2 : 2 * i + 4])) for i in range(n)]\n\n    max_subset_size = find_max_subset_size(projects, r)\n    return str(max_subset_size)\n"
    },
    {
        "number": 4038,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_palindromic(matrix):\n        return all(matrix[i] == matrix[-i - 1] for i in range(n)) and all(matrix[i][j] == matrix[i][-j - 1] for i in range(n) for j in range(n))\n\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    if len(numbers) != n * n:\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n    used_numbers = set()\n\n    for i in range(n):\n        for j in range(n):\n            for num in numbers:\n                if num not in used_numbers:\n                    matrix[i][j] = num\n                    used_numbers.add(num)\n                    break\n\n    if is_palindromic(matrix):\n        return \"YES\\n\" + \"\\n\".join(str(row) for row in matrix)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4039,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, r = map(int, input_data[0].split())\n    projects = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Sort projects by required rating\n    projects.sort(key=lambda x: x[0])\n\n    # Check if it's possible to complete all projects\n    for i in range(n):\n        if r < projects[i][0]:\n            return \"NO\"\n        r += projects[i][1]\n        if r < 0:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 4040,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(a, c):\n        for i in range(1, m + 1):\n            if a[c[i - 1] - 1] != 0:\n                return False\n        return True\n\n    def move_platforms(c, d):\n        for i in range(1, m + 1):\n            while c[i - 1] > 0 and a[c[i - 1] - 1] == 0:\n                c[i - 1] -= 1\n            while c[i - 1] < n and a[c[i - 1] + 1] == i:\n                c[i - 1] += 1\n\n    n, m, d = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:]))\n\n    a = [0] * n\n    a[0] = 1\n    a[n] = 1\n\n    for i in range(1, m + 1):\n        c[i - 1] += 1\n\n    while True:\n        move_platforms(c, d)\n        if is_valid(a, c):\n            break\n\n    if a.count(0) == n:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, a))\n"
    },
    {
        "number": 4041,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, t = stdin.split('\\n')\n    s_list = list(s)\n    t_list = list(t)\n    max_len = 0\n    for i in range(len(s_list)):\n        if s_list[i] == t_list[0]:\n            j = 1\n            while j < len(t_list) and i < len(s_list) and s_list[i] == t_list[j]:\n                j += 1\n            if j == len(t_list):\n                max_len = max(max_len, i - len(t_list) + 1)\n    return max_len\n"
    },
    {
        "number": 4042,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x = float(stdin)\n    a = int(x * 1000000)\n    b = int(x * 1000000 + 1)\n    return f\"{a} {b}\"\n"
    },
    {
        "number": 4043,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(n, d, k):\n        if n < 2 or d < 1 or k < 1:\n            return False\n        if n == 2:\n            return d == 1 and k == 1\n        if k > n - 1:\n            return False\n        if d > n - 1:\n            return False\n        return True\n\n    def construct_tree(n, d, k):\n        if not is_valid(n, d, k):\n            return \"NO\"\n\n        def dfs(node, remaining_degree, depth):\n            if remaining_degree == 0:\n                return True\n            for neighbor in range(node + 1, n + 1):\n                if depth + 1 <= d and remaining_degree - 1 >= k:\n                    if dfs(neighbor, remaining_degree - 1, depth + 1):\n                        return True\n            return False\n\n        if not dfs(1, k, 1):\n            return \"NO\"\n\n        tree = []\n        for node in range(1, n):\n            for neighbor in range(node + 1, n + 1):\n                if dfs(node, k - 1, 1) and dfs(neighbor, k - 1, 1):\n                    tree.append((node, neighbor))\n                    break\n\n        return tree\n\n    n, d, k = map(int, stdin.split())\n    tree = construct_tree(n, d, k)\n    if tree == \"NO\":\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in tree)\n"
    },
    {
        "number": 4044,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, x = map(int, stdin.split())\n    n = a + b\n    s = \"\"\n    for i in range(n):\n        if i < a:\n            s += \"0\"\n        elif i < a + b - x:\n            s += \"1\"\n        else:\n            s += \"0\"\n    return s\n"
    },
    {
        "number": 4045,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    if n * 3 != len(s) + len(t):\n        return \"NO\"\n\n    res = \"\"\n    for _ in range(n):\n        res += \"a\"\n        res += \"b\"\n        res += \"c\"\n\n    if s in res or t in res:\n        return \"NO\"\n\n    return \"YES\\n\" + res\n"
    },
    {
        "number": 4046,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    q = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 2:\n        if q[0] == 1:\n            return \"1 2\"\n        elif q[0] == -1:\n            return \"-1\"\n        else:\n            return \"2 1\"\n\n    for i in range(n-1):\n        if q[i] < 0 or q[i] >= n:\n            return \"-1\"\n\n    p = [0] * n\n    p[0] = 1\n    for i in range(1, n):\n        p[i] = p[i-1] + q[i-1]\n\n    return \" \".join(map(str, p))\n"
    },
    {
        "number": 4047,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_coins = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(x[i] - x[j]) % 2 == 0:\n                min_coins += abs(x[i] - x[j]) // 2\n            else:\n                min_coins += abs(x[i] - x[j]) // 2 + 1\n\n    return str(min_coins)\n"
    },
    {
        "number": 4048,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    moves = 0\n    i = 1\n    j = 1\n    while i * j < N:\n        if i * (j + 1) > N:\n            i += 1\n        else:\n            j += 1\n        moves += 1\n    return moves\n"
    },
    {
        "number": 4049,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n\n    # Initialize the number of rounds Alice can win\n    min_win = 0\n    max_win = 0\n\n    # Iterate through all possible combinations of Alice's moves\n    for i in range(n + 1):\n        for j in range(n + 1):\n            for k in range(n + 1):\n                # Check if the current combination is valid\n                if i + j + k == n:\n                    # Calculate the number of rounds Alice can win\n                    num_win = (a.count('1') - b.count('1')) + (a.count('2') - b.count('2')) + (a.count('3') - b.count('3'))\n                    # Update the minimum and maximum number of rounds Alice can win\n                    min_win = min(min_win, num_win)\n                    max_win = max(max_win, num_win)\n\n    # Print the minimum and maximum number of rounds Alice can win\n    return f\"{min_win} {max_win}\"\n"
    },
    {
        "number": 4050,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def is_valid_block(block, blocks):\n        for other_block in blocks:\n            if block[0] < other_block[1] and block[1] > other_block[0]:\n                return False\n        return True\n\n    def find_blocks(a, n):\n        blocks = []\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                block = (i, j)\n                if is_valid_block(block, blocks):\n                    blocks.append(block)\n        return blocks\n\n    def sum_blocks(blocks, a):\n        sums = {}\n        for block in blocks:\n            sum_value = sum(a[block[0]:block[1] + 1])\n            if sum_value in sums:\n                sums[sum_value].append(block)\n            else:\n                sums[sum_value] = [block]\n        return sums\n\n    def find_max_blocks(sums):\n        max_blocks = []\n        for sum_value in sums:\n            max_blocks.extend(sums[sum_value])\n        return max_blocks\n\n    blocks = find_blocks(a, n)\n    sums = sum_blocks(blocks, a)\n    max_blocks = find_max_blocks(sums)\n\n    k = len(max_blocks)\n    for block in max_blocks:\n        print(block[0], block[1])\n\n    return str(k)\n"
    },
    {
        "number": 4051,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def build_stack(i):\n        stack = []\n        for j in range(i, n):\n            stack.append(a[j])\n        return stack\n\n    def arrange_stacks(stacks):\n        heights = [len(stack) for stack in stacks]\n        max_height = max(heights)\n        max_height_index = heights.index(max_height)\n        max_stack = stacks.pop(max_height_index)\n        max_height_value = max_stack.pop()\n        output.append(max_height_value)\n        for stack in stacks:\n            if stack[-1] < max_height_value:\n                stack.append(max_height_value)\n        return stacks\n\n    def shift_stacks(stacks):\n        for i in range(len(stacks) - 1):\n            if len(stacks[i]) < len(stacks[i + 1]):\n                stacks[i], stacks[i + 1] = stacks[i + 1], stacks[i]\n        return stacks\n\n    output = []\n    stacks = [build_stack(i) for i in range(n)]\n    while stacks:\n        stacks = arrange_stacks(stacks)\n        stacks = shift_stacks(stacks)\n\n    if output == sorted(a):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4052,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(s: str, i: int, j: int) -> str:\n        return s[:i] + s[j] + s[i + 1:j] + s[i] + s[i + 2:]\n\n    n, s, t = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    t = list(t)\n\n    if s == t:\n        return \"0\"\n\n    moves = []\n    for i in range(n - 1):\n        if s[i] != t[i]:\n            if s[i + 1] == t[i]:\n                moves.append((i, i + 1))\n            elif s[i] == t[i + 1]:\n                moves.append((i + 1, i))\n\n    if not moves:\n        return \"0\"\n\n    for i, j in moves:\n        s = swap(s, i, j)\n\n    if s == t:\n        return len(moves), \" \".join(str(c) for c in moves)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 4053,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    prefixes = set()\n    suffixes = set()\n\n    for i in range(1, 2 * n - 2):\n        if i <= n - 1:\n            prefixes.add(input_data[i])\n        else:\n            suffixes.add(input_data[i])\n\n    result = ['P'] * (2 * n - 2)\n\n    for i in range(1, n):\n        if input_data[i] in prefixes:\n            result[i - 1] = 'S'\n        else:\n            result[i - 1] = 'P'\n\n    for i in range(n, 2 * n - 2):\n        if input_data[i] in suffixes:\n            result[i - 1] = 'S'\n        else:\n            result[i - 1] = 'P'\n\n    return ''.join(result)\n"
    },
    {
        "number": 4054,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    a = [int(i) for i in input_list]\n    b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    d = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    e = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    f = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    g = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    h = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    j = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    m = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    o = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    p = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    q = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    r = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    s = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    t = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    u = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    w = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    y = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    z = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    for i in range(len(a)):\n        if a[i] == 1:\n            b[i] = 0\n            c[i] = 0\n            d[i] = 0\n            e[i] = 0\n            f[i] = 0\n            g[i] = 0\n            h[i] = 0\n            i[i] = 0\n            j[i] = 0\n            k[i] = 0\n            l[i] = 0"
    },
    {
        "number": 4055,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    k = 0\n    for i in range(1, n - 1):\n        if a[i - 1] == a[i + 1] == 1 and a[i] == 0:\n            k += 1\n\n    print(k)\n"
    },
    {
        "number": 4056,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    result = a[0]\n    for i in range(1, n):\n        result = lcm(result, a[i])\n\n    return str(result)\n"
    },
    {
        "number": 4057,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    coins = list(map(int, stdin.split('\\n')[1].split()))\n\n    coins.sort()\n    pockets = []\n    i = 0\n\n    while i < n:\n        pocket = [coins[i]]\n        j = i + 1\n        while j < n and coins[j] == pocket[-1]:\n            pocket.append(coins[j])\n            j += 1\n        pockets.append(pocket)\n        i = j\n\n    return len(pockets)\n"
    },
    {
        "number": 4058,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, r = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    heaters = []\n    for i in range(n):\n        if a[i] == 1:\n            heaters.append(i)\n\n    if not heaters:\n        return -1\n\n    heaters.sort()\n    heaters.append(n)\n\n    min_heaters = 0\n    for i in range(len(heaters) - 1):\n        min_heaters += heaters[i + 1] - heaters[i] - 1\n\n    if min_heaters >= r * n:\n        return min_heaters\n    else:\n        return -1\n"
    },
    {
        "number": 4059,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    count = 0\n\n    for A in range(1, N):\n        for B in range(1, N - A + 1):\n            C = N - A * B\n            if C > 0 and C % B == 0:\n                count += 1\n\n    return count\n"
    },
    {
        "number": 4060,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    count = 0\n    for i in range(n):\n        if s[i] == '(' and i < n - 1 and s[i + 1] == ')':\n            count += 1\n        elif s[i] == ')' and i > 0 and s[i - 1] == '(':\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4061,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, t = stdin.split('\\n')\n    s_list = list(s)\n    t_list = list(t)\n    max_len = 0\n    for i in range(len(s_list)):\n        if s_list[i] == t_list[0]:\n            j = 1\n            while j < len(t_list) and i < len(s_list) and s_list[i] == t_list[j]:\n                j += 1\n            if j == len(t_list):\n                max_len = max(max_len, i - len(t_list) + 1)\n    return max_len\n"
    },
    {
        "number": 4062,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c, d = map(int, stdin.split())\n    max_xy = 0\n    for x in range(a, b+1):\n        for y in range(c, d+1):\n            max_xy = max(max_xy, x*y)\n    return str(max_xy)\n"
    },
    {
        "number": 4063,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *d = map(int, stdin.split())\n    d.sort()\n    count = 0\n    for i in range(N):\n        if d[i] >= N//2:\n            count += 1\n    return count"
    },
    {
        "number": 4064,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_good_sleep(a: int, l: int, r: int) -> bool:\n        return l <= a <= r\n\n    def count_good_sleeping_times(a: List[int], l: int, r: int) -> int:\n        count = 0\n        for i in range(len(a)):\n            if is_good_sleep(a[i], l, r):\n                count += 1\n        return count\n\n    n, h, l, r = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n\n    max_count = 0\n    for i in range(n):\n        max_count = max(max_count, count_good_sleeping_times(a, l, r))\n        if a[i] > 1:\n            max_count = max(max_count, count_good_sleeping_times(a, l, r - 1))\n\n    return str(max_count)\n"
    },
    {
        "number": 4065,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(problems):\n        for i in range(1, len(problems)):\n            if problems[i] > problems[i - 1] * 2:\n                return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    max_problems = 1\n    for i in range(1, n):\n        for j in range(i, n):\n            if is_valid(a[i:j + 1]):\n                max_problems = max(max_problems, j - i + 1)\n\n    return str(max_problems)\n"
    },
    {
        "number": 4066,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    min_lcm = float('inf')\n    min_i, min_j = 0, 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            lcm_value = lcm(a[i], a[j])\n            if lcm_value < min_lcm:\n                min_lcm = lcm_value\n                min_i, min_j = i, j\n\n    return f\"{min_i + 1} {min_j + 1}\"\n"
    },
    {
        "number": 4067,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    # Check if the given string is already balanced\n    if s.count('0') == s.count('1') == s.count('2'):\n        return s\n\n    # Initialize variables\n    min_replacements = float('inf')\n    min_balanced_string = ''\n\n    # Iterate through all possible replacements\n    for i in range(n):\n        if s[i] == '0':\n            for j in ['1', '2']:\n                new_s = s[:i] + j + s[i+1:]\n                if new_s.count('0') == new_s.count('1') == new_s.count('2'):\n                    replacements = new_s.count('0') + new_s.count('1') + new_s.count('2')\n                    if replacements < min_replacements:\n                        min_replacements = replacements\n                        min_balanced_string = new_s\n        elif s[i] == '1':\n            for j in ['0', '2']:\n                new_s = s[:i] + j + s[i+1:]\n                if new_s.count('0') == new_s.count('1') == new_s.count('2'):\n                    replacements = new_s.count('0') + new_s.count('1') + new_s.count('2')\n                    if replacements < min_replacements:\n                        min_replacements = replacements\n                        min_balanced_string = new_s\n        else:\n            for j in ['0', '1']:\n                new_s = s[:i] + j + s[i+1:]\n                if new_s.count('0') == new_s.count('1') == new_s.count('2'):\n                    replacements = new_s.count('0') + new_s.count('1') + new_s.count('2')\n                    if replacements < min_replacements:\n                        min_replacements = replacements\n                        min_balanced_string = new_s\n\n    return min_balanced_string "
    },
    {
        "number": 4068,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    broken_steps = sorted(map(int, stdin.split()[2:]))\n\n    def count_ways(n, broken_steps):\n        if n < 0:\n            return 0\n        if n == 0:\n            return 1\n        if n in broken_steps:\n            return 0\n\n        return count_ways(n - 1, broken_steps) + count_ways(n - 2, broken_steps)\n\n    result = count_ways(N - 1, broken_steps)\n    return str(result % 1000000007)\n"
    },
    {
        "number": 4069,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, k, d = map(int, stdin.split())\n    min_abs_value = abs(x)\n    for i in range(k):\n        min_abs_value = min(min_abs_value, abs(x + d), abs(x - d))\n        x += d\n    return str(min_abs_value)\n"
    },
    {
        "number": 4070,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"1\"\n    else:\n        return \"5-10 minutes\" "
    },
    {
        "number": 4071,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a = int(stdin)\n    if a % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\" "
    },
    {
        "number": 4072,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a = int(stdin)\n    if a % 2 == 0:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 4073,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Your code goes here\n    return str(0) "
    },
    {
        "number": 4074,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        n, k = map(int, stdin.split('\\n')[i].split())\n        min_packages = n // k + 1\n        output.append(min_packages)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4075,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_combinations(switches: List[List[int]], bulbs: List[int]) -> int:\n        def count_switches_on(switch_states: List[int]) -> int:\n            return sum(switch_states)\n\n        def count_switches_off(switch_states: List[int]) -> int:\n            return len(switch_states) - count_switches_on(switch_states)\n\n        def count_bulbs_on(switch_states: List[int], bulb_pattern: List[int]) -> int:\n            switch_count = count_switches_on(switch_states)\n            return sum(1 for i in range(len(bulb_pattern)) if bulb_pattern[i] == 1 and switch_count % 2 == 1)\n\n        def count_bulbs_off(switch_states: List[int], bulb_pattern: List[int]) -> int:\n            switch_count = count_switches_off(switch_states)\n            return sum(1 for i in range(len(bulb_pattern)) if bulb_pattern[i] == 0 and switch_count % 2 == 0)\n\n        def count_combinations_recursive(switch_states: List[int], bulb_pattern: List[int], index: int) -> int:\n            if index == len(bulb_pattern):\n                return 1\n\n            bulb_state = bulb_pattern[index]\n            switch_count = count_switches_on(switch_states)\n\n            if bulb_state == 1:\n                if switch_count % 2 == 1:\n                    return count_combinations_recursive(switch_states, bulb_pattern, index + 1)\n                else:\n                    return 0\n            else:\n                if switch_count % 2 == 0:\n                    return count_combinations_recursive(switch_states, bulb_pattern, index + 1)\n                else:\n                    return 0\n\n        switch_count = count_switches_on(switches)\n        bulb_pattern = [1 if p == '1' else 0 for p in stdin.split()[N + M:]]\n\n        if switch_count % 2 == 1:\n            return count_combinations_recursive(switches, bulb_pattern, 0)\n        else:\n            return 0\n\n    N, M = map(int, stdin.split()[:2])\n    switches = [list(map(int, stdin.split()[2 + i * (N + M):2 + (i + 1) * (N + M)])) for i in range(M)]\n    bulbs = [list(map(int, stdin.split()[2 + i * (N + M):2 + (i + 1) * (N + M)])) for i in range(M)]\n\n    return count_combinations(switches, bulbs)\n"
    },
    {
        "number": 4076,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, H, M = map(int, stdin.split())\n\n    # Calculate the distance between the unfixed endpoints of the hands\n    distance = (A * (H % 12) + B * M) / 60\n\n    return round(distance, 9)\n"
    },
    {
        "number": 4077,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_median(arr):\n        arr.sort()\n        n = len(arr)\n        if n % 2 == 0:\n            return (arr[n//2 - 1] + arr[n//2]) / 2\n        else:\n            return arr[n//2]\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if find_median(a[i:j]) == m:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4078,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_diff(arr):\n        return max(arr) - min(arr)\n\n    def apply_segments(a, segments):\n        for l, r in segments:\n            for i in range(l - 1, r):\n                a[i] -= 1\n        return a\n\n    def find_best_segments(a, segments):\n        best_diff = -1\n        best_segments = []\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                if segments[j][0] <= segments[i][1]:\n                    continue\n                new_segments = segments[:i] + segments[j:]\n                new_a = apply_segments(a.copy(), new_segments)\n                new_diff = max_diff(new_a)\n                if new_diff > best_diff:\n                    best_diff = new_diff\n                    best_segments = new_segments\n        return best_diff, best_segments\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    segments = [tuple(map(int, stdin.split()[2 + n + i:2 + n + i + 2])) for i in range(m)]\n\n    best_diff, best_segments = find_best_segments(a, segments)\n    q = len(best_segments)\n    c = [i + 1 for i in range(m) if segments[i] in best_segments]\n\n    output = f\"{best_diff}\\n{q}\\n{' '.join(map(str, c))}\"\n    return output\n"
    },
    {
        "number": 4079,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    strings = stdin.split('\\n')[1:]\n\n    for string in strings:\n        if len(string) != len(set(string)):\n            print(\"No\")\n            continue\n\n        for i in range(len(string) - 1):\n            if ord(string[i]) + 1 != ord(string[i + 1]):\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n"
    },
    {
        "number": 4080,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_diff(arr):\n        return max(arr) - min(arr)\n\n    def apply_segments(a, segments):\n        for l, r in segments:\n            for i in range(l - 1, r):\n                a[i] -= 1\n        return a\n\n    def find_best_segments(a, segments):\n        best_diff = -1\n        best_segments = []\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                if segments[j][0] <= segments[i][1]:\n                    continue\n                new_segments = segments[:i] + segments[j:]\n                new_a = apply_segments(a.copy(), new_segments)\n                new_diff = max_diff(new_a)\n                if new_diff > best_diff:\n                    best_diff = new_diff\n                    best_segments = new_segments\n        return best_diff, best_segments\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    segments = [tuple(map(int, stdin.split()[2 + n + i:2 + n + i + 2])) for i in range(m)]\n\n    best_diff, best_segments = find_best_segments(a, segments)\n    q = len(best_segments)\n    c = [segments.index(s) + 1 for s in best_segments]\n\n    output = f\"{best_diff}\\n{q}\\n{' '.join(map(str, c))}\"\n    return output\n"
    },
    {
        "number": 4081,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def is_increasing(sequence):\n        return all(sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1))\n\n    def find_longest_increasing_sequence(sequence):\n        longest_sequence = []\n        current_sequence = []\n        for element in sequence:\n            if not current_sequence or element > current_sequence[-1]:\n                current_sequence.append(element)\n            else:\n                longest_sequence = max(longest_sequence, current_sequence, key=len)\n                current_sequence = [element]\n        longest_sequence = max(longest_sequence, current_sequence, key=len)\n        return longest_sequence\n\n    longest_sequence = find_longest_increasing_sequence(a)\n    k = len(longest_sequence)\n    s = ''.join('L' if a[i] == longest_sequence[i] else 'R' for i in range(k))\n\n    return f\"{k}\\n{s}\" "
    },
    {
        "number": 4082,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    if n <= 2:\n        return n - 1\n\n    max_length = 1\n    for i in range(1, n - 1):\n        if a[i] > a[i - 1] and a[i] > a[i + 1]:\n            max_length += 1\n        else:\n            break\n\n    return max_length\n"
    },
    {
        "number": 4083,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_equal_numbers(a: List[int]) -> int:\n        return len(set(a))\n\n    def min_operations(a: List[int]) -> int:\n        return sum(a) // 2\n\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if count_equal_numbers(a) >= k:\n        return min_operations(a)\n    else:\n        return -1\n"
    },
    {
        "number": 4084,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = map(int, stdin.split())\n    total_balls = A + B\n    blue_balls = (N * (N + 1)) // 2\n    blue_balls += N * (total_balls - 1)\n    blue_balls += (A * (A - 1)) // 2\n    blue_balls += A * (B - 1)\n    return blue_balls\n"
    },
    {
        "number": 4085,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_almost_all_divisors(divisors, x):\n        for divisor in divisors:\n            if x % divisor != 0:\n                return False\n        return True\n\n    def find_min_x(divisors):\n        x = 1\n        for divisor in divisors:\n            x *= divisor\n        return x\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i * 2])\n        divisors = list(map(int, stdin.split('\\n')[i * 2 + 1].split()))\n\n        if n == 1:\n            output.append(-1)\n            continue\n\n        x = find_min_x(divisors)\n        if is_almost_all_divisors(divisors, x):\n            output.append(x)\n        else:\n            output.append(-1)\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4086,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    unique_elements = set()\n    result = []\n\n    for num in a[::-1]:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            result.append(num)\n\n    x = len(result)\n    result = ' '.join(map(str, result))\n\n    output = f\"{x}\\n{result}\"\n    return output\n"
    },
    {
        "number": 4087,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a = int(stdin)\n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def is_interesting(num: int) -> bool:\n        return sum_of_digits(num) % 4 == 0\n\n    def find_nearest_interesting_number(num: int) -> int:\n        interesting_numbers = [n for n in range(num, 1001) if is_interesting(n)]\n        return min(interesting_numbers)\n\n    nearest_interesting_number = find_nearest_interesting_number(a)\n    return str(nearest_interesting_number)\n"
    },
    {
        "number": 4088,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def calculate_b(t: str) -> List[int]:\n        b = [0] * len(t)\n        for i in range(len(t)):\n            for j in range(i + 1, len(t)):\n                if t[j] > t[i]:\n                    b[i] += abs(i - j)\n        return b\n\n    def is_valid(t: str, b: List[int]) -> bool:\n        return calculate_b(t) == b\n\n    def find_valid_t(s: str, b: List[int]) -> str:\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                t = s[i:j]\n                if is_valid(t, b):\n                    return t\n        return \"\"\n\n    q = int(stdin.readline())\n    for _ in range(q):\n        s = stdin.readline().strip()\n        m = int(stdin.readline())\n        b = list(map(int, stdin.readline().strip().split()))\n        t = find_valid_t(s, b)\n        if t:\n            print(t)\n        else:\n            print(\"No valid t\")\n"
    },
    {
        "number": 4089,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    if 1 <= N <= 26:\n        return chr(ord('a') + N - 1)\n    elif 27 <= N <= 701:\n        return chr(ord('a') + (N - 27) // 26 - 1) + chr(ord('a') + (N - 27) % 26)\n    elif 703 <= N <= 18277:\n        return chr(ord('a') + (N - 703) // 700 - 1) + chr(ord('a') + ((N - 703) % 700) // 26 - 1) + chr(ord('a') + (N - 703) % 26)\n    elif 18279 <= N <= 475253:\n        return chr(ord('a') + (N - 18279) // 18278 - 1) + chr(ord('a') + ((N - 18279) % 18278) // 700 - 1) + chr(ord('a') + ((N - 18279) % 700) // 26 - 1) + chr(ord('a') + (N - 18279) % 26)\n    elif 475255 <= N <= 1000000000000001:\n        return chr(ord('a') + (N - 475255) // 475254 - 1) + chr(ord('a') + ((N - 475255) % 475254) // 18278 - 1) + chr(ord('a') + ((N - 475255) % 18278) // 700 - 1) + chr(ord('a') + ((N - 475255) % 700) // 26 - 1) + chr(ord('a') + (N - 475255) % 26)\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4090,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_equal_segment(w: str, i1: int, j1: int, i2: int, j2: int) -> bool:\n        if j1 - i1 != j2 - i2:\n            return False\n        for t in range(j1 - i1):\n            if w[i1 + t] != w[i2 + t]:\n                return False\n        return True\n\n    def abbreviate(w: str, i: int, j: int) -> str:\n        return ''.join(word.upper() for word in w[i:j + 1].split())\n\n    n = int(stdin.splitlines()[0])\n    words = stdin.splitlines()[1].split()\n    text = ' '.join(words)\n    min_length = len(text)\n\n    for i1 in range(n - 1):\n        for j1 in range(i1 + 1, n):\n            for i2 in range(n - 1):\n                for j2 in range(i2 + 1, n):\n                    if is_equal_segment(text, i1, j1, i2, j2):\n                        abbreviated_text = text[:i1] + abbreviate(text, i1, j1) + text[j1 + 1:i2] + abbreviate(text, i2, j2) + text[j2 + 1:]\n                        min_length = min(min_length, len(abbreviated_text))\n\n    return str(min_length)\n"
    },
    {
        "number": 4091,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_profit(problems, k):\n        n = len(problems)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for l in range(i):\n                    r = l + 1\n                    while r <= i and dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r] <= problems[i]:\n                        dp[i][j] = max(dp[i][j], dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r])\n                        r += 1\n        return dp[n][k]\n\n    def max_profit_distribution(problems, k):\n        n = len(problems)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for l in range(i):\n                    r = l + 1\n                    while r <= i and dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r] <= problems[i]:\n                        dp[i][j] = max(dp[i][j], dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r])\n                        r += 1\n        t = [0] * k\n        i, j = n, k\n        while i > 0 and j > 0:\n            l = i - 1\n            r = l + 1\n            while r <= i and dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r] <= problems[i]:\n                if dp[l][j - 1] + dp[r][j - 1] + problems[l] + problems[r] > dp[i][j]:\n                    t[j - 1] = r - l\n                    i, j = l, j - 1\n                r += 1\n        return dp[n][k], t\n\n    n, k = map(int, stdin.split()[:2])\n    problems = list(map(int, stdin.split()[2:]))\n    max_profit_value = max_profit(problems, k)\n    max_profit_distribution_value, t = max_profit_distribution(problems, k)\n    print(max_profit_value)\n    print(\" \".join(map(str, t)))\n"
    },
    {
        "number": 4092,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_zeros(arr):\n        return sum(1 for x in arr if x == 0)\n\n    def can_sum_to_zero(arr):\n        seen = set()\n        for x in arr:\n            if -x in seen:\n                return True\n            seen.add(x)\n        return False\n\n    def insert_integers(arr):\n        count = 0\n        for i in range(n - 1):\n            if can_sum_to_zero([a[i], a[i + 1]]):\n                count += 1\n                a.insert(i + 1, 1)\n                i += 1\n        return count\n\n    zeros = count_zeros(a)\n    if zeros > 0:\n        return zeros\n    else:\n        return insert_integers(a)\n"
    },
    {
        "number": 4093,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_sum_difference(arr):\n        n = len(arr)\n        dp = [0] * n\n        dp[0] = abs(arr[0])\n        for i in range(1, n):\n            dp[i] = abs(arr[i] - arr[i-1]) + dp[i-1]\n        return max(dp)\n\n    t = int(stdin.split('\\n')[0])\n    for i in range(1, t+1):\n        n, m = map(int, stdin.split('\\n')[i].split())\n        arr = [0] * n\n        if m == 0:\n            print(0)\n        else:\n            for j in range(n):\n                arr[j] = m // n\n                m -= arr[j]\n            print(max_sum_difference(arr))\n"
    },
    {
        "number": 4094,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K = int(stdin.strip())\n    sequence = [7, 77, 777, 7777, 77777, 777777, 7777777, 77777777, 777777777]\n    for i, num in enumerate(sequence):\n        if num % K == 0:\n            return i\n    return -1\n"
    },
    {
        "number": 4095,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    p = list(map(int, input_data[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if sorted(p[i:j])[n // 2] == m:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4096,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_pages(a, k):\n        return max(0, a - k + 1)\n\n    def coffee_effect(a, k):\n        return max_pages(a, k)\n\n    def coffee_effect_sum(a, k):\n        return sum(coffee_effect(ai, k) for ai in a)\n\n    def min_days(n, m, a, k):\n        if k > m:\n            return -1\n        days = 1\n        while coffee_effect_sum(a, k) < m:\n            k += 1\n            days += 1\n            if k > m:\n                return -1\n        return days\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    k = 1\n    while coffee_effect_sum(a, k) < m:\n        k += 1\n\n    if k > m:\n        return -1\n    else:\n        return min_days(n, m, a, k)\n"
    },
    {
        "number": 4097,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n <= 2:\n        return 0\n\n    diff = b[1] - b[0]\n    for i in range(2, n):\n        if b[i] - b[i-1] != diff:\n            return -1\n\n    return 0\n"
    },
    {
        "number": 4098,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_balanced(team: list) -> bool:\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if abs(team[i] - team[j]) > 5:\n                    return False\n        return True\n\n    def count_students(teams: list) -> int:\n        return sum(len(team) for team in teams)\n\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    a.sort(reverse=True)\n    teams = [[] for _ in range(k)]\n\n    for i in range(n):\n        for j in range(k):\n            if len(teams[j]) < 2 or abs(teams[j][-1] - a[i]) <= 5:\n                teams[j].append(a[i])\n                break\n\n    max_students = count_students(teams)\n    for i in range(k):\n        for j in range(i + 1, k):\n            if is_balanced(teams[i] + teams[j]):\n                max_students = max(max_students, count_students(teams[:i] + [teams[i] + teams[j]] + teams[i + 1:j] + [teams[j]] + teams[j + 1:]))\n\n    return str(max_students)\n"
    },
    {
        "number": 4099,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K, M = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    total_score = sum(A)\n    last_subject_score = K - total_score\n\n    if last_subject_score >= M:\n        return last_subject_score\n    else:\n        return -1\n"
    },
    {
        "number": 4100,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, K, Q = map(int, input_data[0].split())\n    A = list(map(int, input_data[1:]))\n\n    # Initialize the players' scores\n    scores = [K] * N\n\n    # Update the scores based on the correct answers\n    for i in range(Q):\n        if A[i] > 0:\n            scores[A[i] - 1] -= 1\n\n    # Eliminate the players with 0 or negative scores\n    survivors = [i + 1 for i in range(N) if scores[i] > 0]\n\n    # Print the survivors' status\n    for i in range(1, N + 1):\n        if i in survivors:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n"
    },
    {
        "number": 4101,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def invert_row(matrix, i):\n        for j in range(len(matrix[i])):\n            matrix[i][j] = 1 - matrix[i][j]\n\n    def invert_column(matrix, j):\n        for i in range(len(matrix)):\n            matrix[i][j] = 1 - matrix[i][j]\n\n    def is_sorted(matrix):\n        flattened = [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[i]))]\n        return all(flattened[i] <= flattened[i + 1] for i in range(len(flattened) - 1))\n\n    n, m = map(int, stdin.split()[:2])\n    matrix = [[int(x) for x in input().split()] for _ in range(n)]\n\n    if not is_sorted(matrix):\n        return \"NO\"\n\n    row_inversions = [0] * n\n    column_inversions = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 0:\n                invert_row(matrix, i)\n                row_inversions[i] += 1\n                invert_column(matrix, j)\n                column_inversions[j] += 1\n\n    return \"YES\\n\" + \"\".join(str(x) for x in row_inversions) + \"\\n\" + \"\".join(str(x) for x in column_inversions) "
    },
    {
        "number": 4102,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Convert the input string to a list of integers\n    nums = [int(digit) for digit in stdin]\n\n    # Check if the sum of the digits is divisible by 3\n    if sum(nums) % 3 == 0:\n        return \"Yes\"\n    else:\n        return \"No\" "
    },
    {
        "number": 4103,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, b, a = map(int, stdin.split()[:3])\n    s = list(map(int, stdin.split()[3:]))\n\n    max_segments = 0\n    battery_used = 0\n    accumulator_used = 0\n\n    for i in range(n):\n        if s[i] == 1:\n            if battery_used < b:\n                battery_used += 1\n                max_segments += 1\n            elif accumulator_used < a:\n                accumulator_used += 1\n                max_segments += 1\n        else:\n            if accumulator_used > 0:\n                accumulator_used -= 1\n\n    return str(max_segments)\n"
    },
    {
        "number": 4104,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    expression = stdin.strip()\n    result = 0\n    for i, char in enumerate(expression):\n        if char in '+-':\n            if expression[i-1] == '+':\n                result += int(expression[i-2:i])\n            elif expression[i-1] == '-':\n                result -= int(expression[i-2:i])\n    return str(result)\n"
    },
    {
        "number": 4105,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split())\n\n    # Check if it's possible to find a suitable color choosing\n    if n % 2 == 0 or k < n or k < 2:\n        return \"NO\"\n\n    # Generate a suitable color choosing\n    colors = list(range(1, k + 1))\n    pairs = [colors[i] for i in range(n)]\n    man_colors = pairs[::2]\n    woman_colors = pairs[1::2]\n\n    # Check if the color choosing is valid\n    for i in range(n - 1):\n        if man_colors[i] == man_colors[i + 1] or woman_colors[i] == woman_colors[i + 1]:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(map(str, pairs))\n"
    },
    {
        "number": 4106,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(arr, x, k):\n        if x == 0:\n            return True\n        if k == 1:\n            return True\n        if k >= len(arr):\n            return False\n        for i in range(len(arr) - k + 1):\n            if arr[i] == 0:\n                continue\n            if is_valid(arr[i+1:], x-1, k-1):\n                return True\n        return False\n\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    if not is_valid(a, x, k):\n        return -1\n\n    return sum(a[:x])\n"
    },
    {
        "number": 4107,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split()[0:2])\n    rooms = list(stdin.split()[2])\n\n    # Calculate the cost of placing a router in each room\n    router_cost = [i for i in range(1, n + 1)]\n    for i in range(n):\n        if rooms[i] == '1':\n            router_cost[i] = 0\n\n    # Calculate the minimum total cost of connecting all rooms to the Internet\n    min_cost = sum(router_cost)\n    for i in range(n):\n        if router_cost[i] == 0:\n            continue\n        min_cost += min(router_cost[max(0, i - k):min(n, i + k) + 1])\n\n    return str(min_cost)\n"
    },
    {
        "number": 4108,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split('\\n')\n\n    if S == T:\n        return \"Yes\"\n\n    for c_1, c_2 in itertools.permutations(\"abcdefghijklmnopqrstuvwxyz\", 2):\n        S_new = S.replace(c_1, c_2).replace(c_2, c_1)\n        if S_new == T:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4109,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_money(algorithms, book_prices, book_increases):\n        n, m = len(algorithms), len(book_prices)\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    dp[i][j] = book_prices[j]\n                else:\n                    dp[i][j] = float('inf')\n                    for k in range(m):\n                        dp[i][j] = min(dp[i][j], dp[i-1][k] + book_prices[j] + book_increases[i-1][k])\n        return dp[n-1][m-1]\n\n    def is_achievable(algorithms, book_prices, book_increases, target_level):\n        n, m = len(algorithms), len(book_prices)\n        dp = [[False] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    dp[i][j] = algorithms[i] >= target_level\n                else:\n                    dp[i][j] = False\n                    for k in range(m):\n                        dp[i][j] = dp[i][j] or (dp[i-1][k] and algorithms[i] >= algorithms[i-1][k] + book_increases[i-1][k])\n        return dp[n-1][m-1]\n\n    def main():\n        algorithms = [0] * int(input())\n        book_prices = [0] * int(input())\n        book_increases = [[0] * len(algorithms) for _ in range(len(book_prices))]\n\n        for i in range(len(algorithms)):\n            algorithms[i] = int(input())\n\n        for i in range(len(book_prices)):\n            book_prices[i] = int(input())\n\n        for i in range(len(book_increases)):\n            for j in range(len(book_increases[0])):\n                book_increases[i][j] = int(input())\n\n        target_level = int(input())\n\n        min_money = find_min_money(algorithms, book_prices, book_increases)\n        achievable = is_achievable(algorithms, book_prices, book_increases, target_level)\n\n        if achievable:\n            print(min_money)\n        else:\n            print(\"Impossible\")\n\n    main()\n"
    },
    {
        "number": 4110,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    D, G = map(int, input_data[0].split())\n    p_i = [int(x) for x in input_data[1].split()]\n    c_i = [int(x) for x in input_data[2].split()]\n\n    total_score = 0\n    perfect_bonuses = 0\n    problems_solved = 0\n\n    for i in range(1, D + 1):\n        total_score += 100 * i * p_i[i - 1]\n        perfect_bonuses += c_i[i - 1]\n\n    if total_score >= G:\n        return 0\n\n    for i in range(1, D + 1):\n        problems_solved += (G - total_score) // (100 * i)\n        total_score += 100 * i * problems_solved\n        if total_score >= G:\n            return problems_solved\n\n    return -1  # This should never happen, but it's included for completeness\n"
    },
    {
        "number": 4111,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    good_candies = 0\n    for i in range(1, n):\n        total_even = sum(a[:i]) + sum(a[i+1:])\n        total_odd = sum(a[:i-1:2]) + sum(a[i:n:2])\n        if total_even == total_odd:\n            good_candies += 1\n\n    return good_candies\n"
    },
    {
        "number": 4112,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(arr, x, k):\n        if x == 0:\n            return True\n        if k == 1:\n            return True\n        if k >= len(arr):\n            return False\n        for i in range(len(arr) - k + 1):\n            if arr[i] == 0:\n                continue\n            if is_valid(arr[i+1:], x-1, k-1):\n                return True\n        return False\n\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    if not is_valid(a, x, k):\n        return -1\n\n    return sum(a[:x])\n"
    },
    {
        "number": 4113,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    if 1 <= N <= 100:\n        if N % 4 == 0 and N % 7 == 0:\n            return \"Yes\"\n        elif N % 4 == 0:\n            return \"Yes\"\n        elif N % 7 == 0:\n            return \"Yes\"\n        else:\n            return \"No\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4114,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def calculate_altitude(x, y, cx, cy, h):\n        return max(h - abs(x - cx) - abs(y - cy), 0)\n\n    def find_center_coordinates(points):\n        cx = sum(x for x, _ in points) // len(points)\n        cy = sum(y for _, y in points) // len(points)\n        return cx, cy\n\n    def find_height(points, cx, cy):\n        return max(calculate_altitude(x, y, cx, cy, h) for x, y, h in points)\n\n    def find_pyramid_parameters(points):\n        cx, cy = find_center_coordinates(points)\n        h = find_height(points, cx, cy)\n        return cx, cy, h\n\n    N = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    cx, cy, h = find_pyramid_parameters(points)\n    return f\"{cx} {cy} {h}\"\n"
    },
    {
        "number": 4115,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    n = len(S)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 0\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 2:\n                if S[i] != S[j]:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n            else:\n                if S[i] != S[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n"
    },
    {
        "number": 4116,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i * j == N:\n                return \"Yes\"\n    return \"No\"\n"
    },
    {
        "number": 4117,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_triangle(a: int, b: int, c: int) -> bool:\n        return a + b > c and a + c > b and b + c > a\n\n    def count_valid_triangles(sticks: List[int]) -> int:\n        count = 0\n        n = len(sticks)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if is_valid_triangle(sticks[i], sticks[j], sticks[k]):\n                        count += 1\n        return count\n\n    def read_input(stdin: str) -> List[int]:\n        N = int(stdin.split()[0])\n        sticks = [int(x) for x in stdin.split()[1:]]\n        return sticks\n\n    sticks = read_input(stdin)\n    result = count_valid_triangles(sticks)\n    return str(result)\n"
    },
    {
        "number": 4118,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    if 1 <= A <= 9 and 1 <= B <= 9:\n        return A * B\n    else:\n        return -1\n"
    },
    {
        "number": 4119,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    X = list(map(int, input_data[1].split()))\n\n    # Sort the X list in ascending order\n    X.sort()\n\n    # Initialize the minimum number of moves required\n    min_moves = 0\n\n    # Iterate through the X list\n    for i in range(M):\n        # If the current X value is greater than the previous X value,\n        # we need to move the piece to the next coordinate\n        if i > 0 and X[i] > X[i - 1]:\n            min_moves += 1\n\n        # If the current X value is less than the previous X value,\n        # we need to move the piece to the previous coordinate\n        elif i > 0 and X[i] < X[i - 1]:\n            min_moves += 1\n\n    return str(min_moves)\n"
    },
    {
        "number": 4120,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(cur, visited, roads, depth, k, result, options):\n        if depth == n - 1:\n            if k == 0:\n                options.append(''.join(str(int(x)) for x in visited))\n            k -= 1\n            return\n        for i in range(len(roads)):\n            if visited[i] == 0:\n                visited[i] = 1\n                dfs(cur + 1, visited, roads, depth + 1, k, result, options)\n                visited[i] = 0\n\n    n, m, k = map(int, stdin.split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    result = []\n    options = []\n    visited = [0] * m\n    dfs(1, visited, roads, 0, k, result, options)\n    return len(options)\n"
    },
    {
        "number": 4121,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Check if all parts have the same height\n    if len(set(a)) == 1:\n        return \"YES\"\n\n    # Check if the wall has no empty spaces inside it\n    if max(a) - min(a) + 1 == n:\n        return \"YES\"\n\n    # Check if Vova can complete the wall using any amount of bricks\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            continue\n        if a[i] + 1 == a[i + 1]:\n            return \"YES\"\n        if a[i] - 1 == a[i + 1]:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 4122,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, n = map(int, stdin.split()[:2])\n    d = list(map(int, stdin.split()[2:]))\n\n    monster_hp = H\n    for i in range(n):\n        monster_hp += d[i]\n        if monster_hp <= 0:\n            return i + 1\n\n    return -1\n"
    },
    {
        "number": 4123,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    two_grams = {}\n    for i in range(n - 1):\n        two_gram = s[i:i+2]\n        if two_gram in two_grams:\n            two_grams[two_gram] += 1\n        else:\n            two_grams[two_gram] = 1\n\n    max_count = 0\n    max_two_gram = ''\n    for two_gram, count in two_grams.items():\n        if count > max_count:\n            max_count = count\n            max_two_gram = two_gram\n\n    return max_two_gram\n"
    },
    {
        "number": 4124,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, t = stdin.split('\\n')\n    moves = 0\n    while s != t:\n        if not s:\n            moves += len(t)\n            break\n        if not t:\n            moves += len(s)\n            break\n        if len(s) > len(t):\n            s = s[1:]\n            moves += 1\n        elif len(s) < len(t):\n            t = t[1:]\n            moves += 1\n        else:\n            s = s[1:]\n            t = t[1:]\n            moves += 1\n    return moves\n"
    },
    {
        "number": 4125,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, X = map(int, stdin.split()[:2])\n    x_i = list(map(int, stdin.split()[2:]))\n\n    # Sort the cities by their coordinates\n    x_i.sort()\n\n    # Initialize the maximum value of D\n    D = 0\n\n    # Iterate through the sorted cities\n    for i in range(N):\n        # Calculate the minimum distance between the current city and the next city\n        min_dist = abs(x_i[i] - x_i[i + 1])\n\n        # Update the maximum value of D\n        D = max(D, min_dist)\n\n    # Print the maximum value of D\n    return D\n"
    },
    {
        "number": 4126,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    N = len(S)\n\n    # Check if S is a palindrome\n    if S != S[::-1]:\n        return \"No\"\n\n    # Check if the string formed by the 1-st through ((N-1)/2)-th characters is a palindrome\n    if S[:N//2] != S[:N//2][::-1]:\n        return \"No\"\n\n    # Check if the string consisting of the (N+3)/2-st through N-th characters is a palindrome\n    if S[N//2:] != S[N//2:][::-1]:\n        return \"No\"\n\n    return \"Yes\" "
    },
    {
        "number": 4127,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(float, stdin.split())\n    result = int(A * B)\n    return str(result)\n"
    },
    {
        "number": 4128,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        n = int(stdin.split('\\n')[i])\n        a = 1\n        b = n - a\n        if a > b:\n            count = 0\n            while a <= n:\n                if a <= b:\n                    count += 1\n                a += 1\n                b -= 1\n            output.append(count)\n        else:\n            output.append(0)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4129,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def bfs(graph, start, visited):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    n, m, s = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    bfs(graph, s, visited)\n\n    count = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4130,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_team_size = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                if a[i-1] != a[j-1] and a[i-1] != a[k-1] and a[j-1] != a[k-1]:\n                    max_team_size = max(max_team_size, i+j+k)\n\n    return str(max_team_size)\n"
    },
    {
        "number": 4131,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    prefectures = {}\n    for i in range(1, M + 1):\n        P, Y = map(int, input_data[i].split())\n        if P not in prefectures:\n            prefectures[P] = []\n        prefectures[P].append((Y, i))\n\n    result = []\n    for P in sorted(prefectures.keys()):\n        cities = sorted(prefectures[P])\n        for i, (Y, index) in enumerate(cities, start=1):\n            id_number = str(P).zfill(6) + str(index).zfill(6)\n            result.append(id_number)\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 4132,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *A = map(int, stdin.split())\n    A = list(A)\n\n    # Initialize the health of each monster\n    monster_health = [A[i] for i in range(N)]\n\n    # Find the minimum possible final health of the last monster alive\n    min_health = float('inf')\n    while len(monster_health) > 1:\n        # Find the indices of the two alive monsters\n        alive_indices = [i for i in range(len(monster_health)) if monster_health[i] > 0]\n        # Choose two random alive monsters\n        i, j = random.sample(alive_indices, 2)\n        # Calculate the health lost by the monster attacked\n        health_lost = abs(monster_health[i] - monster_health[j])\n        # Update the health of the monster attacked\n        monster_health[j] -= health_lost\n        # Update the minimum possible final health\n        min_health = min(min_health, monster_health[j])\n\n    return min_health\n"
    },
    {
        "number": 4133,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Define the shape of the jaws and the number of variables required to feed the golorp\n    jaw_shapes = {\n        \"A\": 2,\n        \"B\": 3,\n        \"C\": 3,\n        \"D\": 4,\n        \"E\": 4,\n        \"F\": 5,\n        \"G\": 5,\n        \"H\": 5,\n        \"I\": 6,\n        \"J\": 6,\n        \"K\": 7,\n        \"L\": 7,\n        \"M\": 8,\n        \"N\": 8,\n        \"O\": 9,\n        \"P\": 9,\n        \"Q\": 10,\n        \"R\": 10,\n        \"S\": 10,\n        \"T\": 11,\n        \"U\": 11,\n        \"V\": 12,\n        \"W\": 12,\n        \"X\": 13,\n        \"Y\": 13,\n        \"Z\": 14,\n    }\n\n    # Define the lexicographically smallest sequence of variable values for each golorp\n    lexicographically_smallest_sequences = {\n        \"A\": \"01\",\n        \"B\": \"012\",\n        \"C\": \"0123\",\n        \"D\": \"01234\",\n        \"E\": \"012345\",\n        \"F\": \"0123456\",\n        \"G\": \"01234567\",\n        \"H\": \"012345678\",\n        \"I\": \"0123456789\",\n        \"J\": \"01234567890\",\n        \"K\": \"012345678901\",\n        \"L\": \"0123456789012\",\n        \"M\": \"01234567890123\",\n        \"N\": \"012345678901234\",\n        \"O\": \"0123456789012345\",\n        \"P\": \"01234567890123456\",\n        \"Q\": \"012345678901234567\",\n        \"R\": \"0123456789012345678\",\n        \"S\": \"01234567890123456789\",\n        \"T\": \"012345678901234567890\",\n        \"U\": \"0123456789012345678901\",\n        \"V\": \"01234567890123456789012\",\n        \"W\": \"012345678901234567890123\",\n        \"X\": \"0123456789012345678901234\",\n        \"Y\": \"01234567890123456789012345\",\n        \"Z\": \"012345678901234567890123456\",\n    }\n\n    # Check if the golorp is possible to feed\n    if stdin not in jaw_shapes:\n        return \"false\"\n\n    # Calculate the number of variables required to feed the golorp\n    num_variables = jaw_shapes[stdin]\n\n    # Generate all possible sequences of variable values\n    variable_sequences = [\"\".join(str(i) for i in range(num_variables)) for _ in range(num_variables)]\n\n    # Filter out sequences that are not lexicographically smallest\n    lexicographically_smallest_sequences = [seq for seq in variable_sequences if seq >= lexicographically_smallest_sequences[stdin]]\n\n    # Return the lexicographically smallest sequence of variable values\n"
    },
    {
        "number": 4134,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def xor_sum(path: List[Tuple[int, int]]) -> int:\n        return sum(a[i][j] for i, j in path)\n\n    def is_valid(path: List[Tuple[int, int]]) -> bool:\n        return all(0 <= i < n and 0 <= j < m for i, j in path)\n\n    def dfs(i: int, j: int, path: List[Tuple[int, int]], k: int) -> int:\n        if i == n - 1 and j == m - 1:\n            return int(xor_sum(path) == k)\n\n        count = 0\n        if is_valid(path + [(i, j + 1)]):\n            count += dfs(i, j + 1, path + [(i, j + 1)], k)\n        if is_valid(path + [(i + 1, j)]):\n            count += dfs(i + 1, j, path + [(i + 1, j)], k)\n        return count\n\n    n, m, k = map(int, stdin.split())\n    a = [[int(x) for x in input().split()] for _ in range(n)]\n\n    return dfs(0, 0, [], k)\n"
    },
    {
        "number": 4135,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    t = stdin.split('\\n')[1]\n\n    s = list(t)\n    for d in range(n, 0, -1):\n        if n % d == 0:\n            s[1:d+1] = reversed(s[1:d+1])\n            n //= d\n\n    return ''.join(s)\n"
    },
    {
        "number": 4136,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    return str(a + b)\n"
    },
    {
        "number": 4137,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # parse input\n    expression = stdin.strip()\n    operands = expression.split()\n    operators = []\n    values = []\n    for operand in operands:\n        if operand in ['+', '-']:\n            operators.append(operand)\n        else:\n            values.append(int(operand))\n\n    # calculate result\n    result = values[0]\n    for i in range(1, len(values)):\n        if operators[i-1] == '+':\n            result += values[i]\n        else:\n            result -= values[i]\n\n    # generate Brainfuck program\n    program = ''.join(['>', '+' * result, '<'])\n\n    return program\n"
    },
    {
        "number": 4138,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    sequence = \"11212312341234512345612345671234567812345678912345678910\"\n    for i in range(1, q + 1):\n        k = int(stdin.split('\\n')[i])\n        index = k - 1\n        digit = int(sequence[index])\n        print(digit)\n"
    },
    {
        "number": 4139,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    count = 0\n\n    for num in range(1, N + 1):\n        digits = [int(digit) for digit in str(num)]\n        if 7 in digits and 5 in digits and 3 in digits:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4140,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    N = len(S)\n    count = 0\n    for i in range(N):\n        if S[i] == '0':\n            if i == 0 or S[i-1] == '1':\n                count += 1\n            elif i == N-1 or S[i+1] == '1':\n                count += 1\n    return count\n"
    },
    {
        "number": 4141,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *A = map(int, stdin.split())\n\n    for a in A:\n        if a % 2 == 0 and a % 3 != 0 and a % 5 != 0:\n            return \"DENIED\"\n\n    return \"APPROVED\"\n"
    },
    {
        "number": 4142,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    for i in range(1, len(S), 2):\n        if S[i] not in ['L', 'R', 'U', 'D']:\n            return \"No\"\n    for i in range(0, len(S), 2):\n        if S[i] not in ['L', 'R', 'U', 'D']:\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 4143,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B, C, D, E = map(int, stdin.split())\n\n    # Calculate the time needed to reach City 2\n    time_2 = N // A\n    if N % A != 0:\n        time_2 += 1\n\n    # Calculate the time needed to reach City 3\n    time_3 = time_2 + (N % A) // B\n    if (N % A) % B != 0:\n        time_3 += 1\n\n    # Calculate the time needed to reach City 4\n    time_4 = time_3 + (N % A + N % B) // C\n    if (N % A + N % B) % C != 0:\n        time_4 += 1\n\n    # Calculate the time needed to reach City 5\n    time_5 = time_4 + (N % A + N % B + N % C) // D\n    if (N % A + N % B + N % C) % D != 0:\n        time_5 += 1\n\n    # Calculate the time needed to reach City 6\n    time_6 = time_5 + (N % A + N % B + N % C + N % D) // E\n    if (N % A + N % B + N % C + N % D) % E != 0:\n        time_6 += 1\n\n    return time_6\n"
    },
    {
        "number": 4144,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    MOD = 10**9 + 7\n\n    if N == 1:\n        return \"1\"\n\n    count = 0\n    for i in range(10):\n        if i == 0 or i == 9:\n            count += 1\n            continue\n        for j in range(10):\n            if j == 0 or j == 9:\n                continue\n            for k in range(10):\n                if k == 0 or k == 9:\n                    continue\n                count += 1\n\n    return str(count % MOD)\n"
    },
    {
        "number": 4145,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin.strip())\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for i in range(X + 1, 10**5 + 1):\n        if is_prime(i):\n            return str(i)"
    },
    {
        "number": 4146,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split()[0])\n    v = list(map(int, stdin.split()[1:]))\n\n    # Check if the sequence is already /\\/\\/\\/\n    if len(set(v)) == 2 and v[0] == v[-1]:\n        return 0\n\n    # Count the number of elements that need to be replaced\n    count = 0\n    for i in range(n // 2):\n        if v[i] != v[n - i - 1]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4147,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def bamboo_length(bamboos: list) -> int:\n        return sum(bamboos)\n\n    def bamboo_composition(bamboos: list, index1: int, index2: int) -> int:\n        bamboos[index1] = bamboos[index1] + bamboos[index2]\n        del bamboos[index2]\n        return bamboos\n\n    def bamboo_shortening(bamboos: list, index: int) -> int:\n        if bamboos[index] > 1:\n            bamboos[index] -= 1\n        else:\n            del bamboos[index]\n        return bamboos\n\n    def bamboo_extension(bamboos: list, index: int) -> int:\n        bamboos[index] += 1\n        return bamboos\n\n    def min_mp_needed(bamboos: list, A: int, B: int, C: int) -> int:\n        mp_needed = 0\n        while bamboo_length(bamboos) != A + B + C:\n            if bamboo_length(bamboos) < A + B + C:\n                if len(bamboos) > 2:\n                    bamboos = bamboo_composition(bamboos, 0, 1)\n                elif len(bamboos) > 1:\n                    bamboos = bamboo_composition(bamboos, 0, 1)\n                else:\n                    bamboos = bamboo_extension(bamboos, 0)\n            else:\n                if bamboo_length(bamboos) > A + B + C:\n                    bamboos = bamboo_shortening(bamboos, 0)\n                else:\n                    bamboos = bamboo_shortening(bamboos, 1)\n            mp_needed += 1\n        return mp_needed\n\n    N, A, B, C = map(int, stdin.split())\n    bamboos = list(map(int, stdin.split()[1:]))\n\n    return min_mp_needed(bamboos, A, B, C)\n"
    },
    {
        "number": 4148,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = map(str, stdin.split())\n    N = int(N)\n    S = S.upper()\n\n    result = \"\"\n    for char in S:\n        shifted_char = chr((ord(char) - 65 + N) % 26 + 65)\n        result += shifted_char\n\n    return result\n"
    },
    {
        "number": 4149,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_gen() -> int:\n        num = 2\n        while True:\n            if is_prime(num):\n                yield num\n                num += 1\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def next_prime(num: int) -> int:\n        while True:\n            num += 1\n            if is_prime(num):\n                return num\n\n    def recover_array(b: List[int]) -> List[int]:\n        n = len(b) // 2\n        a = [0] * n\n        prime_gen_iter = prime_gen()\n        for i in range(n):\n            if b[i] in a:\n                a[i] = next_prime(b[i])\n            else:\n                a[i] = b[i]\n            if is_prime(a[i]):\n                a[i] = next(prime_gen_iter)\n            else:\n                a[i] = gcd(a[i], b[i])\n        return a\n\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n\n    a = recover_array(b)\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 4150,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def find_closest_students(students, index, k):\n        left_students = [i for i in range(index - 1, max(index - k - 1, -1), -1) if i >= 0]\n        right_students = [i for i in range(index + 1, min(index + k + 1, n)) if i < n]\n        return left_students + right_students\n\n    def choose_students(students, index, k):\n        closest_students = find_closest_students(students, index, k)\n        chosen_students = [students.pop(i) for i in closest_students]\n        return chosen_students\n\n    first_team = []\n    second_team = []\n\n    while a:\n        max_index = a.index(max(a))\n        chosen_students = choose_students(a, max_index, k)\n        first_team.extend(chosen_students)\n        a = [i for i in a if i not in chosen_students]\n\n    while a:\n        max_index = a.index(max(a))\n        chosen_students = choose_students(a, max_index, k)\n        second_team.extend(chosen_students)\n        a = [i for i in a if i not in chosen_students]\n\n    result = ['1' if i in first_team else '2' for i in range(1, n + 1)]\n    return ''.join(result)\n"
    },
    {
        "number": 4151,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_renumerations(a):\n        def dfs(i, b):\n            if i == n:\n                return 1\n            if b[i] == b[i - 1]:\n                return dfs(i + 1, b)\n            return dfs(i + 1, b) + dfs(i + 1, b + 1)\n\n        b = [0] * n\n        return dfs(1, b) % 998244353\n\n    return str(count_renumerations(a))\n"
    },
    {
        "number": 4152,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_power_of_two(num: int) -> bool:\n        return num != 0 and (num & (num - 1)) == 0\n\n    def find_power_of_two(num: int) -> int:\n        power_of_two = 1\n        while power_of_two < num:\n            power_of_two <<= 1\n        return power_of_two\n\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_elements_to_remove = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if is_power_of_two(sequence[i] + sequence[j]):\n                    min_elements_to_remove += 1\n                    break\n\n    print(min_elements_to_remove)\n"
    },
    {
        "number": 4153,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    S = list(stdin)\n    red_cubes = [i for i in range(N) if S[i] == '0']\n    blue_cubes = [i for i in range(N) if S[i] == '1']\n    red_cubes.sort(reverse=True)\n    blue_cubes.sort(reverse=True)\n    count = 0\n    i = 0\n    j = 0\n    while i < len(red_cubes) and j < len(blue_cubes):\n        if red_cubes[i] == blue_cubes[j] - 1:\n            count += 1\n            i += 1\n            j += 1\n        elif red_cubes[i] < blue_cubes[j]:\n            i += 1\n        else:\n            j += 1\n    return count\n"
    },
    {
        "number": 4154,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    LR = [list(map(int, stdin.split()[2*i:2*i+2])) for i in range(M)]\n\n    def count_passable_cards(L, R):\n        passable_cards = 0\n        for i in range(N):\n            if any(L[i] <= j <= R[i] for j in range(N)):\n                passable_cards += 1\n        return passable_cards\n\n    passable_cards = 0\n    for L, R in LR:\n        passable_cards = max(passable_cards, count_passable_cards(L, R))\n\n    return passable_cards\n"
    },
    {
        "number": 4155,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, h = map(int, stdin.split())\n    h = list(map(int, h))\n\n    # Initialize the heights of all flowers to 0\n    heights = [0] * N\n\n    # Update the heights of flowers based on the input sequence h\n    for i in range(N):\n        heights[i] = h[i]\n\n    # Initialize the minimum number of watering operations to 0\n    min_ops = 0\n\n    # Iterate through the heights of flowers\n    for i in range(N):\n        # If the height of the current flower is less than the height of the previous flower,\n        # increase the minimum number of watering operations by 1\n        if i > 0 and heights[i] < heights[i - 1]:\n            min_ops += 1\n\n    # Print the minimum number of watering operations required to satisfy the condition\n    return min_ops\n"
    },
    {
        "number": 4156,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_ways(n, w, a):\n        if n == 0:\n            return 1\n        if a[0] < 0 or a[0] > w:\n            return 0\n        if a[0] > 0 and a[0] > w - a[0]:\n            return 0\n        if a[0] == 0:\n            return count_ways(n - 1, w, a[1:])\n        return count_ways(n - 1, w, a[1:]) + count_ways(n - 1, w - a[0], a[1:])\n\n    n, w = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    if n == 0:\n        return 1\n    if count_ways(n, w, a) == 0:\n        return 0\n    return count_ways(n, w, a)\n"
    },
    {
        "number": 4157,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    reordered_sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(sequence):\n        for i in range(1, len(sequence)):\n            if sequence[i] == sequence[i - 1] * 2 or sequence[i] == sequence[i - 1] // 3:\n                continue\n            else:\n                return False\n        return True\n\n    def find_valid_sequence(sequence):\n        for i in range(len(sequence)):\n            if sequence[i] % 3 == 0:\n                sequence[i] //= 3\n            else:\n                sequence[i] *= 2\n        return sequence\n\n    while not is_valid(reordered_sequence):\n        reordered_sequence = find_valid_sequence(reordered_sequence)\n\n    return ' '.join(map(str, reordered_sequence))\n"
    },
    {
        "number": 4158,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_power_of_two(num: int) -> bool:\n        return num > 0 and (num & (num - 1)) == 0\n\n    def distance(x1: int, x2: int) -> int:\n        return abs(x1 - x2)\n\n    def find_subset(points: List[int]) -> List[int]:\n        subset = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if is_power_of_two(distance(points[i], points[j])):\n                    subset.append(points[i])\n                    subset.append(points[j])\n        return subset\n\n    def main(n: int, points: List[int]) -> None:\n        subset = find_subset(points)\n        print(len(subset))\n        print(\" \".join(map(str, subset)))\n\n    n = int(stdin.readline().strip())\n    points = list(map(int, stdin.readline().strip().split()))\n    main(n, points)\n"
    },
    {
        "number": 4159,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, K = map(int, stdin.split())\n    for _ in range(K):\n        if A > 0:\n            A -= 1\n        elif B > 0:\n            B -= 1\n    return f\"{A} {B}\"\n"
    },
    {
        "number": 4160,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin.strip())\n    years = 0\n    balance = 100\n\n    while balance < X:\n        balance *= 1.01\n        years += 1\n\n    return years\n"
    },
    {
        "number": 4161,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K = int(stdin.strip())\n    result = 0\n    for a in range(1, K+1):\n        for b in range(1, K+1):\n            for c in range(1, K+1):\n                result += gcd(a, b, c)\n    return str(result)\n\ndef"
    },
    {
        "number": 4162,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    a_list = list(map(int, input_list[1:]))\n\n    max_f = 0\n    for m in range(1, 10**6):\n        f_m = sum(m % a for a in a_list)\n        if f_m > max_f:\n            max_f = f_m\n\n    return str(max_f)\n"
    },
    {
        "number": 4163,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *dice_rolls = stdin.split()\n    N = int(N)\n    dice_rolls = [tuple(map(int, dice_roll.split())) for dice_roll in dice_rolls]\n\n    for i in range(N - 2):\n        if dice_rolls[i][0] == dice_rolls[i][1] and dice_rolls[i+1][0] == dice_rolls[i+1][1] and dice_rolls[i+2][0] == dice_rolls[i+2][1]:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4164,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    r = int(stdin.strip())\n    area_r = (r ** 2) * 3.14\n    area_1 = 3.14\n    result = area_r // area_1\n    return str(result)\n"
    },
    {
        "number": 4165,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    L = list(map(int, input_list[1:]))\n\n    if not (3 <= N <= 10) or not all(1 <= L_i <= 100 for L_i in L):\n        return \"No\"\n\n    longest_side = max(L)\n    sum_of_other_sides = sum(L) - longest_side\n\n    if longest_side < sum_of_other_sides:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4166,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    digits = []\n    for _ in range(M):\n        s, c = map(int, input().split())\n        if s < 1 or s > N:\n            return -1\n        if c < 0 or c > 9:\n            return -1\n        digits.append(c)\n    digits.sort()\n    for i in range(len(digits)):\n        if digits[i] != 0:\n            return digits[i]\n    return -1\n"
    },
    {
        "number": 4167,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    K = int(input_list[1])\n\n    count = 0\n    for a in range(1, N + 1):\n        for b in range(a, N + 1):\n            c = N - a - b\n            if a + b == K * (c // K) and b + c == K * (a // K) and c + a == K * (b // K):\n                count += 1\n\n    return count\n"
    },
    {
        "number": 4168,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    if N == 0:\n        return \"0\"\n\n    base_2 = \"\"\n    while N > 0:\n        if N % 2 == 1:\n            base_2 = \"1\" + base_2\n        else:\n            base_2 = \"0\" + base_2\n        N //= 2\n\n    return base_2\n"
    },
    {
        "number": 4169,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    A = []\n    B = []\n    for i in range(1, N + 1):\n        a, b = map(int, input_data[i].split())\n        A.append(a)\n        B.append(b)\n\n    # Calculate the minimum amount of money with which Takahashi can buy M cans of energy drinks\n    min_money = sum(A) * M\n\n    # Check if the sum of B is greater than or equal to M\n    if sum(B) >= M:\n        # Sort the B array in descending order\n        B.sort(reverse=True)\n        # Calculate the minimum amount of money with which Takahashi can buy M cans of energy drinks\n        for i in range(N):\n            min_money = min(min_money, A[i] * B[i])\n\n    return min_money\n"
    },
    {
        "number": 4170,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *H = map(int, stdin.split())\n    max_height = H[0]\n    count = 1\n    for i in range(1, N):\n        if H[i] <= max_height:\n            count += 1\n        else:\n            max_height = H[i]\n            count = 1\n    return count\n"
    },
    {
        "number": 4171,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_equal_numbers(a: List[int]) -> int:\n        return len(set(a))\n\n    def min_operations_to_k_equal_numbers(a: List[int], k: int) -> int:\n        operations = 0\n        for i in range(len(a)):\n            a[i] //= 2\n            operations += 1\n            if count_equal_numbers(a) >= k:\n                return operations\n        return operations\n\n    n, k = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    return str(min_operations_to_k_equal_numbers(a, k))\n"
    },
    {
        "number": 4172,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_max(arr):\n        min_val = min(arr)\n        max_val = max(arr)\n        return min_val, max_val\n\n    def find_min_max_index(arr, min_val, max_val):\n        min_index = -1\n        max_index = -1\n        for i in range(len(arr)):\n            if arr[i] == min_val:\n                min_index = i\n            if arr[i] == max_val:\n                max_index = i\n        return min_index, max_index\n\n    def min_moves(arr, k):\n        min_val, max_val = find_min_max(arr)\n        min_index, max_index = find_min_max_index(arr, min_val, max_val)\n\n        if min_index == -1 or max_index == -1:\n            return -1\n\n        min_moves = 0\n        while arr[min_index] < k:\n            arr[min_index] += 1\n            min_moves += 1\n\n        while arr[max_index] > k:\n            arr[max_index] -= 1\n            min_moves += 1\n\n        return min_moves\n\n    n, k = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:]))\n\n    return str(min_moves(arr, k))\n"
    },
    {
        "number": 4173,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for n, a, b in queries:\n        min_cost = float('inf')\n        if n % 2 == 0:\n            min_cost = min(min_cost, a + b * (n // 2))\n        else:\n            min_cost = min(min_cost, a + b * (n // 2 + 1))\n        print(min_cost)\n"
    },
    {
        "number": 4174,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    N = int(input_data[0])\n    X = int(input_data[1])\n    L = list(map(int, input_data[2:]))\n\n    count = 0\n    for i in range(1, N + 1):\n        if L[i - 1] + D[i - 1] <= X:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4175,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    words = input_list[1:]\n    last_word = ''\n    for word in words:\n        if word[0] == last_word[-1]:\n            last_word = word\n        else:\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 4176,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    min_pieces = min(A, B)\n    return min_pieces\n"
    },
    {
        "number": 4177,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    result = \"\"\n    for char in S:\n        result += \"x\"\n    return result"
    },
    {
        "number": 4178,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *H = map(int, stdin.split())\n    dp = [0] * N\n    dp[0] = H[0]\n\n    for i in range(1, N):\n        dp[i] = max(dp[i-1] - 1, H[i])\n\n    for i in range(1, N):\n        if dp[i-1] > dp[i]:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 4179,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M, C = map(int, stdin.split()[:3])\n    B = list(map(int, stdin.split()[3:]))\n    A = [list(map(int, stdin.split()[i:i+M])) for i in range(4, 4+N*M, M)]\n\n    correct_codes = 0\n    for code in A:\n        if sum(a * b for a, b in zip(code, B)) + C > 0:\n            correct_codes += 1\n\n    return correct_codes\n"
    },
    {
        "number": 4180,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    change = N % 1000\n    return change\n"
    },
    {
        "number": 4181,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    dp = [0] * (N + 1)\n\n    for i in range(1, N + 1):\n        dp[i] = max(dp[i - 1] + A[i - 1], dp[i - 2] + A[i - 1])\n\n    for i in range(N, 0, -1):\n        dp[i] = min(dp[i], dp[i + 1] + B[i - 1])\n\n    return dp[1]\n"
    },
    {
        "number": 4182,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M, X, Y = map(int, stdin.split())\n    x_list = list(map(int, input().split()))\n    y_list = list(map(int, input().split()))\n\n    if X < Z <= Y and all(x < Z for x in x_list) and all(y >= Z for y in y_list):\n        return \"War\"\n    else:\n        return \"No War\"\n"
    },
    {
        "number": 4183,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    T_i = [int(x) for x in input_data[1:]]\n\n    total_time = sum(T_i)\n    return total_time\n"
    },
    {
        "number": 4184,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *W = map(int, stdin.split())\n    W = list(W)\n    T = W.index(max(W[:T]))\n    S1 = sum(W[:T])\n    S2 = sum(W[T:])\n    return abs(S1 - S2)\n"
    },
    {
        "number": 4185,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    matrix = [[int(x) for x in input_data[i+1].split()] for i in range(n)]\n\n    # Find the minimum number of moves required to obtain the matrix\n    moves = 0\n    for i in range(1, n):\n        for j in range(1, m):\n            if matrix[i][j] != (i-1)*m + j:\n                moves += 1\n\n    return str(moves)\n"
    },
    {
        "number": 4186,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Calculate the maximum skill of a team\n    max_skill = max(a)\n\n    # Calculate the minimum total number of problems\n    min_problems = n * (max_skill - 1)\n\n    return str(min_problems)\n"
    },
    {
        "number": 4187,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_rest = 0\n    current_rest = 0\n\n    for i in range(n):\n        if a[i] == 0:\n            current_rest = 0\n        else:\n            current_rest += 1\n            max_rest = max(max_rest, current_rest)\n\n    return max_rest\n"
    },
    {
        "number": 4188,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    facts = {\n        1: \"The highest mountain above sea level in the world is Mount Everest. Its peak rises to 8848 m.\",\n        2: \"The largest board game tournament consisted of 958 participants playing chapaev. The largest online maths competition consisted of 12766 participants.\",\n        3: \"The Nile is credited as the longest river in the world. From its farthest stream in Burundi, it extends 6695 km in length.\",\n        4: \"While not in flood, the main stretches of the Amazon river in South America can reach widths of up to 1100 km at its widest points.\",\n        5: \"Angel Falls is the highest waterfall. Its greatest single drop measures 807 m.\",\n        6: \"Uranium is the heaviest of all the naturally occurring elements. Its most common isotope has a nucleus containing 146 neutrons.\",\n        7: \"The coldest permanently inhabited place is the Siberian village of Oymyakon, where the temperature of -68\u00b0C was registered in the twentieth century.\",\n        8: \"The longest snake held in captivity is over 25 feet long. Its name is Medusa.\",\n        9: \"Colonel Meow holds the world record for longest fur on a cat \u2014 almost 134 centimeters.\",\n        10: \"Sea otters can have up to 10000 hairs per square inch. This is the most dense fur in the animal kingdom.\",\n        11: \"The largest state of USA is Alaska; its area is 663268 square miles.\",\n        12: \"Lake Baikal is the largest freshwater lake in the world. It reaches 1642\u00a0meters in depth and contains around one-fifth of the world's unfrozen fresh water.\",\n        13: \"The most colorful national flag is the one of Turkmenistan, with 106 colors.\",\n        14: \"The largest state of USA is Alaska; its area is 663268 square miles.\",\n        15: \"The largest state of USA is Alaska; its area is 663268 square miles.\",\n        16: \"The largest state of USA is Alaska; its area is 663268 square miles.\"\n    }\n\n    return len(facts)\n"
    },
    {
        "number": 4189,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    cheese_dict = {}\n    for i in range(1, N+1):\n        cheese_name, cheese_type = input_list[i].split()\n        cheese_dict[cheese_name] = cheese_type\n\n    soft_cheese_count = 0\n    hard_cheese_count = 0\n    for cheese_type in cheese_dict.values():\n        if cheese_type == \"soft\":\n            soft_cheese_count += 1\n        else:\n            hard_cheese_count += 1\n\n    if soft_cheese_count > hard_cheese_count:\n        return \"soft\"\n    else:\n        return \"hard\"\n"
    },
    {
        "number": 4190,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def lexicographically_less(x: List[int], y: List[int]) -> bool:\n        for i in range(1, len(x) + 1):\n            if x[:i] < y[:i]:\n                return True\n            elif x[:i] > y[:i]:\n                return False\n        return False\n\n    def reorder_b(a: List[int], b: List[int]) -> List[int]:\n        b_sorted = sorted(b)\n        b_reordered = [0] * len(b)\n        for i in range(len(b)):\n            b_reordered[b_sorted[i]] = a[i]\n        return b_reordered\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    b_reordered = reorder_b(a, b)\n    c = [(a[i] + b_reordered[i]) % n for i in range(n)]\n\n    if not lexicographically_less(c, b_reordered):\n        print(*c)\n    else:\n        print(*b_reordered)\n"
    },
    {
        "number": 4191,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    input_lines = stdin.split('\\n')\n    image = [list(line) for line in input_lines]\n\n    # Initialize variables\n    rows = len(image)\n    cols = len(image[0])\n    count_0 = 0\n    count_1 = 0\n\n    # Count the number of 0's and 1's in the image\n    for i in range(rows):\n        for j in range(cols):\n            if image[i][j] == '0':\n                count_0 += 1\n            elif image[i][j] == '1':\n                count_1 += 1\n\n    # Determine the output digit based on the counts\n    if count_0 > count_1:\n        output = '0'\n    elif count_1 > count_0:\n        output = '1'\n    else:\n        output = '0'\n\n    return output "
    },
    {
        "number": 4192,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    D, T, S = map(int, stdin.split())\n    time_to_travel = D / S\n    if time_to_travel <= T:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4193,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    input_data = stdin.split('\\n')\n    grid = [[int(x) for x in input_data[i].split()] for i in range(3)]\n    N = int(input_data[3])\n    bingo_numbers = [int(x) for x in input_data[4:]]\n\n    # Check for bingo\n    def check_bingo(grid, bingo_numbers):\n        # Check rows\n        for row in grid:\n            if len(set(bingo_numbers).intersection(set(row))) >= 3:\n                return True\n\n        # Check columns\n        for i in range(3):\n            col = [grid[j][i] for j in range(3)]\n            if len(set(bingo_numbers).intersection(set(col))) >= 3:\n                return True\n\n        # Check diagonals\n        diag1 = [grid[i][i] for i in range(3)]\n        diag2 = [grid[i][2 - i] for i in range(3)]\n        if len(set(bingo_numbers).intersection(set(diag1))) >= 3 or len(set(bingo_numbers).intersection(set(diag2))) >= 3:\n            return True\n\n        return False\n\n    if check_bingo(grid, bingo_numbers):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4194,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    A = list(map(int, input_data[1].split()))\n\n    A.sort(reverse=True)\n    days_spent = 0\n    assignments_done = 0\n\n    for a in A:\n        if days_spent + a <= N:\n            days_spent += a\n            assignments_done += 1\n        if assignments_done == M:\n            break\n\n    if assignments_done == M:\n        return days_spent\n    else:\n        return -1\n"
    },
    {
        "number": 4195,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    D, N = map(int, stdin.split())\n    if D == 0:\n        return str(N * 100)\n    elif D == 1:\n        return str(N * 100 + 1)\n    else:\n        return str(N * 100 - 1)\n"
    },
    {
        "number": 4196,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def max_gcd(arr):\n        max_val = max(arr)\n        arr.remove(max_val)\n        return max_val, max(gcd(max_val, x) for x in arr)\n\n    N = int(stdin.split(\"\\n\")[0])\n    A = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    max_val, max_gcd_val = max_gcd(A)\n    A[A.index(max_val)] = 1\n    new_max_val, new_max_gcd_val = max_gcd(A)\n\n    return new_max_gcd_val\n"
    },
    {
        "number": 4197,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A_str = map(int, stdin.split())\n    A = list(map(int, A_str))\n\n    # Create a dictionary to store the order in which the students entered the classroom\n    order_dict = {}\n\n    # Iterate through the list of students\n    for i in range(1, N + 1):\n        # Find the index of the student who entered the classroom when student i did\n        index = A.index(i)\n        # Add the student number to the dictionary with the index as the key\n        order_dict[index] = i\n\n    # Sort the dictionary by keys\n    sorted_dict = dict(sorted(order_dict.items()))\n\n    # Print the student numbers in the order they entered the classroom\n    for key in sorted_dict:\n        print(sorted_dict[key], end=\" \")\n"
    },
    {
        "number": 4198,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, X = map(int, stdin.split())\n    max_price = 0\n    max_integer = 0\n\n    for i in range(1, 10**9 + 1):\n        price = A * i + B * len(str(i))\n        if price <= X:\n            max_price = price\n            max_integer = i\n        else:\n            break\n\n    return max_integer if max_integer > 0 else 0\n"
    },
    {
        "number": 4199,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:]))\n    count = 0\n    for height in heights:\n        if height >= K:\n            count += 1\n    return count\n"
    },
    {
        "number": 4200,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    total_votes = sum(A)\n    min_votes = total_votes // (4 * M)\n\n    if min_votes == 0:\n        return \"No\"\n\n    popular_items = []\n    for i in range(N):\n        if A[i] >= min_votes:\n            popular_items.append(i)\n\n        if len(popular_items) == M:\n            break\n\n    if len(popular_items) == M:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4201,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W, K = map(int, stdin.split())\n    grid = [list(input()) for _ in range(H)]\n\n    def count_black_squares(rows, cols):\n        count = 0\n        for i in range(H):\n            for j in range(W):\n                if i in rows or j in cols:\n                    if grid[i][j] == '#':\n                        count += 1\n        return count\n\n    def count_valid_choices(rows, cols):\n        return sum(1 for i in range(H) if i not in rows) * sum(1 for j in range(W) if j not in cols)\n\n    def count_choices(rows, cols):\n        return count_valid_choices(rows, cols) * count_black_squares(rows, cols)\n\n    def count_choices_helper(rows, cols, remaining):\n        if remaining == 0:\n            return count_choices(rows, cols)\n        if len(rows) == H or len(cols) == W:\n            return 0\n        return count_choices_helper(rows + [i], cols, remaining - 1) + count_choices_helper(rows, cols + [j], remaining - 1)\n\n    return count_choices_helper([], [], K)\n"
    },
    {
        "number": 4202,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    L, R = map(int, stdin.split())\n    min_value = float('inf')\n\n    for i in range(L, R):\n        for j in range(i+1, R+1):\n            value = (i * j) % 2019\n            if value < min_value:\n                min_value = value\n\n    return str(min_value)\n"
    },
    {
        "number": 4203,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    if len(S) < 4 or len(S) > 10:\n        return \"WA\"\n\n    if S[0] != \"A\":\n        return \"WA\"\n\n    if \"C\" not in S[3:-2]:\n        return \"WA\"\n\n    for i in range(len(S)):\n        if i == 0:\n            continue\n        if i == 1:\n            if S[i] != \"C\":\n                return \"WA\"\n            continue\n        if i == 2:\n            if S[i] != \"C\":\n                return \"WA\"\n            continue\n        if i == len(S) - 2:\n            if S[i] != \"C\":\n                return \"WA\"\n            continue\n        if i == len(S) - 1:\n            continue\n        if S[i] != \"a\":\n            return \"WA\"\n\n    return \"AC\" "
    },
    {
        "number": 4204,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, K = stdin.split()\n    S = list(S)\n    K = int(K)\n\n    for _ in range(5 * 10**15):\n        new_S = []\n        for i, digit in enumerate(S):\n            if digit == '2':\n                new_S.append('22')\n            elif digit == '3':\n                new_S.append('333')\n            elif digit == '4':\n                new_S.append('4444')\n            elif digit == '5':\n                new_S.append('55555')\n            elif digit == '6':\n                new_S.append('666666')\n            elif digit == '7':\n                new_S.append('7777777')\n            elif digit == '8':\n                new_S.append('88888888')\n            elif digit == '9':\n                new_S.append('999999999')\n            else:\n                new_S.append(digit)\n        S = new_S\n\n    return S[K - 1]\n"
    },
    {
        "number": 4205,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, p = map(int, stdin.split())\n    p = sorted(p)\n    if p == list(range(1, N+1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4206,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '3':\n            count += 1\n        elif s[i] == '0':\n            if i == 0 or s[i-1] != '3':\n                count += 1\n        else:\n            if s[i-1] == '3':\n                count += 1\n    return count\n"
    },
    {
        "number": 4207,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_zeroes(c):\n        return sum(1 for x in c if x == 0)\n\n    def is_zero(x):\n        return x == 0\n\n    def is_positive(x):\n        return x > 0\n\n    def is_negative(x):\n        return x < 0\n\n    def is_non_zero(x):\n        return x != 0\n\n    def is_non_positive(x):\n        return x <= 0\n\n    def is_non_negative(x):\n        return x >= 0\n\n    def is_non_negative_non_zero(x):\n        return is_non_zero(x) and is_non_positive(x)\n\n    def is_non_positive_non_zero(x):\n        return is_non_zero(x) and is_non_negative(x)\n\n    def is_positive_non_zero(x):\n        return is_non_zero(x) and is_positive(x)\n\n    def is_negative_non_zero(x):\n        return is_non_zero(x) and is_negative(x)\n\n    def is_non_zero_non_positive(x):\n        return is_non_positive(x) and is_non_zero(x)\n\n    def is_non_zero_non_negative(x):\n        return is_non_negative(x) and is_non_zero(x)\n\n    def is_non_positive_non_negative_non_zero(x):\n        return is_non_positive_non_zero(x) and is_non_negative_non_zero(x)\n\n    def is_non_positive_non_zero_non_negative(x):\n        return is_non_positive_non_zero(x) and is_non_zero_non_negative(x)\n\n    def is_non_negative_non_zero_non_positive(x):\n        return is_non_negative_non_zero(x) and is_non_zero_non_positive(x)\n\n    def is_non_negative_non_zero_non_positive_non_zero(x):\n        return is_non_negative_non_zero(x) and is_non_positive_non_zero(x)\n\n    def is_non_positive_non_zero_non_negative_non_zero(x):\n        return is_non_positive_non_zero(x) and is_non_negative_non_zero(x)\n\n    def is_non_negative_non_zero_non_positive_non_zero(x):\n        return is_non_negative_non_zero(x) and is_non_positive_non_zero(x)\n\n    def is_non_positive_non_zero_non_negative_non_zero(x):\n        return is_non_positive_non_zero(x) and is_non_negative_non_zero(x)\n\n    def is_non_negative_non_zero_non_positive_non_zero_non_zero(x):\n        return is_non_negative_non_zero(x) and is_non_positive_non_zero(x) and is_non_zero_non_positive(x)\n\n    def is_non_positive_non_zero_non_negative_non_zero_non_zero(x):\n        return is_non_positive_non_zero(x) and is_non_negative_non_zero(x) and is_non_zero_non_positive(x)\n\n    def is_non_negative_non_zero_non_positive_non_zero_non_zero(x):\n        return is_non_negative_non_zero(x) and is_non_positive_non_zero(x) and is_non_zero_non_positive(x)\n\n    def is_non_positive_non_zero_non_negative_non_zero_non_zero(x):\n        return is_non_positive_non_zero(x) and is_non_negative_non_zero(x) and is_non_zero_non_positive(x)\n\n    def is_non_negative_non_zero_non_positive_non"
    },
    {
        "number": 4208,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    l = stdin.split('\\n')[1]\n    r = stdin.split('\\n')[2]\n\n    def is_compatible(color1, color2):\n        return (color1 == color2) or (color1 == '?' or color2 == '?')\n\n    def count_compatible_pairs(colors):\n        count = 0\n        pairs = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if is_compatible(colors[i], colors[j]):\n                    count += 1\n                    pairs.append((i, j))\n        return count, pairs\n\n    left_colors = [c for c in l]\n    right_colors = [c for c in r]\n\n    left_count, left_pairs = count_compatible_pairs(left_colors)\n    right_count, right_pairs = count_compatible_pairs(right_colors)\n\n    max_count = min(left_count, right_count)\n    pairs = left_pairs if left_count <= right_count else right_pairs\n\n    result = f\"{max_count}\\n\"\n    for i in range(max_count):\n        result += f\"{pairs[i][0]} {pairs[i][1]}\\n\"\n\n    return result\n"
    },
    {
        "number": 4209,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def is_valid_block(block, blocks):\n        for other_block in blocks:\n            if block[0] < other_block[1] and block[1] > other_block[0]:\n                return False\n        return True\n\n    def find_blocks(a, n):\n        blocks = []\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                block = (i + 1, j)\n                if is_valid_block(block, blocks):\n                    blocks.append(block)\n        return blocks\n\n    blocks = find_blocks(a, n)\n    k = len(blocks)\n    output = [str(k)]\n    for block in blocks:\n        output.append(f\"{block[0]} {block[1]}\")\n    return '\\n'.join(output)\n"
    },
    {
        "number": 4210,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if int(str(a[i]) + str(a[j])) % k == 0 or int(str(a[j]) + str(a[i])) % k == 0:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4211,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *B = map(int, stdin.split())\n    A = [0] * N\n    A[0] = B[0]\n    for i in range(1, N-1):\n        A[i] = max(A[i-1], B[i-1])\n    A[N-1] = max(A[N-2], B[N-2])\n    return sum(A)\n"
    },
    {
        "number": 4212,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_score(A, b_i, c_i):\n        for i in range(b_i - 1, -1, -1):\n            if A[i] - A[b_i] == c_i:\n                return d_i\n        return 0\n\n    def is_valid(a_i, b_i, c_i, d_i, A):\n        for i in range(b_i - 1, -1, -1):\n            if A[i] - A[b_i] == c_i:\n                return True\n        return False\n\n    N, M, Q = map(int, stdin.split())\n    A = [0] * N\n    max_score = 0\n\n    for _ in range(Q):\n        a_i, b_i, c_i, d_i = map(int, stdin.split())\n        A[b_i - 1] = c_i\n\n        if is_valid(a_i, b_i, c_i, d_i, A):\n            score = find_score(A, b_i, c_i)\n            max_score = max(max_score, score)\n\n    return max_score\n"
    },
    {
        "number": 4213,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    max_diff = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            diff = abs(A[i] - A[j])\n            if diff > max_diff:\n                max_diff = diff\n\n    return max_diff\n"
    },
    {
        "number": 4214,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def compute_path_length(path):\n        length = 0\n        for i in range(len(path)):\n            if i == 0:\n                length += distance(path[0][0], path[0][1], path[1][0], path[1][1])\n            else:\n                length += distance(path[i - 1][0], path[i - 1][1], path[i][0], path[i][1])\n        return length\n\n    def compute_average_path_length(N, x, y):\n        paths = [(i, j) for i in range(N) for j in range(N) if i != j]\n        path_lengths = [compute_path_length(path) for path in paths]\n        return sum(path_lengths) / len(path_lengths)\n\n    N = int(stdin.split()[0])\n    x = [int(i) for i in stdin.split()[1:N * 2:2]]\n    y = [int(i) for i in stdin.split()[2:N * 2:2]]\n\n    average_path_length = compute_average_path_length(N, x, y)\n    return f\"{average_path_length:.6f}\"\n"
    },
    {
        "number": 4215,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    uncovered_length = A - 2 * B\n    return str(uncovered_length)\n"
    },
    {
        "number": 4216,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    min_f = float('inf')\n\n    for i in range(1, int(N**0.5) + 1):\n        if N % i == 0:\n            j = N // i\n            f = max(len(str(i)), len(str(j)))\n            min_f = min(min_f, f)\n\n    return min_f\n"
    },
    {
        "number": 4217,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    K_i = []\n    A_ij = []\n\n    for i in range(1, N + 1):\n        K_i.append(int(stdin.split()[i]))\n        A_ij.append(list(map(int, stdin.split()[i+1:i+1+K_i[-1]])))\n\n    foods_liked_by_all = set(range(1, M+1))\n    for i in range(N):\n        for j in range(K_i[i]):\n            foods_liked_by_all.discard(A_ij[i][j])\n\n    print(len(foods_liked_by_all))\n"
    },
    {
        "number": 4218,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    probability = 1 - (N % 2) / 2\n    return f\"{probability:.6f}\"\n"
    },
    {
        "number": 4219,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(x, y, i, j):\n        return x != i and x != j\n\n    def is_honest(x, y):\n        return y == 1\n\n    def is_unkind(x, y):\n        return y == 0\n\n    def count_honest_persons(testimonies):\n        return sum(1 for x, y in testimonies if is_honest(x, y))\n\n    def process_input(stdin: str):\n        N = int(stdin.pop(0))\n        testimonies = []\n        for i in range(N):\n            A_i = int(stdin.pop(0))\n            for j in range(A_i):\n                x, y = map(int, stdin.pop(0).split())\n                if not is_valid(x, y, i, j):\n                    raise ValueError(\"Invalid testimonies\")\n                testimonies.append((x, y))\n        return N, testimonies\n\n    N, testimonies = process_input(stdin)\n    max_honest_persons = count_honest_persons(testimonies)\n    return str(max_honest_persons)\n"
    },
    {
        "number": 4220,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K, S = map(str, stdin.split())\n    K = int(K)\n    if len(S) <= K:\n        return S\n    else:\n        return S[:K] + \"...\"\n"
    },
    {
        "number": 4221,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    if S[-1] == 's':\n        return S + 'es'\n    else:\n        return S + 's'\n"
    },
    {
        "number": 4222,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data[0].split())\n    d = [0] * K\n    A = [[] for _ in range(K)]\n\n    for i in range(1, K + 1):\n        d[i - 1] = int(input_data[i])\n        A[i - 1] = list(map(int, input_data[i + 1].split()))\n\n    count = 0\n    for i in range(K):\n        if len(A[i]) == 0:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4223,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = map(str, stdin.split())\n    N = int(N)\n    S = S.strip()\n\n    # Initialize the slimes dictionary with the colors and their count\n    slimes = {}\n    for i in range(N):\n        color = S[i]\n        if color in slimes:\n            slimes[color] += 1\n        else:\n            slimes[color] = 1\n\n    # Iterate through the slimes dictionary and count the number of slimes\n    count = 0\n    for color, count_slimes in slimes.items():\n        count += count_slimes\n\n    return str(count)\n"
    },
    {
        "number": 4224,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *a = map(int, stdin.split())\n    count = 0\n    for i in range(N):\n        if a[i] % 2 == 0:\n            a[i] //= 2\n            count += 1\n        else:\n            a[i] *= 3\n            count += 1\n    return count\n"
    },
    {
        "number": 4225,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, K = map(int, stdin.split())\n    max_sum = 0\n\n    # Calculate the maximum possible sum of the numbers written on the cards chosen\n    max_sum = max(max_sum, A * K)\n    max_sum = max(max_sum, B * K)\n    max_sum = max(max_sum, C * K)\n\n    return str(max_sum)\n"
    },
    {
        "number": 4226,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, Y = map(int, stdin.split())\n    if X % 2 == 0 and Y % 2 == 0:\n        return \"Yes\"\n    elif X % 2 == 1 and Y % 2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4227,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    adj_list = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, stdin.split()[2:4])\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n\n    def dfs(node, visited, path_count):\n        if visited[node]:\n            return path_count\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                path_count = dfs(neighbor, visited, path_count)\n        visited[node] = False\n        return path_count\n\n    path_count = 0\n    visited = [False] * N\n    path_count = dfs(0, visited, path_count)\n    return path_count\n"
    },
    {
        "number": 4228,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, L = map(int, stdin.split())\n    apples = [L + i for i in range(N)]\n    apples.sort()\n    return apples[N - 2]\n"
    },
    {
        "number": 4229,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    fizzbuzz_sequence = []\n\n    for i in range(1, N + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            fizzbuzz_sequence.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            fizzbuzz_sequence.append(\"Fizz\")\n        elif i % 5 == 0:\n            fizzbuzz_sequence.append(\"Buzz\")\n        else:\n            fizzbuzz_sequence.append(i)\n\n    sum_of_numbers = sum(fizzbuzz_sequence)\n    return str(sum_of_numbers)\n"
    },
    {
        "number": 4230,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    X = int(input_data[0])\n    N = int(input_data[1])\n    p = list(map(int, input_data[2].split()))\n\n    min_diff = float(\"inf\")\n    nearest_integer = None\n\n    for num in range(1, 101):\n        if num not in p:\n            diff = abs(num - X)\n            if diff < min_diff:\n                min_diff = diff\n                nearest_integer = num\n\n    return str(nearest_integer)\n"
    },
    {
        "number": 4231,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W, h, w = map(int, stdin.split())\n    return (H * W - h * W - w * H + h * w) // 2 "
    },
    {
        "number": 4232,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    sequence = list(map(int, input_data[1].split()))\n\n    x = 1\n    count = 0\n\n    while count < k:\n        if all(elem <= x for elem in sequence):\n            count += 1\n        x += 1\n\n    if count == k:\n        return str(x - 1)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 4233,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split()[0].split(','))\n    grid = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x, y, size):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            for i in range(1, size):\n                if not (0 <= x + i * dx < n and 0 <= y + i * dy < m):\n                    return False\n                if grid[x + i * dx][y + i * dy] != '*':\n                    return False\n        return True\n\n    stars = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                for size in range(1, min(i + 1, m - j) + 1):\n                    if is_valid(i, j, size):\n                        stars.append((i, j, size))\n                        break\n\n    if not stars:\n        return \"-1\"\n\n    k = len(stars)\n    result = [f\"{k}\\n\"]\n    for x, y, size in stars:\n        result.append(f\"{x} {y} {size}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4234,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    k = 0\n    i = 0\n    while i < len(s):\n        if i % 2 == 0:\n            if s[i] == s[i+1]:\n                k += 1\n                i += 1\n        i += 1\n\n    if k % 2 == 1:\n        k += 1\n\n    s = s[:-k] if k > 0 else s\n\n    return k, s\n"
    },
    {
        "number": 4235,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(u: int, v: int, visited: set, graph: list, parent: int) -> bool:\n        visited.add(u)\n        for vertex in graph[u]:\n            if vertex != parent:\n                if vertex == v:\n                    return True\n                if vertex not in visited and dfs(vertex, v, visited, graph, u):\n                    return True\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if dfs(u, v, set(), graph, -1):\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 4236,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_point_in_segment(x, l, r):\n        return l <= x <= r\n\n    def is_segment_in_segment(l1, r1, l2, r2):\n        return l1 <= r2 and l2 <= r1\n\n    def is_point_in_segments(x, segments):\n        for l, r in segments:\n            if is_point_in_segment(x, l, r):\n                return True\n        return False\n\n    def get_points_not_in_segments(m, segments):\n        points_not_in_segments = []\n        for x in range(1, m + 1):\n            if not is_point_in_segments(x, segments):\n                points_not_in_segments.append(x)\n        return points_not_in_segments\n\n    n, m = map(int, stdin.split()[:2])\n    segments = [tuple(map(int, stdin.split()[i:i + 2])) for i in range(2, 2 * n + 1, 2)]\n\n    points_not_in_segments = get_points_not_in_segments(m, segments)\n    k = len(points_not_in_segments)\n\n    if k > 0:\n        output = f\"{k}\\n\" + \" \".join(map(str, points_not_in_segments))\n    else:\n        output = \"0\"\n\n    return output\n"
    },
    {
        "number": 4237,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n\n    for num in range(A, B + 1):\n        if num % C != 0 and num % D != 0:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4238,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    sum_of_digits = sum(int(digit) for digit in str(N))\n    if sum_of_digits % 9 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4239,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    # Calculate the number of operations required to withdraw exactly N yen in total\n    operations = 0\n    while N > 0:\n        if N % 9 == 0:\n            N -= 9\n            operations += 1\n        elif N % 6 == 0:\n            N -= 6\n            operations += 1\n        else:\n            N -= 1\n            operations += 1\n\n    return operations\n"
    },
    {
        "number": 4240,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split()\n    if S == T:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4241,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split()\n    count = 0\n    for i in range(len(S)):\n        if i >= len(T):\n            break\n        if S[i] != T[i]:\n            count += 1\n    return count\n"
    },
    {
        "number": 4242,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, K = map(int, stdin.split())\n    divisors = set()\n    for i in range(1, min(A, B) + 1):\n        if A % i == 0 and B % i == 0:\n            divisors.add(i)\n    divisors = sorted(list(divisors), reverse=True)\n    return divisors[K-1]"
    },
    {
        "number": 4243,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin)\n\n    # Calculate the number of 500-yen coins\n    num_500 = X // 500\n\n    # Calculate the remaining amount after exchanging 500-yen coins\n    remaining = X % 500\n\n    # Calculate the number of 100-yen coins\n    num_100 = remaining // 100\n\n    # Calculate the remaining amount after exchanging 100-yen coins\n    remaining = remaining % 100\n\n    # Calculate the number of 50-yen coins\n    num_50 = remaining // 50\n\n    # Calculate the remaining amount after exchanging 50-yen coins\n    remaining = remaining % 50\n\n    # Calculate the number of 10-yen coins\n    num_10 = remaining // 10\n\n    # Calculate the remaining amount after exchanging 10-yen coins\n    remaining = remaining % 10\n\n    # Calculate the number of 5-yen coins\n    num_5 = remaining // 5\n\n    # Calculate the remaining amount after exchanging 5-yen coins\n    remaining = remaining % 5\n\n    # Calculate the number of 1-yen coins\n    num_1 = remaining\n\n    # Calculate the total happiness points earned\n    happiness_points = (num_500 * 1000) + (num_100 * 500) + (num_50 * 50) + (num_10 * 5) + (num_5 * 5) + (num_1 * 1)\n\n    return happiness_points\n"
    },
    {
        "number": 4244,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *X = map(int, stdin.split())\n    X = sorted(X)\n    min_stamina = 0\n    for i in range(N):\n        min_stamina += (X[i] - X[0]) ** 2\n    return min_stamina\n"
    },
    {
        "number": 4245,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    if A > B:\n        return 1\n    else:\n        return B // A + (B % A > 0)\n"
    },
    {
        "number": 4246,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split(\"\\n\")\n    correct_days = 0\n\n    for i in range(3):\n        if S[i] == T[i]:\n            correct_days += 1\n\n    return str(correct_days)\n"
    },
    {
        "number": 4247,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *p = map(int, stdin.split())\n    count = 0\n\n    for i in range(1, n - 1):\n        if p[i] == sorted(p[i - 1:i + 2])[1]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4248,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(float, line.split())) for line in stdin.split('\\n')[1:]]\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = euclidean_distance(*points[i], *points[j])\n            if distance < min_distance:\n                min_distance = distance\n\n    return round(min_distance, 2)\n"
    },
    {
        "number": 4249,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_pages(a, k):\n        return max(0, a - k + 1)\n\n    def coffee_effect(a, k):\n        return max_pages(a, k)\n\n    def coffee_effect_sum(a, k):\n        return sum(coffee_effect(a[i], k) for i in range(n))\n\n    def find_min_days(m, n, a):\n        low, high = 1, m\n        while low < high:\n            mid = (low + high) // 2\n            if coffee_effect_sum(a, mid) >= m:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if coffee_effect_sum(a, m) < m:\n        return -1\n    else:\n        return find_min_days(m, n, a)\n"
    },
    {
        "number": 4250,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    s = list(map(int, input_data[1].split()))\n\n    t = []\n    for i in range(k):\n        max_val = 0\n        max_index = -1\n        for j in range(n):\n            if s[j] > max_val and s[j] not in t:\n                max_val = s[j]\n                max_index = j\n        if max_index == -1:\n            break\n        t.append(max_val)\n        s.pop(max_index)\n        n -= 1\n\n    return ' '.join(map(str, t))\n"
    },
    {
        "number": 4251,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_k_acceptable(matrix: List[List[int]], k: int) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        s = [matrix[i][0] for i in range(n)]\n        for j in range(1, m):\n            for i in range(n):\n                s[i] += matrix[i][j]\n        for i in range(1, n):\n            for j in range(m):\n                if abs(s[i] - s[i - 1]) < k:\n                    return False\n        return True\n\n    def find_max_k(matrix: List[List[int]]) -> int:\n        n, m = len(matrix), len(matrix[0])\n        left, right = 1, 1000000000\n        while left <= right:\n            mid = (left + right) // 2\n            if is_k_acceptable(matrix, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n    def read_matrix(input_str: str) -> List[List[int]]:\n        lines = input_str.split('\\n')\n        n, m = map(int, lines[0].split())\n        matrix = [[0] * m for _ in range(n)]\n        for i in range(n):\n            row = list(map(int, lines[i + 1].split()))\n            for j in range(m):\n                matrix[i][j] = row[j]\n        return matrix\n\n    matrix = read_matrix(stdin)\n    k = find_max_k(matrix)\n    return str(k)\n"
    },
    {
        "number": 4252,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    file_name = stdin.split('\\n')[1]\n\n    if 'xxx' in file_name:\n        min_deletions = 0\n        for i in range(n - 2):\n            if file_name[i:i+3] == 'xxx':\n                min_deletions += 3\n            else:\n                continue\n        print(min_deletions)\n    else:\n        print(0)\n"
    },
    {
        "number": 4253,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    r = int(stdin.strip())\n    area = 3 * r ** 2\n    return str(area)\n"
    },
    {
        "number": 4254,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, W = map(int, stdin.split())\n    if W >= S:\n        return \"unsafe\"\n    else:\n        return \"safe\"\n"
    },
    {
        "number": 4255,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    a, b, c = map(int, stdin.split())\n\n    # Calculate semi-perimeter\n    s = (a + b + c) / 2\n\n    # Calculate area using Heron's formula\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\n    # Round area to nearest integer and convert to string\n    area_str = str(round(area))\n\n    return area_str\n"
    },
    {
        "number": 4256,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    times = B // A\n    if times > C:\n        times = C\n    print(times)\n"
    },
    {
        "number": 4257,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    result = A * B\n    return str(result)\n"
    },
    {
        "number": 4258,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, T = map(int, stdin.split())\n    total_biscuits = B + (T // A) * (A + 1) + (T % A) // 2\n    return total_biscuits\n"
    },
    {
        "number": 4259,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K, A, B = map(int, stdin.split())\n    carry_distance = B - A\n\n    if carry_distance % K == 0:\n        return \"OK\"\n    else:\n        return \"NG\"\n"
    },
    {
        "number": 4260,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    T, X = map(int, stdin.split())\n    hours_in_world_b = T * X\n    hours_in_world_a = T\n    result = hours_in_world_a - hours_in_world_b\n    return result\n"
    },
    {
        "number": 4261,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    if B > A:\n        return \"Bottle 1 cannot hold more water than Bottle 2.\"\n    if C < B:\n        return \"Bottle 2 does not have enough water to transfer to Bottle 1.\"\n    else:\n        C -= B\n        return C\n"
    },
    {
        "number": 4262,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split(\"\\n\")[0])\n    P = list(map(int, stdin.split(\"\\n\")[1].split()))\n    Q = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    a = P.index(min(P))\n    b = Q.index(min(Q))\n\n    return abs(a - b)\n"
    },
    {
        "number": 4263,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    max_len = 0\n    for i in range(len(S)):\n        for j in range(i+1, len(S)+1):\n            if all(c in \"ACGT\" for c in S[i:j]):\n                max_len = max(max_len, j-i)\n    return max_len\n"
    },
    {
        "number": 4264,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    count = 0\n    for i in range(1, N+1):\n        if len(str(i)) % 2 != 0:\n            count += 1\n    return count\n"
    },
    {
        "number": 4265,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split()\n    count = 0\n    for i in range(len(S)):\n        if S[i] != T[i]:\n            count += 1\n    return count\n"
    },
    {
        "number": 4266,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = stdin.split()\n    K = int(input_values[0])\n    X = int(input_values[1])\n\n    # Calculate the range of stones that potentially contain a black stone\n    start = max(1, X - K + 1)\n    end = min(2000000, X + K - 1)\n\n    # Print the coordinates of the stones in the range\n    for i in range(start, end + 1):\n        print(i, end=\" \")\n\n    return \"\"\n"
    },
    {
        "number": 4267,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    temp = int(stdin)\n\n    # Check if temperature is 30 or above\n    if temp >= 30:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 4268,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, D = map(int, stdin.split()[:2])\n    points = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            distance = sum((points[i][k] - points[j][k]) ** 2 for k in range(D)) ** 0.5\n            if int(distance) == distance:\n                count += 1\n\n    return count\n"
    },
    {
        "number": 4269,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin\n    if len(S) != 4:\n        return \"Bad\"\n    for i in range(3):\n        if S[i] == S[i+1]:\n            return \"Bad\"\n    return \"Good\"\n"
    },
    {
        "number": 4270,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    ingredient_values = list(map(int, input_data[1].split()))\n\n    def get_max_value(ingredient_values):\n        max_value = 0\n        for i in range(len(ingredient_values)):\n            for j in range(i + 1, len(ingredient_values)):\n                new_value = (ingredient_values[i] + ingredient_values[j]) / 2\n                max_value = max(max_value, new_value)\n        return max_value\n\n    max_value = get_max_value(ingredient_values)\n    return str(max_value)\n"
    },
    {
        "number": 4271,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_input():\n        N = int(input())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        C = list(map(int, input().split()))\n        return N, A, B, C\n\n    def calculate_satisfaction_points(N, A, B, C):\n        satisfaction_points = 0\n        for i in range(N - 1):\n            satisfaction_points += B[A[i] - 1]\n            satisfaction_points += C[A[i] - 1]\n        satisfaction_points += B[A[N - 1] - 1]\n        return satisfaction_points\n\n    N, A, B, C = get_input()\n    satisfaction_points = calculate_satisfaction_points(N, A, B, C)\n    return str(satisfaction_points)\n"
    },
    {
        "number": 4272,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = map(str, stdin.split())\n    N = int(N)\n    count = 0\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            count += 1\n    return count\n"
    },
    {
        "number": 4273,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_ways(names: List[str]) -> int:\n        def count_ways_helper(names: List[str], index: int, used_letters: Set[str]) -> int:\n            if index == 3:\n                return 1\n            if index >= len(names):\n                return 0\n            count = 0\n            for i in range(len(names[index])):\n                if names[index][i] not in used_letters:\n                    count += count_ways_helper(names, index + 1, used_letters | {names[index][i]})\n            return count\n\n        return count_ways_helper(names, 0, set())\n\n    N = int(stdin.split('\\n')[0])\n    names = [line.strip() for line in stdin.split('\\n')[1:]]\n    if len(names) != N:\n        raise ValueError(\"Invalid input\")\n    if len(set(names)) != N:\n        raise ValueError(\"Duplicate names\")\n\n    result = count_ways(names)\n    return str(result)\n"
    },
    {
        "number": 4274,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    if M == N:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4275,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    if S[2] == S[3] and S[4] == S[5]:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4276,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, T = map(int, input_data[0].split())\n    routes = []\n    for i in range(1, N+1):\n        c, t = map(int, input_data[i].split())\n        routes.append((c, t))\n\n    routes.sort(key=lambda x: x[1])\n    min_cost = float('inf')\n    for c, t in routes:\n        if t <= T and c < min_cost:\n            min_cost = c\n        elif t > T:\n            break\n\n    if min_cost == float('inf'):\n        return \"TLE\"\n    else:\n        return str(min_cost)\n"
    },
    {
        "number": 4277,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = map(int, stdin.split())\n    return min(N * A, B)\n"
    },
    {
        "number": 4278,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split(\"\\n\")[0])\n    strings = stdin.split(\"\\n\")[1:]\n\n    def is_anagram(s1, s2):\n        return sorted(s1) == sorted(s2)\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if is_anagram(strings[i], strings[j]):\n                count += 1\n\n    return count\n"
    },
    {
        "number": 4279,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    sequence = \"11212312341234512345612345671234567812345678912345678910\"\n    for i in range(1, q + 1):\n        k = int(stdin.split('\\n')[i].split()[0])\n        print(sequence[k - 1])\n"
    },
    {
        "number": 4280,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, visited, parent, company, graph, result):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if neighbor != parent:\n                    dfs(neighbor, visited, node, company, graph, result)\n                else:\n                    result.append((node, neighbor, company))\n\n    n, k = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        x, y = map(int, stdin.split()[2:4])\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n\n    result = []\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, -1, 1, graph, result)\n\n    result.sort(key=lambda x: (x[0], x[1]))\n    companies = [0] * n\n    for i in range(n-1):\n        companies[result[i][0]] = result[i][2]\n        companies[result[i][1]] = result[i][2]\n\n    for i in range(n):\n        if companies[i] == 0:\n            companies[i] = 1\n\n    r = max(companies)\n    print(r)\n    print(\" \".join(map(str, companies)))\n"
    },
    {
        "number": 4281,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_occupied_houses = max(x)\n    max_occupied_houses = n + 1\n\n    for i in range(n):\n        min_occupied_houses = min(min_occupied_houses, x[i] - 1, x[i] + 1)\n        max_occupied_houses = max(max_occupied_houses, x[i] - 1, x[i] + 1)\n\n    return f\"{min_occupied_houses} {max_occupied_houses}\"\n"
    },
    {
        "number": 4282,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create a dictionary to store the remembered kids for each kid\n    remembered_kids = {i: [None, None] for i in range(1, n + 1)}\n    for i in range(n):\n        remembered_kids[a[i][0]][0] = a[i][1]\n        remembered_kids[a[i][1]][0] = a[i][0]\n        remembered_kids[a[i][0]][1] = a[i][1]\n        remembered_kids[a[i][1]][1] = a[i][0]\n\n    # Find the next kid for each kid\n    next_kid = {i: None for i in range(1, n + 1)}\n    for i in range(n):\n        if next_kid[remembered_kids[i][0]] is None:\n            next_kid[remembered_kids[i][0]] = remembered_kids[i][1]\n        else:\n            next_kid[remembered_kids[i][1]] = remembered_kids[i][0]\n\n    # Find the order of the kids in the circle\n    order = []\n    current_kid = 1\n    for i in range(n):\n        order.append(current_kid)\n        current_kid = next_kid[current_kid]\n\n    return ' '.join(map(str, order))\n"
    },
    {
        "number": 4283,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n    max_students = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(a[i] - a[j]) <= 5:\n                max_students += 1\n                break\n\n    return str(max_students)\n"
    },
    {
        "number": 4284,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    result = []\n    for _ in range(q):\n        k, n, a, b = map(int, stdin.split('\\n')[1].split())\n        if k < a:\n            result.append(-1)\n        else:\n            max_turns = 0\n            for i in range(1, n+1):\n                if k < a:\n                    break\n                if k >= a:\n                    max_turns += 1\n                    k -= a\n                elif k >= b:\n                    max_turns += 1\n                    k -= b\n            result.append(max_turns)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4285,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    k = s.count('?')\n    modulo = 10**9 + 7\n\n    def count_subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == 'a' and s[i + 1] == 'b' and s[i + 2] == 'c':\n                count += 1\n        return count\n\n    def count_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == 'a' and s[i + 1] == 'b' and s[i + 2] == 'c':\n                count += 1\n        return count\n\n    def count_subsequences_with_question_marks(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == '?' and s[i + 1] == 'b' and s[i + 2] == 'c':\n                count += 1\n        return count\n\n    def count_substrings_with_question_marks(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == '?' and s[i + 1] == 'b' and s[i + 2] == 'c':\n                count += 1\n        return count\n\n    def count_subsequences_with_question_marks_and_replaced_letters(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == '?' and s[i + 1] == 'b' and s[i + 2] == 'c':\n                count += 3 ** (k - 1)\n        return count\n\n    count_abc = count_subsequences(s)\n    count_abc_with_question_marks = count_subsequences_with_question_marks(s)\n    count_abc_with_replaced_letters = count_subsequences_with_question_marks_and_replaced_letters(s)\n\n    result = (count_abc * 3 ** k) + (count_abc_with_question_marks * 3 ** (k - 1)) - count_abc_with_replaced_letters\n    return str(result % modulo)\n"
    },
    {
        "number": 4286,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_cost(graph: list, visited: list, start: int, cost: int) -> int:\n        if visited[start]:\n            return cost\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                cost = find_min_cost(graph, visited, neighbor, cost + graph[start][neighbor])\n        return cost\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    graph = [{} for _ in range(n)]\n    for i in range(m):\n        x, y, w = map(int, stdin.split()[2 + n + i * 3:2 + n + i * 3 + 3])\n        graph[x - 1][y - 1] = w\n        graph[y - 1][x - 1] = w\n\n    visited = [False] * n\n    min_cost = float('inf')\n    for i in range(n):\n        min_cost = min(min_cost, find_min_cost(graph, visited, i, a[i]))\n\n    return min_cost\n"
    },
    {
        "number": 4287,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def can_reach(a, n, m):\n        segments = sorted([[l, r] for l, r in zip(*[iter(stdin.split())] * 2)], key=lambda x: x[1])\n        umbrellas = sorted([[x, p] for x, p in zip(*[iter(stdin.split())] * 2)], key=lambda x: x[0])\n\n        def can_reach_helper(x, fatigue):\n            if x >= a:\n                return fatigue\n            for l, r in segments:\n                if l <= x < r:\n                    return -1\n            for i, (x_i, p_i) in enumerate(umbrellas):\n                if x_i <= x < x_i + 1:\n                    return can_reach_helper(x + 1, fatigue + p_i)\n            return can_reach_helper(x + 1, fatigue)\n\n        return can_reach_helper(0, 0)\n\n    a, n, m = map(int, stdin.split()[:3])\n    if can_reach(a, n, m) == -1:\n        return \"-1\"\n    else:\n        return str(can_reach(a, n, m))\n"
    },
    {
        "number": 4288,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n\n    if A == B and A != C:\n        return \"Yes\"\n    elif B == C and B != A:\n        return \"Yes\"\n    elif A == C and A != B:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4289,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    T, A = map(int, input_data[1].split())\n    H = list(map(int, input_data[2].split()))\n\n    min_diff = float(\"inf\")\n    min_index = -1\n\n    for i in range(N):\n        temp = T - H[i] * 0.006\n        diff = abs(temp - A)\n\n        if diff < min_diff:\n            min_diff = diff\n            min_index = i\n\n    return min_index\n"
    },
    {
        "number": 4290,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    return (N * (N - 1)) // 2 + (M * (M - 1)) // 2\n"
    },
    {
        "number": 4291,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, Q = map(int, stdin.split()[:2])\n    S = stdin.split()[2]\n    result = []\n\n    for _ in range(Q):\n        l_i, r_i = map(int, stdin.split()[3:5])\n        substring = S[l_i-1:r_i]\n        count = substring.count(\"AC\")\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 4292,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[:2])\n    prices = list(map(int, stdin.split()[2:]))\n\n    prices.sort()\n\n    min_price = 0\n    for i in range(K):\n        min_price += prices[i]\n\n    return min_price\n"
    },
    {
        "number": 4293,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    P, Q, R = map(int, stdin.split())\n    return min(P + Q, P + R, Q + R)\n"
    },
    {
        "number": 4294,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, a = map(int, stdin.split())\n    if x < a:\n        return \"0\"\n    else:\n        return \"10\"\n"
    },
    {
        "number": 4295,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = stdin.split()\n    N = int(input_values[0])\n    K = int(input_values[1])\n\n    if N == 0:\n        return 0\n\n    if N < 0:\n        N = -N\n\n    if K < 0:\n        K = -K\n\n    if N < K:\n        return 0\n\n    return N - K\n"
    },
    {
        "number": 4296,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A_1, A_2, A_3 = map(int, stdin.split())\n\n    if A_1 + A_2 + A_3 >= 22:\n        return \"bust\"\n    else:\n        return \"win\"\n"
    },
    {
        "number": 4297,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    if N == 1:\n        return \"2\"\n    elif N % 2 == 0:\n        return str(N)\n    else:\n        return str(N + 1)\n"
    },
    {
        "number": 4298,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    N = int(input_data[0])\n    D = int(input_data[1])\n\n    # Calculate the minimum number of inspectors needed\n    min_inspectors = (N - 1) // (2 * D) + 1\n\n    return str(min_inspectors)\n"
    },
    {
        "number": 4299,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    if N < 1000:\n        if N % 100 == 0:\n            print(\"\u672c\")\n        elif N % 100 in [2, 4, 5, 7, 9]:\n            print(\"hon\")\n        elif N % 100 in [0, 1, 6, 8]:\n            print(\"pon\")\n        elif N % 100 == 3:\n            print(\"bon\")\n        else:\n            print(\"\u672c\")\n    else:\n        print(\"\u672c\")\n"
    },
    {
        "number": 4300,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *d = map(int, stdin.split())\n    d = list(d)\n\n    total_health = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            total_health += d[i] * d[j]\n\n    return total_health\n"
    },
    {
        "number": 4301,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    A = list(map(int, input_data[1:]))\n\n    for i in range(1, N + 1):\n        max_value = A[0]\n        for j in range(1, N):\n            if A[j] > max_value:\n                max_value = A[j]\n        print(max_value)\n"
    },
    {
        "number": 4302,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    coins = 0\n    while A > 0 and B > 0:\n        if A > B:\n            coins += B\n            A -= 1\n        else:\n            coins += A\n            B -= 1\n    return coins\n"
    },
    {
        "number": 4303,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data[0].split())\n    x_list = list(map(int, input_data[1].split()))\n\n    x_list.sort()\n\n    min_time = 0\n    for i in range(K):\n        min_time += abs(x_list[i] - x_list[K])\n\n    return min_time // 2\n"
    },
    {
        "number": 4304,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    total_height = 1 + 2 + 3 + ... + 999\n    snow_cover = (total_height - (a + b)) * 1000\n    return str(snow_cover)\n"
    },
    {
        "number": 4305,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, A = map(int, stdin.split())\n    count = 0\n    while H > 0:\n        H -= A\n        count += 1\n    return count\n"
    },
    {
        "number": 4306,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n\n    # Check if Alice and Bob were holding down their buttons at the same time\n    if A <= C <= B or C <= A <= D:\n        # Calculate the duration (in seconds) in which both Alice and Bob were holding down their buttons\n        duration = min(B, D) - max(A, C)\n        return str(duration)\n    else:\n        return \"0\"\n"
    },
    {
        "number": 4307,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    count = 0\n\n    for num in range(1, N + 1):\n        if num % 2 == 1:  # Check if the number is odd\n            divisors = 0\n            for i in range(1, num + 1):\n                if num % i == 0:\n                    divisors += 1\n            if divisors == 8:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4308,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n    min_diff = float('inf')\n\n    for i in range(1, N + 1):\n        if i % K == 0:\n            min_diff = min(min_diff, i)\n        else:\n            min_diff = min(min_diff, N // K - (i % K))\n\n    return min_diff\n"
    },
    {
        "number": 4309,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if N < 100 or N > 999:\n        raise ValueError(\"Invalid input. N must be between 100 and 999.\")\n\n    # Find the first ABC where all digits are the same\n    for abc in range(100, 1000):\n        if len(set(str(abc))) == 1:\n            return abc\n\n    # If no such ABC exists, return -1\n    return -1\n"
    },
    {
        "number": 4310,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A = list(map(int, stdin.split()))\n    n = len(A)\n    dp = [0] * n\n    dp[0] = 0\n\n    for i in range(1, n):\n        dp[i] = min(dp[j] + abs(A[i] - A[j]) for j in range(i))\n\n    return dp[-1]\n"
    },
    {
        "number": 4311,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = int(stdin)\n    a = [s]\n    n = 1\n    while n < 1000000:\n        if n % 2 == 0:\n            a.append(n // 2)\n        else:\n            a.append(3 * n + 1)\n        n += 1\n\n    m = 1\n    while m < len(a):\n        if a[m] in a[:m]:\n            break\n        m += 1\n\n    return m\n"
    },
    {
        "number": 4312,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n\n    while A > 0 and C > 0:\n        if A > C:\n            C -= B\n        else:\n            A -= D\n\n        if A <= 0:\n            return \"Yes\"\n        elif C <= 0:\n            return \"No\"\n\n        A, B, C, D = C, D, A, B\n\n    return \"Yes\" if A > 0 else \"No\"\n"
    },
    {
        "number": 4313,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    V = list(map(int, stdin.split('\\n')[1].split()))\n    C = list(map(int, stdin.split('\\n')[2].split()))\n\n    X = sum(V)\n    Y = sum(C)\n\n    return str(max(X - Y, 0))\n"
    },
    {
        "number": 4314,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W = map(int, stdin.split()[:2])\n    grid = [list(input().strip()) for _ in range(H)]\n\n    while any(all(cell == '.' for cell in row) for row in grid) or any(all(cell == '.' for cell in col) for col in zip(*grid)):\n        for i in range(H):\n            if all(grid[i][j] == '.' for j in range(W)):\n                grid.pop(i)\n                H -= 1\n                break\n        else:\n            for j in range(W):\n                if all(grid[i][j] == '.' for i in range(H)):\n                    for row in grid:\n                        row.pop(j)\n                    W -= 1\n                    break\n            else:\n                raise ValueError(\"No row or column with only white squares found\")\n\n    return ''.join(''.join(row) for row in grid)\n"
    },
    {
        "number": 4315,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R = int(stdin.strip())\n    if 1 <= R <= 100:\n        circumference = 2 * 3.14 * R\n        return str(circumference)\n    else:\n        return \"Invalid input. 1 <= R <= 100\" "
    },
    {
        "number": 4316,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    char_count = {}\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    if len(char_count) == 2 and 4 in char_count.values():\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4317,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    max_num = max(A + B, A - B, A * B)\n    return str(max_num)\n"
    },
    {
        "number": 4318,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *H = map(int, stdin.split())\n    count = 0\n    for i in range(N):\n        if all(H[j] <= H[i] for j in range(i)):\n            count += 1\n    return count\n"
    },
    {
        "number": 4319,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    t = 1\n    steps = []\n    steps.append(a[0])\n\n    for i in range(1, n):\n        if a[i] == steps[-1] + 1:\n            steps[-1] += 1\n        else:\n            t += 1\n            steps.append(a[i])\n\n    print(t)\n    print(' '.join(map(str, steps)))\n"
    },
    {
        "number": 4320,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_x(n: int) -> int:\n        x = 1\n        while n % 2 == 0:\n            n //= 2\n            x *= 2\n        return x\n\n    t = int(stdin)\n    for _ in range(t):\n        n = int(input())\n        x = find_x(n)\n        print(x)\n"
    },
    {
        "number": 4321,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split())\n    result = n\n    for _ in range(k):\n        if result % 10 == 0:\n            result //= 10\n        else:\n            result -= 1\n    return str(result)\n"
    },
    {
        "number": 4322,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_balanced(circle: list) -> bool:\n        for i in range(len(circle)):\n            if abs(circle[i] - circle[(i + 1) % len(circle)]) > 1:\n                return False\n        return True\n\n    n, *a = map(int, stdin.split())\n    a.sort()\n    max_circle = []\n    for i in range(n):\n        max_circle.append(a[i])\n        if is_balanced(max_circle):\n            break\n        max_circle.append(a[n - i - 1])\n        if is_balanced(max_circle):\n            break\n\n    result = [max_circle[i] for i in range(len(max_circle))]\n    return f\"{len(max_circle)}\\n{' '.join(map(str, result))}\"\n"
    },
    {
        "number": 4323,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    songs = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    songs.sort(key=lambda x: x[1])\n\n    total_size = sum(song[0] for song in songs)\n    if total_size > m:\n        return \"-1\"\n\n    count = 0\n    total_compressed_size = 0\n    for song in songs:\n        if total_compressed_size + song[1] <= m:\n            total_compressed_size += song[1]\n        else:\n            count += 1\n            total_compressed_size = song[1]\n\n    return count\n"
    },
    {
        "number": 4324,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def generate_string(n: int, a: int, b: int) -> str:\n        if a > n:\n            return \"\"\n        if a == n:\n            return \"\".join(chr(i) for i in range(ord('a'), ord('a') + b))\n        if b == 1:\n            return \"a\" * a\n        if a == 1:\n            return \"a\" * b\n\n        # Generate a string with b distinct letters\n        distinct_letters = \"\".join(chr(i) for i in range(ord('a'), ord('a') + b))\n\n        # Generate a string with a - b distinct letters\n        remaining_letters = \"\".join(chr(i) for i in range(ord('a'), ord('a') + a - b))\n\n        # Generate a string with a - b distinct letters\n        remaining_letters = \"\".join(chr(i) for i in range(ord('a'), ord('a') + a - b))\n\n        # Combine the two strings\n        return distinct_letters + remaining_letters\n\n    def main(stdin: str) -> str:\n        t = int(stdin.split()[0])\n        for _ in range(t):\n            n, a, b = map(int, stdin.split()[1:])\n            result = generate_string(n, a, b)\n            print(result)\n\n    return main(stdin)\n"
    },
    {
        "number": 4325,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, X, T = map(int, stdin.split())\n    return (N // X) * T\n"
    },
    {
        "number": 4326,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    groups = 0\n    for i in range(3, N+1):\n        groups += N // i\n    return groups\n"
    },
    {
        "number": 4327,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, P = map(int, stdin.split())\n    pies = 0\n    while A >= 3:\n        A -= 3\n        pies += 1\n        if A >= 2:\n            A -= 2\n            pies += 1\n    return pies\n"
    },
    {
        "number": 4328,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    if B % A == 0:\n        return str(A + B)\n    else:\n        return str(B - A)\n"
    },
    {
        "number": 4329,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split()\n    if len(S) == len(T) - 1 and T.startswith(S) and T[len(S)] in string.ascii_lowercase:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4330,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    if A == B:\n        return \"IMPOSSIBLE\"\n    elif A > B:\n        A, B = B, A\n    for K in range(A, B+1):\n        if abs(A - K) == abs(B - K):\n            return str(K)\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 4331,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if N // 100 == 7 or N // 1000 == 7 or N % 10 == 7:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4332,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    sum_of_digits = sum(int(digit) for digit in str(N))\n    if N % sum_of_digits == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4333,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    # Calculate the area of the square\n    area = (x1 * y2) - (x2 * y1)\n\n    # Calculate the coordinates of the missing vertices\n    x3 = (y1 * (x1 + x2) - y2 * (x1 * x1 + x2 * x2)) // area\n    y3 = (-1 * (x1 * (x1 + x2) - x2 * (x1 * x1 + x2 * x2))) // area\n\n    x4 = (y1 * (x1 + x2) - y2 * (x1 * x1 + x2 * x2)) // area\n    y4 = (-1 * (x1 * (x1 + x2) - x2 * (x1 * x1 + x2 * x2))) // area\n\n    # Print the missing vertices\n    print(x3, y3, x4, y4)\n"
    },
    {
        "number": 4334,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T, U = stdin.split()\n    A, B = map(int, input().split())\n    balls = A + B\n    if S == U:\n        balls -= A\n    elif T == U:\n        balls -= B\n    print(balls)\n"
    },
    {
        "number": 4335,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    S = stdin.split('\\n')[1]\n\n    if N % 2 == 0:\n        return \"Yes\"\n\n    for i in range(1, N // 2 + 1):\n        if S[:i] * 2 == S and len(S) % i == 0:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4336,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    W, H, x, y = map(int, stdin.split())\n\n    # Calculate the area of the rectangle\n    rect_area = W * H\n\n    # Calculate the area of the triangle formed by the point (x, y) and the two sides of the rectangle\n    triangle_area = 0.5 * (x * H - y * W)\n\n    # Calculate the area of the two parts of the rectangle\n    part1_area = rect_area - triangle_area\n    part2_area = triangle_area\n\n    # Check if the point (x, y) is within the rectangle or on its border\n    if x == 0 or x == W or y == 0 or y == H:\n        # If the point is on the border, the maximum area is the area of the part that is not larger than the other\n        max_area = min(part1_area, part2_area)\n        multiple_ways = 0\n    else:\n        # If the point is within the rectangle, there is only one way to cut the rectangle\n        max_area = part1_area\n        multiple_ways = 1\n\n    # Print the maximum area and the multiple_ways flag\n    print(max_area)\n    print(multiple_ways)\n"
    },
    {
        "number": 4337,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *S = stdin.split()\n    N = int(N)\n    colors = set(S)\n\n    if len(colors) == 3:\n        return \"Three\"\n    elif len(colors) == 4:\n        return \"Four\"\n    else:\n        return \"Invalid\"\n"
    },
    {
        "number": 4338,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, x, y = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    doors_with_zero_durability = 0\n    for i in range(n):\n        if a[i] == 0:\n            doors_with_zero_durability += 1\n\n    return doors_with_zero_durability\n"
    },
    {
        "number": 4339,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] > b[i] + b[j]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4340,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(1, 6):\n        for j in range(n):\n            if a[j] == i:\n                a[j] = i + 1 if i % 2 == 1 else i - 1\n            if a[j] == i + 5:\n                a[j] = i + 4 if i % 2 == 1 else i - 4\n            if a[j] == i + 10:\n                a[j] = i + 9 if i % 2 == 1 else i - 9\n\n    return ' '.join(map(str, a))\n"
    },
    {
        "number": 4341,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    from collections import defaultdict\n    from itertools import permutations\n\n    def find_cycle(graph, start):\n        visited = set()\n        path = [start]\n        while path:\n            node = path[-1]\n            if node in visited:\n                visited.remove(node)\n                path.pop()\n            else:\n                visited.add(node)\n                path.append(graph[node])\n                if node == start:\n                    return True\n        return False\n\n    n, m = map(int, stdin.split()[0:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = defaultdict(int)\n    for u, v in edges:\n        graph[u] = v\n        graph[v] = u\n\n    connected_components = []\n    visited = set()\n    for i in range(1, n + 1):\n        if i not in visited:\n            connected_components.append(i)\n            visited.add(i)\n            while True:\n                found_cycle = False\n                for cycle in permutations(connected_components):\n                    if all(find_cycle(graph, start) for start in cycle):\n                        found_cycle = True\n                        break\n                if not found_cycle:\n                    break\n                connected_components.append(cycle[-1])\n                visited.update(cycle)\n\n    cycles = [connected_component for connected_component in connected_components if len(connected_component) > 2]\n    return len(cycles)\n"
    },
    {
        "number": 4342,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, parent, color, visited, graph):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if not visited[neighbor]:\n                    dfs(neighbor, node, color, visited, graph)\n                    if color[neighbor] == 0:\n                        color[neighbor] = color[node]\n                    else:\n                        if color[neighbor] != color[node]:\n                            nice_edges += 1\n\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n    graph = [[] for _ in range(n)]\n    for edge in stdin.split('\\n')[2:]:\n        v, u = map(int, edge.split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    color = [0] * n\n    color[0] = colors[0]\n    visited = [False] * n\n    dfs(0, -1, color[0], visited, graph)\n\n    for i in range(1, n):\n        if not visited[i]:\n            color[i] = colors[i]\n            dfs(i, -1, color[i], visited, graph)\n\n    nice_edges = 0\n    for edge in stdin.split('\\n')[2:]:\n        v, u = map(int, edge.split())\n        if color[v] != color[u]:\n            nice_edges += 1\n\n    return str(nice_edges)\n"
    },
    {
        "number": 4343,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    k = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    def is_valid(string):\n        return s <= string <= t\n\n    def generate_strings():\n        for i in range(ord('a'), ord('a') + k):\n            for j in range(ord('a'), ord('a') + k):\n                if i < j:\n                    yield chr(i) + chr(j)\n                elif i > j:\n                    yield chr(j) + chr(i)\n\n    valid_strings = sorted(filter(is_valid, generate_strings()))\n\n    if len(valid_strings) % 2 == 0:\n        median = (valid_strings[len(valid_strings) // 2 - 1] + valid_strings[len(valid_strings) // 2])[:k]\n    else:\n        median = valid_strings[len(valid_strings) // 2][:k]\n\n    return median\n"
    },
    {
        "number": 4344,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    if k > n:\n        return \"NO\"\n\n    for i in range(n):\n        if a.count(a[i]) == 1:\n            team = [i]\n            break\n    else:\n        return \"NO\"\n\n    for i in range(n):\n        if i not in team and a[i] == min(a):\n            team.append(i)\n            if len(team) == k:\n                break\n\n    if len(team) < k:\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, team))\n"
    },
    {
        "number": 4345,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    increasing_sequence = []\n    decreasing_sequence = []\n\n    for i in range(n):\n        if i == 0 or a[i] > a[i - 1]:\n            increasing_sequence.append(a[i])\n        else:\n            decreasing_sequence.append(a[i])\n\n    if len(increasing_sequence) == 0 or len(decreasing_sequence) == 0:\n        return \"NO\"\n\n    res = [0] * n\n    for i in range(n):\n        if i == 0 or a[i] > a[i - 1]:\n            res[i] = 0\n        else:\n            res[i] = 1\n\n    return \"YES\\n\" + ' '.join(map(str, res))\n"
    },
    {
        "number": 4346,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_lanterns(L, v, l, r):\n        count = 0\n        for p in range(l, r + 1, v):\n            if p % v == 0 and p not in range(l, r + 1):\n                count += 1\n        return count\n\n    t = int(stdin.splitlines()[0])\n    result = []\n    for i in range(1, t + 1):\n        L, v, l, r = map(int, stdin.splitlines()[i].split())\n        result.append(count_lanterns(L, v, l, r))\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4347,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    if n == 2:\n        return \"1\"\n    elif n == 4:\n        return \"3\"\n    elif n == 6:\n        return \"8\"\n    elif n == 8:\n        return \"23\"\n    elif n == 10:\n        return \"55\"\n    elif n == 12:\n        return \"149\"\n    elif n == 14:\n        return \"403\"\n    elif n == 16:\n        return \"1105\"\n    elif n == 18:\n        return \"2931\"\n    elif n == 20:\n        return \"7429\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 4348,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    s = input_data[1]\n\n    for _ in range(k):\n        if 'a' in s:\n            s = s[s.index('a') + 1:]\n            break\n        elif 'b' in s:\n            s = s[s.index('b') + 1:]\n            break\n        elif 'c' in s:\n            s = s[s.index('c') + 1:]\n            break\n        elif 'd' in s:\n            s = s[s.index('d') + 1:]\n            break\n        elif 'e' in s:\n            s = s[s.index('e') + 1:]\n            break\n        elif 'f' in s:\n            s = s[s.index('f') + 1:]\n            break\n        elif 'g' in s:\n            s = s[s.index('g') + 1:]\n            break\n        elif 'h' in s:\n            s = s[s.index('h') + 1:]\n            break\n        elif 'i' in s:\n            s = s[s.index('i') + 1:]\n            break\n        elif 'j' in s:\n            s = s[s.index('j') + 1:]\n            break\n        elif 'k' in s:\n            s = s[s.index('k') + 1:]\n            break\n        elif 'l' in s:\n            s = s[s.index('l') + 1:]\n            break\n        elif 'm' in s:\n            s = s[s.index('m') + 1:]\n            break\n        elif 'n' in s:\n            s = s[s.index('n') + 1:]\n            break\n        elif 'o' in s:\n            s = s[s.index('o') + 1:]\n            break\n        elif 'p' in s:\n            s = s[s.index('p') + 1:]\n            break\n        elif 'q' in s:\n            s = s[s.index('q') + 1:]\n            break\n        elif 'r' in s:\n            s = s[s.index('r') + 1:]\n            break\n        elif 's' in s:\n            s = s[s.index('s') + 1:]\n            break\n        elif 't' in s:\n            s = s[s.index('t') + 1:]\n            break\n        elif 'u' in s:\n            s = s[s.index('u') + 1:]\n            break\n        elif 'v' in s:\n            s = s[s.index('v') + 1:]\n            break\n        elif 'w' in s:\n            s = s[s.index('w') + 1:]\n            break\n        elif 'x' in s:\n            s = s[s.index('x') + 1:]\n            break\n        elif 'y' in s:\n            s = s[s.index('y') + 1:]\n            break\n        elif 'z' in s:\n            s = s[s.index('z') + 1:]\n            break\n        else:\n            break\n\n    return s\n"
    },
    {
        "number": 4349,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_min_day(d, t, k, offers):\n        for offer in offers:\n            if offer[0] <= d and offer[1] == t:\n                return offer[0]\n        return d + 1\n\n    n, m = map(int, stdin.split()[:2])\n    k = list(map(int, stdin.split()[2:2 + n]))\n    offers = [tuple(map(int, stdin.split()[2 + n + i:2 + n + i + 2])) for i in range(m)]\n\n    min_day = 1\n    for i in range(n):\n        min_day = max(min_day, get_min_day(min_day, i, k[i], offers))\n\n    return str(min_day)\n"
    },
    {
        "number": 4350,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split()[0].split(','))\n    grid = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x, y, size):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            for i in range(1, size):\n                if not (0 <= x + i * dx < n and 0 <= y + i * dy < m):\n                    return False\n                if grid[x + i * dx][y + i * dy] != '*':\n                    return False\n        return True\n\n    stars = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                for size in range(1, min(i + 1, m - j) + 1):\n                    if is_valid(i, j, size):\n                        stars.append((i, j, size))\n                        break\n\n    if not stars:\n        return \"-1\"\n\n    k = len(stars)\n    result = [f\"{k}\\n\"]\n    for x, y, size in stars:\n        result.append(f\"{x} {y} {size}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4351,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if str(N) == str(N)[::-1]:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4352,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n\n    if A > B:\n        return \"Alice\"\n    elif B > A:\n        return \"Bob\"\n    else:\n        return \"Draw\"\n"
    },
    {
        "number": 4353,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    return s[:5] + ' ' + s[6:13] + ' ' + s[14:]\n"
    },
    {
        "number": 4354,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_nearest_checkpoint(student_coords, checkpoints):\n        nearest_checkpoint = None\n        min_distance = float('inf')\n        for i, checkpoint in enumerate(checkpoints):\n            distance = manhattan_distance(student_coords[0], student_coords[1], checkpoint[0], checkpoint[1])\n            if distance < min_distance:\n                min_distance = distance\n                nearest_checkpoint = i\n        return nearest_checkpoint\n\n    N, M = map(int, stdin.split()[:2])\n    students = [tuple(map(int, stdin.split()[2 * i: 2 * i + 2])) for i in range(N)]\n    checkpoints = [tuple(map(int, stdin.split()[2 * N + 2 * i: 2 * N + 2 * i + 2])) for i in range(M)]\n\n    for i in range(N):\n        nearest_checkpoint = find_nearest_checkpoint(students[i], checkpoints)\n        print(nearest_checkpoint)\n"
    },
    {
        "number": 4355,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a = int(stdin)\n    result = a + a**2 + a**3\n    return str(result)\n"
    },
    {
        "number": 4356,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_contained(A: str, B: str) -> bool:\n        for i in range(len(A) - len(B) + 1):\n            if A[i:i + len(B)] == B:\n                return True\n        return False\n\n    def parallel_shift(A: str, B: str) -> bool:\n        for i in range(len(A) - len(B) + 1):\n            if is_contained(A[i:] + A[:i], B):\n                return True\n        return False\n\n    N, M = map(int, stdin.split()[:2])\n    A = stdin.split('\\n')[1:N + 1]\n    B = stdin.split('\\n')[N + 1:]\n\n    if parallel_shift(''.join(A), ''.join(B)):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4357,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    max_allowance = max(A + B, A + C, B + C)\n    return str(max_allowance)\n"
    },
    {
        "number": 4358,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    N = int(stdin.split()[0])\n    p = [int(x) for x in stdin.split()[1:]]\n\n    # Sort the prices in descending order\n    p.sort(reverse=True)\n\n    # Calculate the total amount\n    total = 0\n    for i in range(N):\n        if i == 0:\n            total += p[0]\n        elif i == 1:\n            total += p[1] // 2\n        else:\n            total += p[i]\n\n    return total\n"
    },
    {
        "number": 4359,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D, E = map(int, stdin.split())\n\n    # Find the latest time for the first dish to be served\n    latest_time_for_first_dish = 0\n    if A % 10 != 0:\n        latest_time_for_first_dish = A - (A % 10) + 10\n\n    # Find the latest time for the second dish to be served\n    latest_time_for_second_dish = 0\n    if B % 10 != 0:\n        latest_time_for_second_dish = B - (B % 10) + 10\n\n    # Find the latest time for the third dish to be served\n    latest_time_for_third_dish = 0\n    if C % 10 != 0:\n        latest_time_for_third_dish = C - (C % 10) + 10\n\n    # Find the latest time for the fourth dish to be served\n    latest_time_for_fourth_dish = 0\n    if D % 10 != 0:\n        latest_time_for_fourth_dish = D - (D % 10) + 10\n\n    # Find the latest time for the fifth dish to be served\n    latest_time_for_fifth_dish = 0\n    if E % 10 != 0:\n        latest_time_for_fifth_dish = E - (E % 10) + 10\n\n    # Find the latest time for all dishes to be served\n    latest_time_for_all_dishes = max(latest_time_for_first_dish, latest_time_for_second_dish, latest_time_for_third_dish, latest_time_for_fourth_dish, latest_time_for_fifth_dish)\n\n    # Find the earliest time for the last dish to be delivered\n    earliest_time_for_last_dish = latest_time_for_all_dishes + 10\n\n    return earliest_time_for_last_dish\n"
    },
    {
        "number": 4360,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *A = map(int, stdin.split())\n    A_inv = [1 / a for a in A]\n    sum_inv = sum(A_inv)\n    result = 1 / sum_inv\n    return str(result)\n"
    },
    {
        "number": 4361,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:]))\n\n    heights.sort()\n\n    h_max = heights[-K]\n    h_min = heights[K-1]\n\n    return str(h_max - h_min)\n"
    },
    {
        "number": 4362,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    alpha = stdin.strip()\n    if alpha.isupper():\n        return \"A\"\n    elif alpha.islower():\n        return \"a\"\n    else:\n        return \"Invalid input\" "
    },
    {
        "number": 4363,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K, S = map(int, stdin.split())\n    if 2 <= K <= 2500 and 0 <= S <= 3 * K:\n        count = 0\n        for x in range(K + 1):\n            for y in range(K + 1):\n                z = S - x - y\n                if 0 <= z <= K:\n                    count += 1\n        return str(count)\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4364,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin\n    if len(S) != 4:\n        return \"NA\"\n\n    if S[2] == '0':\n        return \"NA\"\n\n    if S[0] == '0':\n        return \"NA\"\n\n    if S[0] == '1' and S[1] == '9':\n        return \"NA\"\n\n    if S[0] == '2' and S[1] == '0':\n        return \"NA\"\n\n    if S[0] == '2' and S[1] == '1':\n        return \"NA\"\n\n    if S[0] == '2' and S[1] == '9':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '0':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '1':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '2':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '3':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '4':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '5':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '6':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '7':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '8':\n        return \"NA\"\n\n    if S[0] == '3' and S[1] == '9':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '0':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '1':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '2':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '3':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '4':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '5':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '6':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '7':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '8':\n        return \"NA\"\n\n    if S[0] == '4' and S[1] == '9':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '0':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '1':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '2':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '3':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '4':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '5':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '6':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '7':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '8':\n        return \"NA\"\n\n    if S[0] == '5' and S[1] == '9':\n        return \"NA\"\n\n    if S[0] == '6' and S[1] == '0':\n        return \"NA\"\n\n    if S[0] == '6' and S[1] == '1"
    },
    {
        "number": 4365,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K = int(stdin.split()[0])\n    even_count = odd_count = 0\n\n    for i in range(1, K + 1):\n        if i % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return (even_count * odd_count) // 2 "
    },
    {
        "number": 4366,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    contest_start_hour = A + B\n    return str(contest_start_hour)\n"
    },
    {
        "number": 4367,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, R = map(int, stdin.split())\n    if N >= 10:\n        return R\n    else:\n        K = 10 - N\n        return R - 100 * K\n"
    },
    {
        "number": 4368,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = stdin.split()\n    N = int(input_values[0])\n    K = int(input_values[1])\n\n    # Calculate the number of digits in base K\n    digits_count = 0\n    while N > 0:\n        digits_count += 1\n        N //= K\n\n    return digits_count\n"
    },
    {
        "number": 4369,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    sheets_needed = (N // 2) + (N % 2)\n    return str(sheets_needed)\n"
    },
    {
        "number": 4370,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n\n    if 1 <= A <= 16 and 1 <= B <= 16 and abs(A - B) > 1 and A + B <= 16:\n        return \"Yay!\"\n    else:\n        return \":(\"\n"
    },
    {
        "number": 4371,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin\n    min_diff = float('inf')\n    \n    for i in range(len(S) - 2):\n        X = int(S[i] + S[i+1] + S[i+2])\n        diff = abs(X - 753)\n        min_diff = min(min_diff, diff)\n        \n    return str(min_diff)\n"
    },
    {
        "number": 4372,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, a = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    x = sum(a)\n    y = 1\n    z = 0\n    for i in range(n):\n        if a[i] != 0:\n            z = a[i]\n            break\n    while y * z <= x:\n        y += 1\n    return str(y) + \" \" + str(z)\n"
    },
    {
        "number": 4373,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if a[i - 1] >= j:\n                dp[i] = max(dp[i], dp[i - j] + 1)\n    return dp[n]\n"
    },
    {
        "number": 4374,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_diameter(graph: list, n: int) -> int:\n        def dfs(node: int, visited: set, parent: int, depth: int, max_depth: int, max_depth_node: int) -> None:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    if depth + 1 > max_depth:\n                        max_depth = depth + 1\n                        max_depth_node = neighbor\n                    dfs(neighbor, visited, node, depth + 1, max_depth, max_depth_node)\n\n        max_depth = 0\n        max_depth_node = -1\n        visited = set()\n        for node in range(1, n + 1):\n            if node not in visited:\n                dfs(node, visited, -1, 0, max_depth, max_depth_node)\n        return max_depth\n\n    def add_edges(graph: list, n: int, m: int) -> list:\n        added_edges = []\n        for i in range(m):\n            v, u = map(int, input().split())\n            graph[v].append(u)\n            graph[u].append(v)\n            added_edges.append((v, u))\n        return added_edges\n\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        v, u = map(int, input().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    diameter = find_diameter(graph, n)\n    added_edges = add_edges(graph, n, n - 1 - m)\n\n    result = [str(diameter)]\n    for v, u in added_edges:\n        result.append(f\"{v} {u}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4375,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, parent, graph, visited, weights, depth):\n        visited[node] = True\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, graph, visited, weights, depth + 1)\n                if depth < k:\n                    weights[node] += weights[child]\n\n    n, k = map(int, stdin.split()[:2])\n    weights = list(map(int, stdin.split()[2:]))\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[2 + n + i * 2:2 + n + i * 2 + 2])\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    max_weight = 0\n    for i in range(n):\n        if not visited[i]:\n            weights[i] = 0\n            dfs(i, -1, graph, visited, weights, 0)\n            max_weight = max(max_weight, weights[i])\n\n    return max_weight\n"
    },
    {
        "number": 4376,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:]))\n\n    total_rooms = sum(a)\n    room_count = 0\n\n    for i in range(n):\n        room_count += a[i]\n        if room_count >= total_rooms:\n            break\n\n    for j in range(m):\n        room_number = b[j]\n        if room_number <= a[i]:\n            print(i+1, room_number)\n        else:\n            room_number -= a[i]\n            for k in range(i+1, n):\n                room_number -= a[k]\n                if room_number <= a[k]:\n                    print(k+1, room_number)\n                    break\n"
    },
    {
        "number": 4377,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x1, x2, x3, x4 = map(int, stdin.split())\n\n    a = x1 - x2\n    b = x1 - x3\n    c = x1 - x4\n\n    print(a, b, c)\n"
    },
    {
        "number": 4378,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    s = input_data[1]\n\n    # Initialize the diverse garland with the initial colors\n    diverse_garland = [s[i] for i in range(n)]\n\n    # Initialize the minimum number of recolors needed\n    min_recolors = n\n\n    # Iterate through the diverse garland and check if the adjacent lamps have distinct colors\n    for i in range(n - 1):\n        if diverse_garland[i] == diverse_garland[i + 1]:\n            # If adjacent lamps have the same color, recolor one of them\n            diverse_garland[i + 1] = 'R' if diverse_garland[i] == 'G' else 'G' if diverse_garland[i] == 'B' else 'B'\n            min_recolors -= 1\n\n    # Print the minimum number of recolors needed and the diverse garland\n    return f\"{min_recolors}\\n{''.join(diverse_garland)}\"\n"
    },
    {
        "number": 4379,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    arr = list(map(int, input_data[1].split()))\n\n    max_length = 1\n    max_subsequence = [0]\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            current_length = 1\n            while i + current_length < n and arr[i + current_length] == arr[i] + current_length:\n                current_length += 1\n            if current_length > max_length:\n                max_length = current_length\n                max_subsequence = [i] + list(range(i, i + current_length))\n\n    output = f\"{max_length}\\n{' '.join(map(str, max_subsequence))}\"\n    return output\n"
    },
    {
        "number": 4380,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    for C in range(1, 4):\n        if (A * B * C) % 2 != 0:\n            return \"Yes\"\n    return \"No\"\n"
    },
    {
        "number": 4381,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, Y = map(int, stdin.split())\n    x = X + (Y // 2)\n    return str(x)\n"
    },
    {
        "number": 4382,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    if 1 <= N <= 9:\n        num_passwords = 3 ** N\n        return str(num_passwords)\n    else:\n        return \"Invalid input. N must be between 1 and 9, inclusive.\" "
    },
    {
        "number": 4383,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin)\n    if X >= 7 and X <= 9:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4384,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n\n    if N <= 999:\n        return \"ABC\" + str(N + 1).zfill(3)\n    elif N <= 1998:\n        return \"ABD\" + str(N - 999).zfill(3)\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4385,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c, d, e, k = map(int, stdin.split())\n\n    antennas = [a, b, c, d, e]\n    antennas.sort()\n\n    for i in range(len(antennas) - 1):\n        for j in range(i + 1, len(antennas)):\n            if antennas[j] - antennas[i] > k:\n                return \":( \"\n\n    return \"Yay! \"\n"
    },
    {
        "number": 4386,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, s = map(str, stdin.split())\n    a = int(a)\n\n    if a >= 3200:\n        print(s)\n    else:\n        print(\"red\")\n"
    },
    {
        "number": 4387,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R = int(stdin)\n\n    if R < 1200:\n        return \"ABC\"\n    elif R < 2800:\n        return \"ARC\"\n    else:\n        return \"AGC\"\n"
    },
    {
        "number": 4388,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    result = \"\"\n    for digit in str(n):\n        if digit == \"1\":\n            result += \"9\"\n        elif digit == \"9\":\n            result += \"1\"\n        else:\n            result += digit\n    return int(result)\n"
    },
    {
        "number": 4389,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_string(s: str) -> bool:\n        for c in s:\n            if c not in \"abcdefghijklmnopqrstuvwxyz\":\n                return False\n        return True\n\n    def build_b(a: str) -> str:\n        substrings = sorted(set(a[i:i+2] for i in range(len(a) - 1)))\n        return \"\".join(substrings)\n\n    t = int(stdin.splitlines()[0])\n    test_cases = stdin.splitlines()[1:]\n\n    for i, test_case in enumerate(test_cases, start=1):\n        b = test_case\n        if not is_valid_string(b):\n            print(\"Invalid string\")\n            continue\n\n        a = build_b(b)\n        print(a)\n"
    },
    {
        "number": 4390,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_moves(a, b):\n        moves = 0\n        while a % b != 0:\n            a += 1\n            moves += 1\n        return moves\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        output.append(count_moves(a, b))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4391,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def calculate_average(arr, x, y):\n        return sum(arr[x:y+1]) / (y - x + 1)\n\n    def calculate_heat_intensity(arr, k):\n        heat_intensity = 0\n        for i in range(len(arr) - k):\n            avg = calculate_average(arr, i, i + k - 1)\n            if avg > heat_intensity:\n                heat_intensity = avg\n        return heat_intensity\n\n    n, k = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:]))\n\n    heat_intensity = calculate_heat_intensity(arr, k)\n    return heat_intensity\n"
    },
    {
        "number": 4392,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    def is_sorted(a):\n        return all(a[i] <= a[i + 1] for i in range(len(a) - 1))\n\n    def can_sort(a, p):\n        for i in range(len(p)):\n            if a[p[i]] > a[p[i] + 1]:\n                return False\n        return True\n\n    def process_test_case(a, p):\n        for i in range(len(p)):\n            if a[p[i]] > a[p[i] + 1]:\n                swap(a, p[i], p[i] + 1)\n                if not can_sort(a, p):\n                    return \"NO\"\n        return \"YES\" if is_sorted(a) else \"NO\"\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        p = list(map(int, stdin.readline().split()))\n        print(process_test_case(a, p))\n"
    },
    {
        "number": 4393,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    t = stdin.split('\\n')[1]\n\n    s = ''\n    count = 1\n    for char in t:\n        if char == 'a':\n            s += 'a' * count\n            count = 1\n        else:\n            count += 1\n    return s\n"
    },
    {
        "number": 4394,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find(parent, u):\n        if parent[u] == -1:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u = find(parent, u)\n        v = find(parent, v)\n        if u == v:\n            return False\n        if rank[u] < rank[v]:\n            parent[u] = v\n        else:\n            parent[v] = u\n            if rank[u] == rank[v]:\n                rank[u] += 1\n        return True\n\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, stdin.split()[2:])) for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n\n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    mst_cost = 0\n    for u, v, w in edges:\n        if union(parent, rank, u, v):\n            mst_cost += w\n            if mst_cost > k:\n                return -1\n\n    k = mst_cost\n    operations = 0\n    for u, v, w in reversed(edges):\n        if not union(parent, rank, u, v):\n            operations += 1\n            if operations >= k - mst_cost:\n                return -1\n    return operations\n"
    },
    {
        "number": 4395,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    s = input_data[1]\n\n    def is_nice(garland):\n        for i in range(n - 2):\n            if garland[i] == garland[i + 1] and garland[i + 1] == garland[i + 2]:\n                return True\n        return False\n\n    def recolor(garland, i, color):\n        garland[i] = color\n        return garland\n\n    def get_neighbors(i):\n        return [i - 1, i + 1]\n\n    def dfs(garland, i, visited, stack):\n        visited[i] = True\n        stack.append(i)\n\n        for neighbor in get_neighbors(i):\n            if not visited[neighbor] and garland[neighbor] != garland[i]:\n                dfs(garland, neighbor, visited, stack)\n\n        return stack\n\n    def min_recolor(garland):\n        visited = [False] * n\n        stack = []\n        for i in range(n):\n            if not visited[i]:\n                dfs(garland, i, visited, stack)\n\n        min_recolor = 0\n        for i in range(n):\n            if garland[i] != s[i]:\n                min_recolor += 1\n\n        return min_recolor\n\n    def min_recolor_dfs(garland, i, visited, stack):\n        visited[i] = True\n        stack.append(i)\n\n        for neighbor in get_neighbors(i):\n            if not visited[neighbor] and garland[neighbor] != garland[i]:\n                min_recolor_dfs(garland, neighbor, visited, stack)\n\n        return stack\n\n    def min_recolor_dfs_helper(garland, i, visited, stack, min_recolor):\n        visited[i] = True\n        stack.append(i)\n\n        for neighbor in get_neighbors(i):\n            if not visited[neighbor] and garland[neighbor] != garland[i]:\n                min_recolor_dfs_helper(garland, neighbor, visited, stack, min_recolor)\n\n        if is_nice(garland):\n            return min_recolor\n        else:\n            return min_recolor + 1\n\n    def min_recolor_dfs_final(garland):\n        visited = [False] * n\n        stack = []\n        min_recolor = 0\n\n        for i in range(n):\n            if not visited[i]:\n                min_recolor = min_recolor_dfs_helper(garland, i, visited, stack, min_recolor)\n\n        return min_recolor\n\n    def min_recolor_bfs(garland):\n        queue = []\n        min_recolor = 0\n\n        for i in range(n):\n            if garland[i] != s[i]:\n                queue.append(i)\n                min_recolor += 1\n\n        while queue:\n            i = queue.pop(0)\n            for neighbor in get_neighbors(i):\n                if garland[neighbor] != garland[i]:\n                    garland = recolor(garland, neighbor, s[i])\n                    queue.append(neighbor)\n                    min_recolor += 1\n\n        return min_recolor\n\n    def min_recolor_bfs_final(garland):\n        queue = []\n        min_recolor = 0\n\n        for i in range(n):\n            if garland[i] != s[i]:\n                queue.append(i)\n                min_recolor += 1\n\n        while queue:\n            i = queue.pop(0)\n            for neighbor in get_neighbors(i):\n                if garland[neighbor] != garland[i]:\n                    garland = recolor(garland, neighbor, s[i])\n                    queue.append(neighbor)\n                    min_recolor += 1\n\n        return min_recolor\n\n    def min_recolor_bfs_final_"
    },
    {
        "number": 4396,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    total_value = 0\n\n    for i in range(1, N + 1):\n        x, u = input_data[i].split()\n        x = float(x)\n\n        if u == 'JPY':\n            total_value += x\n        elif u == 'BTC':\n            total_value += x * 380000.0\n\n    return total_value\n"
    },
    {
        "number": 4397,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, i = map(int, stdin.split())\n    j = N - i + 1\n    return str(j)\n"
    },
    {
        "number": 4398,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    S, T = stdin.split('\\n')[1].split(' ')\n\n    new_string = ''\n    for i in range(N):\n        new_string += S[i] + T[i]\n\n    return new_string\n"
    },
    {
        "number": 4399,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n\n    if S.count('A') > 0 and S.count('B') > 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4400,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    max_consecutive_rainy_days = 0\n    current_consecutive_rainy_days = 0\n\n    for day in S:\n        if day == 'R':\n            current_consecutive_rainy_days += 1\n        else:\n            max_consecutive_rainy_days = max(max_consecutive_rainy_days, current_consecutive_rainy_days)\n            current_consecutive_rainy_days = 0\n\n    max_consecutive_rainy_days = max(max_consecutive_rainy_days, current_consecutive_rainy_days)\n\n    return str(max_consecutive_rainy_days)\n"
    },
    {
        "number": 4401,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, Y, Z = map(int, stdin.split())\n\n    # Swap the contents of the boxes A and B\n    X, Y = Y, X\n\n    # Swap the contents of the boxes A and C\n    X, Z = Z, X\n\n    return f\"{X} {Y} {Z}\"\n"
    },
    {
        "number": 4402,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n\n    if A >= 13:\n        cost = B\n    elif A >= 6:\n        cost = B // 2\n    else:\n        cost = 0\n\n    return cost\n"
    },
    {
        "number": 4403,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin\n    integer = 0\n    for symbol in S:\n        if symbol == '+':\n            integer += 1\n        elif symbol == '-':\n            integer -= 1\n    return str(integer)\n"
    },
    {
        "number": 4404,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    date_str = stdin.strip()\n    year, month, day = map(int, date_str.split('/'))\n    if year == 2019 and month <= 4 and day <= 30:\n        return \"Heisei\"\n    else:\n        return \"TBD\"\n"
    },
    {
        "number": 4405,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if a[i - 1] == a[j - 1]:\n                continue\n            dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[n]\n"
    },
    {
        "number": 4406,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_friend_id(message_id):\n        for i, id_i in enumerate(message_ids):\n            if id_i == message_id:\n                return i + 1\n        return None\n\n    n, k = map(int, stdin.split()[:2])\n    message_ids = list(map(int, stdin.split()[2:]))\n\n    conversations = [None] * k\n    for message_id in message_ids:\n        friend_id = get_friend_id(message_id)\n        if friend_id is not None:\n            if conversations[-1] is not None and conversations[-1][0] == friend_id:\n                continue\n            if conversations[-1] is not None and conversations[-1][0] != friend_id:\n                conversations.pop()\n            conversations.append((friend_id, message_id))\n            conversations.sort(key=lambda x: x[0])\n            conversations = conversations[-k:]\n\n    output = [len(conversations)]\n    output.extend([x[0] for x in conversations])\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4407,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_set_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def min_coins(coins: list, target: int) -> int:\n        coins.sort(reverse=True)\n        count = 0\n        for coin in coins:\n            if target >= coin:\n                count += target // coin\n                target %= coin\n        return count\n\n    n, q = map(int, stdin.split()[:2])\n    coins = list(map(int, stdin.split()[2:2 + n]))\n    queries = list(map(int, stdin.split()[2 + n:]))\n\n    for b in queries:\n        if b == 0:\n            print(0)\n        else:\n            count = count_set_bits(b)\n            if count == 0:\n                print(-1)\n            else:\n                coins_subset = [coin for coin in coins if count_set_bits(coin) == count]\n                print(min_coins(coins_subset, b))\n"
    },
    {
        "number": 4408,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_cards_with_favorite_number(cards, favorite_numbers):\n        count = [0] * len(favorite_numbers)\n        for card in cards:\n            for i, favorite_number in enumerate(favorite_numbers):\n                if card == favorite_number:\n                    count[i] += 1\n        return count\n\n    def calculate_joy_levels(cards, favorite_numbers, h):\n        counts = count_cards_with_favorite_number(cards, favorite_numbers)\n        joy_levels = [h[t] if counts[i] == t else 0 for i, t in enumerate(range(1, k + 1))]\n        return joy_levels\n\n    n, k = map(int, stdin.split()[:2])\n    cards = list(map(int, stdin.split()[2:2 + k * n]))\n    favorite_numbers = list(map(int, stdin.split()[2 + k * n:2 + k * n + n]))\n    h = list(map(int, stdin.split()[2 + k * n + n:]))\n\n    max_joy_levels = 0\n    for permutation in itertools.permutations(cards):\n        joy_levels = calculate_joy_levels(permutation, favorite_numbers, h)\n        max_joy_levels = max(max_joy_levels, sum(joy_levels))\n\n    return str(max_joy_levels)\n"
    },
    {
        "number": 4409,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_min_operations(a):\n        n = len(a)\n        min_operations = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(a[i] - a[j]) <= 1:\n                    min_operations += 1\n                    break\n        return min_operations\n\n    def perform_operation(a, operation, i, j):\n        if operation == 1:\n            a[i] += abs(a[i] - a[j])\n        else:\n            a[i] -= abs(a[i] - a[j])\n        return a\n\n    def get_operations(a, min_operations):\n        n = len(a)\n        operations = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(a[i] - a[j]) <= 1:\n                    operations.append((1, i, j))\n                    break\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(a[i] - a[j]) <= 1:\n                    operations.append((2, i, j))\n                    break\n        return operations\n\n    def check_constraints(a):\n        for i in range(len(a)):\n            if a[i] > 10**18:\n                return False\n        return True\n\n    def main():\n        n = int(input())\n        a = list(map(int, input().split()))\n        min_operations = get_min_operations(a)\n        operations = get_operations(a, min_operations)\n        if check_constraints(a):\n            print(min_operations)\n            for operation in operations:\n                print(operation[0], operation[1], operation[2])\n        else:\n            print(\"-1\")\n\n    if __name__ == \"__main__\":\n        main()\n"
    },
    {
        "number": 4410,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_ones(s: str) -> int:\n        return s.count('1')\n\n    def can_occupy_table(s: str, i: int, k: int) -> bool:\n        for j in range(max(0, i - k), min(i + k + 1, len(s))):\n            if s[j] == '1':\n                return False\n        return True\n\n    def max_occupied_tables(s: str, k: int) -> int:\n        occupied_tables = count_ones(s)\n        free_tables = len(s) - occupied_tables\n        max_occupied = min(occupied_tables, free_tables)\n\n        for i in range(len(s)):\n            if can_occupy_table(s, i, k):\n                max_occupied += 1\n            else:\n                break\n\n        return max_occupied\n\n    def main(n: int, k: int, s: str) -> int:\n        return max_occupied_tables(s, k)\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n        print(main(n, k, s))\n"
    },
    {
        "number": 4411,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_bad(point: int, segments: List[Tuple[int, int]]) -> bool:\n        count = 0\n        for l, r in segments:\n            if l <= point <= r:\n                count += 1\n                if count > k:\n                    return True\n        return False\n\n    def remove_segments(segments: List[Tuple[int, int]]) -> List[int]:\n        bad_points = set()\n        for l, r in segments:\n            for point in range(l, r + 1):\n                if is_bad(point, segments):\n                    bad_points.add(point)\n        min_removed = len(bad_points)\n        for i in range(n):\n            if segments[i][0] in bad_points:\n                segments[i] = (segments[i][0] + 1, segments[i][1])\n            if segments[i][1] in bad_points:\n                segments[i] = (segments[i][0], segments[i][1] - 1)\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            min_removed = min(min_removed, len(set(range(segments[i][0], segments[i][1] + 1)) & bad_points))\n        return min_removed, sorted(list(bad_points))\n\n    n, k = map(int, stdin.split()[:2])\n    segments = [tuple(map(int, stdin.split()[i:i + 2])) for i in range(2, 2 * n + 1, 2)]\n    min_removed, indices = remove_segments(segments)\n    return f\"{min_removed}\\n{' '.join(map(str, indices))}\" "
    },
    {
        "number": 4412,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q, n = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort(reverse=True)\n    res = []\n    for i in range(q):\n        max_sum = 0\n        for j in range(n):\n            if a[j] % 2 == 0:\n                max_sum += a[j]\n            else:\n                break\n        res.append(max_sum)\n    return '\\n'.join(map(str, res))\n"
    },
    {
        "number": 4413,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = []\n    for i in range(1, q+1):\n        n = int(stdin.split('\\n')[i].split()[0])\n        a = list(map(int, stdin.split('\\n')[i].split()[1:]))\n        queries.append((n, a))\n\n    for n, a in queries:\n        min_teams = 1\n        for i in range(n):\n            for j in range(i+2, n):\n                if abs(a[i] - a[j]) > 1:\n                    min_teams += 1\n                    break\n        print(min_teams)\n"
    },
    {
        "number": 4414,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_possible(a, b, n, S):\n        if S % n == 0:\n            x = S // n\n            y = 0\n            return True\n        if S % (n + 1) == 0:\n            x = S // (n + 1)\n            y = 1\n            return True\n        return False\n\n    q = int(stdin.split('\\n')[0])\n    for i in range(1, q + 1):\n        a, b, n, S = map(int, stdin.split('\\n')[i].split())\n        if is_possible(a, b, n, S):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4415,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    inc_seq = []\n    dec_seq = []\n\n    for i in range(n):\n        if i == 0 or a[i] > a[i - 1]:\n            inc_seq.append(a[i])\n        else:\n            dec_seq.append(a[i])\n\n    if len(inc_seq) + len(dec_seq) != n:\n        return \"NO\"\n\n    return \"YES\\n{}\\n{}\\n{}\\n{}\".format(len(inc_seq), \" \".join(map(str, inc_seq)), len(dec_seq), \" \".join(map(str, dec_seq)))\n"
    },
    {
        "number": 4416,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_suitable_set(books: list) -> bool:\n        alice_books = [book for book in books if book[1] == 1]\n        bob_books = [book for book in books if book[2] == 1]\n        return len(alice_books) >= k and len(bob_books) >= k\n\n    n, k = map(int, stdin.split()[0:2])\n    books = []\n    for i in range(n):\n        t, a, b = map(int, stdin.split()[i + 1:i + 4])\n        books.append((t, a, b))\n\n    suitable_books = [book for book in books if is_suitable_set([book])]\n    if not suitable_books:\n        return str(-1)\n\n    suitable_books.sort(key=lambda x: x[0])\n    return str(sum(book[0] for book in suitable_books))\n"
    },
    {
        "number": 4417,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    output = []\n\n    for _ in range(q):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n\n        min_price = min(a)\n        max_price = max(a)\n\n        if min_price == max_price:\n            output.append(min_price)\n        else:\n            for i in range(min_price, max_price + 1):\n                if all(abs(i - j) <= k for j in a):\n                    output.append(i)\n                    break\n            else:\n                output.append(-1)\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4418,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    def is_good_array(arr):\n        if len(arr) % 6 != 0:\n            return False\n        subsequences = [[] for _ in range(6)]\n        for num in arr:\n            for i in range(6):\n                if num == [4, 8, 15, 16, 23, 42][i]:\n                    subsequences[i].append(num)\n                    break\n        for sub in subsequences:\n            if len(sub) != len(arr) // 6:\n                return False\n        return True\n\n    min_removals = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_good_array(a[i:j]):\n                min_removals = max(min_removals, j - i)\n\n    return str(n - min_removals)\n"
    },
    {
        "number": 4419,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def min_moves(a, b):\n        moves = 0\n        while a != b:\n            if a > b:\n                a -= 1\n            else:\n                a += 1\n            moves += 1\n        return moves\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for _ in range(t):\n        a, b = map(int, stdin.split('\\n')[1].split())\n        output.append(min_moves(a, b))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4420,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_k(x, y, n):\n        if y == 0:\n            return 0\n        if y == x:\n            return n\n        if y > x:\n            return None\n        for k in range(1, n+1):\n            if k % x == y:\n                return k\n        return None\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        x, y, n = map(int, stdin.split('\\n')[i].split())\n        k = find_k(x, y, n)\n        if k is not None:\n            output.append(str(k))\n        else:\n            output.append('-1')\n    return '\\n'.join(output)\n"
    },
    {
        "number": 4421,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    d = list(map(int, input_data[1].split()))\n\n    def is_valid(i, j):\n        return (d[i] + d[j]) % k == 0\n\n    def count_valid_pairs(boxes):\n        count = 0\n        for i in range(boxes):\n            for j in range(i + 1, boxes):\n                if is_valid(i, j):\n                    count += 1\n        return count\n\n    boxes = len(d)\n    max_count = 0\n    for i in range(1, k + 1):\n        max_count += count_valid_pairs(boxes // i)\n\n    return str(max_count)\n"
    },
    {
        "number": 4422,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n    S = input()\n    S = list(S)\n    S[K-1] = S[K-1].lower()\n    S = ''.join(S)\n    return S\n"
    },
    {
        "number": 4423,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    restaurants = []\n    for i in range(1, N+1):\n        city, score = input_data[i].split()\n        restaurants.append((city, int(score)))\n\n    restaurants.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (city, score) in enumerate(restaurants, 1):\n        print(i)\n"
    },
    {
        "number": 4424,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K, X = map(int, stdin.split())\n    coins = [500] * K\n    total = sum(coins)\n    if total >= X:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4425,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n\n    # Calculate the probability of Snuke winning\n    if K == 1:\n        probability = 0\n    elif K == N:\n        probability = 1\n    else:\n        probability = 0.5 * (1 - (1 - 1 / (N - 1)) ** (K - 1))\n\n    return str(probability)\n"
    },
    {
        "number": 4426,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    days = {\"SUN\": 0, \"MON\": 1, \"TUE\": 2, \"WED\": 3, \"THU\": 4, \"FRI\": 5, \"SAT\": 6}\n    today = days[stdin]\n    next_sunday = (today + 6) % 7\n    days_to_next_sunday = next_sunday - today\n    return days_to_next_sunday\n"
    },
    {
        "number": 4427,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    r, D, x_2000 = map(int, stdin.split())\n\n    for i in range(2000, 2010):\n        x_i = r * x_2000 - D\n        x_2000 = x_i\n\n    return \"\\n\".join(map(str, range(2000, 2011)))\n"
    },
    {
        "number": 4428,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    d = list(map(int, input_data[1].split()))\n\n    a, b, c = 0, 0, 0\n    max_sum = 0\n\n    for i in range(n):\n        if i < n // 3:\n            a += d[i]\n        elif i < 2 * n // 3:\n            b += d[i]\n        else:\n            c += d[i]\n\n    max_sum = max(a, b, c)\n\n    print(max_sum)\n"
    },
    {
        "number": 4429,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_triplet(x, y, z):\n        a, b, c = sorted([x, y, z])\n        if a > b + c:\n            return \"NO\"\n        else:\n            return \"YES\\n\" + str(a) + \" \" + str(b) + \" \" + str(c)\n\n    t = int(stdin.splitlines()[0])\n    output = []\n    for _ in range(t):\n        x, y, z = map(int, stdin.splitlines()[1].split())\n        output.append(find_triplet(x, y, z))\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4430,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    # Initialize the boxes with size k\n    boxes = [k] * m\n\n    # Initialize the number of objects packed\n    packed = 0\n\n    # Iterate through the objects\n    for i in range(n):\n        # Find the first box with remaining size greater than or equal to the i-th object\n        box_index = None\n        for j in range(m):\n            if boxes[j] >= a[i]:\n                box_index = j\n                break\n\n        # If there is no such box, break the loop\n        if box_index is None:\n            break\n\n        # Otherwise, pack the i-th object in the box and update the remaining size\n        boxes[box_index] -= a[i]\n        packed += 1\n\n    # If all objects are packed, return the number of objects\n    if packed == n:\n        return str(packed)\n    # Otherwise, return -1\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 4431,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    s = input_data[1]\n    available_letters = set(input_data[2].split())\n\n    substrings_count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if set(s[i - 1:j]).issubset(available_letters):\n                substrings_count += 1\n\n    return str(substrings_count)\n"
    },
    {
        "number": 4432,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_max_sum_alternating_subsequence(a):\n        n = len(a)\n        dp = [0] * n\n        dp[0] = a[0]\n        for i in range(1, n):\n            if a[i] >= 0:\n                dp[i] = max(dp[i - 1] + a[i], a[i])\n            else:\n                dp[i] = min(dp[i - 1] + a[i], a[i])\n        return dp[-1]\n\n    def find_max_alternating_subsequence_length(a):\n        n = len(a)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            if a[i] >= 0:\n                dp[i] = max(dp[i - 1] + 1, 1)\n            else:\n                dp[i] = max(dp[i - 1], 1)\n        return dp[-1]\n\n    def find_max_sum_alternating_subsequence_of_length(a, k):\n        n = len(a)\n        dp = [0] * n\n        dp[0] = a[0]\n        for i in range(1, n):\n            if a[i] >= 0:\n                dp[i] = max(dp[i - 1] + a[i], a[i])\n            else:\n                dp[i] = min(dp[i - 1] + a[i], a[i])\n        return dp[k - 1]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        k = find_max_alternating_subsequence_length(a)\n        print(find_max_sum_alternating_subsequence_of_length(a, k))\n"
    },
    {
        "number": 4433,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def prims_algorithm(graph):\n        visited = [False] * n\n        visited[0] = True\n        mst = []\n        edges = []\n        for i in range(1, n):\n            min_edge = float('inf')\n            min_vertex = -1\n            for j in range(n):\n                if visited[j]:\n                    continue\n                if graph[i][j] < min_edge:\n                    min_edge = graph[i][j]\n                    min_vertex = j\n            visited[min_vertex] = True\n            edges.append((i, min_vertex))\n            mst.append(min_edge)\n        return edges, mst\n\n    def max_degree_spanning_tree(edges):\n        graph = defaultdict(lambda: defaultdict(int))\n        for u, v in edges:\n            graph[u][v] = graph[v][u] = 1\n        return prims_algorithm(graph)\n\n    def main():\n        n, m = map(int, input().split())\n        edges = [tuple(map(int, input().split())) for _ in range(m)]\n        edges, mst = max_degree_spanning_tree(edges)\n        for u, v in edges:\n            print(u, v)\n\n    if __name__ == \"__main__\":\n        main()\n"
    },
    {
        "number": 4434,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_min_moves(n: int) -> int:\n        if n == 1:\n            return 0\n        if n == 3:\n            return 1\n        return 2 * get_min_moves(n - 2) + 1\n\n    t = int(stdin)\n    result = []\n    for _ in range(t):\n        n = int(input())\n        result.append(get_min_moves(n))\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4435,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    d = [-1] * n\n\n    for i in range(n):\n        if a[i] == 0:\n            d[i] = 0\n        else:\n            for j in range(n):\n                if j % a[i] == 0:\n                    d[i] = j // a[i]\n                    break\n\n    result = '\\n'.join(map(str, d))\n    return result\n"
    },
    {
        "number": 4436,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_abc(n: int) -> str:\n        for a in range(2, n):\n            for b in range(2, n):\n                for c in range(2, n):\n                    if a * b * c == n:\n                        return f\"YES {a} {b} {c}\"\n        return \"NO\"\n\n    t = int(stdin.split(\"\\n\")[0])\n    output = []\n    for i in range(1, t + 1):\n        n = int(stdin.split(\"\\n\")[i])\n        output.append(find_abc(n))\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4437,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    operations = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == 'a':\n                operations += 1\n                s = s[:i] + 'b' + s[i+1:]\n            elif s[i] == 'b':\n                operations += 1\n                s = s[:i] + 'a' + s[i+1:]\n\n    result = str(operations) + '\\n' + s\n    return result\n"
    },
    {
        "number": 4438,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def visit_points(points, visited, level, total_distance):\n        if level == len(points):\n            return total_distance\n\n        for i, point in enumerate(points):\n            if i not in visited:\n                visited.add(i)\n                total_distance += distance(point, (0, 0))\n                total_distance = visit_points(points, visited, level + 1, total_distance)\n                visited.remove(i)\n                total_distance -= distance(point, (0, 0))\n\n        return total_distance\n\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    points.sort(key=lambda p: max(abs(p[0]), abs(p[1])))\n    visited = set()\n    total_distance = 0\n\n    return visit_points(points, visited, 0, total_distance)\n"
    },
    {
        "number": 4439,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    choices = [1, 2, 3]\n    choices.remove(A)\n    choices.remove(B)\n    correct_choice = choices[0]\n    return str(correct_choice)\n"
    },
    {
        "number": 4440,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    L = int(stdin.strip())\n\n    # Initialize the maximum volume\n    max_volume = 0\n\n    # Iterate through all possible combinations of dimensions\n    for length in range(1, L + 1):\n        for width in range(1, L + 1):\n            for height in range(1, L + 1):\n                # Check if the sum of dimensions is equal to L\n                if length + width + height == L:\n                    # Calculate the volume of the cuboid\n                    volume = length * width * height\n                    # Update the maximum volume if the current volume is greater\n                    max_volume = max(max_volume, volume)\n\n    return str(max_volume) "
    },
    {
        "number": 4441,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = None, None, None\n\n    # Read input\n    lines = stdin.split('\\n')\n    if len(lines) == 1:\n        N = int(lines[0])\n    else:\n        N = int(lines[0])\n        A = int(lines[1])\n        B = int(lines[2])\n\n    # Write output\n    if N == 1:\n        return \"Hello World\"\n    elif N == 2:\n        return str(A + B)\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4442,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    string_a = str(a) * b\n    string_b = str(b) * a\n\n    if string_a < string_b:\n        return string_a\n    elif string_b < string_a:\n        return string_b\n    else:\n        return string_a\n"
    },
    {
        "number": 4443,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    c = stdin.strip()\n    if c == 'z':\n        raise ValueError(\"C cannot be z\")\n    if c < 'a' or c > 'z':\n        raise ValueError(\"C must be a lowercase English letter\")\n    return chr(ord(c) + 1)\n"
    },
    {
        "number": 4444,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split()\n    return T + S\n"
    },
    {
        "number": 4445,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    parity = 0  # 0 for even, 1 for odd\n    sum_non_deleted = sum(a)\n\n    for i in range(n):\n        if i == 0:\n            parity = 1 - (a[0] % 2)\n        else:\n            if parity == 0:\n                parity = 1 - (a[i] % 2)\n            else:\n                parity = (a[i] % 2)\n\n            if parity == 0:\n                sum_non_deleted -= a[i]\n            else:\n                sum_non_deleted += a[i]\n\n    return sum_non_deleted\n"
    },
    {
        "number": 4446,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, a, b, k = map(int, input_data[0].split())\n    hp = list(map(int, input_data[1].split()))\n\n    max_points = 0\n    current_points = 0\n    current_k = k\n    for i in range(n):\n        if hp[i] <= 0:\n            continue\n        if current_k > 0:\n            current_points += 1\n            current_k -= 1\n        else:\n            current_points += 1\n            current_k = k\n        max_points = max(max_points, current_points)\n        hp[i] -= a\n        if hp[i] <= 0:\n            current_points += 1\n            current_k = k\n        hp[i] -= b\n        if hp[i] <= 0:\n            current_points += 1\n            current_k = k\n\n    return str(max_points)\n"
    },
    {
        "number": 4447,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    def count_remainders(a, m):\n        remainders = [0] * m\n        for num in a:\n            remainders[num % m] += 1\n        return remainders\n\n    def min_moves(remainders, n, m):\n        min_moves = 0\n        for i in range(m):\n            if remainders[i] != n // m:\n                min_moves += abs(remainders[i] - n // m)\n        return min_moves\n\n    remainders = count_remainders(a, m)\n    min_moves_count = min_moves(remainders, n, m)\n\n    if min_moves_count == 0:\n        result = a\n    else:\n        result = [0] * n\n        for i in range(n):\n            result[i] = a[i] + min_moves_count\n\n    output = f\"{min_moves_count}\\n{' '.join(map(str, result))}\"\n    return output\n"
    },
    {
        "number": 4448,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_min_day(k, d, t):\n        min_day = float('inf')\n        for i in range(len(d)):\n            if d[i] > k:\n                min_day = min(min_day, d[i])\n            else:\n                min_day = min(min_day, d[i] + t[i])\n        return min_day\n\n    n, m = map(int, stdin.split()[:2])\n    k = list(map(int, stdin.split()[2:2 + n]))\n    d = []\n    t = []\n    for _ in range(m):\n        d_j, t_j = map(int, stdin.split()[2 + n + len(d):2 + n + len(d) + 2])\n        d.append(d_j)\n        t.append(t_j)\n\n    min_day = float('inf')\n    for i in range(n):\n        min_day = min(min_day, get_min_day(k[i], d, t))\n\n    return min_day\n"
    },
    {
        "number": 4449,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    for i, query in enumerate(queries):\n        n = int(query.split('\\n')[0])\n        a = list(map(int, query.split('\\n')[1].split()))\n\n        if len(a) % 4 != 0 or len(a) < 4 * n:\n            print(\"NO\")\n            continue\n\n        a.sort()\n        a = [a[i:i+4] for i in range(0, len(a), 4)]\n\n        for i in range(n):\n            if a[i][0] != a[i][2] or a[i][1] != a[i][3]:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n\n    return \" \".join([\"YES\"] * q)\n"
    },
    {
        "number": 4450,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            if min_node == -1:\n                break\n            visited[min_node] = True\n            for i in range(n):\n                if not visited[i] and graph[min_node][i] < float('inf'):\n                    new_dist = dist[min_node] + graph[min_node][i]\n                    if new_dist < dist[i]:\n                        dist[i] = new_dist\n        return dist[end]\n\n    def shortest_paths(graph, n):\n        d = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            d[i][i] = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                d[i][j] = d[j][i] = graph[i][j]\n        for k in range(2, n):\n            for i in range(n - k):\n                for j in range(i + 1, n - k + 1):\n                    for m in range(i + 1, j):\n                        new_dist = d[i][m] + d[m][j]\n                        if new_dist < d[i][j]:\n                            d[i][j] = new_dist\n        return d\n\n    def kth_smallest_shortest_path(d, k):\n        sorted_d = sorted([d[i][j] for i in range(n) for j in range(i + 1, n) if d[i][j] != float('inf')])\n        return sorted_d[k - 1]\n\n    n, m, k = map(int, stdin.split())\n    graph = [[float('inf')] * n for _ in range(n)]\n    for _ in range(m):\n        x, y, w = map(int, stdin.split())\n        graph[x - 1][y - 1] = w\n        graph[y - 1][x - 1] = w\n    d = shortest_paths(graph, n)\n    return kth_smallest_shortest_path(d, k)\n"
    },
    {
        "number": 4451,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def diversity(team: list) -> int:\n        return max(team) - min(team)\n\n    def find_teams(students: list) -> list:\n        teams = []\n        while students:\n            team = [students.pop()]\n            while len(team) < 3:\n                team.append(students.pop())\n            teams.append(team)\n        return teams\n\n    n, *a = map(int, stdin.split())\n    students = list(enumerate(a))\n    students.sort(key=lambda x: x[1])\n\n    teams = find_teams(students)\n    total_diversity = sum(diversity(team) for team in teams)\n\n    res = total_diversity\n    k = len(teams)\n\n    team_assignment = [0] * n\n    for i, team in enumerate(teams):\n        for student in team:\n            team_assignment[student[0]] = i + 1\n\n    return f\"{res} {k}\\n{' '.join(map(str, team_assignment))}\"\n"
    },
    {
        "number": 4452,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_round(num: int) -> bool:\n        return all(digit == '0' for digit in str(num)[1:])\n\n    def find_min_summands(n: int) -> str:\n        if n == 1:\n            return '1 1'\n\n        summands = []\n        current_sum = 0\n        i = 1\n\n        while current_sum < n:\n            if is_round(i):\n                current_sum += i\n                summands.append(str(i))\n            i += 1\n\n        return f'{len(summands)} {\" \".join(summands)}'\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        print(find_min_summands(n))\n"
    },
    {
        "number": 4453,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, q+1):\n        n = int(stdin.split('\\n')[i*2])\n        p = list(map(int, stdin.split('\\n')[i*2+1].split()))\n        days = [0]*n\n        for j in range(n):\n            days[p[j]-1] = max(days[p[j]-1], j+1)\n        output.append(days)\n    return '\\n'.join([' '.join(map(str, day)) for day in output])\n"
    },
    {
        "number": 4454,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    output = []\n    for _ in range(q):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        min_price = a[0]\n        for i in range(1, n):\n            if a[i] > min_price:\n                min_price = a[i]\n            else:\n                min_price = min_price + 1\n        output.append(min_price)\n        stdin = stdin[2*n+2:]\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4455,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_mentor(a, b):\n        return r[a] > r[b] and not quarrels[a] and not quarrels[b]\n\n    n, k = map(int, stdin.split()[:2])\n    r = list(map(int, stdin.split()[2:]))\n    quarrels = [False] * n\n\n    for _ in range(k):\n        x, y = map(int, stdin.split()[k * 2:k * 2 + 2])\n        quarrels[x - 1] = True\n        quarrels[y - 1] = True\n\n    mentors = [sum(is_mentor(i, j) for j in range(n)) for i in range(n)]\n\n    return ' '.join(map(str, mentors))\n"
    },
    {
        "number": 4456,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_string(s: str, k: int) -> bool:\n        return len(set(s)) >= k\n\n    def restore_string(p: List[int], q: List[int], n: int) -> str:\n        s = [chr(i + ord('a')) for i in range(n)]\n        p_sorted = sorted(s, key=lambda x: p[ord(x) - ord('a')])\n        q_sorted = sorted(s, key=lambda x: q[ord(x) - ord('a')])\n        return ''.join(p_sorted) if p_sorted == q_sorted else ''.join(q_sorted)\n\n    n, k = map(int, stdin.split()[:2])\n    p = list(map(int, stdin.split()[2:2 * n:2]))\n    q = list(map(int, stdin.split()[3:2 * n:2]))\n\n    s = restore_string(p, q, n)\n    if is_valid_string(s, k):\n        return \"YES\\n\" + s\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4457,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_min_shots(a, x):\n        return sum(a) * x + 1\n\n    def get_min_shots_with_order(a, x, order):\n        return sum([a[i - 1] * x for i in order]) + len(order)\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    min_shots = float('inf')\n    min_order = []\n\n    for order in itertools.permutations(range(1, n + 1)):\n        shots = get_min_shots_with_order(a, 1, order)\n        if shots < min_shots:\n            min_shots = shots\n            min_order = order\n\n    for i in range(2, n + 1):\n        shots = get_min_shots(a, i)\n        if shots < min_shots:\n            min_shots = shots\n            min_order = list(range(1, n + 1))\n\n    output = f\"{min_shots}\\n{' '.join(map(str, min_order))}\"\n    return output\n"
    },
    {
        "number": 4458,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, P = map(int, stdin.split())\n    P = sorted(P)\n    count = 0\n    for i in range(1, N+1):\n        if all(P[j-1] <= P[i-1] for j in range(1, i+1)):\n            count += 1\n    return count\n"
    },
    {
        "number": 4459,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    # Calculate the frequency of each element in the sequence\n    freq = [0] * (max(a) + 1)\n    for num in a:\n        freq[num] += 1\n\n    # Count the number of elements that need to be removed\n    count = 0\n    for num, f in enumerate(freq):\n        if f > num:\n            count += f - num\n\n    return count\n"
    },
    {
        "number": 4460,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x_values = list(map(int, stdin.split()))\n    for i, x in enumerate(x_values, start=1):\n        if x == 0:\n            return str(i)\n    return \"No variable was assigned 0.\"\n"
    },
    {
        "number": 4461,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W = map(int, stdin.split())\n\n    # Calculate the maximum possible area of the largest piece\n    max_area = H * W\n\n    # Calculate the minimum possible area of the smallest piece\n    min_area = 0\n    if H % 2 == 0:\n        min_area = H // 2 * W\n    if W % 2 == 0:\n        min_area = min(min_area, H * W // 2)\n\n    # Calculate the minimum possible value of S_{max} - S_{min}\n    min_diff = max_area - min_area\n\n    return str(min_diff)\n"
    },
    {
        "number": 4462,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *a = map(int, stdin.split())\n\n    for i in range(N - 1):\n        if a[i] * a[i + 1] % 4 != 0:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 4463,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, t = stdin.split('\\n')\n    s_prime = ''.join(sorted(s))\n    t_prime = ''.join(sorted(t))\n\n    if s_prime < t_prime:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4464,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    if A > 100 or B > 100 or 0 <= C < B:\n        return \"NO\"\n\n    input_integers = list(map(int, input().split()))\n    if len(input_integers) == 0:\n        return \"NO\"\n\n    total_sum = sum(input_integers)\n    if total_sum % B == C:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4465,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    area = (A - 2) * (B - 2)\n    return area\n"
    },
    {
        "number": 4466,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, Y, Z = map(int, stdin.split())\n\n    if Y + 2 * Z > X:\n        return \"Not enough space\"\n\n    # Calculate the maximum number of people who can sit on the seat\n    max_people = (X - Y - Z) // (Y + Z)\n\n    return max_people\n"
    },
    {
        "number": 4467,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_friendly(a, b, c, d):\n        return a < c and b < d\n\n    def is_valid(a, b, c, d):\n        return a != c and b != d\n\n    def count_pairs(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if is_friendly(*points[i], *points[j]) and is_valid(*points[i], *points[j]):\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:]]\n    points = list(zip(*[iter(points)] * 2))\n\n    red_points = points[0]\n    blue_points = points[1]\n\n    red_pairs = count_pairs(red_points)\n    blue_pairs = count_pairs(blue_points)\n\n    return max(red_pairs, blue_pairs)\n"
    },
    {
        "number": 4468,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, T = map(int, stdin.split()[:2])\n    t_list = list(map(int, stdin.split()[2:]))\n\n    total_time = 0\n    for i in range(N):\n        if i == 0:\n            total_time += T\n        else:\n            total_time += t_list[i] - t_list[i - 1]\n\n    return total_time\n"
    },
    {
        "number": 4469,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def pop_left(books: list, id: int) -> int:\n        count = 0\n        while books and books[0] < id:\n            books.pop(0)\n            count += 1\n        return count\n\n    def pop_right(books: list, id: int) -> int:\n        count = 0\n        while books and books[-1] > id:\n            books.pop()\n            count += 1\n        return count\n\n    q = int(stdin.splitlines()[0])\n    books = []\n    for line in stdin.splitlines()[1:]:\n        query_type, id = line.split()\n        id = int(id)\n        if query_type == \"L\":\n            books.insert(0, id)\n        elif query_type == \"R\":\n            books.append(id)\n        elif query_type == \"?\":\n            left_count = pop_left(books, id)\n            right_count = pop_right(books, id)\n            if left_count < right_count:\n                print(left_count)\n            else:\n                print(right_count)\n"
    },
    {
        "number": 4470,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    def min_moves(n):\n        moves = 0\n        while n > 1:\n            if n % 5 == 0:\n                n //= 5\n                moves += 1\n            elif n % 3 == 0:\n                n //= 3\n                moves += 1\n            elif n % 2 == 0:\n                n //= 2\n                moves += 1\n            else:\n                break\n        return moves\n\n    for query in queries:\n        n = int(query)\n        if n == 1:\n            print(0)\n        else:\n            result = min_moves(n)\n            if result == float('inf'):\n                print(-1)\n            else:\n                print(result)\n"
    },
    {
        "number": 4471,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def can_clear_field(a):\n        while any(a):\n            a = [max(0, a[i] - 1) for i in range(len(a))]\n            for i in range(len(a)):\n                if a[i] == 0:\n                    continue\n                for j in range(i + 1, len(a)):\n                    if a[j] == 0:\n                        continue\n                    if a[i] + a[j] <= 2:\n                        a[i] += a[j]\n                        a[j] = 0\n                        break\n        return all(a)\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if can_clear_field(a):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4472,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(a, b, i):\n        a[i - 1], b[i - 1] = b[i - 1], a[i - 1]\n\n    def swap_with_reverse(a, b, i):\n        swap(a, b, i)\n        swap(a, b, n + 1 - i)\n\n    def preprocess_move(a, c, i):\n        a[i - 1] = c\n\n    n = int(stdin.split('\\n')[0])\n    a = list(stdin.split('\\n')[1])\n    b = list(stdin.split('\\n')[2])\n\n    if n % 2 == 1:\n        swap(a, b, n // 2 + 1)\n\n    min_moves = 0\n    for i in range(1, n + 1):\n        if a[i - 1] != b[i - 1]:\n            min_moves += 1\n            swap(a, b, i)\n\n    return str(min_moves) "
    },
    {
        "number": 4473,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t+1):\n        a, b, k = map(int, stdin.split('\\n')[i].split())\n        x = 0\n        for j in range(k):\n            if j % 2 == 0:\n                x += a\n            else:\n                x -= b\n        result.append(x)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4474,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    def is_good(n: int) -> bool:\n        n_str = str(n)\n        for digit in n_str:\n            if n_str.count(digit) > 1:\n                return False\n        return True\n\n    def find_smallest_good(n: int) -> int:\n        m = n\n        while not is_good(m):\n            m += 1\n        return m\n\n    for query in queries:\n        n = int(query)\n        result = find_smallest_good(n)\n        print(result)\n"
    },
    {
        "number": 4475,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def min_product(a, b, x, y, n):\n        while n > 0 and (a < x or b < y):\n            if a < b:\n                a += 1\n            else:\n                b += 1\n            n -= 1\n        return a * b\n\n    t = int(stdin.splitlines()[0])\n    output = []\n    for _ in range(t):\n        a, b, x, y, n = map(int, stdin.splitlines()[1].split())\n        output.append(min_product(a, b, x, y, n))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4476,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_odd(n: int) -> bool:\n        return n % 2 == 1\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    def perform_move(a: int, x: int, y: int) -> int:\n        if is_odd(x):\n            return a + x\n        elif is_even(x):\n            return a - y\n        else:\n            raise ValueError(\"Invalid x value\")\n\n    def min_moves(a: int, b: int) -> int:\n        moves = 0\n        while a != b:\n            if is_odd(a):\n                a = perform_move(a, 1, 0)\n            elif is_even(a):\n                a = perform_move(a, 0, 1)\n            else:\n                raise ValueError(\"Invalid a value\")\n            moves += 1\n        return moves\n\n    t = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, t + 1):\n        a, b = map(int, stdin.splitlines()[i].split())\n        output.append(min_moves(a, b))\n\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 4477,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    def count_digits(n: int) -> int:\n        return len(str(n))\n\n    def count_keypresses(x: int) -> int:\n        digits = set(str(x))\n        keypresses = 0\n        for digit in digits:\n            for i in range(1, 10001):\n                if str(i).startswith(digit):\n                    keypresses += count_digits(i)\n        return keypresses\n\n    for i in range(t):\n        x = int(stdin.split('\\n')[i+1])\n        print(count_keypresses(x))\n"
    },
    {
        "number": 4478,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def read_input() -> tuple:\n        k = int(input())\n        sequences = []\n        for _ in range(k):\n            n = int(input())\n            sequence = list(map(int, input().split()))\n            sequences.append((n, sequence))\n        return k, sequences\n\n    def find_pair(k: int, sequences: list) -> str:\n        for i in range(k):\n            for j in range(i + 1, k):\n                if sequences[i][0] == sequences[j][0] and sequences[i][1] != sequences[j][1]:\n                    return i, sequences[i][1], j, sequences[j][1]\n        return None\n\n    def main():\n        k, sequences = read_input()\n        pair = find_pair(k, sequences)\n        if pair is None:\n            return \"NO\"\n        else:\n            return \"YES\\n{}\\n{}\\n{}\".format(pair[0], pair[1], pair[2])\n\n    return main()\n"
    },
    {
        "number": 4479,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, K = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    max_sum = float('-inf')\n    for i in range(len(A)):\n        modified_A = [-A[j] if j == i else A[j] for j in range(len(A))]\n        max_sum = max(max_sum, sum(modified_A))\n    return max_sum\n"
    },
    {
        "number": 4480,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def can_partition(A):\n        total_sum = sum(A)\n        if total_sum % 3 != 0:\n            return False\n        target_sum = total_sum // 3\n        dp = [False] * (total_sum + 1)\n        dp[0] = True\n        for a in A:\n            for i in range(total_sum, a - 1, -1):\n                if dp[i - a]:\n                    dp[i] = True\n        return dp[total_sum]\n\n    def main():\n        n = int(input())\n        A = list(map(int, input().split()))\n        if can_partition(A):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    if __name__ == \"__main__\":\n        main() "
    },
    {
        "number": 4481,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, stdin = stdin.split(\"\\n\", 1)\n    N = int(N)\n    votes = {}\n    for i in range(N):\n        S_i, stdin = stdin.split(\"\\n\", 1)\n        if S_i not in votes:\n            votes[S_i] = 1\n        else:\n            votes[S_i] += 1\n    max_votes = max(votes.values())\n    result = []\n    for S_i, count in votes.items():\n        if count == max_votes:\n            result.append(S_i)\n    result.sort()\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4482,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Initialize the minimum cost to transform each integer\n    min_cost = [abs(a[i] - a[j]) ** 2 for i in range(N) for j in range(N) if i != j]\n\n    # Find the minimum cost to transform all integers\n    min_total_cost = sum(min(min_cost[i:i + N]))\n\n    return min_total_cost\n"
    },
    {
        "number": 4483,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split(\"\\n\")\n    X = int(input_list[0])\n    A = int(input_list[1])\n    B = int(input_list[2])\n\n    total_cost = A + B * X\n    if total_cost > X:\n        print(0)\n    else:\n        print(X - total_cost)\n"
    },
    {
        "number": 4484,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    dp = [0] * (N + M + 2)\n    dp[0] = 1\n    for i in range(1, N + M + 2):\n        if i <= N:\n            dp[i] = dp[i - 1]\n        if i > N and i <= N + M:\n            dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n    return dp[N + M + 1]\n"
    },
    {
        "number": 4485,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    a_b = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2*(M+1), 2)]\n    a_b = set(a_b)\n    for i in range(1, N):\n        if (1, i) in a_b and (i, N) in a_b:\n            return \"POSSIBLE\"\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 4486,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    result = \"\"\n    for i in range(1, len(s), 2):\n        result += s[i]\n    return result\n"
    },
    {
        "number": 4487,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = stdin.split()\n    if A[-1] == B[0] and B[-1] == C[0]:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4488,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n\n    if A > B:\n        return \"GREATER\"\n    elif A < B:\n        return \"LESS\"\n    else:\n        return \"EQUAL\"\n"
    },
    {
        "number": 4489,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    M = int(input_data[N+1])\n    blue_cards = input_data[1:N+1]\n    red_cards = input_data[N+2:N+M+2]\n\n    balance = 0\n    for card in blue_cards:\n        if card in red_cards:\n            balance -= 1\n        else:\n            balance += 1\n\n    return str(balance)"
    },
    {
        "number": 4490,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    b = stdin.strip()\n    if b == 'A':\n        return 'T'\n    elif b == 'C':\n        return 'G'\n    elif b == 'G':\n        return 'C'\n    elif b == 'T':\n        return 'A'\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4491,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    A = [[int(x) for x in line.split()] for line in stdin.split('\\n')[1:]]\n\n    # Initialize the maximum number of candies collected\n    max_candies = 0\n\n    # Traverse the grid and collect the candies\n    for i in range(1, 3):\n        for j in range(1, N + 1):\n            max_candies += A[i - 1][j - 1]\n\n    # Print the maximum number of candies collected\n    return str(max_candies)\n"
    },
    {
        "number": 4492,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, x = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Initialize the minimum number of operations\n    min_ops = 0\n\n    # Iterate through the boxes\n    for i in range(N - 1):\n        # If the sum of the current and next box is greater than x, perform an operation\n        if a[i] + a[i + 1] > x:\n            min_ops += 1\n\n    # If the last two boxes have a sum greater than x, perform an operation\n    if a[-1] + a[-2] > x:\n        min_ops += 1\n\n    return min_ops\n"
    },
    {
        "number": 4493,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    c = [[int(x) for x in input().split()] for _ in range(3)]\n\n    a1, a2, a3, b1, b2, b3 = 1, 2, 3, 4, 5, 6\n\n    for i in range(3):\n        for j in range(3):\n            if c[i][j] != a1 + b1 or c[i][j] != a2 + b2 or c[i][j] != a3 + b3:\n                return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 4494,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    last_week_contest = stdin.strip()\n    if last_week_contest == \"ABC\":\n        this_week_contest = \"ARC\"\n    else:\n        this_week_contest = \"ABC\"\n    return this_week_contest\n"
    },
    {
        "number": 4495,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, x = map(int, stdin.split())\n    count = 0\n    for i in range(a, b+1):\n        if i % x == 0:\n            count += 1\n    return count"
    },
    {
        "number": 4496,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    D = int(stdin.strip())\n    if D == 25:\n        return \"Christmas\"\n    elif D == 24:\n        return \"Christmas Eve\"\n    elif D == 23:\n        return \"Christmas Eve Eve\"\n    elif D == 22:\n        return \"Christmas Eve Eve Eve\"\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4497,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    max_count = 0\n    max_num = 0\n    for i in range(1, N+1):\n        count = 0\n        while i % 2 == 0:\n            count += 1\n            i //= 2\n        if count > max_count:\n            max_count = count\n            max_num = i\n    return str(max_num)"
    },
    {
        "number": 4498,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c, d = map(int, stdin.split())\n\n    if a == b or b == c or a == c:\n        return \"Yes\"\n\n    distance_ab = abs(a - b)\n    distance_bc = abs(b - c)\n\n    if distance_ab <= d and distance_bc <= d:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4499,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    words = stdin.split()\n    acronym = \"\"\n    for word in words:\n        acronym += word[0].upper()\n    return acronym\n"
    },
    {
        "number": 4500,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n\n    if A * 100 + B >= C:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4501,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N, A = map(int, input_data[0].split())\n    x_i = list(map(int, input_data[1].split()))\n\n    total_sum = sum(x_i)\n    total_cards = len(x_i)\n    average = total_sum / total_cards\n\n    if A == total_sum:\n        return 1\n    elif A < total_sum:\n        return 0\n    else:\n        count = 0\n        for i in range(total_cards):\n            for j in range(i + 1, total_cards + 1):\n                if sum(x_i[i:j]) == A:\n                    count += 1\n        return count\n"
    },
    {
        "number": 4502,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *a = map(int, stdin.split())\n    b = []\n    for i in range(n):\n        b.append(a[i])\n        b.reverse()\n    return \" \".join(map(str, b))\n"
    },
    {
        "number": 4503,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, N = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    if H == 0:\n        return \"Yes\"\n\n    if N > H:\n        return \"Yes\"\n\n    used_moves = set()\n    for i in range(N):\n        if H - A[i] in used_moves:\n            return \"No\"\n        used_moves.add(H)\n        H -= A[i]\n        if H <= 0:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4504,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin\n    n = len(S)\n    max_len = 0\n\n    for i in range(n // 2):\n        for j in range(i + 1, n // 2 + 1):\n            if S[i:j] == S[j:n // 2 + j]:\n                max_len = max(max_len, j - i)\n\n    return max_len\n"
    },
    {
        "number": 4505,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    if S == \"abc\" or S == \"acb\" or S == \"bac\" or S == \"bca\" or S == \"cab\" or S == \"cba\":\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4506,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def f(l, r):\n        return sum(a[i] * b[i] for i in range(l, r+1))\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    min_sum = float('inf')\n    for p in permutations(b):\n        b_perm = list(p)\n        cur_sum = sum(f(l, r) for l in range(1, n+1) for r in range(l, n+1))\n        min_sum = min(min_sum, cur_sum)\n\n    return str(min_sum % 998244353)\n"
    },
    {
        "number": 4507,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_cost(shovels, offers, k):\n        n = len(shovels)\n        m = len(offers)\n        dp = [float('inf')] * (k + 1)\n        dp[0] = 0\n\n        for i in range(1, k + 1):\n            for j in range(n):\n                if i - shovels[j] >= 0:\n                    dp[i] = min(dp[i], dp[i - shovels[j]] + shovels[j])\n\n        for offer in offers:\n            x, y = offer\n            for i in range(k - x, -1, -1):\n                for j in range(n):\n                    if i + shovels[j] <= k:\n                        dp[i + shovels[j]] = min(dp[i + shovels[j]], dp[i] + shovels[j])\n\n        return dp[k]\n\n    def main():\n        n, m, k = map(int, input().split())\n        shovels = list(map(int, input().split()))\n        offers = []\n        for _ in range(m):\n            x, y = map(int, input().split())\n            offers.append((x, y))\n\n        return find_min_cost(shovels, offers, k)\n\n    return str(main())\n"
    },
    {
        "number": 4508,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def dijkstra(graph, start):\n        dist = defaultdict(lambda: float('inf'))\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            d, node = heappop(heap)\n            if d > dist[node]:\n                continue\n            for neighbor, weight in graph[node].items():\n                new_dist = d + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heappush(heap, (new_dist, neighbor))\n        return dist\n\n    n = int(stdin.splitlines()[0])\n    graph = defaultdict(dict)\n    for i in range(1, n):\n        u, v = map(int, stdin.splitlines()[i].split())\n        graph[u][v] = 1\n        graph[v][u] = 1\n\n    dist = dijkstra(graph, 1)\n    min_edges = 0\n    for i in range(2, n + 1):\n        if dist[i] > 2:\n            min_edges += 1\n\n    return str(min_edges)\n"
    },
    {
        "number": 4509,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split()[0])\n    for i in range(1, t+1):\n        n, k = map(int, stdin.split()[i].split())\n        count = 0\n        num = 1\n        while count < k:\n            if num % n != 0:\n                count += 1\n            num += 1\n        print(num-1)\n"
    },
    {
        "number": 4510,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_friend_id(message_id):\n        for i, id_i in enumerate(friend_ids):\n            if id_i == message_id:\n                return i + 1\n        return None\n\n    n, k = map(int, stdin.split()[:2])\n    friend_ids = list(map(int, stdin.split()[2:]))\n\n    conversations = [None] * k\n    for message_id in friend_ids:\n        friend_index = get_friend_id(message_id)\n        if friend_index is not None:\n            if conversations[0] is None:\n                conversations[0] = friend_index\n            else:\n                for i in range(k - 1):\n                    conversations[i] = conversations[i + 1]\n                conversations[k - 1] = friend_index\n\n    m = min(n, k)\n    result = [conversations[i] for i in range(m)]\n    output = f\"{m}\\n\" + \" \".join(map(str, result))\n    return output\n"
    },
    {
        "number": 4511,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_cards(cards_data: str) -> List[Tuple[int, int]]:\n        cards = []\n        for line in cards_data.split('\\n'):\n            c, d = map(int, line.split())\n            cards.append((c, d))\n        return cards\n\n    def play_cards(cards: List[Tuple[int, int]], cost_limit: int) -> int:\n        total_cost = 0\n        damage = 0\n        artifact_used = False\n        for c, d in cards:\n            if total_cost + c <= cost_limit:\n                total_cost += c\n                damage += d\n                if not artifact_used and total_cost % 10 == 0:\n                    damage *= 2\n                    artifact_used = True\n        return damage\n\n    n = int(stdin.split('\\n', 1)[0])\n    stdin = stdin.split('\\n', 1)[1]\n    max_damage = 0\n    for i in range(n):\n        k = int(stdin.split('\\n', 1)[0])\n        stdin = stdin.split('\\n', 1)[1]\n        cards = get_cards(stdin[:k * 2])\n        stdin = stdin[k * 2:]\n        max_damage = max(max_damage, play_cards(cards, 3))\n\n    return str(max_damage)\n"
    },
    {
        "number": 4512,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = input()\n    q = int(input())\n    s_dict = {}\n\n    for char in s:\n        if char in s_dict:\n            s_dict[char] += 1\n        else:\n            s_dict[char] = 1\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            pos = int(query[1])\n            c = query[2]\n            s = list(s)\n            s[pos - 1] = c\n            s = ''.join(s)\n            s_dict = {}\n            for char in s:\n                if char in s_dict:\n                    s_dict[char] += 1\n                else:\n                    s_dict[char] = 1\n        else:\n            l = int(query[1])\n            r = int(query[2])\n            sub_s = s[l - 1:r]\n            sub_s_dict = {}\n            for char in sub_s:\n                if char in sub_s_dict:\n                    sub_s_dict[char] += 1\n                else:\n                    sub_s_dict[char] = 1\n            print(len(sub_s_dict))\n"
    },
    {
        "number": 4513,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(board: List[List[int]]) -> bool:\n        for i in range(9):\n            row = set()\n            col = set()\n            for j in range(9):\n                if board[i][j] in row or board[j][i] in col:\n                    return False\n                row.add(board[i][j])\n                col.add(board[j][i])\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                square = set()\n                for k in range(3):\n                    for l in range(3):\n                        square.add(board[i+k][j+l])\n                if len(square) != 9:\n                    return False\n        return True\n\n    def find_empty_cell(board: List[List[int]]) -> Tuple[int, int]:\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return i, j\n        return -1, -1\n\n    def solve(board: List[List[int]]) -> bool:\n        i, j = find_empty_cell(board)\n        if i == -1 and j == -1:\n            return True\n        for num in range(1, 10):\n            if is_valid(board):\n                board[i][j] = num\n                if solve(board):\n                    return True\n                board[i][j] = 0\n        return False\n\n    def anti_sudoku(board: List[List[int]]) -> List[List[int]]:\n        for i in range(9):\n            row = set()\n            col = set()\n            for j in range(9):\n                row.add(board[i][j])\n                col.add(board[j][i])\n            if len(row) == 9:\n                return board\n            if len(col) == 9:\n                return board\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                square = set()\n                for k in range(3):\n                    for l in range(3):\n                        square.add(board[i+k][j+l])\n                if len(square) == 9:\n                    return board\n        return board\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        board = [[0] * 9 for _ in range(9)]\n        for i in range(9):\n            line = stdin.readline().strip()\n            for j in range(9):\n                board[i][j] = int(line[j])\n        board = anti_sudoku(board)\n        for i in range(9):\n            print(\"\".join(str(board[i][j]) for j in range(9)))\n"
    },
    {
        "number": 4514,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, visited, seq, k):\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                dfs(child, visited, seq, k)\n        seq.append(node)\n\n    n, q = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        p = int(stdin.split()[i - 1])\n        graph[p].append(i)\n\n    result = []\n    for _ in range(q):\n        u, k = map(int, stdin.split()[q + 1:q + 3])\n        visited = [False] * (n + 1)\n        seq = []\n        dfs(u, visited, seq, k)\n        if k <= len(seq):\n            result.append(seq[k - 1])\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4515,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_possible(a, b, c, n):\n        return (a + b + c) == n and (a + b) == c\n\n    t = int(stdin)\n    for _ in range(t):\n        a, b, c, n = map(int, input().split())\n        if is_possible(a, b, c, n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4516,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def pos(p, val):\n        return p.index(val)\n\n    n, m = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n    p = [i for i in range(1, n + 1)]\n\n    result = []\n    for i in range(1, n + 1):\n        p[0], p[i] = p[i], p[0]\n        f = sum(abs(pos(p, x[j]) - pos(p, x[j + 1])) for j in range(m - 1))\n        result.append(f)\n        p[0], p[i] = p[i], p[0]\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 4517,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, parent, visited, depth, vertices):\n        visited[node] = True\n        depth[node] = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if not visited[neighbor]:\n                    dfs(neighbor, node, visited, depth, vertices)\n                    depth[node] = min(depth[node], depth[neighbor] + 1)\n                elif vertices[neighbor] and depth[node] + 1 == depth[neighbor]:\n                    vertices[node] = True\n\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for _ in range(m):\n        k = int(stdin.readline())\n        vertices = [False] * n\n        for i in range(k):\n            v = int(stdin.readline())\n            vertices[v] = True\n\n        visited = [False] * n\n        depth = [float('inf')] * n\n        dfs(1, -1, visited, depth, vertices)\n        print(\"YES\" if any(vertices) else \"NO\")\n"
    },
    {
        "number": 4518,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_possible(n: int, a: List[int]) -> bool:\n        def dfs(v: int, visited: Set[int]) -> bool:\n            visited.add(v)\n            for u in range(n):\n                if a[u] != a[v] and u not in visited and dfs(u, visited):\n                    return True\n            return False\n\n        for i in range(n):\n            if dfs(i, set()):\n                return True\n        return False\n\n    def build_roads(n: int, a: List[int]) -> List[Tuple[int, int]]:\n        def dfs(v: int, visited: Set[int], used: Set[int]) -> List[Tuple[int, int]]:\n            visited.add(v)\n            result = []\n            for u in range(n):\n                if a[u] != a[v] and u not in visited and u not in used:\n                    result.extend(dfs(u, visited, used | {u}))\n            return [(v, u) for u in range(n) if a[u] != a[v] and u not in visited and u not in used] + result\n\n        return dfs(0, set(), set())\n\n    def main(n: int, a: List[int]) -> str:\n        if not is_possible(n, a):\n            return \"NO\\n\"\n        roads = build_roads(n, a)\n        return \"YES\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in roads)\n\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        output.append(main(n, a))\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4519,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(s: str, i: int, j: int) -> str:\n        return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n    def min_lexicographically(s: str) -> str:\n        return ''.join(sorted(s))\n\n    q = int(stdin.readline())\n    for _ in range(q):\n        n, k = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n\n        for _ in range(k):\n            i, j = max(0, k - n + 1), min(k, n - 1)\n            s = min_lexicographically(swap(s, i, j))\n\n        print(s)\n"
    },
    {
        "number": 4520,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_bad(point: int, segments: List[Tuple[int, int]]) -> bool:\n        count = 0\n        for l, r in segments:\n            if l <= point <= r:\n                count += 1\n                if count > k:\n                    return True\n        return False\n\n    def remove_segments(segments: List[Tuple[int, int]]) -> List[int]:\n        bad_points = set()\n        for l, r in segments:\n            for point in range(l, r + 1):\n                if is_bad(point, segments):\n                    bad_points.add(point)\n        min_removed = len(bad_points)\n        for i in range(n):\n            if segments[i][0] in bad_points:\n                segments[i] = (segments[i][0] + 1, segments[i][1])\n            if segments[i][1] in bad_points:\n                segments[i] = (segments[i][0], segments[i][1] - 1)\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i][0])\n            if segments[i][0] > segments[i][1]:\n                segments[i] = (segments[i][1], segments[i"
    },
    {
        "number": 4521,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(x1, x2, v1, v2):\n        if x1 < x2:\n            return (x2 - x1) / (v1 - v2)\n        else:\n            return (x1 - x2) / (v2 - v1)\n\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n    v = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = distance(x[i], x[j], v[i], v[j])\n            total_distance += d\n\n    return str(total_distance)\n"
    },
    {
        "number": 4522,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(u: int, v: int, w: int, visited: set, dist: list, parent: list, max_weight: int) -> bool:\n        if u == v:\n            return True\n        visited.add(u)\n        for i in range(len(dist)):\n            if i not in visited and dist[i] > dist[u] + w:\n                if dfs(i, v, max(max_weight, w), visited, dist, parent, max_weight):\n                    return True\n        return False\n\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    queries = list(map(int, stdin.readline().split()))\n\n    adj_list = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj_list[u - 1].append((v - 1, w))\n        adj_list[v - 1].append((u - 1, w))\n\n    result = []\n    for q in queries:\n        visited = set()\n        dist = [float('inf')] * n\n        parent = [-1] * n\n        dist[0] = 0\n        for i in range(n):\n            for j, w in adj_list[i]:\n                if dist[i] + w < dist[j]:\n                    dist[j] = dist[i] + w\n                    parent[j] = i\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dfs(i, j, float('inf'), visited, dist, parent, q):\n                    count += 1\n        result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4523,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_move(a, i, j):\n        return abs(a[i] - a[j]) <= 1\n\n    def find_min_element(a):\n        return min(a)\n\n    def remove_min_element(a):\n        return [x for x in a if x != min(a)]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if len(a) == 1:\n            print(\"YES\")\n        else:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if is_valid_move(a, i, j):\n                        a_new = remove_min_element(a)\n                        if len(a_new) == 1:\n                            print(\"YES\")\n                            break\n                        else:\n                            a = a_new\n                else:\n                    continue\n                break\n            else:\n                print(\"NO\")\n"
    },
    {
        "number": 4524,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    a = input_list[1]\n    b = input_list[2]\n\n    a_binary = bin(int(a, 2))[2:].zfill(n)\n    b_binary = bin(int(b, 2))[2:].zfill(m)\n\n    answer = 0\n    while b_binary != '0' * m:\n        a_binary = a_binary.lstrip('0')\n        b_binary = b_binary.lstrip('0')\n        a_binary = a_binary[:len(b_binary)]\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        b_binary = b_binary.lstrip('1')\n        if a_binary == '' or b_binary == '':\n            break\n        a_binary = a_binary.lstrip('0')\n        b_binary = b_binary.lstrip('0')\n        a_binary = a_binary[:len(b_binary)]\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1')\n        a_binary = a_binary.lstrip('0')\n        a_binary = a_binary.lstrip('1"
    },
    {
        "number": 4525,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    input_data = stdin.split('\\n')[1:]\n\n    for i in range(t):\n        n = int(input_data[i])\n        if n % 2 == 0:\n            a = [i for i in range(1, n+1, 2)] + [i for i in range(2, n+1, 2)]\n            a.sort()\n            print(\"YES\")\n            print(\" \".join(map(str, a)))\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4526,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_special(a, n):\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                if a[i:j] == list(range(a[i-1]+1, a[j-1]+1)):\n                    return True\n        return False\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        count = 0\n        for i in range(n):\n            if is_special(a, n):\n                count += 1\n        print(count)\n"
    },
    {
        "number": 4527,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_non_intersecting(l1, r1, l2, r2):\n        return l1 >= r2 or l2 >= r1\n\n    def is_inside(l1, r1, l2, r2):\n        return l1 <= l2 and r1 >= r2\n\n    def check_intersection(l1, r1, l2, r2):\n        return not (l1 >= r2 or l2 >= r1)\n\n    def check_inside(l1, r1, l2, r2):\n        return l1 <= l2 and r1 >= r2\n\n    def check_subset(segments, subset):\n        for i in range(len(segments)):\n            for j in range(len(segments)):\n                if i != j:\n                    if not (is_non_intersecting(segments[i][0], segments[i][1], segments[j][0], segments[j][1]) or check_inside(segments[i][0], segments[i][1], segments[j][0], segments[j][1])):\n                        return False\n        return True\n\n    def max_subset_size(segments):\n        n = len(segments)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if is_non_intersecting(segments[i][0], segments[i][1], segments[j][0], segments[j][1]):\n                    dp[i][j] = True\n                else:\n                    for k in range(i, j):\n                        if dp[i][k] and dp[k + 1][j]:\n                            dp[i][j] = True\n                            break\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if not dp[i][j]:\n                    return j - i\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().split())\n            segments.append((l, r))\n        subset_size = max_subset_size(segments)\n        print(subset_size)\n"
    },
    {
        "number": 4528,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        h, m = map(int, stdin.split('\\n')[i].split())\n        if h == 0 and m == 0:\n            output.append(0)\n        else:\n            output.append(60*24 - (h*60 + m))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4529,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_substring(s: str, x_e: int, y_e: int) -> int:\n        n = len(s)\n        dp = [[0] * (y_e + 1) for _ in range(x_e + 1)]\n        for i in range(n):\n            for x in range(x_e + 1):\n                for y in range(y_e + 1):\n                    if s[i] == 'L':\n                        dp[x][y] = max(dp[x][y], dp[x - 1][y] + 1)\n                    elif s[i] == 'R':\n                        dp[x][y] = max(dp[x][y], dp[x + 1][y] + 1)\n                    elif s[i] == 'U':\n                        dp[x][y] = max(dp[x][y], dp[x][y - 1] + 1)\n                    elif s[i] == 'D':\n                        dp[x][y] = max(dp[x][y], dp[x][y + 1] + 1)\n        for i in range(x_e + 1):\n            for j in range(y_e + 1):\n                if dp[i][j] == n - i:\n                    return i, j\n        return -1\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        x_e, y_e = 0, 0\n        for i in range(n):\n            if s[i] == 'L':\n                x_e -= 1\n            elif s[i] == 'R':\n                x_e += 1\n            elif s[i] == 'U':\n                y_e -= 1\n            elif s[i] == 'D':\n                y_e += 1\n        l, r = find_min_substring(s, x_e, y_e)\n        if l == -1:\n            print(-1)\n        else:\n            print(l, r)\n"
    },
    {
        "number": 4530,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_pair(team1, team2):\n        for skill in team1:\n            if skill in team2:\n                return False\n        return True\n\n    def find_max_size(n, a):\n        a.sort()\n        max_size = 1\n        for i in range(n - 1):\n            if a[i] != a[i + 1]:\n                max_size += 1\n        return max_size\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        max_size = find_max_size(n, a)\n        if max_size == 1:\n            print(1)\n        else:\n            print(max_size - 1)\n"
    },
    {
        "number": 4531,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dist(x, y):\n        return len(nx.shortest_path(G, x, y)) - 1\n\n    def cost(v):\n        return sum(dist(v, i) * a[i] for i in range(1, n + 1))\n\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        G.add_edge(u, v)\n\n    max_cost = max(cost(v) for v in range(1, n + 1))\n    return str(max_cost)\n"
    },
    {
        "number": 4532,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_divisible(a, k):\n        return all(a_i % k == 0 for a_i in a)\n\n    def min_moves(a, k):\n        x = 0\n        moves = 0\n        for i in range(len(a)):\n            if a[i] % k != 0:\n                a[i] += x\n                x += 1\n                moves += 1\n        return moves\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        while not is_divisible(a, k):\n            a_i = min(i for i in range(len(a)) if a[i] % k != 0)\n            a[a_i] += 1\n        print(min_moves(a, k))\n"
    },
    {
        "number": 4533,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    n, m = map(int, stdin.split())\n    children = []\n    cookies = []\n\n    for _ in range(n):\n        child = list(map(int, input().split()))\n        children.append(child)\n\n    for _ in range(m):\n        cookie = list(map(int, input().split()))\n        cookies.append(cookie)\n\n    # Sort children and cookies by greed factor\n    children.sort(key=lambda x: x[1])\n    cookies.sort(key=lambda x: x[0], reverse=True)\n\n    # Assign cookies to children\n    assigned_cookies = 0\n    content_children = 0\n\n    for child in children:\n        if child[1] <= cookies[assigned_cookies][0]:\n            content_children += 1\n            assigned_cookies += 1\n\n    return content_children\n"
    },
    {
        "number": 4534,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    k = int(stdin)\n    if k < 0 or k > 33:\n        return \"Invalid input\"\n\n    def generate_pascal_triangle(k: int) -> list:\n        triangle = [[1]]\n        for i in range(1, k + 1):\n            row = [1] * (i + 1)\n            for j in range(1, i):\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            triangle.append(row)\n        return triangle\n\n    triangle = generate_pascal_triangle(k)\n    return triangle[k]\n"
    },
    {
        "number": 4535,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Convert the binary string to an integer\n    num = int(stdin, 2)\n\n    # Initialize the count of '1' bits to 0\n    count = 0\n\n    # Iterate through each bit of the integer\n    while num:\n        # If the current bit is 1, increment the count\n        if num & 1:\n            count += 1\n\n        # Shift the integer to the right by 1 bit\n        num >>= 1\n\n    return count"
    },
    {
        "number": 4536,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    digits = list(map(int, stdin))\n    carry = 1\n    for i in range(len(digits)-1, -1, -1):\n        digits[i] += carry\n        if digits[i] == 10:\n            digits[i] = 0\n            carry = 1\n        else:\n            carry = 0\n    if carry == 1:\n        digits = [1] + digits\n    return ''.join(map(str, digits)) "
    },
    {
        "number": 4537,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    max_value = max(A+B, A-B, A*B)\n    return str(max_value)\n"
    },
    {
        "number": 4538,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, D = map(int, input_data[0].split())\n    points = []\n    for i in range(1, N+1):\n        x, y = map(int, input_data[i].split())\n        points.append((x, y))\n\n    count = 0\n    for point in points:\n        if (point[0]**2 + point[1]**2)**0.5 <= D:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 4539,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    f_N = sum(int(digit) for digit in str(N))\n    if N % f_N == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4540,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    A = list(map(int, input_data[1].split()))\n\n    total_cost = 0\n    for i in range(1, N + 1):\n        total_cost += abs(A[i - 1] - A[i])\n\n    for i in range(1, N + 1):\n        print(total_cost)\n"
    },
    {
        "number": 4541,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    c = stdin.lower()\n    if c in vowels:\n        return 'vowel'\n    else:\n        return 'consonant'\n"
    },
    {
        "number": 4542,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    black_count = S.count('B')\n    white_count = S.count('W')\n    min_new_stones = abs(black_count - white_count)\n    return str(min_new_stones)\n"
    },
    {
        "number": 4543,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    concatenation = str(a) + str(b)\n    square_root = int(concatenation) ** 0.5\n    if square_root == int(square_root):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4544,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, X = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    for i in range(N):\n        if a[i] == X:\n            count += 1\n        elif a[i] > X:\n            a[i] -= 1\n            count += 1\n        else:\n            a[i] += 1\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4545,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A = map(int, stdin.split())\n    return (N * N - A) // 2\n"
    },
    {
        "number": 4546,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n\n    if b - a == c - b:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4547,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if 9 in str(N):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4548,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M, X = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    # Initialize the cost array\n    cost = [float('inf')] * (N + 1)\n    cost[X] = 0\n\n    # Calculate the minimum cost to reach each square\n    for i in range(1, M + 1):\n        for j in range(A[i - 1], N):\n            cost[j + 1] = min(cost[j + 1], cost[j] + 1)\n\n    # Find the minimum cost to reach Square 0 or Square N\n    min_cost = float('inf')\n    for i in range(N, -1, -1):\n        if cost[i] < min_cost:\n            min_cost = cost[i]\n\n    return min_cost\n"
    },
    {
        "number": 4549,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W = map(int, stdin.split()[0:2])\n    s = [list(map(str, stdin.split()[2:])) for _ in range(H)]\n\n    def dfs(i, j, visited):\n        if (i, j) in visited:\n            return\n        visited.add((i, j))\n        if s[i][j] == \"#\":\n            return\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < H and 0 <= y < W:\n                dfs(x, y, visited)\n\n    for i in range(H):\n        for j in range(W):\n            if s[i][j] == \"#\":\n                dfs(i, j, set())\n                return \"Yes\"\n    return \"No\"\n"
    },
    {
        "number": 4550,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n    if a == b and b == c:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4551,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n\n    left_pan = A + B\n    right_pan = C + D\n\n    if left_pan > right_pan:\n        return \"Left\"\n    elif left_pan < right_pan:\n        return \"Right\"\n    else:\n        return \"Balanced\"\n"
    },
    {
        "number": 4552,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_profit(c_i: int) -> int:\n        return P[i][c_i]\n\n    def is_open(F: list, i: int, j: int, k: int) -> bool:\n        return F[i][j][k]\n\n    def count_open_periods(F: list) -> int:\n        c = 0\n        for i in range(N):\n            for j in range(1, 6):\n                for k in range(1, 3):\n                    if is_open(F, i, j, k):\n                        c += 1\n        return c\n\n    def max_profit(F: list) -> int:\n        c = count_open_periods(F)\n        return sum(get_profit(c_i) for c_i in range(11))\n\n    # Read input\n    N, *F, *P = stdin.split()\n    N = int(N)\n    F = [[[int(F[i][j][k]) for k in range(2)] for j in range(5)] for i in range(N)]\n    P = [[int(P[i][j]) for j in range(11)] for i in range(N)]\n\n    # Calculate maximum profit\n    result = max_profit(F)\n\n    # Print result\n    return str(result)\n"
    },
    {
        "number": 4553,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, S = stdin.split()\n    A, B = int(A), int(B)\n\n    if len(S) != A + B + 1:\n        return \"No\"\n\n    if S[A] != \"-\":\n        return \"No\"\n\n    for i in range(A + 1):\n        if not S[i].isdigit():\n            return \"No\"\n\n    for i in range(A + 1, A + B + 1):\n        if not S[i].isdigit() or int(S[i]) > 9:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 4554,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    W, a, b = map(int, stdin.split())\n\n    # Calculate the minimum distance needed to move the second rectangle\n    min_distance = min(abs(a - b), abs(a + W - b), abs(a + W - b - 1))\n\n    return str(min_distance)\n"
    },
    {
        "number": 4555,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, K = map(int, stdin.split())\n    if A > B:\n        A, B = B, A\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // 2\n    if K > (B - A + 1) // 2:\n        K = (B - A + 1) // "
    },
    {
        "number": 4556,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.split()\n    s = ''.join(s)\n    x = s[0]\n    return f\"{x}C\"\n"
    },
    {
        "number": 4557,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, X = map(int, stdin.split())\n\n    if X > A + B:\n        return \"NO\"\n    elif X > A:\n        return \"NO\"\n    else:\n        return \"YES\"\n"
    },
    {
        "number": 4558,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, t = map(int, stdin.split())\n    sand_after_t_seconds = X - (t * 1)\n    return sand_after_t_seconds\n"
    },
    {
        "number": 4559,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    A = list(map(int, input_list[1:]))\n\n    result = 1\n    for i in range(N):\n        result *= A[i]\n        if result > 10**18:\n            return -1\n\n    return result\n"
    },
    {
        "number": 4560,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A = map(int, stdin.split())\n\n    if N % 500 == 0:\n        return \"Yes\"\n\n    if A * 500 >= N:\n        return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4561,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, A, B = map(int, stdin.split())\n\n    if A - B <= X:\n        if A - B <= X + 1:\n            return \"delicious\"\n        else:\n            return \"safe\"\n    else:\n        return \"dangerous\"\n"
    },
    {
        "number": 4562,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    sqrt_N = int(N**0.5)\n    square = sqrt_N**2\n    if square > N:\n        square -= 1\n    return str(square)\n"
    },
    {
        "number": 4563,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_min_votes(T, A, N):\n        min_votes = float('inf')\n        for i in range(1, N + 1):\n            min_votes = min(min_votes, T[i - 1] * A[i - 1])\n        return min_votes\n\n    N = int(stdin.split()[0])\n    T = [int(x) for x in stdin.split()[1::2]]\n    A = [int(x) for x in stdin.split()[2::2]]\n\n    min_votes = find_min_votes(T, A, N)\n    return str(min_votes)\n"
    },
    {
        "number": 4564,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    if len(set(S)) == len(S):\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 4565,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = map(str, stdin.split())\n    N = int(N)\n    S = list(S)\n\n    leader_idx = S.index('E')\n    leader_direction = 'E'\n\n    # Count the number of people who have to change their direction\n    count = 0\n    for i in range(N):\n        if S[i] != leader_direction:\n            count += 1\n\n    # If the leader is facing west, we need to count the number of people who have to change their direction\n    if leader_direction == 'W':\n        count += N - leader_idx - 1\n\n    return count\n"
    },
    {
        "number": 4566,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, stdin.split()[2 * i: 2 * i + 2])) for i in range(M)]\n    cities = set(sum(roads, ()))\n    city_connections = {city: 0 for city in cities}\n\n    for a, b in roads:\n        city_connections[a] += 1\n        city_connections[b] += 1\n\n    for city in sorted(cities):\n        print(city_connections[city])\n"
    },
    {
        "number": 4567,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    s_list = list(map(int, input_list[1:]))\n\n    max_grade = sum(s_list)\n    if max_grade % 10 == 0:\n        max_grade -= 10\n\n    return str(max_grade)\n"
    },
    {
        "number": 4568,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    S = stdin.split('\\n')[1]\n\n    # Initialize variables\n    max_diff = 0\n    left = 0\n    right = N - 1\n\n    # Iterate through the string\n    while left < right:\n        # Calculate the number of different letters in X and Y\n        diff_left = len(set(S[:left+1]))\n        diff_right = len(set(S[right:]))\n\n        # Update the maximum number of different letters\n        max_diff = max(max_diff, diff_left, diff_right)\n\n        # Move the left and right pointers\n        if diff_left > diff_right:\n            right -= 1\n        else:\n            left += 1\n\n    return max_diff"
    },
    {
        "number": 4569,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    weather_cycle = ['Sunny', 'Cloudy', 'Rainy']\n    today = stdin.strip()\n    tomorrow = weather_cycle[(weather_cycle.index(today) + 1) % len(weather_cycle)]\n    return tomorrow\n"
    },
    {
        "number": 4570,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = map(int, stdin.split())\n    if N <= 0 or A <= 0 or B <= 0:\n        return \"Invalid input\"\n    if N <= A:\n        return N * A\n    else:\n        return B\n"
    },
    {
        "number": 4571,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    # Calculate the expected value of the total execution time of the code\n    X = (1900 * M + 100 * (N - M)) * 1000\n    return str(X)\n"
    },
    {
        "number": 4572,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    letters = set(S)\n    for letter in range(ord('a'), ord('z') + 1):\n        if chr(letter) not in letters:\n            return chr(letter)\n    return \"None\"\n"
    },
    {
        "number": 4573,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_median(numbers: list) -> int:\n        numbers.sort()\n        length = len(numbers)\n        if length % 2 == 0:\n            return (numbers[length // 2 - 1] + numbers[length // 2]) // 2\n        else:\n            return numbers[length // 2]\n\n    N, *X = map(int, stdin.split())\n    B = []\n\n    for i in range(N):\n        numbers = X[:i] + X[i + 1:]\n        B.append(find_median(numbers))\n\n    return \"\\n\".join(map(str, B))\n"
    },
    {
        "number": 4574,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def max_area(sticks):\n        sticks.sort(reverse=True)\n        area = 0\n        for i in range(3):\n            for j in range(i+1, 4):\n                area = max(area, sticks[i] * sticks[j])\n        return area\n\n    N, *A = map(int, stdin.split())\n    sticks = [0] * N\n    for i in range(N):\n        sticks[i] = A[i]\n\n    result = max_area(sticks)\n    return str(result)\n"
    },
    {
        "number": 4575,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_chocolate_pieces(N, D, X, A):\n        pieces_per_day = X // D\n        remaining_pieces = X % D\n        prepared_pieces = 0\n\n        for i in range(1, N + 1):\n            days_to_eat = A[i - 1] + 1\n            pieces_eaten = days_to_eat * pieces_per_day\n\n            if remaining_pieces > 0:\n                pieces_eaten += 1\n                remaining_pieces -= 1\n\n            prepared_pieces += pieces_eaten\n\n        return prepared_pieces\n\n    N, D, X = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    prepared_pieces = get_chocolate_pieces(N, D, X, A)\n    return prepared_pieces\n"
    },
    {
        "number": 4576,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, X = map(int, stdin.split())\n\n    # Check constraints\n    if not (0 <= A <= 50 and 0 <= B <= 50 and 0 <= C <= 50 and A + B + C >= 1 and 50 <= X <= 20000 and X % 50 == 0):\n        return \"Invalid input\"\n\n    # Calculate the number of ways to select coins\n    total_coins = A + B + C\n    ways = 0\n    for i in range(X // 50 + 1):\n        ways += (total_coins - i * 50) * (total_coins - i * 50 + 1) // 2\n\n    return ways\n"
    },
    {
        "number": 4577,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    if C >= A and C <= B:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4578,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, X = map(int, stdin.split())\n    mi = list(map(int, stdin.split()[1:]))\n    dp = [0] * (X + 1)\n    dp[0] = 1\n    for i in range(1, X + 1):\n        for j in range(1, N + 1):\n            if i >= mi[j - 1]:\n                dp[i] = max(dp[i], dp[i - mi[j - 1]] + 1)\n    return dp[X]\n"
    },
    {
        "number": 4579,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *S = stdin.split()\n    N = int(N)\n    items = set()\n    for s in S:\n        items.add(s)\n    return len(items)\n"
    },
    {
        "number": 4580,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *a = map(int, stdin.split())\n\n    # Define the rating to color mapping\n    rating_to_color = {\n        1: \"gray\",\n        2: \"brown\",\n        3: \"green\",\n        4: \"cyan\",\n        5: \"blue\",\n        6: \"yellow\",\n        7: \"orange\",\n        8: \"red\"\n    }\n\n    # Initialize the minimum and maximum number of different colors\n    min_colors = N\n    max_colors = N\n\n    # Iterate through the ratings and update the minimum and maximum number of different colors\n    for rating in a:\n        if rating in rating_to_color:\n            min_colors = min(min_colors, 1)\n            max_colors = min(max_colors, 8)\n        else:\n            min_colors = min(min_colors, 9)\n            max_colors = min(max_colors, 9)\n\n    # Return the minimum and maximum number of different colors\n    return f\"{min_colors} {max_colors}\"\n"
    },
    {
        "number": 4581,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    price = 700  # price of ramen\n    if S[0] == 'o':\n        price += 100  # add price of boiled egg\n    if S[1] == 'x':\n        price += 100  # add price of sliced pork\n    if S[2] == 'x':\n        price += 100  # add price of green onions\n    return str(price)  # return the price of the bowl of ramen\n"
    },
    {
        "number": 4582,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = stdin.split()\n    if a == 'H' and b == 'H':\n        return 'H'\n    elif a == 'H' and b == 'D':\n        return 'D'\n    elif a == 'D' and b == 'H':\n        return 'D'\n    else:\n        return 'H'\n"
    },
    {
        "number": 4583,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin)\n    op1 = '+' if A + B == 7 else '-'\n    op2 = '+' if B + C == 7 else '-'\n    op3 = '+' if C + D == 7 else '-'\n    return f\"{A}{op1}{B}{op2}{C}{op3}{D} = 7\"\n"
    },
    {
        "number": 4584,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *A = map(int, stdin.split())\n    A = list(A)\n    immediate_subordinates = [0] * (N + 1)\n\n    for i in range(2, N + 1):\n        immediate_subordinates[A[i - 2]] += 1\n\n    for i in range(1, N + 1):\n        print(immediate_subordinates[i])\n"
    },
    {
        "number": 4585,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin.strip())\n\n    if X == 0:\n        return 0\n\n    if X < 0:\n        return \"Impossible\"\n\n    time = 0\n    while X > 0:\n        if X >= time:\n            X -= time\n            time += 1\n        else:\n            break\n\n    if X == 0:\n        return time - 1\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 4586,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if len(set(str(N))) == 4:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4587,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_altar(upper_size, middle_size, lower_size):\n        return upper_size < middle_size < lower_size\n\n    def count_valid_altars(upper_sizes, middle_sizes, lower_sizes):\n        count = 0\n        for i in range(len(upper_sizes)):\n            for j in range(len(middle_sizes)):\n                for k in range(len(lower_sizes)):\n                    if is_valid_altar(upper_sizes[i], middle_sizes[j], lower_sizes[k]):\n                        count += 1\n        return count\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        N = int(lines[0])\n        upper_sizes = [int(x) for x in lines[1].split()]\n        middle_sizes = [int(x) for x in lines[2].split()]\n        lower_sizes = [int(x) for x in lines[3].split()]\n        return N, upper_sizes, middle_sizes, lower_sizes\n\n    N, upper_sizes, middle_sizes, lower_sizes = parse_input(stdin)\n    valid_altars = count_valid_altars(upper_sizes, middle_sizes, lower_sizes)\n    return str(valid_altars)\n"
    },
    {
        "number": 4588,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, Y = stdin.split()\n    X_value = int(X, 16)\n    Y_value = int(Y, 16)\n\n    if X_value < Y_value:\n        return \"<\"\n    elif X_value > Y_value:\n        return \">\"\n    else:\n        return \"=\" "
    },
    {
        "number": 4589,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W = map(int, stdin.split()[0:2])\n    S = stdin.split()[2:]\n\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == '.':\n                count = 0\n                for k in range(max(0, i - 1), min(H, i + 2)):\n                    for l in range(max(0, j - 1), min(W, j + 2)):\n                        if S[k][l] == '#':\n                            count += 1\n                S[i] = S[i][:j] + str(count) + S[i][j + 1:]\n\n    return '\\n'.join(S)\n"
    },
    {
        "number": 4590,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def read_input():\n        first_line = stdin.readline().strip().split()\n        N, M, K = int(first_line[0]), int(first_line[1]), int(first_line[2])\n        A = list(map(int, stdin.readline().strip().split()))\n        B = list(map(int, stdin.readline().strip().split()))\n        return N, M, K, A, B\n\n    def read_book(desk, i):\n        return desk[i - 1] if i > 0 else 0\n\n    def remove_book(desk, i):\n        desk.pop(i - 1)\n\n    def read_book_from_desk(desk, i):\n        return read_book(desk, i)\n\n    def read_book_from_desk_and_remove(desk, i):\n        return read_book(desk, i), remove_book(desk, i)\n\n    def read_books(N, M, K, A, B):\n        total_time = 0\n        while A and B and total_time <= K:\n            time_A, A = read_book_from_desk_and_remove(A, 1)\n            time_B, B = read_book_from_desk_and_remove(B, 1)\n            total_time += max(time_A, time_B)\n        return len(A) + len(B)\n\n    N, M, K, A, B = read_input()\n    return str(read_books(N, M, K, A, B))\n"
    },
    {
        "number": 4591,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, X, Y = map(int, stdin.split())\n    min_money = min(A * X + B * Y, A * X + C * Y, B * Y + C * X)\n    return min_money\n"
    },
    {
        "number": 4592,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    MOD = 10**9 + 7\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n+1):\n            result = (result * i) % MOD\n        return result\n    \n    def count_divisors(n: int) -> int:\n        result = 0\n        for i in range(1, n+1):\n            if n % i == 0:\n                result += 1\n        return result\n    \n    N_factorial = factorial(N)\n    N_divisors = count_divisors(N_factorial)\n    return str(N_divisors)"
    },
    {
        "number": 4593,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin.strip())\n    max_perfect_power = -1\n    for b in range(2, int(X**0.5) + 1):\n        p = 2\n        while b**p <= X:\n            if b**p > max_perfect_power:\n                max_perfect_power = b**p\n            p += 1\n    return str(max_perfect_power)\n"
    },
    {
        "number": 4594,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    diameters = [int(d) for d in input_data[1:]]\n\n    max_layers = 1\n    for i in range(N - 1):\n        if diameters[i] >= diameters[i + 1]:\n            max_layers += 1\n        else:\n            break\n\n    return str(max_layers)\n"
    },
    {
        "number": 4595,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1].startswith('A') and s[i:j+1].endswith('Z'):\n                max_len = max(max_len, j-i+1)\n    return max_len"
    },
    {
        "number": 4596,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    \n    count = 0\n    while all(a % 2 == 0 for a in A):\n        A = [a // 2 for a in A]\n        count += 1\n    \n    return count\n"
    },
    {
        "number": 4597,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    power = 1\n    mod = 10**9 + 7\n    for i in range(1, N+1):\n        power = (power * i) % mod\n    return power\n"
    },
    {
        "number": 4598,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    total_candies = (N * (N + 1)) // 2\n    return total_candies\n"
    },
    {
        "number": 4599,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Alice's score\n    alice_score = 0\n    # Bob's score\n    bob_score = 0\n\n    # Alice's cards\n    alice_cards = []\n    # Bob's cards\n    bob_cards = []\n\n    # Initialize Alice's cards and Bob's cards\n    for i in range(N):\n        if i % 2 == 0:\n            alice_cards.append(a[i])\n        else:\n            bob_cards.append(a[i])\n\n    # Alice's optimal strategy\n    while len(alice_cards) > 0:\n        # Find the maximum number on Alice's cards\n        max_num = max(alice_cards)\n        # Find the index of the maximum number on Alice's cards\n        max_index = alice_cards.index(max_num)\n        # Add the maximum number to Alice's score\n        alice_score += max_num\n        # Remove the maximum number from Alice's cards\n        alice_cards.pop(max_index)\n\n    # Bob's optimal strategy\n    while len(bob_cards) > 0:\n        # Find the minimum number on Bob's cards\n        min_num = min(bob_cards)\n        # Find the index of the minimum number on Bob's cards\n        min_index = bob_cards.index(min_num)\n        # Add the minimum number to Bob's score\n        bob_score += min_num\n        # Remove the minimum number from Bob's cards\n        bob_cards.pop(min_index)\n\n    # Print Alice's score minus Bob's score\n    return str(alice_score - bob_score)\n"
    },
    {
        "number": 4600,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split()[:2])\n    problems = [list(map(str, input().split())) for _ in range(M)]\n\n    correct_answers = 0\n    penalties = 0\n\n    for problem in problems:\n        p, s = problem\n        p, s = int(p), s[0]\n\n        if s == 'AC':\n            correct_answers += 1\n            penalties += p - 1\n\n    print(correct_answers)\n    print(penalties)\n"
    },
    {
        "number": 4601,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[:2])\n    H = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    min_attacks = float('inf')\n    special_move_count = 0\n\n    # Iterate through the monsters' healths\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 1\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 1\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 2\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 3\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 4\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n        # If the monster's health is greater than 0,\n        # we need to do Attack at least once\n        if H[i] > 0:\n            min_attacks = 5\n            break\n\n    # If we can use Special Move, we can reset the health of the monster\n    # to 0 by using Special Move\n    if K > 0:\n        # Count the number of Special Moves used\n        special_move_count += 1\n        # Reset the health of the monster to 0\n        H[i] = 0\n\n    # Iterate through the monsters' healths again\n    for i in range(N):\n       "
    },
    {
        "number": 4602,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    inputs = stdin.split(\"\\n\")\n    N = int(inputs[0])\n    K = int(inputs[1])\n    x_i = list(map(int, inputs[2].split()))\n\n    # Calculate the distance covered by each robot\n    total_distance = 0\n    for i in range(1, N + 1):\n        # Type-A robot\n        distance_A = abs(x_i[i - 1] - 0) + abs(i - 1)\n        # Type-B robot\n        distance_B = abs(x_i[i - 1] - K) + abs(i - 1)\n\n        # Choose the minimum distance\n        min_distance = min(distance_A, distance_B)\n        total_distance += min_distance\n\n    return total_distance\n"
    },
    {
        "number": 4603,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n\n    # Calculate the minimum total fare\n    min_fare = min(A, B) + min(C, D)\n\n    return str(min_fare)\n"
    },
    {
        "number": 4604,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    N = int(input_data[0])\n    A = list(map(int, input_data[1:]))\n\n    # Check if the reports are consistent\n    if len(set(A)) != N:\n        return \"0\"\n\n    # Calculate the number of possible orders\n    MOD = 10**9 + 7\n    dp = [1] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(1, i + 1):\n            if A[i - 1] == j - 1:\n                dp[i] = (dp[i] * dp[j]) % MOD\n            elif A[i - 1] == i - j:\n                dp[i] = (dp[i] * dp[j]) % MOD\n            else:\n                return \"0\"\n\n    return str(dp[N])\n"
    },
    {
        "number": 4605,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, A, B = map(int, stdin.split())\n    total_sum = 0\n\n    for num in range(1, N + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if A <= digit_sum <= B:\n            total_sum += num\n\n    return total_sum\n"
    },
    {
        "number": 4606,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    if 100 <= N <= 999:\n        ABC_round = \"ABC\" + str(N).zfill(3)\n        return ABC_round\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4607,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    takahashi_count = 0\n\n    for day in range(1, b + 1):\n        if a == day:\n            takahashi_count += 1\n\n    return takahashi_count\n"
    },
    {
        "number": 4608,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, a_1, a_2 = map(int, stdin.split())\n    if a_1 == 2:\n        return 1\n    elif a_2 == 2:\n        return 1\n    else:\n        return -1\n"
    },
    {
        "number": 4609,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1:]))\n    count = 0\n\n    for i in range(N):\n        if A[i] in A[:i]:\n            count -= 1\n        else:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4610,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    # Count the frequency of each integer\n    freq = {}\n    for a in A:\n        if a in freq:\n            freq[a] += 1\n        else:\n            freq[a] = 1\n\n    # Find the minimum number of balls needed to rewrite the integers\n    min_balls = 0\n    for f in freq.values():\n        min_balls += f // K\n        if f % K != 0:\n            min_balls += 1\n\n    return min_balls\n"
    },
    {
        "number": 4611,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(x, y, visited):\n        if (x, y) in visited:\n            return False\n        visited.add((x, y))\n        return True\n\n    def can_reach(x, y, t, visited):\n        if (x, y) == (0, 0):\n            return True\n        if not is_valid(x + 1, y, visited):\n            return False\n        if not is_valid(x - 1, y, visited):\n            return False\n        if not is_valid(x, y + 1, visited):\n            return False\n        if not is_valid(x, y - 1, visited):\n            return False\n        return can_reach(x + 1, y, t + 1, visited) or can_reach(x - 1, y, t + 1, visited) or can_reach(x, y + 1, t + 1, visited) or can_reach(x, y - 1, t + 1, visited)\n\n    N, *data = stdin.split()\n    N = int(N)\n    visited = set()\n    for i in range(0, N * 2, 2):\n        t, x, y = int(data[i]), int(data[i + 1]), int(data[i + 2])\n        if not can_reach(x, y, t, visited):\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 4612,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    x = (a + b) / 2\n    return str(int(x + 0.5))\n"
    },
    {
        "number": 4613,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    from collections import defaultdict\n    N, M = map(int, stdin.split()[0:2])\n    adj_list = defaultdict(list)\n    for i in range(1, M+1):\n        a, b = map(int, stdin.split()[i*2-2:i*2])\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(node, visited, parent, bridges):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                if not visited[neighbor]:\n                    dfs(neighbor, visited, node, bridges)\n                elif not parent:\n                    bridges.append((node, neighbor))\n\n    visited = [False] * (N+1)\n    bridges = []\n    for node in range(1, N+1):\n        if not visited[node]:\n            dfs(node, visited, None, bridges)\n\n    return len(bridges)"
    },
    {
        "number": 4614,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n\n    if A == B:\n        return str(C)\n    elif A == C:\n        return str(B)\n    else:\n        return str(A)\n"
    },
    {
        "number": 4615,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D, E, F = map(int, stdin.split())\n\n    # Find the maximum mass of sugar water that can be made\n    max_mass = min(F, (F - 100 * (C + D)) // (C + D - E))\n\n    # Find the mass of sugar dissolved in the maximum mass of sugar water\n    mass_dissolved = min(max_mass * E, F - max_mass)\n\n    # Calculate the mass of the desired sugar water\n    desired_mass = max_mass - mass_dissolved\n\n    return f\"{desired_mass} {mass_dissolved}\"\n"
    },
    {
        "number": 4616,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    i18n = \"i\" + \"\".join(s[1:-1]) + \"n\"\n    return i18n\n"
    },
    {
        "number": 4617,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    grid = [list(stdin[i:i+3]) for i in range(0, len(stdin), 3)]\n    rotated_grid = [list(row[::-1]) for row in grid]\n\n    if grid == rotated_grid:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4618,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, K = stdin.split()\n    s = s.lower()\n    K = int(K)\n\n    def is_prefix(x, y):\n        for i in range(len(y)):\n            if x[i] != y[i]:\n                return False\n        return True\n\n    def lexicographically_smaller(x, y):\n        for i in range(min(len(x), len(y))):\n            if x[i] < y[i]:\n                return True\n            elif x[i] > y[i]:\n                return False\n        return len(x) < len(y)\n\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substrings.add(s[i:j])\n\n    substrings = sorted(list(substrings))\n\n    if K > len(substrings):\n        return \"Invalid input\"\n\n    return substrings[K - 1]\n"
    },
    {
        "number": 4619,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    W, H, N = map(int, stdin.split()[:3])\n    points = [tuple(map(int, stdin.split()[3*i:3*i+2])) for i in range(N)]\n    sequence = list(map(int, stdin.split()[3*N:3*N+N]))\n\n    white_area = W * H\n    for i in range(N):\n        x, y = points[i]\n        if sequence[i] == 1:\n            white_area -= (x - 0) * H\n        elif sequence[i] == 2:\n            white_area -= (W - x) * H\n        elif sequence[i] == 3:\n            white_area -= W * (y - 0)\n        elif sequence[i] == 4:\n            white_area -= W * (H - y)\n\n    return white_area\n"
    },
    {
        "number": 4620,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_time(S, F, C):\n        return S + lcm(F, C)\n\n    def find_earliest_time(S, F, C, N):\n        time = S\n        for i in range(1, N):\n            time = find_time(time, F[i - 1], C[i - 1])\n        return time\n\n    N = int(stdin.split()[0])\n    C = [int(x) for x in stdin.split()[1:N]]\n    S = [int(x) for x in stdin.split()[N:2 * N - 1]]\n    F = [int(x) for x in stdin.split()[2 * N - 1:]]\n\n    result = []\n    for i in range(1, N):\n        time = find_earliest_time(S[i - 1], F[i - 1], C[i - 1], N)\n        result.append(time)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4621,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    H, W = map(int, stdin.split()[:2])\n    image = stdin.split()[2:]\n    new_image = []\n\n    for i in range(H):\n        new_row = []\n        for j in range(W):\n            new_row.append(image[i][j])\n        new_image.append(new_row)\n\n    for i in range(H, 2 * H):\n        new_row = []\n        for j in range(W):\n            new_row.append(image[int((i + 1) / 2)][j])\n        new_image.append(new_row)\n\n    for row in new_image:\n        print(\"\".join(row))\n"
    },
    {
        "number": 4622,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    A = list(map(int, input_list[1:]))\n\n    if len(set(A)) == N:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4623,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_optimal_weight(w: List[int]) -> int:\n        w.sort()\n        return sum(w) // 2\n\n    def count_teams(w: List[int], s: int) -> int:\n        count = 0\n        i = 0\n        while i < len(w):\n            if w[i] + w[i + 1] <= s:\n                count += 1\n                i += 2\n            else:\n                i += 1\n        return count\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        w = list(map(int, stdin.readline().split()))\n        s = find_optimal_weight(w)\n        k = count_teams(w, s)\n        print(k)\n"
    },
    {
        "number": 4624,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        n, x = map(int, stdin.split('\\n')[i].split())\n        if n <= 2:\n            output.append(1)\n        else:\n            output.append(n // 2 + 1)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4625,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def process_test_case(n: int, m: int, s: str, p: List[int]) -> List[int]:\n        button_presses = [0] * 26\n        for i in range(m):\n            for j in range(p[i]):\n                button_presses[ord(s[j]) - ord('a')] += 1\n            button_presses[ord(s[p[i]]) - ord('a')] += 1\n        for j in range(p[m], n):\n            button_presses[ord(s[j]) - ord('a')] += 1\n        return button_presses\n\n    def process_test_cases(test_cases: List[str]) -> List[str]:\n        result = []\n        for test_case in test_cases:\n            n, m = map(int, test_case.split()[:2])\n            s = test_case.split()[2]\n            p = list(map(int, test_case.split()[3:]))\n            button_presses = process_test_case(n, m, s, p)\n            result.append(' '.join(map(str, button_presses)))\n        return result\n\n    test_cases = stdin.strip().split('\\n\\n')\n    test_cases = [test_case.split('\\n') for test_case in test_cases]\n    test_cases = [[line.strip() for line in test_case] for test_case in test_cases]\n    test_cases = [[int(test_case[0]), int(test_case[1])] + test_case[2:] for test_case in test_cases]\n\n    result = process_test_cases(test_cases)\n    return '\\n'.join(result)\n"
    },
    {
        "number": 4626,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, q+1):\n        a, b, c = map(int, stdin.split('\\n')[i].split())\n        min_dist = min(abs(a-b), abs(a-c), abs(b-c))\n        output.append(min_dist)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4627,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_similar(x: int, y: int) -> bool:\n        return (x % 2 == y % 2) or (abs(x - y) == 1)\n\n    def find_pairs(arr: List[int]) -> bool:\n        pairs = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if is_similar(arr[i], arr[j]):\n                    pairs.append((arr[i], arr[j]))\n                    break\n            else:\n                return False\n        return True\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        arr = list(map(int, stdin.readline().split()))\n        if find_pairs(arr):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 4628,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            if min_node == -1:\n                break\n            visited[min_node] = True\n            for i in range(n):\n                if not visited[i] and graph[min_node][i] != float('inf'):\n                    new_dist = dist[min_node] + graph[min_node][i]\n                    if new_dist < dist[i]:\n                        dist[i] = new_dist\n        return dist[end]\n\n    def min_cost(n, m, k, roads, routes):\n        graph = [[float('inf')] * n for _ in range(n)]\n        for i in range(m):\n            x, y, w = roads[i]\n            graph[x - 1][y - 1] = w\n            graph[y - 1][x - 1] = w\n        for i in range(k):\n            a, b = routes[i]\n            cost = dijkstra(graph, a - 1, b - 1)\n            if cost != float('inf'):\n                return cost\n        return 0\n\n    n, m, k = map(int, stdin.split())\n    roads = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    return str(min_cost(n, m, k, roads, routes))\n"
    },
    {
        "number": 4629,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    def is_good(n: int) -> bool:\n        n_str = str(n)\n        for digit in n_str:\n            if n_str.count(digit) > 1:\n                return False\n        return True\n\n    def find_smallest_good(n: int) -> int:\n        m = n\n        while not is_good(m):\n            m += 1\n        return m\n\n    for query in queries:\n        n = int(query)\n        result = find_smallest_good(n)\n        print(result)\n"
    },
    {
        "number": 4630,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split(\"\\n\")[0])\n    output = []\n    for _ in range(q):\n        n = int(stdin.split(\"\\n\")[1])\n        p = list(map(int, stdin.split(\"\\n\")[2].split()))\n        days = [0] * n\n        for i in range(n):\n            days[p[i] - 1] = i + 1\n        output.append(days)\n        stdin = stdin[2:]\n    return \"\\n\".join([\" \".join(map(str, day)) for day in output])\n"
    },
    {
        "number": 4631,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(x, y):\n        return min(abs(x - y), abs(x + 10**9 - y), abs(x - 10**9 - y))\n\n    def nearest_tree(x, trees):\n        return min(trees, key=lambda y: distance(x, y))\n\n    def min_distance(x, y, trees):\n        return sum(distance(x, nearest_tree(y, trees)) for y in range(y, y + m))\n\n    n, m = map(int, stdin.split()[:2])\n    trees = list(map(int, stdin.split()[2:2 + n]))\n    y = 0\n    res = float('inf')\n\n    for i in range(1, 10**9):\n        if all(distance(trees[j - 1], i) <= distance(trees[j - 1], y) + distance(i, y) for j in range(1, m + 1)):\n            y = i\n            res = min_distance(y, trees)\n            if res == 0:\n                break\n\n    print(res)\n    print(*range(y, y + m))\n"
    },
    {
        "number": 4632,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_lexicographically_smallest_path(paths):\n        return min(paths, key=lambda x: x)\n\n    def get_shortest_path(path):\n        result = []\n        for move in path:\n            if move == 'R':\n                result.append('R')\n            else:\n                result.append('U')\n        return ''.join(result)\n\n    def is_valid_path(path, packages):\n        x, y = 0, 0\n        for move in path:\n            if move == 'R':\n                x += 1\n            else:\n                y += 1\n            if (x, y) in packages:\n                return False\n        return True\n\n    def get_all_paths(packages):\n        paths = []\n        for package in packages:\n            paths.append(package)\n            for path in paths:\n                paths.append(path + 'R')\n                paths.append(path + 'U')\n        return paths\n\n    def get_packages(n, packages):\n        result = []\n        for i in range(n):\n            x, y = map(int, packages[i].split())\n            result.append((x, y))\n        return result\n\n    def main(t, n, packages):\n        packages = get_packages(n, packages)\n        paths = get_all_paths(packages)\n        if not is_valid_path(paths[0], packages):\n            return \"NO\"\n        shortest_path = get_shortest_path(get_lexicographically_smallest_path(paths))\n        return \"YES\\n\" + shortest_path\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        packages = [stdin.readline().strip() for _ in range(n)]\n        print(main(t, n, packages))\n"
    },
    {
        "number": 4633,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def sum_of_digits(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    def find_minimum_moves(n: int, s: int) -> int:\n        current_sum = sum_of_digits(n)\n        if current_sum <= s:\n            return 0\n\n        moves = 0\n        while current_sum > s:\n            n += 1\n            current_sum = sum_of_digits(n)\n            moves += 1\n\n        return moves\n\n    t = int(stdin.splitlines()[0])\n    output = []\n    for _ in range(t):\n        n, s = map(int, stdin.splitlines()[1].split())\n        output.append(find_minimum_moves(n, s))\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4634,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_move(a, l, r, direction):\n        if direction == 'right':\n            return r + 1 < n and a[r + 1] == 0\n        else:\n            return l - 1 >= 0 and a[l - 1] == 0\n\n    def make_move(a, l, r, direction):\n        if direction == 'right':\n            for i in range(l, r + 1):\n                a[i], a[i + 1] = a[i + 1], a[i]\n        else:\n            for i in range(r, l - 1, -1):\n                a[i], a[i - 1] = a[i - 1], a[i]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        left, right = -1, -1\n        for i in range(n):\n            if a[i] == 1:\n                if left == -1:\n                    left = i\n                right = i\n        if left == -1:\n            print(0)\n        else:\n            moves = 0\n            while not is_valid_move(a, left, right, 'right'):\n                make_move(a, left, right, 'right')\n                moves += 1\n            while not is_valid_move(a, left, right, 'left'):\n                make_move(a, left, right, 'left')\n                moves += 1\n            print(moves)\n"
    },
    {
        "number": 4635,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    for i, query in enumerate(queries, start=1):\n        n, k = map(int, query.split())\n        s = ''\n        for j in range(k):\n            s += chr(ord('a') + j)\n        print(s)\n"
    },
    {
        "number": 4636,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_move(candies, alice_size, bob_size):\n        move = 0\n        while alice_size + bob_size < len(candies):\n            move += 1\n            alice_size += candies[move]\n            bob_size += candies[len(candies) - move - 1]\n        return move\n\n    def get_alice_bob_sizes(candies, move):\n        alice_size = sum(candies[:move + 1])\n        bob_size = sum(candies[len(candies) - move - 1:])\n        return alice_size, bob_size\n\n    def get_alice_bob_sizes_after_move(candies, move, alice_size, bob_size):\n        alice_size += candies[move]\n        bob_size += candies[len(candies) - move - 1]\n        return alice_size, bob_size\n\n    test_cases = int(stdin.readline())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        candies = list(map(int, stdin.readline().split()))\n        move = get_move(candies, 0, 0)\n        alice_size, bob_size = get_alice_bob_sizes(candies, move)\n        alice_size_after_move, bob_size_after_move = get_alice_bob_sizes_after_move(candies, move, alice_size, bob_size)\n        while alice_size_after_move <= bob_size_after_move:\n            move += 1\n            alice_size, bob_size = get_alice_bob_sizes_after_move(candies, move, alice_size, bob_size)\n            alice_size_after_move, bob_size_after_move = get_alice_bob_sizes_after_move(candies, move, alice_size_after_move, bob_size_after_move)\n        output.append(f\"{move} {alice_size} {bob_size}\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4637,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(a, b, i, j):\n        a[i], b[j] = b[j], a[i]\n\n    def max_sum(a, b, k):\n        n = len(a)\n        a_sum = sum(a)\n        b_sum = sum(b)\n        max_sum = a_sum + b_sum\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    swap(a, b, i, j)\n                    a_sum = sum(a)\n                    b_sum = sum(b)\n                    if a_sum + b_sum > max_sum:\n                        max_sum = a_sum + b_sum\n                    swap(a, b, i, j)\n\n        return max_sum\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n        print(max_sum(a, b, k))\n"
    },
    {
        "number": 4638,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def min_time(x: int, y: int, a: list, b: list, c: int) -> int:\n        if x == y:\n            return 0\n        if x > y:\n            x, y = y, x\n        return c + sum(a[min(x, y) - 1:max(x, y)]) + sum(b[min(x, y) - 1:max(x, y) - 1])\n\n    n, c = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    result = [min_time(i, 1, a, b, c) for i in range(1, n + 1)]\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4639,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def generate_strings(n: int) -> List[str]:\n        result = []\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    result.append('a' * i + 'b' * j + 'a' * k)\n        return result\n\n    def find_kth_string(n: int, k: int) -> str:\n        strings = generate_strings(n)\n        return sorted(strings)[k-1]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        print(find_kth_string(n, k))\n"
    },
    {
        "number": 4640,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_platform_points(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border and y[i] == y[i_platform]:\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border:\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_above(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border and y[i] > y[i_platform]:\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_below(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border and y[i] < y[i_platform]:\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_above_and_below(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border and y[i] != y[i_platform]:\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_above_and_below_and_platform_above(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border and (y[i] > y[i_platform] or y[i] == y[i_platform] and x[i] > x[i_platform]):\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_above_and_below_and_platform_below(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <= right_border or x[i] - k <= x[i_platform] <= x[i] or x[i] <= x[i_platform] + k <= right_border and (y[i] < y[i_platform] or y[i] == y[i_platform] and x[i] < x[i_platform]):\n                points.append(i)\n        return points\n\n    def find_platform_points_with_overlap_and_platform_above_and_below_and_platform_above_and_below(x, y, k):\n        left_border = x\n        right_border = x + k\n        points = []\n        for i in range(n):\n            if left_border <= x[i] <="
    },
    {
        "number": 4641,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q, x = map(int, stdin.split()[0:2])\n    a = []\n    mex = 0\n    for i in range(q):\n        y = int(stdin.split()[i+1])\n        a.append(y)\n        mex = max(mex, y+1)\n        for i in range(len(a)):\n            a[i] = max(a[i]-x, 0)\n        print(mex)\n"
    },
    {
        "number": 4642,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_array(n, x, y):\n        if n == 2:\n            return [x, y]\n        else:\n            mid = (x + y) // 2\n            return [mid] + find_array(n - 1, x, mid) + find_array(n - 1, mid + 1, y)\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for _ in range(t):\n        n, x, y = map(int, stdin.split('\\n')[1].split())\n        array = find_array(n, x, y)\n        output.append(' '.join(map(str, array)))\n    return '\\n'.join(output)\n"
    },
    {
        "number": 4643,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    input_list = input_list[1:]\n    input_list.sort()\n    return ' '.join(map(str, input_list))\n"
    },
    {
        "number": 4644,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_odd_sum(a):\n        return sum(a) % 2 != 0\n\n    t = int(stdin.split(\"\\n\")[0])\n    result = []\n\n    for i in range(1, 2 * t + 1, 2):\n        n = int(stdin.split(\"\\n\")[i].split()[0])\n        a = list(map(int, stdin.split(\"\\n\")[i + 1].split()))\n        result.append(\"YES\" if is_odd_sum(a) else \"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4645,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        n = int(stdin.split('\\n')[i])\n        p = [0] * n\n        p[0] = 1\n        for j in range(1, n):\n            if j % 2 == 0:\n                p[j] = p[j-1] + 2\n            else:\n                p[j] = p[j-1] + 1\n        if p[-1] <= n:\n            p[n-1] = n\n        else:\n            output.append(-1)\n            continue\n        output.append(p)\n    return output\n"
    },
    {
        "number": 4646,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_good(array: list) -> bool:\n        for i in range(len(array)):\n            if (i % 2 == 0 and array[i] % 2 == 1) or (i % 2 == 1 and array[i] % 2 == 0):\n                return False\n        return True\n\n    def swap(array: list, i: int, j: int) -> None:\n        array[i], array[j] = array[j], array[i]\n\n    def min_moves(array: list) -> int:\n        moves = 0\n        for i in range(len(array)):\n            if (i % 2 == 0 and array[i] % 2 == 1) or (i % 2 == 1 and array[i] % 2 == 0):\n                j = i + 1\n                while (j < len(array) and (j % 2 == 0 and array[j] % 2 == 1) or (j % 2 == 1 and array[j] % 2 == 0)):\n                    j += 1\n                if j == len(array):\n                    return -1\n                swap(array, i, j)\n                moves += 1\n        return moves\n\n    def main(stdin: str) -> str:\n        test_cases = int(stdin.split(\"\\n\")[0])\n        output = []\n        for i in range(1, test_cases + 1):\n            n = int(stdin.split(\"\\n\")[i].split()[0])\n            array = list(map(int, stdin.split(\"\\n\")[i].split()[1:]))\n            if is_good(array):\n                output.append(0)\n            else:\n                output.append(min_moves(array))\n        return \"\\n\".join(map(str, output))\n\n    return main(stdin)\n"
    },
    {
        "number": 4647,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(node, parent, color, cnt_w, cnt_b, res):\n        if node == -1:\n            return\n        cnt_w[node] += 1\n        cnt_b[node] += 1 - color[node]\n        res[node] = max(res[node], cnt_w[node] - cnt_b[node])\n        dfs(children[node][0], node, color, cnt_w, cnt_b, res)\n        dfs(children[node][1], node, color, cnt_w, cnt_b, res)\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    color = [0] * n\n    for i in range(n):\n        color[i] = a[i]\n    children = [[] for _ in range(n)]\n    for line in stdin.split('\\n')[2:]:\n        u, v = map(int, line.split())\n        children[u].append(v)\n        children[v].append(u)\n\n    res = [0] * n\n    for i in range(n):\n        cnt_w = [0] * n\n        cnt_b = [0] * n\n        dfs(i, -1, color, cnt_w, cnt_b, res)\n\n    return '\\n'.join(map(str, res))\n"
    },
    {
        "number": 4648,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        n = int(stdin.split('\\n')[i])\n        moves = 0\n        while n != 1:\n            if n % 2 == 0:\n                n //= 2\n            elif n % 6 == 0:\n                n //= 6\n            else:\n                n -= 1\n            moves += 1\n        output.append(moves if n == 1 else -1)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4649,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.readline())\n    result = []\n    for _ in range(q):\n        n, k = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n        count = 0\n        for i in range(n - k + 1):\n            if s[i:i+k] in \"RGBRGBRGB\":\n                count = max(count, i)\n        result.append(count)\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 4650,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (a[i] + a[j]) % 3 == 0:\n                    count += 1\n        result.append(count)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4651,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def is_permutation(arr):\n        return len(arr) == len(set(arr))\n\n    def lexicographically_minimum(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return arr\n        return arr\n\n    def perform_operations(arr, operations):\n        for i, j in operations:\n            swap(arr, i, j)\n        return arr\n\n    def find_minimum_permutation(arr):\n        operations = []\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                operations.append((i, i + 1))\n        return perform_operations(arr, operations)\n\n    q = int(stdin.readline())\n    for _ in range(q):\n        n = int(stdin.readline())\n        arr = list(map(int, stdin.readline().split()))\n        if not is_permutation(arr):\n            print(\"Invalid permutation\")\n        else:\n            minimum_permutation = find_minimum_permutation(arr)\n            print(\" \".join(map(str, minimum_permutation)))\n"
    },
    {
        "number": 4652,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split(\"\\n\")[0])\n    result = []\n\n    for _ in range(q):\n        n = int(stdin.split(\"\\n\")[1])\n        p = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n        if n % 2 == 0:\n            result.append(\"YES\")\n        else:\n            for i in range(2, n):\n                if p[i] - p[i - 1] != 1:\n                    result.append(\"NO\")\n                    break\n            else:\n                result.append(\"YES\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 4653,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_satisfied(a, b, k):\n        return (b - a) <= 1 and k // 2 >= k - b + a\n\n    def count_kids_with_a_plus_one(k):\n        return k // 2\n\n    t = int(stdin)\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = n // k\n        b = n - a\n        result.append(a if is_satisfied(a, b, k) else b)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4654,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    def is_odd(n: int) -> bool:\n        return not is_even(n)\n\n    def find_sum(n: int, k: int) -> str:\n        if k == 1:\n            return \"YES 1\" if n == 1 else \"NO\"\n\n        if is_even(n):\n            a = n // k\n            return f\"YES {a} {a}\" if a > 0 else \"NO\"\n        else:\n            a = (n + 1) // k\n            return f\"YES {a} {a}\" if a > 0 else \"NO\"\n\n    t = int(stdin.split(\"\\n\")[0])\n    output = []\n\n    for i in range(1, t + 1):\n        n, k = map(int, stdin.split(\"\\n\")[i].split())\n        output.append(find_sum(n, k))\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4655,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    result = []\n\n    for query in queries:\n        a, b, c = map(int, query.split())\n        max_candies = max(a, b, c)\n        min_candies = min(a, b, c)\n\n        if max_candies == a:\n            alice_candies = a\n            bob_candies = b + c\n        elif max_candies == b:\n            alice_candies = a + c\n            bob_candies = b\n        else:\n            alice_candies = a + b\n            bob_candies = c\n\n        if alice_candies > bob_candies:\n            alice_candies = bob_candies\n        elif bob_candies > alice_candies:\n            bob_candies = alice_candies\n\n        result.append(alice_candies)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4656,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_beautiful(necklace: str, k: int) -> bool:\n        for i in range(k):\n            if necklace[i:] + necklace[:i] != necklace:\n                return False\n        return True\n\n    def count_colors(necklace: str) -> int:\n        return len(set(necklace))\n\n    def max_beautiful_length(necklaces: List[str], k: int) -> int:\n        max_length = 0\n        for necklace in necklaces:\n            if is_beautiful(necklace, k):\n                max_length = max(max_length, len(necklace))\n        return max_length\n\n    def process_test_case(n: int, k: int, s: str) -> str:\n        necklaces = [\"\".join(sorted(s[i:i+k])) for i in range(len(s) - k + 1)]\n        max_length = max_beautiful_length(necklaces, k)\n        return str(max_length)\n\n    def process_test_cases(test_cases: List[str]) -> List[str]:\n        return [process_test_case(*map(int, test_case.split())) for test_case in test_cases]\n\n    t = int(stdin.readline())\n    test_cases = [stdin.readline().strip() for _ in range(t)]\n    test_cases = [test_case.split() for test_case in test_cases]\n    test_cases = [list(map(int, test_case)) for test_case in test_cases]\n    test_cases = [list(map(str, test_case)) for test_case in test_cases]\n\n    results = process_test_cases(test_cases)\n    return \"\\n\".join(results)\n"
    },
    {
        "number": 4657,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.readline())\n    for _ in range(q):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        # Check if it's possible to divide the array into k subsegments with odd sums\n        if n % k != 0:\n            print(\"NO\")\n            continue\n\n        # Calculate the sum of each subsegment\n        subsegment_sums = [0] * k\n        for i in range(n):\n            subsegment_sums[i % k] += a[i]\n\n        # Check if each subsegment has an odd sum\n        if any(sum % 2 == 0 for sum in subsegment_sums):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            # Calculate the right borders of each subsegment\n            r = [0] * k\n            for i in range(n):\n                r[i % k] = max(r[i % k], a[i])\n\n            # Print the division\n            print(\" \".join(map(str, r)))\n"
    },
    {
        "number": 4658,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Convert the binary string to an integer\n    num = int(stdin, 2)\n    \n    # Reverse the bits of the integer\n    reversed_num = 0\n    for i in range(32):\n        reversed_num <<= 1\n        reversed_num |= (num >> i) & 1\n    \n    # Convert the reversed integer back to a binary string\n    reversed_binary = format(reversed_num, '032b')\n    \n    return reversed_binary "
    },
    {
        "number": 4659,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    numRows = int(input())\n    pascal_triangle = []\n\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        if i > 0:\n            for j in range(1, i):\n                row[j] = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n        pascal_triangle.append(row)\n\n    for row in pascal_triangle:\n        print(\" \".join(str(num) for num in row))\n"
    },
    {
        "number": 4660,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_email(email: str) -> bool:\n        if \"@\" not in email:\n            return False\n        username, website = email.split(\"@\")\n        website_name, extension = website.split(\".\")\n        if not username.replace(\"_\", \"\").replace(\"-\", \"\").isalnum():\n            return False\n        if not website_name.isalnum():\n            return False\n        if len(extension) > 3:\n            return False\n        return True\n\n    N = int(stdin.splitlines()[0])\n    email_list = stdin.splitlines()[1:]\n    valid_emails = list(filter(is_valid_email, email_list))\n    valid_emails.sort()\n    return valid_emails\n"
    },
    {
        "number": 4661,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    fib = [0, 1]\n    for i in range(2, N):\n        fib.append(fib[i-1] + fib[i-2])\n    fib_cubed = list(map(lambda x: x**3, fib))\n    return str(fib_cubed)"
    },
    {
        "number": 4662,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    n = int(stdin.split('\\n')[0])\n    xml = stdin.split('\\n')[1:]\n\n    # Initialize variables\n    max_level = 0\n    level = 0\n\n    # Iterate through each line of the XML document\n    for line in xml:\n        # Increment level for each opening tag\n        level += line.count('<')\n        # Decrement level for each closing tag\n        level -= line.count('/>') + line.count('</')\n        # Update max_level if current level is greater\n        max_level = max(max_level, level)\n\n    # Return the maximum level of nesting\n    return str(max_level) "
    },
    {
        "number": 4663,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(input())\n    for i in range(N):\n        number = input()\n        if len(number) != 10 or not (number[0] == '7' or number[0] == '8' or number[0] == '9'):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n"
    },
    {
        "number": 4664,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split(\"\\n\")\n    M = int(input_list[0])\n    M_set = set(map(int, input_list[1].split()))\n    N = int(input_list[2])\n    N_set = set(map(int, input_list[3].split()))\n\n    symmetric_difference = M_set.symmetric_difference(N_set)\n    symmetric_difference = sorted(symmetric_difference)\n\n    result = \"\\n\".join(str(x) for x in symmetric_difference)\n\n    return result\n"
    },
    {
        "number": 4665,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    from collections import namedtuple\n    import re\n\n    # Read input\n    lines = stdin.split('\\n')\n    num_students = int(lines[0])\n    columns = lines[1].split(',')\n    data = lines[2:]\n\n    # Create namedtuple for each row\n    Row = namedtuple('Row', columns)\n    rows = [Row(*re.split(',\\s*', row)) for row in data]\n\n    # Calculate average marks\n    total_marks = sum(row.MARKS for row in rows)\n    average_marks = round(total_marks / num_students, 2)\n\n    return str(average_marks)"
    },
    {
        "number": 4666,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    if n % 2 != 0:\n        return \"Weird\"\n    elif 2 <= n <= 5:\n        return \"Not Weird\"\n    elif 6 <= n <= 20:\n        return \"Weird\"\n    else:\n        return \"Not Weird\"\n"
    },
    {
        "number": 4667,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    xml = ''.join(lines[1:])\n    score = 0\n\n    def parse_element(element: str) -> int:\n        start = element.find('<') + 1\n        end = element.find('>')\n        tag = element[start:end]\n        attributes = tag.count(' ')\n        return attributes\n\n    def parse_xml(xml: str) -> int:\n        score = 0\n        while xml:\n            start = xml.find('<')\n            end = xml.find('>')\n            if start == -1 or end == -1:\n                break\n            element = xml[start:end + 1]\n            xml = xml[end + 1:]\n            score += parse_element(element)\n        return score\n\n    score = parse_xml(xml)\n    return str(score) "
    },
    {
        "number": 4668,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    import math\n\n    def cross_product(a, b):\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]\n\n    def dot_product(a, b):\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n    def magnitude(a):\n        return math.sqrt(a[0] ** 2 + a[1] ** 2 + a[2] ** 2)\n\n    def angle_between_planes(a, b, c, d):\n        x = cross_product(a, b)\n        y = cross_product(b, c)\n        dot = dot_product(x, y)\n        mag_x = magnitude(x)\n        mag_y = magnitude(y)\n        cos_phi = dot / (mag_x * mag_y)\n        phi = math.degrees(math.acos(cos_phi))\n        return round(phi, 2)\n\n    def parse_input(input_str: str) -> list:\n        return [float(x) for x in input_str.split()]\n\n    A, B, C, D = parse_input(stdin)\n    phi = angle_between_planes([0, 0, 0], A, B, C)\n    return str(phi)\n"
    },
    {
        "number": 4669,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    words = input_list[1].split()\n\n    def score_words(words):\n        score = 0\n        for word in words:\n            vowels = 0\n            for letter in word:\n                if letter in ['a', 'e', 'i', 'o', 'u', 'y']:\n                    vowels += 1\n            if vowels % 2 == 0:\n                score += 2\n            else:\n                score += 1\n        return score\n\n    result = score_words(words)\n    return str(result)\n"
    },
    {
        "number": 4670,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    roman_numeral_regex = r\"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\"\n    if re.match(roman_numeral_regex, stdin):\n        return \"True\"\n    else:\n        return \"False\""
    },
    {
        "number": 4671,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    numbers = stdin.split('\\n')[1:]\n\n    def clean_number(number: str) -> str:\n        return ''.join(filter(str.isdigit, number))\n\n    def add_prefix(number: str) -> str:\n        return '+91' + number if len(number) == 10 else number\n\n    def sort_numbers(numbers: list) -> list:\n        return sorted(numbers, key=lambda x: int(clean_number(x)))\n\n    cleaned_numbers = [add_prefix(clean_number(number)) for number in numbers]\n    sorted_numbers = sort_numbers(cleaned_numbers)\n\n    return '\\n'.join(f\"+91 {number[:4]} {number[4:8]} {number[8:]}\" for number in sorted_numbers)\n"
    },
    {
        "number": 4672,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    student_records = {}\n    for i in range(1, n+1):\n        name, *marks = input_list[i].split()\n        marks = [int(mark) for mark in marks]\n        student_records[name] = marks\n    \n    query_name = input_list[-1]\n    marks_array = student_records[query_name]\n    average = sum(marks_array) / len(marks_array)\n    return f\"{average:.2f}\""
    },
    {
        "number": 4673,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return sorted(result, key=lambda x: (x[2], x[3]))\n        return wrapper\n\n    @decorator\n    def read_input(stdin: str) -> list:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        people = []\n        for line in lines[1:]:\n            first_name, last_name, age, sex = line.split()\n            people.append((first_name, last_name, int(age), sex))\n        return people\n\n    @decorator\n    def print_names(people: list) -> None:\n        for first_name, last_name, age, sex in people:\n            print(f\"{first_name} {last_name} ({age})\")\n\n    people = read_input(stdin)\n    print_names(people)\n"
    },
    {
        "number": 4674,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, y, z, n = map(int, stdin.split())\n    result = [(i, j, k) for i in range(x+1) for j in range(y+1) for k in range(z+1) if i+j+k != n]\n    result.sort()\n    return str(result)\n"
    },
    {
        "number": 4675,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    complex_num1, complex_num2 = stdin.split()\n    real1, imag1 = complex_num1.split('+')\n    real2, imag2 = complex_num2.split('+')\n\n    real1, imag1, real2, imag2 = float(real1), float(imag1), float(real2), float(imag2)\n\n    # Addition\n    real_add = real1 + real2\n    imag_add = imag1 + imag2\n\n    # Subtraction\n    real_sub = real1 - real2\n    imag_sub = imag1 - imag2\n\n    # Multiplication\n    real_mul = (real1 * real2) - (imag1 * imag2)\n    imag_mul = (real1 * imag2) + (imag1 * real2)\n\n    # Division\n    denominator = (real2 ** 2) + (imag2 ** 2)\n    real_div = ((real1 * real2) + (imag1 * imag2)) / denominator\n    imag_div = ((imag1 * real2) - (real1 * imag2)) / denominator\n\n    # Modulus\n    mod_num1 = (real1 ** 2) + (imag1 ** 2)\n    mod_num2 = (real2 ** 2) + (imag2 ** 2)\n\n    # Output\n    output = f\"{real1:.2f}+{imag1:.2f}i\\n{real_add:.2f}+{imag_add:.2f}i\\n{real_sub:.2f}+{imag_sub:.2f}i\\n{real_mul:.2f}+{imag_mul:.2f}i\\n{real_div:.2f}+{imag_div:.2f}i\\n{mod_num1:.2f}\\n{mod_num2:.2f}\"\n\n    return output "
    },
    {
        "number": 4676,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    O, E = stdin.split('\\n')\n    password = ''\n    for i in range(len(O)):\n        if i % 2 == 0:\n            password += O[i]\n        else:\n            password += E[i]\n    return password\n"
    },
    {
        "number": 4677,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    result = \"\"\n    for char in s:\n        if char == '0':\n            result += '0'\n        elif char == '1':\n            result += '1'\n        elif char == 'B':\n            if result:\n                result = result[:-1]\n    return result\n"
    },
    {
        "number": 4678,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *A = map(int, stdin.split())\n    A = sorted(A)\n    stool_height = 0\n    for i in range(N):\n        if A[i] > stool_height:\n            stool_height = A[i]\n    return stool_height\n"
    },
    {
        "number": 4679,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S_A, S_B, S_C = stdin.split('\\n')\n\n    def get_next_player(current_player, discarded_card):\n        if current_player == 'Alice':\n            if discarded_card == 'a':\n                return 'Bob'\n            elif discarded_card == 'b':\n                return 'Charlie'\n            else:\n                return 'Alice'\n        elif current_player == 'Bob':\n            if discarded_card == 'a':\n                return 'Charlie'\n            elif discarded_card == 'b':\n                return 'Alice'\n            else:\n                return 'Bob'\n        else:\n            if discarded_card == 'a':\n                return 'Alice'\n            elif discarded_card == 'b':\n                return 'Bob'\n            else:\n                return 'Charlie'\n\n    def play_game(S_A, S_B, S_C):\n        current_player = 'Alice'\n        while True:\n            if len(S_A) == 0:\n                return current_player\n            discarded_card = S_A[-1]\n            S_A = S_A[:-1]\n            current_player = get_next_player(current_player, discarded_card)\n\n    winner = play_game(S_A, S_B, S_C)\n\n    if winner == 'Alice':\n        return 'A'\n    elif winner == 'Bob':\n        return 'B'\n    else:\n        return 'C'\n"
    },
    {
        "number": 4680,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C = map(int, stdin.split())\n    if A + B + C == 15 and A >= 1 and B >= 1 and C >= 1 and A <= 10 and B <= 10 and C <= 10:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4681,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    if 1 <= N <= 86:\n        if N == 1:\n            return \"2\"\n        elif N == 2:\n            return \"1\"\n        else:\n            prev_prev_lucas = 2\n            prev_lucas = 1\n            for i in range(3, N + 1):\n                lucas = prev_prev_lucas + prev_lucas\n                prev_prev_lucas = prev_lucas\n                prev_lucas = lucas\n            return str(lucas)\n    else:\n        return \"Invalid input. N should be between 1 and 86.\"\n"
    },
    {
        "number": 4682,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, h = map(int, stdin.split())\n    area = ((a + b) / 2) * h\n    return str(area)\n"
    },
    {
        "number": 4683,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    MOD = 10**9 + 7\n    N, *A = map(int, stdin.split())\n    A = list(A)\n    total_sum = 0\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += A[i] * A[j]\n            total_sum %= MOD\n\n    return total_sum\n"
    },
    {
        "number": 4684,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    r, g, b = map(int, stdin.split())\n    number = int(f\"{r}{g}{b}\")\n    if number % 4 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4685,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, K = map(int, stdin.split())\n    max_sum = 0\n\n    for _ in range(K):\n        max_sum = max(max_sum, A, B, C)\n        A, B, C = 2 * A, 2 * B, 2 * C\n\n    return max_sum\n"
    },
    {
        "number": 4686,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    w = stdin.strip()\n    count = [0] * 26\n\n    for char in w:\n        count[ord(char) - ord('a')] += 1\n\n    for num in count:\n        if num % 2 != 0:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 4687,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data[0].split())\n    array = [0] * (K + 1)\n    count = [0] * (K + 1)\n\n    for i in range(1, N + 1):\n        a, b = map(int, input_data[i].split())\n        array[a] += b\n\n    for i in range(1, K + 1):\n        count[i] = array[i] + count[i - 1]\n\n    return count[K]\n"
    },
    {
        "number": 4688,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    N = int(input_data[0])\n    K = int(input_data[1])\n\n    # Calculate the number of possible ways to paint the balls\n    result = 1\n    for i in range(1, N + 1):\n        result *= K - i + 1\n\n    return str(result)\n"
    },
    {
        "number": 4689,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    K = int(input_data[0])\n    N = int(input_data[1])\n    A = list(map(int, input_data[2].split()))\n\n    # Calculate the total distance around the pond\n    total_distance = 0\n    for i in range(N):\n        total_distance += A[i]\n\n    # Calculate the distance needed to travel around the pond\n    distance_around_pond = K * 2 - total_distance\n\n    # Calculate the minimum distance needed to visit all houses\n    min_distance = distance_around_pond / (N - 1)\n\n    return min_distance\n"
    },
    {
        "number": 4690,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split())\n\n    area1 = A * B\n    area2 = C * D\n\n    if area1 > area2:\n        return str(area1)\n    elif area1 < area2:\n        return str(area2)\n    else:\n        return str(area1)\n"
    },
    {
        "number": 4691,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = stdin.split(\"\\n\")\n    N = int(N)\n    C = [0, 0, 0, 0]\n    for i in range(N):\n        if S[i] == \"AC\":\n            C[0] += 1\n        elif S[i] == \"WA\":\n            C[1] += 1\n        elif S[i] == \"TLE\":\n            C[2] += 1\n        elif S[i] == \"RE\":\n            C[3] += 1\n    return f\"AC x {C[0]}\\nWA x {C[1]}\\nTLE x {C[2]}\\nRE x {C[3]}\" "
    },
    {
        "number": 4692,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    M = int(stdin)\n    if 1 <= M <= 23:\n        hours_left = 24 - M\n        if hours_left == 0:\n            print(\"It's already M o'clock! Happy New Year!\")\n        else:\n            print(hours_left)\n    else:\n        print(\"Invalid input. M must be between 1 and 23.\")\n"
    },
    {
        "number": 4693,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    result = A + B\n    if result >= 10:\n        return \"error\"\n    else:\n        return result\n"
    },
    {
        "number": 4694,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, *a = map(int, stdin.split())\n    a.sort()\n    min_distance = float('inf')\n    for i in range(N):\n        distance = a[i] + (N-1-i)*(1000-a[i])\n        min_distance = min(min_distance, distance)\n    return min_distance\n"
    },
    {
        "number": 4695,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, y = map(int, stdin.split())\n\n    if x in range(1, 5) and y in range(5, 10):\n        return \"Yes\"\n    elif x in range(5, 10) and y in range(10, 13):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 4696,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    product = a * b\n    if product % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"
    },
    {
        "number": 4697,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    return (N * (N - 1)) // 2\n"
    },
    {
        "number": 4698,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def calculate_time(problems, drinks):\n        result = []\n        for drink in range(1, M + 1):\n            time = 0\n            for problem in range(1, N + 1):\n                if problem in drinks[drink]:\n                    time += X[problem]\n                else:\n                    time += T[problem]\n            result.append(time)\n        return result\n\n    N, M = map(int, stdin.split()[:2])\n    T = list(map(int, stdin.split()[2:N + 2]))\n    P = [list(map(int, stdin.split()[i:i + 2])) for i in range(N + 2, N + 2 * M + 2, 2)]\n    X = [list(map(int, stdin.split()[i:i + 2])) for i in range(N + 2 * M + 2, len(stdin.split()) + 2, 2)]\n\n    result = calculate_time(T, P)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4699,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    K = int(input_list[1])\n    D = list(map(int, input_list[2:]))\n\n    # Check if the set of disliked digits is not equal to {1, 2, 3, 4, 5, 6, 7, 8, 9}\n    if set(D) == set(range(1, 10)):\n        return \"Iroha will not hand any money to the cashier.\"\n\n    # Find the minimum amount of money that Iroha will hand to the cashier\n    min_amount = N\n    for i in range(1, N + 1):\n        if all(digit not in str(i) for digit in D):\n            min_amount = i\n            break\n\n    return str(min_amount)\n"
    },
    {
        "number": 4700,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_good_observatories(elevations, roads):\n        good_observatories = set()\n        for i in range(1, N + 1):\n            good = True\n            for j in range(1, M + 1):\n                if i in roads[j]:\n                    good = False\n                    break\n            if good:\n                good_observatories.add(i)\n        return good_observatories\n\n    def can_reach(i, j, roads):\n        visited = set()\n        queue = [i]\n        while queue:\n            node = queue.pop(0)\n            if node == j:\n                return True\n            for neighbor in roads[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        return False\n\n    N, M = map(int, stdin.split()[:2])\n    elevations = list(map(int, stdin.split()[2:N + 2]))\n    roads = [set(map(int, stdin.split()[i].split(','))) for i in range(N + 2, N + 2 + M)]\n\n    good_observatories = find_good_observatories(elevations, roads)\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j and can_reach(i, j, roads):\n                good_observatories.discard(i)\n                break\n\n    return len(good_observatories)\n"
    },
    {
        "number": 4701,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n    min_value = 1\n    for _ in range(N):\n        min_value = min_value * 2 + K\n    return min_value\n"
    },
    {
        "number": 4702,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x = int(stdin)\n    if x == 0:\n        return \"1\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 4703,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    n = len(S)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][i] = 1\n\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            for k in range(i, j):\n                if S[k] == '+':\n                    continue\n                dp[i][j] += dp[i][k] * dp[k + 1][j]\n\n    return sum(dp[0][i] for i in range(n))\n"
    },
    {
        "number": 4704,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Snuke takes the first card\n    snuke_cards = [a[0]]\n    raccoon_cards = a[1:]\n\n    # Calculate the sum of the integers on Snuke's cards and Raccoon's cards\n    x = sum(snuke_cards)\n    y = sum(raccoon_cards)\n\n    # Calculate the minimum possible value of |x-y|\n    min_diff = min(abs(x - y), abs(x - (y + 1)), abs(x - (y - 1)))\n\n    return str(min_diff)\n"
    },
    {
        "number": 4705,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.split()[0])\n    x = 800 * N\n    y = (N // 15) * 200\n    return x - y\n"
    },
    {
        "number": 4706,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    grid = [list(stdin[i:i+3]) for i in range(0, len(stdin), 3)]\n    diagonal = [grid[i][i] for i in range(3)]\n    return ''.join(diagonal)\n"
    },
    {
        "number": 4707,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s1, s2, s3 = map(int, stdin)\n    count = 0\n    if s1 == 1:\n        count += 1\n    if s2 == 1:\n        count += 1\n    if s3 == 1:\n        count += 1\n    return count\n"
    },
    {
        "number": 4708,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K, X, Y = map(int, stdin.split())\n    total_fee = 0\n    if N <= K:\n        total_fee = N * X\n    else:\n        total_fee = K * X + (N - K) * Y\n    return total_fee\n"
    },
    {
        "number": 4709,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, op, B = map(int, stdin.split())\n    if op == '+':\n        return A + B\n    elif op == '-':\n        return A - B\n    else:\n        return \"Invalid operator\"\n"
    },
    {
        "number": 4710,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x = int(stdin)\n    if x < 1200:\n        return \"ABC\"\n    else:\n        return \"ARC\"\n"
    },
    {
        "number": 4711,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n    min_price = min(a, b, c)\n    return min_price * 2\n"
    },
    {
        "number": 4712,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    H, W = map(int, stdin.split())\n    image = []\n    for _ in range(H):\n        image.append(list(stdin.readline().strip()))\n\n    # Create box\n    box = \"#\" * (W + 2) + \"\\n\"\n    for _ in range(H):\n        box += \"#\" + \"\".join(image[_]) + \"#\\n\"\n    box += \"#\" * (W + 2)\n\n    return box"
    },
    {
        "number": 4713,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, S = map(int, input().split())\n    x = 0\n    max_x = 0\n\n    for i in range(N):\n        if S[i] == 'I':\n            x += 1\n        else:\n            x -= 1\n        max_x = max(max_x, x)\n\n    return max_x\n"
    },
    {
        "number": 4714,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    count = 0\n\n    for num in range(A, B + 1):\n        if str(num) == str(num)[::-1]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 4715,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n    colors = set()\n    colors.add(a)\n    colors.add(b)\n    colors.add(c)\n    print(len(colors))\n"
    },
    {
        "number": 4716,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split()[0:2])\n    sticks = list(map(int, stdin.split()[2:]))\n\n    sticks.sort(reverse=True)\n\n    max_length = 0\n    for i in range(K):\n        max_length += sticks[i]\n\n    return max_length\n"
    },
    {
        "number": 4717,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, a, b = map(int, stdin.split())\n\n    distance_a = abs(x - a)\n    distance_b = abs(x - b)\n\n    if distance_a < distance_b:\n        return \"A\"\n    else:\n        return \"B\"\n"
    },
    {
        "number": 4718,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S = stdin.strip()\n    year = \"2018\"\n    new_date = year + S[4:]\n    print(new_date)\n"
    },
    {
        "number": 4719,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(headline: str, target: str) -> bool:\n        headline_chars = sorted(headline)\n        target_chars = sorted(target)\n        return all(c in headline_chars for c in target_chars)\n\n    def longest_valid_substring(headline: str, target: str) -> str:\n        headline_chars = sorted(headline)\n        target_chars = sorted(target)\n        start, end = 0, 0\n        max_length = 0\n        max_substring = \"\"\n\n        while end < len(headline):\n            if is_valid(headline[start:end + 1], target):\n                length = end - start + 1\n                if length > max_length:\n                    max_length = length\n                    max_substring = headline[start:end + 1]\n                end += 1\n            else:\n                start += 1\n                end = start\n\n        return max_substring\n\n    n = int(stdin.split(\"\\n\")[0])\n    S = stdin.split(\"\\n\")[1:]\n    target = \"\"\n    for s in S:\n        target += s\n\n    max_substring = \"\"\n    for s in S:\n        substring = longest_valid_substring(target, s)\n        if len(substring) > len(max_substring):\n            max_substring = substring\n\n    return max_substring\n"
    },
    {
        "number": 4720,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    N = int(stdin.split()[0])\n    seats = [list(map(int, input().split())) for _ in range(N)]\n\n    # Initialize variables\n    occupied_seats = set()\n    total_seats = 0\n\n    # Iterate through each group of seats\n    for l, r in seats:\n        # Add the occupied seats to the set\n        occupied_seats.update(range(l, r + 1))\n\n    # Calculate the total number of occupied seats\n    total_seats = len(occupied_seats)\n\n    # Print the result\n    return total_seats\n"
    },
    {
        "number": 4721,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split())\n    return (n-1) * (m-1) "
    },
    {
        "number": 4722,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B = map(int, stdin.split())\n    if A == B:\n        return \"Possible\"\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 4723,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, T = stdin.split('\\n')\n    S = S.replace('?', 'a')\n    T = T.replace('?', 'a')\n    if T in S:\n        return S\n    else:\n        return \"UNRESTORABLE\"\n"
    },
    {
        "number": 4724,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    R = int(input_list[0])\n    G = int(input_list[1])\n\n    performance = (R + G) / 2\n\n    print(performance)\n"
    },
    {
        "number": 4725,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    string = stdin.strip()\n    simplicity = len(set(string))\n    if simplicity == 1 or simplicity == 2:\n        return 0\n    else:\n        min_erase = float('inf')\n        for i in range(len(string)):\n            new_string = string[:i] + string[i+1:]\n            new_simplicity = len(set(new_string))\n            if new_simplicity == 1 or new_simplicity == 2:\n                min_erase = min(min_erase, i+1)\n        return min_erase "
    },
    {
        "number": 4726,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    m, n, t = map(int, stdin.split())\n    if t == 1:\n        if n * n * n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 2:\n        if n * 2**n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 3:\n        if n * n * n * n * n * n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 4:\n        if n * n * n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 5:\n        if n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 6:\n        if n * n * n * n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n    elif t == 7:\n        if n * n * n <= m:\n            return \"AC\"\n        else:\n            return \"TLE\"\n"
    },
    {
        "number": 4727,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_lines = stdin.split('\\n')\n    grid = [[int(x) for x in input_lines[i].split()] for i in range(4)]\n    move = int(input_lines[4])\n\n    def merge(line):\n        merged = [0] * 4\n        for i in range(4):\n            if line[i] == 0:\n                continue\n            j = i\n            while j > 0 and merged[j - 1] and line[j - 1] == line[j]:\n                merged[j - 1] += line[j]\n                line[j] = 0\n                j -= 1\n            if j == i:\n                merged[j] = line[j]\n        return merged\n\n    def move_line(line, direction):\n        if direction == 0:\n            return [line[3], line[2], line[1], line[0]]\n        elif direction == 1:\n            return [line[0], line[1], line[2], line[3]]\n        elif direction == 2:\n            return [line[1], line[2], line[3], line[0]]\n        else:\n            return [line[2], line[3], line[0], line[1]]\n\n    def move_grid(grid, direction):\n        if direction == 0:\n            return [move_line(grid[i], 0) for i in range(4)]\n        elif direction == 1:\n            return [move_line(grid[i], 1) for i in range(4)]\n        elif direction == 2:\n            return [move_line(grid[i], 2) for i in range(4)]\n        else:\n            return [move_line(grid[i], 3) for i in range(4)]\n\n    def merge_grid(grid):\n        return [merge(line) for line in grid]\n\n    def move_and_merge(grid, direction):\n        new_grid = move_grid(grid, direction)\n        merged_grid = merge_grid(new_grid)\n        return merged_grid\n\n    if move == 0:\n        new_grid = move_and_merge(grid, 0)\n    elif move == 1:\n        new_grid = move_and_merge(grid, 1)\n    elif move == 2:\n        new_grid = move_and_merge(grid, 2)\n    else:\n        new_grid = move_and_merge(grid, 3)\n\n    output = '\\n'.join([' '.join(str(x) for x in line) for line in new_grid])\n    return output"
    },
    {
        "number": 4728,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_molecule, k, desired_output_molecule = stdin.split('\\n')\n    input_molecule = input_molecule.split('+')[0]\n    desired_output_molecule = desired_output_molecule.split('+')[0]\n\n    input_atoms = {}\n    for atom in input_molecule:\n        if atom.isalpha():\n            if atom not in input_atoms:\n                input_atoms[atom] = 1\n            else:\n                input_atoms[atom] += 1\n\n    desired_output_atoms = {}\n    for atom in desired_output_molecule:\n        if atom.isalpha():\n            if atom not in desired_output_atoms:\n                desired_output_atoms[atom] = 1\n            else:\n                desired_output_atoms[atom] += 1\n\n    output_atoms = {}\n    for atom in desired_output_atoms:\n        if atom in input_atoms:\n            output_atoms[atom] = min(desired_output_atoms[atom], input_atoms[atom])\n        else:\n            output_atoms[atom] = 0\n\n    for atom in input_atoms:\n        if atom not in desired_output_atoms:\n            output_atoms[atom] = input_atoms[atom]\n\n    n = sum(output_atoms.values())\n    return str(n) "
    },
    {
        "number": 4729,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    password, message = stdin.split()\n    password_set = set(password)\n    message_set = set(message)\n    password_set.discard(' ')\n    message_set.discard(' ')\n\n    if len(password_set) != len(password):\n        return \"FAIL\"\n\n    if len(message_set) != len(message):\n        return \"FAIL\"\n\n    if not password_set.issubset(message_set):\n        return \"FAIL\"\n\n    password_set = set(password)\n    message_set = set(message)\n    password_set.discard(' ')\n    message_set.discard(' ')\n\n    for char in password_set:\n        if char not in message_set:\n            return \"FAIL\"\n        message_set.remove(char)\n\n    return \"PASS\"\n"
    },
    {
        "number": 4730,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    lines = stdin.split('\\n')\n    L = int(lines[0])\n    program = lines[1]\n\n    stack = []\n    for i, c in enumerate(program):\n        if c in '([{':\n            stack.append(c)\n        elif c in ')]}':\n            if not stack:\n                return c, i\n            elif '([{'.index(stack.pop()) != ')]}'.index(c):\n                return c, i\n    if stack:\n        return stack.pop(), len(program)\n    else:\n        return 'ok so far'\n"
    },
    {
        "number": 4731,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    words = input_list[1:]\n    last_letter = words[0][-1]\n    player = 1\n    called_words = set()\n    for word in words:\n        if word[0] != last_letter:\n            return f\"Player {player} lost\"\n        if word in called_words:\n            return f\"Player {player} lost\"\n        called_words.add(word)\n        last_letter = word[-1]\n        player = 3 - player\n    return \"Fair Game\" "
    },
    {
        "number": 4732,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    A = int(input_list[0])\n    operator = input_list[1]\n    B = int(input_list[2])\n\n    if operator == '+':\n        result = A + B\n    elif operator == '*':\n        result = A * B\n    else:\n        raise ValueError(\"Invalid operator\")\n\n    return str(result)\n"
    },
    {
        "number": 4733,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def perfect_shuffle(n: int, shuffle_type: str) -> int:\n        if shuffle_type == \"in\":\n            return n // 2\n        elif shuffle_type == \"out\":\n            return n // 2 + 1\n        else:\n            raise ValueError(\"Invalid shuffle type\")\n\n    def shuffle_deck(n: int, shuffle_type: str) -> str:\n        if shuffle_type == \"in\":\n            return \"\".join(reversed(deck))\n        elif shuffle_type == \"out\":\n            return deck\n        else:\n            raise ValueError(\"Invalid shuffle type\")\n\n    case_number, shuffle_type = stdin.strip().split()\n    n = int(case_number)\n    shuffle_count = perfect_shuffle(n, shuffle_type)\n    deck = \"\".join(chr(i + 65) for i in range(n))\n    for _ in range(shuffle_count):\n        deck = shuffle_deck(n, shuffle_type)\n    return f\"Case {case_number}: {shuffle_count}\"\n"
    },
    {
        "number": 4734,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.split()\n    Y = input_str[0]\n    P = input_str[1]\n\n    if Y[-1] == 'e':\n        return Y + 'x' + P\n    elif Y[-1] in 'aeiou':\n        return Y[:-1] + 'ex' + P\n    else:\n        return Y + 'ex' + P\n"
    },
    {
        "number": 4735,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    year = int(stdin)\n    if year % 26 == 0:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 4736,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def count_ascending_sequences(n: int) -> int:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 1\n        else:\n            return count_ascending_sequences(n - 1) + count_ascending_sequences(n - 2)\n\n    def count_ascending_sequences_with_cards(n: int, k: int) -> int:\n        if k == 1:\n            return 1\n        elif k == 2:\n            return n\n        else:\n            return count_ascending_sequences_with_cards(n, k - 1) + count_ascending_sequences_with_cards(n - 1, k - 1)\n\n    lines = stdin.split('\\n')\n    n_list = list(map(int, lines[0].split()))\n    k = int(lines[1])\n\n    total_count = 0\n    for n in n_list:\n        total_count += count_ascending_sequences_with_cards(n, k)\n\n    return str(total_count)\n"
    },
    {
        "number": 4737,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, p = map(int, input_data[0].split())\n    problem_estimations = list(map(int, input_data[1].split()))\n\n    # Sort the problem estimations in ascending order\n    problem_estimations.sort()\n\n    # Initialize the number of accepted problems and the penalty time\n    num_accepted = 0\n    penalty_time = 0\n\n    # Iterate through the problem estimations\n    for i in range(N):\n        # If the current problem is the one we want to solve first\n        if i == p:\n            # Add the estimation to the penalty time\n            penalty_time += problem_estimations[i]\n        else:\n            # If the current problem is not the one we want to solve first, add its estimation to the penalty time\n            penalty_time += problem_estimations[i]\n            # If the current problem is accepted, increment the number of accepted problems\n            if problem_estimations[i] <= 300:\n                num_accepted += 1\n\n    # Print the number of accepted problems and the penalty time\n    return f\"{num_accepted} {penalty_time}\" "
    },
    {
        "number": 4738,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s = stdin.strip()\n    k = 1\n    while k <= len(s) // 2 and s[k:] != s[:-k]:\n        k += 1\n    return k\n"
    },
    {
        "number": 4739,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    M, N = map(int, input_data[0].split())\n    T = list(map(int, input_data[1].split()))\n    X = list(map(int, input_data[2].split()))\n\n    # Calculate the time difference between each consecutive pair of milestones\n    time_diff = [X[i+1] - X[i] for i in range(len(X)-1)]\n\n    # Calculate the distance between each consecutive pair of milestones\n    distance_diff = [T[i+1] - T[i] for i in range(len(T)-1)]\n\n    # Calculate the possible speeds at which the car could have been travelling\n    possible_speeds = [distance_diff[i] / time_diff[i] for i in range(len(distance_diff))]\n\n    # Calculate the possible distances between the first and second milestone\n    possible_distances = [X[1] - X[0]]\n    for i in range(1, len(X)):\n        possible_distances.append(X[i] - X[i-1])\n\n    # Output the number of distinct possible speeds and the space-separated list of possible distances\n    return len(set(possible_speeds)), ' '.join(map(str, sorted(set(possible_distances))))\n"
    },
    {
        "number": 4740,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    if n // 1000000 == 555:\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 4741,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    fahrenheit = stdin.strip()\n    if fahrenheit[0] == '-':\n        sign = -1\n        fahrenheit = fahrenheit[1:]\n    else:\n        sign = 1\n    numerator, denominator = map(int, fahrenheit.split('/'))\n    celsius = (numerator * 5) // denominator + 32\n    numerator, denominator = sign * celsius * denominator, denominator\n    gcd = math.gcd(numerator, denominator)\n    return f\"{numerator // gcd}/{denominator // gcd}\"\n"
    },
    {
        "number": 4742,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    l = int(input_list[0])\n    melody1 = input_list[1].split()\n    melody2 = input_list[2].split()\n\n    if len(melody1) != l or len(melody2) != l:\n        return \"Nonsense\"\n\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    note_values = {'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11}\n\n    def transposition(melody1, melody2):\n        if all(note_values[note] + 12 == note_values[melody2[i]] for i, note in enumerate(melody1)):\n            return True\n        return False\n\n    def retrograde(melody1, melody2):\n        if all(note_values[note] == note_values[melody2[l - 1 - i]] for i, note in enumerate(melody1)):\n            return True\n        return False\n\n    def inversion(melody1, melody2):\n        if all(note_values[note] == note_values[melody2[i]] for i, note in enumerate(melody1)):\n            return True\n        return False\n\n    if transposition(melody1, melody2):\n        return \"Transposition\"\n    elif retrograde(melody1, melody2):\n        return \"Retrograde\"\n    elif inversion(melody1, melody2):\n        return \"Inversion\"\n    else:\n        return \"Nonsense\"\n"
    },
    {
        "number": 4743,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def replace_first_letter(word: str) -> str:\n        first_letter = word[0]\n        if first_letter in 'bcdfghjklmnpqrstvwxyz':\n            return 'hard' + first_letter.upper()\n        elif first_letter in 'BCDFGHJKLMNPQRSTVWXYZ':\n            return 'Hard' + first_letter.lower()\n        else:\n            return 'hard' + first_letter\n\n    def replace_consonants(word: str) -> str:\n        nimion_word = ''\n        for i, letter in enumerate(word):\n            if letter in 'bcdfghjklmnpqrstvwxyz':\n                nimion_word += letter\n            elif letter in 'BCDFGHJKLMNPQRSTVWXYZ':\n                nimion_word += letter.lower()\n            else:\n                if i == 0:\n                    nimion_word += replace_first_letter(word)\n                else:\n                    nimion_word += letter\n        return nimion_word\n\n    def add_ending(word: str) -> str:\n        last_letter = word[-1]\n        if last_letter in 'bcdfghjklmnpqrstvwxyz':\n            return word + 'ah'\n        elif last_letter in 'BCDFGHJKLMNPQRSTVWXYZ':\n            return word + 'AH'\n        else:\n            return word\n\n    words = stdin.split()\n    nimion_sentence = ''\n    for word in words:\n        if word == 'Each':\n            nimion_sentence += 'Dach'\n        else:\n            nimion_sentence += replace_consonants(word)\n    nimion_sentence = nimion_sentence.replace('-', '')\n    nimion_sentence = add_ending(nimion_sentence)\n    return nimion_sentence "
    },
    {
        "number": 4744,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    V = int(stdin)\n    # Initialize variables\n    min_cost = float('inf')\n    min_area = float('inf')\n    # Iterate through all possible rectangles with sides 1 to sqrt(V)\n    for i in range(1, int(V**0.5)+1):\n        j = V // i\n        area = i * j\n        cost = area + 1\n        if cost < min_cost:\n            min_cost = cost\n            min_area = area\n    return min_cost"
    },
    {
        "number": 4745,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, X = map(int, input_data[0].split())\n    prices = list(map(int, input_data[1].split()))\n\n    # Sort the prices in descending order\n    prices.sort(reverse=True)\n\n    # Initialize variables\n    count = 0\n    i = 0\n\n    # Iterate through the prices\n    while i < n:\n        # If the price is greater than X, mark the item as participating\n        if prices[i] > X:\n            count += 1\n        # If the price is less than or equal to X, move to the next item\n        else:\n            i += 1\n\n    return count\n"
    },
    {
        "number": 4746,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    C, n = map(int, input_data[0].split())\n    passengers = []\n    for i in range(1, n+1):\n        left, in_train, wait = map(int, input_data[i].split())\n        passengers.append((left, in_train, wait))\n\n    for i in range(n):\n        if passengers[i][1] > C or passengers[i][2] > 0:\n            return \"impossible\"\n        if i > 0:\n            if passengers[i][0] > 0:\n                return \"impossible\"\n            if passengers[i][1] + passengers[i-1][1] > C:\n                return \"impossible\"\n\n    if passengers[n-1][1] > 0:\n        return \"impossible\"\n\n    return \"possible\"\n"
    },
    {
        "number": 4747,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return 1\n    if k == 1:\n        return n\n    if k >= n:\n        return n\n    dp = [0] * (k + 1)\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j == 1:\n                dp[j] = i\n            else:\n                dp[j] = max(dp[j - 1], i + dp[j - k])\n    return dp[k]\n"
    },
    {
        "number": 4748,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = list(map(int, stdin.split()))\n    H, N, M = input_values[0], input_values[1], input_values[2]\n\n    # Calculate the number of bricks needed for each layer\n    layer_bricks = [2 * k for k in range(1, H + 1)]\n\n    # Calculate the total number of bricks needed for all layers\n    total_bricks = sum(layer_bricks)\n\n    # Calculate the number of extra bricks needed\n    extra_bricks = total_bricks - (N + M)\n\n    # Calculate the number of extra 2x2 and 4x2 bricks needed\n    extra_2x2 = extra_bricks // 2\n    extra_4x2 = extra_bricks - extra_2x2\n\n    # Print the output\n    print(extra_2x2, extra_4x2)\n"
    },
    {
        "number": 4749,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    grid = [list(row) for row in input_data[1:]]\n\n    def is_valid_row(row):\n        black_count = 0\n        white_count = 0\n        for square in row:\n            if square == 'B':\n                black_count += 1\n            else:\n                white_count += 1\n        return black_count == white_count\n\n    def is_valid_column(column):\n        black_count = 0\n        white_count = 0\n        for square in column:\n            if square == 'B':\n                black_count += 1\n            else:\n                white_count += 1\n        return black_count == white_count\n\n    def is_valid_consecutive_squares(row):\n        for i in range(n - 2):\n            if row[i] == row[i + 1] == row[i + 2]:\n                return False\n        return True\n\n    for row in grid:\n        if not is_valid_row(row):\n            return \"0\"\n\n    for column in zip(*grid):\n        if not is_valid_column(column):\n            return \"0\"\n\n    for row in grid:\n        if not is_valid_consecutive_squares(row):\n            return \"0\"\n\n    for column in zip(*grid):\n        if not is_valid_consecutive_squares(column):\n            return \"0\"\n\n    return \"1\"\n"
    },
    {
        "number": 4750,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    q = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, q+1):\n        l1, r1, l2, r2 = map(int, stdin.split('\\n')[i].split())\n        a = l1\n        b = l2\n        if l1 < l2:\n            a = l1\n            b = l2\n        elif l1 == l2:\n            a = l1 + 1\n            b = l2 + 1\n        output.append(a)\n        output.append(b)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 4751,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_cycle(head: ListNode) -> int:\n        slow = head\n        fast = head\n\n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n\n            if slow == fast:\n                break\n\n        if fast is None or fast.next is None:\n            return -1\n\n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n\n        return slow.val\n\n    from typing import ListNode\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    input_list = list(map(int, stdin.split()))\n    input_list = input_list[1:]\n    head = ListNode(input_list[0])\n    current_node = head\n\n    for val in input_list[1:]:\n        current_node.next = ListNode(val)\n        current_node = current_node.next\n\n    return str(find_cycle(head))"
    },
    {
        "number": 4752,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    target = input_list[1]\n    input_list = input_list[2:]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if input_list[i] + input_list[j] == target:\n                return str(i) + \" \" + str(j)\n\n    return \"Not found\" "
    },
    {
        "number": 4753,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin.strip())\n    # Initialize the number of intersections to 0\n    num_intersections = 0\n\n    # Loop through all possible pairs of diagonals\n    for i in range(N):\n        for j in range(i+1, N):\n            # Check if the two diagonals intersect\n            if do_diagonals_intersect(i, j, N):\n                num_intersections += 1\n\n    # Output the number of intersections\n    return str(num_intersections)\n\n\ndef"
    },
    {
        "number": 4754,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.splitlines()[0])\n    socks = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the two piles\n    pile1 = []\n    pile2 = []\n\n    # Iterate through the socks and add them to the piles\n    for sock in socks:\n        if len(pile1) < n:\n            pile1.append(sock)\n        else:\n            pile2.append(sock)\n\n    # Initialize the number of moves\n    moves = 0\n\n    # Iterate through the socks and pair them\n    for i in range(n):\n        # If the socks are of different types, move the sock from pile1 to pile2\n        if pile1[i] != pile2[i]:\n            moves += 1\n            pile2.append(pile1.pop(i))\n        # If the socks are of the same type, pair them\n        else:\n            pile1.pop(i)\n            pile2.pop(i)\n\n    # If all socks are paired, return the number of moves\n    if len(pile1) == 0:\n        return str(moves)\n    # If it's impossible to pair all socks, return \"impossible\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 4755,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.strip()\n    C, K = map(int, input_str.split())\n\n    # Calculate the smallest bill Mirko has\n    smallest_bill = 10 ** K\n\n    # Calculate the amount Mirko can pay with the smallest bill\n    amount_payable = C // smallest_bill * smallest_bill\n\n    # Calculate the amount Mirko can pay with the next smallest bill\n    next_bill = smallest_bill * 10\n    next_amount_payable = amount_payable + next_bill\n\n    # Check which amount is closer to the actual amount\n    if abs(C - amount_payable) > abs(C - next_amount_payable):\n        result = next_amount_payable\n    else:\n        result = amount_payable\n\n    return str(result)\n"
    },
    {
        "number": 4756,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def closest_distance(x, y, line):\n        a, b = line\n        x_intersect = (b - y) / (a - b)\n        y_intersect = a * x_intersect + b\n        return distance(x, y, x_intersect, y_intersect)\n\n    def unusefulness(x, y, line):\n        return closest_distance(x, y, line) ** 2\n\n    def total_unusefulness(coordinates, line):\n        return sum(unusefulness(x, y, line) for x, y in coordinates)\n\n    N = int(stdin.splitlines()[0])\n    coordinates = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    line = (1, 1)\n\n    a = min(total_unusefulness(coordinates, line) for a in range(-1000000, 1000001))\n\n    return str(a)\n"
    },
    {
        "number": 4757,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_villagers_present(villagers_present: str) -> set:\n        return set(map(int, villagers_present.split()))\n\n    def get_villagers_knowing_all_songs(villagers_present: set, villagers_knowing_all_songs: set) -> set:\n        return villagers_present.intersection(villagers_knowing_all_songs)\n\n    def get_villagers_knowing_all_songs_across_evenings(villagers_present: list, villagers_knowing_all_songs: set) -> set:\n        villagers_knowing_all_songs_across_evenings = set()\n        for evening in villagers_present:\n            villagers_knowing_all_songs_across_evenings = get_villagers_knowing_all_songs(get_villagers_present(evening), villagers_knowing_all_songs_across_evenings)\n        return villagers_knowing_all_songs_across_evenings\n\n    def get_villagers_knowing_all_songs_across_evenings_bard_present(villagers_present: list, villagers_knowing_all_songs: set) -> set:\n        villagers_knowing_all_songs_across_evenings = get_villagers_knowing_all_songs_across_evenings(villagers_present, villagers_knowing_all_songs)\n        return villagers_knowing_all_songs_across_evenings.union({1})\n\n    def get_villagers_knowing_all_songs_across_evenings_bard_not_present(villagers_present: list, villagers_knowing_all_songs: set) -> set:\n        villagers_knowing_all_songs_across_evenings = get_villagers_knowing_all_songs_across_evenings(villagers_present, villagers_knowing_all_songs)\n        return villagers_knowing_all_songs_across_evenings\n\n    def main(stdin: str) -> str:\n        N, E = map(int, stdin.splitlines()[0].split())\n        villagers_present = [stdin.splitlines()[i + 1] for i in range(E)]\n        villagers_knowing_all_songs = {i for i in range(1, N + 1)}\n\n        if 1 in villagers_knowing_all_songs:\n            villagers_knowing_all_songs_across_evenings_bard_present = get_villagers_knowing_all_songs_across_evenings_bard_present(villagers_present, villagers_knowing_all_songs)\n            villagers_knowing_all_songs_across_evenings_bard_not_present = get_villagers_knowing_all_songs_across_evenings_bard_not_present(villagers_present, villagers_knowing_all_songs)\n            result = villagers_knowing_all_songs_across_evenings_bard_present.union(villagers_knowing_all_songs_across_evenings_bard_not_present)\n        else:\n            result = get_villagers_knowing_all_songs_across_evenings(villagers_present, villagers_knowing_all_songs)\n\n        return '\\n'.join(map(str, sorted(result)))\n\n    return main(stdin)\n"
    },
    {
        "number": 4758,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, T, M = map(int, stdin.split())\n    return str(N * T * M)\n"
    },
    {
        "number": 4759,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    at_bats = list(map(int, stdin.split('\\n')[1].split()))\n\n    bases = [0] * 5\n    for at_bat in at_bats:\n        if at_bat >= 0:\n            bases[at_bat] += 1\n\n    slugging_percentage = (bases[3] + bases[4]) / (bases[0] + bases[1] + bases[2] + bases[3] + bases[4])\n\n    return f\"{slugging_percentage:.4f}\"\n"
    },
    {
        "number": 4760,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n    primes = [True] * (N + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= N:\n        if primes[p]:\n            for i in range(p * p, N + 1, p):\n                primes[i] = False\n        p += 1\n    count = 0\n    for i in range(2, N + 1):\n        if primes[i]:\n            count += 1\n            if count == K:\n                return i\n"
    },
    {
        "number": 4761,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    L = int(input_data[0])\n    H = int(input_data[1])\n\n    # Calculate the total number of possible combinations\n    total_combinations = 0\n    for i in range(10):\n        for j in range(10):\n            if j != i:\n                for k in range(10):\n                    if k != i and k != j:\n                        for l in range(10):\n                            if l != i and l != j and l != k:\n                                for m in range(10):\n                                    if m != i and m != j and m != k and m != l:\n                                        for n in range(10):\n                                            if n != i and n != j and n != k and n != l and n != m:\n                                                if L <= 1000000 * i + 100000 * j + 10000 * k + 1000 * l + 100 * m + 10 * n + n and H >= 1000000 * i + 100000 * j + 10000 * k + 1000 * l + 100 * m + 10 * n + n:\n                                                    total_combinations += 1\n\n    # Print the total number of possible combinations\n    return str(total_combinations)"
    },
    {
        "number": 4762,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    p = 1.0\n    for i in range(1, N+1):\n        p *= (N-i) / i\n    return str(1 - p)"
    },
    {
        "number": 4763,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    target_score = int(stdin)\n    if target_score > 180:\n        return \"impossible\"\n\n    def score_for_section(section: int, dart_type: str) -> int:\n        if dart_type == \"single\":\n            return section\n        elif dart_type == \"double\":\n            return 2 * section\n        elif dart_type == \"triple\":\n            return 3 * section\n        else:\n            raise ValueError(\"Invalid dart type\")\n\n    def score_for_dart(dart_type: str) -> int:\n        if dart_type == \"single\":\n            return 1\n        elif dart_type == \"double\":\n            return 2\n        elif dart_type == \"triple\":\n            return 3\n        else:\n            raise ValueError(\"Invalid dart type\")\n\n    def find_valid_darts(target_score: int) -> List[Tuple[str, str, str]]:\n        valid_darts = []\n        for section in range(1, 21):\n            for dart_type in [\"single\", \"double\", \"triple\"]:\n                score = score_for_section(section, dart_type)\n                if score <= target_score:\n                    valid_darts.append((dart_type, \"single\", str(section)))\n                    target_score -= score\n                    if target_score == 0:\n                        return valid_darts\n        return []\n\n    valid_darts = find_valid_darts(target_score)\n    if valid_darts:\n        for dart_type, section_type, section_num in valid_darts:\n            print(f\"{section_type} {section_num}\")\n    else:\n        print(\"impossible\")\n"
    },
    {
        "number": 4764,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    n, h, v = map(int, input_data)\n\n    # Calculate the volume of the cake before the cuts\n    cake_volume = n * n * 4\n\n    # Calculate the volume of the four pieces of cake after the cuts\n    piece1 = n * n * 4 - (n - h) * (n - h) * 4\n    piece2 = n * n * 4 - (n - v) * (n - v) * 4\n    piece3 = (n - h) * (n - h) * 4\n    piece4 = (n - v) * (n - v) * 4\n\n    # Find the largest piece of cake\n    max_piece = max(piece1, piece2, piece3, piece4)\n\n    # Calculate the volume of the largest piece of cake\n    max_volume = max_piece / 4\n\n    return f\"{max_volume:.2f}\"\n"
    },
    {
        "number": 4765,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    ingredients = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    min_diff = float('inf')\n    for i in range(1, 1 << N):\n        sourness = 1\n        bitterness = 0\n        for j in range(N):\n            if i & (1 << j):\n                sourness *= ingredients[j][0]\n                bitterness += ingredients[j][1]\n        diff = abs(sourness - bitterness)\n        min_diff = min(min_diff, diff)\n\n    return str(min_diff)\n"
    },
    {
        "number": 4766,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    output_list = []\n    for i in range(1, N+1):\n        command = input_list[i]\n        if command.startswith(\"Simon says\"):\n            output_list.append(command[11:])\n    return '\\n'.join(output_list)"
    },
    {
        "number": 4767,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = list(map(int, stdin.split()))\n    registers = [0] * 8\n    for i in range(8):\n        registers[i] = input_values[i]\n\n    safe_operations = 0\n    for i in range(8):\n        safe_operations += registers[i]\n\n    for i in range(8):\n        safe_operations += (registers[i] + 1) // 2\n        safe_operations += (registers[i] + 1) % 2\n\n    for i in range(7):\n        safe_operations += (registers[i] + 1) // 3\n        safe_operations += (registers[i] + 1) % 3\n\n    for i in range(6):\n        safe_operations += (registers[i] + 1) // 5\n        safe_operations += (registers[i] + 1) % 5\n\n    for i in range(5):\n        safe_operations += (registers[i] + 1) // 7\n        safe_operations += (registers[i] + 1) % 7\n\n    for i in range(4):\n        safe_operations += (registers[i] + 1) // 11\n        safe_operations += (registers[i] + 1) % 11\n\n    for i in range(3):\n        safe_operations += (registers[i] + 1) // 13\n        safe_operations += (registers[i] + 1) % 13\n\n    for i in range(2):\n        safe_operations += (registers[i] + 1) // 17\n        safe_operations += (registers[i] + 1) % 17\n\n    for i in range(1):\n        safe_operations += (registers[i] + 1) // 19\n        safe_operations += (registers[i] + 1) % 19\n\n    return str(safe_operations)\n"
    },
    {
        "number": 4768,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def compute_unlikeliness(tree):\n        unlikeliness = 0\n        for i in range(len(tree)):\n            for j in range(i+1, len(tree)):\n                unlikeliness += sum(tree[i] != tree[j])\n        return unlikeliness\n\n    def build_tree(samples):\n        tree = [samples[0]]\n        for sample in samples[1:]:\n            min_unlikeliness = float('inf')\n            min_node = None\n            for i, node in enumerate(tree):\n                new_node = node[:]\n                for j in range(len(new_node)):\n                    new_node[j] = sample[j] if node[j] != sample[j] else node[j]\n                unlikeliness = compute_unlikeliness(tree + [new_node])\n                if unlikeliness < min_unlikeliness:\n                    min_unlikeliness = unlikeliness\n                    min_node = i\n            tree.append(min_node)\n        return tree\n\n    n, k = map(int, stdin.split()[:2])\n    samples = [stdin.split()[2:k+2][::-1]]\n    for i in range(3, n+3):\n        samples.append(stdin.split()[i:i+k][::-1])\n\n    tree = build_tree(samples)\n    unlikeliness = compute_unlikeliness(tree)\n    print(unlikeliness)\n\n    for i in range(n-1):\n        print(tree[i], tree[i+1])\n"
    },
    {
        "number": 4769,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    word = stdin.strip()\n    n = len(word)\n    if n < 3:\n        return -1\n\n    def is_anagram(s1: str, s2: str) -> bool:\n        return sorted(s1) == sorted(s2)\n\n    def find_roots(word: str) -> List[str]:\n        roots = []\n        for i in range(1, n):\n            if is_anagram(word[:i], word[i:]):\n                roots.append(word[:i])\n        return roots\n\n    roots = find_roots(word)\n    if not roots:\n        return -1\n\n    return min(roots, key=len)\n"
    },
    {
        "number": 4770,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, M = map(int, stdin.split())\n    if N == M:\n        return \"Dr. Chaz needs 1 more piece of chicken!\"\n    elif N > M:\n        return f\"Dr. Chaz will have {M - N} piece[s] of chicken left over!\"\n    else:\n        return f\"Dr. Chaz needs {N - M} more piece[s] of chicken!\"\n"
    },
    {
        "number": 4771,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, V = map(int, input_data[0].split())\n    boxes = [tuple(map(int, input_data[i].split())) for i in range(1, n+1)]\n\n    max_box = max(boxes, key=lambda x: x[0]*x[1]*x[2])\n    max_volume = max_box[0]*max_box[1]*max_box[2]\n    diff = max_volume - V\n\n    return str(diff)"
    },
    {
        "number": 4772,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    R, C = map(int, input_data[0].split())\n    crossword = [list(line) for line in input_data[1:]]\n\n    def is_valid(word, row, col):\n        for i, c in enumerate(word):\n            if c == '#':\n                continue\n            if not (0 <= row + i < R and 0 <= col + i < C):\n                return False\n            if crossword[row + i][col + i] != c:\n                return False\n        return True\n\n    def find_word(row, col, direction):\n        if direction == 'v':\n            row_inc, col_inc = 1, 0\n        else:\n            row_inc, col_inc = 0, 1\n\n        word = ''\n        while 0 <= row + row_inc < R and 0 <= col + col_inc < C:\n            if crossword[row + row_inc][col + col_inc] == '#':\n                break\n            word += crossword[row + row_inc][col + col_inc]\n            row += row_inc\n            col += col_inc\n\n        return word\n\n    words = []\n    for row in range(R):\n        for col in range(C):\n            if crossword[row][col] == '#':\n                continue\n            if is_valid(crossword[row][col], row, col):\n                words.append(crossword[row][col])\n\n            word_v = find_word(row, col, 'v')\n            if len(word_v) >= 2 and is_valid(word_v, row, col):\n                words.append(word_v)\n\n            word_h = find_word(row, col, 'h')\n            if len(word_h) >= 2 and is_valid(word_h, row, col):\n                words.append(word_h)\n\n    return min(filter(lambda w: len(w) >= 2, words))\n"
    },
    {
        "number": 4773,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def encode_macro(macro_str: str, route_str: str) -> str:\n        encoded_str = \"\"\n        for char in route_str:\n            if char in macro_str:\n                encoded_str += macro_str[macro_str.index(char)]\n            else:\n                encoded_str += char\n        return encoded_str\n\n    def count_chars(route_str: str) -> int:\n        return len(route_str)\n\n    route = stdin\n    macro = \"NSEW\"\n    macro_str = \"M\"\n\n    encoded_route = encode_macro(macro_str, route)\n    min_chars = count_chars(encoded_route)\n\n    return min_chars\n"
    },
    {
        "number": 4774,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c, d = map(int, stdin.split())\n\n    operators = ['+', '-', '*', '/']\n    valid_expressions = []\n\n    for op1 in operators:\n        for op2 in operators:\n            for op3 in operators:\n                for op4 in operators:\n                    expression = f\"{a} {op1} {b} {op2} {c} {op3} {d} {op4}\"\n                    try:\n                        if eval(expression) == c:\n                            valid_expressions.append(expression)\n                    except ZeroDivisionError:\n                        pass\n\n    if valid_expressions:\n        valid_expressions.sort()\n        return '\\n'.join(valid_expressions)\n    else:\n        return \"problems ahead\"\n"
    },
    {
        "number": 4775,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    words = stdin.split()\n    A = words[0]\n    B = words[1]\n\n    N = len(A)\n    M = len(B)\n\n    crossword = [['.'] * N for _ in range(M)]\n\n    for i in range(N):\n        for j in range(M):\n            if A[i] == B[j]:\n                crossword[j][i] = A[i]\n                break\n\n    output = ''\n    for row in crossword:\n        output += ''.join(row) + '\\n'\n\n    return output\n"
    },
    {
        "number": 4776,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_serving_food(day: int, events: list) -> bool:\n        for event in events:\n            if event[0] <= day <= event[1]:\n                return True\n        return False\n\n    def count_days_with_food_serving(events: list) -> int:\n        days = set()\n        for event in events:\n            for day in range(event[0], event[1] + 1):\n                days.add(day)\n        return len(days)\n\n    N = int(stdin.splitlines()[0])\n    events = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    days_with_food_serving = count_days_with_food_serving(events)\n    return str(days_with_food_serving)\n"
    },
    {
        "number": 4777,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K = int(stdin.strip())\n    A = K // 2\n    B = K - A\n    return f\"{A} {B}\"\n"
    },
    {
        "number": 4778,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    P, D = map(int, input_data[0].split())\n    precincts = [list(map(int, line.split())) for line in input_data[1:]]\n\n    # Calculate the total votes for each party\n    total_votes_A = sum(precinct[1] for precinct in precincts)\n    total_votes_B = sum(precinct[2] for precinct in precincts)\n\n    # Calculate the total votes for each district\n    district_votes_A = [sum(precinct[1] for precinct in precincts if precinct[0] == district) for district in range(1, D + 1)]\n    district_votes_B = [sum(precinct[2] for precinct in precincts if precinct[0] == district) for district in range(1, D + 1)]\n\n    # Determine the winner for each district\n    district_winners = []\n    for district in range(1, D + 1):\n        if district_votes_A[district - 1] > district_votes_B[district - 1]:\n            district_winners.append('A')\n        elif district_votes_A[district - 1] < district_votes_B[district - 1]:\n            district_winners.append('B')\n        else:\n            district_winners.append('T')\n\n    # Calculate the wasted votes for each party\n    wasted_votes_A = [0] * D\n    wasted_votes_B = [0] * D\n    for district in range(1, D + 1):\n        if district_winners[district - 1] == 'A':\n            wasted_votes_A[district - 1] = total_votes_B[district - 1] - district_votes_B[district - 1]\n        elif district_winners[district - 1] == 'B':\n            wasted_votes_B[district - 1] = total_votes_A[district - 1] - district_votes_A[district - 1]\n        else:\n            wasted_votes_A[district - 1] = total_votes_B[district - 1] - district_votes_B[district - 1]\n            wasted_votes_B[district - 1] = total_votes_A[district - 1] - district_votes_A[district - 1]\n\n    # Calculate the efficiency gap\n    efficiency_gap = sum(wasted_votes_A) - sum(wasted_votes_B)\n\n    # Print the results\n    for district in range(1, D + 1):\n        print(district_winners[district - 1], end=' ')\n        print(wasted_votes_A[district - 1], end=' ')\n        print(wasted_votes_B[district - 1])\n    print(round(efficiency_gap, 6))\n\n    return '\\n'.join(input_data)\n"
    },
    {
        "number": 4779,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    k = n // 2\n    left = sum(a[:k]) ** 2\n    right = sum(a[k:])\n    return left * right\n"
    },
    {
        "number": 4780,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N1, N2 = map(int, input_data[0].split())\n    row1 = input_data[1].split()\n    row2 = input_data[2].split()\n    T = int(input_data[3])\n\n    def get_ant_position(row, ant):\n        return row.index(ant)\n\n    def swap_ants(row1, row2, ant1, ant2):\n        row1[get_ant_position(row1, ant1)], row1[get_ant_position(row1, ant2)] = row1[get_ant_position(row1, ant2)], row1[get_ant_position(row1, ant1)]\n        row2[get_ant_position(row2, ant1)], row2[get_ant_position(row2, ant2)] = row2[get_ant_position(row2, ant2)], row2[get_ant_position(row2, ant1)]\n\n    def get_ant_order(row):\n        return ''.join(row)\n\n    for i in range(T):\n        for j in range(N1):\n            if j < N1 - 1:\n                if row1[j] < row1[j + 1]:\n                    swap_ants(row1, row2, row1[j], row1[j + 1])\n                elif row1[j] > row1[j + 1]:\n                    swap_ants(row1, row2, row1[j + 1], row1[j])\n\n    return get_ant_order(row1) + get_ant_order(row2) "
    },
    {
        "number": 4781,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    K = int(input_data[0])\n    N = int(input_data[1])\n    questions = input_data[2:]\n\n    players = [i for i in range(1, 9)]\n    current_player = players[K - 1]\n    box_holder = current_player\n\n    for question in questions:\n        time, answer = question.split()\n        time = int(time)\n\n        if answer == 'T':\n            current_player = (current_player - 1) % 8 + 1\n        elif answer == 'N':\n            current_player = (current_player + 1) % 8 + 1\n        else:\n            current_player = (current_player - 2) % 8 + 1\n\n        box_holder = current_player\n\n    return str(box_holder)\n"
    },
    {
        "number": 4782,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, m = map(int, stdin.split())\n    roads = [0] * (n*(n-1)//2)\n    for i in range(m):\n        roads[i] = 1\n    roads[m] = 1\n    roads[m+1] = 1\n    roads[m+2] = 1\n    roads[m+3] = 1\n    roads[m+4] = 1\n    roads[m+5] = 1\n    roads[m+6] = 1\n    roads[m+7] = 1\n    roads[m+8] = 1\n    roads[m+9] = 1\n    roads[m+10] = 1\n    roads[m+11] = 1\n    roads[m+12] = 1\n    roads[m+13] = 1\n    roads[m+14] = 1\n    roads[m+15] = 1\n    roads[m+16] = 1\n    roads[m+17] = 1\n    roads[m+18] = 1\n    roads[m+19] = 1\n    roads[m+20] = 1\n    roads[m+21] = 1\n    roads[m+22] = 1\n    roads[m+23] = 1\n    roads[m+24] = 1\n    roads[m+25] = 1\n    roads[m+26] = 1\n    roads[m+27] = 1\n    roads[m+28] = 1\n    roads[m+29] = 1\n    roads[m+30] = 1\n    roads[m+31] = 1\n    roads[m+32] = 1\n    roads[m+33] = 1\n    roads[m+34] = 1\n    roads[m+35] = 1\n    roads[m+36] = 1\n    roads[m+37] = 1\n    roads[m+38] = 1\n    roads[m+39] = 1\n    roads[m+40] = 1\n    roads[m+41] = 1\n    roads[m+42] = 1\n    roads[m+43] = 1\n    roads[m+44] = 1\n    roads[m+45] = 1\n    roads[m+46] = 1\n    roads[m+47] = 1\n    roads[m+48] = 1\n    roads[m+49] = 1\n    roads[m+50] = 1\n    roads[m+51] = 1\n    roads[m+52] = 1\n    roads[m+53] = 1\n    roads[m+54] = 1\n    roads[m+55] = 1\n    roads[m+56] = 1\n    roads[m+57] = 1\n    roads[m+58] = 1\n    roads[m+59] = 1\n    roads[m+60] = 1\n    roads[m+61] = 1\n    roads[m+62] = 1\n    roads[m+63] = 1\n    roads[m+64] = 1\n    roads[m+65] = 1\n    roads[m+66] = 1\n    roads[m+67] = 1\n    roads[m+68] = 1\n    roads[m+69] = 1\n    roads[m+70] = 1\n    roads[m+71] = 1\n    roads[m+72] = 1\n    roads[m+73] = 1\n    roads[m+74] = 1\n    roads[m+75] = 1\n    roads[m+76] = 1\n    roads[m+77] = 1\n    roads[m+78] = 1\n    roads[m+79] = 1\n    roads[m+80] = 1\n    roads[m+81] = 1\n"
    },
    {
        "number": 4783,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def min_ladder_length(M, N, heights):\n        def min_climb_length(x, y):\n            return abs(heights[x][y] - heights[x - 1][y]) + abs(heights[x][y] - heights[x][y - 1])\n\n        def min_jump_length(x, y):\n            return abs(heights[x][y] - heights[x + 1][y]) + abs(heights[x][y] - heights[x][y + 1])\n\n        def dfs(x, y, visited):\n            if x == M - 1 and y == N - 1:\n                return 0\n\n            if visited[x][y]:\n                return float('inf')\n\n            visited[x][y] = True\n\n            min_cost = float('inf')\n\n            if x > 0:\n                min_cost = min(min_cost, dfs(x - 1, y, visited) + min_climb_length(x, y))\n\n            if y > 0:\n                min_cost = min(min_cost, dfs(x, y - 1, visited) + min_climb_length(x, y))\n\n            if x < M - 1:\n                min_cost = min(min_cost, dfs(x + 1, y, visited) + min_jump_length(x, y))\n\n            if y < N - 1:\n                min_cost = min(min_cost, dfs(x, y + 1, visited) + min_jump_length(x, y))\n\n            visited[x][y] = False\n\n            return min_cost\n\n        visited = [[False for _ in range(N)] for _ in range(M)]\n        return dfs(0, 0, visited)\n\n    M, N = map(int, stdin.split()[:2])\n    heights = [list(map(int, stdin.split()[i + 2:i + 2 + N])) for i in range(0, M * N, N)]\n\n    return str(min_ladder_length(M, N, heights))\n"
    },
    {
        "number": 4784,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X, N = map(int, stdin.split('\\n')[0].split())\n    P = list(map(int, stdin.split('\\n')[1:]))\n\n    remaining_megabytes = X - sum(P[:N])\n    if remaining_megabytes < 0:\n        remaining_megabytes = 0\n\n    return str(remaining_megabytes)\n"
    },
    {
        "number": 4785,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    if 'ss' in stdin:\n        return 'hiss'\n    else:\n        return 'no hiss'"
    },
    {
        "number": 4786,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_similar(k1: str, k2: str) -> bool:\n        return k1.lower().replace('-', ' ') == k2.lower().replace('-', ' ')\n\n    n = int(stdin.splitlines()[0])\n    keywords = set(stdin.splitlines()[1:])\n    similar_keywords = set()\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(keywords[i], keywords[j]):\n                similar_keywords.add((keywords[i], keywords[j]))\n\n    return len(similar_keywords)\n"
    },
    {
        "number": 4787,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    tablet_count = stdin.count('T')\n    compass_count = stdin.count('C')\n    gear_count = stdin.count('G')\n\n    total_points = (tablet_count ** 2) + (compass_count ** 2) + (gear_count ** 2)\n\n    if tablet_count >= 3 and compass_count >= 3 and gear_count >= 3:\n        total_points += 7\n\n    return str(total_points)\n"
    },
    {
        "number": 4788,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n1 = int(input_list[0])\n    n2 = int(input_list[1])\n\n    if n1 == n2:\n        return 0\n    elif n1 < n2:\n        return n2 - n1\n    else:\n        return 360 - n1 + n2\n"
    },
    {
        "number": 4789,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    K = int(input_list[0])\n    clerk_desks = [int(i) for i in input_list[1:]]\n\n    # Find the minimum desk number\n    min_desk = min(clerk_desks)\n\n    # Calculate the number of passes\n    num_passes = min_desk - 1\n\n    # Check if the number of passes is sufficient\n    if num_passes > 0:\n        return str(num_passes)\n    else:\n        return \"0\""
    },
    {
        "number": 4790,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    black_count = 0\n    white_count = 0\n    for stone in stdin:\n        if stone == 'B':\n            black_count += 1\n        else:\n            white_count += 1\n    if black_count == white_count:\n        return '1'\n    else:\n        return '0'"
    },
    {
        "number": 4791,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = list(map(int, stdin.split()))\n    s1, s2, s3, s4 = input_data\n\n    # Calculate the semi-perimeter\n    t = (s1 + s2 + s3 + s4) / 2\n\n    # Calculate the area of the maximum inscribed quadrilateral\n    area_max = (t * (t - s1) * (t - s2) * (t - s3) * (t - s4)) ** 0.5\n\n    # Calculate the area of the maximum inscribed quadrilateral\n    area_min = max(s1 * s2, s2 * s3, s3 * s4, s4 * s1)\n\n    # Calculate the maximum area of the maximum quadrilateral\n    max_area = area_max - area_min\n\n    return f\"{max_area:.6f}\"\n"
    },
    {
        "number": 4792,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    name = stdin.strip()\n    compact_name = \"\"\n    prev_char = \"\"\n\n    for char in name:\n        if char == prev_char:\n            continue\n        compact_name += char\n        prev_char = char\n\n    return compact_name\n"
    },
    {
        "number": 4793,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, v1, v2 = map(int, stdin.split())\n\n    if v1 <= v2:\n        return \"Impossible\"\n\n    bottles_v1 = s // v1\n    bottles_v2 = (s - bottles_v1 * v1) // v2\n\n    return f\"{bottles_v1} {bottles_v2}\"\n"
    },
    {
        "number": 4794,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R, C = map(int, stdin.split()[0:2])\n    map_table = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n\n    def is_valid_space(row, col):\n        return 0 <= row < R and 0 <= col < C and map_table[row][col] == '.'\n\n    def count_squashed_cars(row, col):\n        count = 0\n        for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            if is_valid_space(row + dr, col + dc):\n                count += 1\n        return count\n\n    def count_parking_spaces(squash_count):\n        parking_spaces = 0\n        for row in range(R):\n            for col in range(C):\n                if map_table[row][col] == '.' and count_squashed_cars(row, col) <= squash_count:\n                    parking_spaces += 1\n        return parking_spaces\n\n    result = [count_parking_spaces(i) for i in range(5)]\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 4795,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    numbers = [int(input_data[i]) for i in range(1, N+1)]\n    X = sum(numbers)\n    return str(X)"
    },
    {
        "number": 4796,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    bought_juices = list(map(int, input_data[0].split()))\n    cocktail_ratios = list(map(int, input_data[1].split()))\n\n    total_juice = sum(bought_juices)\n    cocktail_volume = total_juice / sum(cocktail_ratios)\n\n    leftover_orange = bought_juices[0] - cocktail_ratios[0] * cocktail_volume\n    leftover_apple = bought_juices[1] - cocktail_ratios[1] * cocktail_volume\n    leftover_pineapple = bought_juices[2] - cocktail_ratios[2] * cocktail_volume\n\n    return f\"{leftover_orange:.3f} {leftover_apple:.3f} {leftover_pineapple:.3f}\"\n"
    },
    {
        "number": 4797,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    result = \"\"\n    for char in stdin:\n        if char == \"<\":\n            result += \".\"\n        else:\n            result += char\n    return result"
    },
    {
        "number": 4798,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Split the input string into a list of words\n    words = stdin.split()\n\n    # Initialize an empty list to store the short variations\n    short_variations = []\n\n    # Iterate through the words\n    for word in words:\n        # If the word contains a hyphen, split it into a list of last names\n        if '-' in word:\n            last_names = word.split('-')\n            # Convert the last names to short variations\n            short_variation = ''.join([name[0].upper() for name in last_names])\n        else:\n            # If the word doesn't contain a hyphen, use the first letter of the word as the short variation\n            short_variation = word[0].upper()\n\n        # Add the short variation to the list\n        short_variations.append(short_variation)\n\n    # Join the short variations into a single string\n    short_variation_string = ' '.join(short_variations)\n\n    return short_variation_string"
    },
    {
        "number": 4799,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    G, S, C = map(int, stdin.split())\n    \n    # Calculate the best victory card and best treasure card Jake can buy\n    if G >= 3:\n        best_victory = \"Province\"\n    elif S >= 2:\n        best_victory = \"Duchy\"\n    elif C >= 1:\n        best_victory = \"Estate\"\n    else:\n        best_victory = \"None\"\n    \n    if G >= 3:\n        best_treasure = \"Gold\"\n    elif S >= 2:\n        best_treasure = \"Silver\"\n    else:\n        best_treasure = \"Copper\"\n    \n    # Output the best victory card and best treasure card Jake can buy\n    if best_victory != \"None\":\n        return f\"{best_victory} or {best_treasure}\"\n    else:\n        return f\"{best_treasure}\""
    },
    {
        "number": 4800,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    d, s = map(int, input_data[1].split())\n\n    if k == 0:\n        return \"impossible\"\n\n    avg_difficulty = (d * k + s * (n - k)) / n\n\n    if avg_difficulty.is_integer():\n        return str(int(avg_difficulty))\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 4801,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    A = list(map(int, input_data[1].split()))\n\n    gis = [A[0]]\n    for i in range(1, N):\n        if A[i] > gis[-1]:\n            gis.append(A[i])\n        else:\n            j = 0\n            while j < len(gis) and A[i] <= gis[j]:\n                j += 1\n            gis.insert(j, A[i])\n\n    output = [str(len(gis))] + [str(x) for x in gis]\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 4802,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_time = stdin.split()\n    hours = int(input_time[0])\n    minutes = int(input_time[1])\n    \n    if minutes >= 45:\n        minutes -= 45\n    else:\n        minutes += 60 - 45\n        hours -= 1\n    \n    if hours < 0:\n        hours += 24\n    \n    return f\"{hours} {minutes}\"\n"
    },
    {
        "number": 4803,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = float(stdin)\n    if 0.36788 <= N <= 2.718281:\n        a = (N - 1) / (N - 1)\n        return str(a)\n    else:\n        return \"Invalid input. Please enter a number between 0.36788 and 2.718281.\" "
    },
    {
        "number": 4804,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.strip()\n    S = int(input_str)\n\n    def is_valid(pattern):\n        for i in range(len(pattern) - 1):\n            if abs(pattern[i] - pattern[i + 1]) > 1:\n                return False\n        return True\n\n    def generate_patterns(S):\n        patterns = []\n        for i in range(1, S):\n            for j in range(S - i):\n                pattern = [i, j]\n                if is_valid(pattern):\n                    patterns.append(pattern)\n        return patterns\n\n    def compact_representation(pattern):\n        return f\"{pattern[0]},{pattern[1]}\"\n\n    patterns = generate_patterns(S)\n    patterns.sort(key=lambda x: (x[0], x[1]))\n\n    result = f\"{S}:\\n\"\n    for pattern in patterns:\n        result += compact_representation(pattern) + \"\\n\"\n\n    return result\n"
    },
    {
        "number": 4805,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    words = stdin.split()\n    seen_words = set()\n    for word in words:\n        if word in seen_words:\n            return \"no\"\n        seen_words.add(word)\n    return \"yes\""
    },
    {
        "number": 4806,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    moves = {'R': 'S', 'B': 'K', 'L': 'H'}\n    combo_breaker = 'C'\n    result = []\n\n    for move in stdin:\n        if move == 'R' or move == 'B' or move == 'L':\n            result.append(moves[move])\n        else:\n            result.append(combo_breaker)\n\n    return ''.join(result)\n"
    },
    {
        "number": 4807,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.strip()\n    x, y, n = map(int, input_str.split())\n\n    for i in range(1, n + 1):\n        if i % x == 0 and i % y == 0:\n            print(\"FizzBuzz\")\n        elif i % x == 0:\n            print(\"Fizz\")\n        elif i % y == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n"
    },
    {
        "number": 4808,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, d_m, *d_i = map(int, stdin.split())\n    k = 0\n    for i in range(n):\n        if d_m <= d_i[i]:\n            k = i + 1\n            break\n    if k > 0:\n        return f\"It hadn't snowed this early in {k} years!\"\n    else:\n        return \"It had never snowed this early!\"\n"
    },
    {
        "number": 4809,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, n = map(int, stdin.split())\n    if s == 9:\n        s = 10\n    elif s == 3:\n        s = 4\n    else:\n        s = 5\n    p = 1\n    for i in range(2, n+1):\n        if p % s == 0:\n            p += 1\n        p += 1\n    return str(p)"
    },
    {
        "number": 4810,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read the input message\n    message = stdin\n\n    # Initialize the matrix\n    matrix = []\n\n    # Find the matrix with the most rows\n    max_rows = 0\n    for i in range(1, len(message) + 1):\n        if len(message) % i == 0:\n            if i > max_rows:\n                max_rows = i\n\n    # Create the matrix\n    for i in range(max_rows):\n        row = []\n        for j in range(len(message) // max_rows):\n            row.append(message[i + j * max_rows])\n        matrix.append(row)\n\n    # Read the matrix in column-major order\n    decrypted_message = \"\"\n    for i in range(len(matrix[0])):\n        for row in matrix:\n            decrypted_message += row[i]\n\n    return decrypted_message\n"
    },
    {
        "number": 4811,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    K = int(stdin)\n\n    # Initialize variables\n    smallest_bar_size = 1\n    smallest_breaks = 0\n\n    # Iterate through all possible bar sizes\n    while smallest_bar_size ** 2 < K:\n        # Calculate the number of squares in the current bar size\n        squares_in_bar = smallest_bar_size ** 2\n\n        # Calculate the number of breaks needed to get K squares\n        breaks_needed = 1\n        while squares_in_bar < K:\n            squares_in_bar *= 2\n            breaks_needed += 1\n\n        # If the number of breaks is smaller than the current smallest number of breaks, update the smallest number of breaks\n        if breaks_needed < smallest_breaks or smallest_breaks == 0:\n            smallest_breaks = breaks_needed\n\n        # Increment the smallest bar size\n        smallest_bar_size += 1\n\n    # Format the output\n    output = f\"{smallest_bar_size} {smallest_breaks}\"\n\n    return output\n"
    },
    {
        "number": 4812,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    common_word = input_list[0]\n    ending_lists = []\n    for i in range(1, len(input_list), 2):\n        ending_lists.append(input_list[i].split())\n    phrases = input_list[-1].split()\n\n    def find_rhyming_phrase(phrase):\n        words = phrase.split()\n        if len(words) == 2:\n            return words[0][-1] == words[1][-1]\n        elif len(words) == 3:\n            return words[0][-1] == words[2][-1]\n        else:\n            return False\n\n    def find_rhyming_ending(ending_list, ending):\n        for ending_set in ending_list:\n            for e in ending_set:\n                if e == ending:\n                    return True\n        return False\n\n    for phrase in phrases:\n        if find_rhyming_phrase(phrase):\n            print('YES')\n        else:\n            print('NO')\n"
    },
    {
        "number": 4813,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    word, permutation = stdin.split('\\n')\n    permutation = list(permutation)\n    word = list(word)\n    guessed_letters = []\n\n    for letter in permutation:\n        if letter in word:\n            index = word.index(letter)\n            word[index] = None\n            guessed_letters.append(letter)\n\n    if all(letter is None for letter in word):\n        return \"WIN\"\n    else:\n        return \"LOSE\"\n"
    },
    {
        "number": 4814,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    N = int(stdin.splitlines()[0])\n    names = stdin.splitlines()[1:]\n\n    # Check if list is in increasing or decreasing order\n    increasing = True\n    decreasing = True\n    for i in range(1, N):\n        if names[i] < names[i-1]:\n            increasing = False\n        if names[i] > names[i-1]:\n            decreasing = False\n        if not increasing and not decreasing:\n            break\n\n    # Determine output\n    if increasing:\n        return \"INCREASING\"\n    elif decreasing:\n        return \"DECREASING\"\n    else:\n        return \"NEITHER\""
    },
    {
        "number": 4815,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, p, m = map(int, stdin.split()[:3])\n    participants = [input() for _ in range(n)]\n    scores = {}\n    for _ in range(m):\n        name, score = input().split()\n        if name in scores:\n            scores[name] += int(score)\n        else:\n            scores[name] = int(score)\n    winners = [name for name, score in scores.items() if score >= p]\n    if not winners:\n        return \"No winner!\"\n    else:\n        return \"\\n\".join(f\"{winner} wins!\" for winner in winners) "
    },
    {
        "number": 4816,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x, y, x1, y1, x2, y2 = map(int, stdin.split())\n\n    # Calculate the distance between the fence post and the house\n    dist_to_house = min(abs(x - x1), abs(x - x2), abs(y - y1), abs(y - y2))\n\n    # Calculate the distance from the fence post to the closest point on the house\n    closest_x = x1 if abs(x1 - x) < abs(x2 - x) else x2\n    closest_y = y1 if abs(y1 - y) < abs(y2 - y) else y2\n    dist_to_closest_point = abs(x - closest_x) + abs(y - closest_y)\n\n    # Calculate the minimum distance from the fence post to the house\n    min_distance = min(dist_to_house, dist_to_closest_point)\n\n    return f\"{min_distance:.3f}\"\n"
    },
    {
        "number": 4817,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin)\n    digits = [int(d) for d in str(X)]\n    digits.sort()\n    digits[-1] += 1\n    for i in range(len(digits)-1, -1, -1):\n        if digits[i] == 10:\n            digits[i] = 0\n            if i == 0:\n                digits.insert(0, 1)\n            else:\n                digits[i-1] += 1\n        else:\n            break\n    result = int(''.join(str(d) for d in digits))\n    return str(result) if result > X else '0'\n"
    },
    {
        "number": 4818,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    tasks_time = list(map(int, input_list[1].split()))\n    intervals_time = list(map(int, input_list[2].split()))\n\n    intervals_time.sort()\n    tasks_time.sort()\n\n    max_tasks = 0\n    i, j = 0, 0\n\n    while i < n and j < m:\n        if tasks_time[i] < intervals_time[j]:\n            i += 1\n        else:\n            j += 1\n            max_tasks += 1\n\n    return str(max_tasks)\n"
    },
    {
        "number": 4819,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    numbers = [int(line.strip()) % 42 for line in stdin.split('\\n')[:10]]\n    distinct_numbers = set(numbers)\n    return str(len(distinct_numbers))\n"
    },
    {
        "number": 4820,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    N = int(input_data[0])\n    b = int(input_data[1])\n\n    if N * 1000 <= b:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 4821,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    S = stdin.strip()\n\n    # Initialize missing cards count for each suit\n    missing_cards_count = {'P': 0, 'K': 0, 'H': 0, 'T': 0}\n\n    # Check for duplicates\n    if len(set(S)) != len(S):\n        return \"GRESKA\"\n\n    # Check for complete deck\n    if len(S) != 52:\n        return \"GRESKA\"\n\n    # Count missing cards for each suit\n    for card in S:\n        missing_cards_count[card[0]] += 1\n\n    # Output missing cards count for each suit\n    return \" \".join(str(missing_cards_count[suit]) for suit in ['P', 'K', 'H', 'T'])"
    },
    {
        "number": 4822,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R, S, K = map(int, stdin.split()[:3])\n    picture = stdin.split('\\n')[1:]\n    flies = [(i, j) for i, row in enumerate(picture) for j, pixel in enumerate(row) if pixel == '*']\n    max_flies = 0\n    max_shot = None\n\n    for fly in flies:\n        racket_x, racket_y = fly\n        for dx in range(-K, K+1):\n            for dy in range(-K, K+1):\n                if 0 <= racket_x + dx < R and 0 <= racket_y + dy < S:\n                    flies_in_racket = sum(1 for i in range(racket_x, racket_x + dx + 1) for j in range(racket_y, racket_y + dy + 1) if (i, j) in flies)\n                    if flies_in_racket > max_flies:\n                        max_flies = flies_in_racket\n                        max_shot = (racket_x, racket_y, dx, dy)\n\n    output = f\"{max_flies}\\n\"\n    for i in range(R):\n        row = picture[i]\n        for j in range(S):\n            if (i, j) == (max_shot[0], max_shot[1]):\n                output += \"+\"\n            elif (i, j) in flies:\n                output += \"*\"\n            else:\n                output += \".\"\n        output += \"\\n\"\n\n    for i in range(max_shot[2]+1):\n        output += \"-\" * (2*K + 1) + \"\\n\"\n    output += \"|\" + \" \" * (2*K + 1) + \"|\\n\"\n    for i in range(max_shot[3]+1):\n        output += \"-\" * (2*K + 1) + \"\\n\"\n\n    return output\n"
    },
    {
        "number": 4823,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    ranks = {'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13}\n    suits = {'C': 0, 'D': 1, 'H': 2, 'S': 3}\n    hand = stdin.split()\n    ranks_count = {}\n    for card in hand:\n        rank = card[0]\n        suit = card[1]\n        if rank in ranks_count:\n            ranks_count[rank] += 1\n        else:\n            ranks_count[rank] = 1\n    max_count = 0\n    for count in ranks_count.values():\n        if count > max_count:\n            max_count = count\n    return max_count"
    },
    {
        "number": 4824,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def rotate(piece, k):\n        return [[piece[y][x] for y in range(len(piece))] for x in range(len(piece[0]))][::-1][:k]\n\n    def can_fit(field, piece, x, y):\n        for i in range(len(piece)):\n            for j in range(len(piece[0])):\n                if piece[i][j] and y + i >= 0 and x + j >= 0 and x + j < len(field) and y + i < len(field[0]) and field[x + j][y + i]:\n                    return False\n        return True\n\n    def count_configurations(field, piece, x, y, k):\n        if k == 0:\n            return 1\n        count = 0\n        for i in range(4):\n            rotated_piece = rotate(piece, i)\n            for j in range(len(field)):\n                if can_fit(field, rotated_piece, j, y):\n                    count += count_configurations(field, rotated_piece, j, y + len(rotated_piece), k - 1)\n        return count\n\n    C, P = map(int, stdin.split()[:2])\n    field = list(map(int, stdin.split()[2:]))\n    piece = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n\n    result = count_configurations(field, piece, 0, 0, P - 1)\n    return str(result)\n"
    },
    {
        "number": 4825,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    new_alphabet = {\n        'a': '@',\n        'n': '[]\\\\[]',\n        'b': '8',\n        'o': '0',\n        'c': '(',\n        'p': '|D',\n        'd': '|)',\n        'q': '(,)',\n        'e': '3',\n        'r': '|Z',\n        'f': '#',\n        's': '$',\n        'g': '6',\n        't': ']['\n    }\n\n    result = []\n    for char in stdin:\n        if char.isalpha():\n            if char.lower() in new_alphabet:\n                result.append(new_alphabet[char.lower()])\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n\n    return ''.join(result)\n"
    },
    {
        "number": 4826,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if N % 2 == 0:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n"
    },
    {
        "number": 4827,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def name_number(num: int) -> str:\n        if num == 1:\n            return \"one\"\n        elif num == 2:\n            return \"two\"\n        elif num == 3:\n            return \"three\"\n        elif num == 4:\n            return \"four\"\n        elif num == 5:\n            return \"five\"\n        elif num == 6:\n            return \"six\"\n        elif num == 7:\n            return \"seven\"\n        elif num == 8:\n            return \"eight\"\n        elif num == 9:\n            return \"nine\"\n        elif num == 10:\n            return \"ten\"\n        elif num == 11:\n            return \"eleven\"\n        elif num == 12:\n            return \"twelve\"\n        elif num == 13:\n            return \"thirteen\"\n        elif num == 14:\n            return \"fourteen\"\n        elif num == 15:\n            return \"fifteen\"\n        elif num == 16:\n            return \"sixteen\"\n        elif num == 17:\n            return \"seventeen\"\n        elif num == 18:\n            return \"eighteen\"\n        elif num == 19:\n            return \"nineteen\"\n        elif num == 20:\n            return \"twenty\"\n        elif num == 30:\n            return \"thirty\"\n        elif num == 40:\n            return \"forty\"\n        elif num == 50:\n            return \"fifty\"\n        elif num == 60:\n            return \"sixty\"\n        elif num == 70:\n            return \"seventy\"\n        elif num == 80:\n            return \"eighty\"\n        elif num == 90:\n            return \"ninety\"\n        else:\n            return \"onehundred\" + name_number(num % 100)\n\n    def count_letters(sentence: str) -> int:\n        return sum(len(word) for word in sentence.split())\n\n    def find_min_number(sentence: str) -> int:\n        count = count_letters(sentence)\n        for i in range(1, count + 1):\n            if name_number(i) == sentence.replace(\"$\", name_number(i), 1):\n                return i\n        return -1\n\n    N = int(stdin.readline())\n    sentence = \"\"\n    for _ in range(N):\n        sentence += stdin.readline().strip() + \" \"\n    min_number = find_min_number(sentence)\n    if min_number == -1:\n        return \"No valid sentence found\"\n    else:\n        return sentence.replace(\"$\", name_number(min_number), 1) "
    },
    {
        "number": 4828,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    nop_count = 0\n    nop_needed = 0\n    instructions = stdin.split()\n    for i in range(len(instructions)):\n        if i % 4 != 0:\n            nop_count += 1\n        else:\n            nop_needed = max(nop_needed, nop_count)\n            nop_count = 0\n    nop_needed = max(nop_needed, nop_count)\n    return nop_needed"
    },
    {
        "number": 4829,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    left_tines = int(input_data[0])\n    right_tines = int(input_data[1])\n\n    if left_tines == 0 and right_tines == 0:\n        return \"Not a moose\"\n\n    if left_tines == right_tines:\n        points = left_tines * 2\n        return f\"Even {points}\"\n\n    if left_tines > right_tines:\n        points = left_tines * 2 + right_tines\n        return f\"Odd {points}\"\n\n    points = right_tines * 2 + left_tines\n    return f\"Odd {points}\"\n"
    },
    {
        "number": 4830,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def t9_input(word: str, key_presses: str) -> bool:\n        key_presses = key_presses.replace('2', 'abc')\n        key_presses = key_presses.replace('3', 'def')\n        key_presses = key_presses.replace('4', 'ghi')\n        key_presses = key_presses.replace('5', 'jkl')\n        key_presses = key_presses.replace('6', 'mno')\n        key_presses = key_presses.replace('7', 'pqrs')\n        key_presses = key_presses.replace('8', 'tuv')\n        key_presses = key_presses.replace('9', 'wxyz')\n\n        for i, char in enumerate(word):\n            if char not in key_presses[i]:\n                return False\n        return True\n\n    N, *dictionary = stdin.split('\\n')\n    N = int(N)\n    words = set(dictionary)\n    key_presses = stdin.split('\\n')[-1]\n\n    count = 0\n    for word in words:\n        if t9_input(word, key_presses):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 4831,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    word = stdin.upper()\n    result = \"\"\n    frame_type = \"Peter Pan\"\n    for i, char in enumerate(word):\n        if i % 3 == 0:\n            frame_type = \"Wendy\"\n        if frame_type == \"Peter Pan\":\n            result += \"..#..\\n.#.#.\\n#.{}.#\\n.#.#.\\n..#..\\n\".format(char)\n        else:\n            result += \"..*..\\n.*.*.\\n*.{}.*\\n.*.*.\\n..*..\\n\".format(char)\n    return result"
    },
    {
        "number": 4832,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R = int(stdin)\n\n    # Calculate the area of a circle with radius R in normal (Euclidian) geometry\n    area_normal = 3.14 * R ** 2\n\n    # Calculate the area of a circle with radius R in taxicab geometry\n    area_taxicab = (2 * R) ** 2\n\n    # Output the results\n    return f\"{area_normal}\\n{area_taxicab}\"\n"
    },
    {
        "number": 4833,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    expenses = list(map(int, input_list[1].split()))\n\n    total_expenses = sum(expenses)\n\n    return str(total_expenses)\n"
    },
    {
        "number": 4834,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    N = int(stdin.splitlines()[0])\n    team_times = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize variables\n    min_time = 0\n    max_time = 0\n\n    # Iterate through teams\n    for i in range(N):\n        # Calculate max time for team i\n        max_time = max(max_time, team_times[i])\n\n        # If max time is greater than min time, update min time\n        if max_time > min_time:\n            min_time = max_time\n\n    # Add the time required for Ante and Goran to do their lectures\n    min_time += max(team_times)\n\n    # Return the required number from the task\n    return str(min_time)"
    },
    {
        "number": 4835,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    t, N, M = map(int, stdin.split())\n    grid = [list(input()) for _ in range(N)]\n\n    def is_safe(x, y):\n        if 0 <= x < N and 0 <= y < M and grid[x][y] == '0':\n            return True\n        return False\n\n    def bfs(start_x, start_y):\n        visited = [[False] * M for _ in range(N)]\n        visited[start_x][start_y] = True\n        queue = [(start_x, start_y, 0)]\n\n        while queue:\n            x, y, steps = queue.pop(0)\n\n            if x == N - 1 or y == M - 1:\n                return steps\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n\n                if is_safe(nx, ny):\n                    if not visited[nx][ny]:\n                        visited[nx][ny] = True\n                        queue.append((nx, ny, steps + 1))\n\n        return -1\n\n    start_x, start_y = None, None\n    for x in range(N):\n        for y in range(M):\n            if grid[x][y] == 'S':\n                start_x, start_y = x, y\n                break\n        if start_x is not None:\n            break\n\n    if start_x is None:\n        return \"NOT POSSIBLE\"\n\n    steps = bfs(start_x, start_y)\n    if steps == -1:\n        return \"NOT POSSIBLE\"\n    else:\n        return steps // t\n"
    },
    {
        "number": 4836,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, C = map(int, input_data[0].split())\n    weights = list(map(int, input_data[1].split()))\n\n    # Initialize variables\n    dp = [0] * (C + 1)\n    dp[0] = 1\n\n    # Iterate through the weights and update the dp array\n    for weight in weights:\n        for i in range(C, weight - 1, -1):\n            dp[i] = max(dp[i], dp[i - weight] + dp[i - weight + 1])\n\n    # The maximum possible amount of different fruits that Mislav can eat is the last element of the dp array\n    result = dp[-1]\n\n    return str(result)\n"
    },
    {
        "number": 4837,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    R = int(input_list[0])\n    Sven_symbols = input_list[1]\n    N = int(input_list[2])\n    friends_symbols = input_list[3:]\n\n    score = 0\n    max_score = 0\n\n    for i in range(R):\n        sven_symbol = Sven_symbols[i]\n        sven_score = 0\n        max_sven_score = 0\n\n        for j in range(N):\n            friend_symbol = friends_symbols[j][i]\n            if sven_symbol == friend_symbol:\n                sven_score += 1\n                max_sven_score += 1\n            elif (sven_symbol == 'S' and friend_symbol == 'P') or (sven_symbol == 'P' and friend_symbol == 'R') or (sven_symbol == 'R' and friend_symbol == 'S'):\n                sven_score += 2\n                max_sven_score += 2\n            else:\n                sven_score += 0\n                max_sven_score += 2\n\n        score += sven_score\n        max_score += max_sven_score\n\n    output = f\"{score}\\n{max_score}\"\n    return output\n"
    },
    {
        "number": 4838,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    times = [int(time) for time in input_data[1:]]\n\n    timer = 0\n    is_running = False\n\n    for time in times:\n        if is_running:\n            timer += 1\n        if time == 0:\n            is_running = not is_running\n\n    if is_running:\n        return \"Still running\"\n    else:\n        return str(timer)\n"
    },
    {
        "number": 4839,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    canister_helium = list(map(int, input_data[1].split()))\n\n    # Sort the canisters by their helium content\n    canister_helium.sort()\n\n    # Initialize the balloon capacities and helium fractions\n    balloon_capacities = list(range(1, n+1))\n    balloon_fractions = [0] * n\n\n    # Iterate through the canisters and assign them to the balloons\n    for canister_helium_content in canister_helium:\n        # Find the smallest balloon that can still be filled\n        smallest_balloon = 0\n        while smallest_balloon < n and balloon_capacities[smallest_balloon] <= balloon_fractions[smallest_balloon]:\n            smallest_balloon += 1\n\n        # If there are no more balloons that can be filled, the problem is impossible\n        if smallest_balloon == n:\n            return \"impossible\"\n\n        # Assign the canister helium content to the smallest balloon\n        balloon_fractions[smallest_balloon] += canister_helium_content\n        balloon_capacities[smallest_balloon] -= canister_helium_content\n\n    # Calculate the maximum fraction that can be filled without exploding\n    max_fraction = min(balloon_fractions) / min(balloon_capacities)\n\n    return round(max_fraction, 6)\n"
    },
    {
        "number": 4840,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    a1, b1, a2, b2 = map(int, input_data[0].split())\n    a3, b3, a4, b4 = map(int, input_data[1].split())\n\n    # Calculate the probability of winning for each player\n    p1 = (b1 - a1 + 1) * (b1 - a1 + 2) / 2\n    p2 = (b2 - a2 + 1) * (b2 - a2 + 2) / 2\n    p3 = (b3 - a3 + 1) * (b3 - a3 + 2) / 2\n    p4 = (b4 - a4 + 1) * (b4 - a4 + 2) / 2\n\n    # Determine the winner\n    if p1 > p2:\n        if p1 > p3:\n            if p1 > p4:\n                return \"Gunnar\"\n            else:\n                return \"Tie\"\n        else:\n            if p3 > p4:\n                return \"Emma\"\n            else:\n                return \"Tie\"\n    else:\n        if p2 > p3:\n            if p2 > p4:\n                return \"Emma\"\n            else:\n                return \"Tie\"\n        else:\n            if p3 > p4:\n                return \"Gunnar\"\n            else:\n                return \"Tie\"\n"
    },
    {
        "number": 4841,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1].split()\n    count = 0\n    for word in words:\n        if word == \"mumble\":\n            count = 0\n        else:\n            count += int(word)\n    if count == n:\n        return \"makes sense\"\n    else:\n        return \"something is fishy\""
    },
    {
        "number": 4842,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *values = map(int, stdin.split())\n    values = sorted(set(values))\n    differences = [values[i+1] - values[i] for i in range(n-1)]\n    degree = 1\n    while len(set(differences)) == 1:\n        degree += 1\n        differences = [values[i+degree] - values[i] for i in range(n-degree)]\n    d = degree - 1\n    v_nplus1 = values[-1] + differences[-1]\n    return f\"{d} {v_nplus1}\"\n"
    },
    {
        "number": 4843,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_position(x, y, queens):\n        for qx, qy in queens:\n            if qx == x or qy == y:\n                return False\n            if abs(qx - x) == abs(qy - y):\n                return False\n        return True\n\n    def solve(queens, n):\n        if len(queens) == n:\n            return \"CORRECT\"\n        for x in range(n):\n            for y in range(n):\n                if is_valid_position(x, y, queens):\n                    queens.append((x, y))\n                    result = solve(queens, n)\n                    if result == \"CORRECT\":\n                        return result\n                    queens.pop()\n        return \"INCORRECT\"\n\n    N = int(stdin.splitlines()[0])\n    queens = []\n    for i in range(1, N + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        queens.append((x, y))\n    return solve(queens, N)"
    },
    {
        "number": 4844,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    matrix = [[int(x) for x in input_data[i+1].split()] for i in range(N)]\n\n    # Initialize the array with all zeros\n    a = [0] * N\n\n    # Iterate through the matrix and update the array\n    for i in range(N):\n        for j in range(N):\n            if matrix[i][j] == 1:\n                a[i] |= a[j]\n\n    # Convert the array to a string and return it\n    return ' '.join(map(str, a))"
    },
    {
        "number": 4845,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    day, month = map(int, stdin.split())\n\n    # Calculate day of week\n    if month < 3:\n        month += 12\n        year = 2008\n    else:\n        year = 2009\n    day_of_week = (day + 13*(month+1)//5 + year-1) % 7\n\n    # Return day of week\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    return days[day_of_week] "
    },
    {
        "number": 4846,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    L = int(input_data[0])\n    D = int(input_data[1])\n    X = int(input_data[2])\n\n    N = None\n    M = None\n\n    for i in range(L, D+1):\n        if sum(int(digit) for digit in str(i)) == X:\n            if N is None:\n                N = i\n            M = i\n\n    return f\"{N}\\n{M}\"\n"
    },
    {
        "number": 4847,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def area_of_triangle(x1, y1, x2, y2, x3, y3):\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n        area = area_of_triangle(x1, y1, x2, y2, x3, y3)\n        area1 = area_of_triangle(x, y, x2, y2, x3, y3)\n        area2 = area_of_triangle(x1, y1, x, y, x3, y3)\n        area3 = area_of_triangle(x1, y1, x2, y2, x, y)\n        return abs(area - area1 - area2 - area3) < 1e-9\n\n    def count_trees_in_triangle(x1, y1, x2, y2, x3, y3, points):\n        count = 0\n        for x, y in points:\n            if is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n                count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    x1, y1 = map(int, lines[0].split())\n    x2, y2 = map(int, lines[1].split())\n    x3, y3 = map(int, lines[2].split())\n    N = int(lines[3])\n    points = [tuple(map(int, line.split())) for line in lines[4:]]\n\n    area = area_of_triangle(x1, y1, x2, y2, x3, y3)\n    trees_in_triangle = count_trees_in_triangle(x1, y1, x2, y2, x3, y3, points)\n\n    return f\"{area:.1f}\\n{trees_in_triangle}\" "
    },
    {
        "number": 4848,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    m = 2\n    while m < n:\n        if n % m != 0:\n            m += 1\n        else:\n            m += 1\n            n //= m\n    return str(m)\n"
    },
    {
        "number": 4849,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    blimp_list = stdin.split('\\n')\n    cia_blimps = []\n\n    for i, blimp in enumerate(blimp_list):\n        if 'FBI' in blimp:\n            cia_blimps.append(i)\n\n    if not cia_blimps:\n        return \"HE GOT AWAY!\"\n    else:\n        return ' '.join(map(str, cia_blimps))"
    },
    {
        "number": 4850,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def area(a, b, c):\n        s = (a + b + c) / 2\n        return (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\n    def min_length(a, b, c):\n        s = (a + b + c) / 2\n        return 2 * s\n\n    def max_length(a, b, c):\n        s = (a + b + c) / 2\n        return (a * b * c) / s\n\n    def is_valid(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def compute_min_length(triangles):\n        min_len = float('inf')\n        for a, b, c in triangles:\n            if not is_valid(a, b, c):\n                return -1\n            min_len = min(min_len, min_length(a, b, c))\n        return min_len\n\n    def compute_max_length(triangles):\n        max_len = 0\n        for a, b, c in triangles:\n            if not is_valid(a, b, c):\n                return -1\n            max_len = max(max_len, max_length(a, b, c))\n        return max_len\n\n    def compute_min_max_length(triangles):\n        min_len = compute_min_length(triangles)\n        max_len = compute_max_length(triangles)\n        return min_len, max_len\n\n    def main(stdin: str) -> str:\n        n = int(stdin.split()[0])\n        triangles = [tuple(map(int, input().split())) for _ in range(n)]\n        min_len, max_len = compute_min_max_length(triangles)\n        if min_len == -1:\n            return \"Impossible\"\n        elif max_len == 0:\n            return \"0\"\n        else:\n            return f\"{min_len:.4f}\"\n\n    return main(stdin)\n"
    },
    {
        "number": 4851,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.strip())\n    for i in range(n, 1000000000):\n        digits = [int(d) for d in str(i)]\n        if sum(digits) == i:\n            return str(i)\n    return \"No harshad number found\"\n"
    },
    {
        "number": 4852,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = list(stdin)\n    count = 0\n    for i in range(len(input_list)):\n        if input_list[i] == '+':\n            count += 1\n        else:\n            count = 0\n    return count + 1"
    },
    {
        "number": 4853,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    n = int(input_data[0])\n    a = [int(x) for x in input_data[1:]]\n\n    C = [0] * (n + 1)\n    C[n] = a[n]\n    for i in range(n - 1, -1, -1):\n        C[i] = a[i] + C[i + 1]\n\n    return \" \".join(str(x) for x in C)\n"
    },
    {
        "number": 4854,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, C = map(int, input_data[0].split())\n    message = list(map(int, input_data[1].split()))\n\n    sorted_message = sorted(message, key=lambda x: (-message.count(x), -message.index(x)))\n\n    return ' '.join(map(str, sorted_message))\n"
    },
    {
        "number": 4855,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, I = map(int, stdin.split())\n    bribes = I - A + 1\n    return str(bribes)\n"
    },
    {
        "number": 4856,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    numbers = stdin.split()\n    num1 = int(numbers[0])\n    num2 = int(numbers[1])\n\n    if num1 > num2:\n        return str(num1)[::-1]\n    else:\n        return str(num2)[::-1]\n"
    },
    {
        "number": 4857,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.strip()\n    l, w = map(int, input_str.split())\n\n    if not (0 < l <= 40 and 0 < w <= 1000):\n        return \"impossible\"\n\n    def is_valid(word: str) -> bool:\n        return sum(ord(c) - ord('a') + 1 for c in word) == w\n\n    for length in range(1, l + 1):\n        for word in itertools.product('abcdefghijklmnopqrstuvwxyz', repeat=length):\n            if is_valid(''.join(word)):\n                return ''.join(word)\n\n    return \"impossible\" "
    },
    {
        "number": 4858,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_pixel(frame, x, y):\n        return frame[y][x]\n\n    def set_pixel(frame, x, y, value):\n        frame[y][x] = value\n\n    def get_silhouette_pixels(frame, char):\n        return [(x, y) for y in range(len(frame)) for x in range(len(frame[0])) if frame[y][x] == char]\n\n    def extrapolate_silhouette(frame1, frame2, char):\n        silhouette1 = get_silhouette_pixels(frame1, char)\n        silhouette2 = get_silhouette_pixels(frame2, char)\n\n        if not silhouette1 or not silhouette2:\n            return frame2\n\n        x1, y1 = silhouette1[0]\n        x2, y2 = silhouette2[0]\n\n        dx = x2 - x1\n        dy = y2 - y1\n\n        result = [[' ' for _ in range(len(frame2[0]))] for _ in range(len(frame2))]\n\n        for x, y in silhouette2:\n            new_x = x1 + (x - x1) * dx / (dx + dy)\n            new_y = y1 + (y - y1) * dy / (dx + dy)\n            set_pixel(result, int(new_x), int(new_y), char)\n\n        return result\n\n    def print_frame(frame):\n        for line in frame:\n            print(''.join(line))\n        print()\n\n    stdin = stdin.split('\\n')\n    M, N, char = map(int, stdin[0].split())\n    frame1 = [list(line) for line in stdin[1:M + 1]]\n    frame2 = [list(line) for line in stdin[M + 2:]]\n\n    result = extrapolate_silhouette(frame1, frame2, char)\n    print_frame(result)\n"
    },
    {
        "number": 4859,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    b, d, c, l = map(int, stdin.split())\n    \n    if l < 4 * b + 2 * d + 2 * c:\n        return \"impossible\"\n    \n    solutions = []\n    \n    for i in range(1, l // 4 + 1):\n        for j in range(1, min(i, b) + 1):\n            k = (l - 4 * i - 2 * j) // 2\n            if k < 0 or k > min(i, d) or i + j + k != l // 4:\n                continue\n            solutions.append((i, j, k))\n    \n    solutions.sort()\n    \n    for solution in solutions:\n        print(f\"{solution[0]} {solution[1]} {solution[2]}\")\n    \n    return \"impossible\" if not solutions else \"\" "
    },
    {
        "number": 4860,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    recited_numbers = [int(line) for line in stdin.split('\\n')[1:]]\n\n    missing_numbers = set(range(1, 201)) - set(recited_numbers)\n\n    if not missing_numbers:\n        return \"good job\"\n    else:\n        return '\\n'.join(str(num) for num in sorted(missing_numbers))\n"
    },
    {
        "number": 4861,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def log2(x):\n        return math.log2(x)\n\n    def c_sqrt(d):\n        return (c * (2 ** (0.5 * d)))\n\n    n, p, s, v = map(float, stdin.split())\n    c = 1.5\n    t_algorithm = (n * (log2(n) ** c_sqrt(2)) / (p * 10**9))\n    t_distribute = (s * (1 + 1/c) / v)\n    t_total = t_algorithm + t_distribute\n\n    return f\"{t_total:.6f} {c:.6f}\"\n"
    },
    {
        "number": 4862,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if N == 0:\n        return \"0\"\n    elif N == 1:\n        return \"0\"\n    elif N == 2:\n        return \"1\"\n    else:\n        return str(N * (N-1) // 2)\n"
    },
    {
        "number": 4863,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    correct_answers = stdin.split('\\n')[1:]\n\n    score = 0\n    for i, answer in enumerate(correct_answers, start=1):\n        if answer.strip() == 'A':\n            if i == 1:\n                score += 1\n            else:\n                score += 2\n        elif answer.strip() == 'B':\n            if i == 2:\n                score += 1\n            else:\n                score += 2\n        elif answer.strip() == 'C':\n            if i == 3:\n                score += 1\n            else:\n                score += 2\n        elif answer.strip() == 'D':\n            if i == 4:\n                score += 1\n            else:\n                score += 2\n\n    return str(score)\n"
    },
    {
        "number": 4864,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    R, C, Z_R, Z_C = map(int, input_data[0].split())\n    article = [list(line) for line in input_data[1:]]\n\n    enlarged_article = [[' ' for _ in range(C * Z_C)] for _ in range(R * Z_R)]\n\n    for i in range(R):\n        for j in range(C):\n            for z_i in range(Z_R):\n                for z_j in range(Z_C):\n                    enlarged_article[i * Z_R + z_i][j * Z_C + z_j] = article[i][j]\n\n    output = '\\n'.join([''.join(row) for row in enlarged_article])\n    return output\n"
    },
    {
        "number": 4865,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def adjust_time(hour: int, minute: int, direction: str, minutes: int) -> str:\n        if direction == 'F':\n            minutes = minutes * -1\n        new_minute = minute + minutes\n        new_hour = hour\n        while new_minute >= 60:\n            new_minute -= 60\n            new_hour += 1\n        while new_minute < 0:\n            new_minute += 60\n            new_hour -= 1\n        return f\"{new_hour:02d} {new_minute:02d}\"\n\n    test_cases = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, test_cases + 1):\n        direction, minutes, hour, minute = stdin.splitlines()[i].split()\n        new_time = adjust_time(int(hour), int(minute), direction, int(minutes))\n        output.append(new_time)\n\n    return '\\n'.join(output)\n"
    },
    {
        "number": 4866,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Split the input string into month and date\n    month, date = stdin.split()\n\n    # Convert the month to its corresponding integer value\n    month_int = {\n        'JAN': 1, 'FEB': 2, 'MAR': 3, 'APR': 4, 'MAY': 5,\n        'JUN': 6, 'JUL': 7, 'AUG': 8, 'SEP': 9, 'OCT': 10,\n        'NOV': 11, 'DEC': 12\n    }[month]\n\n    # Convert the date to an integer\n    date_int = int(date)\n\n    # Check if the date is October 31 or December 25\n    if (month_int == 10 and date_int == 31) or (month_int == 12 and date_int == 25):\n        return 'yup'\n    else:\n        return 'nope'"
    },
    {
        "number": 4867,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    M, N = map(int, input_data[0].split())\n    U, L, R, D = map(int, input_data[1].split())\n    crossword = input_data[2:]\n\n    frame = '#' * (U + D) + '.' * (L + R)\n    frame_top = frame[:U]\n    frame_bottom = frame[-D:]\n    frame_left = frame[:L]\n    frame_right = frame[-R:]\n\n    result = []\n    for i in range(M + U + D):\n        if i < U or i >= M + U:\n            result.append(frame_top)\n        elif i < U + D:\n            result.append(frame_bottom)\n        else:\n            row = crossword[i - U - D]\n            row = row[:L] + '#' * (U + D) + row[-R:]\n            result.append(row)\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 4868,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Split the input string by newline characters\n    input_data = stdin.split('\\n')\n\n    # Initialize variables to store the input values\n    n = 0\n    m = 0\n    matrix = []\n\n    # Parse the input data\n    for line in input_data:\n        if line.startswith('n = '):\n            n = int(line.split(' = ')[1])\n        elif line.startswith('m = '):\n            m = int(line.split(' = ')[1])\n        elif line.startswith('matrix = ['):\n            # Parse the matrix data\n            matrix = [list(map(int, line.strip('matrix = [').strip(']').split(','))) for line in input_data[1:1 + m]]\n\n    # Initialize variables to store the output values\n    output_n = 0\n    output_m = 0\n    output_matrix = []\n\n    # Calculate the output values\n    output_n = n + m\n    output_m = m\n    output_matrix = [[0 for _ in range(output_n)] for _ in range(output_m)]\n\n    # Fill the output matrix with the input matrix values\n    for i in range(m):\n        for j in range(n):\n            output_matrix[i][j] = matrix[i][j]\n\n    # Format the output data\n    output_data = [f'n = {output_n}', f'm = {output_m}', 'matrix = [']\n    for i in range(output_m):\n        output_data.append(','.join(map(str, output_matrix[i])))\n    output_data.append(']')\n\n    # Join the output data into a single string\n    output = '\\n'.join(output_data)\n\n    return output "
    },
    {
        "number": 4869,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = list(map(float, stdin.split()))\n    A, N = input_values\n\n    if A > 100 or N > 1000:\n        return \"Need more materials!\"\n\n    # Calculate the area of the cage\n    cage_area = N * N\n\n    # Check if the cage area is equal to A\n    if cage_area == A:\n        return \"Diablo is happy!\"\n    else:\n        return \"Need more materials!\" "
    },
    {
        "number": 4870,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    f, s, g, u, d = map(int, stdin.split())\n\n    if s > g:\n        return \"use the stairs\"\n\n    if s == g:\n        return 0\n\n    if u > d:\n        return \"use the stairs\"\n\n    if s > f:\n        return \"use the stairs\"\n\n    if g > f:\n        return \"use the stairs\"\n\n    if s == 1:\n        if g == f:\n            return 1\n        else:\n            return \"use the stairs\"\n\n    if g == f:\n        return 1\n\n    if s == 2:\n        if g == f:\n            return 2\n        else:\n            return \"use the stairs\"\n\n    if g == 1:\n        return 1\n\n    if g == 2:\n        return 2\n\n    if s == g:\n        return 1\n\n    if s == g - 1:\n        return 2\n\n    if s == g - 2:\n        return 3\n\n    if s == g + 1:\n        return 2\n\n    if s == g + 2:\n        return 3\n\n    if s == 1 and g == f:\n        return 2\n\n    if s == 2 and g == f:\n        return 3\n\n    if s == 1 and g == f - 1:\n        return 3\n\n    if s == 2 and g == f - 1:\n        return 4\n\n    if s == 1 and g == f - 2:\n        return 4\n\n    if s == 2 and g == f - 2:\n        return 5\n\n    if s == 1 and g == f + 1:\n        return 3\n\n    if s == 2 and g == f + 1:\n        return 4\n\n    if s == 1 and g == f + 2:\n        return 4\n\n    if s == 2 and g == f + 2:\n        return 5\n\n    if s == 1 and g == f - 1:\n        return 3\n\n    if s == 2 and g == f - 1:\n        return 4\n\n    if s == 1 and g == f - 2:\n        return 4\n\n    if s == 2 and g == f - 2:\n        return 5\n\n    if s == 1 and g == f + 1:\n        return 3\n\n    if s == 2 and g == f + 1:\n        return 4\n\n    if s == 1 and g == f + 2:\n        return 4\n\n    if s == 2 and g == f + 2:\n        return 5\n\n    if s == 1 and g == f - 1:\n        return 3\n\n    if s == 2 and g == f - 1:\n        return 4\n\n    if s == 1 and g == f - 2:\n        return 4\n\n    if s == 2 and g == f - 2:\n        return 5\n\n    if s == 1 and g == f + 1:\n        return 3\n\n    if s == 2 and g == f + 1:\n        return 4\n\n    if s == 1 and g == f + 2:\n        return 4\n\n    if s == 2 and g == f + 2:\n        return 5\n\n    if s == 1 and g == f - 1:\n        return 3\n\n    if s == 2 and g == f - 1:\n        return 4\n\n    if s == 1 and g == f - 2:\n        return 4\n\n    if s == 2 and g == f - 2:\n        return 5\n\n    if s == 1 and g == f + 1:\n        return 3\n\n    if s == 2 and g == f + 1:\n        return 4\n\n    if s == 1 and g == f + 2:\n        return 4\n\n    if s == 2 and g == f + 2:\n        return 5\n\n    if s == 1 and g == f - 1:\n        return 3\n\n    if s == "
    },
    {
        "number": 4871,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    scores = sorted(map(int, stdin.split('\\n')[1:]), reverse=True)\n    \n    group_score = sum([scores[i] * (4/5)**i for i in range(n)]) / (5/4)\n    \n    new_group_scores = []\n    for i in range(n):\n        new_scores = scores[:i] + scores[i+1:]\n        new_group_score = sum([new_scores[j] * (4/5)**j for j in range(len(new_scores))]) / (5/4)\n        new_group_scores.append(new_group_score)\n    \n    avg_new_group_score = sum(new_group_scores) / n\n    \n    return f\"{group_score:.6f}\\n{avg_new_group_score:.6f}\"\n"
    },
    {
        "number": 4872,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *dirtiness = map(int, stdin.split())\n    dirtiness = sorted(dirtiness)\n\n    dirtiness_sum = sum(dirtiness)\n    cleanup_phases = 0\n\n    while dirtiness_sum >= 20:\n        cleanup_phases += 1\n        dirtiness_sum -= (365 - dirtiness[0])\n        dirtiness.pop(0)\n\n    return cleanup_phases\n"
    },
    {
        "number": 4873,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    W, H = map(int, input_data[0].split())\n    map_data = input_data[1:]\n\n    def is_safe(x, y):\n        if x < 0 or x >= W or y < 0 or y >= H:\n            return False\n        return map_data[y][x] != 'T'\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if map_data[y][x] == 'G':\n                return True\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if is_safe(x + dx, y + dy):\n                    queue.append((x + dx, y + dy))\n        return False\n\n    for y, row in enumerate(map_data):\n        if 'P' in row:\n            x = row.index('P')\n            break\n\n    safe_count = 0\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if is_safe(x + dx, y + dy):\n            safe_count += bfs(x + dx, y + dy)\n\n    return safe_count\n"
    },
    {
        "number": 4874,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    dance_grid = input_data[1:]\n\n    # Initialize variables\n    moves = 0\n    current_move = 0\n    blank_columns = 0\n\n    # Iterate through the dance grid\n    for row in dance_grid:\n        for col in row:\n            if col == '$':\n                current_move += 1\n            elif col == '_':\n                if current_move > 0:\n                    moves += 1\n                    current_move = 0\n            else:\n                raise ValueError(\"Invalid character in dance grid\")\n\n            if col == '_':\n                blank_columns += 1\n            else:\n                blank_columns = 0\n\n            if blank_columns == M:\n                moves += 1\n                current_move = 0\n                blank_columns = 0\n\n    # Add the last move if there is one\n    if current_move > 0:\n        moves += 1\n\n    return str(moves)\n"
    },
    {
        "number": 4875,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def pig_latin(word: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n        if word[0].lower() in vowels:\n            return word + 'yay'\n        else:\n            for i, letter in enumerate(word):\n                if letter.lower() in vowels:\n                    return word[i:].lower() + word[:i].lower() + 'ay'\n\n    output = []\n    for line in stdin.split('\\n'):\n        words = line.split()\n        pig_latin_words = [pig_latin(word) for word in words]\n        output.append(' '.join(pig_latin_words))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 4876,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_restaurant(menus: list) -> str:\n        for menu in menus:\n            soup = False\n            pancakes = False\n            for item in menu:\n                if item == \"pea soup\":\n                    soup = True\n                elif item == \"pancakes\":\n                    pancakes = True\n                if soup and pancakes:\n                    return menu[0]\n        return \"Anywhere is fine I guess\"\n\n    n = int(stdin.splitlines()[0])\n    menus = []\n    for i in range(1, n + 1):\n        k = int(stdin.splitlines()[i].split()[0])\n        menu = [stdin.splitlines()[i].split()[1:]]\n        for j in range(2, k + 2):\n            menu.append(stdin.splitlines()[i + j - 1].split())\n        menus.append(menu)\n\n    return find_restaurant(menus)\n"
    },
    {
        "number": 4877,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, h = map(int, stdin.split())\n    if a <= 0 or b <= 0 or h <= 0:\n        return \"Invalid input\"\n    if a < b or a > h:\n        return \"Invalid input\"\n    if b == a:\n        return 1\n    else:\n        return 1 + solution(str(a - b) + \" \" + str(b) + \" \" + str(h - a + b))\n"
    },
    {
        "number": 4878,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R1, S = map(int, stdin.split())\n    R2 = (S - R1) // 2\n    return str(R2)\n"
    },
    {
        "number": 4879,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = stdin.split()\n    if (a == \"North\" and b == \"South\") or (a == \"East\" and b == \"West\"):\n        if c == \"North\" or c == \"East\":\n            return \"Yes\"\n        else:\n            return \"No\"\n    elif (a == \"North\" and b == \"West\") or (a == \"East\" and b == \"North\"):\n        if c == \"South\" or c == \"West\":\n            return \"Yes\"\n        else:\n            return \"No\"\n    else:\n        return \"No\""
    },
    {
        "number": 4880,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    plaintext = input_data[1]\n    ciphertext = input_data[2]\n\n    # Create the encryption key\n    key = [0] * 26\n    for i in range(n):\n        key[ord(plaintext[i]) - ord('a')] = i\n\n    # Decrypt the ciphertext\n    decrypted = ''\n    for i in range(m):\n        shift = key[ord(ciphertext[i]) - ord('a')]\n        decrypted += chr(((ord(ciphertext[i]) - ord('a') - shift) % 26) + ord('a'))\n\n    return decrypted "
    },
    {
        "number": 4881,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    if N % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"
    },
    {
        "number": 4882,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    costs = input_data[1:]\n\n    for cost in costs:\n        digits = len(str(cost))\n        print(digits)\n"
    },
    {
        "number": 4883,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    translations = {}\n    for i in range(1, len(input_data), 2):\n        a, b = input_data[i].split()\n        translations[a] = b\n\n    for i in range(len(input_data) // 2 + 1, len(input_data)):\n        original, deciphered = input_data[i].split()\n        if len(original) != len(deciphered):\n            print(\"no\")\n            continue\n\n        for i in range(len(original)):\n            if original[i] not in translations:\n                print(\"no\")\n                break\n            if deciphered[i] != translations[original[i]]:\n                print(\"no\")\n                break\n        else:\n            print(\"yes\")\n"
    },
    {
        "number": 4884,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, P = map(int, input_data[0].split())\n    contestants = input_data[1:]\n\n    carrots_handed_out = 0\n\n    for contestant in contestants:\n        if \"good at solving difficult problems\" in contestant:\n            carrots_handed_out += 1\n        if \"good at treating digestive problems\" in contestant:\n            carrots_handed_out += 1\n\n    return str(carrots_handed_out)\n"
    },
    {
        "number": 4885,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    chessboard = stdin.split('\\n')\n    white_pieces = []\n    black_pieces = []\n\n    for row in chessboard:\n        for col in row:\n            if col == 'K':\n                white_pieces.append('K')\n            elif col == 'Q':\n                white_pieces.append('Q')\n            elif col == 'R':\n                white_pieces.append('R')\n            elif col == 'B':\n                white_pieces.append('B')\n            elif col == 'N':\n                white_pieces.append('N')\n            elif col == 'P':\n                white_pieces.append('P')\n            elif col == 'k':\n                black_pieces.append('K')\n            elif col == 'q':\n                black_pieces.append('Q')\n            elif col == 'r':\n                black_pieces.append('R')\n            elif col == 'b':\n                black_pieces.append('B')\n            elif col == 'n':\n                black_pieces.append('N')\n            elif col == 'p':\n                black_pieces.append('P')\n\n    white_pieces.sort()\n    black_pieces.sort()\n\n    output = \"White: \" + \",\".join(white_pieces) + \"\\nBlack: \" + \",\".join(black_pieces)\n\n    return output\n"
    },
    {
        "number": 4886,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, K = map(int, stdin.split())\n\n    # Check if N is a prime number\n    if N == 2 or N == 3:\n        return \"Your wish is granted!\"\n    elif N % 2 == 0 or N % 3 == 0:\n        return \"You will become a flying monkey!\"\n\n    # Check if K is greater than or equal to the number of possible questions\n    if K >= N * (N - 1) // 2:\n        return \"Your wish is granted!\"\n\n    # Check if there exists a subset of questions that can determine the secret number\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if i != j and (i + j) % 2 == 0:\n                return \"You will become a flying monkey!\"\n\n    return \"Your wish is granted!\"\n"
    },
    {
        "number": 4887,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    area = int(input_data[0])\n\n    # Calculate the length of the fence needed\n    fence_length = 2 * (area ** 0.5)\n\n    # Round the fence length to 6 decimal places\n    fence_length = round(fence_length, 6)\n\n    return str(fence_length)\n"
    },
    {
        "number": 4888,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    n, T = map(int, input_data[0].split())\n    tasks = list(map(int, input_data[1].split()))\n\n    total_time = sum(tasks)\n    if total_time > T:\n        return 0\n    else:\n        return n\n"
    },
    {
        "number": 4889,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    lengths = [int(length) for length in input_data[1:]]\n\n    total_length = sum(lengths)\n    fused_length = total_length\n\n    for i in range(N - 1):\n        fused_length -= 1\n\n    jumbo_javelin_length = fused_length\n\n    return str(jumbo_javelin_length)\n"
    },
    {
        "number": 4890,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m, s, d = map(int, input_data[0].split())\n    c = list(map(int, input_data[1].split()))\n\n    # Initialize variables\n    new_bottles = n\n    slots = [0] * s\n    refill_scheme = [0] * s\n\n    # Calculate the probability of getting a cold soda for each student\n    probabilities = [0] * m\n    for i in range(s):\n        probabilities[i % m] += c[i] / d\n\n    # Find the slot with the highest probability of getting a cold soda\n    max_probability = max(probabilities)\n\n    # If it's impossible to get a cold soda for all students, return \"impossible\"\n    if max_probability < 1:\n        return \"impossible\"\n\n    # Otherwise, fill the fridge with the new bottles and refill the slots\n    for i in range(s):\n        if probabilities[i] == max_probability:\n            refill_scheme[i] = new_bottles\n            new_bottles = 0\n        else:\n            refill_scheme[i] = 0\n\n    # Output the refill scheme\n    return ' '.join(map(str, refill_scheme)) "
    },
    {
        "number": 4891,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = list(map(int, stdin.split()))\n    kings, queens, rooks, bishops, knights, pawns = input_list\n\n    # Calculate the total number of pieces in the set\n    total_pieces = kings + queens + rooks * 2 + bishops * 2 + knights * 2 + pawns * 8\n\n    # Calculate the expected number of pieces in the set\n    expected_pieces = 1 + 1 + 2 + 2 + 2 + 8\n\n    # Calculate the difference between the total and expected number of pieces\n    diff = expected_pieces - total_pieces\n\n    # Calculate the number of pieces to add or remove for each type\n    kings_diff = diff if diff > 0 else -diff\n    queens_diff = diff if diff > 0 else -diff\n    rooks_diff = diff // 2 if diff > 0 else -diff // 2\n    bishops_diff = diff // 2 if diff > 0 else -diff // 2\n    knights_diff = diff // 2 if diff > 0 else -diff // 2\n    pawns_diff = diff // 8 if diff > 0 else -diff // 8\n\n    # Create the output string\n    output = f\"{kings_diff} {queens_diff} {rooks_diff} {bishops_diff} {knights_diff} {pawns_diff}\"\n\n    return output "
    },
    {
        "number": 4892,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_probability(password: str, probabilities: list) -> float:\n        for p in probabilities:\n            if p[0] == password:\n                return p[1]\n        return 0\n\n    def expected_attempts(probabilities: list) -> float:\n        total_probability = sum([p[1] for p in probabilities])\n        return sum([p[1] * (1 / p[1]) for p in probabilities]) / total_probability\n\n    def optimal_order(probabilities: list) -> list:\n        sorted_probabilities = sorted(probabilities, key=lambda x: x[1], reverse=True)\n        return [p[0] for p in sorted_probabilities]\n\n    def find_password(passwords: list, probabilities: list) -> int:\n        optimal_order_passwords = optimal_order(probabilities)\n        attempts = 0\n        for password in optimal_order_passwords:\n            if password in passwords:\n                attempts += 1\n                passwords.remove(password)\n        return attempts\n\n    N, *probabilities = stdin.split('\\n')\n    N = int(N)\n    probabilities = [p.split() for p in probabilities]\n    probabilities = [(p[0], float(p[1])) for p in probabilities]\n\n    expected_attempts_value = expected_attempts(probabilities)\n    return f\"{expected_attempts_value:.4f}\"\n"
    },
    {
        "number": 4893,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, p = map(int, stdin.split()[0:2])\n    distances = list(map(int, stdin.split()[2:]))\n\n    # Calculate the minimum distance to the car directly in front\n    min_distance = 0\n    for i in range(n):\n        min_distance += distances[i] * (p * (n - i) + 1)\n\n    # Calculate the minimum distance to the car in front\n    min_distance += distances[n] * (p * (n + 1) + 1)\n\n    # Divide by the number of cars between you and the car in front\n    min_distance /= (p * (n + 1) + 1)\n\n    return str(min_distance)\n"
    },
    {
        "number": 4894,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_lines = stdin.split('\\n')\n    num_notes = int(input_lines[0])\n    notes = input_lines[1].split()\n\n    # Define the note durations\n    durations = {'': 1, '2': 2, '3': 3, '4': 4, '6': 6, '8': 8, '16': 16}\n\n    # Define the staff lines\n    staff_lines = ['G:', 'F:', 'E:', 'D:', 'C:', 'B:', 'A:', 'g:', 'f:', 'e:', 'd:', 'c:', 'b:', 'a:']\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g': 11, 'a': 12}\n\n    # Define the note positions on the staff\n    note_positions = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6, 'c': 7,"
    },
    {
        "number": 4895,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sticks = list(map(int, input_data[1].split()))\n\n    if N < 3:\n        return \"impossible\"\n\n    sticks.sort()\n\n    for i in range(N - 2):\n        a, b, c = sticks[i], sticks[i + 1], sticks[i + 2]\n        if a + b > c and a + c > b and b + c > a:\n            return \"possible\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 4896,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split()\n    N = int(input_list[0])\n    widths = [int(width) for width in input_list[1:]]\n\n    towers = 1\n    current_width = widths[0]\n\n    for width in widths[1:]:\n        if width > current_width:\n            towers += 1\n            current_width = width\n\n    return str(towers)\n"
    },
    {
        "number": 4897,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def time_to_seconds(time: str) -> float:\n        return float(time)\n\n    def seconds_to_time(seconds: float) -> str:\n        return f\"{seconds:.2f}\"\n\n    def calculate_team_time(team: list[float]) -> float:\n        return sum(team)\n\n    def find_best_team(runners: list[tuple[str, float, float]]) -> tuple[list[str], float]:\n        runners.sort(key=lambda x: x[1])\n        team = [runners[0][0]]\n        team_time = runners[0][1]\n        for i in range(1, 4):\n            runner_time = runners[i][2]\n            if runner_time < team_time:\n                team.append(runners[i][0])\n                team_time += runner_time\n            else:\n                break\n        return team, team_time\n\n    def main(input_data: str) -> str:\n        n, *runners = input_data.split(\"\\n\")\n        n = int(n)\n        runners = [tuple(line.split()) for line in runners]\n        runners = [(name, time_to_seconds(a_i), time_to_seconds(b_i)) for name, a_i, b_i in runners]\n\n        team, team_time = find_best_team(runners)\n        team_time_str = seconds_to_time(team_time)\n\n        output = [team_time_str]\n        output.extend(team)\n        return \"\\n\".join(output)\n\n    return main(stdin)\n"
    },
    {
        "number": 4898,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    minions_preferences = [list(map(int, line.split())) for line in input_data[1:]]\n\n    minions_preferences.sort(key=lambda x: x[1] - x[0])\n\n    rooms = []\n    current_room = [minions_preferences[0]]\n\n    for minion in minions_preferences[1:]:\n        if minion[1] <= current_room[-1][1]:\n            current_room.append(minion)\n        else:\n            rooms.append(current_room)\n            current_room = [minion]\n\n    rooms.append(current_room)\n\n    return len(rooms)\n"
    },
    {
        "number": 4899,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_str = stdin.strip()\n    if input_str.startswith(\"he\") and input_str.endswith(\"ey\"):\n        return \"hee\" + \"e\" * (len(input_str) - 3) + \"eey\"\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 4900,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    distance_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(1, n+1):\n        row = list(map(int, input_data[i].split()))\n        for j in range(n):\n            distance_matrix[i-1][j] = row[j]\n            distance_matrix[j][i-1] = row[j]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                if distance_matrix[i][k] + distance_matrix[k][j] < distance_matrix[i][j]:\n                    distance_matrix[i][j] = distance_matrix[i][k] + distance_matrix[k][j]\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            for k in range(n):\n                if distance_matrix[i][k] + distance_matrix[k][j] == distance_matrix[i][j]:\n                    print(i+1, k+1)\n                    print(k+1, j+1)\n                    break\n            else:\n                continue\n            break\n"
    },
    {
        "number": 4901,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def divide_and_rotate(message: str) -> tuple:\n        half = len(message) // 2\n        first_half = message[:half]\n        second_half = message[half:]\n        rotation_value = sum(ord(char) - 64 for char in first_half)\n        rotated_first_half = ''.join(chr(((ord(char) - 64 + rotation_value) % 26) + 64) for char in first_half)\n        rotated_second_half = ''.join(chr(((ord(char) - 64 + rotation_value) % 26) + 64) for char in second_half)\n        return rotated_first_half, rotated_second_half\n\n    def merge_and_decrypt(first_half: str, second_half: str) -> str:\n        decrypted_first_half = ''.join(chr(((ord(first_half[i]) - 64 + ord(second_half[i]) - 64) % 26) + 64) for i in range(len(first_half)))\n        decrypted_second_half = ''.join(chr(((ord(second_half[i]) - 64 + ord(first_half[i]) - 64) % 26) + 64) for i in range(len(second_half)))\n        return decrypted_first_half + decrypted_second_half\n\n    first_half, second_half = divide_and_rotate(stdin)\n    decrypted_message = merge_and_decrypt(first_half, second_half)\n    return decrypted_message\n"
    },
    {
        "number": 4902,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_palindrome(word: str) -> bool:\n        return word == word[::-1]\n\n    def is_peragram(word: str) -> bool:\n        palindromes = ['a', 'egg', 'level', 'rotor', 'civic', 'madam', 'racecar', 'deed', 'redder', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer', 'refer',"
    },
    {
        "number": 4903,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    stdin = stdin.split('\\n')\n    std_aah = stdin[0]\n    doc_aah = stdin[1]\n\n    if len(std_aah) >= len(doc_aah):\n        return \"go\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 4904,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    alice_score = 0\n    barbara_score = 0\n    prev_player = 'A'\n\n    for i in range(0, len(stdin), 2):\n        player = stdin[i]\n        points = int(stdin[i+1])\n\n        if player == prev_player:\n            continue\n\n        if player == 'A':\n            alice_score += points\n        else:\n            barbara_score += points\n\n        prev_player = player\n\n        if alice_score >= 11:\n            return 'A'\n        elif barbara_score >= 11:\n            return 'B'\n        elif alice_score == 10 and barbara_score == 10:\n            if alice_score - barbara_score >= 2:\n                return 'A'\n            else:\n                return 'B'\n\n    if alice_score > barbara_score:\n        return 'A'\n    else:\n        return 'B'\n"
    },
    {
        "number": 4905,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_time_needed_to_traverse_street(street_label: int, intersection_labels: List[int], streets: List[Tuple[int, int, int]]) -> int:\n        start_intersection, end_intersection = intersection_labels\n        for a, b, l in streets:\n            if a == street_label and b == end_intersection:\n                return l\n        return 0\n\n    def get_minimum_time_needed_to_make_delivery(start_time: int, end_time: int, streets: List[Tuple[int, int, int]]) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time:\n                return -1\n        return time_needed\n\n    def get_minimum_time_needed_to_make_delivery_with_delay(start_time: int, end_time: int, streets: List[Tuple[int, int, int]], delay: int) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time - delay:\n                return -1\n        return time_needed\n\n    def get_minimum_time_needed_to_make_delivery_with_delay_and_start_time(start_time: int, end_time: int, streets: List[Tuple[int, int, int]], delay: int, start_time_delay: int) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time - delay - start_time_delay:\n                return -1\n        return time_needed\n\n    def get_minimum_time_needed_to_make_delivery_with_delay_and_start_time_and_end_time(start_time: int, end_time: int, streets: List[Tuple[int, int, int]], delay: int, start_time_delay: int, end_time_delay: int) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time - delay - start_time_delay - end_time_delay:\n                return -1\n        return time_needed\n\n    def get_minimum_time_needed_to_make_delivery_with_delay_and_start_time_and_end_time_and_intersection(start_time: int, end_time: int, streets: List[Tuple[int, int, int]], delay: int, start_time_delay: int, end_time_delay: int, start_intersection: int, end_intersection: int) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time - delay - start_time_delay - end_time_delay:\n                return -1\n            if a == start_intersection and b == end_intersection:\n                return time_needed\n        return -1\n\n    def get_minimum_time_needed_to_make_delivery_with_delay_and_start_time_and_end_time_and_intersection_and_start_time_at_end_intersection(start_time: int, end_time: int, streets: List[Tuple[int, int, int]], delay: int, start_time_delay: int, end_time_delay: int, start_intersection: int, end_intersection: int, start_time_at_end_intersection: int) -> int:\n        time_needed = 0\n        for a, b, l in streets:\n            time_needed += l\n            if time_needed > end_time - start_time - delay - start_time_delay - end_time_delay:\n                return -1\n            if a == start_intersection and b == end_intersection:\n                return time_needed + start_"
    },
    {
        "number": 4906,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.strip().split()\n    mode = input_data[0]\n    message = input_data[1]\n\n    if mode == 'E':\n        encoded_message = encode(message)\n        return encoded_message\n    elif mode == 'D':\n        decoded_message = decode(message)\n        return decoded_message\n    else:\n        return \"Invalid input\"\n\n\ndef"
    },
    {
        "number": 4907,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.strip())\n\n    # Alice can win if n is odd\n    if n % 2 == 1:\n        return \"Alice\", n // 2\n    else:\n        # Bob can win if n is even and n >= 4\n        if n >= 4:\n            return \"Bob\", n // 2\n        else:\n            # Alice can win if n is even and n < 4\n            return \"Alice\", 1\n"
    },
    {
        "number": 4908,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    numbers = list(map(int, stdin.split()))\n    num1, num2, num3 = numbers\n    operations = ['+', '-', '*', '/']\n\n    for op1 in operations:\n        for op2 in operations:\n            for op3 in operations:\n                equation = f\"{num1} {op1} {num2} {op2} {num3} {op3}\"\n                if eval(equation) == 0:\n                    return equation\n\n    return \"No solution found\"\n"
    },
    {
        "number": 4909,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, D = map(int, stdin.split())\n    D = list(map(int, D))\n\n    # Check if the sum of D is equal to N-1\n    if sum(D) == N - 1:\n        # Check if the D values are in increasing order\n        for i in range(1, N):\n            if D[i] < D[i - 1]:\n                return \"NO\"\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4910,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    num_colleagues = int(input_data[0])\n    categories = {}\n\n    for i in range(1, num_colleagues + 1):\n        category = input_data[i]\n        if category in categories:\n            categories[category] += 1\n        else:\n            categories[category] = 1\n\n    max_category = max(categories, key=categories.get)\n    return max_category\n"
    },
    {
        "number": 4911,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def stable_sort(songs, sort_attrs):\n        for attr in sort_attrs:\n            songs.sort(key=lambda x: x[attr])\n        return songs\n\n    def parse_input(input_str):\n        attributes = input_str.split()\n        songs = []\n        for line in input_str.split('\\n')[2:]:\n            songs.append(line.split())\n        return attributes, songs\n\n    def print_output(attributes, songs):\n        for song in songs:\n            print(' '.join(song))\n\n    attributes, songs = parse_input(stdin)\n    sort_commands = [line.strip() for line in stdin.split('\\n')[2 + len(songs):]]\n\n    for sort_attrs in sort_commands:\n        songs = stable_sort(songs, sort_attrs.split())\n        print_output(attributes, songs)\n        print()\n"
    },
    {
        "number": 4912,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    h, w, n = map(int, input_data[0].split())\n    x = list(map(int, input_data[1].split()))\n\n    total_length = sum(x)\n    if total_length < w:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 4913,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def calculate_efficacy(vaccinated_count, control_count, infected_count):\n        if vaccinated_count == 0 or control_count == 0:\n            return \"Not Effective\"\n        vaccinated_rate = vaccinated_count / control_count * 100\n        infected_rate = infected_count / control_count * 100\n        efficacy = (vaccinated_rate - infected_rate) / vaccinated_rate * 100\n        return round(efficacy, 2)\n\n    def parse_participant(participant_info):\n        vaccinated = participant_info[0] == 'Y'\n        strain_a = participant_info[1] == 'Y'\n        strain_b = participant_info[2] == 'Y'\n        strain_c = participant_info[3] == 'Y'\n        return vaccinated, strain_a, strain_b, strain_c\n\n    input_lines = stdin.splitlines()\n    num_participants = int(input_lines[0])\n    vaccinated_count = 0\n    control_count = 0\n    strain_a_infected_count = 0\n    strain_b_infected_count = 0\n    strain_c_infected_count = 0\n\n    for i in range(1, num_participants + 1):\n        participant_info = input_lines[i]\n        vaccinated, strain_a, strain_b, strain_c = parse_participant(participant_info)\n        if vaccinated:\n            vaccinated_count += 1\n        else:\n            control_count += 1\n        if strain_a:\n            strain_a_infected_count += 1\n        if strain_b:\n            strain_b_infected_count += 1\n        if strain_c:\n            strain_c_infected_count += 1\n\n    efficacy_a = calculate_efficacy(vaccinated_count, control_count, strain_a_infected_count)\n    efficacy_b = calculate_efficacy(vaccinated_count, control_count, strain_b_infected_count)\n    efficacy_c = calculate_efficacy(vaccinated_count, control_count, strain_c_infected_count)\n\n    return f\"{efficacy_a}, {efficacy_b}, {efficacy_c}\" "
    },
    {
        "number": 4914,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, correct_answers = stdin.split('\\n')\n    N = int(N)\n    correct_answers = correct_answers.strip()\n\n    adrian_sequence = 'A' * (N // 3) + 'B' * (N // 3) + 'C' * (N // 3) + 'A' * (N % 3) + 'B' * (N % 3) + 'C' * (N % 3)\n    bruno_sequence = 'B' * (N // 3) + 'A' * (N // 3) + 'B' * (N // 3) + 'C' * (N % 3) + 'A' * (N % 3) + 'B' * (N % 3)\n    goran_sequence = 'C' * (N // 2) + 'A' * (N // 2) + 'B' * (N % 2) + 'C' * (N // 2) + 'A' * (N // 2) + 'B' * (N % 2)\n\n    adrian_score = sum(1 for i in range(N) if correct_answers[i] == adrian_sequence[i])\n    bruno_score = sum(1 for i in range(N) if correct_answers[i] == bruno_sequence[i])\n    goran_score = sum(1 for i in range(N) if correct_answers[i] == goran_sequence[i])\n\n    max_score = max(adrian_score, bruno_score, goran_score)\n\n    if max_score == adrian_score:\n        print(max_score)\n        print(\"Adrian\")\n    elif max_score == bruno_score:\n        print(max_score)\n        print(\"Bruno\")\n    else:\n        print(max_score)\n        print(\"Goran\")\n"
    },
    {
        "number": 4915,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def process_log(log: str) -> tuple:\n        problems_solved = 0\n        time_score = 0\n        penalty_minutes = 0\n        last_problem = None\n        for line in log.split('\\n'):\n            if line == '-1':\n                break\n            m, problem, result = line.split()\n            m = int(m)\n            if problem != last_problem:\n                problems_solved += 1\n                last_problem = problem\n            if result == 'right':\n                time_score += m\n            elif result == 'wrong':\n                penalty_minutes += 20\n        return problems_solved, time_score + penalty_minutes\n\n    input_data = stdin.split('\\n')\n    log = '\\n'.join(input_data[:-1])\n    n_problems, time_measure = process_log(log)\n    return f\"{n_problems} {time_measure}\"\n"
    },
    {
        "number": 4916,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def shortest_path_length(n, k, art_installation):\n        visited = [False] * (k + 1)\n        queue = [(0, 1)]  # Start at tile 1 with distance 0\n        while queue:\n            distance, tile = queue.pop(0)\n            if tile == k:\n                return distance\n            if visited[tile]:\n                continue\n            visited[tile] = True\n            for x, y in art_installation[tile - 1]:\n                queue.append((distance + manhattan_distance(tile, 1, x, y), x))\n        return -1\n\n    n, k = map(int, stdin.split()[0:2])\n    art_installation = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n    return str(shortest_path_length(n, k, art_installation))\n"
    },
    {
        "number": 4917,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_pot_boiling(intervals: list) -> bool:\n        total_time = sum(intervals)\n        average_time = total_time / len(intervals)\n        return average_time >= 100\n\n    def is_pot_boiling_at_same_time(intervals: list) -> bool:\n        return all(interval == intervals[0] for interval in intervals)\n\n    def process_input(input_data: str) -> list:\n        lines = input_data.split('\\n')\n        N = int(lines[0])\n        intervals = []\n        for line in lines[1:]:\n            a, b = map(int, line.split())\n            intervals.append(b - a)\n        return intervals\n\n    intervals = process_input(stdin)\n    if is_pot_boiling(intervals):\n        if is_pot_boiling_at_same_time(intervals):\n            return \"edward is right\"\n        else:\n            return \"gunilla has a point\"\n    else:\n        return \"edward is right\"\n"
    },
    {
        "number": 4918,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, q = map(int, stdin.split()[0:2])\n    groups = [set() for _ in range(n + 1)]\n    for _ in range(q):\n        query = stdin.split()[_]\n        if query[0] == 't':\n            a, b = map(int, query[1:])\n            groups[a].add(a)\n            groups[b].add(a)\n            for group in groups:\n                if b in group:\n                    group.add(a)\n        elif query[0] == 's':\n            a = int(query[1])\n            print(len(groups[a]))\n"
    },
    {
        "number": 4919,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def parse_input(input_str: str) -> Tuple[int, List[Tuple[str, int]], List[Tuple[str, int]]]:\n        n, *trips, q, *queries = map(int, input_str.split())\n        trip_list = [(trip[0], trip[1]) for trip in zip(*[iter(trips)] * 2)]\n        query_list = [(query[0], query[1]) for query in zip(*[iter(queries)] * 2)]\n        return n, trip_list, query_list\n\n    def find_trip_year(trip_list: List[Tuple[str, int]], country: str, k: int) -> int:\n        for i, (country_name, year) in enumerate(trip_list, start=1):\n            if country_name == country:\n                if i == k:\n                    return year\n        return -1\n\n    def process_queries(trip_list: List[Tuple[str, int]], query_list: List[Tuple[str, int]]) -> str:\n        result = []\n        for country, k in query_list:\n            year = find_trip_year(trip_list, country, k)\n            result.append(str(year))\n        return \"\\n\".join(result)\n\n    n, trip_list, query_list = parse_input(stdin)\n    result = process_queries(trip_list, query_list)\n    return result\n"
    },
    {
        "number": 4920,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_good_itinerary(itinerary: list) -> bool:\n        if len(itinerary) < 2:\n            return False\n        first_event, last_event = itinerary[0], itinerary[-1]\n        if first_event == last_event:\n            return False\n        for event in itinerary[1:-1]:\n            if event == first_event or event == last_event:\n                return False\n        return True\n\n    def count_good_itineraries(stdin: str) -> int:\n        event_types = list(stdin)\n        num_good_itineraries = 0\n        for i in range(len(event_types)):\n            for j in range(i + 2, len(event_types) + 1):\n                itinerary = event_types[i:j]\n                if is_good_itinerary(itinerary):\n                    num_good_itineraries += 1\n        return num_good_itineraries\n\n    return count_good_itineraries(stdin)\n"
    },
    {
        "number": 4921,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    words = set()\n    for line in stdin.split('\\n'):\n        for word in line.split():\n            if word.lower() not in words:\n                words.add(word.lower())\n                print(word, end=' ')\n            else:\n                print('.', end=' ')\n    print()\n"
    },
    {
        "number": 4922,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    m, n = map(int, input_data[0].split())\n    clauses = input_data[1:]\n\n    if m < 8:\n        return \"unsatisfactory\"\n    else:\n        return \"satisfactory\"\n"
    },
    {
        "number": 4923,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    outcomes = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_unique_outcome = 0\n    max_unique_index = -1\n\n    for i in range(n):\n        unique_outcome = len(set(outcomes[:i] + outcomes[i+1:]))\n        if unique_outcome > max_unique_outcome:\n            max_unique_outcome = unique_outcome\n            max_unique_index = i\n\n    if max_unique_index == -1:\n        return \"none\"\n    else:\n        return str(max_unique_index)"
    },
    {
        "number": 4924,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    current_time, explosion_time = stdin.split('\\n')\n    current_time = datetime.datetime.strptime(current_time, '%H:%M:%S')\n    explosion_time = datetime.datetime.strptime(explosion_time, '%H:%M:%S')\n\n    time_to_explosion = explosion_time - current_time\n\n    if time_to_explosion.total_seconds() < 0:\n        print(\"The explosion time is in the past.\")\n    else:\n        time_to_explosion_str = str(time_to_explosion)\n        time_to_explosion_str = time_to_explosion_str.split('.')[0]\n        print(time_to_explosion_str)\n"
    },
    {
        "number": 4925,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_values = list(map(int, stdin.split()))\n    ell, n = input_values[0], input_values[1]\n\n    k = 1\n    while n > ell:\n        n -= ell\n        k += 1\n\n    return k\n"
    },
    {
        "number": 4926,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    e = 0\n    for i in range(n+1):\n        e += 1/math.factorial(i)\n    return str(e)"
    },
    {
        "number": 4927,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N, P, Q = map(int, stdin.split())\n    if P + Q == 0:\n        return \"paul\"\n    elif P == Q:\n        return \"opponent\"\n    else:\n        return \"paul\" if P < Q else \"opponent\"\n"
    },
    {
        "number": 4928,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n\n    # Calculate the maximum number of pieces Slavko's chessboard can crash into\n    max_pieces = 0\n    for i in range(1, N + 1):\n        max_pieces += i * 2 - 1\n\n    return str(max_pieces)\n"
    },
    {
        "number": 4929,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    S, P = stdin.split('\\n')\n    S = S.lower()\n    P = P.lower()\n\n    if S == P:\n        return \"Yes\"\n\n    if P.startswith(S):\n        return \"Yes\"\n\n    if P.endswith(S):\n        return \"Yes\"\n\n    if P[::-1] == S:\n        return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 4930,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Split the input sentence into words\n    words = stdin.split()\n\n    # Initialize an empty list to store the decoded words\n    decoded_words = []\n\n    # Iterate through the words\n    for word in words:\n        # Initialize an empty string to store the decoded word\n        decoded_word = \"\"\n\n        # Iterate through the characters in the word\n        for char in word:\n            # If the character is a vowel, add the modified vowel\n            if char in \"aeiou\":\n                decoded_word += \"p\" + char + char\n            # Otherwise, add the original character\n            else:\n                decoded_word += char\n\n        # Add the decoded word to the list of decoded words\n        decoded_words.append(decoded_word)\n\n    # Join the decoded words with a space and return the result\n    return \" \".join(decoded_words)"
    },
    {
        "number": 4931,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split()\n    x, y = int(input_data[0]), int(input_data[1])\n\n    if x == 0:\n        return \"IMPOSSIBLE\"\n\n    a = 100\n    b = a * y / x\n\n    if b == 0:\n        return \"ALL GOOD\"\n\n    while abs(a - b) > 10**-6:\n        a = (a + b) / 2\n        b = a * y / x\n\n    return a\n"
    },
    {
        "number": 4932,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    A, B, C, D = map(int, stdin.split()[:4])\n    P, M, G = map(int, stdin.split()[4:])\n\n    # Calculate the total time for each dog to be aggressive\n    total_aggressive_time = A + B + C + D\n\n    # Calculate the total time for each dog to be calm\n    total_calm_time = B + D\n\n    # Calculate the total time for each dog to repeat their behaviour\n    total_cycle_time = total_aggressive_time + total_calm_time\n\n    # Calculate the number of cycles that have passed since the postman, milkman and garbage man arrived\n    cycles_passed = (P - 1) // total_cycle_time\n\n    # Calculate the time since the last cycle\n    time_since_last_cycle = (P - 1) % total_cycle_time\n\n    # Calculate the time spent in the aggressive period of the first dog\n    time_in_aggressive_period_of_first_dog = min(time_since_last_cycle, A)\n\n    # Calculate the time spent in the aggressive period of the second dog\n    time_in_aggressive_period_of_second_dog = min(time_since_last_cycle - time_in_aggressive_period_of_first_dog, C)\n\n    # Calculate the time spent in the calm period of the first dog\n    time_in_calm_period_of_first_dog = min(time_since_last_cycle - time_in_aggressive_period_of_first_dog - time_in_aggressive_period_of_second_dog, B)\n\n    # Calculate the time spent in the calm period of the second dog\n    time_in_calm_period_of_second_dog = min(time_since_last_cycle - time_in_aggressive_period_of_first_dog - time_in_aggressive_period_of_second_dog - time_in_calm_period_of_first_dog, D)\n\n    # Determine how many dogs attack each of our heroes\n    postman_attacks_dogs = time_in_aggressive_period_of_first_dog + time_in_aggressive_period_of_second_dog\n    milkman_attacks_dogs = time_in_calm_period_of_first_dog + time_in_calm_period_of_second_dog\n    garbage_man_attacks_dogs = total_cycle_time - postman_attacks_dogs - milkman_attacks_dogs\n\n    # Output the results\n    print(\"Postman:\", end=\" \")\n    if postman_attacks_dogs == 0:\n        print(\"none\")\n    elif postman_attacks_dogs == A:\n        print(\"one\")\n    else:\n        print(\"both\")\n\n    print(\"Milkman:\", end=\" \")\n    if milkman_attacks_dogs == 0:\n        print(\"none\")\n    elif milkman_attacks_dogs == B:\n        print(\"one\")\n    else:\n        print(\"both\")\n\n    print(\"Garbage Man:\", end=\" \")\n    if garbage_man_attacks_dogs == 0:\n        print(\"none\")\n    elif garbage_man_attacks_dogs == C:\n        print(\"one\")\n    else:\n        print(\"both\")\n\n    return \"Output complete\"\n"
    },
    {
        "number": 4933,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, c = map(int, stdin.split())\n    d = (a + b + c) - (a - b + c)\n    return d\n"
    },
    {
        "number": 4934,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    h, v = map(int, stdin.split())\n    ladder_length = (h * 2) / (2 * (1 - (v / 180) * (math.tan(math.radians(v))))))\n    return str(math.ceil(ladder_length))\n"
    },
    {
        "number": 4935,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_velocity(D, theta, g):\n        return D * g * np.cos(np.deg2rad(theta))\n\n    N, g = map(int, stdin.split()[0:2])\n    D_list = []\n    theta_list = []\n\n    for _ in range(N):\n        D, theta = map(int, input().split())\n        D_list.append(D)\n        theta_list.append(theta)\n\n    D_list = np.array(D_list)\n    theta_list = np.array(theta_list)\n\n    velocity_list = []\n    for i in range(N):\n        if i == 0:\n            velocity_list.append(get_velocity(D_list[i], theta_list[i], g))\n        else:\n            velocity_list.append(velocity_list[i-1] + get_velocity(D_list[i], theta_list[i], g))\n\n    output = '\\n'.join(str(velocity) for velocity in velocity_list)\n    return output\n"
    },
    {
        "number": 4936,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_best_day(temps: list) -> tuple:\n        best_day = 0\n        best_temp = temps[0]\n        for i in range(1, len(temps) - 1):\n            if temps[i] < best_temp:\n                best_day = i\n                best_temp = temps[i]\n        return best_day, best_temp\n\n    n = int(stdin.splitlines()[0])\n    temps = list(map(int, stdin.splitlines()[1].split()))\n    best_day, best_temp = find_best_day(temps)\n    return str(best_day + 1), str(best_temp)  # Output day as 1-indexed\n"
    },
    {
        "number": 4937,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, a = map(int, input_data[0].split())\n    e = list(map(int, input_data[1].split()))\n\n    # Initialize variables\n    max_battles = 0\n    total_ships = 0\n\n    # Iterate through each solar system\n    for i in range(n):\n        # Calculate the number of battles Atli can win\n        battles = a // (e[i] + 1)\n\n        # Update the maximum number of battles\n        max_battles = max(max_battles, battles)\n\n        # Update the total number of ships\n        total_ships += e[i] * battles\n\n    # Calculate the number of battles Atli can win if he sends all the ships\n    all_ships_battles = a // (sum(e) + n - 1)\n\n    # Update the maximum number of battles\n    max_battles = max(max_battles, all_ships_battles)\n\n    # Calculate the total number of ships Atli can win if he sends all the ships\n    all_ships_total_ships = sum(e) * all_ships_battles\n\n    # Calculate the number of ships Atli can win if he sends the maximum number of battles\n    max_battles_total_ships = total_ships - all_ships_total_ships\n\n    # Calculate the number of ships Atli can win if he sends the maximum number of battles plus one\n    max_battles_plus_one_total_ships = total_ships - max_battles_total_ships - e[0]\n\n    # Update the maximum number of battles\n    max_battles = max(max_battles, max_battles_plus_one_total_ships // e[0])\n\n    # Return the maximum number of battles\n    return str(max_battles) "
    },
    {
        "number": 4938,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    max_diff = int(input_list[0])\n    gender_queue = input_list[1]\n\n    women_count = 0\n    men_count = 0\n    max_people_count = 0\n\n    for gender in gender_queue:\n        if gender == 'W':\n            women_count += 1\n        else:\n            men_count += 1\n\n        if abs(women_count - men_count) > max_diff:\n            break\n\n        max_people_count += 1\n\n    return str(max_people_count)\n"
    },
    {
        "number": 4939,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    commands = input_list[1].split()\n\n    child_pos = 0\n    for i in range(k):\n        command = commands[i]\n        if command.isdigit():\n            t = int(command)\n            child_pos = (child_pos + t) % n\n        else:\n            m = int(command[4:])\n            child_pos = (child_pos - m) % n\n\n    print(child_pos)\n"
    },
    {
        "number": 4940,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    P = [list(map(int, input_data[i].split())) for i in range(1, N + 1)]\n\n    T = [0] * N\n    for j in range(1, M + 1):\n        min_time = float('inf')\n        min_i = -1\n        for i in range(N):\n            if T[i] + P[i][j - 1] < min_time:\n                min_time = T[i] + P[i][j - 1]\n                min_i = i\n        T[min_i] = min_time\n\n    return ' '.join(map(str, T))\n"
    },
    {
        "number": 4941,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_correct_translation(word: str, dictionary: dict) -> bool:\n        return dictionary.get(word, \"incorrect\") == \"correct\"\n\n    def translate_sentence(sentence: str, dictionary: dict) -> str:\n        return \" \".join(word for word in sentence.split() if is_correct_translation(word, dictionary))\n\n    def count_translations(sentence: str, dictionary: dict) -> Tuple[int, int]:\n        correct_translations = 0\n        incorrect_translations = 0\n        for word in sentence.split():\n            if is_correct_translation(word, dictionary):\n                correct_translations += 1\n            else:\n                incorrect_translations += 1\n        return correct_translations, incorrect_translations\n\n    def process_input(input_str: str) -> Tuple[str, dict]:\n        lines = input_str.split(\"\\n\")\n        n = int(lines[0])\n        sentence = lines[1]\n        m = int(lines[2])\n        dictionary = {}\n        for i in range(3, 3 + m):\n            d, e, c = lines[i].split()\n            dictionary[d] = c\n        return sentence, dictionary\n\n    input_str = stdin.strip()\n    sentence, dictionary = process_input(input_str)\n    translation = translate_sentence(sentence, dictionary)\n    if translation:\n        correct = is_correct_translation(translation, dictionary)\n        output = translation + \"\\n\" + (\"correct\" if correct else \"incorrect\")\n    else:\n        correct_translations, incorrect_translations = count_translations(sentence, dictionary)\n        output = f\"{correct_translations}\\ncorrect\\n{incorrect_translations}\\nincorrect\"\n    return output "
    },
    {
        "number": 4942,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    tree_days = list(map(int, input_data[1].split()))\n\n    max_days = max(tree_days)\n    party_day = max_days + 1\n\n    for days in tree_days:\n        if days < party_day:\n            party_day = days + 1\n\n    return str(party_day)\n"
    },
    {
        "number": 4943,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def rotate(points, angle):\n        angle = math.radians(angle)\n        rotated_points = []\n        for point in points:\n            x, y = point\n            new_x = x * math.cos(angle) - y * math.sin(angle)\n            new_y = x * math.sin(angle) + y * math.cos(angle)\n            rotated_points.append((new_x, new_y))\n        return rotated_points\n\n    def scale(points, factor):\n        scaled_points = []\n        for point in points:\n            x, y = point\n            new_x = x * factor\n            new_y = y * factor\n            scaled_points.append((new_x, new_y))\n        return scaled_points\n\n    def translate(points, dx, dy):\n        translated_points = []\n        for point in points:\n            x, y = point\n            new_x = x + dx\n            new_y = y + dy\n            translated_points.append((new_x, new_y))\n        return translated_points\n\n    def area(points):\n        area = 0\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % len(points)]\n            area += x1 * y2 - x2 * y1\n        return abs(area) / 2\n\n    def is_similar(points1, points2):\n        if len(points1) != len(points2):\n            return False\n        for i in range(len(points1)):\n            if not is_collinear(points1[i], points1[(i + 1) % len(points1)], points2[i], points2[(i + 1) % len(points2)]):\n                return False\n        return True\n\n    def is_collinear(point1, point2, point3):\n        x1, y1 = point1\n        x2, y2 = point2\n        x3, y3 = point3\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0\n\n    def is_inside(points, point):\n        x, y = point\n        n = len(points)\n        inside = False\n        p1x, p1y = points[0]\n        for i in range(1, n + 1):\n            p2x, p2y = points[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def find_new_points(points, angle, factor, dx, dy):\n        rotated_points = rotate(points, angle)\n        scaled_points = scale(rotated_points, factor)\n        translated_points = translate(scaled_points, dx, dy)\n        return translated_points\n\n    def find_new_points_similar(points, angle, factor, dx, dy):\n        new_points = find_new_points(points, angle, factor, dx, dy)\n        if is_similar(points, new_points):\n            return new_points\n        else:\n            return None\n\n    def find_new_points_inside(points, angle, factor, dx, dy):\n        new_points = find_new_points(points, angle, factor, dx, dy)\n        if is_inside(points, new_points[0]):\n            return new_points\n        else:\n            return None\n\n    def find_new_points_area(points, angle, factor, dx, dy, area):\n        new_points = find_new_points(points, angle, factor, dx, dy)\n        if abs(area - area(new_points)) <"
    },
    {
        "number": 4944,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n    days = 0\n    while n > 0:\n        n -= 1\n        n -= 1\n        days += 1\n    return str(days)\n"
    },
    {
        "number": 4945,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b, m, sigma = map(int, stdin.split())\n    def rent(x, y):\n        return a * x + b * y\n    \n    def outlets(x, y):\n        return 2 * x + y\n    \n    def is_valid(x, y):\n        return x >= 1 and y >= 1 and x + y <= m and outlets(x, y) >= sigma\n    \n    max_rent = 0\n    for x in range(1, m // 2 + 1):\n        for y in range(1, m // 2 + 1):\n            if is_valid(x, y) and rent(x, y) > max_rent:\n                max_rent = rent(x, y)\n    \n    return str(max_rent)"
    },
    {
        "number": 4946,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split('\\n')[0])\n    languages = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_separation = n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if languages[i] == languages[j]:\n                min_separation = min(min_separation, abs(i - j))\n\n    return str(min_separation)\n"
    },
    {
        "number": 4947,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    x = float(stdin)\n\n    # Calculate the equivalent number of Roman paces\n    roman_paces = round(1000 * (5280 / 4854) * x)\n\n    return str(roman_paces)"
    },
    {
        "number": 4948,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    def find_slice_thickness(x, y, z, holes):\n        min_distance = float('inf')\n        for hole in holes:\n            d = distance(x, y, z, hole[1], hole[2], hole[3])\n            if d < min_distance:\n                min_distance = d\n        return min_distance\n\n    def cut_cheese(n, s, holes):\n        holes.sort(key=lambda x: x[3])\n        z_step = 100000 / s\n        slice_thicknesses = []\n        for i in range(s):\n            z = i * z_step\n            while True:\n                slice_thickness = find_slice_thickness(0, 0, z, holes)\n                if slice_thickness > 0:\n                    slice_thicknesses.append(slice_thickness)\n                    break\n                z += 1\n        return slice_thicknesses\n\n    n, s = map(int, stdin.split()[:2])\n    holes = [list(map(int, input().split())) for _ in range(n)]\n    slice_thicknesses = cut_cheese(n, s, holes)\n    return '\\n'.join(f'{t:.6f}' for t in slice_thicknesses)\n"
    },
    {
        "number": 4949,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, W, H = map(int, input_data[0].split())\n    matches = input_data[1:]\n\n    for match in matches:\n        length = int(match)\n        if length <= W and length <= H:\n            print(\"DA\")\n        else:\n            print(\"NE\")\n"
    },
    {
        "number": 4950,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_speed(photos: list) -> int:\n        time, distance = photos[0]\n        max_speed = 0\n        for i in range(1, len(photos)):\n            t, d = photos[i]\n            if t > time:\n                speed = (d - distance) * 3600 / (t - time)\n                max_speed = max(max_speed, speed)\n                time, distance = t, d\n        return max_speed\n\n    n = int(stdin.splitlines()[0])\n    photos = [(int(t), int(d)) for t, d in [line.split() for line in stdin.splitlines()[1:]]]\n    return str(find_speed(photos))\n"
    },
    {
        "number": 4951,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n\n    for i, line in enumerate(lines, start=1):\n        assumptions, arrow, conclusion = line.split(' ')\n        assumptions = assumptions.split(',')\n        if arrow != '->':\n            return str(i)\n        if assumptions and assumptions[0] == conclusion:\n            return str(i)\n\n    return 'correct'\n"
    },
    {
        "number": 4952,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    votes = stdin.split('\\n')[:-1]\n    votes_count = {}\n    for vote in votes:\n        if vote in votes_count:\n            votes_count[vote] += 1\n        else:\n            votes_count[vote] = 1\n\n    max_votes = 0\n    max_votes_candidate = \"\"\n    for candidate, votes in votes_count.items():\n        if votes > max_votes:\n            max_votes = votes\n            max_votes_candidate = candidate\n\n    if max_votes > len(votes) / 2:\n        return max_votes_candidate\n    else:\n        return \"Runoff!\"\n"
    },
    {
        "number": 4953,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    num_characters = int(input_data[0])\n    input_data = input_data[1:]\n\n    # Create a dictionary to store the languages each character speaks and understands\n    characters = {}\n    for line in input_data:\n        character, language, *languages = line.split()\n        characters[character] = {'language': language, 'languages': set(languages)}\n\n    # Create a graph to represent the languages each character understands\n    graph = {}\n    for character, data in characters.items():\n        language = data['language']\n        for lang in data['languages']:\n            if lang not in graph:\n                graph[lang] = set()\n            graph[lang].add(language)\n\n    # Find the smallest set of characters that can converse\n    visited = set()\n    stack = [characters[characters.keys()[0]]['language']]\n    while stack:\n        language = stack.pop()\n        if language in visited:\n            continue\n        visited.add(language)\n        for lang in graph[language]:\n            if lang not in visited:\n                stack.append(lang)\n\n    # Calculate the size of the smallest set of characters to ask to leave\n    smallest_set_size = 0\n    for character, data in characters.items():\n        if data['language'] not in visited:\n            smallest_set_size += 1\n\n    return str(smallest_set_size)\n"
    },
    {
        "number": 4954,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_min_cost(participants, budget, hotels, weeks):\n        min_cost = float('inf')\n        for hotel in hotels:\n            price, beds = hotel\n            if price * participants * weeks > budget:\n                continue\n            cost = price * participants * weeks\n            if cost < min_cost:\n                min_cost = cost\n        return min_cost if min_cost != float('inf') else \"stay home\"\n\n    N, B, H, W = map(int, stdin.split()[:4])\n    hotels = []\n    for _ in range(H):\n        price, beds = map(int, stdin.split()[4:6])\n        hotels.append((price, beds))\n\n    result = find_min_cost(N, B, hotels, W)\n    return str(result)\n"
    },
    {
        "number": 4955,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid_scale(notes: list, scale: list) -> bool:\n        for i in range(len(notes)):\n            if notes[i] not in scale:\n                return False\n        return True\n\n    def get_major_scales(notes: list) -> list:\n        scales = []\n        for note in notes:\n            if note == 'A':\n                scales.append(['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'])\n            elif note == 'B':\n                scales.append(['B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#'])\n            elif note == 'C':\n                scales.append(['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'])\n            elif note == 'D':\n                scales.append(['D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#'])\n            elif note == 'E':\n                scales.append(['E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#'])\n            elif note == 'F':\n                scales.append(['F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E'])\n            elif note == 'G':\n                scales.append(['G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#'])\n            elif note == 'A#':\n                scales.append(['A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A'])\n            elif note == 'B#':\n                scales.append(['B#', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#'])\n            elif note == 'C#':\n                scales.append(['C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#'])\n            elif note == 'D#':\n                scales.append(['D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D'])\n            elif note == 'E#':\n                scales.append(['E#', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#'])\n            elif note == 'F#':\n                scales.append(['F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'E#'])\n            elif note == 'G#':\n                scales.append(['G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G'])\n            elif note == 'A##':\n                scales.append(['A##', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A'])\n            elif note == 'C##':\n                scales.append(['C##', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#'])\n            elif note == 'D##':\n                scales.append(['D##', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D'])\n            elif note == 'E##':\n               "
    },
    {
        "number": 4956,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    words = stdin.split()\n    ae_count = 0\n    for word in words:\n        ae_count += word.count('ae')\n    if ae_count >= len(words) * 0.4:\n        return \"dae ae ju traeligt va\"\n    else:\n        return \"haer talar vi rikssvenska\""
    },
    {
        "number": 4957,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    gridland = [list(line) for line in input_data[1:]]\n\n    def is_valid_placement(x, y):\n        if gridland[x][y] == '.':\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if 0 <= x + dx < n and 0 <= y + dy < m and gridland[x + dx][y + dy] == '.':\n                    return False\n            return True\n        return False\n\n    def place_coffee_shops():\n        for x in range(n):\n            for y in range(m):\n                if is_valid_placement(x, y):\n                    gridland[x][y] = 'E'\n                    return True\n        return False\n\n    if not place_coffee_shops():\n        return \"No valid placement found.\"\n\n    result = []\n    for row in gridland:\n        result.append(''.join(row))\n    return '\\n'.join(result)\n"
    },
    {
        "number": 4958,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = list(map(int, stdin.split()))\n    box_heights = input_list[:6]\n    tower_heights = input_list[6:]\n\n    # Sort the box heights in descending order\n    box_heights.sort(reverse=True)\n\n    # Find the heights of the three boxes in each tower\n    tower1_box_heights = [box_heights[0], box_heights[1], tower_heights[0]]\n    tower2_box_heights = [box_heights[2], box_heights[3], tower_heights[1]]\n\n    # Output the tower heights and the box heights in each tower\n    output = f\"{tower1_box_heights}\\n{tower2_box_heights}\"\n\n    return output\n"
    },
    {
        "number": 4959,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    e, f, c = map(int, stdin.split())\n    sodas = (e + f) // c\n    return str(sodas)\n"
    },
    {
        "number": 4960,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    binary_num = stdin.strip()\n    octal_num = \"\"\n\n    # Pad the binary numeral with zeros on the left until the number of digits is divisible by three\n    while len(binary_num) % 3 != 0:\n        binary_num = \"0\" + binary_num\n\n    # Group adjacent binary digits into groups of 3 digits\n    for i in range(0, len(binary_num), 3):\n        group = binary_num[i:i+3]\n        # Replace each group of binary digits with the corresponding octal digit\n        octal_digit = str(int(group, 2))\n        octal_num += octal_digit\n\n    return octal_num"
    },
    {
        "number": 4961,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R, S = map(int, stdin.split()[0].split(','))\n    seating_order = stdin.split('\\n')[1:]\n\n    # Initialize variables\n    total_handshakes = 0\n    num_empty_seats = R * S\n\n    # Iterate through each row\n    for row in seating_order:\n        # Count the number of empty seats in the row\n        num_empty_seats_in_row = row.count('.')\n        # Update the total number of empty seats\n        num_empty_seats -= num_empty_seats_in_row\n        # If there are no empty seats left, break out of the loop\n        if num_empty_seats <= 0:\n            break\n        # Count the number of handshakes in the row\n        num_handshakes_in_row = row.count('o') * (S - 1)\n        # Update the total number of handshakes\n        total_handshakes += num_handshakes_in_row\n\n    # If there are still empty seats left, Mirko cannot shake hands with anyone else\n    if num_empty_seats > 0:\n        total_handshakes = 0\n\n    return str(total_handshakes) "
    },
    {
        "number": 4962,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def find_empty_drawer(drawers, used_drawers):\n        for drawer in drawers:\n            if drawer not in used_drawers:\n                return drawer\n        return None\n\n    def move_item(item, drawers, used_drawers):\n        for drawer in drawers:\n            if drawer not in used_drawers:\n                used_drawers.add(drawer)\n                return drawer\n        return None\n\n    def store_item(item, drawer, drawers, used_drawers):\n        used_drawers.add(drawer)\n        drawers[drawer] = item\n\n    def throw_away_item(item):\n        return f\"SMECE {item}\"\n\n    N, L = map(int, stdin.split()[:2])\n    items = list(map(int, stdin.split()[2:]))\n    drawers = [None] * L\n    used_drawers = set()\n\n    for i in range(N):\n        A_i, B_i = items[i]\n        if drawers[A_i - 1] is None:\n            drawer = find_empty_drawer(range(A_i, L), used_drawers)\n            if drawer is not None:\n                store_item(i + 1, drawer, drawers, used_drawers)\n            else:\n                print(throw_away_item(i + 1))\n        elif drawers[B_i - 1] is None:\n            drawer = find_empty_drawer(range(B_i, L), used_drawers)\n            if drawer is not None:\n                store_item(i + 1, drawer, drawers, used_drawers)\n            else:\n                print(throw_away_item(i + 1))\n        else:\n            drawer = move_item(i + 1, [A_i - 1, B_i - 1], used_drawers)\n            if drawer is not None:\n                store_item(i + 1, drawer, drawers, used_drawers)\n            else:\n                print(throw_away_item(i + 1))\n\n    for i, drawer in enumerate(drawers):\n        if drawer is not None:\n            print(f\"LADICA {drawer}\")\n        else:\n            print(throw_away_item(i + 1))\n"
    },
    {
        "number": 4963,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.splitlines()[0])\n    d = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the order list with the first person as Jimmy\n    order = [0] * n\n    order[0] = 1\n\n    # Iterate through the list of people between each person and Jimmy\n    for i in range(1, n):\n        # Find the index of the person who is i places away from Jimmy\n        index = 0\n        while d[index] != i:\n            index += 1\n\n        # Insert the person at the found index in the order list\n        order.insert(index + 1, i + 1)\n\n    # Print the order list\n    return \" \".join(map(str, order))\n"
    },
    {
        "number": 4964,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def get_horror_index(movie_id, horror_list, similarities):\n        worst_similar_movie = float('inf')\n        for similar_movie in similarities[movie_id]:\n            if similar_movie in horror_list:\n                worst_similar_movie = min(worst_similar_movie, 1)\n            else:\n                worst_similar_movie = min(worst_similar_movie, get_horror_index(similar_movie, horror_list, similarities))\n        return worst_similar_movie + 1\n\n    def get_worst_horrible_movie(horror_list, similarities):\n        worst_horrible_movie = float('-inf')\n        for movie_id in range(len(similarities)):\n            if movie_id not in horror_list:\n                worst_horrible_movie = max(worst_horrible_movie, get_horror_index(movie_id, horror_list, similarities))\n        return worst_horrible_movie\n\n    # Read input\n    lines = stdin.split('\\n')\n    N, H, L = map(int, lines[0].split())\n    horror_list = list(map(int, lines[1].split()))\n    similarities = [set() for _ in range(N)]\n    for i in range(2, len(lines)):\n        a, b = map(int, lines[i].split())\n        similarities[a].add(b)\n        similarities[b].add(a)\n\n    # Calculate worst horrible movie\n    worst_horrible_movie = get_worst_horrible_movie(horror_list, similarities)\n\n    # Find movie with highest Horror Index\n    highest_horror_index = float('-inf')\n    worst_movie = None\n    for movie_id in range(N):\n        if movie_id not in horror_list:\n            horror_index = get_horror_index(movie_id, horror_list, similarities)\n            if horror_index > highest_horror_index:\n                highest_horror_index = horror_index\n                worst_movie = movie_id\n            elif horror_index == highest_horror_index and movie_id < worst_movie:\n                worst_movie = movie_id\n\n    # Output result\n    if worst_horrible_movie == float('-inf'):\n        return str(worst_movie)\n    else:\n        return str(worst_movie) if worst_horrible_movie == float('inf') else str(worst_movie) + ' ' + str(worst_horrible_movie)"
    },
    {
        "number": 4965,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    t = list(map(int, input_data[1].split()))\n\n    t.sort()\n    t_new = [t[0]]\n\n    for i in range(1, n):\n        if t[i] - t_new[-1] > 0:\n            t_new.append(t[i])\n        else:\n            t_new.append(t[i])\n            t_new.append(t[i-1])\n\n    if len(t_new) == n:\n        return \" \".join(map(str, t_new))\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 4966,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n, p, k = map(int, input_data[0].split())\n    t = list(map(int, input_data[1].split()))\n\n    t.insert(0, 0)\n    t.append(k)\n\n    speed = [100]\n    for i in range(1, n + 1):\n        speed.append(speed[-1] + p)\n\n    total_time = 0\n    for i in range(1, n + 1):\n        total_time += t[i] - t[i - 1]\n\n    original_length = total_time * 100 / speed[-1]\n\n    return str(int(original_length))\n"
    },
    {
        "number": 4967,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def nearest_safe_house(spy_location, safe_houses):\n        return min(safe_houses, key=lambda safe_house: manhattan_distance(spy_location, safe_house))\n\n    def find_max_distance(grid, safe_houses):\n        max_distance = 0\n        for y, row in enumerate(grid):\n            for x, block in enumerate(row):\n                if block == 'S':\n                    spy_location = (x, y)\n                    nearest_safe_house_location = nearest_safe_house(spy_location, safe_houses)\n                    distance = manhattan_distance(spy_location, nearest_safe_house_location)\n                    max_distance = max(max_distance, distance)\n        return max_distance\n\n    lines = stdin.split('\\n')\n    width = int(lines[0])\n    height = len(lines)\n    grid = [list(line) for line in lines[1:]]\n    safe_houses = [(x, y) for y, row in enumerate(grid) for x, block in enumerate(row) if block == 'H']\n\n    max_distance = find_max_distance(grid, safe_houses)\n    return str(max_distance)\n"
    },
    {
        "number": 4968,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def lend_kayak(teams, damaged_teams, reserve_teams):\n        lendable_teams = set(range(1, N+1)) - set(damaged_teams)\n        lendable_teams -= set(reserve_teams)\n        for team in reserve_teams:\n            if team-1 in lendable_teams:\n                lendable_teams.remove(team-1)\n            if team+1 in lendable_teams:\n                lendable_teams.remove(team+1)\n        return lendable_teams\n\n    N, S, R = map(int, stdin.splitlines()[0].split())\n    damaged_teams = sorted(map(int, stdin.splitlines()[1].split()))\n    reserve_teams = sorted(map(int, stdin.splitlines()[2].split()))\n\n    lendable_teams = lend_kayak(range(1, N+1), damaged_teams, reserve_teams)\n    return str(len(lendable_teams))\n"
    },
    {
        "number": 4969,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    R, C = map(int, stdin.split())\n    if C > R:\n        return \"C cannot be greater than R\"\n    cheese_area = (R**2 - C**2) * 3.14159\n    total_area = 2 * 3.14159 * R**2\n    cheese_percentage = (cheese_area / total_area) * 100\n    return f\"{cheese_percentage:.6f}\""
    },
    {
        "number": 4970,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin.split()[0])\n    courses = {}\n    for i in range(1, n+1):\n        line = stdin.split('\\n')[i].split()\n        course_list = [int(course) for course in line]\n        course_list.sort()\n        course_str = ' '.join(str(course) for course in course_list)\n        if course_str in courses:\n            courses[course_str] += 1\n        else:\n            courses[course_str] = 1\n    max_popularity = 0\n    for course_str, popularity in courses.items():\n        if popularity > max_popularity:\n            max_popularity = popularity\n    return str(max_popularity)"
    },
    {
        "number": 4971,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    m = int(stdin)\n    bus_numbers = set()\n    for a in range(1, m):\n        for b in range(1, m):\n            if a**3 + b**3 <= m:\n                bus_numbers.add(a**3 + b**3)\n            if a**3 - b**3 <= m:\n                bus_numbers.add(a**3 - b**3)\n            if b**3 - a**3 <= m:\n                bus_numbers.add(b**3 - a**3)\n    if len(bus_numbers) == 0:\n        return \"none\"\n    else:\n        return max(bus_numbers)\n"
    },
    {
        "number": 4972,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    X = int(stdin)\n    k = 0\n    i = 1\n    while X > 1:\n        if X % i == 0:\n            k += 1\n            X //= i\n        else:\n            i += 1\n    return str(k)\n"
    },
    {
        "number": 4973,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def is_valid(r, c):\n        return 1 <= r <= N and 1 <= c <= N and board[r][c] != '#'\n\n    def bfs(start_r, start_c):\n        queue = [(start_r, start_c, 0)]\n        visited = set()\n        visited.add((start_r, start_c))\n\n        while queue:\n            r, c, steps = queue.pop(0)\n\n            if (r, c) == (1, 1):\n                return steps\n\n            for dr, dc in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if is_valid(new_r, new_c) and (new_r, new_c) not in visited:\n                    visited.add((new_r, new_c))\n                    queue.append((new_r, new_c, steps + 1))\n\n    N = int(stdin.split('\\n')[0])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    start_r, start_c = next((r, c) for r in range(1, N + 1) for c in range(1, N + 1) if board[r - 1][c - 1] == 'K')\n\n    result = bfs(start_r, start_c)\n    return str(result) if result is not None else '-1'\n"
    },
    {
        "number": 4974,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read input\n    r, n = map(int, stdin.split())\n    booked_rooms = set(map(int, stdin.split()))\n\n    # Check if there are available rooms\n    for room in range(1, r + 1):\n        if room not in booked_rooms:\n            return str(room)\n\n    # No available rooms\n    return \"too late\""
    },
    {
        "number": 4975,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    key_phrase, plaintext = stdin.split('\\n')\n    key_phrase = key_phrase.replace(' ', '').upper()\n    plaintext = plaintext.replace(' ', '').upper()\n\n    # Generate encryption key\n    key = [''] * 25\n    key[0] = 'P'\n    key[1] = 'L'\n    key[2] = 'A'\n    key[3] = 'Y'\n    key[4] = 'F'\n    key[5] = 'I'\n    key[6] = 'R'\n    key[7] = 'E'\n    key[8] = 'X'\n    key[9] = 'M'\n    key[10] = 'B'\n    key[11] = 'C'\n    key[12] = 'D'\n    key[13] = 'G'\n    key[14] = 'H'\n    key[15] = 'J'\n    key[16] = 'K'\n    key[17] = 'N'\n    key[18] = 'O'\n    key[19] = 'S'\n    key[20] = 'T'\n    key[21] = 'U'\n    key[22] = 'V'\n    key[23] = 'W'\n    key[24] = 'Z'\n\n    # Encrypt plaintext\n    encrypted = ''\n    for i in range(0, len(plaintext), 2):\n        if plaintext[i] == plaintext[i + 1]:\n            encrypted += plaintext[i] + 'X'\n        else:\n            row1, col1 = divmod(key.index(plaintext[i]), 5)\n            row2, col2 = divmod(key.index(plaintext[i + 1]), 5)\n            if row1 == row2:\n                encrypted += key[row1 * 5 + (col1 + 1) % 5] + key[row1 * 5 + (col2 + 1) % 5]\n            elif col1 == col2:\n                encrypted += key[(row1 + 1) % 5 * 5 + col1] + key[(row2 + 1) % 5 * 5 + col2]\n            else:\n                encrypted += key[row1 * 5 + col2] + key[row2 * 5 + col1]\n\n    return encrypted"
    },
    {
        "number": 4976,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def closest_hole(gopher, dog, holes):\n        min_dist = float('inf')\n        closest_hole = None\n        for hole in holes:\n            dist = distance(gopher, hole)\n            if dist < min_dist:\n                min_dist = dist\n                closest_hole = hole\n        return closest_hole\n\n    lines = stdin.split('\\n')\n    gopher = tuple(float(x) for x in lines[0].split())\n    dog = tuple(float(x) for x in lines[1].split())\n    holes = [tuple(float(x) for x in line.split()) for line in lines[2:]]\n\n    closest_hole = closest_hole(gopher, dog, holes)\n    if closest_hole is not None:\n        return f\"The gopher can escape through the hole at ({closest_hole[0]:.3f}, {closest_hole[1]:.3f}).\"\n    else:\n        return \"The gopher cannot escape.\"\n"
    },
    {
        "number": 4977,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split('\\n')\n    start_coord = tuple(map(int, input_list[0].split()[1:]))\n    dest_coord = tuple(map(int, input_list[1].split()[1:]))\n    t = int(input_list[2])\n\n    def is_valid_move(coord, move):\n        return (coord[0] + move[0], coord[1] + move[1])\n\n    def is_valid_turn(coord, turn):\n        return (coord[0], coord[1] + turn)\n\n    def dfs(coord, t, visited):\n        if t < 0:\n            return False\n        if coord == dest_coord:\n            return t == 0\n        visited.add(coord)\n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_coord = is_valid_move(coord, move)\n            if new_coord not in visited and is_valid_move(new_coord, move) not in visited:\n                if dfs(new_coord, t - 1, visited):\n                    return True\n        for turn in [1, -1]:\n            new_coord = is_valid_turn(coord, turn)\n            if new_coord not in visited and is_valid_turn(new_coord, turn) not in visited:\n                if dfs(new_coord, t, visited):\n                    return True\n        return False\n\n    return 'Y' if dfs(start_coord, t, set()) else 'N'\n"
    },
    {
        "number": 4978,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    grid = [list(input_data[i]) for i in range(1, N+1)]\n\n    def spread_water(grid, row, col):\n        if grid[row][col] == 'V':\n            return\n        if row == 0 or col == 0 or col == M-1:\n            grid[row][col] = 'V'\n            return\n        if grid[row-1][col] == 'V':\n            grid[row][col] = 'V'\n            return\n        if grid[row-1][col-1] == 'V' or grid[row-1][col+1] == 'V':\n            grid[row][col] = 'V'\n            return\n        spread_water(grid, row-1, col)\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'V':\n                spread_water(grid, i, j)\n\n    for i in range(N):\n        print(''.join(grid[i]))\n"
    },
    {
        "number": 4979,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    N = int(stdin)\n    binary_N = bin(N)[2:]\n    reversed_binary_N = binary_N[::-1]\n    reversed_N = int(reversed_binary_N, 2)\n    return str(reversed_N)\n"
    },
    {
        "number": 4980,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    pink_buttons = 0\n    rose_buttons = 0\n\n    for color in input_data:\n        if 'pink' in color.lower():\n            pink_buttons += 1\n        if 'rose' in color.lower():\n            rose_buttons += 1\n\n    if pink_buttons > 0:\n        return pink_buttons\n    else:\n        return \"I must watch Star Wars with my daughter\"\n"
    },
    {
        "number": 4981,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_list = stdin.split(\"\\n\")\n    input_list = input_list[0].split(\" \")\n    A, B, C = map(int, input_list)\n\n    desired_order = input_list[1]\n\n    if desired_order == \"ABC\":\n        return f\"{A} {B} {C}\"\n    elif desired_order == \"ACB\":\n        return f\"{A} {C} {B}\"\n    elif desired_order == \"BAC\":\n        return f\"{B} {A} {C}\"\n    elif desired_order == \"BCA\":\n        return f\"{B} {C} {A}\"\n    elif desired_order == \"CBA\":\n        return f\"{C} {B} {A}\"\n    elif desired_order == \"CAB\":\n        return f\"{C} {A} {B}\"\n"
    },
    {
        "number": 4982,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    events = stdin.split('\\n')\n    shares = 0\n    cost = 0\n    for event in events:\n        if event.startswith('buy'):\n            shares += int(event.split()[1])\n            cost += int(event.split()[2]) * int(event.split()[1])\n        elif event.startswith('sell'):\n            shares -= int(event.split()[1])\n            cost -= int(event.split()[2]) * int(event.split()[1])\n        elif event.startswith('split'):\n            x = int(event.split()[1])\n            shares = shares * x\n            cost = cost * x\n        elif event.startswith('merge'):\n            x = int(event.split()[1])\n            shares = shares // x\n            cost = cost // x\n        elif event.startswith('die'):\n            y = int(event.split()[1])\n            profit = shares * y - cost\n            tax = profit * 0.3\n            final_sale = shares * y\n            total_profit = final_sale - cost\n            total_profit_after_tax = total_profit - tax\n            return round(total_profit_after_tax, 2)"
    },
    {
        "number": 4983,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    x = int(stdin)\n    while x > 0:\n        digits = [int(d) for d in str(x) if int(d) > 0]\n        x = 1\n        for d in digits:\n            x *= d\n    return str(x) "
    },
    {
        "number": 4984,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    def dfs(i, j, visited):\n        if i < 0 or i >= r or j < 0 or j >= c or visited[i][j] or image[i][j] == 'C':\n            return 0\n        visited[i][j] = True\n        return 1 + dfs(i-1, j, visited) + dfs(i+1, j, visited) + dfs(i, j-1, visited) + dfs(i, j+1, visited)\n\n    r, c = map(int, stdin.split()[0].split(','))\n    image = [list(stdin.split()[i+1]) for i in range(r)]\n    visited = [[False for _ in range(c)] for _ in range(r)]\n    count = 0\n\n    for i in range(r):\n        for j in range(c):\n            if not visited[i][j] and image[i][j] == 'L':\n                count += 1\n                count += dfs(i, j, visited)\n\n    return str(count)\n"
    },
    {
        "number": 4985,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    b = input_data[1][1]\n    hands = []\n    for i in range(2, len(input_data), 4):\n        hand = []\n        for j in range(i, i+4):\n            card = input_data[j]\n            number = card[0]\n            suit = card[1]\n            hand.append((number, suit))\n        hands.append(hand)\n\n    def get_value(card):\n        number, suit = card\n        if suit == b:\n            return {\n                'A': 11,\n                'K': 4,\n                'Q': 3,\n                'J': 20,\n                'T': 10,\n                '9': 14,\n                '8': 0,\n                '7': 0\n            }[number]\n        else:\n            return {\n                'A': 11,\n                'K': 4,\n                'Q': 3,\n                'J': 2,\n                'T': 10,\n                '9': 14,\n                '8': 0,\n                '7': 0\n            }[number]\n\n    total_points = 0\n    for hand in hands:\n        total_points += sum(get_value(card) for card in hand)\n\n    return str(total_points)\n"
    },
    {
        "number": 4986,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    s, t = stdin.split('\\n')\n    sticky_keys = []\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            sticky_keys.append(s[i])\n\n    return ''.join(sticky_keys)\n"
    },
    {
        "number": 4987,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    first_line = input_data[0].split()\n    S, C, K = int(first_line[0]), int(first_line[1]), int(first_line[2])\n    socks_colors = list(map(int, input_data[1].split()))\n\n    # Calculate the number of machines needed\n    machines_needed = 1\n    current_machine_socks = 0\n    current_machine_color_sum = 0\n\n    for sock_color in socks_colors:\n        if current_machine_socks < C:\n            current_machine_socks += 1\n            current_machine_color_sum += sock_color\n        else:\n            machines_needed += 1\n            current_machine_socks = 1\n            current_machine_color_sum = sock_color\n\n    # Check if the last machine needs to be added\n    if current_machine_socks > 0:\n        machines_needed += 1\n\n    return str(machines_needed)\n"
    },
    {
        "number": 4988,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    T = int(stdin.split()[0])\n    for i in range(1, T+1):\n        N = int(stdin.split()[i])\n        fact = 1\n        for j in range(1, N+1):\n            fact *= j\n        print(fact % 10)\n"
    },
    {
        "number": 4989,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    alice_sum = sum(a[::2])\n    bob_sum = sum(a[1::2])\n    return f\"{alice_sum} {bob_sum}\"\n"
    },
    {
        "number": 4990,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    b, k, g = map(int, stdin.split())\n    d = (b-1) // (k-g) + 1\n    return str(d)"
    },
    {
        "number": 4991,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    n = int(stdin)\n\n    def hailstone_sequence(n):\n        if n == 1:\n            return [1]\n        elif n % 2 == 0:\n            return [n] + hailstone_sequence(n // 2)\n        else:\n            return [n] + hailstone_sequence(3 * n + 1)\n\n    sequence = hailstone_sequence(n)\n    return str(sum(sequence))\n"
    },
    {
        "number": 4992,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    s = list(map(int, input_data[1].split()))\n\n    # Check if there is a safe order\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        if s[0] == s[1]:\n            return \"impossible\"\n        else:\n            return \"1 2\"\n    else:\n        # Check if there is a safe order for n >= 3\n        total_students = sum(s)\n        exams_left = total_students\n        for i in range(n):\n            if exams_left < s[i]:\n                return \"impossible\"\n            exams_left -= s[i]\n\n        # Generate all possible orders\n        orders = []\n        for i in range(1, n):\n            orders.append(str(i))\n        for i in range(1, n):\n            for j in range(i+1, n):\n                orders.append(f\"{i} {j}\")\n        for i in range(1, n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    orders.append(f\"{i} {j} {k}\")\n\n        # Check if each order is safe\n        for order in orders:\n            exams_left = total_students\n            for room in order.split():\n                room_index = int(room) - 1\n                exams_left -= s[room_index]\n                if exams_left < 0:\n                    break\n            else:\n                return order\n\n        return \"impossible\"\n"
    },
    {
        "number": 4993,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    P, N = map(int, input_data[0].split())\n    parts = set()\n    for i in range(1, N+1):\n        parts.add(input_data[i])\n    if len(parts) == P:\n        return \"Paradox avoided\"\n    else:\n        return N"
    },
    {
        "number": 4994,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Read the input\n    x1, y1 = map(int, stdin.splitlines()[0].split())\n    x2, y2 = map(int, stdin.splitlines()[1].split())\n    x3, y3 = map(int, stdin.splitlines()[2].split())\n\n    # Calculate the slope of the first line\n    m1 = (y2 - y1) / (x2 - x1)\n\n    # Calculate the slope of the second line\n    m2 = (y3 - y2) / (x3 - x2)\n\n    # Calculate the slope of the third line\n    m3 = (y1 - y3) / (x1 - x3)\n\n    # Calculate the intersection point of the first line and the second line\n    x4 = (y2 - y1) / (m1 - m2) + x1\n    y4 = m1 * (x4 - x1) + y1\n\n    # Calculate the intersection point of the second line and the third line\n    x5 = (y3 - y2) / (m2 - m3) + x2\n    y5 = m2 * (x5 - x2) + y2\n\n    # Calculate the intersection point of the first line and the third line\n    x6 = (y1 - y3) / (m3 - m1) + x1\n    y6 = m3 * (x6 - x1) + y1\n\n    # Calculate the intersection point of the second line and the fourth line\n    x7 = (y4 - y2) / (m2 - m3) + x2\n    y7 = m2 * (x7 - x2) + y2\n\n    # Calculate the intersection point of the third line and the fourth line\n    x8 = (y5 - y3) / (m3 - m1) + x3\n    y8 = m3 * (x8 - x3) + y3\n\n    # Calculate the intersection point of the first line and the fourth line\n    x9 = (y4 - y1) / (m1 - m3) + x1\n    y9 = m1 * (x9 - x1) + y1\n\n    # Calculate the intersection point of the second line and the fifth line\n    x10 = (y5 - y2) / (m2 - m3) + x2\n    y10 = m2 * (x10 - x2) + y2\n\n    # Calculate the intersection point of the third line and the fifth line\n    x11 = (y6 - y3) / (m3 - m1) + x3\n    y11 = m3 * (x11 - x3) + y3\n\n    # Calculate the intersection point of the fourth line and the fifth line\n    x12 = (y7 - y4) / (m1 - m3) + x4\n    y12 = m1 * (x12 - x4) + y4\n\n    # Calculate the intersection point of the first line and the sixth line\n    x13 = (y8 - y1) / (m1 - m3) + x1\n    y13 = m1 * (x13 - x1) + y1\n\n    # Calculate the intersection point of the second line and the seventh line\n    x14 = (y9 - y2) / (m2 - m3) + x2\n    y14 = m2 * (x14 - x2) + y2\n\n    # Calculate the intersection point of the third line and the seventh line\n    x15 = (y10 - y3) / (m3 - m1) + x3\n    y15 = m3 * (x15 - x3) + y3\n\n    # Calculate the intersection point of the fourth line and the seventh line\n    x16 = (y11 - y4) / (m1 - m3) + x4\n    y16 = m1 * (x16 - x4) + y4\n\n    # Calculate the intersection point of the fifth line and the seventh line\n    x17 = (y12 - y5) / (m1 - m3) + x5\n    y17 = m1 * (x17 - x5) + y5\n\n    # Calculate the intersection point of"
    },
    {
        "number": 4995,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    minutes = []\n    for i in range(1, n+1):\n        m, s = map(int, input_data[i].split())\n        minutes.append(m + s/60)\n    avg_minute = sum(minutes)/n\n    if avg_minute <= 1:\n        return \"measurement error\"\n    else:\n        return round(avg_minute, 7)"
    },
    {
        "number": 4996,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    encrypted_message, key = stdin.split('\\n')\n    decrypted_message = ''\n    key_index = 0\n\n    for char in encrypted_message:\n        if key_index >= len(key):\n            key_index = 0\n\n        key_char = key[key_index]\n        key_index += 1\n\n        shift = ord(key_char) - ord('A')\n        if key_index % 2 == 0:\n            shift = -shift\n\n        decrypted_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n        decrypted_message += decrypted_char\n\n    return decrypted_message\n"
    },
    {
        "number": 4997,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    # Initialize the cups and the ball\n    cups = ['A', 'B', 'C']\n    ball = 'A'\n\n    # Swap the cups according to Borko's moves\n    for move in stdin:\n        if move == 'A':\n            cups[0], cups[1] = cups[1], cups[0]\n        elif move == 'B':\n            cups[1], cups[2] = cups[2], cups[1]\n        else:\n            cups[0], cups[2] = cups[2], cups[0]\n\n    # Determine the cup under which the ball is\n    if ball == cups[0]:\n        return '1'\n    elif ball == cups[1]:\n        return '2'\n    else:\n        return '3'"
    },
    {
        "number": 4998,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    input_data = stdin.split('\\n')\n    A, B, C, D = map(int, input_data[0].split())\n\n    # Calculate the largest rectangle\n    largest_area = min(A, B, C, D) * min(A, B, C, D)\n\n    return str(largest_area)\n"
    },
    {
        "number": 4999,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\n    a, b = map(int, stdin.split())\n    count = 0\n    while a != b:\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a += 1\n        count += 1\n    return count\n"
    }
]