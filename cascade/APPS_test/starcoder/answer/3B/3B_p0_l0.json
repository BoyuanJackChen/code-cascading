[
    {
        "number": 4000,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    max_edges = 0\n    max_path = []\n    for u in range(1, n + 1):\n        visited = [False] * (n + 1)\n        dfs(u, visited)\n        for v in range(1, n + 1):\n            if visited[v]:\n                max_edges = max(max_edges, len(graph[u]) + len(graph[v]) - 2)\n                max_path.append(u)\n                max_path.append(v)\n\n    return str(max_edges) + '\\n' +''.join(map(str, max_path))"
    },
    {
        "number": 4001,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *divisors = map(int, stdin.split())\n    divisors = set(divisors)\n    for divisor in divisors:\n        if divisor % 2 == 0:\n            return \"IMPOSSIBLE\"\n\n    x, y = 1, 1\n    while True:\n        if x in divisors and y in divisors:\n            return f\"{x} {y}\"\n        x += 1\n        y += 1"
    },
    {
        "number": 4002,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def max_sum(row):\n        return max(row)\n\n    def min_sum(row):\n        return min(row)\n\n    def sum_divisible_by_k(row):\n        return sum(x for x in row if x % k == 0)\n\n    def choose_elements(row, max_sum_divisible_by_k):\n        chosen_elements = []\n        for i in range(len(row)):\n            if sum_divisible_by_k(row[:i]) + sum_divisible_by_k(row[i:]) <= max_sum_divisible_by_k:\n                chosen_elements.append(row[i])\n        return chosen_elements\n\n    chosen_rows = []\n    max_sum_divisible_by_k = 0\n\n    for row in a:\n        chosen_elements = choose_elements(row, max_sum_divisible_by_k)\n        chosen_rows.append(chosen_elements)\n        max_sum_divisible_by_k = max(max_sum_divisible_by_k, sum_divisible_by_k(chosen_elements))\n\n    chosen_rows = [row for row in chosen_rows if row]\n    chosen_rows.sort(key=lambda x: sum_divisible_by_k(x), reverse=True)\n\n    return str(sum_divisible_by_k(chosen_rows[0]))"
    },
    {
        "number": 4003,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_increasing(seq):\n        return all(seq[i] <= seq[i + 1] for i in range(len(seq) - 1))\n\n    def longest_increasing_subsequence(seq):\n        increasing_subsequences = []\n        for i in range(len(seq)):\n            increasing_subsequences.append(seq[:i] + seq[i + 1:])\n        return max(increasing_subsequences, key=len)\n\n    def longest_increasing_subsequence_length(seq):\n        increasing_subsequences = []\n        for i in range(len(seq)):\n            increasing_subsequences.append(seq[:i] + seq[i + 1:])\n        return max(len(s) for s in increasing_subsequences)\n\n    increasing_subsequences = longest_increasing_subsequence(a)\n    longest_increasing_subsequence_length_k = longest_increasing_subsequence_length(increasing_subsequences)\n\n    if longest_increasing_subsequence_length_k == len(increasing_subsequences):\n        return str(longest_increasing_subsequence_length_k)\n\n    for i in range(len(increasing_subsequences)):\n        if len(increasing_subsequences[i]) == longest_increasing_subsequence_length_k:\n            return ''.join('L' if a[j] in increasing_subsequences[i] else 'R' for j in range(n))\n\n    return ''"
    },
    {
        "number": 4004,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_diff(a: list) -> int:\n        min_diff = float('inf')\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                diff = abs(a[i] - a[j])\n                min_diff = min(min_diff, diff)\n        return min_diff\n\n    def min_diff_with_changes(a: list) -> int:\n        min_diff = float('inf')\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                diff = abs(a[i] - a[j])\n                min_diff = min(min_diff, diff)\n                if diff == 0:\n                    min_diff = min(min_diff, abs(a[i] - a[j]))\n        return min_diff\n\n    min_diff_value = min_diff(a)\n    if min_diff_value == float('inf'):\n        return -1\n\n    min_diff_with_changes_value = min_diff_with_changes(a)\n    if min_diff_with_changes_value == float('inf'):\n        return -1\n\n    return str(min(min_diff_value, min_diff_with_changes_value))\n"
    },
    {
        "number": 4005,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x3, y3, x4, y4 = map(int, stdin.split())\n    x5, y5, x6, y6 = map(int, stdin.split())\n\n    def is_inside(x: float, y: float) -> bool:\n        return 0 <= x <= 1 and 0 <= y <= 1\n\n    def is_outside(x: float, y: float) -> bool:\n        return not is_inside(x, y)\n\n    def is_visible(x: float, y: float) -> bool:\n        return is_inside(x, y) and not (is_outside(x3, y3) or is_outside(x4, y4) or is_outside(x5, y5) or is_outside(x6, y6))\n\n    if is_visible(x1, y1) or is_visible(x2, y2):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 4006,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if i == 1:\n            count += 1\n        else:\n            while i % 10 == 0:\n                i //= 10\n            count += 1\n    return str(count)"
    },
    {
        "number": 4007,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    friends = list(map(int, stdin.split()[1:]))\n\n    def dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        return dfs(friends[node - 1], visited)\n\n    def bfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_bfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if bfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs_bfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if bfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs_bfs_dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs_bfs_dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def dfs_bfs_dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs_bfs_dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs_bfs_dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs_bfs_dfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs_bfs_dfs_bfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n\n        if node == 0:\n            return 1\n\n        for neighbor in range(1, n + 1):\n            if neighbor!= node and neighbor!= friends[node - 1]:\n                if dfs_bfs_dfs_bfs(neighbor, visited) == 1:\n                    return 1\n\n        return 0\n\n    def fill_in_unknowns_dfs_bfs_dfs_bfs_bfs("
    }
]