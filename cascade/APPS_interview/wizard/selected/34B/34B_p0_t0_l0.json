[
    {
        "number": 0,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 4:\n        return \"-1\"\n\n    opening_bracket = \"[\"\n    closing_bracket = \"]\"\n    colon = \":\"\n    vertical_line = \"|\"\n\n    if s[0] != opening_bracket or s[-1] != closing_bracket:\n        return \"-1\"\n\n    max_length = 0\n    current_length = 0\n\n    for i in range(len(s)):\n        if s[i] == opening_bracket and current_length == 0:\n            current_length += 1\n        elif s[i] == colon and current_length == 1:\n            current_length += 1\n        elif s[i] == vertical_line and current_length == 2:\n            current_length += 1\n        elif s[i] == colon and current_length == 3:\n            current_length += 1\n        elif s[i] == closing_bracket and current_length == 4:\n            current_length = 0\n            max_length = i + 1\n\n    return str(max_length) if max_length > 0 else \"-1\"",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 1,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    max_sum = 0\n    max_number = 0\n\n    for i in range(1, x + 1):\n        sum_of_digits = sum(int(digit) for digit in str(i))\n        if sum_of_digits > max_sum:\n            max_sum = sum_of_digits\n            max_number = i\n        elif sum_of_digits == max_sum:\n            max_number = max(max_number, i)\n\n    return str(max_number)",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 2,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin)\n    next_lucky_year = year + 1\n    while True:\n        if len(set(str(next_lucky_year))) <= 2:\n            break\n        next_lucky_year += 1\n    return str(next_lucky_year - year)",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 3,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    painters = []\n    for _ in range(q):\n        l, r = map(int, input().split())\n        painters.append((l, r))\n\n    painters.sort(key=lambda x: x[1])\n\n    max_painted = 0\n    current_painted = 0\n    for i in range(q - 2):\n        current_painted = max(current_painted, painters[i][1])\n        max_painted = max(max_painted, current_painted)\n\n    return str(max_painted)",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 4,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, hh, mm = map(int, stdin.split())\n\n    def is_lucky(time: int) -> bool:\n        return '7' in str(time)\n\n    def minutes_before(hh: int, mm: int, minutes: int) -> tuple:\n        total_minutes = hh * 60 + mm\n        new_time = total_minutes - minutes\n        new_hh, new_mm = new_time // 60, new_time % 60\n        return new_hh, new_mm\n\n    def find_lucky_time(x: int, hh: int, mm: int) -> int:\n        y = 0\n        while not is_lucky(y):\n            y += 1\n            new_hh, new_mm = minutes_before(hh, mm, x * y)\n            if new_hh < hh or (new_hh == hh and new_mm <= mm):\n                return y\n        return y\n\n    return str(find_lucky_time(x, hh, mm))",
        "test": "",
        "num_ids": 255,
        "indeed": false
    },
    {
        "number": 5,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pos, l, r = map(int, stdin.split())\n    a = l - 1\n    b = r + 1\n\n    if pos < l:\n        return str(l - pos - 1)\n    elif pos > r:\n        return str(r - pos + 1)\n    else:\n        return \"0\"",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 6,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_blows(n, x, d, h):\n        q = [(x, 0)]\n        visited = set()\n        while q:\n            curX, curBlows = q.pop(0)\n            if curX == 0:\n                return curBlows\n            if (curX, curBlows) in visited:\n                continue\n            visited.add((curX, curBlows))\n            for i in range(n):\n                newX = curX - min(d[i], curX)\n                if newX > 0:\n                    q.append((newX + h[i], curBlows + 1))\n        return -1\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, x = map(int, stdin.readline().split())\n        d = []\n        h = []\n        for _ in range(n):\n            d_i, h_i = map(int, stdin.readline().split())\n            d.append(d_i)\n            h.append(h_i)\n        result.append(min_blows(n, x, d, h))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 7,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = 1\n    grains = n\n    while grains > 0:\n        grains -= m\n        if grains < 0:\n            grains += m\n        days += 1\n        sparrows = days\n        for i in range(1, sparrows):\n            grains -= i\n        if grains <= 0:\n            break\n    return str(days)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 8,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_mentsu(tiles):\n        if len(tiles) < 3:\n            return False\n        for i in range(len(tiles) - 2):\n            if tiles[i] == tiles[i + 1] == tiles[i + 2]:\n                return True\n            if tiles[i] + 1 == tiles[i + 1] + 1 == tiles[i + 2] + 1:\n                return True\n        return False\n\n    def count_mentsu(tiles):\n        count = 0\n        for i in range(len(tiles) - 2):\n            if tiles[i] == tiles[i + 1] == tiles[i + 2]:\n                count += 1\n            if tiles[i] + 1 == tiles[i + 1] + 1 == tiles[i + 2] + 1:\n                count += 1\n        return count\n\n    tiles = [int(x[0]) for x in stdin.split()]\n    tiles.sort()\n\n    if is_mentsu(tiles):\n        return 0\n\n    for i in range(len(tiles) - 2):\n        if tiles[i] + 1 == tiles[i + 1] + 1 == tiles[i + 2] + 1:\n            return 1\n\n    return min(count_mentsu(tiles), 1)",
        "test": "",
        "num_ids": 351,
        "indeed": false
    },
    {
        "number": 9,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_left(a, b):\n        return a[0] < b[0] and a[1] == b[1]\n\n    def is_right(a, b):\n        return a[0] > b[0] and a[1] == b[1]\n\n    def is_top(a, b):\n        return a[1] < b[1] and a[0] == b[0]\n\n    def is_bottom(a, b):\n        return a[1] > b[1] and a[0] == b[0]\n\n    def count_sofas(sofas, condition):\n        result = 0\n        for i in range(len(sofas)):\n            for j in range(len(sofas)):\n                if i != j and condition(sofas[i], sofas[j]):\n                    result += 1\n        return result\n\n    def find_sofa(sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n        for i, sofa in enumerate(sofas, start=1):\n            if count_sofas([sofa], is_left) == cnt_l and \\\n               count_sofas([sofa], is_right) == cnt_r and \\\n               count_sofas([sofa], is_top) == cnt_t and \\\n               count_sofas([sofa], is_bottom) == cnt_b:\n                return i\n        return -1\n\n    d, n, m = map(int, stdin.readline().split())\n    sofas = [tuple(map(int, stdin.readline().split())) for _ in range(d)]\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, stdin.readline().split())\n\n    return str(find_sofa(sofas, cnt_l, cnt_r, cnt_t, cnt_b))",
        "test": "",
        "num_ids": 469,
        "indeed": false
    },
    {
        "number": 10,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    min_days_off = n // 7 * 2\n    max_days_off = min_days_off + 2\n    return f\"{min_days_off} {max_days_off}\"",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 11,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, p, q = map(int, stdin.split())\n    red_tiles = [i for i in range(1, n + 1) if i % a == 0]\n    blue_tiles = [i for i in range(1, n + 1) if i % b == 0]\n    common_tiles = set(red_tiles) & set(blue_tiles)\n    red_chocolates = len(red_tiles) - len(common_tiles)\n    blue_chocolates = len(blue_tiles) - len(common_tiles)\n    common_chocolates = len(common_tiles) * (p + q)\n    total_chocolates = red_chocolates * p + blue_chocolates * q + common_chocolates\n    return str(total_chocolates)",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 12,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, trophies = int(stdin.split(\"\\n\")[0]), stdin.split(\"\\n\")[1]\n    max_length = 0\n    current_length = 0\n    for i in range(n):\n        if trophies[i] == \"G\":\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n    max_length = max(max_length, current_length)\n\n    if max_length == 0:\n        return \"0\"\n\n    for i in range(n):\n        if trophies[i] == \"S\":\n            for j in range(i + 1, n):\n                if trophies[j] == \"G\":\n                    trophies = list(trophies)\n                    trophies[i], trophies[j] = trophies[j], trophies[i]\n                    new_max_length = 0\n                    new_current_length = 0\n                    for k in range(n):\n                        if trophies[k] == \"G\":\n                            new_current_length += 1\n                        else:\n                            new_max_length = max(new_max_length, new_current_length)\n                            new_current_length = 0\n                    new_max_length = max(new_max_length, new_current_length)\n                    if new_max_length > max_length:\n                        max_length = new_max_length\n                        trophies = \"\".join(trophies)\n                    trophies = list(trophies)\n                    trophies[i], trophies[j] = trophies[j], trophies[i]\n                    trophies = \"\".join(trophies)\n                    break\n\n    return str(max_length)",
        "test": "",
        "num_ids": 459,
        "indeed": false
    },
    {
        "number": 13,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, course, result):\n        visited[course] = True\n        for next_course in graph[course]:\n            if not visited[next_course]:\n                dfs(graph, visited, next_course, result)\n        result.append(course)\n\n    def topological_sort(graph, main_courses):\n        visited = [False] * (len(graph) + 1)\n        result = []\n        for main_course in main_courses:\n            if not visited[main_course]:\n                dfs(graph, visited, main_course, result)\n        return result[::-1]\n\n    def build_graph(n, dependencies):\n        graph = [[] for _ in range(n + 1)]\n        for i, dependency in enumerate(dependencies):\n            for course in dependency:\n                graph[course].append(i + 1)\n        return graph\n\n    n, k = map(int, stdin.readline().split())\n    main_courses = list(map(int, stdin.readline().split()))\n    dependencies = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    graph = build_graph(n, dependencies)\n    sorted_courses = topological_sort(graph, main_courses)\n\n    if len(sorted_courses) != n:\n        return \"-1\"\n\n    return f\"{len(sorted_courses)}\\n{' '.join(map(str, sorted_courses))}\"",
        "test": "",
        "num_ids": 359,
        "indeed": false
    },
    {
        "number": 14,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n\n    if k == n:\n        return -1\n\n    s = []\n    b = []\n\n    for i in range(k, 0, -1):\n        s.append(p[i - 1])\n\n    for i in range(k, n):\n        b.append(i + 1)\n\n    for i in range(len(b)):\n        if b[i] not in p:\n            p.insert(i + k, b[i])\n\n    return \" \".join(map(str, p))\n",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 15,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a == b:\n        return \"YES\"\n    while a < b:\n        a += c\n    if a == b:\n        return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 16,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, cnt_3, cnt_4 = map(int, stdin.splitlines())\n\n    if cnt_1 % 2 != 0 or cnt_2 % 2 != 0 or cnt_3 % 2 != 0 or cnt_4 % 2 != 0:\n        return \"0\"\n\n    return \"1\"",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 17,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = map(int, stdin.split())\n    standing_spectators = 0\n    for i in range(1, n + 1):\n        if t >= i and t <= n + i - k:\n            standing_spectators += 1\n        elif t == n + i - k + 1:\n            break\n    return str(standing_spectators)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 18,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    t = \"\"\n    u = \"\"\n\n    while s:\n        t += s[0]\n        s = s[1:]\n        if not s:\n            break\n        u = s[-1] + u\n        s = s[:-1]\n\n    return u",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 19,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_valid(stats: list) -> bool:\n        for i in range(1, len(stats)):\n            if stats[i][0] < stats[i - 1][0]:\n                return False\n            if stats[i][1] < stats[i - 1][1]:\n                return False\n        return True\n\n    test_cases = int(stdin.readline())\n    results = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        stats = []\n        for _ in range(n):\n            stats.append(list(map(int, stdin.readline().split())))\n        results.append(\"YES\" if check_valid(stats) else \"NO\")\n\n    return \"\\n\".join(results)\n",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 20,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split(':'))\n    total_minutes = hh * 60 + mm\n    if total_minutes % 2 == 1:\n        total_minutes += 1\n    hh, mm = divmod(total_minutes, 60)\n    hh %= 24\n    return str(hh).zfill(2) + ':' + str(mm).zfill(2)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 21,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    if min_index < max_index:\n        min_index_candidate = max_index\n        max_index_candidate = min_index\n    else:\n        min_index_candidate = min_index\n        max_index_candidate = max_index\n\n    for i in range(min_index + 1, max_index):\n        if a[i] == 1:\n            min_index_candidate = i\n        elif a[i] == n:\n            max_index_candidate = i\n\n    return abs(min_index_candidate - max_index_candidate)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 22,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return \"NIE\"\n    return \"TAK\"",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 23,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    a_str = str(a)\n    b_str = str(b)\n    max_num = \"\"\n\n    for digit in sorted(a_str, reverse=True):\n        while digit in a_str and int(max_num + digit) <= b:\n            max_num += digit\n            a_str = a_str.replace(digit, \"\", 1)\n\n    return max_num",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 24,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(line.strip()) for line in stdin.split('\\n')]\n    crosses = [(i, j) for i in range(10) for j in range(10) if matrix[i][j] == 'X']\n    noughts = [(i, j) for i in range(10) for j in range(10) if matrix[i][j] == 'O']\n    empty_cells = [(i, j) for i in range(10) for j in range(10) if matrix[i][j] == '.']\n\n    def check_win(cells):\n        for i in range(10):\n            for j in range(10):\n                if matrix[i][j] == '.':\n                    matrix[i][j] = 'X'\n                    if (i, j) in cells:\n                        if i + 4 <= 9 and all(matrix[x][y] == 'X' for x, y in [(i + k, j) for k in range(5)]):\n                            return True\n                        if j + 4 <= 9 and all(matrix[x][y] == 'X' for x, y in [(i, j + k) for k in range(5)]):\n                            return True\n                        if i + 4 <= 9 and j + 4 <= 9 and all(matrix[x][y] == 'X' for x, y in [(i + k, j + k) for k in range(5)]):\n                            return True\n                        if i - 4 >= 0 and j + 4 <= 9 and all(matrix[x][y] == 'X' for x, y in [(i - k, j + k) for k in range(5)]):\n                            return True\n                    matrix[i][j] = '.'\n        return False\n\n    if check_win(crosses) or check_win(noughts):\n        return 'NO'\n    else:\n        return 'YES' ",
        "test": "",
        "num_ids": 473,
        "indeed": false
    },
    {
        "number": 25,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * (n + 1) // 2:\n        return \"-1\"\n\n    matrix = [[0] * n for _ in range(n)]\n    row, col = 0, 0\n    for _ in range(k):\n        matrix[row][col] = 1\n        if col + 1 < n and matrix[row][col + 1] == 0:\n            col += 1\n        else:\n            row += 1\n            col = 0\n\n    return \"\\n\".join(\" \".join(str(x) for x in row) for row in matrix)",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 26,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(float, stdin.split())\n    expressions = [\n        f\"x^y^z\", f\"x^z^y\", f\"(x^y)^z\", f\"(x^z)^y\",\n        f\"y^x^z\", f\"y^z^x\", f\"(y^x)^z\", f\"(y^z)^x\",\n        f\"z^x^y\", f\"z^y^x\", f\"(z^x)^y\", f\"(z^y)^x\"\n    ]\n    values = [eval(expr) for expr in expressions]\n    max_value = max(values)\n    max_index = values.index(max_value)\n    return expressions[max_index]",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 27,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    if n == 1:\n        return 1\n\n    if len(set(s)) == 1:\n        return 4\n\n    if n % 2 == 0 and s[:n // 2] == s[n // 2:]:\n        return n // 2 + 2\n\n    return n\n",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 28,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    files = []\n    examples = []\n    for _ in range(n):\n        name, is_example = stdin.readline().strip().split()\n        if int(is_example):\n            examples.append(name)\n        else:\n            files.append(name)\n\n    lines = []\n    for i, example in enumerate(examples):\n        lines.append(f\"move {example} {i + 1}\")\n\n    for i, file in enumerate(files):\n        lines.append(f\"move {file} {len(examples) + i + 1}\")\n\n    return f\"{len(lines)}\\n\" + \"\\n\".join(lines)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 29,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    ticket = [int(x) for x in stdin]\n    total_sum = sum(ticket)\n    first_sum = sum(ticket[:3])\n    last_sum = sum(ticket[3:])\n\n    if first_sum == last_sum:\n        return 0\n\n    diff = abs(first_sum - last_sum)\n    if diff > 9:\n        return -1\n\n    if diff == 0:\n        return 1\n\n    if total_sum - diff < diff:\n        return -1\n\n    return 1",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 30,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, x = map(int, stdin.split())\n    return str(m - 1)",
        "test": "",
        "num_ids": 26,
        "indeed": false
    },
    {
        "number": 31,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = 1\n    B = 2**n\n    for i in range(1, k+1):\n        A *= (B - i)\n        B *= (i)\n    A %= (10**6 + 3)\n    B %= (10**6 + 3)\n    return f\"{A} {B}\"",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 32,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    data = [line.split() for line in stdin.split('\\n')[1:n+1]]\n    pos = 0\n    for i in range(n):\n        if data[i][1] == \"North\":\n            pos += int(data[i][0])\n        elif data[i][1] == \"South\":\n            pos -= int(data[i][0])\n        elif data[i][1] == \"West\":\n            continue\n        elif data[i][1] == \"East\":\n            continue\n    if pos == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 33,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, b1, a2, b2, L, R = map(int, stdin.split())\n\n    count = 0\n    for k in range(R - L + 1):\n        x1 = a1 * k + b1\n        x2 = a2 * k + b2\n\n        if L <= x1 <= R and L <= x2 <= R:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 34,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    x = min(a, b) // n\n    if a % n <= x and b % n <= x:\n        return str(x)\n    else:\n        return \"IMPOSSIBLE\"",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 35,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = [stdin.readline().strip() for _ in range(n)]\n\n    if n % 3 != 0 or m % 3 != 0:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == \"R\" and i < n // 3:\n                continue\n            elif field[i][j] == \"G\" and i < n * 2 // 3:\n                continue\n            elif field[i][j] == \"B\" and i >= n * 2 // 3:\n                continue\n            else:\n                return \"NO\"\n\n    return \"YES\"\n",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 36,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x, y = 0, 0\n    dx, dy = 0, -1\n\n    for i in range(n):\n        if x == y or (x < 0 and x == -y) or (x > 0 and x == 1 - y):\n            dx, dy = -dy, dx\n\n        x, y = x + dx, y + dy\n\n    return f\"{x} {y}\"",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 37,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    for i in range(c // a + 1):\n        for j in range(c // b + 1):\n            if a * i + b * j == c:\n                return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 71,
        "indeed": true
    },
    {
        "number": 38,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split()[0:2])\n    kefa = list(map(int, stdin.split()[2:2 + n]))\n    sasha = list(map(int, stdin.split()[2 + n:2 + 2 * n]))\n\n    if kefa == sasha:\n        return \"YES\"\n\n    for i in range(1, L):\n        kefa_shifted = [x + i for x in kefa]\n        if kefa_shifted == sasha:\n            return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 39,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_non_palindrome_substring(s: str) -> int:\n        max_length = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if not is_palindrome(s[i:j]):\n                    max_length = max(max_length, j - i)\n        return max_length\n\n    return str(longest_non_palindrome_substring(stdin))",
        "test": "",
        "num_ids": 148,
        "indeed": true
    },
    {
        "number": 40,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    ratings_before = []\n    ratings_after = []\n\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        ratings_before.append(a)\n        ratings_after.append(b)\n\n    is_rated = False\n    for i in range(n - 1):\n        if ratings_before[i] < ratings_before[i + 1] and ratings_after[i] > ratings_after[i + 1]:\n            is_rated = True\n            break\n\n    if is_rated:\n        return \"rated\"\n\n    for i in range(n):\n        if ratings_before[i] != ratings_after[i]:\n            return \"rated\"\n\n    return \"maybe\"",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 41,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    zeros = [i for i in range(n) if a[i] == 0]\n    result = []\n    for i in range(n):\n        if a[i] == 0:\n            result.append(0)\n        else:\n            distances = [abs(i - z) for z in zeros]\n            result.append(min(distances))\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 136,
        "indeed": true
    },
    {
        "number": 42,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split('\\n'))\n    n = int(n)\n\n    def is_cyclical_substring(t: str, s: str) -> bool:\n        for i in range(len(t)):\n            if s in t[i:] + t[:i]:\n                return True\n        return False\n\n    total = 0\n    for i in range(2**n):\n        t = bin(i)[2:].zfill(n)\n        if is_cyclical_substring(t, s):\n            total += 1\n\n    return str(total)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 43,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dot_product(a, b):\n        return a[0] * b[0] + a[1] * b[1]\n\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def angle(a, b):\n        return abs(math.atan2(cross_product(a, b), dot_product(a, b)))\n\n    n = int(stdin.readline())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        vectors.append((x, y))\n\n    min_angle = float('inf')\n    min_pair = None\n    for i in range(n):\n        for j in range(i + 1, n):\n            a = vectors[i]\n            b = vectors[j]\n            if a != (-b[0], -b[1]):\n                current_angle = angle(a, b)\n                if current_angle < min_angle:\n                    min_angle = current_angle\n                    min_pair = (i + 1, j + 1)\n\n    return f\"{min_pair[0]} {min_pair[1]}\\n\"",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 44,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k, a, b, t = map(int, stdin.split())\n    time = 0\n    distance = 0\n    while distance < d:\n        if distance + k <= d:\n            time += k / a\n            distance += k\n        else:\n            time += (d - distance) / a\n            distance = d\n        time += t\n        if distance < d:\n            time += b\n    return str(int(time))",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 45,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return \"1\"\n    if n < k:\n        return \"-1\"\n    a = [1] * k\n    for i in range(k):\n        a[i] += (n - k) // k\n    if (n - k) % k != 0:\n        a[-1] += 1\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 46,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i + j) % 5 == 0:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 47,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def beauty(arr):\n        return max(sum(arr), 0)\n\n    def max_beauty(n, x, a):\n        ans = beauty(a)\n        for i in range(n):\n            for j in range(i, n):\n                temp = [val * x for val in a[i:j + 1]]\n                ans = max(ans, beauty(temp) + beauty(a[:i]) + beauty(a[j + 1:]))\n        return ans\n\n    return str(max_beauty(n, x, a))",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 48,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            table[i][j] = (i + 1) * (j + 1)\n\n    flattened_table = [num for row in table for num in row]\n    flattened_table.sort(reverse=True)\n\n    return str(flattened_table[k - 1])",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 49,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    num = 1\n    digits = 1\n    while digits < k:\n        num += 1\n        digits += len(str(num))\n    num_str = str(num)\n    return num_str[k - digits - 1]",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 50,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[0].split())\n    s = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    s.sort()\n    b.sort(reverse=True)\n\n    for i in range(min(n, m)):\n        r += s[i] * (min(n, m) - i)\n        r -= b[i] * (min(n, m) - i)\n\n    return str(r)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 52,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n    for i in range(2, 20):\n        if (i * (i - 1) // 2) + ((i // 2) * (i // 2 - 1) // 2) == n:\n            result.append(i)\n    if not result:\n        return \"-1\"\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 53,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def is_antipalindromic(s: str) -> bool:\n        for i in range(len(s) // 2):\n            if s[i] == s[-i - 1]:\n                return False\n        return True\n\n    def get_beauty(s: str, t: str, b: list) -> int:\n        beauty = 0\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                beauty += b[i]\n        return beauty\n\n    if not is_antipalindromic(s):\n        return \"The string s is not antipalindromic.\"\n\n    t = list(s)\n    max_beauty = get_beauty(s, ''.join(t), b)\n\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            t[i], t[n - i - 1] = t[n - i - 1], t[i]\n            temp_beauty = get_beauty(s, ''.join(t), b)\n            max_beauty = max(max_beauty, temp_beauty)\n            t[i], t[n - i - 1] = t[n - i - 1], t[i]\n\n    return max_beauty",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 54,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m = map(int, stdin.split())\n    if m % w == 0:\n        return 'YES'\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 42,
        "indeed": false
    },
    {
        "number": 55,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def find_sequence(n: int, k: int, start: int = 0) -> List[int]:\n        if k == 0:\n            return []\n        if n == 1:\n            return [start]\n        if n % 2 == 1:\n            return None\n        n //= 2\n        k -= 1\n        return [start + n] + find_sequence(n, k, start + n)\n\n    sequence = find_sequence(n, k)\n    if sequence is None:\n        return \"No\"\n    return \"Yes\\n\" + \" \".join(map(str, sequence))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 56,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    full_glasses = 0\n    for i in range(1, n + 1):\n        full_glasses += i\n    full_glasses -= (t - n) * (n - 1) // 2\n    return str(full_glasses)",
        "test": "",
        "num_ids": 79,
        "indeed": false
    },
    {
        "number": 57,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    if n == 2:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        area = abs(x1 * y2 - x2 * y1)\n    elif n == 4:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x3, y3 = points[2]\n        x4, y4 = points[3]\n        area = abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))\n    else:\n        area = -1\n\n    return str(area)",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 58,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    return str(max(a + b, n))",
        "test": "",
        "num_ids": 31,
        "indeed": false
    },
    {
        "number": 59,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    swappable = stdin.split('\\n')[2]\n\n    for i in range(n - 1):\n        if swappable[i] == '1':\n            continue\n        if a[i] > a[i + 1]:\n            return 'NO'\n\n    return 'YES'",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 60,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin[0], stdin[1]\n    n = int(n)\n    if s == 'f':\n        return '1'\n    elif s == 'e':\n        return '10'\n    elif s == 'd':\n        return '18'\n    elif s == 'c':\n        return '20'\n    elif s == 'b':\n        return '21'\n    elif s == 'a':\n        return '22'",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 61,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, bx = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    m, by = map(int, stdin.readline().split())\n    y = list(map(int, stdin.readline().split()))\n\n    # Convert to decimal\n    decimal_x = sum(xi * bx**(n-1-i) for i, xi in enumerate(x))\n    decimal_y = sum(yi * by**(m-1-i) for i, yi in enumerate(y))\n\n    # Compare\n    if decimal_x < decimal_y:\n        return '<'\n    elif decimal_x > decimal_y:\n        return '>'\n    else:\n        return '='",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 62,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    while True:\n        min_a = min(a)\n        if min_a == 0:\n            return \"BitAryo\"\n        if all(x == 1 for x in a):\n            return \"BitLGM\"\n\n        a_min = min(a)\n        a_min_index = a.index(a_min)\n        a[a_min_index] -= 1\n\n        for i in range(n):\n            if i == a_min_index:\n                continue\n            a[i] -= min_a\n\n    return \"BitAryo\"",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 63,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    valid_count = 0\n\n    for x in range(n):\n        for y in range(n):\n            if x + y >= n:\n                continue\n            product = 1\n            for i in range(x + 1, n - y):\n                product *= a[i]\n            if product % k == 0:\n                valid_count += 1\n\n    return str(valid_count)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 64,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    colors = set(s)\n\n    if len(colors) >= k:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 58,
        "indeed": false
    },
    {
        "number": 65,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    min_val = min(arr)\n    min_indexes = [i for i in range(n) if arr[i] == min_val]\n    min_indexes.sort()\n    min_dist = min_indexes[1] - min_indexes[0]\n    return str(min_dist)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 66,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, w, b = map(int, stdin.split())\n    p = 0\n    for L in range(1, t + 1):\n        if L % gcd(w, b) == 0:\n            p += 1\n    q = t\n    g = gcd(p, q)\n    return f\"{p//g}/{q//g}\"\n\ndef",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 67,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    upvotes = x + z\n    downvotes = y + z\n\n    if upvotes > downvotes:\n        return \"+\"\n    elif upvotes < downvotes:\n        return \"-\"\n    else:\n        return \"0\" if z == 0 else \"?\"",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 68,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, operations, x, y = stdin.split('\\n')\n    n = int(n)\n    x, y = map(int, (x, y))\n\n    if x < 0 or y < 0:\n        return \"-1\"\n\n    min_length = float('inf')\n    min_length_id = None\n    max_length_id = None\n\n    current_x = 0\n    current_y = 0\n\n    for i in range(n):\n        if operations[i] == 'U':\n            current_y += 1\n        elif operations[i] == 'D':\n            current_y -= 1\n        elif operations[i] == 'L':\n            current_x -= 1\n        elif operations[i] == 'R':\n            current_x += 1\n\n        if current_x == x and current_y == y:\n            length = i + 1\n            if length < min_length:\n                min_length = length\n                min_length_id = i\n                max_length_id = i\n            elif length == min_length:\n                max_length_id = i\n\n    if min_length_id is None:\n        return \"-1\"\n\n    return str(max_length_id - min_length_id + 1)",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 69,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_prefixes(n: int, x: int, s: str) -> int:\n        cnt_0, cnt_1 = 0, 0\n        for i in range(n):\n            if s[i] == '0':\n                cnt_0 += 1\n            else:\n                cnt_1 += 1\n\n            if cnt_0 - cnt_1 == x:\n                return i + 1\n\n        return -1\n\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        n, x = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n        result.append(count_prefixes(n, x, s))\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 70,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_str = str(n)\n    w = 0\n\n    if n == 0:\n        return str(w)\n\n    while n % 10**k != 0:\n        if n_str[w] != '0':\n            w += 1\n        n //= 10\n\n    return str(w)\n",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 71,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x, y = map(int, stdin.split())\n\n    max_questions = 0\n    min_questions = k // (n * m)\n    sergei_questions = 0\n\n    if x == 1:\n        max_questions += 1\n        if y == 1:\n            sergei_questions += 1\n    if x == n:\n        max_questions += 1\n        if y == m:\n            sergei_questions += 1\n\n    if n > 1:\n        max_questions += 2\n        if x % 2 == 1:\n            if y == 1:\n                sergei_questions += 1\n            max_questions += 1\n        else:\n            if y == m:\n                sergei_questions += 1\n            max_questions += 1\n\n    return f\"{max_questions} {min_questions} {sergei_questions}\"",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 72,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_beauty(s: str) -> int:\n        max_beauty = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                subribbon = s[i:j]\n                beauty = s.count(subribbon)\n                max_beauty = max(max_beauty, beauty)\n        return max_beauty\n\n    def change_ribbon(ribbon: str, i: int, new_color: str) -> str:\n        return ribbon[:i] + new_color + ribbon[i + 1:]\n\n    def play_game(n: int, kuro: str, shiro: str, katie: str) -> str:\n        max_beauty = 0\n        winner = \"\"\n        for i in range(len(kuro)):\n            for new_color in \"abcdefghijklmnopqrstuvwxyz\":\n                if new_color != kuro[i]:\n                    new_kuro = change_ribbon(kuro, i, new_color)\n                    if get_beauty(new_kuro) > max_beauty:\n                        max_beauty = get_beauty(new_kuro)\n                        winner = \"Kuro\"\n        for i in range(len(shiro)):\n            for new_color in \"abcdefghijklmnopqrstuvwxyz\":\n                if new_color != shiro[i]:\n                    new_shiro = change_ribbon(shiro, i, new_color)\n                    if get_beauty(new_shiro) > max_beauty:\n                        max_beauty = get_beauty(new_shiro)\n                        winner = \"Shiro\"\n        for i in range(len(katie)):\n            for new_color in \"abcdefghijklmnopqrstuvwxyz\":\n                if new_color != katie[i]:\n                    new_katie = change_ribbon(katie, i, new_color)\n                    if get_beauty(new_katie) > max_beauty:\n                        max_beauty = get_beauty(new_katie)\n                        winner = \"Katie\"\n        return winner\n\n    n = int(stdin.readline().strip())\n    kuro = stdin.readline().strip()\n    shiro = stdin.readline().strip()\n    katie = stdin.readline().strip()\n\n    return play_game(n, kuro, shiro, katie)",
        "test": "",
        "num_ids": 635,
        "indeed": false
    },
    {
        "number": 73,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, v_0, v_1, a, l = map(int, stdin.split())\n\n    days = 1\n    total_pages_read = v_0\n\n    while total_pages_read < c:\n        days += 1\n        total_pages_read += v_0 + a * days\n        total_pages_read = min(total_pages_read, c)\n\n    return str(days)",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 74,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 3\n    primes = []\n\n    # Find at most 3 prime numbers that sum up to n\n    for i in range(2, n):\n        if len(primes) == k:\n            break\n        if is_prime(i) and n - i >= i and is_prime(n - i):\n            primes.append(i)\n            primes.append(n - i)\n    if len(primes) < k:\n        for i in range(2, n):\n            if len(primes) == k:\n                break\n            if is_prime(i) and n - i >= i and is_prime(n - i) and n - i - i >= i and is_prime(n - i - i):\n                primes.append(i)\n                primes.append(n - i - i)\n                primes.append(n - i)\n\n    # Check if there is a solution with at most 3 prime numbers\n    if len(primes) < k:\n        for i in range(2, n):\n            if len(primes) == k:\n                break\n            if is_prime(i) and n - i >= i and is_prime(n - i) and n - i - i >= i and is_prime(n - i - i) and n - i - i - i >= i and is_prime(n - i - i - i):\n                primes.append(i)\n                primes.append(n - i - i - i)\n                primes.append(n - i - i)\n                primes.append(n - i)\n\n    # If there is no solution, return -1\n    if len(primes) == 0:\n        return \"-1\"\n\n    # Sort the prime numbers and return the result\n    primes.sort()\n    return f\"{len(primes)}\\n{' '.join(map(str, primes))}\"\n\ndef",
        "test": "",
        "num_ids": 463,
        "indeed": false
    },
    {
        "number": 75,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def can_wipe_out_walls(x: int, y: int) -> bool:\n        if not (0 <= x < n and 0 <= y < m):\n            return False\n        if field[x][y] == \"*\":\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if can_wipe_out_walls(i, j) and can_wipe_out_walls(i, y) and can_wipe_out_walls(x, j):\n                return \"YES\\n{0} {1}\".format(i + 1, j + 1)\n\n    return \"NO\"\n",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 76,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n\n    if n % m != 0:\n        boxes_to_build = m - (n % m)\n        total_cost = boxes_to_build * a\n\n        if total_cost > b:\n            boxes_to_build = n // m + 1\n            total_cost = (boxes_to_build - n // m) * a + (n - n // m * (n // m)) * b\n        else:\n            total_cost += (n // m) * b\n    else:\n        total_cost = 0\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 77,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    even_sum = 0\n    odd_sum = 0\n\n    for i in range(n):\n        if a[i] % 2 == 0:\n            even_sum += a[i]\n        else:\n            odd_sum += a[i]\n\n    return str(max(even_sum, odd_sum))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 78,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(playlist: List[int]) -> bool:\n        for i in range(len(playlist) - 1):\n            if songs[playlist[i]][1] == songs[playlist[i + 1]][1]:\n                return False\n        return True\n\n    def count_sequences(T: int, index: int, playlist: List[int]) -> int:\n        if sum(songs[i][0] for i in playlist) == T and is_valid(playlist):\n            return 1\n        if index == n:\n            return 0\n        if len(playlist) == 0 or songs[index][0] + sum(songs[i][0] for i in playlist) <= T:\n            playlist.append(index)\n            return count_sequences(T, index + 1, playlist) + count_sequences(T, index + 1, [])\n        else:\n            return count_sequences(T, index + 1, playlist)\n\n    n, T = map(int, stdin.readline().split())\n    songs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    return str(count_sequences(T, 0, []) % (10**9 + 7))",
        "test": "",
        "num_ids": 314,
        "indeed": false
    },
    {
        "number": 79,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.strip())\n    P = 1\n    Q = 1\n    for i in range(2, m + 1):\n        P *= i\n        Q *= (i - 1)\n    return str(P * pow(Q, -1, 10**9 + 7))\n\ndef",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 80,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y = map(int, stdin.split())\n    count = 0\n\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if a * b == x * y and a % x == 0 and b % x == 0 and a % y == 0 and b % y == 0:\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 81,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    lcm = lambda x, y: (x * y) // gcd(x, y)\n    gcd = lambda x, y: x if y == 0 else gcd(y, x % y)\n\n    k = 0\n    min_lcm = lcm(a + k, b + k)\n\n    for i in range(1, a + b + 1):\n        lcm_value = lcm(a + i, b + i)\n        if lcm_value < min_lcm:\n            min_lcm = lcm_value\n            k = i\n\n    return str(k)",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 82,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    marks = list(map(int, stdin.split()[2:]))\n    current_average = sum(marks) / len(marks)\n    required_average = k\n\n    if current_average >= required_average:\n        return 0\n\n    marks_to_add = (required_average * len(marks)) - sum(marks)\n    return marks_to_add",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 83,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_positive(d):\n        return sum(1 for x in arr if x / d > 0)\n\n    low, high = 1, 2000\n    while low < high:\n        mid = (low + high) // 2\n        if count_positive(mid) >= n // 2:\n            high = mid\n        else:\n            low = mid + 1\n\n    if count_positive(low) >= n // 2:\n        return str(low)\n    else:\n        return \"0\"",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 84,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n // 2 + 1):\n        j = n - i\n        if str(i + j).endswith(\"9\" * len(str(i + j).split(\"9\")[0])):\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 85,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, b_1, a_2, b_2 = map(int, stdin.split())\n\n    def can_divide(a, b):\n        return a % 2 == 0 or b % 3 == 0\n\n    def divide(a, b):\n        if a % 2 == 0:\n            return a // 2, b\n        else:\n            return a, b // 3\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    if a_1 * b_1 != a_2 * b_2:\n        return \"-1\"\n\n    minutes = 0\n    while not (can_divide(a_1, b_1) and can_divide(a_2, b_2)):\n        a_1, b_1 = divide(a_1, b_1)\n        a_2, b_2 = divide(a_2, b_2)\n        minutes += 1\n\n    return f\"{minutes}\\n{a_1} {b_1}\\n{a_2} {b_2}\"",
        "test": "",
        "num_ids": 301,
        "indeed": false
    },
    {
        "number": 86,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_p, y_p, x_v, y_v = map(int, stdin.split())\n\n    if x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    if x_v == 0 and y_v == 0:\n        return \"Vasiliy\"\n\n    if x_p < x_v:\n        return \"Polycarp\"\n    elif x_p > x_v:\n        return \"Vasiliy\"\n    else:\n        if y_p < y_v:\n            return \"Polycarp\"\n        else:\n            return \"Vasiliy\"",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 87,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if m == 2:\n        days_in_month[1] = 29\n    return (days_in_month[m-1] + d - 1) // 7 + 1",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 88,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    for i in range(a, b + 1):\n        binary = bin(i)[2:]\n        if binary.count('0') == 1:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 89,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return str((N * (N + 1)) // 2)",
        "test": "",
        "num_ids": 27,
        "indeed": false
    },
    {
        "number": 90,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, S = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(k + 1):\n            dp[i + 1][j] = dp[i][j]\n            if j > 0:\n                dp[i + 1][j] += dp[i][j - 1]\n\n    def count_ways(i: int, target: int) -> int:\n        if target == 0:\n            return 1\n        if i == n:\n            return 0\n        if target < a[i]:\n            return 0\n        return count_ways(i + 1, target) + count_ways(i + 1, target - a[i]) * dp[i][1]\n\n    return str(count_ways(0, S))",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 91,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_equal(a: List[int], v: List[int]) -> bool:\n        for i in range(len(a)):\n            if a[i] != v[i]:\n                return False\n        return True\n\n    def find_diff(a: List[int], v: List[int]) -> int:\n        for i in range(len(a)):\n            if a[i] != v[i]:\n                return i\n        return -1\n\n    def find_k(a: List[int], v: List[int], k: int) -> bool:\n        diff_pos = find_diff(a, v)\n        if diff_pos == -1:\n            return True\n        required = a[diff_pos] - v[diff_pos]\n        if required % k != 0:\n            return False\n        return True\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        n, k = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        v = [0] * n\n\n        if check_equal(a, v):\n            result.append(\"YES\")\n            continue\n\n        for i in range(n):\n            if find_k(a, v, k):\n                result.append(\"YES\")\n                break\n            v[i] += k ** i\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 367,
        "indeed": false
    },
    {
        "number": 92,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    mod = 1073741824\n    d = [0] * (a * b * c + 1)\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                d[i * j * k] += 1\n    for i in range(2, a * b * c + 1):\n        for j in range(i, a * b * c + 1, i):\n            d[j] += d[i]\n            d[j] %= mod\n    return str(sum(d[1:]) % mod)",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 93,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_config(puzzle1, puzzle2):\n        for i in range(2):\n            for j in range(2):\n                if puzzle1[i][j] != puzzle2[i][j]:\n                    return False\n        return True\n\n    def move(puzzle, row, col, new_row, new_col):\n        puzzle[row][col], puzzle[new_row][new_col] = puzzle[new_row][new_col], puzzle[row][col]\n\n    def find_empty_cell(puzzle):\n        for i in range(2):\n            for j in range(2):\n                if puzzle[i][j] == 'X':\n                    return i, j\n\n    def generate_moves(puzzle):\n        row, col = find_empty_cell(puzzle)\n        moves = []\n        if row > 0:\n            moves.append((row - 1, col, row, col))\n        if row < 1:\n            moves.append((row + 1, col, row, col))\n        if col > 0:\n            moves.append((row, col - 1, row, col))\n        if col < 1:\n            moves.append((row, col + 1, row, col))\n        return moves\n\n    def search(puzzle1, puzzle2):\n        if is_same_config(puzzle1, puzzle2):\n            return True\n        for move in generate_moves(puzzle1):\n            move_puzzle1(puzzle1, *move)\n            if search(puzzle1, puzzle2):\n                return True\n            move_puzzle1(puzzle1, *move[::-1])\n        return False\n\n    puzzle1 = [list(stdin.readline().strip()) for _ in range(2)]\n    puzzle2 = [list(stdin.readline().strip()) for _ in range(2)]\n\n    if search(puzzle1, puzzle2):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 510,
        "indeed": false
    },
    {
        "number": 94,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = 0\n    for i in range(1, n):\n        if k % i == 0:\n            if n % i == 0:\n                result = max(result, k // i)\n    return str(result)",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 95,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    increasing = decreasing = True\n    for i in range(1, n - 1):\n        if arr[i] < arr[i - 1]:\n            increasing = False\n        if arr[i] > arr[i + 1]:\n            decreasing = False\n\n    if increasing or decreasing:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 96,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    paths = [[] for _ in range(n + 1)]\n\n    def f(x):\n        return x // 2 if x % 2 == 0 else x - 1\n\n    def build_paths(x):\n        while x != 1:\n            x = f(x)\n            paths[x].append(x)\n\n    for i in range(2, n + 1):\n        build_paths(i)\n\n    max_y = 0\n    for i in range(1, n + 1):\n        paths[i] = set(paths[i])\n        for y in paths[i]:\n            if len(paths[i].intersection(paths[y])) >= k:\n                max_y = max(max_y, y)\n\n    return str(max_y)",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 97,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, v_x, v_y = map(int, stdin.split())\n\n    if v_x == 0:\n        if y == 0 or y == m:\n            return \"-1\"\n        elif v_y == 1:\n            return \"0 0\"\n        else:\n            return \"0 \" + str(m)\n    elif v_y == 0:\n        if x == 0 or x == n:\n            return \"-1\"\n        elif v_x == 1:\n            return \"0 0\"\n        else:\n            return str(n) + \" 0\"\n    else:\n        return \"-1\"\n\n    # Read the input\n    n, m, x, y, v_x, v_y = map(int, input().split())\n\n    # Check if the ball will fall into a pocket\n    if v_x == 0:\n        if y == 0 or y == m:\n            print(\"-1\")\n        elif v_y == 1:\n            print(\"0 0\")\n        else:\n            print(\"0 \" + str(m))\n    elif v_y == 0:\n        if x == 0 or x == n:\n            print(\"-1\")\n        elif v_x == 1:\n            print(\"0 0\")\n        else:\n            print(str(n) + \" 0\")\n    else:\n        print(\"-1\") ",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 98,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, b1 = map(int, stdin.split()[:2])\n    a2, b2 = map(int, stdin.split()[2:4])\n    a3, b3 = map(int, stdin.split()[4:])\n\n    if a1 >= a2 + a3 and b1 >= b2 and b1 >= b3:\n        return \"YES\"\n    elif a1 >= a2 and a1 >= b3 and b1 >= b2 + b3:\n        return \"YES\"\n    elif a1 >= b2 + b3 and a1 >= a2 and b1 >= b2 and b1 >= b3:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 99,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    b_1, q, l, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    if b_1 == 0 and q == 0:\n        return \"inf\"\n\n    if b_1 > 0:\n        sign = 1\n    else:\n        sign = -1\n\n    count = 0\n    current = b_1\n\n    while abs(current) <= l:\n        if current not in a:\n            count += 1\n        current *= q\n        current *= sign\n\n    if count == 0:\n        return \"0\"\n    else:\n        return str(count)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 100,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    monitor = [list(stdin.readline().strip()) for _ in range(n)]\n    white_pixels = [(i, j) for i in range(n) for j in range(m) if monitor[i][j] == \"w\"]\n\n    def is_valid(x1, y1, d):\n        for i in range(x1, x1 + d):\n            for j in range(y1, y1 + d):\n                if not (0 <= i < n and 0 <= j < m and monitor[i][j] == \".\"):\n                    return False\n        return True\n\n    def paint_frame(x1, y1, d):\n        for i in range(x1, x1 + d):\n            for j in range(y1, y1 + d):\n                if (i == x1 or i == x1 + d - 1 or j == y1 or j == y1 + d - 1) and monitor[i][j] == \".\":\n                    monitor[i][j] = \"+\"\n\n    min_size = float(\"inf\")\n    for i in range(n):\n        for j in range(m):\n            for d in range(1, min(n - i + 1, m - j + 1) + 1):\n                if all((x, y) in white_pixels for x in range(i, i + d) for y in range(j, j + d) if (x, y) not in white_pixels):\n                    if is_valid(i, j, d):\n                        paint_frame(i, j, d)\n                        min_size = min(min_size, d)\n\n    if min_size == float(\"inf\"):\n        return \"-1\"\n\n    return \"\\n\".join(\"\".join(row) for row in monitor)",
        "test": "",
        "num_ids": 453,
        "indeed": false
    },
    {
        "number": 101,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n\n    if n % gcd(a, b) != 0:\n        return \"NO\"\n\n    x = n // a\n    y = n // b\n\n    return f\"YES\\n{x} {y}\"\n\ndef",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 102,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    s = int(stdin)\n    if s == 0:\n        return \"zero\"\n    elif s < 10:\n        return ones[s]\n    elif s < 20:\n        return teens[s - 10]\n    elif s < 100:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n    elif s == 100:\n        return \"one-hundred\"\n\n    return \"Invalid input\"",
        "test": "",
        "num_ids": 276,
        "indeed": true
    },
    {
        "number": 103,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_erased = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if all(x in a for x in range(a[i - 1] + 1, a[j - 1])):\n                max_erased = max(max_erased, j - i)\n\n    return str(max_erased)",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 104,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    total_problems = sum(a)\n    solved_problems = 0\n    for i in range(n):\n        solved_problems += a[i]\n        if solved_problems >= total_problems / 2:\n            return str(i + 1)\n    return \"0\"",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 105,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(board_size, cur_pos, new_pos):\n        if new_pos[0] < 1 or new_pos[0] > board_size or new_pos[1] < 1 or new_pos[1] > board_size:\n            return False\n        if cur_pos == new_pos:\n            return False\n        return True\n\n    def knight_moves(board_size, cur_pos):\n        moves = []\n        for i in [-2, 2]:\n            for j in [-1, 1]:\n                new_pos = (cur_pos[0] + i, cur_pos[1] + j)\n                if is_valid_move(board_size, cur_pos, new_pos):\n                    moves.append(new_pos)\n        return moves\n\n    def bishop_moves(board_size, cur_pos):\n        moves = []\n        for i in range(1, board_size):\n            new_pos = (cur_pos[0] + i, cur_pos[1] + i)\n            if is_valid_move(board_size, cur_pos, new_pos):\n                moves.append(new_pos)\n            new_pos = (cur_pos[0] + i, cur_pos[1] - i)\n            if is_valid_move(board_size, cur_pos, new_pos):\n                moves.append(new_pos)\n        return moves\n\n    def rook_moves(board_size, cur_pos):\n        moves = []\n        for i in range(1, board_size):\n            new_pos = (cur_pos[0] + i, cur_pos[1])\n            if is_valid_move(board_size, cur_pos, new_pos):\n                moves.append(new_pos)\n            new_pos = (cur_pos[0], cur_pos[1] + i)\n            if is_valid_move(board_size, cur_pos, new_pos):\n                moves.append(new_pos)\n        return moves\n\n    def find_path(board_size, board, start_pos, end_pos, cur_piece, cur_steps, min_steps, min_replacements):\n        if cur_steps >= min_steps or (cur_steps == min_steps - 1 and cur_steps + 1 < min_replacements):\n            return None\n\n        if start_pos == end_pos:\n            if cur_steps + 1 < min_steps:\n                min_steps = cur_steps + 1\n                min_replacements = cur_steps\n            return (min_steps, min_replacements)\n\n        if cur_piece == \"knight\":\n            moves = knight_moves(board_size, start_pos)\n        elif cur_piece == \"bishop\":\n            moves = bishop_moves(board_size, start_pos)\n        else:\n            moves = rook_moves(board_size, start_pos)\n\n        min_steps = float(\"inf\")\n        min_replacements = float(\"inf\")\n        for move in moves:\n            if board[move[0] - 1][move[1] - 1] == cur_steps + 1:\n                continue\n            board[move[0] - 1][move[1] - 1] = cur_steps + 1\n            if cur_piece == \"knight\":\n                result = find_path(board_size, board, move, end_pos, \"bishop\", cur_steps + 1, min_steps, min_replacements)\n                if result:\n                    min_steps, min_replacements = result\n            elif cur_piece == \"bishop\":\n                result = find_path(board_size, board, move, end_pos, \"rook\", cur_steps + 1, min_steps, min_replacements)\n                if result:\n                    min_steps, min_replacements = result\n            else:\n                result = find_path(board_size, board, move, end_pos, \"knight\", cur_steps + 1, min_steps, min_replacements)\n                if result:\n                    min_steps, min_replacements = result\n            board[move[0] - 1][",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 107,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if s.count('1') % 6 != 0:\n        return 'no'\n    return 'yes'",
        "test": "",
        "num_ids": 38,
        "indeed": false
    },
    {
        "number": 108,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    alphabet_dict = {alphabet[i]: i for i in range(len(alphabet))}\n    s_dict = {s[i]: i for i in range(len(s))}\n\n    for letter in alphabet:\n        if letter not in s_dict:\n            continue\n        index = s_dict[letter]\n        if index == len(s) - 1:\n            continue\n        next_letter = s[index + 1]\n        if alphabet_dict[next_letter] < alphabet_dict[letter]:\n            s = s[:index + 1] + letter + s[index + 2:]\n\n    if \"abcdefghijklmnopqrstuvwxyz\" in s:\n        return s\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 109,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, k = map(int, stdin.split())\n\n    if k > n * m:\n        return \"0.0000000000\"\n\n    max_caught_fishes = 0\n    for x in range(n - r + 1):\n        for y in range(m - r + 1):\n            caught_fishes = 0\n            for i in range(x, x + r):\n                for j in range(y, y + r):\n                    caught_fishes += 1\n            max_caught_fishes = max(max_caught_fishes, caught_fishes)\n\n    return f\"{max_caught_fishes / ((n - r + 1) * (m - r + 1)):.10f}\"",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 110,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        a[i] = -a[i] - 1\n\n    return ' '.join(map(str, a))",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 111,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    divisors = []\n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n\n    if len(divisors) < k:\n        return \"-1\"\n    else:\n        return str(divisors[k - 1])",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 112,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    cubes = []\n    for _ in range(n):\n        cube = [int(x) for x in stdin.readline().split()]\n        cubes.append(cube)\n\n    def rotate_cube(cube: List[int]) -> List[int]:\n        return [cube[3], cube[0], cube[1], cube[2], cube[5], cube[4]]\n\n    def build_number(cubes: List[List[int]]) -> str:\n        number = \"\"\n        for cube in cubes:\n            if cube[0] == 0:\n                return \"0\" + number\n            if cube[0] != 9:\n                number += str(cube[0])\n            else:\n                number += \"6\"\n        return number\n\n    max_x = 0\n    for permutation in itertools.permutations(cubes):\n        for i in range(1, len(permutation) + 1):\n            for rotation in itertools.permutations(permutation[:i]):\n                number = build_number(rotation)\n                if number.startswith(\"0\"):\n                    continue\n                x = int(number)\n                if x > max_x:\n                    max_x = x\n\n    return str(max_x)",
        "test": "",
        "num_ids": 324,
        "indeed": false
    },
    {
        "number": 113,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = n\n    while not str(result).endswith('0' * k) or result % n != 0:\n        result += n\n    return str(result)",
        "test": "",
        "num_ids": 57,
        "indeed": false
    },
    {
        "number": 114,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_equal(A, B):\n        for i in range(n):\n            for j in range(m):\n                if A[i][j] != B[i][j]:\n                    return False\n        return True\n\n    def make_operation(B, x, y):\n        B[x][y] = 1\n        B[x][y + 1] = 1\n        B[x + 1][y] = 1\n        B[x + 1][y + 1] = 1\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    A = [[int(x) for x in line.split()] for line in lines[1:n+1]]\n    B = [[0] * m for _ in range(n)]\n\n    if is_equal(A, B):\n        return \"0\\n\"\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            make_operation(B, i, j)\n            if is_equal(A, B):\n                operations = [(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)]\n                return f\"{len(operations)}\\n\" + \"\\n\".join(\" \".join(map(str, op)) for op in operations)\n            B = [[0] * m for _ in range(n)]\n\n    return \"-1\\n\"",
        "test": "",
        "num_ids": 371,
        "indeed": false
    },
    {
        "number": 115,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, s, p = map(int, stdin.split())\n    total = r + s + p\n    rock_survive = 0\n    scissor_survive = 0\n    paper_survive = 0\n\n    for i in range(total):\n        if i < r:\n            rock_survive += 1\n        elif i < r + s:\n            scissor_survive += 1\n        else:\n            paper_survive += 1\n\n    rock_probability = rock_survive / total\n    scissor_probability = scissor_survive / total\n    paper_probability = paper_survive / total\n\n    return f\"{rock_probability} {scissor_probability} {paper_probability}\"",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 116,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_1, r_1, l_2, r_2, k = map(int, stdin.split())\n\n    # Case 1: Sonya and Filya meet before Sonya prinks\n    if l_2 <= k <= r_1:\n        if l_1 <= l_2:\n            return str(min(r_1, r_2) - max(l_1, l_2) + 1)\n        else:\n            return str(min(r_1, r_2) - k + 1)\n    # Case 2: Sonya and Filya meet after Sonya prinks\n    elif l_2 <= r_1 < k <= r_2:\n        return str(r_1 - l_2 + 1)\n    else:\n        return \"0\"",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 117,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_point_in_segment(x, y, A, B, C, D):\n        return (A <= x <= B) and (C <= y <= D)\n\n    def is_point_in_polygon(x, y, polygon):\n        n = len(polygon)\n        inside = False\n        for i in range(n):\n            A, B, C = polygon[i]\n            D, E, F = polygon[(i + 1) % n]\n            if is_point_in_segment(x, y, A, B, C, E):\n                inside = not inside\n        return inside\n\n    def area_of_polygon(polygon):\n        n = len(polygon)\n        area = 0\n        for i in range(n):\n            A, B, C = polygon[i]\n            D, E, F = polygon[(i + 1) % n]\n            area += (B - A) * (F + C)\n        return abs(area) // 2\n\n    N, M = map(int, stdin.readline().split())\n    north_south_lines = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n    east_west_lines = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    polygon = []\n    for A, B, C in north_south_lines:\n        polygon.append((A, B, C))\n        polygon.append((A, B, C + 1))\n    for D, E, F in east_west_lines:\n        polygon.append((D, E, F))\n        polygon.append((D, E + 1, F))\n\n    if is_point_in_polygon(0, 0, polygon):\n        return \"INF\"\n    else:\n        return str(area_of_polygon(polygon))",
        "test": "",
        "num_ids": 456,
        "indeed": false
    },
    {
        "number": 118,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s, x = map(int, stdin.split())\n    if (x - t) % s == 0 or (x - t) % s == 1:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 119,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n                return f\"{i + 1} {j + 1}\"\n    return \"-1 -1\"",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 120,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if s.count('?') % 4 != 0:\n        return \"===\"\n\n    a_count = s.count('A')\n    c_count = s.count('C')\n    g_count = s.count('G')\n    t_count = s.count('T')\n\n    unrecognized_count = s.count('?')\n\n    a_diff = (a_count - c_count + g_count - t_count) / 2\n    c_diff = (c_count - g_count + t_count - a_count) / 2\n    g_diff = (g_count - t_count + a_count - c_count) / 2\n    t_diff = (t_count - a_count + c_count - g_count) / 2\n\n    a_diff = int(a_diff)\n    c_diff = int(c_diff)\n    g_diff = int(g_diff)\n    t_diff = int(t_diff)\n\n    if a_diff < 0:\n        a_diff, c_diff, g_diff, t_diff = t_diff, g_diff, c_diff, a_diff\n    elif c_diff < 0:\n        c_diff, g_diff, t_diff = t_diff, g_diff, c_diff\n    elif g_diff < 0:\n        g_diff, t_diff = t_diff, g_diff\n    elif t_diff < 0:\n        t_diff = 0\n\n    decoded_s = \"\"\n    for nucleotide in s:\n        if nucleotide == '?':\n            if a_diff > 0:\n                decoded_s += 'A'\n                a_diff -= 1\n            elif c_diff > 0:\n                decoded_s += 'C'\n                c_diff -= 1\n            elif g_diff > 0:\n                decoded_s += 'G'\n                g_diff -= 1\n            else:\n                decoded_s += 'T'\n                t_diff -= 1\n        else:\n            decoded_s += nucleotide\n\n    return decoded_s if unrecognized_count % 4 == 0 else \"===\"",
        "test": "",
        "num_ids": 564,
        "indeed": false
    },
    {
        "number": 121,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    rows = len(board)\n    cols = len(board[0])\n\n    def check_win(x, y, dx, dy):\n        for i in range(4):\n            if board[x][y] != '.':\n                if board[x][y] == board[x + dx][y + dy] == board[x + 2 * dx][y + 2 * dy] == 'x':\n                    return True\n                break\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == '.':\n                for dx, dy in [(-1, 0), (0, -1), (1, 1), (1, -1)]:\n                    if check_win(i, j, dx, dy):\n                        return 'YES'\n    return 'NO'",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 122,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    total_sum = sum(a)\n    prefix_sum = 0\n\n    for i in range(n):\n        if prefix_sum == total_sum - prefix_sum:\n            return \"YES\"\n        prefix_sum += a[i]\n\n    return \"NO\"",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 123,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            for j in range(k):\n                if b[j] not in a:\n                    a[i] = b[j]\n                    k -= 1\n                    break\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            return \"Yes\"\n\n    return \"No\"\n",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 124,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, a, b, c = map(int, stdin.split())\n\n    if x > a or y > a + b or z > a + b + c:\n        return \"NO\"\n    else:\n        return \"YES\"",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 125,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    parts = []\n    for _ in range(4):\n        l, s, r, p = map(int, stdin.readline().split())\n        parts.append((l, s, r, p))\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if parts[i][3] == 1 and parts[j][3] == 1:\n                for k in range(4):\n                    if parts[i][k] == 1 and parts[j][k] == 1:\n                        return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 126,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    number = stdin.readline().strip()\n    finger_movements = []\n    for i in range(n):\n        row, col = int(number[i]) // 3, int(number[i]) % 3\n        if i == 0:\n            finger_movements.append((row, col))\n        else:\n            prev_row, prev_col = int(number[i - 1]) // 3, int(number[i - 1]) % 3\n            finger_movements.append((row - prev_row, col - prev_col))\n\n    count = 0\n    for i in range(10):\n        row, col = i // 3, i % 3\n        if (row, col) in finger_movements:\n            count += 1\n\n    if count == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 127,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f = map(int, stdin.split())\n    products = []\n    clients = []\n    for _ in range(n):\n        k, l = map(int, input().split())\n        products.append(k)\n        clients.append(l)\n\n    total_products = sum(products)\n    max_sold_products = 0\n\n    for i in range(n):\n        max_sold_products += products[i]\n\n    for i in range(n):\n        if i not in range(n - f, n):\n            total_products -= products[i]\n\n    max_sold_products = max(max_sold_products, total_products)\n\n    return str(max_sold_products)",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 128,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    max_messiness = (n * (n - 1)) // 2\n    if k >= n - 1:\n        return str(max_messiness)\n    return str(max_messiness - (n - k - 1)) ",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 129,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, L = map(int, stdin.split())\n\n    if N < L:\n        return \"-1\"\n\n    coins_to_buy = L - K\n    if coins_to_buy < 0:\n        coins_to_buy = 0\n\n    return str(coins_to_buy)",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 130,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_square(x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if field[i][j] != 'B':\n                    return False\n        return True\n\n    def find_square(x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return float('inf')\n        if is_square(x1, y1, x2, y2):\n            return 0\n        min_cost = float('inf')\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if field[i][j] == 'W':\n                    field[i][j] = 'B'\n                    min_cost = min(min_cost, 1 + find_square(x1, y1, x2, y2))\n                    field[i][j] = 'W'\n        return min_cost\n\n    min_cost = find_square(0, 0, n - 1, m - 1)\n    return str(min_cost) if min_cost != float('inf') else '-1'",
        "test": "",
        "num_ids": 348,
        "indeed": false
    },
    {
        "number": 131,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        if x[i] == y[i]:\n            continue\n        elif x[i] > y[i]:\n            if i == 0:\n                if x[i] - y[i] == 1 and x[i + 1] == y[i + 1]:\n                    x[i] = y[i]\n                else:\n                    return \"No\"\n            elif i == n - 1:\n                if x[i] - y[i] == 1 and x[i - 1] == y[i - 1]:\n                    x[i] = y[i]\n                else:\n                    return \"No\"\n            else:\n                if x[i] - y[i] == 1 and x[i - 1] == y[i - 1] and x[i + 1] == y[i + 1]:\n                    x[i] = y[i]\n                else:\n                    return \"No\"\n        else:\n            if i == 0:\n                if y[i] - x[i] == 1 and y[i + 1] == x[i + 1]:\n                    y[i] = x[i]\n                else:\n                    return \"No\"\n            elif i == n - 1:\n                if y[i] - x[i] == 1 and y[i - 1] == x[i - 1]:\n                    y[i] = x[i]\n                else:\n                    return \"No\"\n            else:\n                if y[i] - x[i] == 1 and y[i - 1] == x[i - 1] and y[i + 1] == x[i + 1]:\n                    y[i] = x[i]\n                else:\n                    return \"No\"\n\n    if x == y:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 520,
        "indeed": false
    },
    {
        "number": 132,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort()\n    if n == 1:\n        return str(a[0])\n    else:\n        return str(min(abs(sum(a[:n-1]) - sum(a[n-1:])), abs(sum(a[:n-1]) - sum(a[n-1:]) + 360)))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 133,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def factorial(x):\n        res = 1\n        for i in range(1, x + 1):\n            res = (res * i) % mod\n        return res\n\n    def power(x, y):\n        res = 1\n        while y > 0:\n            if y & 1:\n                res = (res * x) % mod\n            x = (x * x) % mod\n            y >>= 1\n        return res\n\n    return str((factorial(n - 1) * power(m, n - 1)) % mod)",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 134,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    for i in range(2, n):\n        for j in range(i + 1, n):\n            if i + j + (i**2 + j**2)**0.5 == n:\n                return f\"{i} {j}\"\n    return \"-1\"",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 135,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    remainders = set()\n\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n\n    return \"Yes\"\n",
        "test": "",
        "num_ids": 78,
        "indeed": true
    },
    {
        "number": 136,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    a, b = int(a), int(b)\n\n    if a < b:\n        return '<'\n    elif a > b:\n        return '>'\n    else:\n        return '='",
        "test": "",
        "num_ids": 62,
        "indeed": true
    },
    {
        "number": 137,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_paths(n, c, p):\n        MOD = 10**9 + 7\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][c[0]] = 1\n\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][1]\n            dp[i][1] = dp[i - 1][0] + dp[i - 1][1]\n\n            if c[i] != -1:\n                dp[i][c[i]] = (dp[i][c[i]] + dp[i - 1][(c[i] + 1) % 2]) % MOD\n\n        return dp[n - 1][p]\n\n    n, p = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n\n    return str(count_paths(n, c, p))",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 138,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    k = 4 - (n % 4)\n    if k == 4:\n        k = 0\n    return str(min(k * a, (k - 1) * a + b, (k - 2) * a + 2 * b, (k - 3) * a + 3 * c))",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 139,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u - 1].append(v - 1)\n\n    def dfs(v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for u in graph[v]:\n            if not visited[u]:\n                if dfs(u, visited, rec_stack):\n                    return True\n            elif rec_stack[u]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    for i in range(n):\n        visited = [False] * n\n        rec_stack = [False] * n\n        if dfs(i, visited, rec_stack):\n            return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 140,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def find_antenna(x):\n        index = binary_search(antenna_positions, x)\n        if index != -1:\n            return index\n        else:\n            index = binary_search(antenna_positions, x - 1)\n            if index != -1:\n                return index\n            else:\n                index = binary_search(antenna_positions, x + 1)\n                return index\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    antenna_positions = [int(line.split()[0]) for line in lines[1:n + 1]]\n    antenna_scopes = [int(line.split()[1]) for line in lines[1:n + 1]]\n\n    antenna_positions.sort()\n\n    coins = 0\n    for i in range(1, m + 1):\n        index = find_antenna(i)\n        if antenna_scopes[index] < i:\n            coins += i - antenna_scopes[index]\n            antenna_scopes[index] = i\n\n    return str(coins)",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 141,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, *cnts = list(map(int, stdin.split()))\n    dp = [0] * (W + 1)\n\n    for i in range(8):\n        for j in range(W, cnts[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - cnts[i]] + cnts[i])\n\n    return str(dp[-1])",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 142,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    bottles = []\n    for i in range(n):\n        bottles.append((2**i - 1, c[i]))\n    bottles.sort(key=lambda x: x[1])\n    total_roubles = 0\n    for i in range(n):\n        liters = bottles[i][0]\n        roubles = bottles[i][1]\n        if L <= liters:\n            total_roubles += roubles\n            break\n        else:\n            L -= liters\n            total_roubles += roubles\n    return str(total_roubles)",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 143,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n    mex = 1\n\n    for i in range(n):\n        if a[i] > mex:\n            break\n        mex += 1\n\n    return str(mex)",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 144,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    ticket = stdin.readline().strip()\n\n    def is_lucky(ticket: str) -> bool:\n        total_sum = sum(int(digit) for digit in ticket)\n        if total_sum % 2 != 0:\n            return False\n\n        half_sum = total_sum // 2\n        current_sum = 0\n\n        for digit in ticket:\n            current_sum += int(digit)\n            if current_sum == half_sum:\n                return True\n\n        return False\n\n    return \"YES\" if is_lucky(ticket) else \"NO\"\n",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 145,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    distinct_chars = set(stdin)\n    if len(distinct_chars) % 2 == 0:\n        return \"IGNORE HIM!\"\n    else:\n        return \"CHAT WITH HER!\"",
        "test": "",
        "num_ids": 55,
        "indeed": false
    },
    {
        "number": 146,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    tabs = list(map(int, stdin.readline().split()))\n\n    for i in range(1, n):\n        if i % k == 0:\n            continue\n        tabs[i] = 0\n\n    e = sum(1 for tab in tabs if tab == 1)\n    s = sum(1 for tab in tabs if tab == -1)\n\n    return str(abs(e - s))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 147,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_0, c_1 = map(int, stdin.split())\n    total_cost = 0\n    for i in range(n):\n        binary_str = bin(i)[2:]\n        total_cost += len(binary_str) * c_0 + (len(binary_str) - len(binary_str.rstrip('0'))) * c_1\n    return total_cost",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 148,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, x, b, y = map(int, stdin.split())\n\n    if a == b or a == y or x == b or x == y:\n        return \"YES\"\n\n    if a > b:\n        a, b = b, a\n        x, y = y, x\n\n    for i in range(a, x + 1):\n        if i == b:\n            return \"YES\"\n\n    for i in range(b, y + 1):\n        if i == a:\n            return \"YES\"\n\n    return \"NO\"\n",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 149,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, l, r = map(int, stdin.split())\n    max_length = 0\n\n    for a in range(1, 1000):\n        for b in range(1, 1000):\n            n = x ** a + y ** b\n            if l <= n <= r:\n                start = l\n                while start <= r:\n                    if start <= n <= r:\n                        end = r\n                        while end >= start:\n                            if start <= n <= end:\n                                max_length = max(max_length, end - start + 1)\n                            end -= 1\n                    start += 1\n            elif n > r:\n                break\n\n    return str(max_length)\n",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 150,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 2:\n        return 1\n    d = 2\n    while n % d == 0:\n        d += 1\n    return str(d)",
        "test": "",
        "num_ids": 54,
        "indeed": false
    },
    {
        "number": 151,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    consonants = set(\"bcdfghjklmnpqrstvwxyz\")\n\n    def has_typo(word: str) -> bool:\n        for i in range(len(word) - 2):\n            if word[i] in consonants and word[i + 1] in consonants and word[i + 2] in consonants:\n                if len(set(word[i:i + 3])) > 1:\n                    return True\n        return False\n\n    def fix_typo(word: str) -> str:\n        result = []\n        i = 0\n        while i < len(word):\n            if i + 2 < len(word) and word[i] in consonants and word[i + 1] in consonants and word[i + 2] in consonants:\n                if len(set(word[i:i + 3])) > 1:\n                    result.append(word[i])\n                    i += 1\n                    while i < len(word) and word[i] in consonants:\n                        result.append(word[i])\n                        i += 1\n                    result.append(\" \")\n                else:\n                    result.append(word[i])\n                    i += 1\n            else:\n                result.append(word[i])\n                i += 1\n        return \"\".join(result)\n\n    if not has_typo(stdin):\n        return stdin\n    else:\n        return fix_typo(stdin)",
        "test": "",
        "num_ids": 390,
        "indeed": false
    },
    {
        "number": 152,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    x, s = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n    c.sort()\n    d.sort()\n\n    min_time = float('inf')\n\n    for i in range(min(m, s // min(b))):\n        time = a[i] * n\n        min_time = min(min_time, time)\n\n    for i in range(min(k, s // min(d))):\n        time = (n - c[i]) * x + c[i] * d[i]\n        min_time = min(min_time, time)\n\n    return str(min_time)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 153,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    t = list(map(int, input().split()))\n\n    t.sort()\n\n    points = 0\n    for i in range(k):\n        if m >= t[i]:\n            points += i + 1\n            m -= t[i]\n        else:\n            break\n\n    return str(points + n)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 154,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 998244353\n\n    def is_perfectly_balanced(root):\n        if root is None:\n            return True, 0\n\n        left_balanced, left_depth = is_perfectly_balanced(root.left)\n        right_balanced, right_depth = is_perfectly_balanced(root.right)\n\n        if not left_balanced or not right_balanced:\n            return False, 0\n\n        depth = max(left_depth, right_depth) + 1\n        return abs(left_depth - right_depth) <= 1, depth\n\n    def is_striped(root):\n        if root is None:\n            return True\n\n        if (root.key % 2 == 0) != (root.left.key % 2 == 0):\n            if not is_striped(root.left):\n                return False\n        else:\n            if is_striped(root.left):\n                return False\n\n        if (root.key % 2 == 0) != (root.right.key % 2 == 0):\n            if not is_striped(root.right):\n                return False\n        else:\n            if is_striped(root.right):\n                return False\n\n        return True\n\n    class Node:\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n\n    def generate_trees(n):\n        if n == 0:\n            return []\n        if n == 1:\n            return [Node(1)]\n\n        trees = []\n        for i in range(1, n + 1):\n            left_trees = generate_trees(i - 1)\n            right_trees = generate_trees(n - i)\n            for left in left_trees:\n                for right in right_trees:\n                    root = Node(i)\n                    root.left = left\n                    root.right = right\n                    if is_striped(root) and is_perfectly_balanced(root)[0]:\n                        trees.append(root)\n\n        return trees\n\n    trees = generate_trees(n)\n    return str(len(trees)) + \"\\n\"",
        "test": "",
        "num_ids": 552,
        "indeed": false
    },
    {
        "number": 155,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    row, col = 1, 1\n    snake_direction = 0\n    snake_moves = 0\n    snake_steps = 0\n\n    while snake_steps < k:\n        if snake_direction == 0:\n            if col == m:\n                snake_direction = 1\n                snake_moves = 1\n            else:\n                col += 1\n                snake_steps += 1\n        elif snake_direction == 1:\n            if row == n:\n                snake_direction = 2\n                snake_moves = 1\n            else:\n                row += 1\n                snake_steps += 1\n        elif snake_direction == 2:\n            if col == 1:\n                snake_direction = 3\n                snake_moves = 1\n            else:\n                col -= 1\n                snake_steps += 1\n        else:\n            if row == 1:\n                snake_direction = 0\n                snake_moves = 1\n            else:\n                row -= 1\n                snake_steps += 1\n\n        if snake_moves == n - 1:\n            snake_moves = 0\n        else:\n            snake_moves += 1\n\n    return f\"{row} {col}\"",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 156,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    a = 1\n    b = X\n\n    while a < X:\n        if X % a == 0:\n            b = X // a\n            break\n        a += 1\n\n    return f\"{a} {b}\\n\"",
        "test": "",
        "num_ids": 71,
        "indeed": false
    },
    {
        "number": 157,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    total_lemons = total_apples = total_pears = 0\n\n    while a >= 1 and b >= 2 and c >= 4:\n        total_lemons += 1\n        a -= 1\n        b -= 2\n        c -= 4\n\n    return str(total_lemons + total_apples + total_pears)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 158,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    ratings = sorted(map(int, stdin.split('\\n')[1].split()))\n\n    team1 = ratings[:n]\n    team2 = ratings[n:]\n\n    for i in range(n):\n        if team1[i] < team2[i]:\n            team1[i], team2[i] = team2[i], team1[i]\n        elif team1[i] == team2[i]:\n            break\n\n    if i == n - 1:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 159,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    k = 0\n    for i in range(n - 1):\n        if not is_coprime(a[i], a[i + 1]):\n            k += 1\n            a.insert(i + 1, a[i] + 1)\n\n    return f\"{k}\\n{' '.join(map(str, a))}\"",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 160,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *A = list(map(int, stdin.split()))\n    A.sort()\n\n    for _ in range(K):\n        for i in range(1, N):\n            if A[i] > A[0]:\n                A[i] -= A[0]\n                A[0] += 1\n            else:\n                break\n\n    gcd = A[0]\n    for i in range(1, N):\n        gcd = gcd_euclid(gcd, A[i])\n\n    return str(gcd)\n\ndef",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 161,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    t = 0\n    result = []\n\n    while x != 0 and t < 40:\n        if t % 2 == 0:\n            x += 1\n        else:\n            n = 1\n            while (1 << n) - 1 <= x:\n                n += 1\n            x ^= (1 << n) - 1\n            result.append(str(n))\n        t += 1\n\n    return str(t) + '\\n' + '\\n'.join(result)",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 162,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n    hours = 0\n    i = 0\n\n    while k > 0:\n        if a[i] <= k:\n            k -= a[i]\n            hours += 1\n        i += 1\n\n    return str(hours)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 163,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    line = stdin.readline().strip()\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n\n    if abs(g_pos - t_pos) % (k + 1) == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 164,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    y1, y2, yw, xb, yb, r = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_between(x, y1, y2):\n        return y1 <= y <= y2\n\n    def is_goal(x, y):\n        return is_between(y, y1, y2) and x <= 0\n\n    def reflect(x, y, x1, y1, x2, y2):\n        d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        u_x = (x2 - x1) / d\n        u_y = (y2 - y1) / d\n        v_x = x - x1\n        v_y = y - y1\n        scalar = (v_x * u_x + v_y * u_y) * 2\n        reflected_x = x + (u_x * scalar - v_x)\n        reflected_y = y + (u_y * scalar - v_y)\n        return reflected_x, reflected_y\n\n    def is_valid(x, y):\n        if not is_between(y, yw - 2 * r, yw):\n            return False\n        if is_goal(x, y):\n            return False\n        if distance(x, y, xb, yb) <= r:\n            return False\n        return True\n\n    def find_wall_point(x, y):\n        while not is_valid(x, y):\n            x, y = reflect(x, y, 0, yw - 2 * r, 0, yw)\n        return x, y\n\n    xw, yw = find_wall_point(xb, yb)\n    return f\"{xw:.10f}\" if is_valid(xw, yw) else \"-1\"",
        "test": "",
        "num_ids": 499,
        "indeed": false
    },
    {
        "number": 165,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d, s = map(int, stdin.split())\n    total_meals = b + d + s\n\n    if total_meals == 1:\n        return str(0)\n    elif total_meals == 2:\n        if b == 2 or d == 2 or s == 2:\n            return str(0)\n        else:\n            return str(1)\n    else:\n        return str(total_meals - 2) ",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 166,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(a, x, y):\n        for i in range(len(a) - 1):\n            if a[i] != a[i + 1] - y:\n                return False\n            if a[i] < 1 or a[i] > x * y:\n                return False\n        return True\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\\n1 1\"\n\n    x_max = y_max = 10**9\n    x_min = y_min = 1\n\n    for i in range(1, n):\n        diff = a[i] - a[i - 1]\n        if diff == 0:\n            return \"NO\"\n        if diff > 0:\n            y_min = max(y_min, diff)\n            y_max = min(y_max, diff)\n        else:\n            x_min = max(x_min, abs(diff))\n            x_max = min(x_max, abs(diff))\n\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            if is_valid_path(a, x, y):\n                return \"YES\\n{} {}\".format(x, y)\n\n    return \"NO\"",
        "test": "",
        "num_ids": 353,
        "indeed": false
    },
    {
        "number": 167,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    i, j = 0, 0\n    result = []\n\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n\n    if not result:\n        return '-'\n\n    return ''.join(result)\n",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 168,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    operations = stdin.split(\"\\n\")[1]\n\n    stones = 0\n    for op in operations:\n        if op == \"-\":\n            stones -= 1\n        else:\n            stones += 1\n\n    return str(max(0, stones))",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 169,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n\n    if a > b:\n        a, b = b, a\n        c = b - a\n\n    if n >= b:\n        return str(n // b)\n    else:\n        return str(n // a + (n % a) // c)",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 170,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    k1 = int(stdin.split('\\n')[1].split(' ')[0])\n    k2 = int(stdin.split('\\n')[2].split(' ')[0])\n    cards1 = list(map(int, stdin.split('\\n')[1].split(' ')[1:]))\n    cards2 = list(map(int, stdin.split('\\n')[2].split(' ')[1:]))\n\n    if k1 == 0 or k2 == 0:\n        return \"-1\"\n\n    fights = 0\n    while cards1 and cards2:\n        if cards1[-1] > cards2[-1]:\n            cards1.append(cards2.pop())\n            cards1.append(cards1.pop())\n        else:\n            cards2.append(cards1.pop())\n            cards2.append(cards2.pop())\n        fights += 1\n\n    if cards1:\n        return f\"{fights} 1\"\n    else:\n        return f\"{fights} 2\"",
        "test": "",
        "num_ids": 261,
        "indeed": false
    },
    {
        "number": 171,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    password = stdin\n    if len(password) < 5:\n        return \"Too weak\"\n    if not any(char.isdigit() for char in password):\n        return \"Too weak\"\n    if not any(char.islower() for char in password):\n        return \"Too weak\"\n    if not any(char.isupper() for char in password):\n        return \"Too weak\"\n    return \"Correct\"\n\npassword = input()\nprint(solution(password)) ",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 172,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    b = [int(x) for x in stdin.split('\\n')[2].split()]\n\n    count_a = [0] * 5\n    count_b = [0] * 5\n\n    for i in a:\n        count_a[i - 1] += 1\n\n    for i in b:\n        count_b[i - 1] += 1\n\n    exchanges = 0\n\n    for i in range(5):\n        exchanges += abs(count_a[i] - count_b[i])\n\n    return str(exchanges // 2) if exchanges % 2 == 0 else '-1'",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 173,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    horizontal_streets = stdin.readline().strip()\n    vertical_streets = stdin.readline().strip()\n\n    def is_valid(x: int, y: int, direction: str) -> bool:\n        if direction == '>':\n            return x < n - 1\n        elif direction == '<':\n            return x > 0\n        elif direction == '^':\n            return y < m - 1\n        elif direction == 'v':\n            return y > 0\n        return False\n\n    def dfs(x: int, y: int, visited: set) -> bool:\n        if (x, y) in visited:\n            return True\n        visited.add((x, y))\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and is_valid(nx, ny, horizontal_streets[x] if dx == 0 else vertical_streets[y]):\n                if not dfs(nx, ny, visited):\n                    return False\n        return True\n\n    if dfs(0, 0, set()):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 334,
        "indeed": false
    },
    {
        "number": 174,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_correct(expression: str) -> bool:\n        if len(expression) == 1:\n            return True\n        if '(' in expression:\n            i = expression.index('(')\n            j = i + expression[i:].index(')')\n            if is_correct(expression[:i] + expression[i + 1:j] + expression[j + 1:]):\n                return True\n        for i in range(len(expression) - 2):\n            if expression[i] == '0' and expression[i + 2] == '0':\n                if is_correct(expression[:i] + '1' + expression[i + 3:]):\n                    return True\n            elif expression[i] == '1' and expression[i + 2] == '1':\n                if is_correct(expression[:i] + '1' + expression[i + 3:]):\n                    return True\n            elif expression[i] == '0' and expression[i + 2] == '1':\n                if is_correct(expression[:i] + '0' + expression[i + 3:]):\n                    return True\n            elif expression[i] == '1' and expression[i + 2] == '0':\n                if is_correct(expression[:i] + '0' + expression[i + 3:]):\n                    return True\n        return False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                expression = '(' * (i + 1) + '0' + '->' + '1' + ')' * (i + 1)\n                expression += '(' * (j - i) + '0' + '->' + '1' + ')' * (j - i)\n                expression += '(' * (k - j) + '0' + '->' + '1' + ')' * (k - j)\n                expression += '(' * (n - k) + '0' + '->' + '1' + ')' * (n - k)\n                if is_correct(expression):\n                    return 'YES\\n' + expression\n    return 'NO'",
        "test": "",
        "num_ids": 559,
        "indeed": false
    },
    {
        "number": 175,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n\n    return f\"{a} {b}\"",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 176,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(a, b + 1):\n        if i % k == 0:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 177,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    num = 1\n    digits = 1\n    while digits < k:\n        num += 1\n        digits += len(str(num))\n    num_str = str(num)\n    return num_str[k - (digits - len(num_str))]",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 178,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if s[0] != '8':\n        return 'NO'\n\n    def is_phone_number(s: str) -> bool:\n        if len(s) != 11:\n            return False\n        for c in s:\n            if c not in '0123456789':\n                return False\n        return True\n\n    def vasya_move(s: str) -> str:\n        for i in range(len(s)):\n            if is_phone_number(s[:i] + s[i+1:]):\n                return s[:i] + s[i+1:]\n        return s\n\n    while len(s) != 11:\n        s = vasya_move(s)\n        if s == '':\n            return 'NO'\n        s = stdin.readline().strip()\n\n    if is_phone_number(s):\n        return 'YES'\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 179,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, pos = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def factorial(n):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = (fact[i - 1] * i) % mod\n        return fact\n\n    def inv(n):\n        inv = [1] * (n + 1)\n        inv[n] = pow(factorial(n)[n], mod - 2, mod)\n        for i in range(n - 1, -1, -1):\n            inv[i] = (inv[i + 1] * (i + 1)) % mod\n        return inv\n\n    def permutation(n, r):\n        return factorial(n) // (factorial(n - r) * factorial(r))\n\n    def combination(n, r):\n        return factorial(n) // (factorial(n - r) * factorial(r))\n\n    def binary_search(a, x):\n        left = 0\n        right = len(a)\n        while left < right:\n            middle = (left + right) // 2\n            if a[middle] <= x:\n                left = middle + 1\n            else:\n                right = middle\n        return left > 0 and a[left - 1] == x\n\n    def count_permutations(n, x, pos):\n        valid_permutations = 0\n        for i in range(n):\n            if i != pos:\n                a = [j for j in range(1, n + 1) if j != x]\n                a.insert(i, x)\n                if binary_search(a, x):\n                    valid_permutations += permutation(n - 1, i)\n                    valid_permutations %= mod\n        return valid_permutations\n\n    return str(count_permutations(n, x, pos))",
        "test": "",
        "num_ids": 480,
        "indeed": false
    },
    {
        "number": 180,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split('\\n')\n    k = int(k)\n\n    def generate_messages(s, k):\n        if k == 0:\n            return ['']\n        if len(s) == 0:\n            return []\n        if s[0] == '*':\n            return [s[1] + msg for msg in generate_messages(s[2:], k - 1)]\n        elif s[0] == '?':\n            if k > 1:\n                return [s[1] + msg for msg in generate_messages(s[2:], k - 1)] + [s[1] * i + msg for i in range(2, k + 1) for msg in generate_messages(s[2:], k - i)]\n            else:\n                return [s[1]]\n        else:\n            return [s[0] + msg for msg in generate_messages(s[1:], k - 1)]\n\n    messages = generate_messages(s, k)\n    if messages:\n        return messages[0]\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 263,
        "indeed": false
    },
    {
        "number": 181,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x == 0:\n        return \"0\"\n    elif x > 0:\n        turns = x // 90\n        deviation = x % 90\n        if deviation <= 45:\n            return str(turns)\n        else:\n            return str(turns + 1)\n    else:\n        turns = abs(x) // 90\n        deviation = abs(x) % 90\n        if deviation <= 45:\n            return str(turns)\n        else:\n            return str(turns + 1)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 182,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, x, y, z = map(int, stdin.split())\n    if x <= a and y <= b and z <= c:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 55,
        "indeed": false
    },
    {
        "number": 183,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    result = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i % j == 0:\n                result += 9 * (10 ** (i - 1)) // k\n\n    return str(result % m)\n",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 184,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, a = map(int, stdin.split())\n    left_handers = l + a\n    right_handers = r + a\n    if left_handers % 2 == 1 or right_handers % 2 == 1:\n        return \"0\"\n    else:\n        return str(min(left_handers, right_handers))",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 185,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return 0\n    if k == 1:\n        return 2 * (n - 1) + 1\n    if k == n:\n        return 2 * (n - 1) + 1\n    return 2 * (n - 2) + 2",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 186,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_height = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            height = i * 2 + j * 3\n            if height > max_height:\n                max_height = height\n\n    return str(max_height)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 187,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = list(map(int, stdin.split(\"\\n\")[1:]))\n\n    if len(set(cards)) == 1:\n        return \"NO\"\n\n    for i in range(1, 101):\n        if cards.count(i) == n // 2:\n            for j in range(1, 101):\n                if cards.count(j) == n // 2 and i != j:\n                    return f\"YES\\n{i} {j}\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 143,
        "indeed": true
    },
    {
        "number": 188,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    soldiers = list(map(int, stdin.split()))\n\n    if sum(soldiers) > 8 * n:\n        return \"NO\"\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if (soldiers[i] + soldiers[j]) > 8:\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 189,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    min_cost = float('inf')\n    min_t = -1\n\n    for i in range(a[0], a[-1] + 1):\n        cost = sum(abs(x - i) for x in a)\n        if cost < min_cost:\n            min_cost = cost\n            min_t = i\n\n    return f\"{min_t} {min_cost}\\n\"",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 191,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def count_inversions(a):\n        inv_count = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    inv_count += 1\n        return inv_count\n\n    def count_swaps(a, k):\n        total_swaps = 0\n        for i in range(k):\n            for j in range(i + 1, n):\n                total_swaps += 1\n        return total_swaps\n\n    total_inversions = count_inversions(a)\n    total_swaps = count_swaps(a, k)\n\n    if total_inversions % 2 == 0:\n        P = 2 ** total_swaps\n        Q = 2 ** (n * (n - 1) // 2 - total_inversions)\n    else:\n        P = 2 ** (n * (n - 1) // 2 - total_inversions)\n        Q = 2 ** total_swaps\n\n    return f\"{P * pow(Q, -1, 10**9+7)}\"",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 192,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    seconds = 0\n\n    while x != y:\n        if x > y:\n            x -= 1\n        else:\n            x += 1\n        seconds += 1\n\n    return str(seconds)",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 193,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    if a == 0 and b == 0 and c == 0 and d == 0:\n        return \"0.000000000\"\n\n    det_A = a * d - b * c\n    if det_A == 0:\n        return \"0.000000000\"\n\n    norm_A = max(abs(a), abs(b), abs(c), abs(d))\n\n    if norm_A == 0:\n        return \"0.000000000\"\n\n    min_norm = float('inf')\n\n    for x in range(-norm_A, norm_A + 1):\n        for y in range(-norm_A, norm_A + 1):\n            det_B = a * y - b * x\n            if det_B == 0:\n                continue\n            else:\n                B = [[x, y], [c, d]]\n                norm_B = max(max(map(abs, B[0])), max(map(abs, B[1])))\n                norm_diff = max(abs(norm_A - norm_B), abs(norm_A + norm_B))\n                min_norm = min(min_norm, norm_diff)\n\n    return \"{:.10f}\".format(min_norm)",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 194,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, *groups = map(int, stdin.split())\n    one_seaters = [True] * a\n    two_seaters = [True] * b\n    denied = 0\n\n    for group in groups:\n        if group == 1:\n            if any(one_seaters):\n                one_seaters[one_seaters.index(True)] = False\n            elif any(two_seaters):\n                two_seaters[two_seaters.index(True)] = False\n            else:\n                denied += 1\n        else:\n            if any(two_seaters):\n                two_seaters[two_seaters.index(True)] = False\n            else:\n                denied += 1\n\n    return str(denied)",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 195,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, N = map(int, stdin.split())\n\n    if A + B + C > N:\n        return \"-1\"\n\n    if A + B + C == N:\n        return \"0\"\n\n    if A + B + C < N:\n        return str(N - A - B - C)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 196,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def expected_dresses(x, k):\n        if k == 0:\n            return x\n        elif k == 1:\n            return 3 * x // 2\n        else:\n            return (2 * expected_dresses(x, k - 1) + expected_dresses(x, k - 2)) % mod\n\n    return str(expected_dresses(x, k))",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 197,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return g, y - (b // a) * x, x\n\n    def mod_inverse(x, mod):\n        g, inv, _ = extended_gcd(x, mod)\n        if g != 1:\n            raise Exception(\"Inverse doesn't exist\")\n        return inv % mod\n\n    n = int(stdin.readline().strip())\n    problems = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        problems.append((l, r))\n\n    total_solutions = sum(r - l for l, r in problems)\n    total_inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if problems[i][1] > problems[j][0]:\n                total_inversions += problems[i][1] - problems[j][0]\n\n    probability = (total_solutions - total_inversions) / total_solutions\n    result = int(probability * 998244353)\n    mod = 998244353\n    mod_inv = mod_inverse(result, mod)\n    return str(result * mod_inv)",
        "test": "",
        "num_ids": 354,
        "indeed": false
    },
    {
        "number": 198,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n // 4 + 1):\n        for j in range(i, n // 2 - i + 1):\n            if i * j + i + j <= n:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 199,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    if sum(v) < s:\n        return \"-1\"\n\n    v.sort()\n    total_liters = 0\n\n    for i in range(n):\n        if s == 0:\n            break\n        pour = min(s, v[i])\n        total_liters += pour\n        s -= pour\n\n    return str(total_liters)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 200,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, h_2, a, b = map(int, stdin.split())\n    height = h_1\n    days = 0\n\n    while height < h_2:\n        height += a\n        days += 1\n        if height >= h_2:\n            break\n        height -= b\n        days += 1\n\n    if height >= h_2:\n        return str(days)\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 201,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, H_r, H_b, W_r, W_b = map(int, stdin.split())\n\n    max_joy = 0\n    red_candies = 0\n    blue_candies = 0\n\n    while red_candies * W_r <= C and blue_candies * W_b <= C:\n        if H_r / W_r > H_b / W_b:\n            red_candies += 1\n        else:\n            blue_candies += 1\n\n        max_joy = max(max_joy, red_candies * H_r + blue_candies * H_b)\n\n    return str(max_joy)",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 202,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    d = dx + dy\n    if d % 2 == 0:\n        return str(d)\n    else:\n        return str(d + 1)",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 203,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, fractions = int(stdin.split('\\n')[0]), stdin.split('\\n')[1]\n    depublicans, remocrats = [], []\n\n    for i, fraction in enumerate(fractions):\n        if fraction == 'D':\n            depublicans.append(i + 1)\n        else:\n            remocrats.append(i + 1)\n\n    while len(depublicans) > 1 or len(remocrats) > 1:\n        new_depublicans, new_remocrats = [], []\n\n        for i in range(1, n + 1):\n            if i in depublicans:\n                new_depublicans.append(i)\n            elif i in remocrats:\n                new_remocrats.append(i)\n\n        for i in range(len(new_depublicans)):\n            if new_depublicans[i] not in depublicans:\n                continue\n\n            if i + 1 < len(new_depublicans) and new_depublicans[i + 1] in depublicans:\n                depublicans.remove(new_depublicans[i + 1])\n            elif i - 1 >= 0 and new_depublicans[i - 1] in depublicans:\n                depublicans.remove(new_depublicans[i - 1])\n\n        for i in range(len(new_remocrats)):\n            if new_remocrats[i] not in remocrats:\n                continue\n\n            if i + 1 < len(new_remocrats) and new_remocrats[i + 1] in remocrats:\n                remocrats.remove(new_remocrats[i + 1])\n            elif i - 1 >= 0 and new_remocrats[i - 1] in remocrats:\n                remocrats.remove(new_remocrats[i - 1])\n\n    return 'D' if len(depublicans) > 0 else 'R'",
        "test": "",
        "num_ids": 479,
        "indeed": false
    },
    {
        "number": 204,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    count = 0\n    for w in range(1, a + 1):\n        h = w * y // x\n        if h <= b:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 205,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    trailing_zeros = 0\n\n    for i in range(1, n + 1):\n        while i % b == 0:\n            trailing_zeros += 1\n            i //= b\n\n    return str(trailing_zeros)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 206,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b = map(int, stdin.split())\n    f = [1] * (m + 1)\n    for i in range(1, m + 1):\n        for j in range(1, i + 1):\n            if j > a and j > b:\n                break\n            if i - j >= 0:\n                f[i] = max(f[i], f[i - j] + 1)\n    return str(sum(f))",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 207,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(subsegment):\n        return len(subsegment) % 2 == 1 and subsegment[0] % 2 == 1 and subsegment[-1] % 2 == 1\n\n    for i in range(n):\n        for j in range(i, n, 2):\n            if is_valid(a[i:j + 1]):\n                if j + 2 <= n:\n                    if is_valid(a[j + 1:n]):\n                        return \"Yes\"\n                else:\n                    return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 208,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    if x1 == x2 or y1 == y2:\n        return \"-1\"\n\n    x3 = x1 + (x2 - x1) // 2\n    y3 = y1 + (y2 - y1) // 2\n    x4 = x2 + (x1 - x2) // 2\n    y4 = y2 + (y1 - y2) // 2\n\n    return f\"{x3} {y3} {x4} {y4}\"",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 209,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if n == 1:\n        return x % mod\n    elif n == 2:\n        return y % mod\n    else:\n        f = [x, y]\n        for i in range(2, n):\n            f.append((f[i - 1] + f[i + 1]) % mod)\n        return f[n - 1] % mod",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 210,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1 or sum(a) == 0:\n        return \"NO\"\n\n    k = 1\n    for i in range(n - 1):\n        if a[i] == 0:\n            k += 1\n        else:\n            k += 2\n\n    result = \"YES\\n\" + str(k) + \"\\n\"\n    l = 1\n    r = 1\n    for i in range(n):\n        if a[i] != 0:\n            result += str(l) + \" \" + str(r) + \"\\n\"\n            l = r + 1\n        r += 1\n\n    return result",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 211,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    min_score = 0\n    consecutive_correct = 0\n    for i in range(1, n + 1):\n        if i <= m:\n            min_score += 1\n            consecutive_correct += 1\n            if consecutive_correct == k:\n                min_score *= 2\n                consecutive_correct = 0\n        else:\n            min_score += 1\n            consecutive_correct = 0\n    return str(min_score % (10**9 + 9))",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 212,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = [int(d) for d in str(n)]\n    removed_digits = []\n\n    for digit in digits:\n        if digit % 8 == 0:\n            removed_digits.append(digit)\n        else:\n            for i in range(digit // 8 + 1, 8):\n                if digit % i == 0:\n                    removed_digits.append(digit)\n                    break\n\n    if not removed_digits:\n        return \"NO\"\n\n    result = int(\"\".join(str(d) for d in removed_digits))\n    return f\"YES\\n{result}\"",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 213,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    memory = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    memory.sort(key=lambda x: x[0])\n    memory.sort(key=lambda x: x[1], reverse=True)\n\n    floor = 1\n    current_flat = 1\n    for k, f in memory:\n        if current_flat == n:\n            return str(f)\n        if k == current_flat:\n            current_flat += 1\n            floor = f\n        else:\n            break\n\n    return \"-1\"\n",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 214,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[str]], row: int, col: int, bishwock_state: int) -> bool:\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n            return False\n        if board[row][col] == \"X\":\n            return False\n        if bishwock_state == 0:\n            if col + 1 < len(board[0]) and board[row][col + 1] == \"X\":\n                return False\n            if row + 1 < len(board) and board[row + 1][col] == \"X\":\n                return False\n        elif bishwock_state == 1:\n            if col - 1 >= 0 and board[row][col - 1] == \"X\":\n                return False\n            if row + 1 < len(board) and board[row + 1][col] == \"X\":\n                return False\n        elif bishwock_state == 2:\n            if col - 1 >= 0 and board[row][col - 1] == \"X\":\n                return False\n            if row - 1 >= 0 and board[row - 1][col] == \"X\":\n                return False\n        elif bishwock_state == 3:\n            if col + 1 < len(board[0]) and board[row][col + 1] == \"X\":\n                return False\n            if row - 1 >= 0 and board[row - 1][col] == \"X\":\n                return False\n        return True\n\n    def count_bishwocks(board: List[List[str]]) -> int:\n        max_bishwocks = 0\n        for bishwock_state in range(4):\n            bishwocks = 0\n            for row in range(len(board)):\n                for col in range(len(board[0])):\n                    if board[row][col] == \"0\" and is_valid(board, row, col, bishwock_state):\n                        bishwocks += 1\n            max_bishwocks = max(max_bishwocks, bishwocks)\n        return max_bishwocks\n\n    board = [list(line) for line in stdin.split(\"\\n\")]\n    return str(count_bishwocks(board)) ",
        "test": "",
        "num_ids": 568,
        "indeed": false
    },
    {
        "number": 215,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    lowercase = [i for i in range(n) if s[i].islower()]\n    uppercase = [i for i in range(n) if s[i].isupper()]\n    if not lowercase:\n        return '0'\n    lowercase.sort()\n    uppercase.sort()\n    i, j, count = 0, 0, 0\n    while i < len(lowercase) and j < len(uppercase):\n        if lowercase[i] < uppercase[j]:\n            count += 1\n            i += 1\n        else:\n            i = max(i, j + 1)\n            j += 1\n    return str(count)",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 216,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    b = a[:n//2]\n    c = a[n//2:]\n\n    B = sum(b)\n    C = sum(c)\n\n    return str(B - C)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 217,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, f, k = map(int, stdin.split())\n\n    total_distance = 2 * a\n    fuel_needed = total_distance\n    refuel_count = 0\n\n    while fuel_needed > b:\n        fuel_needed -= b - f\n        refuel_count += 1\n\n    if fuel_needed <= 0:\n        return -1\n\n    return (refuel_count + 1) * k\n",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 218,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    s = input()\n    if n % (p + q) != 0:\n        return \"-1\"\n    k = n // (p + q)\n    result = []\n    for i in range(0, n, p + q):\n        result.append(s[i:i + p + q])\n    return f\"{k}\\n\" + \"\\n\".join(result)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 219,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, d, obstacles = map(int, stdin.split())\n    obstacles = sorted(map(int, obstacles.split()))\n\n    def is_possible(x_start, x_finish, obstacles):\n        if x_start >= x_finish:\n            return True\n        for obstacle in obstacles:\n            if obstacle <= x_start:\n                continue\n            if obstacle >= x_finish:\n                break\n            if obstacle - x_start >= s:\n                return False\n        return True\n\n    def find_solution(x_start, x_finish, obstacles):\n        if x_start >= x_finish:\n            return []\n        for obstacle in obstacles:\n            if obstacle <= x_start:\n                continue\n            if obstacle >= x_finish:\n                break\n            if obstacle - x_start >= s:\n                return None\n        if x_finish - x_start <= d:\n            return [f\"JUMP {x_finish - x_start}\"]\n        for i in range(s, d + 1):\n            if is_possible(x_start, x_start + i, obstacles):\n                solution = find_solution(x_start + i, x_finish, obstacles)\n                if solution is not None:\n                    return [f\"RUN {i}>\"] + solution\n        return None\n\n    solution = find_solution(0, m, obstacles)\n    if solution is None:\n        return \"IMPOSSIBLE\"\n    return \"\\n\".join(solution)",
        "test": "",
        "num_ids": 384,
        "indeed": false
    },
    {
        "number": 220,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x = map(int, stdin.split())\n    count = 0\n\n    for i in range(1, s // 2 + 1):\n        if i ^ (s - i) == x:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 221,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    actions = []\n    for i in range(1, n + 1):\n        if not actions or actions[-1] + k < i:\n            actions.append(i)\n    return f\"{len(actions)}\\n{' '.join(map(str, actions))}\"",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 222,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = 0\n    while n > 0:\n        if n % 10 == 0:\n            return -1\n        n //= 10\n        i += 1\n    return i - 1",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 223,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n    f_max = 0\n    count = 0\n\n    for i in range(1, n + 1):\n        f_max = (f_max + i - 1) * i // i\n\n    for i in range(1, n + 1):\n        count = (count + f_max // i) % MOD\n\n    return str(count)\n",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 224,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    max_jump = 0\n    current_jump = 0\n    current_position = 0\n\n    while current_position < len(stdin):\n        if stdin[current_position] in vowels:\n            current_jump = 0\n        else:\n            current_jump += 1\n\n        if current_jump > max_jump:\n            max_jump = current_jump\n\n        current_position += 1\n\n    return max_jump + 1",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 225,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, a3, a4 = map(int, stdin.split())\n    total_candies = a1 + a2 + a3 + a4\n    if total_candies % 2 == 1:\n        return \"NO\"\n    if a1 == a2 == a3 == a4:\n        return \"YES\"\n    half_candies = total_candies // 2\n    if a1 + a3 == a2 + a4 == half_candies:\n        return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 226,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    slices = list(map(int, stdin.split('\\n')[1].split()))\n    slices.sort(reverse=True)\n\n    alice_score = sum(slices[::2])\n    bob_score = sum(slices[1::2])\n\n    return f\"{alice_score} {bob_score}\"",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 227,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def can_perform_operations(m: int) -> bool:\n        b = [0] * m\n        for i in range(n):\n            found = False\n            for j in range(m):\n                if b[j] == a[i]:\n                    found = True\n                    break\n            if found:\n                continue\n            for j in range(m):\n                for k in range(m):\n                    b[j] += b[k]\n                    if b[j] == a[i]:\n                        found = True\n                        break\n                if found:\n                    break\n            if not found:\n                return False\n        return True\n\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_perform_operations(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return str(left) if left <= n else \"-1\"",
        "test": "",
        "num_ids": 271,
        "indeed": false
    },
    {
        "number": 228,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = sorted(a, reverse=True)\n    alice_turn = True\n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n\n        if alice_turn:\n            a[i] -= 1\n            alice_turn = False\n        else:\n            alice_turn = True\n\n        if a[i] == 0:\n            break\n\n    if alice_turn:\n        return \"Alice\"\n    else:\n        return \"Bob\"",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 229,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(set(arr)) == 1:\n        return \"YES\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                x = abs(arr[i] - arr[j])\n                new_arr = [a + x if a < arr[j] else a - x if a > arr[j] else a for a in arr]\n                if len(set(new_arr)) == 1:\n                    return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 230,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split('\\n')\n    N = int(N)\n    S = S.strip()\n    max_len = 0\n    for len_ in range(1, N // 2 + 1):\n        for l_1 in range(N - len_ * 2 + 1):\n            l_2 = l_1 + len_\n            while l_2 + len_ <= N:\n                if S[l_1:l_1 + len_] == S[l_2:l_2 + len_]:\n                    max_len = max(max_len, len_)\n                    break\n                l_2 += 1\n    return str(max_len)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 231,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    if a == n // 2 + 1:\n        return str(n // 2)\n    else:\n        return str(n // 2 - 1)",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 232,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    lightsabers = list(map(int, stdin.split()[2:n + 2]))\n    k = list(map(int, stdin.split()[n + 2:n + 2 + m]))\n\n    for i in range(n - sum(k) + 1):\n        colors = [0] * m\n        for j in range(i, i + sum(k)):\n            colors[lightsabers[j] - 1] += 1\n        if colors == k:\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 153,
        "indeed": true
    },
    {
        "number": 233,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    mishka_score = 0\n    chris_score = 0\n\n    for i in range(1, n + 1):\n        mishka_throw, chris_throw = map(int, stdin.split('\\n')[i].split())\n\n        if mishka_throw > chris_throw:\n            mishka_score += 1\n        elif chris_throw > mishka_throw:\n            chris_score += 1\n\n    if mishka_score > chris_score:\n        return \"Mishka\"\n    elif chris_score > mishka_score:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"",
        "test": "",
        "num_ids": 186,
        "indeed": true
    },
    {
        "number": 234,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = []\n    for _ in range(n):\n        field.append(list(stdin.readline().strip()))\n\n    def count_bombs(i, j):\n        count = 0\n        for di in range(-1, 2):\n            for dj in range(-1, 2):\n                if 0 <= i + di < n and 0 <= j + dj < m:\n                    if field[i + di][j + dj] == '*':\n                        count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if count_bombs(i, j) != 0:\n                    return \"NO\"\n            else:\n                k = int(field[i][j])\n                if k != count_bombs(i, j):\n                    return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 235,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 1\n    total_eaten = 0\n    while total_eaten < n // 2:\n        k += 1\n        total_eaten = (n // k) * k + min(n % k, k // 10 * k)\n    return str(k)",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 236,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    pearls = [i for i in range(len(s)) if s[i] == 'o']\n    if len(pearls) == 1:\n        return \"YES\"\n    for i in range(len(pearls) - 1):\n        if pearls[i + 1] - pearls[i] != pearls[i] - pearls[i - 1]:\n            return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 237,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    min_pillows = (m // n) + 1\n    max_pillows = (m // n) + 2\n    return str(min(max_pillows, m - min_pillows * (n - 1) + 1))",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 238,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    def ceil(x):\n        return -(-x // 1)\n\n    def cost(l, r):\n        return sum(a[l:r + 1]) - k * ceil((r - l + 1) / m)\n\n    max_cost = 0\n    for l in range(n + 1):\n        for r in range(l, n):\n            max_cost = max(max_cost, cost(l, r))\n\n    return str(max_cost)",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 239,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p1 = (n, m)\n    p2 = (0, m)\n    p3 = (n, 0)\n    p4 = (0, 0)\n\n    return f\"{p1[0]} {p1[1]}\\n{p2[0]} {p2[1]}\\n{p3[0]} {p3[1]}\\n{p4[0]} {p4[1]}\\n\"",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 240,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_str, sub_str = stdin.split('\\n')\n    n_len = len(n_str)\n    sub_len = len(sub_str)\n\n    if n_len == sub_len:\n        return n_str\n\n    if n_len < sub_len:\n        n_str = '0' * (sub_len - n_len) + n_str\n\n    for i in range(sub_len):\n        if n_str[i] != sub_str[i]:\n            return n_str[:i] + sub_str[i] + n_str[i + 1:]\n\n    return n_str\n",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 241,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, min_temp, max_temp = map(int, stdin.split())\n    temperatures = list(map(int, input().split()))\n\n    if not (min_temp in temperatures and max_temp in temperatures):\n        return 'Incorrect'\n\n    temperatures.remove(min_temp)\n    temperatures.remove(max_temp)\n\n    for i in range(min_temp + 1, max_temp):\n        if i not in temperatures:\n            return 'Incorrect'\n\n    return 'Correct'\n",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 242,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    n = 5\n    factorial = 1\n    count = 0\n    result = []\n\n    while count < m:\n        if n == 0:\n            break\n        factorial *= n\n        count = 0\n        temp = factorial\n        while temp % 10 == 0:\n            count += 1\n            temp //= 10\n        if count >= m:\n            result.append(n)\n        n += 1\n\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 243,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            (cost, vertex) = heapq.heappop(queue)\n            if vertex not in visited:\n                visited.add(vertex)\n                if vertex == end:\n                    return cost\n                for neighbor, weight in graph[vertex].items():\n                    heapq.heappush(queue, (cost + weight, neighbor))\n        return None\n\n    def farthest_special_vertex(graph, special_vertices):\n        max_distance = 0\n        for i in range(len(special_vertices)):\n            for j in range(i + 1, len(special_vertices)):\n                distance = dijkstra(graph, special_vertices[i], special_vertices[j])\n                max_distance = max(max_distance, distance)\n        return max_distance\n\n    lines = stdin.splitlines()\n    n, m, k = map(int, lines[0].split())\n    x = list(map(int, lines[1].split()))\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for i in range(2, len(lines)):\n        u, v, w = map(int, lines[i].split())\n        graph[u][v] = w\n        graph[v][u] = w\n\n    result = []\n    for x_i in x:\n        distance = farthest_special_vertex(graph, [x_i])\n        result.append(distance)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 396,
        "indeed": false
    },
    {
        "number": 244,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n % 2 == 0:\n        return str((x + 1) % 3)\n    else:\n        return str((x - 1) % 3)",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 245,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_square(x1, y1, x2, y2):\n        return (x2 - x1) == (y2 - y1)\n\n    def is_inside_square(x1, y1, x2, y2, square_x1, square_y1, square_x2, square_y2):\n        return (square_x1 <= x1 <= square_x2) and (square_x1 <= x2 <= square_x2) and \\\n               (square_y1 <= y1 <= square_y2) and (square_y1 <= y2 <= square_y2)\n\n    n = int(stdin.readline())\n    rectangles = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    for square_x1 in range(31401):\n        for square_y1 in range(31401):\n            square_x2, square_y2 = square_x1 + 1, square_y1 + 1\n            if not is_square(square_x1, square_y1, square_x2, square_y2):\n                continue\n\n            inside_square = True\n            for x1, y1, x2, y2 in rectangles:\n                if not is_inside_square(x1, y1, x2, y2, square_x1, square_y1, square_x2, square_y2):\n                    inside_square = False\n                    break\n\n            if inside_square:\n                return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 377,
        "indeed": false
    },
    {
        "number": 246,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    count = 0\n\n    for x in range(1, n + 1):\n        digits_sum = sum(int(digit) for digit in str(x))\n        if x - digits_sum >= s:\n            count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 247,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_collinear(p1, p2, p3):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0\n\n    def is_possible(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_collinear(points[i], points[j], points[k]):\n                        return True\n        return False\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    if is_possible(points):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 248,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k, t = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_games(score_diff, remaining_turns):\n        if remaining_turns == 0:\n            return 1 if score_diff > 0 else 0\n\n        total_games = 0\n        for i in range(-k, k + 1):\n            new_score_diff = score_diff + i\n            if new_score_diff > 0:\n                total_games += count_games(new_score_diff, remaining_turns - 1)\n            elif new_score_diff < 0:\n                total_games += count_games(new_score_diff, remaining_turns - 1) * 2\n\n        return total_games % mod\n\n    total_games = count_games(a - b, t)\n    return str(total_games)",
        "test": "",
        "num_ids": 231,
        "indeed": false
    },
    {
        "number": 249,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    v = 0\n    if not binary_search(a, x):\n        v += 1\n    if not binary_search(a, y):\n        v += 1\n\n    return f\"{v}\\n{' '.join(map(str, [x, y]))}\"",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 250,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cakes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    cakes.sort(key=lambda x: x[2], reverse=True)\n\n    def is_valid(cakes, i, j):\n        if i == j:\n            return False\n        for k in range(i):\n            if cakes[k][1] < cakes[i][1] and cakes[k][2] >= cakes[i][2]:\n                return False\n        return True\n\n    def find_max_volume(cakes):\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if is_valid(cakes, i, j):\n                    dp[i] = max(dp[i], dp[j] + cakes[i][2])\n        return max(dp)\n\n    return str(find_max_volume(cakes))",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 251,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, input().split()))\n\n    h.sort()\n\n    total_cost = 0\n    for i in range(n - k):\n        total_cost += h[i + k] - h[i]\n\n    return total_cost",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 252,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_score = float('-inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            score = sum(a[:i] + a[i+1:j] + a[j+1:])\n            max_score = max(max_score, score)\n\n    return str(max_score)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 253,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k1, k2, k3 = map(int, stdin.split())\n\n    for x1 in range(k1, 10000):\n        for x2 in range(k2, 10000):\n            for x3 in range(k3, 10000):\n                if x1 <= x2 <= x3:\n                    continue\n                if x1 <= x3 <= x2:\n                    continue\n                if x2 <= x1 <= x3:\n                    continue\n                if x2 <= x3 <= x1:\n                    continue\n                if x3 <= x1 <= x2:\n                    continue\n                if x3 <= x2 <= x1:\n                    continue\n\n                if x1 <= max(k1, k2, k3):\n                    if x2 <= max(k1, k2, k3):\n                        if x3 <= max(k1, k2, k3):\n                            return \"YES\"\n                else:\n                    if x2 <= max(k1, k2, k3):\n                        if x3 <= max(k1, k2, k3):\n                            return \"YES\"\n                    else:\n                        if x3 <= max(k1, k2, k3):\n                            return \"YES\"\n                        else:\n                            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 328,
        "indeed": false
    },
    {
        "number": 254,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    i = 0\n    j = 1\n    min_operations = n\n\n    while j < n:\n        if s[i] == s[j]:\n            while j < n and s[i] == s[j]:\n                j += 1\n        else:\n            i += 1\n\n        min_operations = min(min_operations, n - j + i)\n\n    return str(min_operations)",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 255,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a = sorted(list(map(int, a.split())))\n    b = sorted(list(map(int, b.split())))\n\n    count = 0\n    i = 0\n    j = 0\n\n    while i < n and j < m:\n        if abs(a[i] - b[j]) <= 1:\n            count += 1\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            j += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 256,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    players = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    team1_defence = max(players[0][0], players[1][0])\n    team1_attack = max(players[0][1], players[1][1])\n    team2_defence = max(players[2][0], players[3][0])\n    team2_attack = max(players[2][1], players[3][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"",
        "test": "",
        "num_ids": 200,
        "indeed": false
    },
    {
        "number": 257,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def time_to_ready(x1, y1, x2, y2, c):\n        return c * distance(x1, y1, x2, y2)\n\n    def find_optimal_position(meat_coordinates, heat_source_position, ready_meat_count):\n        optimal_position = None\n        min_time = float('inf')\n\n        for x, y in meat_coordinates:\n            time = time_to_ready(x, y, heat_source_position[0], heat_source_position[1], 1)\n            if time < min_time:\n                min_time = time\n                optimal_position = (x, y)\n\n        return optimal_position, min_time\n\n    def main():\n        N, K = map(int, stdin.readline().split())\n        meat_coordinates = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n        optimal_position, min_time = find_optimal_position(meat_coordinates, (0, 0), K)\n\n        for x, y, c in meat_coordinates:\n            time = time_to_ready(x, y, optimal_position[0], optimal_position[1], c)\n            if time <= min_time:\n                min_time = time\n\n        return min_time\n\n    return main()",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 258,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, ticket = stdin.split('\\n')\n    n = int(n)\n    ticket = list(ticket)\n    erased_digits = [i for i, x in enumerate(ticket) if x == \"?\"]\n    total_erased = len(erased_digits)\n\n    def is_happy(ticket):\n        first_half = sum(int(x) for x in ticket[:n//2])\n        second_half = sum(int(x) for x in ticket[n//2:])\n        return first_half == second_half\n\n    def replace_digit(ticket, pos, digit):\n        ticket[pos] = digit\n\n    def play_game(ticket, current_player):\n        if not erased_digits:\n            return \"Monocarp\" if is_happy(ticket) else \"Bicarp\"\n\n        if current_player == \"Monocarp\":\n            next_player = \"Bicarp\"\n        else:\n            next_player = \"Monocarp\"\n\n        for pos in erased_digits:\n            for digit in range(10):\n                replace_digit(ticket, pos, str(digit))\n                result = play_game(ticket, next_player)\n                if result == next_player:\n                    return current_player\n                replace_digit(ticket, pos, \"?\")\n\n        return \"Monocarp\" if is_happy(ticket) else \"Bicarp\"\n\n    return play_game(ticket, \"Monocarp\")",
        "test": "",
        "num_ids": 369,
        "indeed": false
    },
    {
        "number": 259,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.readline().split())\n    buses = []\n    for i in range(n):\n        s, d = map(int, stdin.readline().split())\n        buses.append((s, d))\n\n    best_bus = None\n    best_time = float('inf')\n    for i, (s, d) in enumerate(buses):\n        if s >= t:\n            if s < best_time:\n                best_time = s\n                best_bus = i + 1\n        else:\n            arrival_time = s + (t - s) // d * d\n            if arrival_time < best_time:\n                best_time = arrival_time\n                best_bus = i + 1\n\n    return str(best_bus)",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 260,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if bin(i).count('1') == k:\n                count += 1\n        if count == m:\n            return str(n)\n        n += 1",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 261,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, scheme = stdin.split('\\n')\n    n = int(n)\n\n    if n < 5:\n        return \"no\"\n\n    platforms = []\n    for i in range(n):\n        if scheme[i] == '*':\n            platforms.append(i)\n\n    for i in range(len(platforms) - 4):\n        if platforms[i + 1] - platforms[i] == platforms[i + 2] - platforms[i + 1] == platforms[i + 3] - platforms[i + 2] == platforms[i + 4] - platforms[i + 3]:\n            return \"yes\"\n\n    return \"no\"",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 262,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magic_square(matrix, n, x):\n        sums = [sum(row) for row in matrix]\n        for i in range(n):\n            col_sum = 0\n            for j in range(n):\n                col_sum += matrix[j][i]\n            if col_sum != sums[0]:\n                return False\n\n        diag1_sum = sum(matrix[i][i] for i in range(n))\n        diag2_sum = sum(matrix[i][n - i - 1] for i in range(n))\n\n        return diag1_sum == diag2_sum == sums[0]\n\n    def find_empty_cell(matrix, n):\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    return i, j\n        return None\n\n    def fill_empty_cell(matrix, n, x):\n        empty_cell = find_empty_cell(matrix, n)\n        if empty_cell:\n            matrix[empty_cell[0]][empty_cell[1]] = x\n\n    n = int(stdin.readline().strip())\n    matrix = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    for x in range(1, 10**18):\n        fill_empty_cell(matrix, n, x)\n        if is_magic_square(matrix, n, x):\n            return str(x)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 370,
        "indeed": false
    },
    {
        "number": 263,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    k_min = max(a) + m // n\n    k_max = max(a) + m % n\n    if m % n != 0:\n        k_max += 1\n    return f\"{k_min} {k_max}\"",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 264,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    dp = [[0] * (n + 1) for _ in range(2)]\n    dp[0][1] = 1\n\n    for _ in range(m):\n        new_dp = [[0] * (n + 1) for _ in range(2)]\n        for i in range(1, n + 1):\n            for j in range(2):\n                if j == 0:\n                    new_dp[j][i] = (dp[j][i - 1] + dp[j][i + 1]) % MOD\n                else:\n                    new_dp[j][i] = (dp[j][i - 1] + dp[j][i + 1] + dp[j ^ 1][i]) % MOD\n        dp = new_dp\n\n    return sum(dp[0][1:]) % MOD",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 265,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_pleased(person, pizza):\n        return all(ingredient in pizza for ingredient in person)\n\n    def get_pleased_people(pizza1, pizza2):\n        return sum(is_pleased(person, pizza1) or is_pleased(person, pizza2) for person in people)\n\n    def get_total_price(pizza1, pizza2):\n        return pizzas[pizza1][\"price\"] + pizzas[pizza2][\"price\"]\n\n    def find_best_pizzas():\n        best_pizzas = (0, 0)\n        max_pleased_people = 0\n        min_total_price = float(\"inf\")\n\n        for i in range(len(pizzas)):\n            for j in range(i + 1, len(pizzas)):\n                pleased_people = get_pleased_people(pizzas[i][\"ingredients\"], pizzas[j][\"ingredients\"])\n                total_price = get_total_price(i, j)\n\n                if pleased_people > max_pleased_people or (pleased_people == max_pleased_people and total_price < min_total_price):\n                    max_pleased_people = pleased_people\n                    min_total_price = total_price\n                    best_pizzas = (i, j)\n\n        return best_pizzas\n\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n\n    people = []\n    for i in range(1, n + 1):\n        line = list(map(int, lines[i].split()))\n        f = line[0]\n        b = line[1:]\n        people.append(b)\n\n    pizzas = []\n    for i in range(n + 1, n + m + 1):\n        line = list(map(int, lines[i].split()))\n        c = line[0]\n        r = line[1]\n        a = line[2:]\n        pizzas.append({\"price\": c, \"ingredients\": set(a)})\n\n    best_pizzas = find_best_pizzas()\n    return f\"{best_pizzas[0] + 1} {best_pizzas[1] + 1}\\n\"",
        "test": "",
        "num_ids": 573,
        "indeed": false
    },
    {
        "number": 266,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    if s > 9 * m:\n        return \"-1 -1\"\n\n    max_num = int(\"9\" * m)\n    min_num = sum(range(1, m - s + 2))\n    if min_num > max_num:\n        return \"-1 -1\"\n\n    return f\"{min_num} {max_num}\"",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 267,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    mod = 998244353\n    total = 0\n\n    for num in range(l, r + 1):\n        digits = set(str(num))\n        if len(digits) <= k:\n            total += num\n\n    return str(total % mod)",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 268,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort()\n\n    boxes = []\n    current_box = [a[0]]\n\n    for i in range(1, n):\n        if abs(a[i] - a[i - 1]) <= d and len(current_box) < k:\n            current_box.append(a[i])\n        else:\n            boxes.append(current_box)\n            current_box = [a[i]]\n\n    boxes.append(current_box)\n\n    if all(len(box) >= k for box in boxes):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 269,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k_r, k_b, k_y, k_g = 0, 0, 0, 0\n\n    for i in range(len(s)):\n        if s[i] == 'R' and s[i - 1] != 'R' and s[i - 2] != 'R' and s[i - 3] != 'R':\n            k_r += 1\n        elif s[i] == 'B' and s[i - 1] != 'B' and s[i - 2] != 'B' and s[i - 3] != 'B':\n            k_b += 1\n        elif s[i] == 'Y' and s[i - 1] != 'Y' and s[i - 2] != 'Y' and s[i - 3] != 'Y':\n            k_y += 1\n        elif s[i] == 'G' and s[i - 1] != 'G' and s[i - 2] != 'G' and s[i - 3] != 'G':\n            k_g += 1\n\n    return f\"{k_r} {k_b} {k_y} {k_g}\"",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 270,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, graph):\n        if start == end:\n            return 1\n        if start in visited:\n            return 0\n        visited.add(start)\n        res = 0\n        for v in graph[start]:\n            res += dfs(v, end, visited, graph)\n        visited.remove(start)\n        return res\n\n    N, M = map(int, stdin.readline().split())\n    s_list = [0] * M\n    t_list = [0] * M\n    for i in range(M):\n        s, t = map(int, stdin.readline().split())\n        s_list[i] = s\n        t_list[i] = t\n\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        graph[s_list[i] - 1].append(t_list[i] - 1)\n\n    visited = set()\n    res = dfs(0, N - 1, visited, graph)\n    return f\"{res / 2:.10f}\"",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 271,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n    elif n % 10 == 0:\n        return str(n)\n    else:\n        return str(n - (n % 10) + 10)",
        "test": "",
        "num_ids": 68,
        "indeed": false
    },
    {
        "number": 272,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    if s == t:\n        return \"0\"\n\n    char_dict = {}\n    for i in range(len(s)):\n        if s[i] not in char_dict:\n            char_dict[s[i]] = [i]\n        else:\n            char_dict[s[i]].append(i)\n\n    swaps = []\n    for i in range(len(t)):\n        if t[i] != s[i]:\n            if char_dict[s[i]][-1] == i:\n                char_dict[s[i]].pop()\n            else:\n                swaps.append((s[i], t[i]))\n                char_dict[s[i]].remove(i)\n                char_dict[t[i]].remove(i)\n\n    if len(swaps) % 2 != 0:\n        return \"-1\"\n\n    result = [str(len(swaps) // 2)]\n    for swap in swaps:\n        result.append(\" \".join(swap))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 273,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_name, last_name = stdin.split()\n    prefixes = [first_name, last_name]\n    for i in range(1, len(first_name)):\n        prefixes.append(first_name[:i] + last_name)\n    for i in range(1, len(last_name)):\n        prefixes.append(first_name + last_name[:i])\n    prefixes.sort()\n    return prefixes[0]",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 274,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    brackets = stdin.readline().strip()\n\n    def draw_brackets(brackets: str) -> str:\n        if len(brackets) == 2:\n            return \"+- -+-+\\n|   |\\n+- -+-+\\n\"\n        elif len(brackets) == 4:\n            return \"+- -++- -+-+\\n|   ||   |\\n+- -++- -+-+\\n\"\n        else:\n            mid = len(brackets) // 2\n            left = brackets[:mid]\n            right = brackets[mid:]\n\n            left_drawn = draw_brackets(left)\n            right_drawn = draw_brackets(right)\n\n            left_rows = left_drawn.split(\"\\n\")[:-2]\n            right_rows = right_drawn.split(\"\\n\")[2:]\n\n            max_height = max(len(left_rows), len(right_rows))\n\n            left_rows += [\"\"] * (max_height - len(left_rows))\n            right_rows += [\"\"] * (max_height - len(right_rows))\n\n            for i in range(max_height):\n                left_rows[i] = left_rows[i].ljust(len(left)) + \"|\" + \" \" * (len(right))\n\n            return \"\\n\".join(left_rows + [\"|\"] + right_rows)\n\n    return draw_brackets(brackets)",
        "test": "",
        "num_ids": 361,
        "indeed": false
    },
    {
        "number": 275,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def golden_to_decimal(num: str) -> float:\n        decimal_value = 0\n        for i, digit in enumerate(num):\n            decimal_value += int(digit) * (q ** (len(num) - i - 1))\n        return decimal_value\n\n    q = (1 + 5 ** 0.5) / 2\n    num1, num2 = stdin.split('\\n')\n    decimal_value1 = golden_to_decimal(num1)\n    decimal_value2 = golden_to_decimal(num2)\n\n    if decimal_value1 > decimal_value2:\n        return '>'\n    elif decimal_value1 < decimal_value2:\n        return '<'\n    else:\n        return '='",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 276,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    gems = [\"Power\", \"Time\", \"Space\", \"Soul\", \"Reality\", \"Mind\"]\n    colors = [\"purple\", \"green\", \"blue\", \"orange\", \"red\", \"yellow\"]\n    n = int(stdin.readline())\n    seen_colors = [False] * 6\n    for i in range(n):\n        color = stdin.readline().strip()\n        seen_colors[colors.index(color)] = True\n    missing_gems = []\n    for i in range(6):\n        if not seen_colors[i]:\n            missing_gems.append(gems[i])\n    return f\"{len(missing_gems)}\\n\" + \"\\n\".join(missing_gems)",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 277,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a > n or b > n or a == b:\n        return \"Invalid input\"\n\n    if a % 2 == 1:\n        a += 1\n    if b % 2 == 1:\n        b += 1\n\n    if abs(a - b) == 2 or abs(a - b) == n - 2:\n        return \"Final!\"\n    else:\n        return 1\n\n    for i in range(2, n // 2 + 1):\n        if abs(a - i) == 2 or abs(a - i) == n - 2:\n            return i\n        if abs(b - i) == 2 or abs(b - i) == n - 2:\n            return i\n\n    return \"Impossible\"",
        "test": "",
        "num_ids": 200,
        "indeed": false
    },
    {
        "number": 278,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    count = 0\n    for i in range(n):\n        if p[i] != i + 1:\n            count += 1\n        if b[i] == 1:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 279,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    v_1, v_2, t, d = map(int, stdin.split())\n    max_length = (v_1 + v_2) * t / 2\n    if d == 0:\n        return str(max_length)\n    else:\n        for i in range(1, t):\n            max_length += min(d, v_2 - v_1 + d * i)\n        return str(max_length)",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 280,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(distances: List[int]) -> bool:\n        for i in range(1, M):\n            weight_sum = sum(w[j] for j in range(i, N, i) if j != 0)\n            if weight_sum > v[i - 1]:\n                return False\n        return True\n\n    N, M = map(int, stdin.readline().split())\n    w = list(map(int, stdin.readline().split()))\n    l, v = [], []\n    for _ in range(M):\n        li, vi = map(int, stdin.readline().split())\n        l.append(li)\n        v.append(vi)\n\n    if sum(w) > sum(v):\n        return \"-1\"\n\n    min_distance = float(\"inf\")\n    max_distance = (sum(l) - N + 1) // N\n    while min_distance < max_distance:\n        mid_distance = (min_distance + max_distance + 1) // 2\n        distances = [mid_distance] * (N - 1)\n        if is_valid(distances):\n            max_distance = mid_distance - 1\n            min_distance = mid_distance\n        else:\n            max_distance = mid_distance - 1\n\n    return str(min_distance)",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 281,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0:\n        return str(b % 10)\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result *= i\n            result %= 10\n        return str(result % 10)",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 282,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    if s[0] == '0' or s[-1] == '0':\n        return -1\n\n    lilies = [i for i in range(n) if s[i] == '1']\n    lilies.append(n)\n\n    jumps = [0] * (n + 1)\n    for i in range(1, n + 1):\n        jumps[i] = float('inf')\n        for j in lilies:\n            if j <= i <= j + d:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n\n    return -1 if jumps[n] == float('inf') else jumps[n]",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 283,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = 1\n    while True:\n        if n * m + 1 <= 1000:\n            if is_prime(n * m + 1):\n                m += 1\n            else:\n                return str(m)\n        else:\n            return str(m)\n\ndef",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 284,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for a in range(n // 1234567 + 1):\n        for b in range(n // 123456 + 1):\n            c = (n - a * 1234567 - b * 123456) // 1234\n            if a * 1234567 + b * 123456 + c * 1234 == n:\n                return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 285,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_strip(x, x_1, x_2):\n        return x_1 < x < x_2\n\n    def line_intersection(line1, line2):\n        x1, y1, k1, b1 = line1\n        x2, y2, k2, b2 = line2\n        x = (b2 - b1) / (k1 - k2)\n        y = k1 * x + b1\n        return x, y\n\n    def has_intersection_inside_strip(lines, x_1, x_2):\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                x, y = line_intersection(lines[i], lines[j])\n                if is_inside_strip(x, x_1, x_2):\n                    return True\n        return False\n\n    lines = []\n    n, x_1, x_2 = map(int, stdin.split()[0:3])\n    for i in range(n):\n        k, b = map(int, stdin.split()[3 + 2 * i:5 + 2 * i])\n        lines.append((x_1, x_2, k, b))\n\n    if has_intersection_inside_strip(lines, x_1, x_2):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 286,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    weights = set()\n\n    def generate_splits(remaining_sum, current_split, current_weight):\n        if remaining_sum == 0:\n            weights.add(current_weight)\n            return\n        if remaining_sum > 0:\n            generate_splits(remaining_sum - current_split[0], [current_split[0] + 1] + current_split, current_weight + 1)\n            generate_splits(remaining_sum, [current_split[0] + 1] + current_split, current_weight)\n\n    generate_splits(n, [1], 1)\n    return str(len(weights))",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 287,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    min_good_apartments = max(0, k - 1)\n    max_good_apartments = min(n - 1, k + 1)\n    return f\"{min_good_apartments} {max_good_apartments}\"",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 288,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    elif n % 2 == 0:\n        return str(n // 2)\n    else:\n        return str(n // 2 + 1)",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 289,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    count = 0\n    max_count = 0\n\n    for i in range(len(s) - 1):\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n        elif s[i] == 'K' and s[i + 1] == 'V':\n            count += 1\n\n    max_count = count\n\n    for i in range(1, len(s) - 1):\n        if s[i - 1] != s[i + 1]:\n            if s[i] == 'K':\n                s = s[:i] + 'V' + s[i + 1:]\n            else:\n                s = s[:i] + 'K' + s[i + 1:]\n\n            count = 0\n            for j in range(len(s) - 1):\n                if s[j] == 'V' and s[j + 1] == 'K':\n                    count += 1\n                elif s[j] == 'K' and s[j + 1] == 'V':\n                    count += 1\n\n            max_count = max(max_count, count)\n\n    return max_count",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 290,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"2\"\n    elif n == 2:\n        return \"3\"\n    else:\n        return str(n)",
        "test": "",
        "num_ids": 49,
        "indeed": false
    },
    {
        "number": 291,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return str(years)",
        "test": "",
        "num_ids": 57,
        "indeed": true
    },
    {
        "number": 292,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, n = map(int, stdin.split())\n    total_nodes = 2 ** h - 1\n    visited_nodes = 0\n    current_node = 1\n    command_index = 0\n    commands = \"LRLRLRLRL\"\n    visited = [False] * total_nodes\n\n    while not visited[n - 1]:\n        if command_index % 2 == 1 and visited[current_node - 1]:\n            command_index += 1\n\n        if command_index >= len(commands):\n            command_index = len(commands) - 1\n\n        if commands[command_index] == 'L':\n            next_node = current_node * 2\n        else:\n            next_node = current_node * 2 + 1\n\n        if next_node <= total_nodes:\n            visited[current_node - 1] = True\n            visited_nodes += 1\n            current_node = next_node\n\n        command_index += 1\n\n    return str(visited_nodes)",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 293,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    k = 0\n    result = []\n\n    for n in range(1, x + 1):\n        for m in range(1, x + 1):\n            distinct_squares = 0\n            for i in range(1, min(n, m) + 1):\n                distinct_squares += (n // i) * (m // i)\n            if distinct_squares == x:\n                k += 1\n                result.append((n, m))\n\n    return f\"{k}\\n\" + \"\\n\".join(f\"{n} {m}\" for n, m in result) + \"\\n\"",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 294,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    months = stdin.split(\"\\n\")[1].split()\n\n    for i in range(n):\n        months[i] = int(months[i])\n\n    total_days = sum(months)\n\n    if total_days > 365 or total_days < 363:\n        return \"NO\"\n\n    if n == 12:\n        return \"YES\"\n\n    if n == 13:\n        if months[0] == 31 and months[1] == 29:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 24:\n        if months[0] == 31 and months[1] == 29 and months[11] == 31 and months[12] == 31 and months[23] == 31:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 244,
        "indeed": false
    },
    {
        "number": 295,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_sequence(n: int) -> List[Tuple[int, int]]:\n        sequence = []\n        for b in range(2, n):\n            if n % b == 0:\n                for a in range(1, b):\n                    if gcd(a, b) == 1:\n                        sequence.append((a, b))\n        return sequence\n\n    def is_valid_sequence(sequence: List[Tuple[int, int]], n: int) -> bool:\n        numerator = sum(a for a, _ in sequence)\n        denominator = sum(b for _, b in sequence)\n        return 1 - numerator / denominator == 1 / n and denominator <= n\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin)\n    sequence = find_sequence(n)\n\n    if not sequence or not is_valid_sequence(sequence, n):\n        return \"NO\"\n\n    output = [\"YES\", f\"{len(sequence)}\"]\n    output.extend(f\"{a} {b}\" for a, b in sequence)\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 296,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, h = map(int, stdin.split())\n    h = list(map(int, h.split()))\n\n    def paint_fence(red_boards, green_boards):\n        unattractiveness = 0\n        for i in range(1, n):\n            if (i - 1 in red_boards and i in green_boards) or (i - 1 in green_boards and i in red_boards):\n                unattractiveness += h[i - 1]\n        return unattractiveness\n\n    min_unattractiveness = float('inf')\n    for i in range(1, n):\n        red_boards = [i - 1]\n        green_boards = [i]\n        for j in range(i + 1, n):\n            if sum(h[:j]) - sum(h[k] for k in red_boards) <= a and sum(h[j:]) - sum(h[k] for k in green_boards) <= b:\n                red_boards.append(j)\n                green_boards.append(j + 1)\n            else:\n                break\n        if i == n - 1 and sum(h[:i + 1]) - sum(h[k] for k in red_boards) <= a and sum(h[i + 1:]) - sum(h[k] for k in green_boards) <= b:\n            min_unattractiveness = min(min_unattractiveness, paint_fence(red_boards, green_boards))\n\n    return str(min_unattractiveness) if min_unattractiveness != float('inf') else '-1'",
        "test": "",
        "num_ids": 391,
        "indeed": false
    },
    {
        "number": 297,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    area = n * m // k\n\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1, n + 1):\n                for y2 in range(y1, m + 1):\n                    if x1 == x2 and y1 == y2:\n                        continue\n                    x3 = (area - x1 * (y2 - y1) + x2 * (y1 - y2)) // (y2 - y1)\n                    y3 = y1 + (area - x1 * (y2 - y1) + x2 * (y1 - y2)) % (y2 - y1)\n                    if 0 <= x3 <= n and 0 <= y3 <= m:\n                        return f\"YES\\n{x1} {y1}\\n{x2} {y2}\\n{x3} {y3}\"\n    return \"NO\"",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 298,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < k:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 39,
        "indeed": false
    },
    {
        "number": 299,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    exercises = list(map(int, stdin.split('\\n')[1].split()))\n\n    chest_exercises = 0\n    biceps_exercises = 0\n    back_exercises = 0\n\n    for i in range(n):\n        if i % 3 == 0:\n            chest_exercises += exercises[i]\n        elif i % 3 == 1:\n            biceps_exercises += exercises[i]\n        else:\n            back_exercises += exercises[i]\n\n    max_exercises = max(chest_exercises, biceps_exercises, back_exercises)\n\n    if max_exercises == chest_exercises:\n        return \"chest\"\n    elif max_exercises == biceps_exercises:\n        return \"biceps\"\n    else:\n        return \"back\"",
        "test": "",
        "num_ids": 259,
        "indeed": true
    },
    {
        "number": 300,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grades = list(map(int, stdin.split('\\n')[1].split()))\n    avg = sum(grades) / n\n    redo = 0\n\n    if avg < 4.5:\n        redo = 5 - n\n    elif avg > 4.5:\n        redo = 0\n    else:\n        for grade in grades:\n            if grade < 5:\n                redo += 1\n                avg = (avg * n + 5) / (n + 1)\n                if avg >= 4.5:\n                    break\n\n    return str(redo)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 301,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    u, v = map(int, stdin.split())\n\n    if u == 0 and v == 0:\n        return \"0\\n\"\n\n    if u == 0 and v != 0:\n        return \"-1\\n\"\n\n    if u == v:\n        return \"1\\n{}\\n\".format(u)\n\n    if u > v:\n        return \"-1\\n\"\n\n    if v % u == 0:\n        n = v // u\n        return \"{} \\n{}\\n\".format(n, u)\n\n    return \"-1\\n\"",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 302,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    while n > 0:\n        n -= 2 ** (len(bin(n)[2:]) - 1)\n        count += 1\n    return count",
        "test": "",
        "num_ids": 57,
        "indeed": false
    },
    {
        "number": 303,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[:4])\n    x, y = map(int, stdin.split()[4:])\n\n    def is_possible(x1, y1, x2, y2, x, y):\n        if x1 == x2 and y1 == y2:\n            return True\n        if x1 + x == x2 and y1 + y == y2:\n            return True\n        if x1 + x == x2 and y1 - y == y2:\n            return True\n        if x1 - x == x2 and y1 + y == y2:\n            return True\n        if x1 - x == x2 and y1 - y == y2:\n            return True\n        return False\n\n    if is_possible(x1, y1, x2, y2, x, y):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 304,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    variants = []\n    for i in range(1, 10):\n        variants.append(str(i) + str(n))\n        variants.append(str(n) + str(i))\n\n    for i in range(10, n):\n        for j in range(10):\n            variants.append(str(i) + str(j) + str(n))\n            variants.append(str(n) + str(i) + str(j))\n            variants.append(str(i) + str(n) + str(j))\n\n    return str(len(set(variants)))",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 305,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, e, f = map(int, stdin.split())\n\n    first_type_suits = min(a, d)\n    second_type_suits = min(b, c, d)\n\n    total_cost = first_type_suits * e + second_type_suits * f\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 306,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, p, x = map(int, stdin.split())\n    count = 0\n\n    for n in range(1, x + 1):\n        if n * pow(a, n, p) % p == b:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 73,
        "indeed": false
    },
    {
        "number": 307,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_2, k_3, k_5, k_6 = map(int, stdin.split())\n\n    max_sum = 0\n\n    # Create all possible combinations of 32 and 256\n    for i in range(k_2 + 1):\n        for j in range(k_3 + 1):\n            for l in range(k_5 + 1):\n                for m in range(k_6 + 1):\n                    # Calculate the sum of the current combination\n                    current_sum = i * 256 + j * 32 + l * 256 + m * 256\n                    max_sum = max(max_sum, current_sum)\n\n    return str(max_sum)",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 308,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, c = map(int, stdin.split())\n    painted = [(x, y)]\n    happy = False\n    time = 0\n\n    while not happy:\n        new_painted = []\n        for x, y in painted:\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if 1 <= new_x <= n and 1 <= new_y <= n and (new_x, new_y) not in painted:\n                    new_painted.append((new_x, new_y))\n        painted += new_painted\n        time += 1\n        if len(painted) >= c:\n            happy = True\n\n    return str(time)",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 309,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    max_xor = 0\n\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            max_xor = max(max_xor, a ^ b)\n\n    return str(max_xor)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 310,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    height = k // n\n    if k % n != 0:\n        height += 1\n    return str(height)",
        "test": "",
        "num_ids": 46,
        "indeed": true
    },
    {
        "number": 311,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, t1, t2, t3 = map(int, stdin.split())\n\n    time_stairs = (abs(x - y) - 1) * t1\n    time_elevator = t3 + (abs(x - z) * t2) + t3 + (abs(z - y) * t2) + t3\n\n    if time_stairs < time_elevator:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 312,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_prob = 0\n    min_a = 1\n\n    for a in range(1, n + 1):\n        prob = 0\n        for c in range(1, n + 1):\n            if abs(c - a) < abs(c - m):\n                prob += 1\n        prob /= n\n        if prob > max_prob:\n            max_prob = prob\n            min_a = a\n        elif prob == max_prob and a < min_a:\n            min_a = a\n\n    return str(min_a)",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 313,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pairs = map(int, stdin.split())\n    pairs = list(map(int, pairs))\n    stay = 0\n    i = 0\n    while i < n:\n        if pairs[i] == 1:\n            stay += 1\n            i += 1\n            while i < n and pairs[i] == 0:\n                i += 1\n        else:\n            i += 1\n    return str(stay)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 314,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    total_candies = 0\n    days = 0\n\n    for i in range(n):\n        total_candies += a[i]\n        if total_candies >= k:\n            days += 1\n            break\n        else:\n            total_candies += 8\n            days += 1\n\n    if total_candies < k:\n        return -1\n    else:\n        return days ",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 315,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = [0] * n\n    additional_walks = 0\n\n    for i in range(n):\n        if i == 0:\n            b[i] = k\n        elif i == n - 1:\n            b[i] = k\n        else:\n            b[i] = max(a[i] + k - b[i - 1], k)\n            additional_walks += b[i] - a[i]\n\n    return f\"{additional_walks}\\n{' '.join(map(str, b))}\"",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 316,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"5\"\n    else:\n        return str((n - 1) * 5 + 1)",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 317,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    for char in s:\n        if char.lower() in alphabet:\n            alphabet.remove(char.lower())\n    if len(alphabet) == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 104,
        "indeed": true
    },
    {
        "number": 318,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    time, minutes = stdin.split('\\n')\n    hours, mins = map(int, time.split(':'))\n    minutes = int(minutes)\n\n    total_minutes = hours * 60 + mins + minutes\n\n    hours, mins = divmod(total_minutes, 60)\n    hours %= 24\n\n    return f\"{hours:02d}:{mins:02d}\"",
        "test": "",
        "num_ids": 108,
        "indeed": true
    },
    {
        "number": 319,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(n):\n                    if k != i:\n                        a[k][j] = 1\n\n    for i in range(n):\n        if all(a[i]):\n            return \"YES\"\n    return \"NO\"\n",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 320,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    dominoes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_even_sum(dominoes: list) -> bool:\n        upper_sum = sum(domino[0] for domino in dominoes)\n        lower_sum = sum(domino[1] for domino in dominoes)\n        return (upper_sum + lower_sum) % 2 == 0\n\n    def rotate_dominoes(dominoes: list, index: int) -> None:\n        dominoes[index][0], dominoes[index][1] = dominoes[index][1], dominoes[index][0]\n\n    time = 0\n    for i in range(n):\n        if not is_even_sum(dominoes):\n            for j in range(i, n):\n                rotate_dominoes(dominoes, j)\n                if is_even_sum(dominoes):\n                    time += j - i + 1\n                    break\n            else:\n                return -1\n\n    return str(time)",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 321,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def area(a: int, b: int) -> int:\n        return a**2 - b**2\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        if is_prime(area(a, b)):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 322,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_on_same_side(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) >= 0\n\n    def is_on_one_side(points):\n        for i in range(len(points)):\n            if all(is_on_same_side(points[i], points[j], points[k]) for j, k in zip(range(i), range(i + 1, len(points)))):\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    if is_on_one_side(points):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 323,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def factorial(n):\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact\n    return str(gcd(factorial(A), factorial(B)))",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 324,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = n + 2\n    b = n\n    return f\"{a} {b}\"",
        "test": "",
        "num_ids": 36,
        "indeed": false
    },
    {
        "number": 325,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(vertex, time, coins):\n        if vertex == N:\n            return max(0, coins - time * P)\n        if (vertex, time, coins) in memo:\n            return memo[(vertex, time, coins)]\n\n        memo[(vertex, time, coins)] = -1\n        for i in range(len(edges)):\n            if edges[i][0] == vertex:\n                next_vertex = edges[i][1]\n                next_coins = edges[i][2] + coins\n                memo[(vertex, time, coins)] = max(\n                    memo[(vertex, time, coins)],\n                    dfs(next_vertex, time + 1, next_coins)\n                )\n\n        return memo[(vertex, time, coins)]\n\n    N, M, P = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n    memo = {}\n\n    max_score = dfs(1, 0, 0)\n    return str(max_score) if max_score != -1 else \"-1\" ",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 326,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_min_cost(s: str, c: int, memo: dict) -> int:\n        if (s, c) in memo:\n            return memo[(s, c)]\n\n        if c == 0:\n            return 0 if is_palindrome(s) else float('inf')\n\n        min_cost = float('inf')\n        for i in range(1, len(s) // 2 + 1):\n            left, right = s[:i], s[-i:]\n            if left == right:\n                min_cost = min(min_cost, find_min_cost(left, c - 1, memo) + c * len(left))\n\n        memo[(s, c)] = min_cost\n        return min_cost\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    strings = lines[1:N + 1]\n    costs = [int(s.split()[1]) for s in strings]\n    strings = [s.split()[0] for s in strings]\n\n    memo = {}\n    min_cost = float('inf')\n    for s, c in zip(strings, costs):\n        min_cost = min(min_cost, find_min_cost(s, c, memo))\n\n    return str(min_cost) if min_cost != float('inf') else '-1'",
        "test": "",
        "num_ids": 360,
        "indeed": false
    },
    {
        "number": 327,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    max_xor_sum = 0\n\n    for i in range(k):\n        max_xor_sum ^= a[i]\n\n    for i in range(k, n):\n        max_xor_sum ^= a[i]\n        max_xor_sum ^= a[i - k]\n\n    return str(max_xor_sum)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 328,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside_triangle(p, triangle):\n        a, b, c = triangle\n        A1 = ((b[0] - a[0]) * (p[1] - a[1]) - (b[1] - a[1]) * (p[0] - a[0]))\n        A2 = ((c[0] - b[0]) * (p[1] - b[1]) - (c[1] - b[1]) * (p[0] - b[0]))\n        A3 = ((a[0] - c[0]) * (p[1] - c[1]) - (a[1] - c[1]) * (p[0] - c[0]))\n        return A1 >= 0 and A2 >= 0 and A3 >= 0\n\n    def find_min_side(points):\n        points.sort(key=lambda p: p[0])\n        n = len(points)\n        min_side = float('inf')\n\n        for i in range(n - 2):\n            a, b, c = points[i], points[i + 1], points[i + 2]\n            if a[0] == b[0] and b[0] == c[0]:\n                continue\n            if a[1] == b[1] and b[1] == c[1]:\n                continue\n\n            if is_inside_triangle(a, (b, c, points[i - 1])):\n                min_side = min(min_side, distance(a, b) + distance(b, c))\n            if is_inside_triangle(b, (a, c, points[i + 3])):\n                min_side = min(min_side, distance(a, b) + distance(b, c))\n\n        return int(min_side)\n\n    n = int(stdin.readline())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    return str(find_min_side(points))",
        "test": "",
        "num_ids": 535,
        "indeed": false
    },
    {
        "number": 329,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    count = 0\n    for i in range(len(s) - 19):\n        if s[i:i+19] == \"nineteenineteen\":\n            count += 2\n        elif s[i:i+19] == \"nineteen\":\n            count += 1\n    return count",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 330,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, y = map(int, stdin.split())\n    highest_branch = -1\n\n    for i in range(p + 1, y + 1):\n        is_reachable = False\n        for j in range(2, p + 1):\n            if i % j == 0:\n                is_reachable = True\n                break\n        if not is_reachable:\n            highest_branch = i\n\n    return str(highest_branch)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 331,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    houses = list(map(int, stdin.split()[3:]))\n    houses[m - 1] = 0\n\n    min_distance = float('inf')\n    for i in range(n):\n        if houses[i] <= k:\n            min_distance = min(min_distance, abs(i - m + 1) * 10)\n\n    return str(min_distance)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 332,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    A = [[int(x) for x in stdin.readline().split()] for _ in range(n)]\n    B = [[int(x) for x in stdin.readline().split()] for _ in range(n)]\n\n    def is_transposable(A, B):\n        for i in range(n):\n            for j in range(m):\n                if A[i][j] != B[i][j]:\n                    return False\n        return True\n\n    def transpose_submatrix(A, x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                A[i][j], A[j][i] = A[j][i], A[i][j]\n\n    def find_submatrix(A, B):\n        for x1 in range(n):\n            for y1 in range(m):\n                for x2 in range(x1, n):\n                    for y2 in range(y1, m):\n                        if x2 - x1 + 1 == y2 - y1 + 1:\n                            submatrix_A = [[A[i][j] for j in range(y1, y2 + 1)] for i in range(x1, x2 + 1)]\n                            submatrix_B = [[B[i][j] for j in range(y1, y2 + 1)] for i in range(x1, x2 + 1)]\n                            if is_transposable(submatrix_A, submatrix_B):\n                                transpose_submatrix(A, x1, y1, x2, y2)\n                                if is_transposable(A, B):\n                                    return True\n        return False\n\n    if is_transposable(A, B):\n        return \"YES\"\n    elif find_submatrix(A, B):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 498,
        "indeed": false
    },
    {
        "number": 333,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    dp_a = [0] * (len(a) + 1)\n    dp_b = [0] * (len(b) + 1)\n\n    for i in range(1, len(a) + 1):\n        for j in range(1, len(b) + 1):\n            if a[i - 1] == b[j - 1]:\n                dp_a[i] = max(dp_a[i], dp_a[i - 1] + 1)\n                dp_b[j] = max(dp_b[j], dp_b[j - 1] + 1)\n            else:\n                dp_a[i] = max(dp_a[i], dp_a[i - 1])\n                dp_b[j] = max(dp_b[j], dp_b[j - 1])\n\n    return str(max(dp_a[-1], dp_b[-1]))\n",
        "test": "",
        "num_ids": 253,
        "indeed": false
    },
    {
        "number": 334,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    rick_screams = [b + i * a for i in range(100)]\n    morty_screams = [d + i * c for i in range(100)]\n\n    for rick_scream in rick_screams:\n        for morty_scream in morty_screams:\n            if rick_scream == morty_scream:\n                return str(rick_scream)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 139,
        "indeed": true
    },
    {
        "number": 335,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a, b, c = 1, 1, n - 2\n    while c % 3 == 0:\n        c -= 3\n        a += 3\n        b += 3\n    return f\"{a} {b} {c}\\n\"",
        "test": "",
        "num_ids": 73,
        "indeed": false
    },
    {
        "number": 336,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c, d = map(int, stdin.split())\n    count = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                for l in range(1, n + 1):\n                    for m in range(1, n + 1):\n                        for o in range(1, n + 1):\n                            for p in range(1, n + 1):\n                                for q in range(1, n + 1):\n                                    for r in range(1, n + 1):\n                                        if i != j and i != k and i != l and i != m and i != o and i != p and i != q and i != r and j != k and j != l and j != m and j != o and j != p and j != q and j != r and k != l and k != m and k != o and k != p and k != q and k != r and l != m and l != o and l != p and l != q and l != r and m != o and m != p and m != q and m != r and o != p and o != q and o != r and p != q and p != r and q != r:\n                                            square = [[i, j, k], [l, a, c], [m, d, o], [p, q, r]]\n                                            if sum(square[0]) == sum(square[1]) and sum(square[1]) == sum(square[2]) and sum(square[2]) == sum(square[3]) and sum(square[3]) == sum(square[0]):\n                                                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 421,
        "indeed": false
    },
    {
        "number": 337,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[:2])\n    u1, d1 = map(int, stdin.split()[2:4])\n    u2, d2 = map(int, stdin.split()[4:])\n\n    while h > 0:\n        w += h\n        if h == d1:\n            w -= u1\n        elif h == d2:\n            w -= u2\n        h -= 1\n\n    return str(w)",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 338,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, c, x, y = map(int, stdin.split())\n    c = sorted(c, reverse=True)\n    total_students = sum(c)\n    passing_rate = 0\n\n    for i in range(1, m + 1):\n        beginner_students = sum(c[:i])\n        intermediate_students = total_students - beginner_students\n\n        if x <= beginner_students <= y and x <= intermediate_students <= y:\n            passing_rate = i\n            break\n\n    return str(passing_rate) if passing_rate else \"0\"",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 339,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n\n    def min_coins(x, A, B):\n        if x == 1:\n            return 0\n        if x % k == 0:\n            return min_coins(x // k, A, B) + B\n        else:\n            return min_coins(x - 1, A, B) + A\n\n    return str(min_coins(n, A, B))",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 340,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_n = n\n    min_operations = 0\n\n    while n > 1:\n        sqrt_n = int(n ** 0.5)\n        if sqrt_n ** 2 == n:\n            n = sqrt_n\n            min_operations += 1\n        else:\n            for i in range(2, n):\n                if n % i == 0:\n                    quotient = n // i\n                    if quotient < i:\n                        break\n                    if quotient <= min_n:\n                        min_n = quotient\n                        min_operations = i - 1\n                    if quotient == i:\n                        break\n\n    return f\"{min_n} {min_operations}\"",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 341,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, R, S, P, T = list(map(int, stdin.split()))\n    T = list(T)\n    score = 0\n    for i in range(N):\n        if i >= K:\n            if T[i] != T[i - K]:\n                if T[i] == 'r':\n                    score += R\n                elif T[i] == 's':\n                    score += S\n                elif T[i] == 'p':\n                    score += P\n        else:\n            if T[i] == 'r':\n                score += R\n            elif T[i] == 's':\n                score += S\n            elif T[i] == 'p':\n                score += P\n    return str(score)",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 342,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_length = 0\n\n    max_length += a\n    max_length += b\n    max_length += 2 * min(a, b)\n    max_length += 2 * c\n\n    return str(max_length)",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 343,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p, x, y = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    if sum(a) > x:\n        return \"-1\"\n\n    remaining_tests = n - k\n    median_sum = sum(sorted(a)[n // 2 - 1:n // 2 + 1])\n\n    if median_sum < y:\n        return \"-1\"\n\n    result = []\n    for i in range(remaining_tests):\n        result.append(y - median_sum + 1)\n\n    return \" \".join(map(str, result))\n",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 344,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"aoiuie\"\n    prev_char = \"\"\n    for char in stdin:\n        if char not in vowels and prev_char not in vowels and prev_char != \"n\":\n            return \"NO\"\n        prev_char = char\n    return \"YES\"",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 345,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    dominoes = [0] * 7\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if j in graph[i - 1]:\n                dominoes[i] += 1\n                dominoes[j] += 1\n\n    return str(sum(min(dominoes[i], dominoes[i + 1]) for i in range(6)))",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 346,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    max_points = 0\n    for i in range(n):\n        if i + 1 in b:\n            max_points += a[i]\n        else:\n            max_points += a[-1]\n\n    return str(max_points)",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 347,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, w, h = map(lambda x: list(map(int, x.split())), stdin.split('\\n'))\n    h_s, h_u = h[0], h[1]\n    mx = [500, 1000, 1500, 2000, 2500]\n    score = 0\n\n    for i in range(5):\n        score += max(0.3 * mx[i], (1 - m[i] / 250) * mx[i] - 50 * w[i])\n\n    score += 100 * h_s - 50 * h_u\n\n    return str(int(score))",
        "test": "",
        "num_ids": 174,
        "indeed": true
    },
    {
        "number": 348,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, L, R = map(int, stdin.split())\n    MOD = 998244353\n\n    dp = [[0] * (R + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(R + 1):\n            for k in range(L, j + 1):\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j - k]\n                if j > 0:\n                    dp[i][j] += dp[i][j - k]\n                dp[i][j] %= MOD\n\n    return str(dp[n][R])",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 349,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    matrix1 = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    matrix2 = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_increasing(matrix):\n        for i in range(n):\n            for j in range(m - 1):\n                if matrix[i][j] >= matrix[i][j + 1]:\n                    return False\n        for j in range(m):\n            for i in range(n - 1):\n                if matrix[i][j] >= matrix[i + 1][j]:\n                    return False\n        return True\n\n    if is_increasing(matrix1) and is_increasing(matrix2):\n        return \"Possible\"\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 220,
        "indeed": false
    },
    {
        "number": 350,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_length = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                length = 0\n                for l in range(n):\n                    length += min(a[l], i, j, k)\n                max_length = max(max_length, length)\n\n    return max_length",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 351,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] > 2 * k:\n            count += 1\n            k = a[i]\n    return str(count)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solution(stdin)) ",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 352,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, min_1, max_1, min_2, max_2, min_3, max_3 = map(int, stdin.split())\n\n    max_1_diplomas = min(n, max_1)\n    max_2_diplomas = min(n - max_1_diplomas, max_2)\n    max_3_diplomas = n - max_1_diplomas - max_2_diplomas\n\n    return f\"{max_1_diplomas} {max_2_diplomas} {max_3_diplomas}\\n\"",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 353,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n < 30:\n        return -1\n\n    if a[-1] < a[-2]:\n        return \"DOWN\"\n    elif a[-1] > a[-2]:\n        return \"UP\"\n    else:\n        return -1",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 354,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in vowels and t[i] in vowels:\n                continue\n            elif s[i] not in vowels and t[i] not in vowels:\n                continue\n            else:\n                return \"No\"\n    return \"Yes\"",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 355,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    rows, cols = len(board), len(board[0])\n\n    def is_valid_move(player, row, col):\n        if player == 'W' and row == rows - 1:\n            return False\n        if player == 'B' and row == 0:\n            return False\n        return board[row][col] == '.'\n\n    def find_moves(player):\n        moves = []\n        for row in range(rows):\n            for col in range(cols):\n                if is_valid_move(player, row - 1 if player == 'W' else row + 1, col):\n                    moves.append((row, col))\n        return moves\n\n    def make_move(player, row, col):\n        board[row][col] = player\n        board[row - 1 if player == 'W' else row + 1][col] = '.'\n\n    while True:\n        white_moves = find_moves('W')\n        if not white_moves:\n            return 'B'\n        black_moves = find_moves('B')\n        if not black_moves:\n            return 'A'\n        for row, col in white_moves:\n            make_move('W', row, col)\n            if not black_moves:\n                return 'A'\n            for r, c in black_moves:\n                make_move('B', r, c)\n                if not white_moves:\n                    return 'B'\n                make_move('B', r, c)\n            make_move('W', row, col)\n",
        "test": "",
        "num_ids": 400,
        "indeed": false
    },
    {
        "number": 356,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a = sorted(a)\n    b = sorted(b)\n    i = j = 0\n    while i < n and j < m:\n        if a[i] == b[j]:\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            j += 1\n    return max(n, m) - i if i != n and i != m else \"-1\"",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 357,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        if friend in stdin:\n            count += 1\n    return \"YES\" if count == 1 else \"NO\"",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 358,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    l = b - a + 1\n    for i in range(1, l):\n        count = 0\n        for j in range(a, b - i + 1):\n            if is_prime(j) or is_prime(j + i):\n                count += 1\n        if count >= k:\n            return str(i)\n    return \"-1\"\n\ndef",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 359,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, h, w = map(int, stdin.split())\n\n    if a > min(h, w):\n        return \"-1\"\n\n    if a == min(h, w):\n        return \"0\"\n\n    x = (min(h, w) - a) / (a + 1)\n    return str(x)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 360,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    chapters = []\n    for i in range(n):\n        l, r = map(int, stdin.split('\\n')[i+1].split())\n        chapters.append((l, r))\n    k = int(stdin.split('\\n')[n+1])\n\n    unfinished_chapters = 0\n    for i, (l, r) in enumerate(chapters):\n        if i == len(chapters) - 1:\n            if l <= k <= r:\n                unfinished_chapters += 1\n        else:\n            if l <= k <= r:\n                unfinished_chapters += 1\n            elif k < l:\n                break\n\n    return str(unfinished_chapters)",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 361,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = \"CODEFORCES\"\n    if word in stdin:\n        return \"YES\"\n    for i in range(len(word), 0, -1):\n        for j in range(len(stdin) - len(word) + 1):\n            if stdin[j:j + i] == word[:i] and stdin[j + i:] == word[i:]:\n                return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 362,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    if n == 3:\n        return str(1 * 2 * 3)\n    elif n == 4:\n        return str(1 * 2 * 3 + 1 * 3 * 4)\n    else:\n        total_area = n * (n - 1) // 2\n        min_weight = float('inf')\n        for i in range(1, n - 1):\n            weight = i * (i + 1) // 2 * (total_area - i * (i + 1) // 2)\n            min_weight = min(min_weight, weight)\n        return str(min_weight)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 363,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = len(str(n))\n    return str(digits)",
        "test": "",
        "num_ids": 30,
        "indeed": false
    },
    {
        "number": 364,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split('\\n')[0].split())\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    cnt_A = [0] * n\n    cnt_B = [0] * n\n\n    for i in range(n):\n        if colors[i] == A:\n            cnt_A[i] = 1\n        else:\n            cnt_B[i] = 1\n\n    for i in range(1, n):\n        cnt_A[i] += cnt_A[i - 1]\n        cnt_B[i] += cnt_B[i - 1]\n\n    for B in range(1, 1000001):\n        if B == A:\n            continue\n\n        is_win = True\n        for i in range(n):\n            if cnt_A[i] > cnt_B[i] + 1:\n                is_win = False\n                break\n\n        if is_win:\n            return str(B)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 365,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.readline().split())\n    encoding = list(map(int, stdin.readline().split()))\n\n    if sum(encoding) != x:\n        return \"NO\"\n\n    segments = [0] * n\n    segments[0] = 1\n    for i in range(1, n):\n        if encoding[i] == encoding[i - 1]:\n            segments[i] = segments[i - 1]\n        else:\n            segments[i] = segments[i - 1] + 1\n\n    if len(set(segments)) == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 366,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    dp = [float('inf')] * (S + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(i, S + 1):\n            if j - i >= 0:\n                dp[j] = min(dp[j], dp[j - i] + 1)\n    return str(dp[S])",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 367,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    changes = 0\n    palindrome = \"\"\n\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            changes += 1\n            palindrome += s[n - i - 1]\n        else:\n            palindrome += s[i]\n\n    if n % 2 == 1:\n        if s[n // 2] != s[n // 2 - 1]:\n            changes += 1\n            palindrome += s[n // 2 - 1]\n        else:\n            palindrome += s[n // 2]\n\n    if changes % 2 == 1:\n        palindrome = palindrome[:n // 2 + 1] + s[n // 2] + palindrome[n // 2 + 1:]\n\n    return palindrome",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 368,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    white_weight = 0\n    black_weight = 0\n\n    for line in stdin.split('\\n'):\n        for char in line:\n            if char.isupper():\n                if char == 'Q':\n                    white_weight += 9\n                elif char == 'R':\n                    white_weight += 5\n                elif char == 'B':\n                    white_weight += 3\n                elif char == 'N':\n                    white_weight += 3\n                elif char == 'P':\n                    white_weight += 1\n            elif char.islower():\n                if char == 'q':\n                    black_weight += 9\n                elif char == 'r':\n                    black_weight += 5\n                elif char == 'b':\n                    black_weight += 3\n                elif char == 'n':\n                    black_weight += 3\n                elif char == 'p':\n                    black_weight += 1\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif white_weight < black_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"",
        "test": "",
        "num_ids": 268,
        "indeed": true
    },
    {
        "number": 369,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    S = stdin.readline().strip()\n\n    if S[0] == '1' or S[N] == '1':\n        return \"-1\"\n\n    def is_game_over(s: str) -> bool:\n        for i in range(N + 1):\n            if s[i] == '1':\n                return True\n        return False\n\n    def find_shortest_seq(start: int, end: int, depth: int, path: list) -> list:\n        if start > end:\n            return None\n        if start == end:\n            return path\n\n        min_seq = None\n        for i in range(1, M + 1):\n            next_pos = start + i\n            if next_pos <= end and not is_game_over(S[:next_pos] + '0' * (N + 1 - next_pos)):\n                new_path = find_shortest_seq(next_pos, end, depth + 1, path + [i])\n                if new_path:\n                    if min_seq is None or len(new_path) < len(min_seq):\n                        min_seq = new_path\n\n        return min_seq\n\n    shortest_seq = find_shortest_seq(0, N, 0, [])\n    if shortest_seq:\n        return \" \".join(map(str, shortest_seq))\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 360,
        "indeed": false
    },
    {
        "number": 370,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, X, Y = map(int, stdin.split())\n\n    if K < abs(X) + abs(Y):\n        return \"-1\"\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    score = 0\n    current_x, current_y = 0, 0\n    while current_x != X or current_y != Y:\n        score += 1\n        next_x, next_y = min((current_x + K, current_y), (current_x - K, current_y), (current_x, current_y + K), (current_x, current_y - K))\n        if manhattan_distance(current_x, current_y, next_x, next_y) != K:\n            return \"-1\"\n        current_x, current_y = next_x, next_y\n\n    return f\"{score}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in zip([0, *current_x], [0, *current_y]))",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 371,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    n = 1\n    while True:\n        ways = 0\n        for i in range(4):\n            for j in range(i + 1):\n                ways += 1\n        if ways == m:\n            return str(n)\n        elif ways > m:\n            return \"-1\"\n        n += 1",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 372,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, r1 = map(int, stdin.split()[0].split())\n    x2, y2, r2 = map(int, stdin.split()[1].split())\n\n    if x1 == x2 and y1 == y2 and r1 == r2:\n        return str(3.141592653589793 * r1 ** 2)\n\n    d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    if d > r1 + r2 or d < abs(r1 - r2):\n        return str(0.0)\n\n    if r1 > r2:\n        r1, r2 = r2, r1\n\n    a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    h = (r1 ** 2 - a ** 2) ** 0.5\n\n    area = r1 ** 2 * acos((a ** 2 + r1 ** 2 - r2 ** 2) / (2 * a * r1)) + r2 ** 2 * acos((a ** 2 + r2 ** 2 - r1 ** 2) / (2 * a * r2)) - 0.5 * sqrt((-a + r1 + r2) * (a + r1 - r2) * (a - r1 + r2) * (a + r1 + r2))\n\n    return str(area)",
        "test": "",
        "num_ids": 370,
        "indeed": false
    },
    {
        "number": 373,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    v = int(stdin.strip())\n    if v == 1:\n        return \"1\"\n    factors = []\n    for i in range(2, int(v**0.5) + 1):\n        if v % i == 0:\n            factors.append(i)\n            if i != v // i:\n                factors.append(v // i)\n    factors.sort()\n    for factor in factors:\n        if factor < v:\n            v -= factor\n    return str(v)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 374,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, a = map(int, stdin.split())\n    p = [0] + p\n    a = [0] + a\n    for i in range(1, n + 1):\n        a[p[i]] += a[i]\n    return str(a[0])",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 375,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    S = stdin.readline().strip()\n    T = stdin.readline().strip()\n\n    def can_transform(W: str, S: str, T: str) -> bool:\n        if len(W) != len(S) + 1 or len(W) != len(T) + 1:\n            return False\n\n        for i in range(n):\n            if S[i] == W[i] and T[i] == W[i + 1]:\n                continue\n            if S[i] == W[i + 1] and T[i] == W[i]:\n                continue\n\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            W = S[:i] + S[i + 1:] + T[j]\n            if can_transform(W, S, T):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 376,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_neighbor(u, v):\n        return u in graph[v] or v in graph[u]\n\n    def is_semi_neighbor(u, v):\n        for k in range(1, n + 1):\n            if k != u and k != v and is_neighbor(u, k) and is_neighbor(k, v):\n                return True\n        return False\n\n    def find_min_strength():\n        min_strength = float('inf')\n        for i in range(1, n + 1):\n            if strengths[i - 1] <= min_strength:\n                for j in range(1, n + 1):\n                    if j != i and not is_neighbor(i, j) and not is_semi_neighbor(i, j):\n                        min_strength = min(min_strength, strengths[i - 1])\n        return min_strength\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    strengths = list(map(int, lines[1].split()))\n    graph = [[] for _ in range(n)]\n\n    for i in range(2, n):\n        u, v = map(int, lines[i].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    return str(find_min_strength())",
        "test": "",
        "num_ids": 357,
        "indeed": false
    },
    {
        "number": 377,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(max(0, n - m - 1))",
        "test": "",
        "num_ids": 32,
        "indeed": false
    },
    {
        "number": 378,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, r = map(int, stdin.split())\n    if r == 10:\n        return \"1\"\n    else:\n        return str((k + r - 1) // r)",
        "test": "",
        "num_ids": 50,
        "indeed": false
    },
    {
        "number": 379,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    puzzle = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x, y, n, m):\n        for i in range(x, x + n):\n            for j in range(y, y + m):\n                if puzzle[i][j] != 'X':\n                    return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j, n, m) and is_valid(i, j, n, m):\n                return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 380,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return \"1\"\n    elif x1 == x2 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"2\"\n    else:\n        return \"3\"",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 381,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n\n    if k < 1 or k > 100:\n        return \"NO\"\n\n    n = 2\n    m = 1\n    edges = [(1, 2)]\n\n    output = [\"YES\", f\"{n} {m}\"]\n    for a, b in edges:\n        output.append(f\"{a} {b}\")\n\n    return \"\\n\".join(output)\n",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 382,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split('\\n')[0].split())\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    def count_occurrences(s: str, t: str, l: int, r: int) -> int:\n        count = 0\n        for i in range(l, r - m + 1):\n            if s[i:i + m] == t:\n                count += 1\n        return count\n\n    result = []\n    for l, r in queries:\n        result.append(count_occurrences(s, t, l, r))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 383,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_paths(n: int, k: int, d: int) -> int:\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, k + 1):\n            for j in range(1, n + 1):\n                for l in range(1, i + 1):\n                    for m in range(1, j + 1):\n                        if l >= d and m >= d:\n                            dp[i][j] += dp[i - l][j - m]\n                            dp[i][j] %= mod\n\n        return dp[k][n]\n\n    return str(count_paths(n, k, d))",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 384,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    row = stdin.readline().strip()\n\n    # Count the number of black squares in the row\n    black_count = 0\n    for square in row:\n        if square == 'B':\n            black_count += 1\n\n    # If there are no black squares, return 0\n    if black_count == 0:\n        return \"0\\n\"\n\n    # Find the groups of black squares\n    groups = []\n    group_count = 1\n    for i in range(1, n):\n        if row[i] == 'B' and row[i - 1] == 'W':\n            groups.append(group_count)\n            group_count = 1\n        elif row[i] == 'B' and row[i - 1] == 'B':\n            group_count += 1\n        else:\n            groups.append(group_count)\n            group_count = 1\n    groups.append(group_count)\n\n    # Remove groups of size 1\n    groups = [group for group in groups if group != 1]\n\n    # Return the output\n    output = \"{}\".format(len(groups))\n    for group in groups:\n        output += \"\\n{}\".format(group)\n    return output",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 385,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[0].split())\n    sequence = stdin.split()[1]\n    operations = stdin.split()[2]\n\n    cursor = p - 1\n\n    def find_pair(sequence: str, cursor: int) -> int:\n        stack = []\n        for i, bracket in enumerate(sequence):\n            if bracket == \"(\":\n                stack.append(i)\n            else:\n                if not stack:\n                    return -1\n                if i == cursor:\n                    return stack[-1]\n                stack.pop()\n        return -1\n\n    def delete_pair(sequence: str, cursor: int) -> str:\n        pair = find_pair(sequence, cursor)\n        if pair == -1:\n            return sequence\n        left = min(cursor, pair)\n        right = max(cursor, pair)\n        return sequence[:left] + sequence[right + 1:]\n\n    for operation in operations:\n        if operation == \"L\":\n            cursor = max(0, cursor - 1)\n        elif operation == \"R\":\n            cursor = min(n - 1, cursor + 1)\n        elif operation == \"D\":\n            sequence = delete_pair(sequence, cursor)\n            cursor = max(0, min(cursor, len(sequence) - 1))\n\n    return sequence",
        "test": "",
        "num_ids": 327,
        "indeed": false
    },
    {
        "number": 386,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n\n    lower_bound = -2 * (10 ** 9)\n    upper_bound = 2 * (10 ** 9)\n\n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n\n        if sign == '>':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x + 1)\n            else:\n                upper_bound = min(upper_bound, x)\n        elif sign == '<':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x - 1)\n            else:\n                lower_bound = max(lower_bound, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x)\n            else:\n                upper_bound = min(upper_bound, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x)\n            else:\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return str(lower_bound)\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 387,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_letters = a + b\n\n    periods = set()\n\n    for period in range(1, total_letters + 1):\n        valid = True\n        for i in range(total_letters):\n            if i % period < a:\n                if i % period != i // period % period:\n                    valid = False\n                    break\n            else:\n                if (i % period) != (a + (i // period) % b):\n                    valid = False\n                    break\n        if valid:\n            periods.add(period)\n\n    return len(periods)\n",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 388,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_name(length: int) -> str:\n        import random\n        import string\n        return ''.join(random.choice(string.ascii_uppercase) for _ in range(1)) + ''.join(random.choice(string.ascii_lowercase) for _ in range(length - 1))\n\n    n, k = map(int, stdin.split()[0:2])\n    soldiers_notes = stdin.split()[2:]\n\n    soldiers = []\n    for i in range(n):\n        name = generate_name(random.randint(1, 10))\n        soldiers.append(name)\n\n    for i in range(n - k + 1):\n        group = soldiers[i:i + k]\n        if len(set(group)) != len(group) and soldiers_notes[i] == \"YES\":\n            return \"INVALID\"\n        elif len(set(group)) == len(group) and soldiers_notes[i] == \"NO\":\n            return \"INVALID\"\n\n    return ' '.join(soldiers)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 389,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if a == b:\n        return \"0\"\n\n    operations = 0\n    while a % 2 == 0 and b % 2 == 0:\n        a //= 2\n        b //= 2\n        operations += 1\n\n    while a % 3 == 0 and b % 3 == 0:\n        a //= 3\n        b //= 3\n        operations += 1\n\n    while a % 5 == 0 and b % 5 == 0:\n        a //= 5\n        b //= 5\n        operations += 1\n\n    if a == b:\n        return str(operations)\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 390,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_form_palindrome(colors, a, b):\n        left, right = 0, len(colors) - 1\n        while left < right:\n            if colors[left] == 2 and colors[right] == 2:\n                return True\n            elif colors[left] == 2:\n                if colors[right] == 0:\n                    if a <= b:\n                        return False\n                    else:\n                        colors[left] = 0\n                        colors[right] = 1\n                else:\n                    if a >= b:\n                        return False\n                    else:\n                        colors[left] = 1\n                        colors[right] = 0\n            elif colors[right] == 2:\n                if colors[left] == 0:\n                    if a <= b:\n                        return False\n                    else:\n                        colors[left] = 0\n                        colors[right] = 1\n                else:\n                    if a >= b:\n                        return False\n                    else:\n                        colors[left] = 1\n                        colors[right] = 0\n            elif colors[left] != colors[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    def min_cost(colors, a, b):\n        cost = 0\n        for i in range(len(colors)):\n            if colors[i] == 2:\n                if i % 2 == 0:\n                    colors[i] = 0\n                    cost += a\n                else:\n                    colors[i] = 1\n                    cost += b\n        return cost\n\n    n, a, b = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    if can_form_palindrome(colors, a, b):\n        return str(min_cost(colors, a, b))\n    else:\n        return str(-1)",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 391,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n\n    if k % 2 == 0:\n        return \"-1\"\n\n    output = \"\"\n    for i in range(k):\n        for j in range(k):\n            if (i + j) % 2 == 0:\n                output += \"b\"\n            else:\n                output += \"w\"\n        output += \"\\n\"\n\n    return output",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 392,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_num = 1\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            max_num = max(max_num, i)\n            if i != n // i:\n                max_num = max(max_num, n // i)\n\n    return str(n // max_num)",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 393,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, seating = stdin.split('\\n')\n    n = int(n)\n\n    if seating.count('1') == 1:\n        return \"Yes\"\n\n    if seating.count('1') == n:\n        return \"No\"\n\n    for i in range(1, n - 1):\n        if seating[i] == '1' and seating[i - 1] == seating[i + 1] == '1':\n            return \"No\"\n\n    return \"Yes\"",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 394,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(k: int) -> bool:\n        x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n        for i in range(k, n):\n            if a[i] - a[i - 1] != x[(i - k) % k]:\n                return False\n        return True\n\n    valid_ks = [k for k in range(1, n + 1) if is_valid(k)]\n    return f\"{len(valid_ks)}\\n\" + \" \".join(map(str, valid_ks))",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 395,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    scores = list(map(int, stdin.split()))\n    scores.sort()\n    team1 = scores[:3]\n    team2 = scores[3:]\n    team1_score = sum(team1)\n    team2_score = sum(team2)\n    if team1_score == team2_score:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 396,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r + 1):\n        x, y = 0, 0\n        while i % 2 == 0:\n            x += 1\n            i //= 2\n        while i % 3 == 0:\n            y += 1\n            i //= 3\n        if i == 1:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 397,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sweets_ate = 0\n    sweets_in_box = 1\n\n    for _ in range(n - 1):\n        if sweets_in_box > 0:\n            choice = input(\"Choose option 1 or 2: \")\n            if choice == \"1\":\n                sweets_in_box -= 1\n                sweets_ate += 1\n            elif choice == \"2\":\n                sweets_in_box += 1\n        else:\n            sweets_in_box += 1\n\n    return str(sweets_ate)",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 398,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    line_segments = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if line_segments[i] + line_segments[j] > line_segments[k] and line_segments[i] + line_segments[k] > line_segments[j] and line_segments[j] + line_segments[k] > line_segments[i]:\n                    return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 165,
        "indeed": true
    },
    {
        "number": 399,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 0 and y == 1:\n        return \"Yes\"\n    elif x == 1 and y == 2:\n        return \"Yes\"\n    elif x > 0 and y > 1 and (x + y) % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 400,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    a.sort()\n\n    total_rating = sum([floor(x / 10) for x in a])\n\n    for i in range(n):\n        if k == 0:\n            break\n        if a[i] == 100:\n            continue\n        units_to_use = min(k, 100 - a[i])\n        a[i] += units_to_use\n        total_rating += units_to_use\n        k -= units_to_use\n\n    return str(total_rating)",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 401,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    def is_pretty(num: int) -> bool:\n        num_str = str(num)\n        has_a = any(digit in num_str for digit in a)\n        has_b = any(digit in num_str for digit in b)\n        return has_a and has_b\n\n    i = 1\n    while not is_pretty(i):\n        i += 1\n\n    return str(i)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 402,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    time_to_solve = [5 * i for i in range(1, n + 1)]\n    total_time = sum(time_to_solve)\n    total_time += k\n    if total_time <= 1200:\n        return str(n)\n    else:\n        time_left = total_time - 1200\n        for i in range(n):\n            if time_left <= 0:\n                return str(i)\n            time_left -= time_to_solve[i]\n        return str(n)",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 404,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin.strip())\n    result = set()\n    for a in range(1, 10**18 + 1):\n        result.add(lcm(a, b) // a)\n    return str(len(result))\n\ndef",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 405,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bumpers = stdin.split('\\n')\n    n = int(n)\n\n    count = 0\n    for i in range(n):\n        if bumpers[i] == '<':\n            if i == 0 or bumpers[i - 1] == '>':\n                count += 1\n        elif bumpers[i] == '>':\n            if i == n - 1 or bumpers[i + 1] == '<':\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 406,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    l = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                for m in range(k, n):\n                    if l[i] == l[j] and l[k] == l[m] and l[i] <= l[j] <= l[k] <= l[m]:\n                        area = l[i] * l[k]\n                        max_area = max(max_area, area)\n\n    return str(max_area)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 407,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    numbers = []\n    for _ in range(n):\n        number = stdin.readline().strip()\n        for i in range(len(number)):\n            number = number.replace(chr(97 + i), str(i))\n        numbers.append(int(number))\n    return str(sum(numbers))",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 408,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_teams = min(n, m)\n    return str(max_teams)",
        "test": "",
        "num_ids": 39,
        "indeed": false
    },
    {
        "number": 409,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if \"AB\" in s and \"BA\" in s:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 38,
        "indeed": false
    },
    {
        "number": 410,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_eating_order(a, b):\n        eating_order = []\n        queue = [(w, i) for i, w in enumerate(a, start=1)]\n\n        for i, w in enumerate(b, start=1):\n            while queue and queue[0][0] < w:\n                weight, index = queue.pop(0)\n                eating_order.append((index, \"L\" if queue else \"R\"))\n                w += weight\n            if not queue:\n                return None\n            queue.pop(0)\n\n        return eating_order\n\n    n, a, k, b = (list(map(int, line.split())) for line in stdin.splitlines())\n    eating_order = find_eating_order(a, b)\n\n    if eating_order:\n        return \"YES\\n\" + \"\\n\".join(f\"{index} {action}\" for index, action in eating_order)\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 411,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_collinear(p1, p2, p3):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0\n\n    def is_valid_matching(rebels, bases):\n        for i in range(len(rebels)):\n            for j in range(i + 1, len(rebels)):\n                if is_collinear(rebels[i], rebels[j], bases[i]) or is_collinear(rebels[i], rebels[j], bases[j]):\n                    return False\n        return True\n\n    R, B = map(int, stdin.readline().split())\n    rebels = [tuple(map(int, stdin.readline().split())) for _ in range(R)]\n    bases = [tuple(map(int, stdin.readline().split())) for _ in range(B)]\n\n    if is_valid_matching(rebels, bases):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 288,
        "indeed": false
    },
    {
        "number": 413,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n\n    while n != m:\n        if n > m:\n            if n % 2 == 0:\n                n //= 2\n                count += 1\n            else:\n                n -= 1\n                count += 1\n        else:\n            n += 1\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 414,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersecting(a, b, c, d):\n        if a <= c <= b or a <= d <= b:\n            return True\n        return False\n\n    def is_inside(a, b, c, d):\n        if a <= c and d <= b:\n            return True\n        return False\n\n    def is_tree(segments):\n        n = len(segments)\n        adj = [[] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if not is_intersecting(segments[i][0], segments[i][1], segments[j][0], segments[j][1]):\n                    continue\n                if is_inside(segments[i][0], segments[i][1], segments[j][0], segments[j][1]):\n                    continue\n                adj[i].append(j)\n                adj[j].append(i)\n\n        visited = [False] * n\n        stack = [(0, -1)]\n\n        while stack:\n            curr, parent = stack.pop()\n            if visited[curr]:\n                continue\n            visited[curr] = True\n            for neighbor in adj[curr]:\n                if neighbor == parent:\n                    continue\n                stack.append((neighbor, curr))\n\n        return all(visited)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    segments = [list(map(int, lines[i + 1].split())) for i in range(n)]\n\n    if is_tree(segments):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 401,
        "indeed": false
    },
    {
        "number": 415,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, requests = map(int, stdin.split())\n    requests = list(map(int, requests))\n    max_length = 0\n    current_length = 0\n    total_requests = 0\n\n    for i in range(n):\n        total_requests += requests[i]\n        if total_requests > 100 * (i + 1):\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n            total_requests = 0\n\n    return str(max_length)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 416,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    memories = list(stdin.strip().split()[-1])\n\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for memory in memories:\n        if memory == \"N\":\n            current_dissatisfaction += 1\n        else:\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n            current_dissatisfaction = 0\n\n    max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n\n    if max_dissatisfaction == k:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 417,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, D = map(int, stdin.split())\n    A = [X + i * D for i in range(N)]\n    S_values = set()\n\n    for i in range(2 ** N):\n        takahashi = []\n        aoki = []\n        for j in range(N):\n            if i & (1 << j):\n                takahashi.append(A[j])\n            else:\n                aoki.append(A[j])\n        S_values.add(sum(takahashi) - sum(aoki))\n\n    return str(len(S_values))",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 418,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    participants = stdin.split('\\n')[1:]\n\n    def get_color(rating: int) -> str:\n        if rating >= 2400:\n            return 'red'\n        elif rating >= 2200:\n            return 'orange'\n        elif rating >= 2000:\n            return 'green'\n        elif rating >= 1600:\n            return 'blue'\n        elif rating >= 1200:\n            return 'cyan'\n        elif rating >= 800:\n            return 'magenta'\n        else:\n            return 'gray'\n\n    def is_good_performance(participant: str) -> bool:\n        name, before, after = participant.split()\n        before = int(before)\n        after = int(after)\n        if get_color(before) == 'red' and after > before:\n            return True\n        return False\n\n    good_performances = sum(is_good_performance(participant) for participant in participants)\n\n    if good_performances > 0:\n        return 'YES'\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 288,
        "indeed": true
    },
    {
        "number": 419,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = int(stdin, 2)\n    count = 0\n    for i in range(100):\n        if 4**i <= s:\n            count += 1\n        else:\n            break\n    return str(count)",
        "test": "",
        "num_ids": 60,
        "indeed": false
    },
    {
        "number": 420,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_mirror(a, b):\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] != b[i][j]:\n                    return False\n        return True\n\n    def find_min_rows(a):\n        for i in range(1, n):\n            if is_mirror(a, a[i:] + a[:i]):\n                return i\n        return n\n\n    return str(find_min_rows(a))",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 421,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    orders = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    orders.sort(key=lambda x: x[1])\n\n    accepted_orders = []\n    for order in orders:\n        if not accepted_orders or order[0] >= accepted_orders[-1][1]:\n            accepted_orders.append(order)\n\n    return str(len(accepted_orders))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 422,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n\n    for i in range(n):\n        if x[i] > k or y[i] > k:\n            return \"NO\"\n\n        if i > 0:\n            if x[i] + x[i - 1] > k or y[i] + y[i - 1] > k:\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 423,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    coefficients = list(map(int, stdin.split()[2:]))\n\n    def is_divisible(coefficients: list, k: int) -> bool:\n        polynomial = sum([[coefficients[i], [1, 0]] if coefficients[i] != '?' else [[1, 0], [1, 0]] for i in range(len(coefficients))])\n        return polynomial[0][0] % k == 0 and polynomial[0][1] % k == 0 and polynomial[1][0] % k == 0 and polynomial[1][1] % k == 0\n\n    if '?' in coefficients:\n        return \"Yes\" if is_divisible(coefficients, k) else \"No\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 424,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X_2 = int(stdin)\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def next_turn(X_i):\n        primes = [p for p in range(2, X_i - 1) if is_prime(p)]\n        for p in primes:\n            if p > X_i - 1:\n                return X_i\n            if X_i % p == 0:\n                return X_i\n            else:\n                X_i += p - (X_i % p)\n        return X_i\n\n    X_0 = 3\n    X_1 = next_turn(X_0)\n    while X_1 < X_2:\n        X_0 += 1\n        X_1 = next_turn(X_0)\n\n    return str(X_0)",
        "test": "",
        "num_ids": 248,
        "indeed": false
    },
    {
        "number": 425,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n\n    def is_power_of_two(x: int) -> bool:\n        return x != 0 and (x & (x - 1)) == 0\n\n    def p_binary_representation(x: int) -> int:\n        return 2 ** x + p\n\n    if n == 0:\n        return \"0\"\n    if n == 1 and p == 0:\n        return \"-1\"\n    if n == abs(p) and is_power_of_two(n):\n        return \"1\"\n    if p == 0:\n        return str(bin(n).count('1'))\n    else:\n        result = float('inf')\n        for i in range(31):\n            if p_binary_representation(i) > n:\n                break\n            else:\n                result = min(result, i + 1)\n        return str(result) if result != float('inf') else \"-1\"",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 426,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    # If there are no digits to change, the result is the original number\n    if k == 0:\n        return s\n\n    # If the number is already minimal, the result is the same\n    if s == '1' * n:\n        return s\n\n    # If the number is not minimal, we can change the rightmost digit to make it minimal\n    return s[:-1] + str(int(s[-1]) - 1)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 427,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, x, y = map(int, stdin.split())\n\n    v = 1\n    while True:\n        numbers = set(range(1, v + 1))\n        for num in numbers.copy():\n            if num % x == 0 or num % y == 0:\n                numbers.remove(num)\n\n        if len(numbers) >= cnt_1 + cnt_2:\n            return str(v)\n        v += 1\n",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 428,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sx, sy, dx, dy, t = map(int, stdin.split())\n\n    for _ in range(t):\n        # Eat raspberry\n        k = dx + dy\n        dx += k\n        dy += k\n\n        # Move to next cell\n        sx = ((sx + dx - 1) % n) + 1\n        sy = ((sy + dy - 1) % n) + 1\n\n        # New raspberry bush grows\n        n += 1\n\n    return f\"{sx} {sy}\"",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 429,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 26:\n        return \"-1\"\n\n    stdin = stdin.replace(\"?\", \"A\")\n    missing_letters = 26 - len(stdin)\n\n    if missing_letters > 0:\n        for i in range(missing_letters):\n            stdin = stdin[:i] + chr(ord(\"A\") + i) + stdin[i:]\n\n    for i in range(len(stdin) - 25):\n        substring = stdin[i:i + 26]\n        if all(substring.count(chr(ord(\"A\") + j)) == 1 for j in range(26)):\n            return stdin\n\n    return \"-1\"",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 430,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    apples = [int(x) for x in stdin.split('\\n')[1].split()]\n    total_weight = sum(apples)\n    half_weight = total_weight // 2\n\n    current_weight = 0\n    for i in range(n):\n        current_weight += apples[i]\n        if current_weight == half_weight:\n            return \"YES\"\n        elif current_weight > half_weight:\n            break\n\n    return \"NO\"",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 431,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    building = []\n    for i in range(n):\n        building.append(list(stdin.readline().strip()))\n\n    def find_next_room(floor, room):\n        if floor < n - 1:\n            if building[floor + 1][room] == '1':\n                return floor + 1, room\n        if room < m - 1:\n            if building[floor][room + 1] == '1':\n                return floor, room + 1\n        if room > 0:\n            if building[floor][room - 1] == '1':\n                return floor, room - 1\n        return None\n\n    def find_next_stairs(floor, room):\n        if room == 0:\n            if building[floor][room + 1] == '1':\n                return floor, room + 1\n        elif room == m + 1:\n            if building[floor][room - 1] == '1':\n                return floor, room - 1\n        else:\n            if building[floor][room - 1] == '1':\n                return floor, room - 1\n            if building[floor][room + 1] == '1':\n                return floor, room + 1\n        return None\n\n    total_time = 0\n    current_floor = 0\n    current_room = 1\n    while current_floor < n:\n        if building[current_floor][current_room] == '1':\n            total_time += 1\n            building[current_floor][current_room] = '0'\n        next_room = find_next_room(current_floor, current_room)\n        if next_room:\n            current_floor, current_room = next_room\n        else:\n            next_stairs = find_next_stairs(current_floor, current_room)\n            if next_stairs:\n                current_floor, current_room = next_stairs\n            else:\n                current_floor += 1\n                current_room = 1\n\n    return str(total_time)",
        "test": "",
        "num_ids": 504,
        "indeed": false
    },
    {
        "number": 432,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n    a = list(map(int, stdin.split('\\n')[2].split()))\n\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == j:\n                continue\n            dp[j] = min(dp[j], dp[i] + c[i - 1])\n            if a[i - 1] == j:\n                break\n\n    return str(min(dp[1:]))",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 433,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if b == 0:\n        return a\n    if b > 0:\n        return (a + b - 1) % n + 1\n    else:\n        return (a - b) % n + 1",
        "test": "",
        "num_ids": 71,
        "indeed": false
    },
    {
        "number": 434,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_arithmetic_progression(arr):\n        diff = arr[1] - arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] - arr[i - 1] != diff:\n                return False\n        return True\n\n    def find_arithmetic_progressions(arr):\n        progressions = []\n        i = 0\n        while i < len(arr):\n            if arr[i] != -1:\n                prog = [arr[i]]\n                j = i + 1\n                while j < len(arr) and arr[j] != -1:\n                    if arr[j] - arr[j - 1] == prog[-1] - prog[-2]:\n                        prog.append(arr[j])\n                    else:\n                        break\n                    j += 1\n                if len(prog) > 1:\n                    progressions.append(prog)\n                i = j\n            else:\n                i += 1\n        return progressions\n\n    def merge_progressions(progressions):\n        merged = []\n        for prog in progressions:\n            if not merged or prog[0] - merged[-1][-1] != merged[-1][1] - merged[-1][0]:\n                merged.append(prog)\n            else:\n                merged[-1].extend(prog[1:])\n        return merged\n\n    def count_unknowns(arr):\n        return arr.count(-1)\n\n    unknowns = count_unknowns(a)\n    progressions = find_arithmetic_progressions(a)\n    merged_progressions = merge_progressions(progressions)\n\n    if not merged_progressions:\n        return 1\n\n    min_progressions = len(merged_progressions)\n    for i in range(len(merged_progressions)):\n        for j in range(i + 1, len(merged_progressions)):\n            if is_arithmetic_progression(merged_progressions[i] + merged_progressions[j]):\n                min_progressions = min(min_progressions, len(merged_progressions[:i]) + len(merged_progressions[i:j]) + len(merged_progressions[j:]))\n\n    return min_progressions + unknowns",
        "test": "",
        "num_ids": 587,
        "indeed": false
    },
    {
        "number": 435,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s.count(s[i]) + s.count(s[j]) - (j - i + 1) <= k:\n                max_beauty = max(max_beauty, j - i + 1)\n\n    return max_beauty\n\nn, k = map(int, input().split())\ns = input()\nprint(solution(f\"{n} {k}\\n{s}\")) ",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 436,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Check if Alice's party has a strict majority\n    total_seats = sum(a)\n    alice_seats = a[0]\n    if alice_seats <= total_seats // 2:\n        return \"0\"\n\n    # Check if Alice's party has at least 2 times more seats than any other party\n    max_other_seats = max(a[1:])\n    if alice_seats <= 2 * max_other_seats:\n        return \"0\"\n\n    # Find the coalition\n    coalition = [1]\n    for i in range(1, n):\n        if a[i] > 2 * max_other_seats:\n            coalition.append(i + 1)\n\n    # Print the coalition\n    output = [str(len(coalition))] + [str(c) for c in coalition]\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 437,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_prize = 0\n    for i in range(1, n + 1):\n        max_prize += i / n\n    return f\"{max_prize:.10f}\"",
        "test": "",
        "num_ids": 64,
        "indeed": false
    },
    {
        "number": 438,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 1\n    candies = [1]\n    while sum(candies) < n:\n        k += 1\n        candies = [i for i in range(1, k + 1)]\n    return f\"{k}\\n{' '.join(map(str, candies))}\"",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 439,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    while m % 2**n != m:\n        m += 1\n    return str(m % 2**n)",
        "test": "",
        "num_ids": 46,
        "indeed": false
    },
    {
        "number": 440,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n            i -= 1\n        i += 1\n    return s",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 441,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seats = list(input())\n\n    empty_seats = [i for i in range(n) if seats[i] == \".\"]\n    jury_seats = [i for i in range(n) if seats[i] == \"*\"]\n\n    def is_valid(arrangement: List[int]) -> bool:\n        for i in range(1, len(arrangement)):\n            if abs(arrangement[i] - arrangement[i - 1]) == 1:\n                return False\n        return True\n\n    def count_students(start: int, student_type: int) -> int:\n        if student_type == 0:\n            return min(a, len(empty_seats) - start)\n        else:\n            return min(b, len(empty_seats) - start)\n\n    def backtrack(start: int, student_type: int, current_count: int, max_count: int) -> int:\n        if current_count > max_count:\n            max_count = current_count\n\n        if start >= len(empty_seats):\n            return max_count\n\n        next_student_type = (student_type + 1) % 2\n        count = count_students(start, next_student_type)\n\n        for i in range(start, start + count):\n            arrangement = [empty_seats[j] for j in range(len(empty_seats)) if (j < i and j >= i - 1) or (j > i and j <= i + 1)]\n            if is_valid(arrangement):\n                max_count = backtrack(i + 1, next_student_type, current_count + 1, max_count)\n\n        return max_count\n\n    return str(backtrack(0, 0, 0, 0))",
        "test": "",
        "num_ids": 453,
        "indeed": false
    },
    {
        "number": 442,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin.strip())\n    x = 0\n    y = 0\n    found = False\n\n    while x <= r:\n        y = r - (x ** 2) - x\n        if y >= 0 and (y // 2) ** 2 == y:\n            found = True\n            break\n        x += 1\n\n    if found:\n        return f\"{x} {int(y // 2)}\\n\"\n    else:\n        return \"NO\\n\"",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 443,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_packets(packets, total_balloons, index, current_balloons, result):\n        if index == len(packets) and current_balloons != total_balloons:\n            return False\n        if current_balloons == total_balloons:\n            return True\n        if index == len(packets):\n            return False\n        for i in range(index, len(packets)):\n            if i > index and packets[i] == packets[i - 1]:\n                continue\n            if find_packets(packets, total_balloons, i + 1, current_balloons + packets[i], result):\n                result.append(i)\n                return True\n        return False\n\n    n = int(stdin.split('\\n')[0])\n    packets = list(map(int, stdin.split('\\n')[1].split()))\n    total_balloons = sum(packets)\n\n    if n < 2 or total_balloons % 2 != 0:\n        return \"-1\"\n\n    half_balloons = total_balloons // 2\n    result = []\n    if find_packets(packets, half_balloons, 0, 0, result):\n        return f\"{len(result)}\\n{' '.join(map(str, result))}\"\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 444,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 1\n    digits = [9]\n\n    while sum(digits) < n:\n        k += 1\n        digits = [9] * k\n\n    if sum(digits) > n:\n        k -= 1\n        digits = [9] * k\n\n    return f\"{k}\\n{' '.join(map(str, digits))}\"",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 445,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_simple(subset):\n        for i in range(len(subset)):\n            for j in range(i + 1, len(subset)):\n                if not is_prime(subset[i] + subset[j]):\n                    return False\n        return True\n\n    def find_max_simple_subset(a):\n        max_size = 0\n        max_subset = []\n        for i in range(1, len(a) + 1):\n            for subset in itertools.combinations(a, i):\n                if is_simple(subset):\n                    if len(subset) > max_size:\n                        max_size = len(subset)\n                        max_subset = subset\n        return max_size, max_subset\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_size, max_subset = find_max_simple_subset(a)\n\n    return f\"{max_size}\\n{' '.join(map(str, max_subset))}\"",
        "test": "",
        "num_ids": 319,
        "indeed": false
    },
    {
        "number": 446,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 1\n    while (2 ** (2 * k) - 1) * (2 ** (2 * k) - 1) <= n:\n        k += 1\n    return str(2 ** (2 * (k - 1)) - 1)",
        "test": "",
        "num_ids": 73,
        "indeed": false
    },
    {
        "number": 447,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split()[0].split())\n    a, b = map(int, stdin.split()[1:])\n\n    def is_d_magic(number: int, d: int) -> bool:\n        decimal = str(number)\n        for i, digit in enumerate(decimal):\n            if i % 2 == 0 and digit != str(d):\n                return False\n            if i % 2 == 1 and digit == str(d):\n                return False\n        return True\n\n    def count_magic_numbers(a: int, b: int, d: int, m: int) -> int:\n        count = 0\n        for number in range(a, b + 1):\n            if number % m == 0 and is_d_magic(number, d):\n                count += 1\n        return count\n\n    result = count_magic_numbers(a, b, d, m)\n    return result % (10**9 + 7)\n",
        "test": "",
        "num_ids": 244,
        "indeed": false
    },
    {
        "number": 448,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    line = [i for i in range(1, n + 1)]\n    last_child = 0\n\n    while line:\n        child = line.pop(0)\n        if a[child - 1] <= m:\n            a[child - 1] += m\n            line.append(child)\n        else:\n            last_child = child\n\n    return str(last_child)",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 449,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bills = [1, 5, 10, 20, 100]\n    count = 0\n\n    for bill in bills[::-1]:\n        count += n // bill\n        n %= bill\n\n    return str(count)",
        "test": "",
        "num_ids": 76,
        "indeed": true
    },
    {
        "number": 450,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if k == 0:\n        return \"1\"\n\n    if n == 1:\n        return \"0\"\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n\n    return str(dp[k])\n",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 451,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    b = list(map(int, stdin.split('\\n')[1].split()))\n    c = stdin.split('\\n')[2]\n\n    def is_valid(roses: list) -> bool:\n        colors = set([c[i] for i in roses])\n        if len(colors) == 1:\n            return False\n        if 'R' in colors and 'W' in colors:\n            return False\n        return True\n\n    def total_beauty(roses: list) -> int:\n        return sum([b[i] for i in roses])\n\n    def dfs(start: int, k: int, current: list) -> int:\n        if k == 0:\n            if is_valid(current):\n                return total_beauty(current)\n            else:\n                return -1\n\n        if start == n:\n            return -1\n\n        max_beauty = -1\n        for i in range(start, n):\n            if i > 0 and c[i] == c[i - 1]:\n                continue\n            current.append(i)\n            max_beauty = max(max_beauty, dfs(i + 1, k - 1, current))\n            current.pop()\n\n        return max_beauty\n\n    max_beauty = dfs(0, k, [])\n    return str(max_beauty)",
        "test": "",
        "num_ids": 359,
        "indeed": false
    },
    {
        "number": 452,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q, n, a = map(int, stdin.split())\n    numerator = p\n    denominator = q\n    for i in range(n):\n        numerator += denominator * a[i]\n        numerator, denominator = denominator, numerator\n    if numerator == p and denominator == q:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 453,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(len, stdin.split('='))\n    if A + B == C:\n        return stdin\n    if A + B > C:\n        return \"Impossible\"\n    if A + B < C:\n        if A > 0 and B > 0:\n            return stdin.replace('|', '', 1) + '|'\n        elif A > 0:\n            return stdin.replace('|', '', 1) + '|' + '='\n        elif B > 0:\n            return '|' + stdin.replace('|', '', 1) + '|' + '='\n    return \"Impossible\"",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 454,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j + 1] + dp[i - 1][j - 1]) % mod\n\n    return str(dp[n][k])",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 455,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_mode(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return \"D\"\n        if x1 == x2 and y1 < y2:\n            return \"U\"\n        if x1 < x2 and y1 == y2:\n            return \"R\"\n        if x1 > x2 and y1 == y2:\n            return \"L\"\n        return None\n\n    def find_robot_arm(points):\n        m = len(points)\n        d = [0] * (m + 1)\n        w = [\"\"] * len(points)\n\n        for i in range(m):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % m]\n            mode = find_mode(x1, y1, x2, y2)\n            if mode is None:\n                return None\n            d[i + 1] = abs(x2 - x1) if mode in [\"L\", \"R\"] else abs(y2 - y1)\n            w[i] += mode\n\n        return m, d, w\n\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = find_robot_arm(points)\n\n    if result is None:\n        return \"-1\"\n    else:\n        m, d, w = result\n        return \"\\n\".join(map(str, [m, *d, *w]))",
        "test": "",
        "num_ids": 368,
        "indeed": false
    },
    {
        "number": 456,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    def is_filler(word: str) -> bool:\n        if len(word) < 3:\n            return False\n        if word[:3] != 'ogo':\n            return False\n        for i in range(3, len(word)):\n            if word[i] != 'g':\n                return False\n        return True\n\n    result = ''\n    i = 0\n    while i < n:\n        if is_filler(s[i:i+3]):\n            result += '***'\n            i += 3\n        else:\n            result += s[i]\n            i += 1\n\n    return result",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 457,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, n = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def prime(x):\n        primes = set()\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                primes.add(i)\n                primes.add(x // i)\n        if x > 1:\n            primes.add(x)\n        return primes\n\n    def g(x, p):\n        k = 0\n        while x % (p**(k + 1)) == 0:\n            k += 1\n        return p**k\n\n    def f(x, y):\n        result = 1\n        for p in prime(x):\n            result *= g(y, p)\n            result %= mod\n        return result\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n        result %= mod\n\n    return str(result)",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 458,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    solutions = []\n\n    def s(x: int) -> int:\n        return sum(int(digit) for digit in str(x))\n\n    x = 1\n    while x < 10**9:\n        if x == b * s(x) ** a + c:\n            solutions.append(x)\n        x += 1\n\n    if not solutions:\n        return \"0\\n\"\n    else:\n        output = f\"{len(solutions)}\\n\"\n        output += \" \".join(str(solution) for solution in solutions) + \"\\n\"\n        return output",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 459,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = list(map(int, stdin.split()))\n    if len(colors) != 24:\n        return \"NO\"\n\n    def rotate_face(face_index: int, direction: int) -> None:\n        if face_index == 0:\n            if direction == 1:\n                colors[0], colors[1], colors[2], colors[3], colors[4], colors[5], colors[6], colors[7], colors[8] = colors[4], colors[1], colors[2], colors[3], colors[0], colors[7], colors[6], colors[5], colors[8]\n            else:\n                colors[0], colors[1], colors[2], colors[3], colors[4], colors[5], colors[6], colors[7], colors[8] = colors[8], colors[5], colors[6], colors[7], colors[4], colors[3], colors[2], colors[1], colors[0]\n        elif face_index == 1:\n            if direction == 1:\n                colors[9], colors[10], colors[11], colors[12], colors[13], colors[14], colors[15], colors[16], colors[17] = colors[13], colors[10], colors[11], colors[12], colors[17], colors[14], colors[15], colors[16], colors[9]\n            else:\n                colors[9], colors[10], colors[11], colors[12], colors[13], colors[14], colors[15], colors[16], colors[17] = colors[9], colors[16], colors[15], colors[14], colors[13], colors[12], colors[11], colors[10], colors[17]\n        elif face_index == 2:\n            if direction == 1:\n                colors[18], colors[19], colors[20], colors[21], colors[22], colors[23], colors[0], colors[3], colors[6] = colors[0], colors[18], colors[19], colors[20], colors[21], colors[22], colors[23], colors[6], colors[3]\n            else:\n                colors[18], colors[19], colors[20], colors[21], colors[22], colors[23], colors[0], colors[3], colors[6] = colors[18], colors[19], colors[20], colors[21], colors[22], colors[23], colors[0], colors[3], colors[6]\n        elif face_index == 3:\n            if direction == 1:\n                colors[24], colors[25], colors[26], colors[27], colors[28], colors[29], colors[12], colors[15], colors[18] = colors[12], colors[24], colors[25], colors[26], colors[27], colors[28], colors[29], colors[18], colors[15]\n            else:\n                colors[24], colors[25], colors[26], colors[27], colors[28], colors[29], colors[12], colors[15], colors[18] = colors[24], colors[25], colors[26], colors[27], colors[28], colors[29], colors[12], colors[15], colors[18]\n        elif face_index == 4:\n            if direction == 1:\n                colors[17], colors[20], colors[23], colors[26], colors[29], colors[32], colors[16], colors[19], colors[22] = colors[16], colors[17], colors[20], colors[23], colors[26], colors[29], colors[32], colors[22], colors[19]\n            else:\n                colors[17], colors[20], colors[23], colors[26], colors[29], colors[32], colors[16], colors[19], colors[22] = colors[17], colors[20], colors[23], colors[26], colors[29], colors[",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 460,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x, y = map(int, stdin.split())\n\n    def generate_tshirt_numbers(s: int) -> List[int]:\n        i = s // 50 % 475\n        tshirt_numbers = []\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            tshirt_numbers.append(26 + i)\n        return tshirt_numbers\n\n    tshirt_numbers = generate_tshirt_numbers(x)\n    if p in tshirt_numbers:\n        return \"0\"\n\n    def binary_search(left: int, right: int) -> int:\n        while left <= right:\n            mid = (left + right) // 2\n            tshirt_numbers = generate_tshirt_numbers(x + mid * 100)\n            if p in tshirt_numbers:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    return str(binary_search(0, (y - x) // 100))",
        "test": "",
        "num_ids": 272,
        "indeed": false
    },
    {
        "number": 461,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n\n    if n == 1:\n        return str(0)\n    elif n == 2:\n        return str(min(a, b))\n    else:\n        return str(min(a + c, b))",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 462,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, x2, x3 = map(int, stdin.split())\n    distances = sorted([abs(x1 - x2), abs(x2 - x3), abs(x1 - x3)])\n    return str(distances[0] + distances[1]) ",
        "test": "",
        "num_ids": 68,
        "indeed": true
    },
    {
        "number": 463,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n):\n        if arr[i] & x in arr[:i] + arr[i + 1:]:\n            count += 1\n\n    return str(count) if count > 0 else \"-1\"",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 464,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.readline().split())\n    picture = [list(stdin.readline().strip()) for _ in range(h)]\n\n    def is_valid_plus(x, y):\n        if picture[x][y] != '*':\n            return False\n\n        for i in range(x - 1, -1, -1):\n            if picture[i][y] == '.':\n                break\n            if i == 0 or picture[i - 1][y] == '.':\n                return False\n\n        for i in range(x + 1, h):\n            if picture[i][y] == '.':\n                break\n            if i == h - 1 or picture[i + 1][y] == '.':\n                return False\n\n        for j in range(y - 1, -1, -1):\n            if picture[x][j] == '.':\n                break\n            if j == 0 or picture[x][j - 1] == '.':\n                return False\n\n        for j in range(y + 1, w):\n            if picture[x][j] == '.':\n                break\n            if j == w - 1 or picture[x][j + 1] == '.':\n                return False\n\n        return True\n\n    plus_count = 0\n    for i in range(h):\n        for j in range(w):\n            if is_valid_plus(i, j):\n                plus_count += 1\n                if plus_count > 1:\n                    return \"NO\"\n\n    return \"YES\" if plus_count == 1 else \"NO\"",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 465,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n\n    if a > n or b > n:\n        return \"NO\"\n\n    def is_valid(matrix):\n        components = [set() for _ in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                if matrix[i][j] == 1:\n                    components[i].add(j)\n                    components[j].add(i)\n\n        visited = set()\n        for component in components:\n            if not component:\n                continue\n            if component & visited:\n                return False\n            visited |= component\n\n        return True\n\n    def complement(matrix):\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j] = 1 - matrix[i][j]\n                matrix[j][i] = 1 - matrix[j][i]\n\n    def count_components(matrix):\n        components = []\n        visited = set()\n        for i in range(n):\n            if i in visited:\n                continue\n            component = set()\n            queue = [i]\n            while queue:\n                vertex = queue.pop(0)\n                if vertex in visited:\n                    continue\n                visited.add(vertex)\n                component.add(vertex)\n                for j in range(n):\n                    if matrix[vertex][j] == 1:\n                        queue.append(j)\n            components.append(component)\n\n        return len(components)\n\n    def find_matrix(a, b):\n        matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a > 0 and b > 0:\n                    matrix[i][j] = 1\n                    a -= 1\n                    b -= 1\n                elif a > 0:\n                    matrix[i][j] = 1\n                    a -= 1\n                elif b > 0:\n                    matrix[i][j] = 1\n                    b -= 1\n\n        if not is_valid(matrix):\n            return None\n\n        complement(matrix)\n        if count_components(matrix) != a:\n            return None\n\n        return matrix\n\n    matrix = find_matrix(a, b)\n    if matrix is None:\n        return \"NO\"\n\n    output = [\"YES\"]\n    for row in matrix:\n        output.append(\"\".join(map(str, row)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 624,
        "indeed": false
    },
    {
        "number": 466,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, d = map(int, stdin.split()[0].split())\n    n, m = map(int, stdin.split()[1].split())\n    k = int(stdin.split()[2])\n\n    min_problems = c * n + d * m + k\n\n    return str(min_problems)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 467,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if len(s) != 27:\n        return \"Impossible\"\n\n    def is_valid_grid(grid: List[str]) -> bool:\n        for row in grid:\n            if not all(c.isupper() and c.isalpha() for c in row):\n                return False\n        return True\n\n    def find_path(grid: List[str], path: str) -> bool:\n        if not path:\n            return True\n        for i in range(2):\n            for j in range(13):\n                if grid[i][j] == path[0]:\n                    if (i > 0 and grid[i - 1][j] == path[1]) or (j > 0 and grid[i][j - 1] == path[1]) or (i < 1 and grid[i + 1][j] == path[1]) or (j < 12 and grid[i][j + 1] == path[1]):\n                        new_grid = [row[:j] + row[j + 1:] for row in grid]\n                        if find_path(new_grid, path[1:]):\n                            return True\n        return False\n\n    def generate_grid(s: str) -> List[str]:\n        s = list(s)\n        grid = [[''] * 13 for _ in range(2)]\n        for i in range(2):\n            for j in range(13):\n                if not s:\n                    return grid\n                grid[i][j] = s.pop(0)\n        return grid\n\n    def print_grid(grid: List[str]) -> str:\n        return '\\n'.join([''.join(row) for row in grid])\n\n    s = sorted(s)\n    grid = generate_grid(s)\n    if not is_valid_grid(grid):\n        return \"Impossible\"\n    if find_path(grid, s):\n        return print_grid(grid)\n    else:\n        return \"Impossible\" ",
        "test": "",
        "num_ids": 483,
        "indeed": false
    },
    {
        "number": 468,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 1 or y == 1:\n        if x == y:\n            return '='\n        elif x < y:\n            return '<'\n        else:\n            return '>'\n    else:\n        x_pow_y = x ** y\n        y_pow_x = y ** x\n        if x_pow_y < y_pow_x:\n            return '<'\n        elif x_pow_y > y_pow_x:\n            return '>'\n        else:\n            return '='",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 469,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, h = map(int, stdin.split())\n    balloon_radius = r / 2\n    max_balloons = 0\n\n    # Calculate maximum balloons for each row\n    for i in range(1, h + 1):\n        balloons_in_row = int(2 * (h - i + 1) * balloon_radius)\n        max_balloons += balloons_in_row\n\n    return str(max_balloons)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 470,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    cards = sorted(list(map(int, stdin.split())), reverse=True)\n    min_sum = sum(cards)\n\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] == cards[j]:\n                continue\n            new_sum = sum(cards[:i] + cards[i + 1:j] + cards[j + 1:])\n            if new_sum < min_sum:\n                min_sum = new_sum\n\n    return str(min_sum)",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 471,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    x = list(map(int, input().split()))\n\n    x.sort()\n    distance = 0\n    visited = 0\n    current_position = a\n\n    for checkpoint in x:\n        if visited >= n - 1:\n            break\n        if checkpoint >= current_position:\n            distance += checkpoint - current_position\n            current_position = checkpoint\n            visited += 1\n\n    return str(distance)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 472,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x = 1\n    while True:\n        digits_sum = sum(int(digit) for digit in str(x))\n        if x * x + digits_sum * x - n > 0:\n            return -1\n        elif x * x + digits_sum * x - n == 0:\n            return x\n        x += 1\n",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 473,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s_h, s_m = map(int, s.split(':'))\n    t_h, t_m = map(int, t.split(':'))\n\n    p_m = s_m - t_m\n    p_h = s_h - t_h\n\n    if p_m < 0:\n        p_m += 60\n        p_h -= 1\n\n    if p_h < 0:\n        p_h += 24\n\n    return f\"{p_h:02d}:{p_m:02d}\"",
        "test": "",
        "num_ids": 153,
        "indeed": true
    },
    {
        "number": 474,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_mean = float('-inf')\n    max_length = 1\n    current_sum = a[0]\n    current_length = 1\n\n    for i in range(1, n):\n        current_sum += a[i]\n        current_length += 1\n        mean = current_sum / current_length\n\n        if mean > max_mean:\n            max_mean = mean\n            max_length = current_length\n        elif mean == max_mean and current_length > max_length:\n            max_length = current_length\n\n    return str(max_length)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 475,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    MOD = 998244353\n\n    if k == 0:\n        return str(m)\n\n    dp = [0] * (n + 1)\n    dp[1] = m\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (m - 1) + dp[i - 1] - dp[i - 2]) % MOD\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 476,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    if n.startswith(\"1414\") or n.startswith(\"114\") or n.startswith(\"144\") or n.startswith(\"14144\"):\n        return \"YES\"\n    for i in range(len(n) - 3):\n        if n[i:i+3] in [\"141\", \"144\", \"1414\"]:\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 477,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, i, j, a, b = map(int, stdin.split())\n    corners = [(1, m), (n, 1), (n, m), (1, 1)]\n    visited = set()\n    queue = [(i, j, 0)]\n    while queue:\n        x, y, depth = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if (x, y) in corners:\n            return str(depth)\n        for move in [(x - a, y - b), (x + a, y - b), (x - a, y + b), (x + a, y + b)]:\n            if 1 <= move[0] <= n and 1 <= move[1] <= m:\n                queue.append((move[0], move[1], depth + 1))\n    return \"Poor Inna and pony!\"",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 478,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_valid_move(s: str, i: int) -> bool:\n        if i == 0:\n            return s[i + 1] == chr(ord(s[i]) - 1)\n        elif i == len(s) - 1:\n            return s[i - 1] == chr(ord(s[i]) - 1)\n        else:\n            return s[i - 1] == chr(ord(s[i]) - 1) or s[i + 1] == chr(ord(s[i]) - 1)\n\n    def remove_char(s: str, i: int) -> str:\n        return s[:i] + s[i + 1:]\n\n    max_removals = 0\n    for i in range(n):\n        if is_valid_move(s, i):\n            s = remove_char(s, i)\n            max_removals += 1\n\n    return str(max_removals)",
        "test": "",
        "num_ids": 264,
        "indeed": false
    },
    {
        "number": 479,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_bills(x, a, k):\n        dp = [0] * (x + 1)\n        for i in range(1, x + 1):\n            dp[i] = k + 1\n        for i in range(k, 0, -1):\n            for j in range(1, x + 1):\n                for denom in a:\n                    if denom <= j and dp[j - denom] + 1 < dp[j]:\n                        dp[j] = dp[j - denom] + 1\n        return dp[x] if dp[x] <= k else -1\n\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    q = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n\n    return \"\\n\".join(str(get_min_bills(x[i], a, k)) for i in range(q))",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 480,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x1, x2, t1, t2, p, d = map(int, stdin.split())\n\n    def time_to_reach(x):\n        if x <= p:\n            return (x - p) * t1 * d + t1\n        else:\n            return (x - p) * t1 * d + t1 + (p - x) * t1 * (-d) + t1\n\n    t1_p = time_to_reach(p)\n    t1_x1 = time_to_reach(x1)\n    t1_x2 = time_to_reach(x2)\n\n    if t1_x1 <= t1_x2:\n        return str(t1_x1 + (x2 - x1) // t2 + 1)\n    else:\n        return str(t1_x2 + (x1 - x2) // t2 + 1)",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 481,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * j == x:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 482,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return 'a' * n\n    elif k == 2 and n % 2 == 0:\n        return 'ab' * (n // 2)\n    else:\n        password = ['a'] * n\n        for i in range(1, n):\n            if password[i - 1] == 'z':\n                password[i] = 'a'\n            else:\n                password[i] = chr(ord(password[i - 1]) + 1)\n        return ''.join(password)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 483,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    directions = stdin.readline().strip()\n    positions = list(map(int, stdin.readline().strip().split()))\n\n    left_particles = [positions[i] for i in range(n) if directions[i] == \"L\"]\n    right_particles = [positions[i] for i in range(n) if directions[i] == \"R\"]\n\n    left_particles.sort()\n    right_particles.sort(reverse=True)\n\n    time = float('inf')\n\n    for i in range(len(left_particles)):\n        for j in range(len(right_particles)):\n            if left_particles[i] + right_particles[j] <= positions[n - 1]:\n                time = min(time, i + j)\n            else:\n                break\n\n    return str(time if time != float('inf') else -1)",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 484,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[0:3])\n    seals = [list(map(int, stdin.split()[i:i + 2])) for i in range(3, len(stdin.split()), 2)]\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            area = min(seals[i][0] * seals[i][1], seals[j][0] * seals[j][1])\n            if area > max_area:\n                max_area = area\n\n    return str(max_area)",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 485,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for _ in range(4 * n + 1):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    for point in points:\n        if point[0] in (0, 50) or point[1] in (0, 50):\n            continue\n        else:\n            return f\"{point[0]} {point[1]}\"\n",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 486,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_product = 0\n\n    for i in range(1, n + 1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n\n    return str(max_product)",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 487,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    votes = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_vote = max(votes)\n    total_votes = sum(votes)\n\n    if total_votes % 2 == 0:\n        return str(max_vote + 1)\n    else:\n        return str(max_vote)",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 488,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = list(stdin)\n    operations = 0\n\n    while True:\n        deleted = []\n        for i in range(1, len(points) - 1):\n            if points[i] != points[i - 1] and points[i] != points[i + 1]:\n                deleted.append(i)\n\n        if not deleted:\n            break\n\n        for i in reversed(deleted):\n            points.pop(i)\n\n        operations += 1\n\n    return str(operations)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 489,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    count = 0\n    for i in range(n - 2):\n        if a[i] == a[i + 1]:\n            count += 1\n        else:\n            break\n\n    return str(count)",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 490,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"2\"\n    else:\n        return str(solution(str(n - 1)) + n - 1)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 491,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 0:\n        n -= n % 10\n    return str(n)",
        "test": "",
        "num_ids": 34,
        "indeed": false
    },
    {
        "number": 492,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    start, end = stdin.split()\n    n = int(input())\n\n    if start == '^' and end == '>':\n        return 'cw' if n % 2 == 0 else 'ccw'\n    elif start == '<' and end == '^':\n        return 'cw' if n % 2 == 0 else 'ccw'\n    elif start == 'v' and end == '<':\n        return 'cw' if n % 2 == 0 else 'ccw'\n    elif start == '>' and end == 'v':\n        return 'cw' if n % 2 == 0 else 'ccw'\n    else:\n        return 'undefined'",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 493,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n\n    for i in range(n):\n        if s[i] == '.':\n            if i > 0 and i < n - 1:\n                if s[i - 1] == 'L' and s[i + 1] == 'R':\n                    s[i] = 'L'\n                elif s[i - 1] == 'R' and s[i + 1] == 'L':\n                    s[i] = 'R'\n\n    count = 0\n    for i in range(n):\n        if s[i] == '.':\n            count += 1\n        else:\n            if i > 0 and s[i - 1] == '.':\n                s[i - 1] = 'L' if s[i] == 'R' else 'R'\n            if i < n - 1 and s[i + 1] == '.':\n                s[i + 1] = 'L' if s[i] == 'R' else 'R'\n\n    return str(count)",
        "test": "",
        "num_ids": 273,
        "indeed": false
    },
    {
        "number": 494,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    l = list(map(int, stdin.split()[2:]))\n    a = [0] * n\n\n    for i in range(m):\n        a[l[i] - 1] = l[i] + l[(i + 1) % m] - l[i]\n\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = n\n\n    if sum(a) != (n * (n + 1)) // 2:\n        return -1\n\n    return \" \".join(map(str, a))\n",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 495,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = map(int, stdin.split())\n    a_str = str(a)\n    n = len(a_str)\n    max_num = a_str\n\n    for i in range(min(n - 1, k)):\n        max_num = max(max_num, ''.join([a_str[:i], a_str[i + 1], a_str[i], a_str[i + 2:]]))\n\n    return max_num",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 496,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    if a == b == c == d:\n        return \"42\"\n\n    if a == b == c or a == b or a == c or b == c:\n        return \"42\"\n\n    if a == b:\n        return \"42\"\n\n    if a == c:\n        return \"42\"\n\n    if a == d:\n        return \"42\"\n\n    if b == c:\n        return \"42\"\n\n    if b == d:\n        return \"42\"\n\n    if c == d:\n        return \"42\"\n\n    if a + (b - a) == c:\n        return str(a + (c - b))\n\n    if a * (b / a) == c:\n        return str(int(a * (c / b)))\n\n    return \"42\"\n",
        "test": "",
        "num_ids": 221,
        "indeed": false
    },
    {
        "number": 497,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors[i] != colors[j]:\n                max_distance = max(max_distance, j - i)\n\n    return str(max_distance)",
        "test": "",
        "num_ids": 107,
        "indeed": true
    },
    {
        "number": 498,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    lane = (k - 1) // (2 * m) + 1\n    desk = ((k - 1) % (2 * m)) // 2 + 1\n    side = \"L\" if ((k - 1) % 2) == 0 else \"R\"\n    return f\"{lane} {desk} {side}\"",
        "test": "",
        "num_ids": 101,
        "indeed": true
    },
    {
        "number": 499,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    red = s.count('R')\n    green = s.count('G')\n    blue = s.count('B')\n\n    if n == 1:\n        return s\n    elif n == 2:\n        if red == 1 and green == 1:\n            return 'B'\n        elif red == 2:\n            return 'G'\n        elif green == 2:\n            return 'R'\n        else:\n            return 'BGR'\n    else:\n        if red == 0:\n            return 'B'\n        elif green == 0:\n            return 'G'\n        elif blue == 0:\n            return 'R'\n        else:\n            return 'BGR'",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 500,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(positions: List[Tuple[int, int]]) -> bool:\n        for i in range(len(positions)):\n            for j in range(i + 1, len(positions)):\n                if positions[i] == positions[j]:\n                    return False\n                if positions[i][0] == positions[j][0] or positions[i][1] == positions[j][1]:\n                    if positions[i][0] != positions[j][0] and positions[i][1] != positions[j][1]:\n                        return False\n        return True\n\n    def dfs(graph: List[List[int]], visited: Set[int], positions: List[Tuple[int, int]], x: int, y: int) -> bool:\n        visited.add(x)\n        positions[x - 1] = (x, y)\n        for neighbor in graph[x - 1]:\n            if neighbor not in visited:\n                if not dfs(graph, visited, positions, neighbor, y + 1 if x == neighbor else y - 1):\n                    return False\n        return True\n\n    n, edges = int(stdin.readline().strip()), [tuple(map(int, line.split())) for line in stdin]\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v)\n        graph[v - 1].append(u)\n\n    if len(graph) != n or any(len(vertex) != n - 1 for vertex in graph):\n        return \"NO\"\n\n    positions = [(0, 0)] * n\n    if not dfs(graph, set(), positions, 1, 0):\n        return \"NO\"\n\n    if not is_valid(positions):\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, position)) for position in positions)",
        "test": "",
        "num_ids": 464,
        "indeed": false
    },
    {
        "number": 501,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    MOD = 1000000007\n\n    def sum_of_numbers(start, end, step):\n        return (step * (2 * end**2 - (start - 1) * 2 * end) // 4) % MOD\n\n    total_sum = 0\n    for i in range(1, r + 1):\n        if i >= l:\n            total_sum += i\n            total_sum %= MOD\n\n        if i % 2 == 1:\n            total_sum += sum_of_numbers(1, i, 2)\n            total_sum %= MOD\n        else:\n            total_sum += sum_of_numbers(2, i, 4)\n            total_sum %= MOD\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 502,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    # Check if the points are collinear\n    if (a_x * (b_y - c_y) + b_x * (c_y - a_y) + c_x * (a_y - b_y)) == 0:\n        return \"No\"\n\n    return \"Yes\"",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 503,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for l in range(j + 1, n):\n                if a[j] // a[i] == a[l] // a[j] == k:\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 504,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    creatures = []\n    for _ in range(n):\n        hp, dmg = map(int, input().split())\n        creatures.append((hp, dmg))\n    \n    creatures.sort(key=lambda x: x[1])\n    \n    total_damage = 0\n    for i in range(n):\n        hp, dmg = creatures[i]\n        if a > 0 and hp < dmg:\n            creatures[i] = (hp * 2, dmg)\n            a -= 1\n        if b > 0 and hp > dmg:\n            creatures[i] = (hp, hp)\n            b -= 1\n    \n    for _, dmg in creatures:\n        total_damage += dmg\n    \n    return str(total_damage)",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 505,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    maze = stdin.split('\\n')[1:]\n    initial_position = None\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == 'X':\n                initial_position = (i, j)\n                break\n        if initial_position:\n            break\n\n    def is_valid_move(x, y, direction):\n        if direction == 'L':\n            return y > 0 and maze[x][y - 1] != '*'\n        elif direction == 'R':\n            return y < m - 1 and maze[x][y + 1] != '*'\n        elif direction == 'U':\n            return x > 0 and maze[x - 1][y] != '*'\n        elif direction == 'D':\n            return x < n - 1 and maze[x + 1][y] != '*'\n\n    def find_cycle(position, direction, cycle, length):\n        if length == k:\n            if position == initial_position:\n                return cycle\n            else:\n                return None\n\n        for new_direction in 'LRU':\n            if new_direction != direction and is_valid_move(position[0], position[1], new_direction):\n                new_position = (position[0] + {'L': 0, 'R': 0, 'U': -1, 'D': 1}[new_direction],\n                                 position[1] + {'L': -1, 'R': 1, 'U': 0, 'D': 0}[new_direction])\n                result = find_cycle(new_position, new_direction, cycle + new_direction, length + 1)\n                if result:\n                    return result\n\n        return None\n\n    result = find_cycle(initial_position, None, '', 0)\n    return result if result else 'IMPOSSIBLE'",
        "test": "",
        "num_ids": 475,
        "indeed": false
    },
    {
        "number": 506,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    while a > b:\n        a -= b\n        count += 1\n    return str(count + 1)",
        "test": "",
        "num_ids": 50,
        "indeed": false
    },
    {
        "number": 507,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    p = [0] * n\n    for i in range(n):\n        if a[i] != b[i]:\n            p[i] = a[i]\n            p[i ^ 1] = b[i]\n            break\n\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = a[i]\n\n    return \" \".join(map(str, p))",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 508,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    v1, v2, v3 = 1, 2, 3\n    min_diff = abs(a - 60)\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                angle = abs(i * j + j * k + k * i)\n                diff = abs(angle - a)\n                if diff < min_diff:\n                    min_diff = diff\n                    v1, v2, v3 = i, j, k\n    return f\"{v1} {v2} {v3}\"",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 509,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rotations = [int(x) for x in stdin.split('\\n')[1:]]\n    total_rotation = sum(rotations) % 360\n    if total_rotation == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 510,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    def distance(x, y):\n        return abs(x - y)\n\n    def min_duration(a, b, c, d):\n        distances = sorted([distance(a, b), distance(b, c), distance(c, a)])\n        min_duration = 0\n\n        for i in range(3):\n            if distances[i] < d:\n                min_duration += d - distances[i]\n\n        return min_duration\n\n    return str(min_duration(a, b, c, d))",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 511,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def f(a, b):\n        if b == 0:\n            return 0\n        return 1 + f(a, b - gcd(a, b))\n    return f(x, y)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 512,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(A, B, C):\n        for i in range(len(A)):\n            if A[i] != -1 and B[i] != -1:\n                for j in range(i + 1, len(A)):\n                    if A[j] != -1 and B[j] != -1:\n                        if A[i] < A[j] < B[i] < B[j]:\n                            if C[i] != C[j]:\n                                return False\n        return True\n\n    N = int(stdin.readline().strip())\n    A = []\n    B = []\n    C = []\n\n    for _ in range(N):\n        a, b = map(int, stdin.readline().strip().split())\n        A.append(a)\n        B.append(b)\n        if a != -1 and b != -1:\n            C.append(b - a - 1)\n        else:\n            C.append(-1)\n\n    if is_valid(A, B, C):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 513,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(8):\n        x, y = map(int, stdin.splitlines()[i].split())\n        points.append((x, y))\n\n    points.sort()\n    x_1, y_1 = points[0]\n    x_2, y_2 = points[3]\n    x_3, y_3 = points[7]\n\n    if x_1 < x_2 < x_3 and y_1 < y_2 < y_3 and (x_2, y_2) not in points:\n        return \"respectable\"\n    else:\n        return \"ugly\"",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 514,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def ceil(a: float) -> int:\n        return int(a) + 1 if a - int(a) > 0 else int(a)\n\n    def can_fit(n: int, d: int) -> bool:\n        for x in range(n):\n            if x + ceil(d / (x + 1)) <= n:\n                return True\n        return False\n\n    T = int(stdin.split('\\n')[0])\n    test_cases = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    output = []\n    for n, d in test_cases:\n        if can_fit(n, d):\n            output.append('YES')\n        else:\n            output.append('NO')\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 199,
        "indeed": true
    },
    {
        "number": 515,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    n = 1\n    while True:\n        if k == 0:\n            return str(n)\n        n_str = str(n)\n        if len(n_str) > 10**18:\n            return str(-1)\n        loops = 0\n        for digit in n_str:\n            if digit == '4':\n                loops += 1\n            elif digit == '8':\n                loops += 2\n        if loops == k:\n            return str(n)\n        n += 1",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 516,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    k = 0\n    positions = []\n\n    for i in range(n):\n        if s[i] != t[i]:\n            k += 1\n            positions.append(i + 1)\n\n    return f\"{k}\\n{' '.join(map(str, positions))}\"\n",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 517,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, h = map(int, stdin.split())\n\n    if d == h:\n        return \"-1\"\n\n    # Generate the tree\n    tree = []\n    for i in range(1, n + 1):\n        if i == 1:\n            tree.append([2, 3])\n        elif i == n:\n            tree.append([i - 1])\n        else:\n            tree.append([i - 1, i + 1])\n\n    # Check if the tree satisfies the conditions\n    diameter = 0\n    height = 0\n    for i in range(1, n + 1):\n        if i == 1:\n            continue\n        dist = 0\n        visited = [False] * (n + 1)\n        queue = [i]\n        while queue:\n            curr = queue.pop(0)\n            if curr == 1:\n                dist += 1\n                break\n            if not visited[curr]:\n                visited[curr] = True\n                queue.extend(tree[curr])\n        diameter = max(diameter, dist)\n        if i == 2:\n            height = dist\n\n    if diameter != d or height != h:\n        return \"-1\"\n\n    # Print the tree\n    result = []\n    for i in range(1, n + 1):\n        for j in tree[i]:\n            result.append(\"{} {}\\n\".format(i, j))\n\n    return \"\".join(result)",
        "test": "",
        "num_ids": 354,
        "indeed": false
    },
    {
        "number": 518,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    R = (n * r) / (2 * (n - 1) + 2)\n    return f\"{R:.7f}\"",
        "test": "",
        "num_ids": 51,
        "indeed": false
    },
    {
        "number": 519,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, p, q = map(int, stdin.split())\n    distance = (l / 2) * (p + q)\n    return f\"{distance:.4f}\"",
        "test": "",
        "num_ids": 46,
        "indeed": false
    },
    {
        "number": 520,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    years = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    x = years[1] - years[0]\n    return str(sum(years) // n + x // 2)",
        "test": "",
        "num_ids": 71,
        "indeed": false
    },
    {
        "number": 521,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    if '?' not in s:\n        return \"No\"\n\n    cyan, magenta, yellow = s.count('C'), s.count('M'), s.count('Y')\n    unpainted = n - cyan - magenta - yellow\n\n    if unpainted == 0:\n        return \"No\"\n\n    if cyan > 0 and magenta > 0 and yellow > 0:\n        return \"Yes\"\n\n    if cyan > 0 and magenta > 0:\n        return \"Yes\"\n\n    if cyan > 0 and yellow > 0:\n        return \"Yes\"\n\n    if magenta > 0 and yellow > 0:\n        return \"Yes\"\n\n    return \"No\"",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 522,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f1, f2, f3, c = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    f = [0] * (n + 1)\n    f[1], f[2], f[3] = f1, f2, f3\n\n    for i in range(4, n + 1):\n        f[i] = (c**(2*i - 6) * f[i - 1] * f[i - 2] * f[i - 3]) % mod\n\n    return str(f[n])",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 523,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_palindrome(s1: str, s2: str) -> str:\n        for i in range(1, m + 1):\n            if is_palindrome(s1[:i] + s2[m - i:]):\n                return s1[:i] + s2[m - i:]\n        return \"\"\n\n    palindrome = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp = longest_palindrome(strings[i], strings[j])\n            if len(temp) > len(palindrome):\n                palindrome = temp\n\n    return f\"{len(palindrome)}\\n{palindrome}\"",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 524,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    cost = 0\n    c = a[0]\n    for i in range(n):\n        if a[i] != c:\n            cost += a[i] - c\n            c = a[i]\n\n    return str(cost)",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 525,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(test_cases):\n        n = int(stdin.split('\\n')[1 + i * 2])\n        password = list(map(int, stdin.split('\\n')[2 + i * 2].split()))\n\n        shortest_length = n\n        for j in range(n - 1):\n            if password[j] != password[j + 1]:\n                shortest_length -= 1\n                password.pop(j + 1)\n                password.pop(j)\n                password.insert(j, password[j] + password[j - 1])\n                break\n\n        result.append(str(shortest_length))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 526,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_valid(c: List[int]) -> bool:\n        xor_sum = 0\n        for i in range(n):\n            xor_sum ^= a[i][c[i] - 1]\n        return xor_sum > 0\n\n    for c in itertools.product(range(1, m + 1), repeat=n):\n        if is_valid(c):\n            return \"TAK\\n\" + \" \".join(map(str, c))\n    return \"NIE\"",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 527,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s_prime = s * (10 ** 100)\n    for i in range(len(s_prime), -1, -1):\n        if t in s_prime[:i]:\n            return str(i)\n    return '-1'",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 528,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def is_reasonable(x: int, y: int, z: int) -> bool:\n        if y in adj_list[x] and z in adj_list[y]:\n            return True\n        return False\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                if i != j and j != k and i != k:\n                    if is_reasonable(i, j, k) is False:\n                        return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 529,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split('\\n')\n    n = int(n)\n    result = ''\n    for i, c in enumerate(s):\n        if c.isalpha():\n            if c.islower():\n                result += chr(((ord(c) - ord('a') + n) % 26) + ord('a'))\n            else:\n                result += chr(((ord(c) - ord('A') + n) % 26) + ord('A'))\n        else:\n            result += c\n    return result",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 530,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    def get_largest_number(s: str) -> str:\n        return ''.join(sorted(s, reverse=True))\n\n    s_largest = get_largest_number(s)\n    t_largest = get_largest_number(t)\n\n    if s_largest > t_largest:\n        return \"First\"\n    elif s_largest < t_largest:\n        return \"Second\"\n    else:\n        return \"Draw\"",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 531,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_max(values):\n        return min(values), max(values)\n\n    def count_equal_measurements(values1, values2):\n        count = 0\n        for value in values1:\n            if value in values2:\n                count += 1\n        return count\n\n    def find_y_values(x_values, min_y, max_y):\n        y_values = []\n        for x in x_values:\n            if x < min_y:\n                y_values.append(min_y)\n            elif x > max_y:\n                y_values.append(max_y)\n            else:\n                y_values.append(x)\n        return y_values\n\n    n = int(stdin.readline().strip())\n    x_values = list(map(int, stdin.readline().strip().split()))\n\n    min_x, max_x = find_min_max(x_values)\n    min_y = min_x - 1 if min_x > 0 else min_x + 1\n    max_y = max_x + 1 if max_x < 0 else max_x - 1\n\n    min_equal_measurements = n\n    y_values = []\n\n    for i in range(min_y, max_y + 1):\n        y_values_candidate = find_y_values(x_values, i, i)\n        equal_measurements = count_equal_measurements(x_values, y_values_candidate)\n        if equal_measurements < min_equal_measurements:\n            min_equal_measurements = equal_measurements\n            y_values = y_values_candidate\n\n    return f\"{min_equal_measurements}\\n{' '.join(map(str, y_values))}\"",
        "test": "",
        "num_ids": 438,
        "indeed": false
    },
    {
        "number": 532,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    wheel = {alphabet[i]: i for i in range(len(alphabet))}\n    total_rotations = 0\n\n    for i in range(len(stdin)):\n        current_letter = stdin[i]\n        next_letter = stdin[(i + 1) % len(stdin)]\n\n        current_position = wheel[current_letter]\n        next_position = wheel[next_letter]\n\n        if current_position < next_position:\n            rotations = next_position - current_position\n        else:\n            rotations = len(alphabet) - current_position + next_position\n\n        total_rotations += rotations\n\n    return total_rotations\n",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 533,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, k1, k2, n = map(int, stdin.split())\n\n    min_players = 0\n    max_players = 0\n\n    # Calculate the minimum number of players that could have been sent off\n    min_players += min(n // k1, a1)\n    min_players += min(n // k2, a2)\n\n    # Calculate the maximum number of players that could have been sent off\n    max_players += n // k1\n    max_players += n // k2\n\n    return f\"{min_players} {max_players}\"",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 534,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s = input()\n    for _ in range(t):\n        for i in range(n - 1):\n            if s[i] == \"B\" and s[i + 1] == \"G\":\n                s = s[:i] + \"G\" + s[i] + s[i + 2:]\n    return s\n\nn, t = map(int, input().split())\ns = input()\nprint(solution(f\"{n} {t}\\n{s}\")) ",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 535,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def phi(x):\n        res = x\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                res -= res // i\n                while x % i == 0:\n                    x //= i\n        if x > 1:\n            res -= res // x\n        return res\n\n    def euler_totient(x):\n        res = x\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                res -= res // i\n                while x % i == 0:\n                    x //= i\n        if x > 1:\n            res -= res // x\n        return res\n\n    def mod_pow(a, b, m):\n        res = 1\n        while b:\n            if b & 1:\n                res = (res * a) % m\n            a = (a * a) % m\n            b >>= 1\n        return res\n\n    def mod_inv(a, m):\n        return mod_pow(a, m - 2, m)\n\n    def expected_value(n, k):\n        phi_n = phi(n)\n        euler_n = euler_totient(n)\n        p = phi_n * (n - 1)\n        q = euler_n * (n - 1)\n        return (p * mod_inv(q, mod)) % mod\n\n    return str(expected_value(n, k))",
        "test": "",
        "num_ids": 400,
        "indeed": false
    },
    {
        "number": 536,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 0:\n        return \"1\" * m if m % 2 == 0 else \"-1\"\n    if m == 0:\n        return \"0\" * n if n % 2 == 0 else \"-1\"\n    if n % 2 == 1 and m % 2 == 1:\n        return \"-1\"\n    sequence = []\n    for _ in range(n):\n        sequence.append(\"0\")\n    for _ in range(m):\n        sequence.append(\"1\")\n    return \"\".join(sequence)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 537,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_winners = n // 2\n    max_diplomas = max_winners // (k + 1)\n    max_certificates = k * max_diplomas\n    max_not_winners = n - max_diplomas - max_certificates\n    return f\"{max_diplomas} {max_certificates} {max_not_winners}\"",
        "test": "",
        "num_ids": 110,
        "indeed": true
    },
    {
        "number": 538,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    s = str(x)\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[-i - 1]:\n            return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 539,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = a ^ b\n            if c <= n and a + b > c and a + c > b and b + c > a:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 540,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    cave = []\n    for _ in range(n):\n        cave.append(list(stdin.readline().strip()))\n\n    r1, c1 = map(int, stdin.readline().split())\n    r2, c2 = map(int, stdin.readline().split())\n\n    def is_valid_move(r, c):\n        return 1 <= r <= n and 1 <= c <= m and cave[r - 1][c - 1] != 'X'\n\n    def dfs(r, c, target):\n        if (r, c) == target:\n            return True\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_r, new_c = r + dr, c + dc\n            if is_valid_move(new_r, new_c):\n                if dfs(new_r, new_c, target):\n                    return True\n\n        return False\n\n    if dfs(r1, c1, (r2, c2)):\n        return 'YES'\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 541,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    bridges = [1] * (N - 1)\n\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        bridges[a - 1] += 1\n        bridges[b - 2] += 1\n\n    return str(sum(min(bridges[i], bridges[i + 1]) for i in range(N - 2)))",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 542,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [int(x) for x in stdin.split('\\n')[1:]]\n\n    first_wrestler_points = [x for x in points if x > 0]\n    second_wrestler_points = [-x for x in points if x < 0]\n\n    first_wrestler_sequence = ''.join(str(x) for x in first_wrestler_points)\n    second_wrestler_sequence = ''.join(str(x) for x in second_wrestler_points)\n\n    if sum(first_wrestler_points) > sum(second_wrestler_points):\n        return \"first\"\n    elif sum(first_wrestler_points) < sum(second_wrestler_points):\n        return \"second\"\n    else:\n        if first_wrestler_sequence > second_wrestler_sequence:\n            return \"first\"\n        elif first_wrestler_sequence < second_wrestler_sequence:\n            return \"second\"\n        else:\n            return \"second\" if n % 2 == 0 else \"first\"",
        "test": "",
        "num_ids": 279,
        "indeed": false
    },
    {
        "number": 543,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 544,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def can_be_palindrome(s: str) -> bool:\n        changes = 0\n        for i in range(len(s) // 2):\n            if s[i] != s[-i - 1]:\n                changes += 1\n                if changes > 1:\n                    return False\n        return True\n\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n\n        if n == 2:\n            result.append(\"NO\")\n        elif can_be_palindrome(s):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 545,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split('\\n')[0].split())\n    s1 = stdin.split('\\n')[1]\n    s2 = stdin.split('\\n')[2]\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                s3 = ''\n                diff_count = 0\n                for k in range(n):\n                    if s1[k] != s2[k]:\n                        diff_count += 1\n                        if diff_count > t:\n                            break\n                        s3 += s1[k]\n                    else:\n                        s3 += s2[k]\n                if diff_count == t:\n                    return s3\n    return -1",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 546,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    good_letters = set(stdin.readline().strip())\n    pattern = stdin.readline().strip()\n    n = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(n):\n        query = stdin.readline().strip()\n        is_match = True\n\n        pattern_index = 0\n        query_index = 0\n\n        while pattern_index < len(pattern) and query_index < len(query):\n            if pattern[pattern_index] == '*':\n                if pattern_index == len(pattern) - 1:\n                    is_match = True\n                    break\n                else:\n                    pattern_index += 1\n                    continue\n            elif pattern[pattern_index] == '?':\n                pattern_index += 1\n                query_index += 1\n            else:\n                if pattern[pattern_index] not in good_letters:\n                    is_match = False\n                    break\n                else:\n                    pattern_index += 1\n                    query_index += 1\n\n        if pattern_index < len(pattern) - 1 or query_index < len(query):\n            is_match = False\n\n        if is_match:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 327,
        "indeed": false
    },
    {
        "number": 547,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    passwords = [stdin.readline().strip() for _ in range(n)]\n    codehorses_password = stdin.readline().strip()\n\n    best_case = 1\n    worst_case = 1\n\n    for password in sorted(passwords, key=len):\n        if password == codehorses_password:\n            break\n        if len(password) == len(codehorses_password):\n            worst_case += 5\n\n    return f\"{best_case} {worst_case}\"",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 548,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_even(num):\n        return num % 2 == 0\n\n    def is_odd(num):\n        return num % 2 != 0\n\n    def get_subsegment_sum(arr, start, end):\n        return sum(arr[start:end + 1])\n\n    def find_subsegments(arr, is_even_func):\n        subsegments = []\n        start = 0\n        end = 0\n        current_sum = 0\n\n        while end < len(arr):\n            current_sum += arr[end]\n\n            if is_even_func(current_sum):\n                subsegments.append((start, end))\n                current_sum = 0\n                start = end + 1\n\n            end += 1\n\n        return subsegments\n\n    odd_subsegments = find_subsegments(arr, is_odd)\n    even_subsegments = find_subsegments(arr, is_even)\n\n    if not odd_subsegments:\n        return \"Second\"\n\n    if not even_subsegments:\n        return \"First\"\n\n    odd_subsegment_sums = [get_subsegment_sum(arr, start, end) for start, end in odd_subsegments]\n    even_subsegment_sums = [get_subsegment_sum(arr, start, end) for start, end in even_subsegments]\n\n    if max(odd_subsegment_sums) > max(even_subsegment_sums):\n        return \"First\"\n    else:\n        return \"Second\"",
        "test": "",
        "num_ids": 416,
        "indeed": false
    },
    {
        "number": 549,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = 1\n    b = n\n    min_diff = n\n    while a <= b:\n        diff = b - a\n        if diff < min_diff:\n            min_diff = diff\n            rows = a\n            cols = b\n        if n % a == 0:\n            b = n // a\n        else:\n            a += 1\n    return f\"{rows} {cols}\"",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 550,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        for c1, c2 in zip(s1, s2):\n            if c1 == c2:\n                continue\n            if c1.isalpha() and c2.isalpha() and c1.lower() == c2.lower():\n                continue\n            if c1.isdigit() and c2.isdigit() and (c1 == '1' and c2 in 'lI') or (c1 in 'lI' and c2 == '1'):\n                continue\n            if c1 == 'O' and c2 == '0' or c1 == '0' and c2 == 'O':\n                continue\n            return False\n        return True\n\n    stdin_list = stdin.split('\\n')\n    new_login = stdin_list[0]\n    existing_logins = stdin_list[1:]\n\n    for login in existing_logins:\n        if is_similar(new_login, login):\n            return 'No'\n    return 'Yes'",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 551,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y = map(int, stdin.split())\n    y = sorted(y)\n    lines = []\n    for i in range(n):\n        if i == 0 or y[i] != y[i - 1]:\n            lines.append(y[i])\n    if len(lines) % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 552,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a, b, s = stdin.readline().strip(), stdin.readline().strip(), stdin.readline().strip()\n\n    def count_ways(l1: int, r1: int, l2: int, r2: int) -> int:\n        if l1 > r1 or l2 > r2:\n            return 0\n        intersection = set(range(l1, r1 + 1)) & set(range(l2, r2 + 1))\n        if not intersection:\n            return 0\n        sub_a = a[l1:r1 + 1]\n        sub_b = b[l2:r2 + 1]\n        for x in intersection:\n            if a[x] != b[x]:\n                return 0\n        return len(intersection)\n\n    total_ways = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if count_ways(l1, r1, l2, r2) == m:\n                        total_ways += 1\n\n    return str(total_ways)",
        "test": "",
        "num_ids": 323,
        "indeed": false
    },
    {
        "number": 553,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    promocodes = [stdin.readline().strip() for _ in range(n)]\n\n    def is_valid(code: str, typed_code: str) -> bool:\n        errors = 0\n        for c1, c2 in zip(code, typed_code):\n            if c1 != c2:\n                errors += 1\n                if errors > 1:\n                    return False\n        return True\n\n    k = 1\n    while any(is_valid(code, f\"{code[:k]}{typed_code}{code[k+1:]}\") for typed_code in \"0123456789\") for code in promocodes):\n        k += 1\n\n    return str(k - 1)",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 554,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    subarrays = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    happiness = 0\n    for i in range(n):\n        subarray_count = sum(1 for l, r in subarrays if l <= i <= r)\n        happiness += a[i] * subarray_count\n\n    return str(happiness)",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 555,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x == 0:\n        return \"1\"\n    result = \"\"\n    for digit in str(x):\n        result += str(9 - int(digit))\n    return result",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 556,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    power = 0\n    while k ** (power + 1) <= r:\n        power += 1\n    while power >= 0:\n        current_power = k ** power\n        if l <= current_power <= r:\n            result.append(current_power)\n        power -= 1\n    if not result:\n        return \"-1\"\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 557,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teleports = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        teleports.append((a, b))\n\n    def can_reach(start, end, idx):\n        if start >= end:\n            return True\n        if idx < 0:\n            return False\n        return can_reach(start, teleports[idx][1], idx - 1) or can_reach(teleports[idx][0], end, idx - 1)\n\n    for i in range(n - 1, -1, -1):\n        if can_reach(teleports[i][0], m, i - 1):\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 558,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [[0] * M for _ in range(K + 1)]\n    dp[0][0] = M\n\n    for i in range(1, N + 1):\n        for j in range(K, -1, -1):\n            for k in range(M):\n                if j == K:\n                    dp[j][k] = dp[j][k - 1]\n                elif k == 0:\n                    dp[j][k] = dp[j + 1][k + 1]\n                else:\n                    dp[j][k] = (dp[j][k - 1] + dp[j + 1][k]) % 998244353\n\n    return dp[0][0]",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 559,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, a = map(int, stdin.split())\n    b = [0] * (p - 1)\n\n    for i in range(p - 1):\n        b[i] = (a[i] - b[i]) % p\n\n    return ' '.join(map(str, b))",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 560,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.readline().split())\n    cake = [list(stdin.readline().strip()) for _ in range(r)]\n\n    def is_valid(row_or_col):\n        return all(cell != 'S' for cell in row_or_col)\n\n    def eat(cake):\n        max_eat = 0\n        for i in range(r + c):\n            if i < r:\n                if is_valid(cake[i]):\n                    max_eat += cake[i].count('.')\n                    for j in range(c):\n                        if cake[i][j] == '.':\n                            cake[i][j] = 'X'\n            else:\n                col = [cake[j][i - r] for j in range(r)]\n                if is_valid(col):\n                    max_eat += col.count('.')\n                    for j in range(r):\n                        if col[j] == '.':\n                            cake[j][i - r] = 'X'\n        return max_eat\n\n    return str(eat(cake))",
        "test": "",
        "num_ids": 281,
        "indeed": false
    },
    {
        "number": 561,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    if n == 1:\n        return \"-1\\n\"\n\n    diff = cards[1] - cards[0]\n    min_card = cards[0] - diff\n    max_card = cards[-1] + diff\n\n    if min_card > 0:\n        return \"1\\n\" + str(min_card) + \"\\n\"\n    elif max_card < 0:\n        return \"1\\n\" + str(max_card) + \"\\n\"\n    else:\n        return \"-1\\n\"",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 562,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    shows = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    shows.sort(key=lambda x: x[1])\n\n    tv1 = shows[0][1]\n    tv2 = None\n\n    for i in range(1, n):\n        if shows[i][0] >= tv1:\n            if tv2 is None or shows[i][0] >= tv2:\n                tv2 = shows[i][1]\n            else:\n                return \"NO\"\n        else:\n            return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 563,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    for a in range(l, r - 1):\n        for b in range(a + 1, r):\n            if all(a % i != 0 or b % i != 0 for i in range(2, int(a ** 0.5) + 1)) and all(b % i != 0 or c % i != 0 for i in range(2, int(b ** 0.5) + 1)):\n                for c in range(b + 1, r + 1):\n                    if a != b and b != c and a != c and all(a % i != 0 or c % i != 0 for i in range(2, int(c ** 0.5) + 1)):\n                        return f\"{a} {b} {c}\"\n\n    return \"-1\"",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 564,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    mugs = list(map(int, stdin.split()))\n    total_volume = sum(mugs)\n    if total_volume <= s:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 68,
        "indeed": false
    },
    {
        "number": 565,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_ornaments = 0\n\n    for i in range(1, y + 1):\n        for j in range(i + 1, b + 1):\n            for k in range(j + 1, r + 1):\n                if j - i == 1 and k - j == 1:\n                    max_ornaments = max(max_ornaments, i + j + k)\n\n    return str(max_ornaments)",
        "test": "",
        "num_ids": 125,
        "indeed": true
    },
    {
        "number": 566,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    total_balloons = r + g + b\n    min_balloons_per_table = 3\n    max_tables = total_balloons // min_balloons_per_table\n    return str(max_tables)",
        "test": "",
        "num_ids": 75,
        "indeed": false
    },
    {
        "number": 567,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    time = 0\n    i, j = 0, n - 1\n    while i <= j:\n        if a[i] <= 1000000 - 1000000 // 2:\n            time += a[i] - 1\n            i += 1\n        else:\n            time += 1000000 - a[j]\n            j -= 1\n\n    return str(time)",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 568,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n\n    def count_ways(i: int, a: int, b: int, c: int) -> int:\n        if i == 3 * n:\n            return 1\n        if a + b + c != 6:\n            return 0\n        return (count_ways(i + 1, a - 1, b, c) +\n                count_ways(i + 1, a, b - 1, c) +\n                count_ways(i + 1, a, b, c - 1)) % MOD\n\n    result = 0\n    for a in range(1, 4):\n        for b in range(1, 4):\n            for c in range(1, 4):\n                if a + b + c == 6:\n                    result += count_ways(0, a, b, c)\n                    result %= MOD\n\n    return str(result)",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 569,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if len(set(s)) == len(s):\n        return 0\n\n    substrings = set()\n    min_changes = float('inf')\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            sub = s[i:j]\n            if sub in substrings:\n                min_changes = min(min_changes, len(sub))\n            substrings.add(sub)\n\n    return -1 if min_changes == float('inf') else min_changes",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 570,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    while a <= b:\n        a += 1\n        b -= 2\n    return \"Vladik\" if a <= b else \"Valera\"",
        "test": "",
        "num_ids": 52,
        "indeed": false
    },
    {
        "number": 571,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_correct_parenthesis(sequence: str) -> bool:\n        stack = []\n        for char in sequence:\n            if char == \"(\":\n                stack.append(char)\n            elif char == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def generate_parenthesis_sequences(s: str, prefix: str, result: set):\n        if len(prefix) == len(s):\n            if is_correct_parenthesis(prefix):\n                result.add(prefix)\n            return\n\n        if s[len(prefix)] == \"?\":\n            generate_parenthesis_sequences(s, prefix + \"(\", result)\n            generate_parenthesis_sequences(s, prefix + \")\", result)\n        else:\n            generate_parenthesis_sequences(s, prefix + s[len(prefix)], result)\n\n    def replace_question_marks(s: str) -> str:\n        all_sequences = set()\n        generate_parenthesis_sequences(s, \"\", all_sequences)\n\n        for sequence in all_sequences:\n            if all(not is_correct_parenthesis(sequence[:i]) for i in range(1, len(sequence) + 1)):\n                return sequence\n\n        return \":(\"\n\n    return replace_question_marks(s)",
        "test": "",
        "num_ids": 355,
        "indeed": false
    },
    {
        "number": 572,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for i in range(n + 1):\n        if abs(a[i]) > k:\n            count += 2\n        elif a[i] == 0:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 573,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    groups = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    teams = 0\n    for i in range(n):\n        if groups[i] == 1:\n            teams += 1\n\n    for i in range(n):\n        if groups[i] == 2:\n            found = False\n            for j in range(n):\n                if j != i and groups[j] == 2:\n                    found = True\n                    break\n            if found:\n                groups[i] = 0\n                groups[j] = 0\n                teams += 1\n\n    return str(teams)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 574,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    width = x2 - x1 + 1\n    height = y2 - y1 + 1\n    units_count = width * height // 2\n    return str(units_count)",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 575,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    def is_in_check(x, y, a_x, a_y, b_x, b_y):\n        return (x == a_x or y == a_y or abs(x - a_x) == abs(y - a_y)) or (x == b_x and y == b_y)\n\n    def bfs(start_x, start_y, target_x, target_y):\n        visited = set()\n        queue = [(start_x, start_y)]\n\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == (target_x, target_y):\n                return True\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                    new_x, new_y = x + dx, y + dy\n                    if 1 <= new_x <= n and 1 <= new_y <= n and not is_in_check(new_x, new_y, a_x, a_y, b_x, b_y):\n                        queue.append((new_x, new_y))\n\n        return False\n\n    if bfs(b_x, b_y, c_x, c_y):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 407,
        "indeed": false
    },
    {
        "number": 576,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    max_lcm = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)",
        "test": "",
        "num_ids": 164,
        "indeed": true
    },
    {
        "number": 577,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = []\n    b = []\n    for i in range(n):\n        a_i, b_i = map(int, stdin.readline().split())\n        a.append(a_i)\n        b.append(b_i)\n\n    total_red = sum(a)\n    total_blue = sum(b)\n\n    if total_red < k or total_blue < k:\n        return \"0\"\n\n    max_baskets = min(total_red // k, total_blue // k)\n\n    for i in range(n):\n        max_baskets_red = a[i] // k\n        max_baskets_blue = b[i] // k\n        max_baskets = min(max_baskets, max_baskets_red, max_baskets_blue)\n\n    return str(max_baskets)",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 578,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('e')\n    a, b = float(a), int(b)\n    x = a * 10 ** b\n    if x.is_integer():\n        return str(int(x))\n    else:\n        p, q = str(x).split('.')\n        p = p.lstrip('0')\n        q = q.rstrip('0')\n        return p + '.' + q if q else p",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 579,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    P = list(map(int, stdin.readline().split()))\n    C = list(map(int, stdin.readline().split()))\n\n    def max_score(start_square: int, moves_left: int) -> int:\n        if moves_left == 0:\n            return 0\n        next_square = P[start_square - 1]\n        max_score_here = C[next_square - 1]\n        max_score_next = max_score(next_square, moves_left - 1)\n        return max(max_score_here + max_score_next, max_score(start_square, moves_left))\n\n    max_score_starting_at_1 = max_score(1, K)\n    max_score_starting_at_2 = max_score(2, K)\n    max_score_starting_at_3 = max_score(3, K)\n    max_score_starting_at_4 = max_score(4, K)\n    max_score_starting_at_5 = max_score(5, K)\n\n    return max(max_score_starting_at_1, max_score_starting_at_2, max_score_starting_at_3, max_score_starting_at_4, max_score_starting_at_5)",
        "test": "",
        "num_ids": 344,
        "indeed": false
    },
    {
        "number": 580,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start - 1] = 0\n        queue = [(0, start)]\n\n        while queue:\n            weight, node = heapq.heappop(queue)\n            if node == end:\n                return weight\n            if not visited[node - 1]:\n                visited[node - 1] = True\n                for neighbor, weight in graph[node - 1]:\n                    new_weight = weight + weight\n                    if new_weight < weights[neighbor - 1]:\n                        weights[neighbor - 1] = new_weight\n                        heapq.heappush(queue, (new_weight, neighbor))\n        return -1\n\n    def min_cost_repair(graph, start, end, visited):\n        min_cost = float('inf')\n        for i, (neighbors, weight) in enumerate(graph):\n            if i not in visited:\n                min_cost = min(min_cost, weight)\n        return min_cost\n\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, m + 1):\n        a, b, l = map(int, lines[i].split())\n        graph[a - 1].append((b - 1, l))\n        graph[b - 1].append((a - 1, l))\n\n    shortest_path = dijkstra(graph, s, t)\n    result = []\n\n    for i in range(1, m + 1):\n        a, b, l = map(int, lines[i].split())\n        if a - 1 in shortest_path or b - 1 in shortest_path:\n            result.append('YES')\n        else:\n            visited = set(shortest_path)\n            min_cost = min_cost_repair(graph, s, t, visited)\n            if min_cost == float('inf'):\n                result.append('NO')\n            else:\n                result.append(f'CAN {min_cost}')\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 559,
        "indeed": false
    },
    {
        "number": 581,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(u, v):\n        path = []\n        while u != v:\n            path.append(u)\n            u = parent[u]\n        path.append(v)\n        return path\n\n    def find_height(u, v):\n        path = find_path(u, v)\n        height = 0\n        for i in range(len(path) - 1):\n            height += length[path[i], path[i + 1]]\n        return height\n\n    def find_farthest_leaves(u):\n        farthest_leaves = []\n        for v in range(1, n + 1):\n            if v != u and v not in parent:\n                farthest_leaves.append(v)\n        return farthest_leaves\n\n    def find_max_path_length(u):\n        farthest_leaves = find_farthest_leaves(u)\n        max_path_length = 0\n        for i in range(len(farthest_leaves)):\n            for j in range(i + 1, len(farthest_leaves)):\n                max_path_length = max(max_path_length, find_height(farthest_leaves[i], farthest_leaves[j]))\n        return max_path_length\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = [tuple(map(int, line.split())) for line in lines[1:n - 1]]\n    parent = {}\n    length = {}\n\n    for u, v in edges:\n        parent[v] = u\n        length[u, v] = 1\n        length[v, u] = 1\n\n    max_path_length = find_max_path_length(1)\n    operations = []\n\n    for i in range(n - 2, -1, -1):\n        farthest_leaves = find_farthest_leaves(1)\n        max_height = 0\n        max_leaves = None\n        for j in range(len(farthest_leaves) - 1):\n            for k in range(j + 1, len(farthest_leaves)):\n                height = find_height(farthest_leaves[j], farthest_leaves[k])\n                if height > max_height:\n                    max_height = height\n                    max_leaves = (farthest_leaves[j], farthest_leaves[k])\n\n        operations.append((max_leaves[0], max_leaves[1], max_leaves[0]))\n        operations.append((max_leaves[0], max_leaves[1], max_leaves[1]))\n        parent.pop(max_leaves[0])\n        parent.pop(max_leaves[1])\n\n    return f\"{max_path_length}\\n\" + '\\n'.join([' '.join(map(str, op)) for op in operations[::-1]])",
        "test": "",
        "num_ids": 727,
        "indeed": false
    },
    {
        "number": 582,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, t = map(int, stdin.split())\n    a.sort()\n    t.sort()\n    time = 0\n    for i in range(n):\n        if i > 0 and a[i] == a[i - 1]:\n            time += t[i] - t[i - 1]\n    return str(time)",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 583,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_correct(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            else:\n                if not stack or stack.pop() != '(':\n                    return False\n        return len(stack) == 0\n\n    def cyclical_shift(s: str, k: int) -> str:\n        return s[-k:] + s[:-k]\n\n    def count_beauty(s: str) -> int:\n        beauty = 0\n        for k in range(n):\n            if is_correct(cyclical_shift(s, k)):\n                beauty += 1\n        return beauty\n\n    max_beauty = 0\n    max_i = 0\n    max_j = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            temp_s = list(s)\n            temp_s[i - 1], temp_s[j - 1] = temp_s[j - 1], temp_s[i - 1]\n            temp_s = ''.join(temp_s)\n            beauty = count_beauty(temp_s)\n            if beauty > max_beauty:\n                max_beauty = beauty\n                max_i = i\n                max_j = j\n\n    return f\"{max_beauty}\\n{max_i} {max_j}\\n\"",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 584,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    # Find words outside parentheses\n    longest_word_outside = 0\n    words_outside = []\n    word = \"\"\n    inside_parentheses = False\n    for i in range(n):\n        if s[i] == \"(\":\n            inside_parentheses = True\n        elif s[i] == \")\":\n            inside_parentheses = False\n        elif s[i] == \"_\" and not inside_parentheses:\n            if len(word) > 0:\n                words_outside.append(word)\n                word = \"\"\n        elif s[i].isalpha() and not inside_parentheses:\n            word += s[i]\n            longest_word_outside = max(longest_word_outside, len(word))\n        else:\n            word = \"\"\n    if len(word) > 0:\n        words_outside.append(word)\n\n    # Find words inside parentheses\n    words_inside = []\n    word = \"\"\n    inside_parentheses = False\n    for i in range(n):\n        if s[i] == \"(\":\n            inside_parentheses = True\n        elif s[i] == \")\":\n            inside_parentheses = False\n        elif s[i] == \"_\" and inside_parentheses:\n            if len(word) > 0:\n                words_inside.append(word)\n                word = \"\"\n        elif s[i].isalpha() and inside_parentheses:\n            word += s[i]\n        else:\n            word = \"\"\n    if len(word) > 0:\n        words_inside.append(word)\n\n    return f\"{longest_word_outside} {len(words_inside)}\"",
        "test": "",
        "num_ids": 439,
        "indeed": false
    },
    {
        "number": 585,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    MOD = 998244353\n\n    def count_ways(a, b):\n        dp = [0] * (len(a) + 1)\n        dp[0] = 1\n\n        for i in range(len(a)):\n            for j in range(len(b)):\n                if a[i] >= b[j]:\n                    dp[i + 1] += dp[i - j]\n                    dp[i + 1] %= MOD\n\n        return dp[-1]\n\n    return str(count_ways(a, b))",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 586,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_colorings(n: int, k: int) -> int:\n        dp = [[0, 0] for _ in range(n + 1)]\n        dp[1][0] = 1\n        dp[1][1] = 1\n\n        for i in range(2, n + 1):\n            for j in range(2):\n                dp[i][j] = 2 * dp[i - 1][j] - (dp[i - 2][j] if i > 2 else 0)\n                dp[i][j] %= MOD\n\n        return dp[n][0]\n\n    return str(count_colorings(n, k))",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 587,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_satisfaction(N, K, sushi):\n        sushi.sort(key=lambda x: x[1], reverse=True)\n        max_sat = 0\n        toppings = set()\n        for i in range(K):\n            max_sat += sushi[i][1]\n            toppings.add(sushi[i][0])\n        max_sat += len(toppings) ** 2\n        return max_sat\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    sushi = [tuple(map(int, line.split())) for line in lines[1:]]\n    return str(max_satisfaction(N, K, sushi))",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 588,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x, y):\n        return (x ** 2 + y ** 2) ** 0.5\n\n    N, *engines = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    max_distance = 0\n\n    for i in range(1, (1 << N) - 1):\n        x, y = 0, 0\n        for j in range(N):\n            if (i >> j) & 1:\n                x += engines[j][0]\n                y += engines[j][1]\n        max_distance = max(max_distance, distance(x, y))\n\n    return f\"{max_distance:.100f}\"",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 589,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    digits = set(s) - {'?'}\n    if '0' in digits:\n        return '0'\n\n    def count_variants(s: str) -> int:\n        if '?' not in s:\n            return 1\n        if len(set(s)) == 1:\n            return 10 ** s.count('?')\n        total = 0\n        for i in range(10):\n            new_s = s.replace('?', str(i), 1)\n            total += count_variants(new_s)\n        return total\n\n    total = 0\n    for i in range(1, n):\n        if s[i] != s[0]:\n            break\n    else:\n        i += 1\n    total += count_variants(s[i:]) * 9 ** i\n\n    return str(total)",
        "test": "",
        "num_ids": 220,
        "indeed": false
    },
    {
        "number": 590,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    q = 0\n    for i in range(n):\n        if arr[i] != i + 1:\n            q += 1\n\n    if q == 0:\n        return f\"0\\n{' '.join(map(str, arr))}\"\n\n    lex_min_perm = []\n    for i in range(n):\n        if i + 1 not in arr:\n            lex_min_perm.append(i + 1)\n        else:\n            lex_min_perm.append(arr[i])\n\n    return f\"{q}\\n{' '.join(map(str, lex_min_perm))}\"",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 591,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    light_levels = list(map(int, stdin.split()[2:]))\n    light_levels.sort(reverse=True)\n    selected_hours = light_levels[0:k]\n    min_light_level = min(selected_hours)\n    indexes = [i + 1 for i in range(n) if light_levels[i] in selected_hours]\n    return f\"{min_light_level}\\n{' '.join(map(str, indexes))}\"",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 592,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n\n    for i in range(2, n + 1):\n        score = 0\n        while i != 1:\n            x = 2\n            while x <= n:\n                if i * x > n:\n                    break\n                if i * x == n:\n                    score += abs(x)\n                    i = n\n                    break\n                x += 1\n            else:\n                break\n        max_score = max(max_score, score)\n\n    return str(max_score)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 593,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    votes = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    first_stage_winners = [max(range(n), key=lambda x: (votes[i][x], -x)) + 1 for i in range(m)]\n    second_stage_winners = max(range(n), key=lambda x: (first_stage_winners.count(x + 1), -x)) + 1\n\n    return str(second_stage_winners)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 594,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    if a[0] > b[-1]:\n        return -1\n\n    v = 1\n    while v <= 100:\n        correct_solutions = all(a_ <= v for a_ in a)\n        extra_time = any(a_ > v // 2 for a_ in a)\n        wrong_solutions = all(b_ > v for b_ in b)\n\n        if correct_solutions and extra_time and wrong_solutions:\n            return str(v)\n        v += 1\n\n    return -1",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 595,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days_in_month_leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days_in_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    days_in_week_count = [0] * 7\n    week_start = days_in_week.index(days_in_week[y % 7])\n\n    for i in range(12):\n        if (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0):\n            days_in_week_count[week_start] += days_in_month_leap[i]\n        else:\n            days_in_week_count[week_start] += days_in_month[i]\n\n    for i in range(1, 7):\n        days_in_week_count[week_start] += days_in_week_count[week_start - i]\n\n    for i in range(y + 1, 100000):\n        if days_in_week_count[i % 7] == days_in_week_count[y % 7]:\n            return i\n\n    return -1",
        "test": "",
        "num_ids": 410,
        "indeed": false
    },
    {
        "number": 596,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        if year % 4 == 0:\n            if year % 100 == 0:\n                if year % 400 == 0:\n                    return True\n                else:\n                    return False\n            else:\n                return True\n        else:\n            return False\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            return 31\n        elif month == 2:\n            if is_leap_year(year):\n                return 29\n            else:\n                return 28\n        else:\n            return 30\n\n    def days_between_dates(date1: str, date2: str) -> int:\n        year1, month1, day1 = map(int, date1.split(':'))\n        year2, month2, day2 = map(int, date2.split(':'))\n\n        days = 0\n        for year in range(year1, year2):\n            days += 365\n            if is_leap_year(year):\n                days += 1\n\n        for month in range(month1, month2):\n            days += days_in_month(year1, month)\n\n        days += day2 - day1\n\n        return days\n\n    date1, date2 = stdin.strip().split('\\n')\n    return str(days_between_dates(date1, date2))",
        "test": "",
        "num_ids": 378,
        "indeed": false
    },
    {
        "number": 597,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_time(graph, start, cities):\n        visited = [False] * len(graph)\n        distances = [float('inf')] * len(graph)\n        distances[start] = 0\n\n        for _ in range(len(graph)):\n            current_vertex = -1\n            for i in range(len(graph)):\n                if not visited[i] and (current_vertex == -1 or distances[i] < distances[current_vertex]):\n                    current_vertex = i\n\n            if current_vertex == -1:\n                break\n\n            visited[current_vertex] = True\n\n            for neighbor, dist in enumerate(graph[current_vertex]):\n                if not visited[neighbor] and dist != float('inf'):\n                    new_distance = distances[current_vertex] + dist\n                    if new_distance < distances[neighbor]:\n                        distances[neighbor] = new_distance\n\n        min_time = float('inf')\n        for city in cities:\n            min_time = min(min_time, distances[city - 1])\n\n        return min_time\n\n    def find_start_city(graph, cities):\n        min_time = float('inf')\n        start_city = -1\n        for i in range(len(graph)):\n            time = find_min_time(graph, i, cities)\n            if time < min_time:\n                min_time = time\n                start_city = i\n\n        return start_city + 1, min_time\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    for i in range(n - 1):\n        u, v = map(int, lines[i + 1].split())\n        graph[u - 1][v - 1] = 1\n        graph[v - 1][u - 1] = 1\n\n    cities = list(map(int, lines[-1].split()))\n\n    start_city, min_time = find_start_city(graph, cities)\n\n    return f\"{start_city}\\n{min_time}\"",
        "test": "",
        "num_ids": 541,
        "indeed": false
    },
    {
        "number": 598,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, x):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def find_min_cost(n, x, l, r, cost):\n        l.sort()\n        r.sort()\n        min_cost = float('inf')\n        for i in range(n):\n            j = binary_search(l, r[i] + 1)\n            if j != -1 and l[j] - r[i] >= x:\n                min_cost = min(min_cost, cost[i] + cost[j])\n        return min_cost if min_cost != float('inf') else -1\n\n    n, x = map(int, stdin.readline().split())\n    l, r, cost = [], [], []\n    for _ in range(n):\n        l_i, r_i, cost_i = map(int, stdin.readline().split())\n        l.append(l_i)\n        r.append(r_i)\n        cost.append(cost_i)\n\n    return str(find_min_cost(n, x, l, r, cost))",
        "test": "",
        "num_ids": 341,
        "indeed": false
    },
    {
        "number": 599,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return s[:n - i - 1] + s[i] + s[n - i - 1:]\n    if n % 2 == 0:\n        return s + s[n // 2]\n    else:\n        return s[:n // 2 + 1] + s[n // 2] + s[n // 2 + 1:]\n\n    return \"NA\"\n",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 600,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    return str(abs(a - b))",
        "test": "",
        "num_ids": 27,
        "indeed": false
    },
    {
        "number": 601,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_weapons(p, f, cnt_s, cnt_w, s, w):\n        max_swords = min(cnt_s, p // s)\n        max_war_axes = min(cnt_w, f // w)\n        return max_swords + max_war_axes\n\n    cases = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, cases + 1):\n        p, f, cnt_s, cnt_w, s, w = map(int, stdin.split('\\n')[i * 3 + 1].split())\n        result.append(max_weapons(p, f, cnt_s, cnt_w, s, w))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 200,
        "indeed": false
    },
    {
        "number": 602,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    presidents = [\n        \"George Washington\",\n        \"John Adams\",\n        \"Thomas Jefferson\",\n        \"James Madison\",\n        \"James Monroe\",\n        \"John Quincy Adams\",\n        \"Andrew Jackson\",\n        \"Martin Van Buren\",\n        \"William Henry Harrison\",\n        \"John Tyler\",\n        \"James K. Polk\",\n        \"Zachary Taylor\",\n        \"Millard Fillmore\",\n        \"Franklin Pierce\",\n        \"James Buchanan\",\n        \"Abraham Lincoln\",\n        \"Andrew Johnson\",\n        \"Ulysses S. Grant\",\n        \"Rutherford B. Hayes\",\n        \"James A. Garfield\",\n        \"Chester A. Arthur\",\n        \"Grover Cleveland\",\n        \"Benjamin Harrison\",\n        \"Grover Cleveland\",\n        \"William McKinley\",\n        \"Theodore Roosevelt\",\n        \"William Howard Taft\",\n        \"Woodrow Wilson\",\n        \"Warren G. Harding\",\n        \"Calvin Coolidge\",\n        \"Herbert Hoover\",\n        \"Franklin D. Roosevelt\",\n        \"Harry S. Truman\",\n        \"Dwight D. Eisenhower\",\n        \"John F. Kennedy\",\n        \"Lyndon B. Johnson\",\n        \"Richard Nixon\",\n        \"Gerald Ford\",\n        \"Jimmy Carter\",\n        \"Ronald Reagan\",\n        \"George H. W. Bush\",\n        \"Bill Clinton\",\n        \"George W. Bush\",\n        \"Barack Obama\",\n        \"Donald Trump\",\n    ]\n\n    a = int(stdin)\n    return presidents[a - 1]",
        "test": "",
        "num_ids": 418,
        "indeed": false
    },
    {
        "number": 603,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    red_bouquets = r // 3\n    green_bouquets = g // 3\n    blue_bouquets = b // 3\n    mixing_bouquets = min(red_bouquets, green_bouquets, blue_bouquets)\n    total_bouquets = red_bouquets + green_bouquets + blue_bouquets + mixing_bouquets\n    return str(total_bouquets)",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 604,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    time = 0\n    while any(arr):\n        time += 1\n        for i in range(n):\n            if arr[i] != 0:\n                arr[i] += -arr[i]\n                if arr[i] == 0:\n                    break\n\n    return str(time)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 605,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    def get_points(points, time):\n        return max(points * 3 / 10, points - points / 250 * time)\n\n    misha_points = get_points(a, c)\n    vasya_points = get_points(b, d)\n\n    if misha_points > vasya_points:\n        return \"Misha\"\n    elif misha_points < vasya_points:\n        return \"Vasya\"\n    else:\n        return \"Tie\"",
        "test": "",
        "num_ids": 145,
        "indeed": true
    },
    {
        "number": 606,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, x_1, y_1, x_2, y_2 = map(int, stdin.split())\n\n    # Calculate the distance between Fifa's position and Fafa's position\n    distance = ((x_1 - x_2) ** 2 + (y_1 - y_2) ** 2) ** 0.5\n\n    # Calculate the radius of the access point\n    r = R - distance\n\n    # Calculate the position of the access point\n    x_ap = x_1 - (x_1 - x_2) * R / distance\n    y_ap = y_1 - (y_1 - y_2) * R / distance\n\n    return f\"{x_ap} {y_ap} {r}\"",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 607,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    happiness = 0\n\n    def is_framed_segment(p: List[int], l: int, r: int) -> bool:\n        return max(p[l:r + 1]) - min(p[l:r + 1]) == r - l\n\n    for p in permutations(range(1, n + 1)):\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if is_framed_segment(p, l - 1, r - 1):\n                    happiness += 1\n\n    return str(happiness % m)\n",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 609,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    paper = [list(line) for line in stdin.split('\\n')[1:]]\n\n    diagonal1 = [paper[i][i] for i in range(n)]\n    diagonal2 = [paper[i][n - i - 1] for i in range(n)]\n\n    if diagonal1 == diagonal2:\n        for i in range(n):\n            for j in range(n):\n                if i == j or i == n - j - 1:\n                    continue\n                if paper[i][j] != diagonal1[0]:\n                    return \"NO\"\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 610,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = max(n, m)\n    vasya_points = min(n, m)\n    return f\"{petya_points} {vasya_points}\"",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 611,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    x_i = [0] * n\n    d_i = [0] * n\n\n    for _ in range(m):\n        x, d = map(int, stdin.readline().split())\n        for i in range(n):\n            x_i[i] += x + d * abs(i - 1)\n            d_i[i] += 1\n\n    mean = sum(x_i[i] / d_i[i] for i in range(n)) / n\n    return f\"{mean:.10f}\"",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 612,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    if p > k or p < 0:\n        return \"NO\"\n\n    even_sum = 0\n    odd_sum = 0\n    even_parts = []\n    odd_parts = []\n\n    for num in arr:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n\n    if p * 2 == k:\n        if even_sum % 2 == 0:\n            for num in arr:\n                if num % 2 == 0:\n                    even_parts.append(num)\n            print(\"YES\")\n            for part in even_parts:\n                print(1, part)\n        else:\n            print(\"NO\")\n    elif (k - p) * 2 == k:\n        if odd_sum % 2 == 1:\n            for num in arr:\n                if num % 2 == 1:\n                    odd_parts.append(num)\n            print(\"YES\")\n            for part in odd_parts:\n                print(1, part)\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\n\n    return \"\"",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 613,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if a == b:\n        return \"inf\"\n\n    count = 0\n    for n in range(1, 19):\n        for i in range(n + 1):\n            for j in range(n - i + 1):\n                if i * t**(n - 1) + j * a**(n - 1) == b:\n                    count += 1\n                    count %= mod\n\n    return count",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 614,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    items = []\n    for _ in range(n):\n        w, c = map(int, input().split())\n        items.append((w, c))\n\n    items.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    total_cost = 0\n    for w, c in items:\n        if m >= w:\n            m -= w\n            total_cost += c\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 615,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort()\n    P = sum(A[:N // 4])\n    Q = sum(A[N // 4:N // 2])\n    R = sum(A[N // 2:3 * N // 4])\n    S = sum(A[3 * N // 4:])\n    return str(max(P, Q, R, S) - min(P, Q, R, S))",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 616,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, cost):\n        if start == N:\n            return cost\n        if (start, cost) in memo:\n            return memo[(start, cost)]\n\n        result = float('inf')\n        for i in range(M):\n            if b[i] == 0 or boxes[start - 1] in unlocked:\n                continue\n            new_cost = cost + a[i]\n            if new_cost > min_cost:\n                continue\n            for box in boxes[start - 1:start - 1 + b[i]]:\n                unlocked.add(box)\n            result = min(result, dfs(start + 1, new_cost))\n            for box in boxes[start - 1:start - 1 + b[i]]:\n                unlocked.remove(box)\n\n        memo[(start, cost)] = result if result != float('inf') else -1\n        return memo[(start, cost)]\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    a = [0] * M\n    b = [0] * M\n    boxes = [[] for _ in range(N)]\n\n    for i in range(M):\n        a[i], b[i] = map(int, lines[i + 1].split())\n        for j in range(b[i]):\n            box = int(lines[i + 1 + j + 1])\n            boxes[box - 1].append(box)\n\n    min_cost = float('inf')\n    for i in range(M):\n        if b[i] == 0:\n            continue\n        for box in boxes[0:b[i]]:\n            unlocked = set([box])\n            min_cost = min(min_cost, dfs(1, a[i]))\n\n    return str(min_cost) if min_cost != float('inf') else '-1' ",
        "test": "",
        "num_ids": 465,
        "indeed": false
    },
    {
        "number": 617,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_value = float('-inf')\n    for i in range(1, n, 2):\n        if s[i] == '+':\n            left_value = int(s[:i])\n            right_value = int(s[i + 1:])\n            max_value = max(max_value, left_value + right_value)\n        else:\n            for j in range(1, i, 2):\n                for k in range(j + 2, i, 2):\n                    left_value = int(s[:j])\n                    middle_value = int(s[j + 1:k])\n                    right_value = int(s[k + 1:])\n                    max_value = max(max_value, left_value * (middle_value + right_value))\n    return str(max_value)",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 618,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    scales, unused_weights = stdin.split('\\n')\n    left_pan, right_pan = scales.split('|')\n    left_sum = sum(ord(c) for c in left_pan)\n    right_sum = sum(ord(c) for c in right_pan)\n\n    for weight in unused_weights:\n        if left_sum + ord(weight) == right_sum + ord(weight):\n            left_pan += weight\n            left_sum += ord(weight)\n        elif left_sum == right_sum + ord(weight):\n            right_pan += weight\n            right_sum += ord(weight)\n        else:\n            return \"Impossible\"\n\n    return left_pan + '|' + right_pan",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 619,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n\n    max_coconuts = min(x, y) // z\n    min_chizhiks = min(x, y) % z\n\n    return f\"{max_coconuts} {min_chizhiks}\"",
        "test": "",
        "num_ids": 73,
        "indeed": false
    },
    {
        "number": 620,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')]\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    # Calculate the area of the parallelogram\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    # Check if the points form a parallelogram\n    if area == 0:\n        return \"0\\n\"\n\n    # Calculate the coordinates of the fourth point\n    x4 = x3 + (y2 - y1)\n    y4 = y3 - (x2 - x1)\n\n    # Check if the fourth point is inside the parallelogram\n    if (x1 <= x4 <= x2 or x1 >= x4 >= x2) and (y1 <= y4 <= y2 or y1 >= y4 >= y2):\n        return \"1\\n{0} {1}\\n\".format(x4, y4)\n    else:\n        return \"0\\n\"",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 621,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    i = 0\n    j = 0\n    k = 0\n    b = []\n\n    while j < n:\n        while k < 3 and j < n and a[j] >= 0:\n            k += 1\n            j += 1\n        b.append(k)\n        i += k\n        j += 1\n        k = 0\n\n    return f\"{len(b)}\\n{' '.join(map(str, b))}\"",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 622,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        new_sequence = sequence + [i + 2] + sequence\n        sequence = new_sequence\n    return str(sequence[k - 1])",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 623,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n\n    minutes = 0\n    while a_1 > 0 and a_2 > 0:\n        a_1 -= 2\n        a_2 -= 2\n        minutes += 1\n\n        if a_1 <= 0 or a_2 <= 0:\n            break\n\n        a_1 += 1\n        a_2 += 1\n\n    return str(minutes)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 624,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[0].split())\n    powers = list(map(int, stdin.split()[1].split()))\n\n    # Calculate the initial average power\n    initial_average = sum(powers) / n\n\n    # Calculate the maximum possible average power\n    maximum_average = sum(sorted(powers, reverse=True)[:n - 1]) / (n - 1)\n\n    # Calculate the minimum possible average power\n    minimum_average = sum(sorted(powers)[:n - 1]) / (n - 1)\n\n    # If the maximum possible average power is less than the minimum possible average power,\n    # then it means that we cannot increase the power of any superhero,\n    # so the answer is the initial average power\n    if maximum_average < minimum_average:\n        return initial_average\n\n    # If the maximum possible average power is greater than or equal to the minimum possible average power,\n    # then we can increase the power of some superheroes\n    else:\n        # Calculate the number of operations needed to reach the maximum possible average power\n        operations = sum(sorted(powers, reverse=True)[:n - 1]) - sum(sorted(powers)[:n - 1])\n\n        # If the number of operations needed is greater than the total maximum number of operations,\n        # then it means that we cannot reach the maximum possible average power,\n        # so the answer is the initial average power\n        if operations > m:\n            return initial_average\n\n        # If the number of operations needed is less than or equal to the total maximum number of operations,\n        # then we can reach the maximum possible average power\n        else:\n            # Calculate the remaining number of operations after reaching the maximum possible average power\n            remaining_operations = m - operations\n\n            # Calculate the number of superheroes whose power can be increased\n            increase_count = min(n - 1, remaining_operations // k)\n\n            # Calculate the final average power\n            final_average = (sum(sorted(powers, reverse=True)[:n - 1]) + increase_count * k) / n\n\n            return final_average",
        "test": "",
        "num_ids": 525,
        "indeed": false
    },
    {
        "number": 625,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result -= i\n        else:\n            result += i\n    return str(result)",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 626,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a))\n    changes = 0\n    i = 0\n    while i < n:\n        if a[i] == 0:\n            i += 1\n        else:\n            changes += 1\n            for j in range(i + 1, i + a[i] + 1):\n                if j >= n:\n                    break\n                if a[j] == 0:\n                    i = j + 1\n                    break\n            else:\n                return -1  # Impossible to collect all information\n    return changes",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 627,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if n == 2:\n        return s[0]\n\n    for i in range(1, n - 1):\n        if s[i] < s[i - 1]:\n            return s[:i] + s[i + 1:]\n\n    return s[:-1]\n",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 628,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    books = list(map(int, stdin.split()))\n    books.sort(reverse=True)\n\n    shelves = [0] * k\n    for i in range(n):\n        shelves[i % k] ^= books[i]\n\n    return max(shelves)",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 629,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [list(map(int, row.split())) for row in stdin.split('\\n')[1:n+1]]\n    b = list(map(int, stdin.split('\\n')[n+1].split()))\n\n    total_time = sum(b)\n    for i in range(n):\n        total_time += a[0][i] + a[1][i]\n\n    return str(total_time)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 630,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def dfs(i: int) -> set:\n        if i == 0:\n            return {0}\n        seen = set()\n        seen.add(i)\n        for j in range(i - k, i):\n            if j >= 0 and a[j] < i:\n                seen |= dfs(a[j])\n        return seen\n\n    result = []\n    for i in range(n):\n        result.append(len(dfs(i)))\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 631,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_sum(a: List[int], n: int, m: int) -> bool:\n        total_sum = 0\n        for i in range(1, n + 1):\n            inner_sum = 0\n            for j in range(i, n + 1):\n                inner_sum += a[j - 1] / j\n            total_sum += inner_sum\n        return total_sum == m\n\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def find_reorder(a: List[int], n: int, m: int) -> str:\n        sorted_a = merge_sort(a)\n        if compute_sum(sorted_a, n, m):\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        output.append(find_reorder(a, n, m))\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 475,
        "indeed": false
    },
    {
        "number": 632,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(n: int) -> int:\n        for i in range(2, n):\n            if n % i == 0:\n                return i\n        return n\n\n    def add_f_to_n(n: int, k: int) -> int:\n        for _ in range(k):\n            n += f(n)\n        return n\n\n    t = int(stdin.split('\\n')[0])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:t + 1]]\n\n    result = []\n    for n, k in queries:\n        result.append(add_f_to_n(n, k))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 633,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n, m = map(int, stdin.split())\n\n    if n % 2 == 0 and m > n:\n        return \"Impossible\"\n\n    if n % 2 == 1:\n        edges = []\n        for i in range(1, n // 2 + 1):\n            edges.append((i, n - i + 1))\n        edges.append((n // 2 + 1, n // 2 + 1))\n        for i in range(n // 2 + 2, n + 1):\n            edges.append((i, i - n // 2))\n    else:\n        edges = []\n        for i in range(1, n // 2 + 1):\n            edges.append((i, n - i + 1))\n        for i in range(n // 2 + 1, n + 1):\n            edges.append((i, i - n // 2))\n\n    if len(edges) != m:\n        return \"Impossible\"\n\n    output = [\"Possible\"]\n    for edge in edges:\n        output.append(f\"{edge[0]} {edge[1]}\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 317,
        "indeed": false
    },
    {
        "number": 634,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.readline().split())\n    reclaimed = set()\n    for _ in range(n):\n        r_i, c_i = map(int, stdin.readline().split())\n        reclaimed.add((r_i, c_i))\n\n    def is_valid(row, col):\n        return (row, 3 - col) not in reclaimed\n\n    def find_valid_cells():\n        valid_cells = []\n        for row in range(1, r + 1):\n            for col in range(1, 3):\n                if is_valid(row, col):\n                    valid_cells.append((row, col))\n        return valid_cells\n\n    valid_cells = find_valid_cells()\n    if not valid_cells:\n        return \"LOSE\"\n\n    for cell in valid_cells:\n        row, col = cell\n        reclaimed.add(cell)\n        if not find_valid_cells():\n            return \"WIN\"\n        reclaimed.remove(cell)\n\n    return \"LOSE\"",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 635,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    if a[0] == 1 and b[n - 1] == 1:\n        return \"YES\"\n    elif a[s - 1] == 1 and b[0] == 1:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 636,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort()\n\n    m = 0\n    instruments = []\n\n    for i in range(n):\n        if k >= a[i]:\n            k -= a[i]\n            instruments.append(i + 1)\n            m += 1\n\n    return f\"{m}\\n{' '.join(map(str, instruments))}\"",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 637,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, arr = map(int, stdin.split())\n    arr = list(map(int, arr))\n    if all(x == 1 for x in arr):\n        return \"YES\"\n    for i in range(1, n):\n        if arr[i] != arr[i - 1]:\n            if n % i != 0:\n                return \"NO\"\n            for j in range(i, n, i):\n                if arr[j] == arr[j - i]:\n                    return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 638,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, input().split()))\n    result = [0] * n\n\n    for i in range(n):\n        time_left = M\n        j = i\n        while j < n and time_left >= t[j]:\n            time_left -= t[j]\n            j += 1\n        result[i] = j - i\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 639,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n\n    if x == 0:\n        return str(n - len(set(arr)))\n\n    if n == 1:\n        return str(1 if arr[0] != x else 0)\n\n    if arr[0] > x:\n        return \"0\"\n\n    if arr[-1] < x:\n        return str(1)\n\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] > 1:\n            return str(arr[i] - arr[i - 1] - 1)\n\n    return \"0\"",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 640,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_ways = 0\n    first_player_wins = 0\n    second_player_wins = 0\n    draws = 0\n\n    for i in range(1, 7):\n        total_ways += 1\n        if abs(a - i) < abs(b - i):\n            first_player_wins += 1\n        elif abs(a - i) > abs(b - i):\n            second_player_wins += 1\n        else:\n            draws += 1\n\n    return f\"{first_player_wins} {draws} {second_player_wins}\"",
        "test": "",
        "num_ids": 165,
        "indeed": true
    },
    {
        "number": 641,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    days_of_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    if 'of week' in stdin:\n        day_of_week = days_of_week.index(stdin.split()[0])\n        return str(52) if day_of_week == 4 else str(53)\n    else:\n        day_of_month = int(stdin.split()[0])\n        return str(sum(1 for month in days_of_month if month >= day_of_month))",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 642,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    dirty_stairs = set(map(int, stdin.split()[2:]))\n\n    if n in dirty_stairs:\n        return \"NO\"\n\n    for i in range(1, n):\n        if i not in dirty_stairs and i + 1 not in dirty_stairs and i + 2 not in dirty_stairs:\n            continue\n        else:\n            return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 643,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    t = int(stdin.split('\\n', 1)[0])\n    result = []\n\n    for i in range(t):\n        x, y, p, q = map(int, stdin.split('\\n')[i + 1].split())\n        if x == y:\n            result.append(-1)\n        else:\n            l = lcm(q, y)\n            result.append((p * l) // q)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 644,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    x = 0\n    stack = []\n\n    for line in lines:\n        if line == \"add\":\n            x += 1\n            if x > 2 ** 32 - 1:\n                return \"OVERFLOW!!!\"\n        elif line.startswith(\"for\"):\n            stack.append(int(line[3:]))\n        else:\n            n = stack.pop()\n            for _ in range(n):\n                if \"add\" in lines:\n                    x += 1\n                    if x > 2 ** 32 - 1:\n                        return \"OVERFLOW!!!\"\n\n    return str(x)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 645,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    even_digits = {'0', '2', '4', '6', '8'}\n    cards = stdin\n    min_cards = 0\n\n    for i in range(len(cards)):\n        if cards[i] in vowels:\n            if i % 2 == 0:\n                min_cards += 1\n            else:\n                if cards[i + 1] not in even_digits:\n                    min_cards += 1\n\n    return str(min_cards)",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 646,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def check_distance(t, n, x, y):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(x[i], y[i], x[j], y[j]) > t:\n                    return False\n        return True\n\n    def binary_search(n, x, y):\n        left, right = 0, 1000000000\n        while left <= right:\n            mid = (left + right) // 2\n            if check_distance(mid, n, x, y):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left if left < 1000000000 else -1\n\n    n = int(stdin.readline().strip())\n    x, y = [], []\n    for _ in range(n):\n        x_i, y_i = map(int, stdin.readline().strip().split())\n        x.append(x_i)\n        y.append(y_i)\n\n    result = binary_search(n, x, y)\n    return str(result)",
        "test": "",
        "num_ids": 317,
        "indeed": false
    },
    {
        "number": 647,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = stdin.split('\\n')[1]\n\n    left_handed_students = [i + 1 for i, student in enumerate(students) if student == 'L']\n    right_handed_students = [i + 1 for i, student in enumerate(students) if student == 'R']\n\n    output = []\n    for i in range(n // 2):\n        if i % 2 == 0:\n            output.append((left_handed_students[i], right_handed_students[i]))\n        else:\n            output.append((right_handed_students[i], left_handed_students[i]))\n\n    return '\\n'.join([' '.join(map(str, pair)) for pair in output])",
        "test": "",
        "num_ids": 200,
        "indeed": false
    },
    {
        "number": 648,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    max_bananas = 0\n\n    for x in range(1001):\n        for y in range(1001):\n            if y <= -x/m + b:\n                max_bananas = max(max_bananas, x + y)\n\n    return str(max_bananas)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 649,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    total_cells = 0\n    for i in range(n):\n        total_cells += 2 ** i * (t[i] + 1)\n    return str(total_cells)",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 650,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    if len(stdin) == 1:\n        return \"YES\" if stdin in vowels else \"NO\"\n    elif len(stdin) == 2:\n        return \"YES\" if stdin[0] in vowels and stdin[1] in vowels else \"NO\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 651,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    maze = []\n    for _ in range(n):\n        maze.append(stdin.readline().strip())\n    instructions = stdin.readline().strip()\n\n    def is_valid_move(x, y, direction):\n        if direction == 'D':\n            return 0 <= x < n and maze[x][y] != '#' and maze[x][y] != 'E'\n        elif direction == 'U':\n            return 0 <= x < n and maze[x][y] != '#' and maze[x][y] != 'E'\n        elif direction == 'L':\n            return 0 <= y < m and maze[x][y] != '#' and maze[x][y] != 'E'\n        elif direction == 'R':\n            return 0 <= y < m and maze[x][y] != '#' and maze[x][y] != 'E'\n\n    def find_valid_mappings(instructions, x, y, mapping):\n        if not instructions:\n            return 1\n\n        direction = mapping[int(instructions[0])]\n        if is_valid_move(x, y, direction):\n            if direction == 'D':\n                x += 1\n            elif direction == 'U':\n                x -= 1\n            elif direction == 'L':\n                y -= 1\n            elif direction == 'R':\n                y += 1\n\n            if maze[x][y] == 'E':\n                return 1\n            else:\n                return find_valid_mappings(instructions[1:], x, y, mapping)\n        else:\n            return 0\n\n    valid_mappings = 0\n    for direction_0 in 'UDLR':\n        for direction_1 in 'UDLR':\n            if direction_1 != direction_0:\n                for direction_2 in 'UDLR':\n                    if direction_2 not in [direction_0, direction_1]:\n                        for direction_3 in 'UDLR':\n                            if direction_3 not in [direction_0, direction_1, direction_2]:\n                                mapping = {0: direction_0, 1: direction_1, 2: direction_2, 3: direction_3}\n                                valid_mappings += find_valid_mappings(instructions, maze.index('S'), maze[0].index('S'), mapping)\n\n    return str(valid_mappings)",
        "test": "",
        "num_ids": 599,
        "indeed": false
    },
    {
        "number": 652,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_parallel(a, b, c, d):\n        return (a[0] - b[0]) * (c[1] - d[1]) == (a[1] - b[1]) * (c[0] - d[0])\n\n    def is_between(a, b, c):\n        return a[0] <= c[0] <= b[0] or a[0] >= c[0] >= b[0]\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_parallel(points[i], points[j], points[k], points[(k + 1) % n]) and is_between(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 258,
        "indeed": false
    },
    {
        "number": 653,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    events = stdin.split('\\n')[1]\n    rooms = [0] * 10\n\n    for event in events:\n        if event == 'L':\n            for i in range(10):\n                if rooms[i] == 0:\n                    rooms[i] = 1\n                    break\n        elif event == 'R':\n            for i in range(9, -1, -1):\n                if rooms[i] == 0:\n                    rooms[i] = 1\n                    break\n        else:\n            rooms[int(event)] = 0\n\n    return ''.join(map(str, rooms))",
        "test": "",
        "num_ids": 168,
        "indeed": true
    },
    {
        "number": 654,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n    max_matching = 1\n\n    for i in range(1, n + 1):\n        max_matching = (max_matching * (2 * i + 1)) % MOD\n\n    return str(max_matching)\n",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 655,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n\n    if x == 1 or y == 1 or x == n or y == n:\n        return \"Black\"\n    else:\n        return \"White\"\n\n    # Read input\n    n = int(input())\n    x, y = map(int, input().split())\n\n    # Determine the winner\n    if x == 1 or y == 1 or x == n or y == n:\n        print(\"Black\")\n    else:\n        print(\"White\")",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 656,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    temperatures = list(map(int, stdin.split()[1].split()))\n\n    winter_days = 0\n    for temp in temperatures:\n        if temp >= 0:\n            winter_days += 1\n\n    if winter_days <= k:\n        return str(0)\n\n    changes = 0\n    days_left = k\n    for temp in temperatures:\n        if temp < 0:\n            days_left = k\n            changes += 1\n        else:\n            days_left -= 1\n            if days_left == 0:\n                changes += 1\n                days_left = k\n\n    return str(changes)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 657,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, x, y, z = map(int, stdin.split())\n\n    yellow_crystals = max(0, x - 2 * A)\n    green_crystals = max(0, y - A - B)\n    blue_crystals = max(0, z - 3 * B)\n\n    return str(yellow_crystals + green_crystals + blue_crystals)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 658,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_polygon(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(1, n + 1):\n            p2 = polygon[i % n]\n            if point[1] > min(p1[1], p2[1]):\n                if point[1] <= max(p1[1], p2[1]):\n                    if point[0] <= max(p1[0], p2[0]):\n                        if p1[1] != p2[1]:\n                            x_intersect = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n                            if p1[0] == p2[0] or point[0] <= x_intersect:\n                                inside = not inside\n            p1 = p2\n        return inside\n\n    def find_min_time(n, w, v, u, bus_polygon):\n        t = 0\n        while True:\n            pedestrian_position = (0, t * u)\n            if pedestrian_position[1] > w:\n                break\n            if is_inside_polygon(pedestrian_position, bus_polygon):\n                t += 1\n            else:\n                t += v\n                break\n        return t\n\n    input_data = list(map(int, stdin.split()))\n    n, w, v, u = input_data[0], input_data[1], input_data[2], input_data[3]\n    bus_polygon = [(x, y) for x, y in [tuple(map(int, input_data[4 + i].split())) for i in range(n)]]\n\n    min_time = find_min_time(n, w, v, u, bus_polygon)\n    return f\"{min_time:.10f}\"",
        "test": "",
        "num_ids": 481,
        "indeed": false
    },
    {
        "number": 659,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1 or sorted(a) == a or sorted(a, reverse=True) == a:\n        return \"-1\"\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            return f\"{i + 1} {i + 2}\"\n\n    return f\"{n} {n - 1}\"",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 660,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    bottles = 0\n    towels = 0\n    while n > 1:\n        k = 1\n        while 2 ** k <= n:\n            k += 1\n        k -= 1\n        participants = 2 ** k\n        if participants // 2 <= n - participants:\n            n -= participants // 2\n        else:\n            n -= participants\n        bottles += participants * b + k * b\n        towels += participants * p\n    bottles += n * b\n    towels += n * p\n    return f\"{bottles} {towels}\"",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 661,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if M == 0:\n        return \"0 0\"\n    elif M == 1:\n        return \"0 0 1 1\"\n    else:\n        return \"-1\"\n\ndef",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 662,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    players = [int(x) for x in stdin.split('\\n')[1:]]\n\n    if n == 1:\n        return 'YES'\n\n    for i in range(1, n):\n        if players[i] == players[i - 1]:\n            return 'NO'\n\n    return 'YES'",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 663,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_prime, y_prime = map(int, stdin.split())\n\n    if x == x_prime and y == y_prime:\n        return \"0\"\n\n    dx, dy = x_prime - x, y_prime - y\n    distance = (dx ** 2 + dy ** 2) ** 0.5\n\n    if distance > 2 * r:\n        return \"-1\"\n\n    if distance == 2 * r:\n        return \"1\"\n\n    if distance <= r:\n        return \"2\"\n\n    return \"3\"",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 664,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    if sorted(arr) != arr:\n        return -1\n\n    count = 0\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            count += arr[i + 1:].index(arr[i]) + 1\n            arr = arr[:i + 1] + [arr[i]] + arr[i + 1:]\n\n    return count",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 665,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(t):\n        n, s = map(int, stdin.split('\\n')[i * 2 + 1].split())\n        a = list(map(int, stdin.split('\\n')[i * 2 + 2].split()))\n\n        total_time = sum(a)\n        if total_time <= s:\n            result.append(0)\n        else:\n            skip_index = -1\n            max_gifts = 0\n            for j in range(n):\n                if total_time - a[j] <= s:\n                    gifts = j + 1\n                    if gifts > max_gifts:\n                        max_gifts = gifts\n                        skip_index = j\n            result.append(skip_index + 1)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 666,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    current_number = 1\n    current_position = 1\n    result = 0\n\n    while current_position <= n:\n        if current_position == n:\n            result = current_number\n        current_position += 1\n        current_number += 1\n\n    return str(result)\n",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 667,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    graph = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    max_length = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                shortest_path = find_shortest_path(graph, i, j)\n                if shortest_path > max_length:\n                    max_length = shortest_path\n\n    return str(max_length)\n\ndef",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 668,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    if sum(a) < n - 1:\n        return \"-1\"\n\n    k = n - 1\n    res = []\n\n    for i in range(2, n + 1):\n        res.append((1, i))\n\n    for i in range(2, n + 1):\n        for j in range(i + 1, n + 1):\n            if a[i - 1] > 0 and a[j - 1] > 0:\n                res.append((i, j))\n                a[i - 1] -= 1\n                a[j - 1] -= 1\n\n    return f\"{k}\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in res)",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 669,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    result = 0\n    for i in range(n):\n        result += a[i]\n        if result % m == 0:\n            return str(result)\n    return str(result % m)",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 670,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, x1, y1, x2, y2 = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_on_avenue(x, y):\n        return a * x + b * y + c == 0\n\n    def min_distance(x1, y1, x2, y2):\n        if is_on_avenue(x1, y1) and is_on_avenue(x2, y2):\n            return distance(x1, y1, x2, y2)\n        else:\n            min_dist = float('inf')\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if is_on_avenue(x, y):\n                        min_dist = min(min_dist, distance(x1, y1, x, y) + distance(x, y, x2, y2))\n            return min_dist\n\n    return f\"{min_distance(x1, y1, x2, y2):.10f}\"",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 671,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    num = 1\n    while count < n:\n        count += len(str(num))\n        num += 1\n    num -= 1\n    return str(num)[n - count - 1]",
        "test": "",
        "num_ids": 65,
        "indeed": true
    },
    {
        "number": 672,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % b == 0:\n        return \"infinity\"\n    else:\n        count = 0\n        for i in range(1, b + 1):\n            if (a + i) % b == 0:\n                count += 1\n        return count ",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 673,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k - n % k\n    return str(x)",
        "test": "",
        "num_ids": 34,
        "indeed": true
    },
    {
        "number": 674,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_most_frequent(substring: str, string: str) -> bool:\n        substring_count = string.count(substring)\n        for s in strings:\n            if s != substring and string.count(s) >= substring_count:\n                return False\n        return True\n\n    def find_good_strings(strings: List[str]) -> List[str]:\n        good_strings = []\n        for string in strings:\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring = string[i:j]\n                    if is_most_frequent(substring, string):\n                        good_strings.append(substring)\n        return good_strings\n\n    good_strings = find_good_strings(strings)\n\n    if not good_strings:\n        return \"NO\"\n\n    min_length = min(len(s) for s in good_strings)\n    min_length_good_strings = [s for s in good_strings if len(s) == min_length]\n\n    return min(min_length_good_strings)\n",
        "test": "",
        "num_ids": 302,
        "indeed": false
    },
    {
        "number": 675,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[0].split())\n    w = list(map(int, stdin.split()[1].split()))\n\n    # Check if it's possible to make at least r candles burn during each visit\n    for i in range(m):\n        if i == 0:\n            if w[i] < t + 1:\n                return \"-1\"\n        else:\n            if w[i] - w[i - 1] < t + 1:\n                return \"-1\"\n\n    # Calculate the minimum number of candles needed\n    min_candles = 0\n    for i in range(m):\n        if i == 0:\n            min_candles += w[i] // t\n        else:\n            min_candles += (w[i] - w[i - 1]) // t\n\n    return str(min_candles)",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 676,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(mean, median, range_):\n        return mean == median == range_\n\n    def find_missing_boxes(a, n):\n        missing_boxes = []\n        for i in range(4 - n):\n            missing_boxes.append(a[i])\n        return missing_boxes\n\n    def find_solution(a, n):\n        a.sort()\n        mean = sum(a) / len(a)\n        median = (a[n - 1] + a[n]) / 2\n        range_ = a[-1] - a[0]\n\n        if is_valid(mean, median, range_):\n            return find_missing_boxes(a, n)\n        else:\n            return None\n\n    n = int(stdin.readline().strip())\n    a = [int(stdin.readline().strip()) for _ in range(n)]\n\n    missing_boxes = find_solution(a, n)\n\n    if missing_boxes:\n        return \"YES\\n\" + \"\\n\".join(map(str, missing_boxes))\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 677,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_positive_integer(l, r, d):\n        for x in range(d, r + 1, d):\n            if x not in range(l, r + 1):\n                return x\n        return -1\n\n    queries = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    results = []\n\n    for l, r, d in queries:\n        result = find_min_positive_integer(l, r, d)\n        results.append(result)\n\n    return \"\\n\".join(map(str, results))\n",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 678,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    tux = 0\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n    pur = 0\n\n    for i in range(len(input_list)):\n        tux = input_list[i]\n        pur = i + 1\n        foo = foo + pur\n        bar = bar + 1\n        if (foo * quz) * (bar * baz * quz) == (bar * baz * quz) * (foo * quz):\n            baz = foo\n            quz = bar\n\n    baz = float(baz)\n    quz = float(quz)\n    result = baz / quz\n\n    return f\"{result:.5f}\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 679,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    flowers = stdin.replace('.', '')\n    for i in range(len(flowers)):\n        if 'A' in flowers and 'B' in flowers and 'C' in flowers:\n            return 'Yes'\n        flowers = flowers[1:] + flowers[0]\n    return 'No'",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 680,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_A, y_A, x_B, y_B, x_C, y_C = map(int, stdin.split())\n\n    def is_adjacent(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1]) <= 1\n\n    def find_min_plots(A, B, C):\n        plots = set([A, B, C])\n        min_plots = len(plots)\n        while not all(is_adjacent(p1, p2) for p1 in plots for p2 in plots):\n            plots.add((min(plots)[0] - 1, min(plots)[1]))\n            plots.add((max(plots)[0] + 1, max(plots)[1]))\n            plots.add((max(plots)[0], max(plots)[1] + 1))\n            plots.add((min(plots)[0], min(plots)[1] - 1))\n            min_plots = len(plots)\n        return min_plots\n\n    min_plots = find_min_plots((x_A, y_A), (x_B, y_B), (x_C, y_C))\n    output = f\"{min_plots}\\n\"\n    for plot in sorted(list(set([(x_A, y_A), (x_B, y_B), (x_C, y_C)]))):\n        output += f\"{plot[0]} {plot[1]}\\n\"\n    return output.strip()",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 681,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(N + 1):\n        for j in range(M):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n                dp[i] %= 1000000007\n    return str(dp[N])",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 682,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n\n    # Calculate the number of moves for the rook\n    rook_moves = max(abs(r1 - r2), abs(c1 - c2))\n\n    # Calculate the number of moves for the bishop\n    bishop_moves = abs(r1 - r2) + abs(c1 - c2) - max(abs(r1 - r2), abs(c1 - c2))\n    bishop_moves = max(0, bishop_moves)\n\n    # Calculate the number of moves for the king\n    king_moves = max(abs(r1 - r2), abs(c1 - c2))\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\"",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 683,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    result = 2 ** a\n    return str(result)",
        "test": "",
        "num_ids": 27,
        "indeed": false
    },
    {
        "number": 684,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def find_triangle(a, b, c, d):\n        for x in range(a, b + 1):\n            for y in range(b, c + 1):\n                for z in range(c, d + 1):\n                    if is_valid_triangle(x, y, z):\n                        return x, y, z\n        return None, None, None\n\n    def process_test_case(a, b, c, d):\n        x, y, z = find_triangle(a, b, c, d)\n        return f\"{x} {y} {z}\\n\"\n\n    test_cases = int(stdin.readline().strip())\n    output = \"\"\n    for _ in range(test_cases):\n        a, b, c, d = map(int, stdin.readline().strip().split())\n        output += process_test_case(a, b, c, d)\n    return output",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 685,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.readline().split())\n    ascending_flows = []\n    for _ in range(n):\n        x1, x2 = map(int, stdin.readline().split())\n        ascending_flows.append((x1, x2))\n\n    def can_reach(x: int) -> bool:\n        for x1, x2 in ascending_flows:\n            if x1 <= x < x2:\n                return True\n        return False\n\n    def find_max_distance(start_x: int, end_x: int) -> int:\n        max_distance = 0\n        current_x = start_x\n        while current_x <= end_x:\n            if can_reach(current_x):\n                max_distance = max(max_distance, current_x - start_x)\n                current_x += 1\n            else:\n                current_x += 1\n        return max_distance\n\n    max_distance = 0\n    for i in range(-10**9, 10**9):\n        if can_reach(i):\n            max_distance = max(max_distance, find_max_distance(i, 10**9))\n\n    return str(max_distance)",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 686,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        if x == y:\n            result.append('YES')\n        else:\n            if gcd(x, y) != 1:\n                result.append('NO')\n            else:\n                for p in range(2, x):\n                    if is_prime(p) and x - p * (x // p) == y:\n                        result.append('YES')\n                        break\n                else:\n                    result.append('NO')\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 687,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n\n    if d_a == d_b:\n        return \"-1\"\n\n    a = int(str(d_a) + \"0\" * 9)\n    b = int(str(d_b) + \"0\" * 9)\n\n    if d_a < d_b:\n        a += 1\n    else:\n        b += 1\n\n    return f\"{a} {b}\"",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 688,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, sequence = stdin.split('\\n')\n    t = int(t)\n    sequence = list(map(int, sequence))\n\n    def rotate(digit):\n        if digit == 6:\n            return 9\n        elif digit == 9:\n            return 6\n        elif digit == 2:\n            return 5\n        elif digit == 5:\n            return 2\n        else:\n            return digit\n\n    def construct(sequence, t):\n        if len(sequence) < len(str(t)):\n            return 0\n        if t == 0:\n            return 1\n        if t < 0:\n            return 0\n        if len(str(t)) == 1:\n            return int(t in sequence)\n\n        count = 0\n        for i in range(len(sequence) - len(str(t)) + 1):\n            if sequence[i:i + len(str(t))] == [rotate(int(digit)) for digit in str(t)]:\n                count += 1\n        return count\n\n    return str(construct(sequence, t))",
        "test": "",
        "num_ids": 261,
        "indeed": false
    },
    {
        "number": 689,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(strings: List[str]) -> bool:\n        for i in range(len(strings) - 1):\n            if len(strings[i]) != len(strings[i + 1]):\n                return False\n            for j in range(len(strings[i])):\n                if strings[i][j] != strings[i + 1][j]:\n                    return False\n        return True\n\n    def process_input(stdin: str) -> List[List[str]]:\n        result = []\n        for case in stdin.split(\"\\n\"):\n            if not case:\n                continue\n            strings = []\n            n = int(case.split(\"\\n\")[0])\n            for i in range(1, n + 1):\n                strings.append(case.split(\"\\n\")[i])\n            result.append(strings)\n        return result\n\n    cases = process_input(stdin)\n    output = []\n    for case in cases:\n        if is_possible(case):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 270,
        "indeed": false
    },
    {
        "number": 690,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n\n    while n > 0:\n        digit = n % 10\n        soroban = [\"-\"] * 5\n        soroban[0] = \"|\"\n\n        if digit >= 5:\n            soroban[0] = \"O\"\n            digit -= 5\n\n        for i in range(1, digit + 1):\n            soroban[i] = \"O\"\n\n        result.append(\"\".join(soroban))\n        n //= 10\n\n    return \"\\n\".join(result[::-1])\n",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 691,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n > x:\n        return \"NO\"\n    if n == 1:\n        return \"YES\\n\" + str(x)\n    if n == 2:\n        return \"YES\\n\" + str(x) + \" 0\"\n    result = [0] * n\n    for i in range(n):\n        result[i] = i * (n - i) // 2\n        if result[i] > x:\n            return \"NO\"\n    return \"YES\\n\" + \" \".join(map(str, result))",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 692,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    M = list(map(int, stdin.split('\\n')[1].split()))\n    R = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_days = 0\n    for i in range(N):\n        if R[i] == 0:\n            total_days += M[i]\n        else:\n            total_days += M[i] * (R[i] + 1) // R[i]\n\n    return f\"{total_days / sum(M):.6f}\"",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 693,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    lightsabers = list(map(int, stdin.readline().split()))\n    k_colors = list(map(int, stdin.readline().split()))\n\n    def is_valid_interval(start: int, end: int) -> bool:\n        colors_count = [0] * m\n        for i in range(start, end + 1):\n            colors_count[lightsabers[i] - 1] += 1\n        return colors_count == k_colors\n\n    def binary_search(left: int, right: int) -> int:\n        while left <= right:\n            mid = (left + right) // 2\n            if is_valid_interval(0, mid):\n                return mid\n            elif is_valid_interval(mid + 1, n - 1):\n                return mid + 1\n            elif is_valid_interval(0, right):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    result = binary_search(0, n - 1)\n    return str(result)",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 694,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = map(int, stdin.split())\n    public_key_str = str(public_key)\n\n    for i in range(1, len(public_key_str)):\n        left_part = int(public_key_str[:i])\n        right_part = int(public_key_str[i:])\n\n        if left_part % a == 0 and right_part % b == 0:\n            return \"YES\\n{}\\n{}\".format(left_part, right_part)\n\n    return \"NO\"",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 695,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    if a_1 == a_2:\n        return \"0\"\n    elif a_1 < a_2:\n        return \"1\"\n    else:\n        return \"2\" ",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 696,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    count = 0\n    for x in range(1, p):\n        is_primitive = True\n        for i in range(1, p):\n            if (x ** i) % p == 1:\n                is_primitive = False\n                break\n        if is_primitive:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 697,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_sum = 0\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i + j > n + m:\n                continue\n\n            array = [1] * i + [-1] * j + [0] * (n + m - i - j)\n            prefix_sum = 0\n            max_prefix_sum = 0\n\n            for num in array:\n                prefix_sum += num\n                max_prefix_sum = max(max_prefix_sum, prefix_sum)\n\n            total_sum += max_prefix_sum\n\n    return total_sum % 998244853",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 698,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split()[:2])\n    rounds = [int(num) for round_info in stdin.split('\\n')[1:] if round_info.startswith('2') for num in round_info.split()[1:]]\n    min_missed = max(0, x - max(rounds) - 1)\n    max_missed = min(x - min(rounds) - 1, k)\n    return f\"{min_missed} {max_missed}\"",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 699,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    x_min = max(1, n - y)\n    x_max = min(n - k, y)\n    if x_min > x_max:\n        return \"-1\"\n    return \" \".join(map(str, range(x_min, x_max + 1)))",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 700,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(matrix, times):\n        for i in range(times):\n            matrix = list(zip(*matrix[::-1]))\n        return matrix\n\n    def flip_vertical(matrix):\n        return matrix[::-1]\n\n    def flip_horizontal(matrix):\n        return [row[::-1] for row in matrix]\n\n    def compare_matrices(matrix1, matrix2):\n        for row1, row2 in zip(matrix1, matrix2):\n            if row1 != row2:\n                return False\n        return True\n\n    def find_match(matrix1, matrix2):\n        if compare_matrices(matrix1, matrix2):\n            return True\n\n        for i in range(3):\n            matrix1 = rotate(matrix1, 90)\n            if compare_matrices(matrix1, matrix2):\n                return True\n\n        matrix1 = flip_vertical(matrix1)\n        if compare_matrices(matrix1, matrix2):\n            return True\n\n        for i in range(3):\n            matrix1 = rotate(matrix1, 90)\n            if compare_matrices(matrix1, matrix2):\n                return True\n\n        matrix1 = flip_horizontal(matrix1)\n        if compare_matrices(matrix1, matrix2):\n            return True\n\n        for i in range(3):\n            matrix1 = rotate(matrix1, 90)\n            if compare_matrices(matrix1, matrix2):\n                return True\n\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    matrix1 = [list(lines[i + 1]) for i in range(N)]\n    matrix2 = [list(lines[i + N + 1]) for i in range(N)]\n\n    if find_match(matrix1, matrix2):\n        return 'Yes'\n    else:\n        return 'No'",
        "test": "",
        "num_ids": 457,
        "indeed": false
    },
    {
        "number": 701,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    if sorted(s) != sorted(t):\n        return \"need tree\"\n\n    s_len, t_len = len(s), len(t)\n    for i in range(min(s_len, t_len)):\n        if s[i] != t[i]:\n            if s_len == t_len:\n                return \"both\"\n            elif s_len > t_len:\n                return \"array\"\n            else:\n                return \"automaton\"\n\n    if s_len == t_len:\n        return \"both\"\n    elif s_len > t_len:\n        return \"array\"\n    else:\n        return \"automaton\"",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 702,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[str]], row: int, col: int, size: int) -> bool:\n        for i in range(row, row + size):\n            for j in range(col, col + size):\n                if board[i][j] == \"#\":\n                    return False\n        return True\n\n    def dfs(board: List[List[str]], row: int, col: int, size: int) -> bool:\n        if row + size > n or col + size > n:\n            return False\n\n        for i in range(row, row + size):\n            for j in range(col, col + size):\n                if board[i][j] == \".\":\n                    board[i][j] = \"#\"\n\n        if is_valid(board, row, col, size):\n            if row + 2 * size <= n and col + 2 * size <= n:\n                if dfs(board, row, col + size, size):\n                    return True\n                if dfs(board, row + size, col, size):\n                    return True\n            else:\n                return True\n\n        for i in range(row, row + size):\n            for j in range(col, col + size):\n                if board[i][j] == \"#\":\n                    board[i][j] = \".\"\n\n        return False\n\n    n = int(stdin.readline().strip())\n    board = [list(stdin.readline().strip()) for _ in range(n)]\n\n    if dfs(board, 0, 0, 5):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 392,
        "indeed": false
    },
    {
        "number": 703,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    boxes = 0\n    nuts = a\n    while nuts > 0:\n        boxes += 1\n        if nuts <= k * v:\n            nuts = 0\n        else:\n            nuts -= k * v\n            nuts += k\n    return str(boxes)",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 704,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, r1, c1, r2, c2 = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    def move_up(r, c):\n        if r > 1:\n            return r - 1, c\n        return r, c\n\n    def move_down(r, c):\n        if r < n:\n            return r + 1, c\n        return r, c\n\n    def move_right(r, c):\n        if c < a[r - 1] + 1:\n            return r, c + 1\n        return r, c\n\n    def move_left(r, c):\n        if c > 1:\n            return r, c - 1\n        return r, c\n\n    def count_moves(r1, c1, r2, c2):\n        moves = 0\n        while (r1, c1) != (r2, c2):\n            if r1 > r2:\n                r1, c1 = move_up(r1, c1)\n            elif r1 < r2:\n                r1, c1 = move_down(r1, c1)\n            elif c1 > c2:\n                r1, c1 = move_left(r1, c1)\n            else:\n                r1, c1 = move_right(r1, c1)\n            moves += 1\n        return moves\n\n    return count_moves(r1, c1, r2, c2)",
        "test": "",
        "num_ids": 368,
        "indeed": false
    },
    {
        "number": 705,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    pairs = 0\n    for i in range(n):\n        for j in range(n):\n            if x[i] ^ y[j] in x + y:\n                pairs += 1\n\n    return \"Karen\" if pairs % 2 == 0 else \"Koyomi\"",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 706,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def g(n, x):\n        if n == 0:\n            return x\n        else:\n            return f(g(n - 1, x))\n\n    def f(x):\n        return A * x + B\n\n    result = g(n, x) % MOD\n    return str(result)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 707,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    p = list(map(int, stdin.readline().split()))\n\n    for y in range(1, 10**18):\n        for j in range(1, m + 1):\n            if all(y + p[j - 1] * i in x for i in range(1, n + 1)):\n                return \"YES\\n\" + str(y) + \" \" + str(j)\n\n    return \"NO\"",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 708,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, n):\n        path = [start]\n        for i in range(n - 1):\n            path.append(path[-1] + i + 1)\n        path.append(end)\n        return path\n\n    n, k = map(int, stdin.split()[0].split())\n    a, b, c, d = map(int, stdin.split()[1].split())\n\n    if k < n - 1:\n        return -1\n\n    path_ab = find_path(a, b, n)\n    path_cd = find_path(c, d, n)\n\n    return \" \".join(map(str, path_ab)) + \"\\n\" + \" \".join(map(str, path_cd))\n",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 709,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x <= 1:\n        return str(x)\n    else:\n        return str(solution(x // 2) + 1)",
        "test": "",
        "num_ids": 48,
        "indeed": false
    },
    {
        "number": 710,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    genome = \"ACTG\"\n    count = float('inf')\n\n    for i in range(n - 3):\n        substring = s[i:i + 4]\n        if genome in substring:\n            count = min(count, 4 - i)\n\n    for i in range(n - 3):\n        substring = s[i:i + 4]\n        if genome[::-1] in substring:\n            count = min(count, 4 - i)\n\n    for i in range(n - 3):\n        substring = s[i:i + 4]\n        for j in range(4):\n            if substring[j] == 'A':\n                substring = substring[:j] + 'Z' + substring[j + 1:]\n            elif substring[j] == 'Z':\n                substring = substring[:j] + 'A' + substring[j + 1:]\n            else:\n                substring = substring[:j] + chr(ord(substring[j]) - 1) + substring[j + 1:]\n\n        if genome in substring:\n            count = min(count, 4 - i)\n\n    for i in range(n - 3):\n        substring = s[i:i + 4]\n        for j in range(4):\n            if substring[j] == 'A':\n                substring = substring[:j] + 'Z' + substring[j + 1:]\n            elif substring[j] == 'Z':\n                substring = substring[:j] + 'A' + substring[j + 1:]\n            else:\n                substring = substring[:j] + chr(ord(substring[j]) + 1) + substring[j + 1:]\n\n        if genome in substring:\n            count = min(count, 4 - i)\n\n    return count if count != float('inf') else -1",
        "test": "",
        "num_ids": 463,
        "indeed": false
    },
    {
        "number": 711,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if n == 1:\n        return 1\n\n    if m == 1:\n        return n % mod\n\n    if n == 2:\n        return factorial(m - 1) % mod\n\n    return (pow(factorial(m - 1), n - 1, mod) * factorial(m - n)) % mod\n\ndef",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 712,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    p = int(p * 100)\n    dp = [[0] * (p + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, p + 1):\n            dp[i][j] = dp[i - 1][j] + (dp[i - 1][j - 1] if j > 1 else 0)\n            dp[i][j] /= i\n\n    return f\"{dp[n][p]}\"",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 713,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = [(x, y) for x in range(n + 1) for y in range(m + 1) if x + y > 0]\n    max_size = 0\n    max_set = []\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            if (x1 + y1) == (x2 + y2) or (x1 - y1) == (x2 - y2):\n                continue\n            dist = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n            if dist.is_integer():\n                continue\n            if len(set([points[i], points[j]])) == 2:\n                current_set = [points[i], points[j]]\n                current_size = 2\n                for k in range(j + 1, len(points)):\n                    if len(set(current_set + [points[k]])) == current_size + 1:\n                        dist_1 = ((x1 - points[k][0]) ** 2 + (y1 - points[k][1]) ** 2) ** 0.5\n                        dist_2 = ((x2 - points[k][0]) ** 2 + (y2 - points[k][1]) ** 2) ** 0.5\n                        if not dist_1.is_integer() and not dist_2.is_integer():\n                            current_set.append(points[k])\n                            current_size += 1\n                if current_size > max_size:\n                    max_size = current_size\n                    max_set = current_set\n\n    return f\"{max_size}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in max_set)",
        "test": "",
        "num_ids": 477,
        "indeed": false
    },
    {
        "number": 714,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = sorted([int(i) for i in stdin.split('\\n')[1].split()])\n    output = []\n    for i in range(n // 2):\n        output.append(f\"{cards[i]} {cards[n - i - 1]}\")\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 715,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_great_choice(choice: str, choices: list) -> bool:\n        choice_length = len(choice)\n        min_length = min(len(c) for c in choices)\n        max_length = max(len(c) for c in choices)\n        return choice_length == 2 * min_length or choice_length == 2 * max_length\n\n    lines = stdin.split('\\n')\n    choices = [line.split('.')[1] for line in lines]\n    great_choices = [c for c in choices if is_great_choice(c, choices)]\n\n    if len(great_choices) == 1:\n        return 'A'\n    elif len(great_choices) == 2:\n        return 'B'\n    elif len(great_choices) == 3:\n        return 'C'\n    else:\n        return 'D'",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 716,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, *companies = list(map(int, stdin.split()))\n    cost = abs(a - b)\n    for i in range(1, n):\n        if companies[a - 1] != companies[i]:\n            cost += 1\n        if i < n - 1 and companies[i] != companies[b - 1]:\n            cost += 1\n    return str(cost)",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 717,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    doctors = []\n    for i in range(n):\n        s, d = map(int, stdin.split('\\n')[i+1].split())\n        doctors.append((s, d))\n    \n    last_doctor_day = 0\n    for s, d in doctors:\n        last_doctor_day = max(last_doctor_day, s + (d-1)*d)\n    \n    return str(last_doctor_day)",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 718,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"9\"\n    elif a > 0:\n        return str(8 - a % 10)\n    else:\n        return str(abs(a) % 10 + 1)",
        "test": "",
        "num_ids": 66,
        "indeed": false
    },
    {
        "number": 719,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    perfect_numbers = []\n    i = 1\n    while len(perfect_numbers) < k:\n        if sum(int(digit) for digit in str(i)) == 10:\n            perfect_numbers.append(i)\n        i += 1\n    return str(perfect_numbers[-1])",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 720,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    pairs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    max_draws = 0\n    draws = 0\n    prev_x, prev_y = 0, 0\n\n    for x, y in pairs:\n        if x == y:\n            draws += 1\n        else:\n            max_draws = max(max_draws, draws)\n            draws = 0\n\n        if x != prev_x and y != prev_y:\n            max_draws = max(max_draws, draws)\n            draws = 0\n\n        prev_x, prev_y = x, y\n\n    return str(max_draws + draws)",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 721,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    m = int(stdin.split()[-1])\n\n    a.sort()\n    profit = 0\n    i = 0\n    for _ in range(m):\n        if i < n:\n            profit += a[i]\n            i += 1\n        else:\n            profit -= d\n\n    return str(profit)",
        "test": "",
        "num_ids": 124,
        "indeed": true
    },
    {
        "number": 722,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_year(abbr: str) -> int:\n        y = abbr.split(\"'\")[1]\n        if len(y) == 1:\n            return 1990 + int(y)\n        elif len(y) == 2:\n            return 1990 + int(y)\n        elif len(y) == 3:\n            return 1990 + int(y)\n        elif len(y) == 4:\n            return 1990 + int(y)\n        else:\n            return int(y)\n\n    n = int(stdin.split(\"\\n\")[0])\n    olympiads = stdin.split(\"\\n\")[1:]\n    years = []\n\n    for olympiad in olympiads:\n        years.append(find_year(olympiad))\n\n    return \"\\n\".join(map(str, years))",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 724,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = sorted(list(map(int, input().split())))\n\n    if d == 0:\n        return 0\n\n    min_points_to_remove = n\n    for i in range(n - 1):\n        max_diameter = points[-1] - points[i]\n        if max_diameter <= d:\n            min_points_to_remove = min(min_points_to_remove, n - i - 1)\n        else:\n            break\n\n    return str(min_points_to_remove)",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 725,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    matrix = []\n    for _ in range(n):\n        row = stdin.readline().strip()\n        matrix.append(row)\n\n    colors = set()\n    for row in matrix:\n        colors.update(row)\n\n    if colors.issubset({'W', 'B', 'G'}):\n        return \"#Black&White\"\n    else:\n        return \"#Color\"",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 726,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    count = 0\n\n    for i in range(len(x) - 1):\n        if abs(x[i + 1] - x[i]) >= 2 * d:\n            count += 1\n\n    return count + 1",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 727,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    count = 0\n    while arr:\n        max_count = 1\n        for i in range(1, n):\n            if arr[i] == arr[i - 1]:\n                max_count += 1\n            else:\n                max_count = 1\n            if max_count > count:\n                count = max_count\n        for i in range(count):\n            arr.pop(0)\n        n -= count\n        count = 0\n\n    return str(n)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 728,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    votes = [int(x) for x in stdin.split('\\n')[1].split()]\n    votes[0] += 1\n    votes.sort(reverse=True)\n    bribes = 0\n    for i in range(1, n):\n        if votes[i] >= votes[0]:\n            bribes += i\n            votes[i] -= 1\n        else:\n            break\n    return str(bribes)",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 729,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char, count in char_count.items():\n        if count > n / 2:\n            return \"NO\"\n\n    return \"YES\"\n",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 730,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    rows = 4\n    seats_per_row = 3\n    total_seats = rows * seats_per_row\n    bus = [['#' for _ in range(total_seats)] for _ in range(rows)]\n\n    for i in range(k):\n        row = (i // seats_per_row) + 1\n        col = (i % seats_per_row) + 1\n        bus[row - 1][(col - 1) * 2] = 'O'\n\n    output = '+------------------------+\\n'\n    for row in bus:\n        output += '|'\n        for seat in row:\n            output += seat\n        output += '|\\n'\n    output += '+------------------------+\\n'\n\n    return output",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 731,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    n = 0\n    while True:\n        if n * k <= w:\n            n += 1\n        else:\n            break\n    return str(n + m - 1)",
        "test": "",
        "num_ids": 63,
        "indeed": false
    },
    {
        "number": 732,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        if \"0\" not in str(i):\n            if len(set(str(i))) == 2:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 733,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = set(range(x, b + 1, x))\n    pink_bricks = set(range(y, b + 1, y))\n    common_bricks = red_bricks.intersection(pink_bricks)\n    count = sum(1 for brick in common_bricks if a <= brick <= b)\n    return str(count)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 734,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    blocks = list(map(int, stdin.split()))\n\n    # Calculate the maximum number of blocks that can be removed from each stack\n    max_removable = [min(blocks[i], m - sum(blocks[:i])) for i in range(n)]\n\n    # Calculate the total number of removable blocks\n    total_removable = sum(max_removable)\n\n    return str(total_removable)",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 735,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    def reverse_segment(arr, start, end):\n        return arr[:start] + arr[start:end + 1][::-1] + arr[end + 1:]\n\n    for i in range(n):\n        for j in range(i, n):\n            if is_sorted(reverse_segment(a, i, j)):\n                return \"yes\\n\" + str(i + 1) + \" \" + str(j + 1)\n\n    return \"no\"",
        "test": "",
        "num_ids": 194,
        "indeed": true
    },
    {
        "number": 736,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m == 0:\n        return \"0\"\n    if n % 2 == 0:\n        return str(n // 2)\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 63,
        "indeed": false
    },
    {
        "number": 737,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N % 4 == 0:\n        return str(N * 2)\n    elif N % 2 == 0:\n        return str(N + 2)\n    else:\n        return str(N + 1)",
        "test": "",
        "num_ids": 68,
        "indeed": false
    },
    {
        "number": 738,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n    for x in range(A, B + 1):\n        for y in range(x, C + 1):\n            for z in range(y, D + 1):\n                if x + y > z and x + z > y and y + z > x:\n                    count += 1\n    return str(count)",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 739,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    s = A + B * (L - 1)\n    d = s - A\n    n = (L * (s + A) + d) // 2\n    concatenated = n // M\n    return str(concatenated)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 740,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    time_wash = k * t_1\n    time_dry = k * t_2\n    time_fold = k * t_3\n\n    time_wash_dry = time_wash + time_dry\n    time_dry_fold = time_dry + time_fold\n\n    time_total = max(time_wash_dry, time_dry_fold)\n\n    return str(time_total)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 741,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def total_time_lit(program):\n        total_time = 0\n        for i in range(len(program) - 1):\n            total_time += program[i + 1] - program[i]\n        return total_time\n\n    max_time_lit = total_time_lit(a)\n\n    for i in range(len(a) - 1):\n        for x in range(a[i] + 1, a[i + 1]):\n            program = a[:i] + [x] + a[i:]\n            time_lit = total_time_lit(program)\n            if time_lit > max_time_lit:\n                max_time_lit = time_lit\n\n    for x in range(1, a[0]):\n        program = [x] + a\n        time_lit = total_time_lit(program)\n        if time_lit > max_time_lit:\n            max_time_lit = time_lit\n\n    for x in range(a[-1] + 1, M):\n        program = a + [x]\n        time_lit = total_time_lit(program)\n        if time_lit > max_time_lit:\n            max_time_lit = time_lit\n\n    return str(max_time_lit)",
        "test": "",
        "num_ids": 349,
        "indeed": false
    },
    {
        "number": 742,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_permutation(b: List[int]) -> List[int]:\n        n = len(b)\n        a = [0] * (2 * n)\n        for i in range(n):\n            a[2 * i] = b[i] - 1\n        for i in range(n - 1, -1, -1):\n            a[2 * i + 1] = min(a[2 * i - 1], a[2 * i]) + 1\n        return a\n\n    def is_valid_permutation(a: List[int]) -> bool:\n        for i in range(1, len(a), 2):\n            if a[i] <= a[i - 1]:\n                return False\n        return True\n\n    def find_lexicographically_minimal_permutation(b: List[int]) -> List[int]:\n        a = find_permutation(b)\n        if is_valid_permutation(a):\n            return a\n        else:\n            return [-1]\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        b = list(map(int, stdin.readline().strip().split()))\n        result = find_lexicographically_minimal_permutation(b)\n        output.append(\" \".join(map(str, result)))\n\n    return \"\\n\".join(output) ",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 743,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n    x.sort()\n    sum = 0\n    for i in range(1, n):\n        sum += x[i] - x[0]\n    return str(sum)",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 744,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    flights = stdin.split('\\n')[1]\n    seattle_to_sf = flights.count('S')\n    sf_to_seattle = n - seattle_to_sf\n    if seattle_to_sf > sf_to_seattle:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 745,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    def count_ways(n: int, k: int) -> int:\n        if k == 0:\n            return pow(n, n, mod)\n\n        total_ways = 0\n        for i in range(n):\n            ways = count_ways(n - 1, k - i)\n            total_ways += ways\n            total_ways %= mod\n\n        return total_ways\n\n    return str(count_ways(n, k))",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 746,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split()[0:3])\n    cars = []\n    for i in range(n):\n        x, y, v = map(int, stdin.split()[3 * i + 3:3 * i + 6])\n        cars.append((x, y, v))\n\n    min_time = float('inf')\n    for car in cars:\n        x, y, v = car\n        time = abs(a - x) + abs(b - y)\n        time /= v\n        min_time = min(min_time, time)\n\n    return f\"{min_time:.10f}\"",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 747,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.readline().split())\n    sweets = []\n    for i in range(n):\n        t, h, m = map(int, stdin.readline().split())\n        sweets.append((t, h, m))\n\n    sweets.sort(key=lambda x: x[1])\n    last_type = -1\n    total_mass = 0\n    for t, h, m in sweets:\n        if t != last_type:\n            total_mass += m\n            last_type = t\n        else:\n            continue\n\n        if h > x + total_mass:\n            break\n\n    return str(len(sweets) - 1)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 748,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    def is_valid_partition(partition):\n        for group in partition:\n            if group[0] >= group[1] or group[1] >= group[2]:\n                return False\n            if group[0] != group[1] // group[0] or group[1] != group[2] // group[1]:\n                return False\n        return True\n\n    def print_partition(partition):\n        return '\\n'.join([' '.join(map(str, group)) for group in partition])\n\n    def backtrack(start, partition):\n        if len(partition) == n // 3:\n            if is_valid_partition(partition):\n                return print_partition(partition)\n            return -1\n\n        for i in range(start, len(sequence)):\n            if i > 0 and sequence[i] == sequence[i - 1]:\n                continue\n            if len(partition) == 0 or sequence[i] > partition[-1][-1]:\n                partition.append([sequence[i]])\n                if backtrack(i + 1, partition) != -1:\n                    return print_partition(partition)\n                partition.pop()\n\n        return -1\n\n    return backtrack(0, [])",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 749,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    for k in range(1, n + 1):\n        for c in s:\n            if all(c in s[i:i + k] for i in range(n - k + 1)):\n                return k",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 750,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red = ceil(2 * n / k)\n    green = ceil(5 * n / k)\n    blue = ceil(8 * n / k)\n    return str(red + green + blue)\n\ndef",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 751,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    groups = list(map(int, stdin.split()[2:]))\n    buses = 0\n    while groups:\n        bus = [0] * m\n        for i in range(len(groups)):\n            if sum(bus) + groups[i] <= m:\n                bus = bus + [groups[i]]\n                groups[i] = 0\n        buses += 1\n        groups = [x for x in groups if x != 0]\n    return str(buses)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 752,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [stdin.readline().strip() for _ in range(n)]\n    b = [stdin.readline().strip() for _ in range(n)]\n\n    count = 0\n    for i in range(n):\n        if a[i] != b[i]:\n            count += 1\n\n    return count",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 753,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    total_screen_size = a * b\n    movie_size = c * d\n    empty_screen = total_screen_size - movie_size\n    p, q = empty_screen, total_screen_size\n    while q != 1:\n        p, q = p % q, q\n    return f\"{p}/{q}\"",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 754,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    count = 0\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 73,
        "indeed": true
    },
    {
        "number": 755,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    steps = 0\n    while x > 0:\n        if x >= 5:\n            x -= 5\n        elif x >= 4:\n            x -= 4\n        elif x >= 3:\n            x -= 3\n        elif x >= 2:\n            x -= 2\n        else:\n            x -= 1\n        steps += 1\n    return str(steps)",
        "test": "",
        "num_ids": 105,
        "indeed": true
    },
    {
        "number": 756,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    t = list(map(int, stdin.split('\\n')[1].split()))\n    t.sort()\n    boring = [False] * 90\n    for i in range(n):\n        boring[t[i] - 1] = True\n    for i in range(90):\n        if not boring[i]:\n            continue\n        if i + 14 < 90 and all(boring[j] for j in range(i, i + 15)):\n            return str(i + 1)\n    return str(90)",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 757,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n    a.sort(reverse=True)\n\n    total_sockets = k\n    for i in range(n):\n        total_sockets += a[i]\n        if total_sockets >= m:\n            return str(i + 1)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 758,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    operations = 0\n\n    while s.count('B') > 0:\n        if s[n - 1] == 'R':\n            s.pop()\n            s[n - 2] = 'R'\n            operations += 1\n        else:\n            s[n - 1] = 'R'\n            operations += 1\n\n    return str(operations)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 759,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm, H, D, C, N = map(int, stdin.split())\n    time_in_minutes = hh * 60 + mm\n    hunger_increase = time_in_minutes * D\n    total_hunger = H + hunger_increase\n\n    if total_hunger <= 0:\n        return \"{:.3f}\".format(0)\n\n    buns_per_visit = N * C\n    visits = total_hunger // buns_per_visit\n    remaining_hunger = total_hunger % buns_per_visit\n\n    if remaining_hunger > 0:\n        visits += 1\n\n    total_cost = visits * C\n\n    if time_in_minutes >= 20 * 60:\n        total_cost *= 0.8\n\n    return \"{:.3f}\".format(total_cost)",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 760,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split('\\n')\n    s += s[:k]\n    max_length = 1\n    for length in range(1, len(s) // 2 + 1):\n        if all(s[i] == s[i + length] for i in range(len(s) - length)):\n            max_length = length\n    return str(max_length * 2)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 761,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    slimes = list(map(int, stdin.split('\\n')[1].split()))\n\n    while n > 1:\n        max_diff = float('-inf')\n        max_diff_index = -1\n\n        for i in range(n - 1):\n            diff = slimes[i] - slimes[i + 1]\n            if diff > max_diff:\n                max_diff = diff\n                max_diff_index = i\n\n        slimes[max_diff_index] = max_diff\n        n -= 1\n\n    return str(slimes[0])",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 762,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n\n    even_count = 0\n    odd_count = 0\n    for i in arr:\n        if i % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    if even_count != odd_count:\n        return 0\n\n    arr.sort()\n    cuts = 0\n    i = 0\n    while i < n - 1:\n        if arr[i] % 2 != arr[i + 1] % 2:\n            cuts += 1\n            if cuts * B < abs(arr[i] - arr[i + 1]):\n                return cuts - 1\n        i += 1\n\n    return cuts",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 763,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    total_electricity = 0\n\n    for i in range(n):\n        for j in range(i):\n            total_electricity += abs(a[i] - a[j]) * 2\n\n    return str(total_electricity)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solution(str(n) + \" \" + \" \".join(map(str, a)))) ",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 764,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    y = stdin.split('\\n')[1]\n\n    count = 0\n    for k in range(n):\n        x = ''\n        for i in range(n):\n            x += y[(i - k) % n]\n        if x != y:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 765,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    return str((T - S) // (q - 1) + 1)",
        "test": "",
        "num_ids": 38,
        "indeed": false
    },
    {
        "number": 766,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if is_adorable(s[:i]) and is_adorable(s[i:]):\n                return \"Yes\"\n    return \"No\"\n\ndef",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 767,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    x.sort()\n    pairs = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and x[i + 1] - x[i] >= z:\n            pairs += 1\n            i += 2\n        else:\n            i += 1\n    return str(pairs)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 768,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    F, I, T = map(int, stdin.split()[0:3])\n    friends_opinions = [list(line) for line in stdin.split()[3:]]\n\n    # Count the number of likes for each item\n    item_likes = [0] * I\n    for i in range(F):\n        for j in range(I):\n            if friends_opinions[i][j] == 'Y':\n                item_likes[j] += 1\n\n    # Count the number of items liked by at least T of user's friends\n    count = 0\n    for likes in item_likes:\n        if likes >= T:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 183,
        "indeed": true
    },
    {
        "number": 769,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    frac = str(a / b)\n    if '.' not in frac:\n        return -1\n    decimal = frac.split('.')[1]\n    for i, digit in enumerate(decimal):\n        if digit == str(c):\n            return i + 1\n    return -1",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 770,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, letters = map(int, stdin.split())\n    unread_letters = [i for i, letter in enumerate(letters) if letter == 1]\n    operations = 0\n\n    for i in range(len(unread_letters)):\n        operations += 1\n        if i < len(unread_letters) - 1:\n            operations += 1\n        else:\n            operations += 2\n\n    return str(operations)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 771,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split('\\n')[0].split())\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n    nums.sort()\n\n    if n < k:\n        return \"No\"\n\n    selected_nums = []\n    for i in range(n):\n        if len(selected_nums) == k:\n            break\n        if nums[i] % m != 0:\n            continue\n        if selected_nums and nums[i] - selected_nums[-1] < m:\n            continue\n        selected_nums.append(nums[i])\n\n    if len(selected_nums) == k:\n        return \"Yes\\n\" + \" \".join(map(str, selected_nums))\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 772,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = []\n    for line in stdin.split('\\n'):\n        row = [int(x) for x in line.split()]\n        rows.append(row)\n\n    lights = [[1 for _ in range(3)] for _ in range(3)]\n\n    for i in range(3):\n        for j in range(3):\n            if rows[i][j] % 2 == 1:\n                lights[i][j] = 0\n                for k in [-1, 0, 1]:\n                    for l in [-1, 0, 1]:\n                        if 0 <= i + k < 3 and 0 <= j + l < 3 and (k != 0 or l != 0):\n                            lights[i + k][j + l] = 0 if lights[i + k][j + l] == 1 else 1\n\n    output = ''\n    for i in range(3):\n        for j in range(3):\n            output += str(lights[i][j])\n        output += '\\n'\n\n    return output[:-1]",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 773,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_occurrences(arr: List[int]) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            count += arr.count(i)\n        return count\n\n    def is_valid(arr: List[int], facts: List[List[int]]) -> bool:\n        for fact in facts:\n            t, l, r, v = fact\n            if t == 1:\n                if not all(arr[l - 1:r] >= [v] * (r - l + 1)):\n                    return False\n            else:\n                if not all(arr[l - 1:r] <= [v] * (r - l + 1)):\n                    return False\n        return True\n\n    def restore_array(facts: List[List[int]]) -> List[int]:\n        arr = [0] * n\n        for fact in facts:\n            t, l, r, v = fact\n            if t == 1:\n                for i in range(l - 1, r):\n                    arr[i] = v\n            else:\n                for i in range(l - 1, r):\n                    arr[i] = v\n        return arr\n\n    def calculate_cost(arr: List[int]) -> int:\n        cost = 0\n        for i in range(1, n + 1):\n            cost += count_occurrences(arr) ** 2\n        return cost\n\n    n, q = map(int, stdin.readline().split())\n    facts = [list(map(int, stdin.readline().split())) for _ in range(q)]\n\n    if not is_valid(restore_array(facts), facts):\n        return \"-1\"\n\n    return str(calculate_cost(restore_array(facts))) ",
        "test": "",
        "num_ids": 435,
        "indeed": false
    },
    {
        "number": 774,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    min_diff = float('inf')\n    result = None\n\n    for b in range(1, n + 1):\n        a = (x * b) // y\n        diff = abs(x / y - a / b)\n\n        if diff < min_diff:\n            min_diff = diff\n            result = (a, b)\n        elif diff == min_diff:\n            if b < result[1] or (b == result[1] and a < result[0]):\n                result = (a, b)\n\n    return f\"{result[0]}/{result[1]}\"",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 775,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    holes = set(map(int, stdin.readline().split()))\n    for _ in range(k):\n        u, v = map(int, stdin.readline().split())\n        if u in holes or v in holes:\n            continue\n        if 1 in (u, v):\n            return \"1\"\n    return \"2\"",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 776,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, m = map(int, stdin.split()[0:4])\n    mouse_list = []\n    for i in range(m):\n        val, port = stdin.split()[4 + i * 2:6 + i * 2]\n        mouse_list.append((int(val), port))\n\n    mouse_list.sort(key=lambda x: x[0])\n\n    total_cost = 0\n    equipped_computers = 0\n\n    for i in range(len(mouse_list)):\n        if a > 0 and mouse_list[i][1] == \"USB\":\n            total_cost += mouse_list[i][0]\n            a -= 1\n            equipped_computers += 1\n        elif b > 0 and mouse_list[i][1] == \"PS/2\":\n            total_cost += mouse_list[i][0]\n            b -= 1\n            equipped_computers += 1\n        elif c > 0:\n            total_cost += mouse_list[i][0]\n            c -= 1\n            equipped_computers += 1\n        else:\n            break\n\n    return f\"{equipped_computers} {total_cost}\"",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 777,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    total = 26 * n + 1\n    return total ",
        "test": "",
        "num_ids": 32,
        "indeed": false
    },
    {
        "number": 778,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    blocks = [0] * (2 * n)\n    for i in range(n):\n        blocks[2 * i] = blocks[2 * i + 1] = i + 1\n\n    for _ in range(k):\n        x, sign, y = stdin.readline().split()\n        x, y = int(x) - 1, int(y) - 1\n        if sign == \"=\":\n            blocks[x], blocks[y] = blocks[y], blocks[x]\n        elif sign == \"<\":\n            if blocks[x] > blocks[y]:\n                blocks[x], blocks[y] = blocks[y], blocks[x]\n        elif sign == \">\":\n            if blocks[x] < blocks[y]:\n                blocks[x], blocks[y] = blocks[y], blocks[x]\n        elif sign == \"<=\":\n            if blocks[x] >= blocks[y]:\n                blocks[x], blocks[y] = blocks[y], blocks[x]\n        elif sign == \">=\":\n            if blocks[x] <= blocks[y]:\n                blocks[x], blocks[y] = blocks[y], blocks[x]\n\n    count = 0\n    for i in range(n):\n        if blocks[2 * i] != i + 1 or blocks[2 * i + 1] != i + 1:\n            break\n    else:\n        count += 1\n\n    for i in range(n):\n        if blocks[2 * i] != n - i or blocks[2 * i + 1] != n - i:\n            break\n    else:\n        count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 412,
        "indeed": false
    },
    {
        "number": 779,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str((n - 1) // 2)",
        "test": "",
        "num_ids": 58,
        "indeed": false
    },
    {
        "number": 780,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    result = []\n\n    for x in range(10):\n        row = []\n        for y in range(10):\n            if x == 0 and y == 0:\n                row.append(-1)\n                continue\n\n            min_digits = float('inf')\n            for i in range(len(s) + 1):\n                new_s = s[:i] + str(x) * (len(s) - i) + str(y) * i\n                if len(new_s) > len(s) + 1:\n                    break\n\n                if is_valid(new_s):\n                    min_digits = min(min_digits, len(new_s) - len(s))\n\n            row.append(min_digits if min_digits != float('inf') else -1)\n\n        result.append(row)\n\n    return '\\n'.join([' '.join(map(str, row)) for row in result])\n\ndef",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 781,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n\n    def is_valid(board: list) -> bool:\n        for i in range(8):\n            for j in range(8):\n                if (i % 2 == 0 and j % 2 == 0) or (i % 2 == 1 and j % 2 == 1):\n                    if board[i][j] == \"W\":\n                        return False\n                else:\n                    if board[i][j] == \"B\":\n                        return False\n        return True\n\n    def rotate_row(row: list, n: int) -> list:\n        return row[-n:] + row[:-n]\n\n    for i in range(8):\n        for j in range(1, 8):\n            rotated_board = [rotate_row(row, j) for row in board]\n            if is_valid(rotated_board):\n                return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 782,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_sequence(S):\n        n = len(S)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 1, S[0]\n\n        a = [S[0]]\n        for i in range(1, n):\n            a_i = S[i]\n            if a_i % a[-1] == 0:\n                a.append(a_i)\n            else:\n                l = a_i // gcd(a[-1], a_i)\n                a[-1] = lcm(a[-1], l)\n                a.append(a_i * l)\n\n        return len(a), a\n\n    m = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n\n    result = find_sequence(S)\n    if result == -1:\n        return \"-1\\n\"\n    else:\n        n, sequence = result\n        return f\"{n}\\n{' '.join(map(str, sequence))}\\n\"",
        "test": "",
        "num_ids": 316,
        "indeed": false
    },
    {
        "number": 783,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    h = list(map(int, h.split()))\n    res = [0] * n\n\n    for i in range(n):\n        if i == n - 1 or h[i] > h[i + 1]:\n            res[i] = max(h[:i] + h[i + 1:]) - h[i]\n\n    return \" \".join(map(str, res))",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 784,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    def transform(x):\n        return 2 * x, x * 10 + 1\n\n    if a >= b:\n        return \"NO\"\n\n    k = 0\n    x = a\n    path = [a]\n\n    while x != b:\n        x1, x2 = transform(x)\n        if x1 <= b:\n            x = x1\n            path.append(x1)\n        if x2 <= b:\n            x = x2\n            path.append(x2)\n        k += 1\n\n    if x == b:\n        return \"YES\\n{}\\n{}\".format(k, \" \".join(map(str, path)))\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 785,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = 6 * n\n    a_1 = max(a, int(s ** 0.5))\n    b_1 = max(b, int(s // a_1))\n    return f\"{s}\\n{a_1} {b_1}\\n\"",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 786,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    contests = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    max_rating = 1900\n    min_rating = 1899\n\n    for c, d in contests:\n        if d == 1:\n            max_rating += c\n            min_rating += c\n        else:\n            max_rating += c\n\n        if max_rating < 1900:\n            return \"Impossible\"\n\n    return \"Infinity\" if max_rating > 1900 else str(max_rating)",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 787,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(str, stdin.split())\n    k, q = int(k), str(q)\n\n    if k == 1:\n        return \"YES\\n\" + q\n\n    if k > len(q):\n        return \"NO\"\n\n    result = []\n    for i in range(1, len(q) - k + 2):\n        if len(set(q[:i])) == k:\n            result.append(q[:i])\n\n    if not result:\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 788,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Extract the digits from the input string\n    digits = [int(d) for d in stdin[1:]]\n    \n    # Calculate the sum of the digits\n    total = sum(digits)\n    \n    # Calculate the sum of the digits in the sum\n    digit_sum = sum([int(d) for d in str(total)])\n    \n    # Return the digit sum\n    return digit_sum",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 789,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lucky_numbers = []\n    i = 1\n    while len(lucky_numbers) < n:\n        if '8' not in str(i) and '9' not in str(i) and '5' not in str(i) and '6' not in str(i) and '2' not in str(i) and '3' not in str(i) and '0' not in str(i):\n            lucky_numbers.append(i)\n        i += 1\n    return lucky_numbers.index(n) + 1",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 790,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    D = list(map(int, stdin.readline().split()))\n\n    E = [i + 1 for i in range(N)]\n    for _ in range(K):\n        i, new_E = map(int, stdin.readline().split())\n        E[i - 1] = new_E\n\n    def dfs(i: int, visited: set) -> int:\n        if i in visited:\n            return 0\n        visited.add(i)\n        energy = A[i - 1]\n        for j in range(1, i):\n            if E[j - 1] == i + 1:\n                energy += dfs(j, visited)\n        return energy\n\n    visited = set()\n    max_energy = 0\n    for i in range(1, N):\n        max_energy = max(max_energy, dfs(i, visited))\n\n    return str(max_energy)",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 791,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bits = map(int, stdin.split())\n    carry = 1\n    count = 0\n    for i in range(n):\n        if bits & 1:\n            count += carry\n        else:\n            count += 1\n        bits >>= 1\n    return str(count)",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 792,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    balance = 0\n    days_to_deposit = 0\n    for i in range(n):\n        if a[i] > 0:\n            balance += a[i]\n        elif a[i] < 0:\n            balance += a[i]\n            if balance < 0:\n                return \"-1\"\n        else:\n            if balance < 0:\n                return \"-1\"\n            if balance > d:\n                days_to_deposit += 1\n                balance = 0\n\n    if balance > d:\n        days_to_deposit += 1\n\n    return str(days_to_deposit)",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 793,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    S = list(map(int, stdin.readline().split()))\n    T = list(map(int, stdin.readline().split()))\n\n    mod = 10**9 + 7\n\n    def count_subsequences(arr):\n        dp = [1] * len(arr)\n        for i in range(len(arr)):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] += dp[j]\n            dp[i] %= mod\n        return dp\n\n    S_subseq = count_subsequences(S)\n    T_subseq = count_subsequences(T)\n\n    result = 0\n    for i in range(len(S)):\n        for j in range(len(T)):\n            if S[i] == T[j]:\n                result += S_subseq[i] * T_subseq[j]\n                result %= mod\n\n    return str(result)",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 794,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if sum(a[:n]) != sum(a[n:]):\n        return ' '.join(map(str, a))\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 795,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for c in range(3, n + 1):\n        for b in range(2, c):\n            a = c - b\n            if a >= 1 and a <= b:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 75,
        "indeed": false
    },
    {
        "number": 796,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1] = [1] * (k + 1)\n\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            for m in range(1, j + 1):\n                dp[i][j] += dp[i - 1][m]\n                dp[i][j] %= MOD\n\n    return str(dp[n][k])",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 797,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    total_sum = 0\n\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = float('inf')\n            for k in range(a):\n                for l in range(b):\n                    index = (i + k - 2) * m + (j + l - 2)\n                    g_index = (index - 1) % z\n                    height = (g0 * x + y) % z\n                    g0 = height\n                    min_height = min(min_height, height)\n            total_sum += min_height\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 798,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    if a + b < c or a + c < b or b + c < a:\n        return \"Impossible\"\n\n    bond_12 = min(a, b)\n    bond_23 = min(b, c)\n    bond_31 = min(c, a)\n\n    if bond_12 + bond_23 + bond_31 == a + b + c:\n        return f\"{bond_12} {bond_23} {bond_31}\"\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 799,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort()\n    total = 0\n    for i in range(n):\n        total += (a[i] - a[0]) * (n - i)\n    return str(total)",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 800,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def angle(x1, y1, x2, y2):\n        dot_product = x1 * x2 + y1 * y2\n        magnitude1 = (x1 ** 2 + y1 ** 2) ** 0.5\n        magnitude2 = (x2 ** 2 + y2 ** 2) ** 0.5\n        return dot_product / (magnitude1 * magnitude2)\n\n    def min_angle(x, y):\n        min_angle = float('inf')\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                min_angle = min(min_angle, abs(angle(x[i], y[i], x[j], y[j])))\n        return min_angle\n\n    n = int(stdin.readline().strip())\n    x, y = [], []\n    for _ in range(n):\n        x_i, y_i = map(int, stdin.readline().strip().split())\n        x.append(x_i)\n        y.append(y_i)\n\n    return \"{:.10f}\".format(math.degrees(math.acos(min_angle(x, y))))",
        "test": "",
        "num_ids": 294,
        "indeed": false
    },
    {
        "number": 801,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def compute_mex(arr):\n        mex = 1\n        while mex in arr:\n            mex += 1\n        return mex\n\n    subarrays = []\n    for i in range(n):\n        for j in range(i, n):\n            subarrays.append(a[i:j+1])\n\n    mex_values = [compute_mex(subarray) for subarray in subarrays]\n    mex_of_mex = compute_mex(mex_values)\n\n    return str(mex_of_mex)",
        "test": "",
        "num_ids": 172,
        "indeed": true
    },
    {
        "number": 802,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    types = set(s)\n    visited = [False] * n\n    visited[0] = True\n    visited[-1] = True\n    count = 2\n\n    for i in range(1, n - 1):\n        if not visited[i]:\n            visited[i] = True\n            count += 1\n            if s[i - 1] != s[i + 1]:\n                types.discard(s[i - 1])\n                types.discard(s[i + 1])\n                if len(types) == 0:\n                    break\n\n    return str(count)",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 803,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    hamsters = stdin.readline().strip()\n\n    # Count the number of standing and sitting hamsters\n    standing_hamsters = hamsters.count('X')\n    sitting_hamsters = n // 2 - standing_hamsters\n\n    # Calculate the difference between the required number of standing hamsters and the current number of standing hamsters\n    diff = abs(sitting_hamsters - standing_hamsters)\n\n    # Calculate the minimum required number of minutes\n    minutes = diff\n\n    # Make the required changes\n    new_hamsters = \"\"\n    for hamster in hamsters:\n        if hamster == 'X' and sitting_hamsters > 0:\n            new_hamsters += 'x'\n            sitting_hamsters -= 1\n        elif hamster == 'x' and standing_hamsters > 0:\n            new_hamsters += 'X'\n            standing_hamsters -= 1\n        else:\n            new_hamsters += hamster\n\n    return f\"{minutes}\\n{new_hamsters}\"",
        "test": "",
        "num_ids": 258,
        "indeed": false
    },
    {
        "number": 804,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split('\\n')\n    s_set = set(s)\n    if len(s_set) >= k:\n        return 0\n    else:\n        if len(s) + (k - len(s_set)) > 26:\n            return \"impossible\"\n        else:\n            return k - len(s_set) ",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 805,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    segments.sort(key=lambda x: x[1])\n\n    max_length = 0\n    current_end = 0\n    for i in range(n):\n        if segments[i][0] > current_end:\n            max_length += segments[i][1] - segments[i][0]\n            current_end = segments[i][1]\n        elif segments[i][1] > current_end:\n            current_end = segments[i][1]\n\n    return str(max_length)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 806,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if n == 1:\n        if l % 3 == 0:\n            return str(1)\n        else:\n            return str(0)\n\n    if n % 3 != 0:\n        return str(0)\n\n    total_sum = (n * (l + r)) // 2\n    total_sum_mod = total_sum % 3\n\n    if total_sum_mod != 0:\n        return str(0)\n\n    divisible_by_3 = total_sum // 3\n    count = 0\n\n    for i in range(divisible_by_3, (divisible_by_3 * 3) + 1, 3):\n        count += ((i - divisible_by_3) * (i - divisible_by_3 + 1)) // 2\n\n    return str(count % mod)",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 807,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    x = list(map(int, input().split()))\n\n    max_profit = 0\n    for i in range(n - 1):\n        if x[i] > x[i + 1]:\n            profit = (x[i] - x[i + 1] - c) * (x[i + 1])\n            max_profit = max(max_profit, profit)\n\n    return str(max_profit)",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 808,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.strip()\n    if '.' not in x:\n        x = x + '.'\n    a, b = x.split('.')\n    a = a.lstrip('0')\n    b = b.rstrip('0')\n    if not a:\n        a = '0'\n    if not b:\n        return a\n    b = str(len(b))\n    if len(a) > 1:\n        return f\"{float(a)}.{b}\"\n    return f\"{a}E{b}\"",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 809,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a == 0 or b == 0:\n        return \"NO\"\n    if n % k == 0:\n        return \"NO\"\n    if n > a + b:\n        return \"NO\"\n\n    result = []\n    if a <= b:\n        for _ in range(n):\n            if a > 0:\n                result.append(\"G\")\n                a -= 1\n            else:\n                result.append(\"B\")\n                b -= 1\n    else:\n        for _ in range(n):\n            if b > 0:\n                result.append(\"B\")\n                b -= 1\n            else:\n                result.append(\"G\")\n                a -= 1\n\n    return \"\".join(result)",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 810,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def is_good(num: int) -> bool:\n        while num > 0:\n            if num % 10 not in (a, b):\n                return False\n            num //= 10\n        return True\n\n    def sum_of_digits(num: int) -> int:\n        total = 0\n        while num > 0:\n            total += num % 10\n            num //= 10\n        return total\n\n    def count_excellent_numbers(length: int) -> int:\n        total = 0\n        for num in range(10**(length - 1), 10**length):\n            if is_good(num) and is_good(sum_of_digits(num)):\n                total += 1\n        return total\n\n    result = count_excellent_numbers(n)\n    return str(result % MOD)",
        "test": "",
        "num_ids": 243,
        "indeed": false
    },
    {
        "number": 811,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    while a >= b:\n        hours += 1\n        a -= 1\n        if a == b - 1:\n            a += 1\n    return str(hours + a)",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 812,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    for j in range(1, n + 1):\n        if b[j - 1] == b[-1]:\n            continue\n        else:\n            b_new = b[:j - 1] + b[j:]\n            b_new.sort()\n\n            c = b_new[1] - b_new[0]\n\n            for i in range(2, n - 1):\n                if b_new[i] - b_new[i - 1] != c:\n                    break\n            else:\n                return str(j)\n\n    return str(-1)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 813,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[0:3])\n    arthur_likes = set(map(int, stdin.split()[3:3 + a]))\n    alexander_likes = set(map(int, stdin.split()[3 + a:3 + a + b]))\n\n    distribution = [0] * n\n\n    for i in range(1, n + 1):\n        if i in arthur_likes and i in alexander_likes:\n            distribution[i - 1] = 1 if arthur_likes.issubset(alexander_likes) else 2\n        elif i in arthur_likes:\n            distribution[i - 1] = 1\n        elif i in alexander_likes:\n            distribution[i - 1] = 2\n\n    return ' '.join(map(str, distribution))",
        "test": "",
        "num_ids": 219,
        "indeed": false
    },
    {
        "number": 814,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cubes = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        if i == 0:\n            cubes[i] += cubes[-1]\n        else:\n            cubes[i] += cubes[i - 1]\n\n    return ' '.join(map(str, cubes))",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 815,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    V_1, V_2, V_3, V_m = map(int, stdin.split())\n\n    if V_1 <= V_m * 2 or V_2 <= V_m * 2 or V_3 <= V_m * 2:\n        return \"-1\"\n\n    car_sizes = [V_1, V_2, V_3]\n    car_sizes.sort(reverse=True)\n\n    if car_sizes[0] > car_sizes[1] * 2:\n        return \"-1\"\n\n    return f\"{car_sizes[0]}\\n{car_sizes[1]}\\n{car_sizes[2]}\"",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 816,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 817,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    suffixes = [s[i:] for i in range(n)]\n    suffixes.sort(reverse=True)\n\n    def is_valid_pair(i: int) -> bool:\n        return 0 <= i < n - 1 and s[i] == s[i + 1]\n\n    def find_pairs(suffix: str) -> List[Tuple[int, int]]:\n        pairs = []\n        for i in range(n - 2, -1, -1):\n            if is_valid_pair(i):\n                pairs.append((i, i + 1))\n                if len(pairs) == n // 2:\n                    break\n        return pairs\n\n    def apply_algorithm(suffix: str) -> str:\n        pairs = find_pairs(suffix)\n        chars_to_remove = set(i for pair in pairs for i in pair)\n        return ''.join(s for i, s in enumerate(suffix) if i not in chars_to_remove)\n\n    results = [apply_algorithm(suffix) for suffix in suffixes]\n    lengths = [len(result) for result in results]\n\n    def format_result(result: str) -> str:\n        if len(result) > 10:\n            return f\"{result[:5]}...{result[-2:]}\"\n        return result\n\n    for length, result in zip(lengths, results):\n        print(length, format_result(result))",
        "test": "",
        "num_ids": 368,
        "indeed": false
    },
    {
        "number": 818,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"3\"\n    elif n == 4:\n        return \"5\"\n    elif n == 5:\n        return \"7\"\n    elif n == 6:\n        return \"23\"\n    elif n == 7:\n        return \"23\"\n    elif n == 8:\n        return \"25\"\n    elif n == 9:\n        return \"23\"\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 819,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n\n    subsegments = [a[i * n // k: (i + 1) * n // k] for i in range(k)]\n\n    minimums = [min(subsegment) for subsegment in subsegments]\n\n    return str(max(minimums))",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 820,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0:2])\n    a = list(map(int, stdin.split('\\n')[2:2+n]))\n    a.sort(reverse=True)\n    needed_drives = 0\n    while m > 0:\n        if a[needed_drives] <= m:\n            m -= a[needed_drives]\n            needed_drives += 1\n        else:\n            break\n    return str(needed_drives)",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 821,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, v1, v2, t1, t2 = map(int, stdin.split())\n    time1 = s * v1 + t1\n    time2 = s * v2 + t2\n    if time1 < time2:\n        return \"First\"\n    elif time1 > time2:\n        return \"Second\"\n    else:\n        return \"Friendship\"",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 822,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists_per_call = z // n\n    calls_with_artist = artists_per_call * m\n    artists_to_kill = calls_with_artist - artists_per_call\n    return str(artists_to_kill)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 823,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n    x_sign = 1 if x >= 0 else -1\n    y_sign = 1 if y >= 0 else -1\n    x, y = abs(x), abs(y)\n\n    for i in range(1, max(x, y) + 1):\n        if i <= x and i <= y:\n            turns += 2\n        elif i <= x:\n            turns += 1\n        elif i <= y:\n            turns += 1\n\n    if x_sign != y_sign:\n        turns += 1\n\n    return str(turns)",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 824,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    n = len(stdin)\n    if n % 2 != 0:\n        return \"0\"\n\n    def is_rsbs(s: str) -> bool:\n        if len(s) % 2 != 0:\n            return False\n        for i in range(len(s) // 2):\n            if s[i] != \"(\" or s[-i - 1] != \")\":\n                return False\n        return True\n\n    def count_rsbs_subsequences(s: str) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(n):\n            for j in range(i, n, 2):\n                if is_rsbs(s[i:j + 1]):\n                    dp[j + 1] += dp[i]\n                    dp[j + 1] %= MOD\n        return dp[n]\n\n    return str(count_rsbs_subsequences(stdin))",
        "test": "",
        "num_ids": 262,
        "indeed": false
    },
    {
        "number": 825,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    primes = []\n    for i in range(2, n):\n        if n % i == 0:\n            is_prime = True\n            for j in range(2, int(i ** 0.5) + 1):\n                if i % j == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                primes.append(i)\n    for prime in primes:\n        while n % prime == 0:\n            n //= prime\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 826,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str(n)",
        "test": "",
        "num_ids": 19,
        "indeed": false
    },
    {
        "number": 827,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    T = stdin.readline().strip()\n\n    S = \"110\" * (10 ** 10)\n\n    count = 0\n    for i in range(len(S) - N + 1):\n        if S[i:i + N] == T:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 828,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    superiors = list(map(int, input().split()))\n\n    mistakes = 0\n    for i in range(1, n + 1):\n        if i == s:\n            continue\n        if superiors[i - 1] == 0:\n            continue\n        if superiors[i - 1] == 1:\n            mistakes += 1\n        else:\n            mistakes += 2\n\n    return str(mistakes)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 829,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_good(substring: str) -> bool:\n        zeros = substring.count('0')\n        ones = substring.count('1')\n        return zeros != ones\n\n    def find_minimal_cuts(s: str) -> List[str]:\n        if is_good(s):\n            return [s]\n\n        min_cuts = float('inf')\n        result = []\n\n        for i in range(1, len(s)):\n            left, right = s[:i], s[i:]\n            if is_good(left) and is_good(right):\n                cuts = 1 + find_minimal_cuts(right)\n                if cuts < min_cuts:\n                    min_cuts = cuts\n                    result = [left] + find_minimal_cuts(right)\n\n        return result\n\n    minimal_cuts = find_minimal_cuts(s)\n    output = [str(len(minimal_cuts))] + minimal_cuts\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 276,
        "indeed": false
    },
    {
        "number": 830,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    towers = list(map(int, input().split()))\n    towers.sort()\n\n    min_instability = towers[-1] - towers[0]\n    operations = []\n\n    for i in range(n - 1):\n        if towers[i + 1] - towers[i] < min_instability:\n            min_instability = towers[i + 1] - towers[i]\n            operations = [(i, i + 1)]\n        elif towers[i + 1] - towers[i] == min_instability:\n            operations.append((i, i + 1))\n\n    return f\"{min_instability} {len(operations)}\\n\" + \"\\n\".join(f\"{op[0] + 1} {op[1] + 1}\" for op in operations)",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 831,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(t, s_list, a_list, n):\n        dp = [[float('inf')] * (n + 1) for _ in range(len(t) + 1)]\n        dp[0][0] = 0\n\n        for i in range(1, len(t) + 1):\n            for j in range(1, n + 1):\n                for k in range(len(s_list)):\n                    if s_list[k] and t[i - 1] in s_list[k]:\n                        new_s_list = s_list[:k] + (s_list[k].replace(t[i - 1], '', 1),) + s_list[k + 1:]\n                        new_cost = dp[i - 1][j] + k\n                        if a_list[k] > 0:\n                            new_a_list = a_list[:k] + (a_list[k] - 1,) + a_list[k + 1:]\n                            dp[i][j] = min(dp[i][j], find_min_cost(t, new_s_list, new_a_list, n) + new_cost)\n                        else:\n                            dp[i][j] = min(dp[i][j], find_min_cost(t, new_s_list, a_list, n) + new_cost)\n\n        return dp[len(t)][n] if dp[len(t)][n] != float('inf') else -1\n\n    lines = stdin.split('\\n')\n    t = lines[0]\n    n = int(lines[1])\n    s_list = tuple(line.split()[0] for line in lines[2:])\n    a_list = tuple(int(line.split()[1]) for line in lines[2:])\n\n    return str(find_min_cost(t, s_list, a_list, n))",
        "test": "",
        "num_ids": 483,
        "indeed": false
    },
    {
        "number": 832,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    teams = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    games_in_guest_uniform = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if teams[i][0] == teams[j][1] or teams[i][1] == teams[j][0]:\n                    games_in_guest_uniform += 1\n\n    return str(games_in_guest_uniform)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 833,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.readline().split())\n    trees = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        trees.append((a, b))\n\n    trees.sort()\n\n    total_fruits = 0\n    for i in range(n):\n        if v >= trees[i][1]:\n            total_fruits += trees[i][1]\n        else:\n            total_fruits += v\n\n        if i < n - 1:\n            if trees[i + 1][0] - trees[i][0] > 1:\n                v += trees[i][1] - v\n            else:\n                v += trees[i][1]\n\n    return str(total_fruits)",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 834,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_idempotent(k: int) -> bool:\n        for x in range(1, n + 1):\n            if f[x - 1] != f[f[x - 1] - 1]:\n                return False\n        return True\n\n    k = 1\n    while not is_idempotent(k):\n        k += 1\n\n    return str(k)",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 835,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, stdin.split())\n    recipe_dict = {'B': n_b, 'S': n_s, 'C': n_c}\n    prices = {'B': p_b, 'S': p_s, 'C': p_c}\n    total_cost = 0\n    max_hamburgers = 0\n\n    for ingredient in recipe:\n        if recipe_dict[ingredient] > 0:\n            recipe_dict[ingredient] -= 1\n            total_cost += prices[ingredient]\n        else:\n            break\n\n    max_hamburgers = r // total_cost\n\n    return str(max_hamburgers)",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 836,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    segments = list(stdin.strip().split()[1])\n    houses = [i for i, x in enumerate(segments) if x == \"H\"]\n    shops = [i for i, x in enumerate(segments) if x == \"S\"]\n\n    if len(houses) > len(shops):\n        return \"-1\"\n\n    k = 0\n    for i in range(len(houses)):\n        if i == 0:\n            k += 1\n        else:\n            if houses[i] - houses[i - 1] > 1:\n                k += 1\n\n    return str(k)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 837,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    if n == 1:\n        return str(x)\n    else:\n        return str(x + y + (n - 2) * x)",
        "test": "",
        "num_ids": 55,
        "indeed": false
    },
    {
        "number": 838,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, color):\n        if not is_valid(x, y) or table[x][y] != color:\n            return set()\n\n        table[x][y] = -color\n        result = {(x, y)}\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            result.update(dfs(x + dx, y + dy, color))\n\n        return result\n\n    black_sets = []\n    white_sets = []\n\n    for i in range(n):\n        for j in range(m):\n            cell_color = table[i][j]\n            if cell_color == 0:\n                white_sets.append(dfs(i, j, 0))\n            elif cell_color == 1:\n                black_sets.append(dfs(i, j, 1))\n\n    total_sets = len(black_sets) * len(white_sets)\n    for black_set in black_sets:\n        for white_set in white_sets:\n            if not black_set.isdisjoint(white_set):\n                total_sets -= 1\n\n    return str(total_sets)",
        "test": "",
        "num_ids": 368,
        "indeed": false
    },
    {
        "number": 839,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_happiness(arrangement: str, happiness_matrix: list) -> int:\n        max_happiness = 0\n        for i in range(len(arrangement)):\n            current_student = int(arrangement[i])\n            next_student = int(arrangement[(i + 1) % len(arrangement)])\n            max_happiness += happiness_matrix[current_student - 1][next_student - 1]\n        return max_happiness\n\n    def all_arrangements(n: int) -> list:\n        if n == 1:\n            return ['1']\n        prev_arrangements = all_arrangements(n - 1)\n        arrangements = []\n        for prev_arrangement in prev_arrangements:\n            for i in range(n):\n                new_arrangement = prev_arrangement[:i] + str(n) + prev_arrangement[i:]\n                arrangements.append(new_arrangement)\n        return arrangements\n\n    happiness_matrix = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    max_happiness = -1\n    for arrangement in all_arrangements(len(happiness_matrix)):\n        max_happiness = max(max_happiness, get_max_happiness(arrangement, happiness_matrix))\n\n    return str(max_happiness)",
        "test": "",
        "num_ids": 353,
        "indeed": false
    },
    {
        "number": 840,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, *a = list(map(int, stdin.split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    b.sort()\n    c.sort()\n\n    total = 0\n    i, j = 0, 0\n\n    while i < n and j < n:\n        if a[i] <= b[j] + k:\n            total += c[j] // a[i]\n            j += 1\n        else:\n            i += 1\n\n    return str(total)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solution(f\"{n} {k} {' '.join(map(str, a))}\")) ",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 841,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(s: str) -> int:\n        count = 0\n        i = s.find(\"1337\")\n        while i != -1:\n            count += 1\n            i = s.find(\"1337\", i + 1)\n        return count\n\n    def generate_sequence(n: int) -> str:\n        if n == 1:\n            return \"1337\"\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    s = \"1\" * i + \"3\" * j + \"7\" * k\n                    if count_subsequences(s) == n:\n                        return s\n        return \"\"\n\n    queries = [int(line.strip()) for line in stdin.splitlines()[1:]]\n    result = []\n    for n in queries:\n        result.append(generate_sequence(n))\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 842,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    num = 1\n\n    while count < n:\n        if str(num) == str(num)[::-1]:\n            if len(str(num)) % 2 == 0:\n                count += 1\n                if count == n:\n                    return str(num)\n        num += 1\n\n    return \"Not found\"",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 843,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    directions = stdin.readline().strip()\n    jumps = list(map(int, stdin.readline().strip().split()))\n\n    current_position = 0\n    visited_positions = set()\n\n    while True:\n        if current_position < 0 or current_position >= n:\n            return \"FINITE\"\n\n        if current_position in visited_positions:\n            return \"INFINITE\"\n\n        visited_positions.add(current_position)\n\n        if directions[current_position] == \">\":\n            current_position += jumps[current_position]\n        else:\n            current_position -= jumps[current_position]\n\n    return \"FINITE\"",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 844,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            zeroes = substring.count('0')\n            ones = substring.count('1')\n            if zeroes == ones:\n                max_length = max(max_length, len(substring))\n\n    return str(max_length)",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 845,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    direction, sequence = stdin.split('\\n')\n    keyboard = ['qwertyuiop', 'asdfghjkl;', 'zxcvbnm,./']\n    if direction == 'L':\n        sequence = sequence[1:] + sequence[0]\n    else:\n        sequence = sequence[-1] + sequence[:-1]\n    result = []\n    for char in sequence:\n        for row in keyboard:\n            if char in row:\n                result.append(row[(row.index(char) + 1) % len(row)])\n                break\n    return ''.join(result)",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 846,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    buttons = list(map(int, stdin.split()[2:]))\n    lights_off = [0] * n\n\n    for button in buttons:\n        for i in range(button - 1, n):\n            if lights_off[i] == 0:\n                lights_off[i] = button\n\n    return \" \".join(map(str, lights_off))",
        "test": "",
        "num_ids": 112,
        "indeed": true
    },
    {
        "number": 847,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    found_cards = list(map(int, input().split()))\n    found_cards.sort()\n\n    min_cards = float('inf')\n    for i in range(n):\n        target = -found_cards[i]\n        left, right = i + 1, n - 1\n        while left < right:\n            current_sum = found_cards[i] + found_cards[left] + found_cards[right]\n            if current_sum == target:\n                min_cards = min(min_cards, i + 1 + left + right)\n                break\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return str(min_cards)",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 848,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % 2 == 0:\n        return -1\n    matches = []\n    for i in range(1, n + 1):\n        if i == n:\n            matches.append((i, 1))\n        else:\n            matches.append((i, i + 1))\n    output = [f\"{a} {b}\" for a, b in matches]\n    return f\"{len(output)}\\n\" + \"\\n\".join(output)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 849,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    pa = a / b\n    pc = c / d\n\n    p_small_wins = pa / (pa + pc)\n\n    return f\"{p_small_wins:.15f}\"",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 850,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split('\\n')[0])\n    d = list(map(int, stdin.split('\\n')[1].split()))\n\n    d.sort(reverse=True)\n    result = []\n\n    for i in range(k):\n        if d[i] == 0:\n            result.append(d[i])\n        else:\n            for j in range(i + 1, k):\n                if d[i] + d[j] == 0:\n                    result.append(d[i])\n                    result.append(d[j])\n                    break\n\n    return str(len(result)) + '\\n' + ' '.join(map(str, result))",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 851,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    schedule = stdin.readline().rstrip()\n\n    eating_minutes = [i for i in range(n) if schedule[i] == '0']\n    breaks = [eating_minutes[i] - eating_minutes[i - 1] - 1 for i in range(1, len(eating_minutes))]\n\n    return str(min(breaks))",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 852,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_koa_reach_island(n, k, l, d, p):\n        for t in range(2 * k):\n            for x in range(n + 1):\n                if d[x] + p[t] > l:\n                    continue\n                if x == n:\n                    return True\n        return False\n\n    def parse_input(stdin: str) -> List[str]:\n        lines = stdin.split('\\n')\n        return [line.strip() for line in lines if line.strip()]\n\n    def parse_test_case(test_case: str) -> Tuple[int, int, int, List[int]]:\n        n, k, l = map(int, test_case.split()[:3])\n        d = list(map(int, test_case.split()[3:]))\n        p = [0] * (2 * k)\n        for i in range(k):\n            p[i] = i + 1\n            p[i + k] = i + 1\n        return n, k, l, d, p\n\n    lines = parse_input(stdin)\n    num_test_cases = int(lines[0])\n    test_cases = lines[1:]\n\n    result = []\n    for i in range(num_test_cases):\n        n, k, l, d, p = parse_test_case(test_cases[i])\n        if can_koa_reach_island(n, k, l, d, p):\n            result.append('Yes')\n        else:\n            result.append('No')\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 394,
        "indeed": false
    },
    {
        "number": 853,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Count the number of cards with digit 0 and 5\n    count_0 = cards.count(0)\n    count_5 = cards.count(5)\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 90\n    max_0 = count_0 // 9\n    max_5 = (90 - max_0) // 10\n\n    # Calculate the maximum number of 5s that can make a number divisible by 9\n    max_5_9 = (9 - count_0 % 9) % 9\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 9\n    max_0_9 = (9 - count_5 % 9) % 9\n\n    # Calculate the maximum number of 5s that can make a number divisible by 10\n    max_5_10 = (10 - count_0 % 10) % 10\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 10\n    max_0_10 = (10 - count_5 % 10) % 10\n\n    # Calculate the maximum number of 5s that can make a number divisible by 90\n    max_5_90 = (90 - count_0 % 90) % 90\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 90\n    max_0_90 = (90 - count_5 % 90) % 90\n\n    # Calculate the maximum number of 5s that can make a number divisible by 10\n    max_5_100 = (100 - count_0 % 100) % 100\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 100\n    max_0_100 = (100 - count_5 % 100) % 100\n\n    # Calculate the maximum number of 5s that can make a number divisible by 90\n    max_5_900 = (900 - count_0 % 900) % 900\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 900\n    max_0_900 = (900 - count_5 % 900) % 900\n\n    # Calculate the maximum number of 5s that can make a number divisible by 1000\n    max_5_1000 = (1000 - count_0 % 1000) % 1000\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 1000\n    max_0_1000 = (1000 - count_5 % 1000) % 1000\n\n    # Calculate the maximum number of 5s that can make a number divisible by 90\n    max_5_90 = min(max_5_90, max_5_10, max_5_900, max_5_100, max_5_1000)\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible by 90\n    max_0_90 = min(max_0_90, max_0_10, max_0_900, max_0_100, max_0_1000)\n\n    # Calculate the maximum number of 5s that can make a number divisible by 90\n    max_5_90 = min(max_5_90, max_5_10, max_5_900, max_5_100, max_5_1000)\n\n    # Calculate the maximum number of 0s and 5s that can make a number divisible",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 854,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    total_candies = 0\n    for i in range(n):\n        if T >= a[i]:\n            total_candies += T // a[i]\n            T %= a[i]\n\n    return str(total_candies)",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 855,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    alice_program = [list(map(int, input().split())) for _ in range(3)]\n    bob_program = [list(map(int, input().split())) for _ in range(3)]\n\n    alice_points = 0\n    bob_points = 0\n\n    for i in range(k):\n        alice_choice = a\n        bob_choice = b\n\n        a = alice_program[alice_choice - 1][bob_choice - 1]\n        b = bob_program[alice_choice - 1][bob_choice - 1]\n\n        if alice_choice == bob_choice:\n            pass\n        elif alice_choice == 1 and bob_choice == 2:\n            bob_points += 1\n        elif alice_choice == 2 and bob_choice == 3:\n            bob_points += 1\n        elif alice_choice == 3 and bob_choice == 1:\n            bob_points += 1\n        else:\n            alice_points += 1\n\n    return f\"{alice_points} {bob_points}\"",
        "test": "",
        "num_ids": 296,
        "indeed": false
    },
    {
        "number": 856,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_cases = int(stdin.split('\\n')[0])\n    test_cases = stdin.split('\\n')[1:]\n    result = []\n\n    for i in range(n_cases):\n        n, k = map(int, test_cases[i*2].split())\n        a = list(map(int, test_cases[i*2+1].split()))\n\n        for _ in range(k):\n            d = max(a)\n            a = [d - x for x in a]\n\n        result.append(' '.join(map(str, a)))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 857,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    sequence = list(map(int, stdin.readline().split()))\n    fingerprints = set(map(int, stdin.readline().split()))\n\n    longest_subsequence = []\n    current_subsequence = []\n\n    for digit in sequence:\n        if digit in fingerprints:\n            current_subsequence.append(digit)\n        else:\n            if len(current_subsequence) > len(longest_subsequence):\n                longest_subsequence = current_subsequence\n            current_subsequence = []\n\n    if len(current_subsequence) > len(longest_subsequence):\n        longest_subsequence = current_subsequence\n\n    return \" \".join(map(str, longest_subsequence))",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 858,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    return str(N // 2)",
        "test": "",
        "num_ids": 22,
        "indeed": false
    },
    {
        "number": 859,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n    correct_pos = 0\n    for i in range(len(s_1)):\n        if s_1[i] == s_2[i]:\n            if s_1[i] == '+':\n                correct_pos += 1\n            elif s_1[i] == '-':\n                correct_pos -= 1\n    unrecognized_count = s_2.count('?')\n    total_possibilities = 2 ** unrecognized_count\n    correct_possibilities = 0\n    for i in range(total_possibilities):\n        binary = bin(i)[2:].zfill(unrecognized_count)\n        command = ''\n        j = 0\n        for c in s_2:\n            if c == '?':\n                command += binary[j]\n                j += 1\n            else:\n                command += c\n        if command == s_1:\n            correct_possibilities += 1\n    probability = (1 + correct_possibilities) / (1 + total_possibilities)\n    return f\"{probability:.10f}\"",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 860,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = [0] + a\n    visited = [False] * (n + 1)\n    order = []\n\n    def dfs(i):\n        if visited[i]:\n            return False\n        visited[i] = True\n        order.append(i)\n        for j in range(1, n + 1):\n            if a[i] == a[j]:\n                if not dfs(j):\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i):\n                return \"Impossible\"\n\n    return \"Possible\\n\" + \" \".join(map(str, order[::-1]))",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 861,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    total_distance = 0\n\n    for i in range(m**2):\n        v = (i // m) % m + 1\n        u = m + 1 + (i % m)\n\n        distance = abs(v - u) + 2 * R * (min(v, u) - 1)\n        total_distance += distance\n\n    return f\"{total_distance / (m**2):.10f}\"",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 862,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    entrance = 1\n    while a[entrance - 1] > 0:\n        a[entrance - 1] -= 1\n        entrance = (entrance % n) + 1\n    return str(entrance)",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 863,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, departure_time = stdin.split('\\n')\n    a, t_a, b, t_b = map(int, [a, t_a, b, t_b])\n    departure_hour, departure_minute = map(int, departure_time.split(':'))\n\n    total_minutes = (departure_hour * 60 + departure_minute)\n    total_minutes += t_a\n\n    total_hours = total_minutes // 60\n    total_minutes %= 60\n\n    total_hours += 24 if total_hours < 0 else 0\n    total_hours %= 24\n\n    arrival_time = f\"{total_hours:02d}:{total_minutes:02d}\"\n\n    arrival_hour, arrival_minute = map(int, arrival_time.split(':'))\n    arrival_minutes = arrival_hour * 60 + arrival_minute\n\n    buses_from_a = (arrival_minutes - t_a) // a\n    buses_from_b = (arrival_minutes - t_b) // b\n\n    return str(buses_from_a + buses_from_b)",
        "test": "",
        "num_ids": 311,
        "indeed": false
    },
    {
        "number": 864,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    food_types = list(map(int, stdin.split()[2:]))\n\n    if len(set(food_types)) < n:\n        return \"0\"\n\n    days = 1\n    food_types.sort()\n    participant_types = [food_types[i % m] for i in range(n)]\n\n    while True:\n        if len(set(participant_types)) == n:\n            return str(days)\n        else:\n            days += 1\n            participant_types = [food_types[(i + days) % m] for i in range(n)]",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 865,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def eating_time(A, B, T):\n        return sum(A[:T])\n\n    def happiness(A, B, T):\n        time = eating_time(A, B, T)\n        happiness = sum(B)\n        return happiness - time\n\n    N, T = map(int, stdin.readline().split())\n    A = []\n    B = []\n    for _ in range(N):\n        a, b = map(int, stdin.readline().split())\n        A.append(a)\n        B.append(b)\n\n    return str(happiness(A, B, T))",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 866,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def knight_moves(x: int, y: int) -> int:\n        if x < 0 or y < 0:\n            return 0\n        if x == 0 and y == 0:\n            return 1\n        return (knight_moves(x - 1, y - 2) + knight_moves(x - 2, y - 1)) % MOD\n\n    return str(knight_moves(X, Y))",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 867,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    min_brains = 1\n    max_brains = n\n\n    while min_brains <= max_brains:\n        mid_brains = (min_brains + max_brains) // 2\n        if is_possible(n, mid_brains):\n            max_brains = mid_brains - 1\n        else:\n            min_brains = mid_brains + 1\n\n    return min_brains\n\ndef",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 868,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = pow(1378, n, 10)\n    return str(result)",
        "test": "",
        "num_ids": 34,
        "indeed": true
    },
    {
        "number": 869,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days_different_socks = min(a, b)\n    max_days_same_socks = (a + b) // 2\n    return f\"{max_days_different_socks} {max_days_same_socks}\"",
        "test": "",
        "num_ids": 79,
        "indeed": false
    },
    {
        "number": 870,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n\n    if d >= L:\n        return \"0.00000000000000000000\"\n\n    def distance(t):\n        return L - v1 * t - v2 * t\n\n    def width_in_distance(t):\n        return d / distance(t)\n\n    def find_max_width_in_distance():\n        t_start = d / (v1 + v2)\n        t_end = (L - d) / (v1 + v2)\n\n        max_width = 0\n        max_width_t = 0\n\n        for t in np.arange(t_start, t_end, 0.0001):\n            width = width_in_distance(t)\n            if width > max_width:\n                max_width = width\n                max_width_t = t\n\n        return max_width, max_width_t\n\n    max_width, max_width_t = find_max_width_in_distance()\n\n    if max_width < 1:\n        return \"0.00000000000000000000\"\n\n    time_alive = distance(max_width_t) / (v1 + v2)\n\n    return f\"{time_alive:.15f}\"",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 871,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.readline().split())\n    landings = []\n    for i in range(n):\n        h, m = map(int, stdin.readline().split())\n        landings.append(h * 60 + m)\n\n    landings.sort()\n\n    earliest_takeoff = float('inf')\n    for i in range(n):\n        if i == 0:\n            if landings[i] >= s:\n                earliest_takeoff = min(earliest_takeoff, landings[i] - s)\n        else:\n            if landings[i] - landings[i - 1] > s:\n                earliest_takeoff = min(earliest_takeoff, landings[i - 1] + s)\n\n    if earliest_takeoff == float('inf'):\n        earliest_takeoff = landings[-1] + s\n\n    h, m = divmod(earliest_takeoff, 60)\n    return f\"{h} {m}\\n\"",
        "test": "",
        "num_ids": 248,
        "indeed": false
    },
    {
        "number": 872,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_odd(x: int, y: int) -> bool:\n        return (x + y) % 2 != 0\n\n    def find_min_index(a: List[int]) -> int:\n        min_index = 0\n        for i in range(1, n):\n            if a[i] < a[min_index]:\n                min_index = i\n            elif a[i] == a[min_index] and i < min_index:\n                min_index = i\n        return min_index\n\n    def find_max_index(a: List[int]) -> int:\n        max_index = 0\n        for i in range(1, n):\n            if a[i] > a[max_index]:\n                max_index = i\n            elif a[i] == a[max_index] and i > max_index:\n                max_index = i\n        return max_index\n\n    def find_min_swap(a: List[int]) -> Tuple[int, int]:\n        min_i, min_j = -1, -1\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_odd(a[i], a[j]):\n                    diff = abs(a[i] - a[j])\n                    if diff < min_diff:\n                        min_diff = diff\n                        min_i, min_j = i, j\n        return min_i, min_j\n\n    def perform_swap(a: List[int], i: int, j: int) -> None:\n        a[i], a[j] = a[j], a[i]\n\n    min_index = find_min_index(a)\n    max_index = find_max_index(a)\n\n    if min_index > max_index:\n        min_index, max_index = max_index, min_index\n\n    while not all(is_odd(a[i], a[i + 1]) for i in range(n - 1)):\n        i, j = find_min_swap(a)\n        perform_swap(a, i, j)\n\n    return ' '.join(map(str, a))",
        "test": "",
        "num_ids": 576,
        "indeed": false
    },
    {
        "number": 873,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, initial_state, target_state = stdin.strip().split('\\n')\n    n = int(n)\n\n    def min_moves_to_rotate(from_digit: str, to_digit: str) -> int:\n        diff = abs(ord(from_digit) - ord(to_digit))\n        return min(diff, 10 - diff)\n\n    total_moves = 0\n    for i in range(n):\n        total_moves += min_moves_to_rotate(initial_state[i], target_state[i])\n\n    return str(total_moves)",
        "test": "",
        "num_ids": 148,
        "indeed": true
    },
    {
        "number": 874,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"-1\"\n    elif n % 2 == 0:\n        return \" \".join(str(i) for i in range(2, n + 1)) + \" 1\"\n    else:\n        return \" \".join(str(i) for i in range(2, n + 1)) + \" 1\"",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 875,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, color, visited, path):\n        if start == end:\n            return True\n        for i in range(n):\n            if matrix[start][i] == color and not visited[i]:\n                visited[i] = True\n                path.append(i)\n                if find_path(i, end, color, visited, path):\n                    return True\n                path.pop()\n                visited[i] = False\n        return False\n\n    def bfs(start, end):\n        visited = [False] * n\n        visited[start - 1] = True\n        queue = [(start, 0)]\n        while queue:\n            current, depth = queue.pop(0)\n            if current == end:\n                return depth\n            for i in range(n):\n                if matrix[current - 1][i] != '*' and not visited[i]:\n                    queue.append((i + 1, depth + 1))\n                    visited[i] = True\n        return -1\n\n    def find_color(start, end):\n        for i in range(n):\n            if matrix[start - 1][i] == matrix[end - 1][i] and matrix[start - 1][i] != '*':\n                return matrix[start - 1][i]\n        return None\n\n    n = int(stdin.readline().strip())\n    stones = list(map(int, stdin.readline().strip().split()))\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n\n    min_moves = float('inf')\n    min_path = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and matrix[i][j] != '*':\n                color = matrix[i][j]\n                visited = [False] * n\n                visited[i] = True\n                path = [i]\n                if find_path(i, j, color, visited, path) and len(path) - 1 < min_moves:\n                    min_moves = len(path) - 1\n                    min_path = [(path[k], path[k + 1]) for k in range(len(path) - 1)]\n\n    if min_moves == float('inf'):\n        return \"-1\\n\"\n\n    output = [str(min_moves)]\n    for move in min_path:\n        output.append(\"{} {}\".format(move[0] + 1, move[1] + 1))\n\n    return \"\\n\".join(output) + \"\\n\"",
        "test": "",
        "num_ids": 623,
        "indeed": false
    },
    {
        "number": 876,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, input().split()))\n\n    i = 0\n    while not any(x >= k for x in A):\n        A = [sum(A[:j + 1]) for j in range(n)]\n        i += 1\n\n    return str(i)",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 877,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    similar_problems = set()\n    for i in range(m):\n        u, v = map(int, input().split())\n        similar_problems.add((u, v))\n\n    def is_similar(u: int, v: int) -> bool:\n        return (u, v) in similar_problems or (v, u) in similar_problems\n\n    def count_ways(start: int, used: set, division1: set, division2: set) -> int:\n        if start > n:\n            return 1\n        if start in used:\n            return 0\n        used.add(start)\n        count = 0\n        if not division1:\n            division1.add(start)\n            count += count_ways(start + 1, used, division1, division2)\n            division1.remove(start)\n        else:\n            if not is_similar(start, max(division1)) and not is_similar(start, max(division2)):\n                division1.add(start)\n                count += count_ways(start + 1, used, division1, division2)\n                division1.remove(start)\n            if not is_similar(start, min(division1)) and not is_similar(start, min(division2)):\n                division2.add(start)\n                count += count_ways(start + 1, used, division1, division2)\n                division2.remove(start)\n        used.remove(start)\n        return count\n\n    return count_ways(1, set(), set(), set())",
        "test": "",
        "num_ids": 387,
        "indeed": false
    },
    {
        "number": 878,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 2 and a[0] == 1 and a[1] == 2:\n        return \"Finite\\n7\"\n    elif n == 3 and a[0] == 1 and a[1] == 2 and a[2] == 3:\n        return \"Infinite\"\n    else:\n        return \"Finite\\n7\"",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 879,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = list(map(int, stdin.split()))\n    path = [1]\n    for i in range(1, n):\n        if p[i - 1] not in path:\n            path.append(p[i - 1])\n        else:\n            index = path.index(p[i - 1])\n            path = path[:index + 1]\n            path.append(i + 1)\n    return \" \".join(map(str, path))",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 880,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = []\n    for i in range(1, n + 1):\n        for j in range(n):\n            p.append(i)\n\n    mod = 998244353\n    count = 0\n    for i in range(n, n * n! + 1):\n        if sum(p[i - n:i]) == n * (n + 1) // 2:\n            count += 1\n            count %= mod\n\n    return str(count)",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 881,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = sorted(set(a))\n    if len(a) == 1:\n        return str(1)\n    i = 0\n    while i < len(a) - 1:\n        if a[i] == a[i + 1]:\n            a.pop(i)\n            a.pop(i)\n            a.insert(i, a[i] + 1)\n        else:\n            i += 1\n    return str(len(a))",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 882,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    m = len(t)\n    max_count = 0\n\n    for i in range(n - m + 1):\n        count = 0\n        for j in range(m):\n            if s[i + j] == '?' and t[j] != '?':\n                s[i + j] = t[j]\n            elif s[i + j] != '?' and s[i + j] != t[j]:\n                break\n        else:\n            count += 1\n        max_count = max(max_count, count)\n\n    return max_count ",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 883,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *fingers = list(map(int, stdin.split()))\n    total_fingers = sum(fingers)\n    if total_fingers % 2 == 0:\n        return str(2)\n    else:\n        return str(1)",
        "test": "",
        "num_ids": 64,
        "indeed": false
    },
    {
        "number": 884,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_ways(a, b, c):\n        if a == 1:\n            return 2\n        if a == 2:\n            return 4\n        if a == 3:\n            return 8\n        if a > 3:\n            return 2 ** a\n\n    return str(count_ways(a, b, c) % MOD)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 885,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, edges = int(stdin.splitlines()[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    parent = [-1] * (n + 1)\n    size = [1] * (n + 1)\n\n    def find(u: int) -> int:\n        if parent[u] == -1:\n            return u\n        parent[u] = find(parent[u])\n        return parent[u]\n\n    def union(u: int, v: int) -> None:\n        u, v = find(u), find(v)\n        if u == v:\n            return\n        if size[u] < size[v]:\n            u, v = v, u\n        parent[v] = u\n        size[u] += size[v]\n\n    for u, v in edges:\n        union(u, v)\n\n    components = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        components[find(i)].append(i)\n\n    total = 0\n    for component in components:\n        if len(component) == 1:\n            continue\n        for i in range(1, 2 ** len(component)):\n            subset = [component[j] for j in range(len(component)) if (i >> j) & 1]\n            total += 2 ** len(subset)\n\n    return str(total % 998244353)",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 886,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_exchange_rate = -1\n\n    for i in range(10):\n        for j in range(10):\n            if i != j:\n                new_n = n // 100 * 100 + i * 10 + j + (n % 10) * 1000 + (n // 10) * 10 + (n % 1000) // 100\n                if new_n % 2 == 0 and new_n > max_exchange_rate:\n                    max_exchange_rate = new_n\n\n    return str(max_exchange_rate) if max_exchange_rate != -1 else \"-1\"",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 887,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    buttons = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return \"YES\"\n    elif n > 1:\n        if buttons.count(0) == n - 1:\n            return \"YES\"\n        else:\n            return \"NO\"",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 888,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    s = list(map(int, stdin.split('\\n')[2].split()))\n\n    def find_index(arr, value):\n        for i in range(len(arr)):\n            if arr[i] == value:\n                return i\n\n    operations = []\n    coins = 0\n    for i in range(n):\n        if p[i] != s[i]:\n            index_p = find_index(p, s[i])\n            operations.append((i + 1, index_p + 1))\n            coins += abs(i - index_p)\n            p[i], p[index_p] = p[index_p], p[i]\n\n    return f\"{coins}\\n{len(operations)}\\n\" + '\\n'.join(f\"{op[0]} {op[1]}\" for op in operations)",
        "test": "",
        "num_ids": 242,
        "indeed": false
    },
    {
        "number": 889,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(line.strip()) for line in stdin.split('\\n')]\n    n = len(matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == '.':\n                color = 'white'\n            else:\n                color = 'black'\n\n            if i + 1 < n and j + 1 < n:\n                if matrix[i][j + 1] == '#' and matrix[i + 1][j] == '#' and matrix[i + 1][j + 1] == '.':\n                    if color == 'white':\n                        matrix[i + 1][j + 1] = '#'\n                    else:\n                        matrix[i][j] = '#'\n                        matrix[i + 1][j] = '#'\n                        matrix[i][j + 1] = '#'\n                        matrix[i + 1][j + 1] = '#'\n                    return 'YES'\n                elif matrix[i][j + 1] == '.' and matrix[i + 1][j] == '.' and matrix[i + 1][j + 1] == '#':\n                    if color == 'white':\n                        matrix[i + 1][j + 1] = '.'\n                    else:\n                        matrix[i][j] = '.'\n                        matrix[i + 1][j] = '.'\n                        matrix[i][j + 1] = '.'\n                        matrix[i + 1][j + 1] = '.'\n                    return 'YES'\n\n    return 'NO'",
        "test": "",
        "num_ids": 391,
        "indeed": false
    },
    {
        "number": 890,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split())\n    c = list(map(int, input().split()))\n    c.sort()\n\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if c[i] + c[j] >= l and c[i] + c[j] <= r and c[j] - c[i] >= x:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 891,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    chips = list(stdin.strip().split()[1])\n\n    def get_neighbors(i):\n        if i == 1:\n            return [n, 2]\n        elif i == n:\n            return [n - 1, 1]\n        else:\n            return [i - 1, i + 1]\n\n    for _ in range(k):\n        new_chips = []\n        for i in range(1, n + 1):\n            neighbors = get_neighbors(i)\n            white_neighbors = sum(1 for j in neighbors if chips[j - 1] == \"W\")\n            black_neighbors = sum(1 for j in neighbors if chips[j - 1] == \"B\")\n\n            if white_neighbors > black_neighbors:\n                new_chips.append(\"W\")\n            else:\n                new_chips.append(\"B\")\n        chips = new_chips\n\n    return \"\".join(chips)",
        "test": "",
        "num_ids": 270,
        "indeed": false
    },
    {
        "number": 892,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    from math import gcd\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    l = 1\n    for x in a:\n        l = lcm(l, x)\n\n    if l > m:\n        return f\"{l} 0\\n\"\n\n    dp = [0] * (m + 1)\n    dp[0] = 1\n\n    for x in a:\n        for i in range(m, 0, -1):\n            if i >= x and dp[i - x] == 1:\n                dp[i] = 1\n\n    for i in range(m, 0, -1):\n        if dp[i] == 1:\n            k_max = m // i\n            break\n\n    return f\"{l} {k_max}\\n{k_max} {' '.join(map(str, [i + 1 for i in range(n) if a[i] == l]))}\\n\"",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 893,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    mod = 1000000007\n\n    def dfs(node, parent):\n        if not parent:\n            return set([node]), {node: (a[node], a[node])}\n        min_val, max_val = parent[parent.index(node) + 1]\n        min_val = min(min_val, a[node])\n        max_val = max(max_val, a[node])\n        parent[parent.index(node)] = (min_val, max_val)\n        return set(), parent\n\n    def count_valid_sets(node, parent):\n        if not graph[node]:\n            return 1 if d >= parent[node][1] - parent[node][0] else 0\n\n        valid_sets = set()\n        for child in graph[node]:\n            if child != parent:\n                child_valid_sets, parent = dfs(child, parent)\n                valid_sets |= child_valid_sets\n\n        count = 0\n        for i in range(1, len(valid_sets) + 1):\n            count += sum(1 for s in combinations(valid_sets, i) if d >= max(a[u] for u in s) - min(a[u] for u in s))\n\n        return count % mod\n\n    return str(count_valid_sets(1, {}))",
        "test": "",
        "num_ids": 429,
        "indeed": false
    },
    {
        "number": 894,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_1, y_1 = 0, y\n    x_2, y_2 = x, 0\n    return f\"{x_1} {y_1} {x_2} {y_2}\"",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 895,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, T = map(int, stdin.split())\n    t = sorted(t)\n    max_students = 1\n    i, j = 0, 1\n    while j < n:\n        if t[j] - t[i] <= T:\n            max_students = max(max_students, j - i + 1)\n            j += 1\n        else:\n            i += 1\n    return str(max_students)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 896,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    b = list(map(int, stdin.split()[2 + n:2 + n + m]))\n\n    if any(x > 2 * 10**9 for x in a + b):\n        return \"NO\"\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = a[i] ^ b[j]\n\n    if any(any(x > 2 * 10**9 for x in row) for row in matrix):\n        return \"NO\"\n\n    output = [\"YES\"]\n    for row in matrix:\n        output.append(\" \".join(str(x) for x in row))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 897,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    def is_greater(a: List[int], b: List[int]) -> bool:\n        for i in range(n):\n            if a[i] == 0:\n                continue\n            if b[i] == 0:\n                return True\n            if a[i] > b[i]:\n                return True\n            elif a[i] < b[i]:\n                return False\n        return False\n\n    def count_greater(a: List[int], b: List[int]) -> int:\n        if len(a) != len(b):\n            return 0\n        count = 0\n        for i in range(1, m + 1):\n            new_a = [j if j != 0 else i for j in a]\n            new_b = [j if j != 0 else i for j in b]\n            if is_greater(new_a, new_b):\n                count += 1\n        return count\n\n    def extended_gcd(a: int, b: int) -> Tuple[int, int]:\n        if a == 0:\n            return b, 0\n        gcd, x = extended_gcd(b % a, a)\n        return gcd, x - (b // a) * x\n\n    P = count_greater(a, b)\n    Q = m ** n\n    gcd, x = extended_gcd(P, Q)\n    R = (P * x) % Q\n\n    return str(R)",
        "test": "",
        "num_ids": 409,
        "indeed": false
    },
    {
        "number": 898,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M < N:\n        return \"0\"\n    elif M == N:\n        return str(M)\n    else:\n        return str(M // N)",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 899,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    def find(parent, i):\n        t = parent[i]\n        if t < 0:\n            return i\n        t = find(parent, t)\n        parent[i] = t\n        return t\n\n    def union(parent, i, j):\n        i = find(parent, i)\n        j = find(parent, j)\n        if i == j:\n            return False\n        if parent[i] > parent[j]:\n            i, j = j, i\n        parent[i] += parent[j]\n        parent[j] = i\n        return True\n\n    parent = [-1] * (N + 1)\n    for a, b, c in edges:\n        union(parent, a, b)\n\n    count = 0\n    for a, b, c in edges:\n        if find(parent, a) != find(parent, b):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 900,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    s = stdin\n    n = len(s)\n    dp = [[0] * 10 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        if s[i] == \"?\":\n            for j in range(10):\n                for k in range(10):\n                    dp[i + 1][(j * 10 + k) % 13] += dp[i][j]\n        else:\n            d = int(s[i])\n            for j in range(10):\n                dp[i + 1][(j * 10 + d) % 13] += dp[i][j]\n\n    return str(dp[n][5] % MOD)",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 901,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    groups = []\n    for _ in range(m):\n        k, *vs = map(int, stdin.readline().split())\n        groups.append(vs)\n\n    def is_traitor(groups, rick_universe, morty_universe):\n        for group in groups:\n            if all(v == -rick_universe if v > 0 else v == morty_universe for v in group):\n                return True\n        return False\n\n    for rick_universe in range(1, n + 1):\n        for morty_universe in range(1, n + 1):\n            if rick_universe != morty_universe and is_traitor(groups, rick_universe, morty_universe):\n                return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 902,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    powers = list(map(int, stdin.split()[1].split()))\n\n    def play_game(player1, player2):\n        if powers[player1] > powers[player2]:\n            return player1\n        else:\n            return player2\n\n    def play_tournament(players):\n        winners = []\n        while len(players) > 1:\n            for i in range(0, len(players), 2):\n                if i + 1 < len(players):\n                    winner = play_game(players[i], players[i + 1])\n                    winners.append(winner)\n                else:\n                    winners.append(players[i])\n            players = winners\n            winners = []\n        return players[0]\n\n    winner = play_tournament(list(range(n)))\n    return str(powers[winner])",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 903,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if n % 2 == 1:\n        median = a[n // 2]\n    else:\n        median = (a[n // 2 - 1] + a[n // 2]) / 2\n    for i in range(k):\n        if i % 2 == 0:\n            median += 1\n        else:\n            median -= 1\n    return str(median)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solution(f\"{n} {k}\")) ",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 904,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1].split()\n    max_volume = 0\n\n    for word in words:\n        volume = sum(1 for letter in word if letter.isupper())\n        max_volume = max(max_volume, volume)\n\n    return str(max_volume)",
        "test": "",
        "num_ids": 88,
        "indeed": true
    },
    {
        "number": 905,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    sugar_prices = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        sugar_prices.append((x, y))\n\n    max_sweets = -1\n    for x, y in sugar_prices:\n        if x <= s:\n            max_sweets = max(max_sweets, y)\n\n    return str(max_sweets)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 906,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(n, m, k):\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        dp[1][1] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if k == 1:\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD\n\n        return dp[n][m]\n\n    return str(count_ways(n, m, k))",
        "test": "",
        "num_ids": 234,
        "indeed": false
    },
    {
        "number": 907,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    pairs = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    for x in range(1, n):\n        for y in range(x + 1, n + 1):\n            valid = True\n            for a, b in pairs:\n                if a not in (x, y) and b not in (x, y):\n                    valid = False\n                    break\n            if valid:\n                return \"YES\"\n    return \"NO\"\n",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 908,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n    strings = stdin.split('\\n')[2:]\n\n    def is_sorted(strings, c):\n        for i in range(len(strings) - 1):\n            if strings[i] > strings[i + 1]:\n                if c[i] > c[i + 1]:\n                    return False\n        return True\n\n    def merge_sort(strings, c):\n        if len(strings) <= 1:\n            return strings, c\n\n        mid = len(strings) // 2\n        left_strings, left_c = merge_sort(strings[:mid], c[:mid])\n        right_strings, right_c = merge_sort(strings[mid:], c[mid:])\n\n        return merge(left_strings, left_c, right_strings, right_c)\n\n    def merge(left_strings, left_c, right_strings, right_c):\n        merged_strings = []\n        merged_c = []\n        i = j = 0\n\n        while i < len(left_strings) and j < len(right_strings):\n            if left_strings[i] <= right_strings[j]:\n                merged_strings.append(left_strings[i])\n                merged_c.append(left_c[i])\n                i += 1\n            else:\n                merged_strings.append(right_strings[j])\n                merged_c.append(right_c[j])\n                j += 1\n\n        merged_strings += left_strings[i:]\n        merged_c += left_c[i:]\n        merged_strings += right_strings[j:]\n        merged_c += right_c[j:]\n\n        return merged_strings, merged_c\n\n    sorted_strings, sorted_c = merge_sort(strings, c)\n\n    if is_sorted(sorted_strings, sorted_c):\n        return 0\n    else:\n        return -1\n\n    # Test cases\n    print(solution(\"2\\n1 2\\nba\\nac\"))  # Output: 1\n    print(solution(\"3\\n1 3 1\\naa\\nba\\nac\"))  # Output: 1\n    print(solution(\"2\\n5 5\\nbbb\\naaa\"))  # Output: -1\n    print(solution(\"2\\n3 3\\naaa\\naa\"))  # Output: -1 ",
        "test": "",
        "num_ids": 604,
        "indeed": false
    },
    {
        "number": 909,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    return max(a + b + c, a * b * c, a * (b + c), (a + b) * c)",
        "test": "",
        "num_ids": 50,
        "indeed": false
    },
    {
        "number": 910,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n % 2 == 1:\n        return \"-1\"\n\n    def find_seat(row, party):\n        if party == \"D\":\n            return row * b + b - 1\n        else:\n            return row * b\n\n    result = []\n    for i in range(a):\n        row = []\n        for j in range(b):\n            if (i + j) % 2 == 0:\n                row.append(find_seat(i, \"R\"))\n            else:\n                row.append(find_seat(i, \"D\"))\n        result.append(row)\n\n    return \"\\n\".join([\" \".join(map(str, row)) for row in result])",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 911,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split('\\n')[0].split())\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    t = list(map(int, stdin.split('\\n')[2].split()))\n\n    limak_points = 0\n    radewoosh_points = 0\n\n    for i in range(n):\n        limak_points += max(0, p[i] - c * (sum(t[:i]) + i))\n        radewoosh_points += max(0, p[n - i - 1] - c * (sum(t[:n - i - 1]) + n - i - 1))\n\n    if limak_points > radewoosh_points:\n        return \"Limak\"\n    elif limak_points < radewoosh_points:\n        return \"Radewoosh\"\n    else:\n        return \"Tie\"",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 912,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_staircases(n, s, k, closed_restaurants):\n        min_staircases = n - 1\n        for i in range(1, n + 1):\n            if i not in closed_restaurants:\n                staircases = abs(s - i)\n                if staircases < min_staircases:\n                    min_staircases = staircases\n        return min_staircases\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n, s, k = map(int, stdin.readline().strip().split())\n        closed_restaurants = set(map(int, stdin.readline().strip().split()))\n        output.append(find_min_staircases(n, s, k, closed_restaurants))\n\n    return \"\\n\".join(map(str, output))\n",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 913,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    r = [int(x) for x in stdin.split('\\n')[1].split()]\n    b = [int(x) for x in stdin.split('\\n')[2].split()]\n\n    if sum(r) == 0 or sum(b) == 0:\n        return \"-1\"\n\n    r_points = [0] * n\n    b_points = [0] * n\n\n    for i in range(n):\n        if r[i] == 1:\n            r_points[i] = 1\n        if b[i] == 1:\n            b_points[i] = 1\n\n    while sum(r_points) <= sum(b_points):\n        for i in range(n):\n            if r[i] == 1 and b[i] == 1:\n                if r_points[i] < b_points[i]:\n                    r_points[i] += 1\n                else:\n                    b_points[i] += 1\n            elif r[i] == 1:\n                r_points[i] += 1\n            elif b[i] == 1:\n                b_points[i] += 1\n\n    max_point = max(max(r_points), max(b_points))\n\n    return str(max_point)",
        "test": "",
        "num_ids": 331,
        "indeed": false
    },
    {
        "number": 914,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split('\\n')\n    s = s.strip()\n    n = int(n.strip())\n\n    if len(s) % n != 0:\n        return \"-1\"\n\n    sheet = \"\"\n    for i in range(n):\n        sheet += s[i::n]\n\n    return f\"{len(s) // n}\\n{sheet}\"",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 915,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    result = \"codeforces\"\n\n    while k > 1:\n        result += \"s\"\n        k -= 1\n\n    return result",
        "test": "",
        "num_ids": 48,
        "indeed": false
    },
    {
        "number": 916,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, p = map(int, stdin.split())\n    return str(len(a) - 2)",
        "test": "",
        "num_ids": 31,
        "indeed": false
    },
    {
        "number": 917,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m = map(int, stdin.split()[0:3])\n    restrictions = []\n    for i in range(m):\n        l, r, x = map(int, stdin.split()[(i * 3) + 3:(i * 3) + 6])\n        restrictions.append((l, r, x))\n\n    def is_valid(heights: List[int]) -> bool:\n        for l, r, x in restrictions:\n            if max(heights[l - 1:r]) > x:\n                return False\n        return True\n\n    def profit(heights: List[int]) -> int:\n        return sum(height ** 2 for height in heights)\n\n    max_profit = 0\n    for i in range(1, 2 ** n):\n        heights = [h if (i & (1 << j)) else 0 for j in range(n)]\n        if is_valid(heights):\n            max_profit = max(max_profit, profit(heights))\n\n    return str(max_profit)",
        "test": "",
        "num_ids": 261,
        "indeed": false
    },
    {
        "number": 918,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_team(region_scores):\n        team = []\n        for score in sorted(region_scores, key=lambda x: x[1], reverse=True):\n            if score[0] not in [t[0] for t in team]:\n                team.append(score)\n            if len(team) == 2:\n                break\n        return team\n\n    def process_region(region_scores):\n        team = find_team(region_scores)\n        if len(team) == 2:\n            return \" \".join([surname for surname, _ in team])\n        else:\n            return \"?\"\n\n    n, m = map(int, stdin.readline().split())\n    data = [line.strip().split() for line in stdin.readlines()]\n    data.sort(key=lambda x: x[2], reverse=True)\n\n    region_scores = [[] for _ in range(m)]\n    for surname, region, points in data:\n        region_scores[int(region) - 1].append((surname, int(points)))\n\n    result = [process_region(scores) for scores in region_scores]\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 292,
        "indeed": false
    },
    {
        "number": 919,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stages = sorted(stdin.strip().split()[1], key=lambda x: ord(x))\n\n    def is_valid(rocket: str) -> bool:\n        for i in range(len(rocket) - 1):\n            if abs(ord(rocket[i]) - ord(rocket[i + 1])) < 2:\n                return False\n        return True\n\n    def dfs(stages: list, k: int, weight: int) -> int:\n        if k == 0:\n            return weight\n\n        if not stages:\n            return -1\n\n        min_weight = float('inf')\n        for i, stage in enumerate(stages):\n            new_stages = stages[:i] + stages[i + 1:]\n            new_weight = weight + ord(stage)\n            res = dfs(new_stages, k - 1, new_weight)\n            if res != -1:\n                min_weight = min(min_weight, res)\n\n        return min_weight if min_weight != float('inf') else -1\n\n    result = dfs(stages, k, 0)\n    return str(result) if result != -1 else '-1'",
        "test": "",
        "num_ids": 303,
        "indeed": false
    },
    {
        "number": 920,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    guardposts = []\n    for i in range(1, 5):\n        prices = list(map(int, stdin.split('\\n')[i].split()))\n        guardposts.append(prices)\n\n    for i, post in enumerate(guardposts):\n        total_cost = 0\n        for j in range(0, 4, 2):\n            chocolate_price, juice_price = post[j], post[j + 1]\n            if chocolate_price <= n and juice_price <= n:\n                total_cost += chocolate_price + juice_price\n            else:\n                break\n        if total_cost == n:\n            return f\"{i + 1} {chocolate_price} {juice_price}\\n\"\n    return \"-1\\n\"",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 921,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort(reverse=True)\n\n    if sum(a) < w:\n        return \"-1\"\n\n    tea_poured = [0] * n\n    for i in range(n):\n        tea_poured[i] = max(w // n, a[i] // 2)\n        w -= tea_poured[i]\n        n -= 1\n\n    return \" \".join(map(str, tea_poured))",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 922,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    d = list(map(int, input().split()))\n    res = []\n\n    for i in range(n):\n        if A > n * d[i]:\n            res.append(0)\n        else:\n            res.append(A - n * d[i] + d[i] - 1)\n\n    return \" \".join(map(str, res))",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 923,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, active_teeth = map(int, stdin.split())\n    sequence = [i for i in range(n)]\n\n    for i in range(n):\n        if active_teeth[i] != sequence[i]:\n            return \"No\"\n\n        if i % 2 == 0:\n            active_teeth[(i + 1) % n] -= 1\n        else:\n            active_teeth[(i + 1) % n] += 1\n\n        if active_teeth[(i + 1) % n] < 0:\n            active_teeth[(i + 1) % n] += n\n        elif active_teeth[(i + 1) % n] >= n:\n            active_teeth[(i + 1) % n] -= n\n\n    return \"Yes\"",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 924,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_a, r_a, t_a = map(int, stdin.readline().split())\n    l_b, r_b, t_b = map(int, stdin.readline().split())\n\n    max_days = 0\n    for k in range(t_a):\n        for i in range(l_a + k * t_a, r_a + k * t_a + 1):\n            if l_b <= i <= r_b and (i - l_b) % t_b == 0:\n                max_days = max(max_days, i - l_a - k * t_a + 1)\n\n    return str(max_days)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 925,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(10):\n        for j in range(10):\n            if i != j:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 926,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_volume(a, b, c):\n        return a * b * c\n\n    def get_radius(a, b, c):\n        return (a * b * c / (2 * 3.14159)) ** (1 / 3)\n\n    def can_merge(a1, b1, c1, a2, b2, c2):\n        for a, b, c in [(a1, b1, c1), (a2, b2, c2)]:\n            for face in [(a, b), (a, c), (b, c)]:\n                if face in [(a2, b2), (a2, c2), (b2, c2)]:\n                    return True\n        return False\n\n    n = int(stdin.readline())\n    stones = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.readline().split())\n        stones.append((a, b, c))\n\n    max_volume = 0\n    max_stones = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_merge(stones[i][0], stones[i][1], stones[i][2], stones[j][0], stones[j][1], stones[j][2]):\n                volume = get_volume(*stones[i], *stones[j])\n                if volume > max_volume:\n                    max_volume = volume\n                    max_stones = [i + 1, j + 1]\n\n    if max_volume == 0:\n        return f\"1\\n{1}\\n\"\n    else:\n        return f\"2\\n{max_stones[0]} {max_stones[1]}\\n\"",
        "test": "",
        "num_ids": 432,
        "indeed": false
    },
    {
        "number": 927,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort(reverse=True)\n\n    digits = [2, 5, 5, 4, 5, 6, 3, 7, 6]\n    result = []\n\n    for i in range(9, -1, -1):\n        while N >= digits[i] and A:\n            if A[-1] == i + 1:\n                N -= digits[i]\n                result.append(str(A.pop()))\n            else:\n                break\n\n    return \"\".join(result)",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 928,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, A = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    count = 0\n    left, right = 0, 0\n    current_sum = 0\n    while right < N:\n        current_sum += A[right]\n        while current_sum >= K:\n            count += right - left + 1\n            current_sum -= A[left]\n            left += 1\n        right += 1\n    return str(count)",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 929,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n\n    def find_moves(matrix: List[List[int]]) -> List[Tuple[int, int, int, int]]:\n        moves = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] > 0:\n                    if i > 0 and matrix[i - 1][j] % 2 != matrix[i][j] % 2:\n                        moves.append((i, j, i - 1, j))\n                    if i < len(matrix) - 1 and matrix[i + 1][j] % 2 != matrix[i][j] % 2:\n                        moves.append((i, j, i + 1, j))\n                    if j > 0 and matrix[i][j - 1] % 2 != matrix[i][j] % 2:\n                        moves.append((i, j, i, j - 1))\n                    if j < len(matrix[0]) - 1 and matrix[i][j + 1] % 2 != matrix[i][j] % 2:\n                        moves.append((i, j, i, j + 1))\n        return moves\n\n    def apply_move(matrix: List[List[int]], move: Tuple[int, int, int, int]) -> None:\n        i, j, i_new, j_new = move\n        matrix[i][j] -= 1\n        matrix[i_new][j_new] += 1\n\n    def count_even(matrix: List[List[int]]) -> int:\n        return sum(sum(is_even(cell) for cell in row) for row in matrix)\n\n    H, W = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(H)]\n\n    moves = find_moves(matrix)\n    max_even = count_even(matrix)\n    max_moves = []\n\n    for move in moves:\n        apply_move(matrix, move)\n        even_count = count_even(matrix)\n        if even_count > max_even:\n            max_even = even_count\n            max_moves = [move]\n        elif even_count == max_even:\n            max_moves.append(move)\n        apply_move(matrix, move)\n\n    output = [str(len(max_moves))]\n    for move in max_moves:\n        output.append(\" \".join(map(str, move)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 651,
        "indeed": false
    },
    {
        "number": 930,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    # Calculate the total number of possible combinations\n    total_combinations = pow(n, k, mod)\n\n    # Calculate the number of combinations where at least one person is in each room\n    at_least_one_in_each_room = (n - 1) * pow(n - 2, k - 1, mod) * (n - 1)\n    at_least_one_in_each_room %= mod\n\n    # Calculate the final result\n    result = (total_combinations - at_least_one_in_each_room) % mod\n\n    return str(result)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 931,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, z, p = map(int, stdin.split()[0].split())\n    candy_coordinates = [list(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def rotate_90_clockwise(matrix):\n        return [[matrix[j][n - i - 1] for j in range(m)] for i in range(n)]\n\n    def rotate_90_counterclockwise(matrix):\n        return [[matrix[n - j - 1][i] for j in range(m)] for i in range(n)]\n\n    def horizontal_flip(matrix):\n        return [row[::-1] for row in matrix]\n\n    for _ in range(x):\n        candy_coordinates = rotate_90_clockwise(candy_coordinates)\n    for _ in range(y):\n        candy_coordinates = horizontal_flip(candy_coordinates)\n    for _ in range(z):\n        candy_coordinates = rotate_90_counterclockwise(candy_coordinates)\n\n    return \"\\n\".join([\" \".join(map(str, coord)) for coord in candy_coordinates])",
        "test": "",
        "num_ids": 293,
        "indeed": false
    },
    {
        "number": 932,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    b = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def or_matrix(a):\n        return [[1 if any(row) else 0 for row in zip(*cols)] for cols in zip(*a)]\n\n    def is_possible(a):\n        return b == or_matrix(a)\n\n    def generate_matrix(m, n):\n        for a in range(2 ** (m * n)):\n            matrix = [[int(bit) for bit in format(a, f'0{m*n}b')[i:i+n]] for i in range(0, m*n, n)]\n            if is_possible(matrix):\n                return matrix\n        return None\n\n    a = generate_matrix(m, n)\n    if a is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, row)) for row in a)",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 933,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def correct_typo(word: str) -> str:\n        if len(word) < 3:\n            return word\n        for i in range(len(word) - 2):\n            if word[i] == word[i + 1] == word[i + 2]:\n                return word[:i] + word[i + 1:]\n        return word\n\n    def correct_typo2(word: str) -> str:\n        if len(word) < 5:\n            return word\n        for i in range(len(word) - 4):\n            if word[i] == word[i + 1] == word[i + 3] == word[i + 4]:\n                return word[:i] + word[i + 1:i + 3] + word[i + 4:]\n        return word\n\n    def delete_letters(word: str) -> str:\n        if len(word) < 3:\n            return word\n        for i in range(len(word) - 2):\n            if word[i] == word[i + 1] == word[i + 2]:\n                return word[:i] + word[i + 1:]\n        return word\n\n    def delete_letters2(word: str) -> str:\n        if len(word) < 5:\n            return word\n        for i in range(len(word) - 4):\n            if word[i] == word[i + 1] == word[i + 3] == word[i + 4]:\n                return word[:i] + word[i + 1:i + 3] + word[i + 4:]\n        return word\n\n    word = stdin\n    while True:\n        corrected_word = correct_typo(word)\n        corrected_word = correct_typo2(corrected_word)\n        if len(corrected_word) == len(word):\n            break\n        word = corrected_word\n\n    while True:\n        deleted_word = delete_letters(word)\n        deleted_word = delete_letters2(deleted_word)\n        if len(deleted_word) == len(word):\n            break\n        word = deleted_word\n\n    return word",
        "test": "",
        "num_ids": 529,
        "indeed": false
    },
    {
        "number": 934,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    table_card, hand_cards = stdin.split('\\n')\n    suit_table, rank_table = table_card\n    hand_cards = hand_cards.split()\n\n    for hand_card in hand_cards:\n        suit_hand, rank_hand = hand_card\n        if suit_hand == suit_table or rank_hand == rank_table:\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 99,
        "indeed": true
    },
    {
        "number": 935,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1 or m == 1:\n        return \"Akshat\"\n    else:\n        return \"Malvika\"",
        "test": "",
        "num_ids": 50,
        "indeed": false
    },
    {
        "number": 936,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    max_likes = max(a.count(x) for x in set(a))\n    winner = [x for x in set(a) if a.count(x) == max_likes][0]\n    return str(winner)",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 937,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    t = list(map(int, stdin.readline().split()))\n\n    max_theorems = 0\n    for i in range(n - k + 1):\n        current_theorems = sum(a[j] * t[j] for j in range(i, i + k))\n        max_theorems = max(max_theorems, current_theorems)\n\n    return str(max_theorems)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 938,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    n = min(a, b)\n    p = list(range(1, n + 1))\n\n    m = b - n\n    q = list(range(1, m + 1))\n\n    return f\"{n}\\n{' '.join(map(str, p))}\\n{m}\\n{' '.join(map(str, q))}\\n\" ",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 939,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(dance, dancers):\n        for color in dance:\n            if dancers[color] == 0:\n                return False\n            dancers[color] -= 1\n        return True\n\n    def recover(dance, dancers):\n        for color in dance:\n            dancers[color] += 1\n\n    def assign_colors(n, m, dances):\n        dancers = [0, 0, 0]\n        colors = [1, 2, 3]\n        result = [0] * n\n\n        for dance in dances:\n            for color in colors:\n                if dance.count(color) > 0:\n                    for dancer in dance:\n                        if result[dancer - 1] == 0:\n                            result[dancer - 1] = color\n                            dancers[color - 1] += 1\n                            break\n\n        return result\n\n    n, m = map(int, stdin.readline().split())\n    dances = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    result = assign_colors(n, m, dances)\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 303,
        "indeed": false
    },
    {
        "number": 940,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    def is_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    if is_triangle(a, b, c):\n        return \"0\"\n\n    minutes = 0\n    while not is_triangle(a, b, c):\n        if a < b and a < c:\n            a += 1\n        elif b < a and b < c:\n            b += 1\n        else:\n            c += 1\n        minutes += 1\n\n    return str(minutes)",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 941,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    n = 0\n    for i in range(k):\n        n += a[i] * (b ** (k - 1 - i))\n    return \"even\" if n % 2 == 0 else \"odd\"",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 942,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_valid(b: List[int]) -> bool:\n        for i in range(n):\n            count = 0\n            for j in range(n):\n                if b[j] != b[i]:\n                    count += 1\n            if count != a[i]:\n                return False\n        return True\n\n    def dfs(depth: int, b: List[int]) -> bool:\n        if depth == n:\n            return check_valid(b)\n        for i in range(1, n + 1):\n            b[depth] = i\n            if dfs(depth + 1, b):\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if sum(a) > n * (n - 1):\n        return \"Impossible\"\n\n    b = [0] * n\n    if dfs(0, b):\n        return \"Possible\\n\" + \" \".join(map(str, b))\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 266,
        "indeed": false
    },
    {
        "number": 943,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    integers = list(map(int, stdin.split('\\n')[1].split()))\n    even_sum = 0\n    odd_sum = 0\n\n    for num in integers:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            if odd_sum < num:\n                odd_sum = num\n\n    return str(even_sum + odd_sum)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 944,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, roads = int(stdin.split(\"\\n\", 1)[0]), [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    days = []\n    while roads:\n        day = []\n        for i, (u, v) in enumerate(roads):\n            if u == v:\n                continue\n            if u in day or v in day:\n                continue\n            day.extend([u, v])\n        days.append(day)\n        roads = [road for road in roads if road[0] not in day and road[1] not in day]\n    output = [f\"{len(day)} {' '.join(map(str, day))}\" for day in days]\n    return f\"{len(days)}\\n\" + \"\\n\".join(output)",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 945,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    points = sorted(list(map(int, stdin.split(\"\\n\")[1].split())))\n\n    def is_intersect(p1, p2, p3, p4):\n        x1, x2, x3, x4 = p1[0], p2[0], p3[0], p4[0]\n        y1, y2, y3, y4 = p1[1], p2[1], p3[1], p4[1]\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) * \\\n               (x3 * (y4 - y1) + x4 * (y1 - y3) + x1 * (y3 - y4)) >= 0 \\\n            and (x1 * (y2 - y4) + x2 * (y4 - y1) + x4 * (y1 - y2)) * \\\n               (x4 * (y3 - y1) + x3 * (y1 - y4) + x1 * (y4 - y3)) >= 0\n\n    for i in range(n - 2):\n        for j in range(i + 2, n - 1):\n            if is_intersect((points[i], 0), (points[i + 1], 0), (points[j], 0), (points[j + 1], 0)):\n                return \"yes\"\n    return \"no\"",
        "test": "",
        "num_ids": 371,
        "indeed": false
    },
    {
        "number": 946,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    responses = list(map(int, stdin.split('\\n')[1].split()))\n\n    if 1 in responses:\n        return \"HARD\"\n    else:\n        return \"EASY\"",
        "test": "",
        "num_ids": 65,
        "indeed": true
    },
    {
        "number": 947,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_min_lcm(n):\n        min_lcm = float('inf')\n        for i in range(1, n // 2 + 1):\n            j = n - i\n            if i * j <= min_lcm:\n                min_lcm = lcm(i, j)\n        return min_lcm\n\n    test_cases = [int(x) for x in stdin.split('\\n') if x.isdigit()]\n    test_cases.pop(0)\n\n    output = []\n    for n in test_cases:\n        min_lcm = find_min_lcm(n)\n        a = n // 2\n        b = n - a\n        if lcm(a, b) != min_lcm:\n            for i in range(1, n // 2 + 1):\n                j = n - i\n                if lcm(i, j) == min_lcm:\n                    a = i\n                    b = j\n                    break\n        output.append(f\"{a} {b}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 948,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    image = [list(input()) for _ in range(n)]\n    faces_count = 0\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if image[i][j] == 'f' and image[i][j + 1] == 'a' and image[i + 1][j] == 'c' and image[i + 1][j + 1] == 'e':\n                faces_count += 1\n\n    return str(faces_count)",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 949,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    gcd = 1\n    for i in range(2, int(b**0.5) + 1):\n        if a % i == 0 and b % i == 0:\n            gcd = i\n            while a % gcd == 0 and b % gcd == 0:\n                a //= gcd\n                b //= gcd\n    if a > 1:\n        gcd = a\n    elif b > 1:\n        gcd = b\n    return str(gcd)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 950,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_valid(s: str) -> bool:\n        return any(c.isdigit() for c in s) and any(c.islower() for c in s) and any(c in '#*&' for c in s)\n\n    def move_pointer(s: str, i: int, direction: str) -> str:\n        if direction == 'left':\n            return s[i - 1:] + s[:i - 1]\n        else:\n            return s[i + 1:] + s[:i + 1]\n\n    def get_displayed_string(strings: List[str]) -> str:\n        return ''.join(s[i] for i, s in enumerate(strings))\n\n    def min_operations(strings: List[str]) -> int:\n        displayed_string = get_displayed_string(strings)\n        if is_valid(displayed_string):\n            return 0\n\n        min_ops = float('inf')\n        for i in range(n):\n            for direction in ('left', 'right'):\n                new_strings = [move_pointer(s, i + 1, direction) for s in strings]\n                new_displayed_string = get_displayed_string(new_strings)\n                if is_valid(new_displayed_string):\n                    min_ops = min(min_ops, 1 + min_operations(new_strings))\n\n        return min_ops\n\n    return min_operations(strings)",
        "test": "",
        "num_ids": 390,
        "indeed": false
    },
    {
        "number": 951,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    initial_sum = sum(map(int, str(n)))\n    if initial_sum < k:\n        return \"0\"\n    else:\n        n_str = str(n)\n        min_diff = float(\"inf\")\n        for i in range(len(n_str)):\n            for j in range(10):\n                new_digit = str(j)\n                if new_digit != n_str[i]:\n                    new_number = n_str[:i] + new_digit + n_str[i + 1:]\n                    diff = abs(sum(map(int, str(int(new_number))) if new_number != \"0\" else [0]) - k)\n                    min_diff = min(min_diff, diff)\n        return str(min_diff)",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 952,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def is_connected(n, m, edges):\n        graph = [[] for _ in range(n)]\n        for u, v, _ in edges:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n        visited = [False] * n\n        dfs(0, visited)\n        return all(visited)\n\n    def find_roads_to_reverse(n, m, edges, k):\n        result = []\n        for i, (u, v, c) in enumerate(edges):\n            edges[i][2] -= k\n            if edges[i][2] <= 0:\n                result.append((u, v))\n        return result\n\n    def reverse_roads(n, m, edges, k):\n        roads_to_reverse = find_roads_to_reverse(n, m, edges, k)\n        for u, v in roads_to_reverse:\n            for i, (su, sv, c) in enumerate(edges):\n                if su == u and sv == v:\n                    edges[i][2] = 0\n                elif su == v and sv == u:\n                    edges[i][2] = 0\n        return roads_to_reverse\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n\n    k = 0\n    while not is_connected(n, m, edges):\n        k += 1\n        reverse_roads(n, m, edges, k)\n\n    roads_to_reverse = find_roads_to_reverse(n, m, edges, k)\n    output = [str(k), str(len(roads_to_reverse))]\n    output.extend(str(i + 1) for i in range(len(roads_to_reverse)))\n    return '\\n'.join(output) + '\\n'",
        "test": "",
        "num_ids": 529,
        "indeed": false
    },
    {
        "number": 953,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prettier(p: List[int], k: int) -> bool:\n        for i in range(1, k):\n            if p[i] == p[i - 1] + 1:\n                return False\n        return p[k] > p[k - 1]\n\n    def find_prettiest_permutation(p: List[int], A: List[List[int]]) -> List[int]:\n        for k in range(1, len(p)):\n            if is_prettier(p, k):\n                for i in range(1, len(p)):\n                    if A[p[i] - 1][p[k] - 1] == 1 and p[i] != p[k]:\n                        p[i], p[k] = p[k], p[i]\n                        return p\n        return p\n\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    A = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    prettiest_permutation = find_prettiest_permutation(p, A)\n    return ' '.join(map(str, prettiest_permutation))",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 954,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    if n == 1 or len(set(s)) == 1:\n        return 1\n    else:\n        return n",
        "test": "",
        "num_ids": 46,
        "indeed": false
    },
    {
        "number": 955,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    juices = [line.split() for line in stdin.split('\\n')[1:]]\n    prices = [int(price) for price, _ in juices]\n    vitamins = [''.join(sorted(vitamins)) for _, vitamins in juices]\n\n    min_price = float('inf')\n    for a in range(n):\n        if vitamins[a] == 'ABC':\n            min_price = min(min_price, prices[a])\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            if vitamins[a] + vitamins[b] == 'ABC':\n                min_price = min(min_price, prices[a] + prices[b])\n\n    for a in range(n):\n        for b in range(a + 1, n):\n            for c in range(b + 1, n):\n                if vitamins[a] + vitamins[b] + vitamins[c] == 'ABC':\n                    min_price = min(min_price, prices[a] + prices[b] + prices[c])\n\n    return str(min_price) if min_price != float('inf') else '-1'",
        "test": "",
        "num_ids": 311,
        "indeed": false
    },
    {
        "number": 957,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    if \"heidi\" in stdin:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 28,
        "indeed": false
    },
    {
        "number": 958,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    if k < n or k > 26 * n:\n        return \"-1\"\n\n    s_prime = ['a'] * n\n    for i in range(n):\n        s_prime[i] = chr((ord(s_prime[i]) - ord('a') + k - 26 * i) % 26 + ord('a'))\n\n    return ''.join(s_prime)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 959,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, mod = map(int, stdin.split())\n    given_rows = []\n    for _ in range(m):\n        row = input()\n        given_rows.append(row)\n\n    def is_special(matrix: list) -> bool:\n        for i in range(n):\n            if matrix[i].count('1') != 2:\n                return False\n        for j in range(n):\n            ones_count = sum(int(matrix[i][j]) for i in range(n))\n            if ones_count != 2:\n                return False\n        return True\n\n    def count_special_matrices(given_rows: list) -> int:\n        if len(given_rows) == n:\n            return is_special(given_rows)\n\n        count = 0\n        for row in generate_rows(n, len(given_rows) + 1):\n            count += count_special_matrices(given_rows + [row])\n            count %= mod\n\n        return count\n\n    def generate_rows(n: int, current_row: int) -> list:\n        if current_row == n:\n            return [[]]\n\n        rows = []\n        for bit in ['0', '1']:\n            for row in generate_rows(n, current_row + 1):\n                rows.append([bit] + row)\n\n        return rows\n\n    return count_special_matrices(given_rows)",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 960,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n\n    while True:\n        if (x // k) * (x % k) == n:\n            return str(x)\n        x += 1",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 961,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def xor(a, b):\n        return a ^ b\n\n    def max_comfort(a, l, r):\n        return sum([xor(a[i], a[j]) for i in range(l, r + 1) for j in range(l, r + 1)])\n\n    total_comfort = 0\n    for i in range(n):\n        for j in range(i, n):\n            total_comfort = max(total_comfort, max_comfort(a, i, j))\n\n    return str(total_comfort)",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 962,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subgraph(graph, n, m, a, b):\n        in_degree = [0] * (n + 1)\n        out_degree = [0] * (n + 1)\n        for i in range(m):\n            in_degree[b[i]] += 1\n            out_degree[a[i]] += 1\n\n        for i in range(1, n + 1):\n            if in_degree[i] == 1 and out_degree[i] == 1:\n                graph[i] = [v for v in graph[i] if in_degree[v] == 1 and out_degree[v] == 1]\n\n        for i in range(1, n + 1):\n            if len(graph[i]) == 1:\n                return True\n        return False\n\n    def dfs(graph, start, visited):\n        if visited[start]:\n            return []\n        visited[start] = True\n        result = [start]\n        for v in graph[start]:\n            result.extend(dfs(graph, v, visited))\n        return result\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a, b = zip(*[map(int, line.split()) for line in lines[1:]])\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        graph[a[i]].append(b[i])\n\n    if find_subgraph(graph, n, m, a, b):\n        for i in range(1, n + 1):\n            if len(graph[i]) == 1:\n                start = i\n                break\n        visited = [False] * (n + 1)\n        result = dfs(graph, start, visited)\n        return f\"{len(result)}\\n{' '.join(map(str, result))}\"\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 482,
        "indeed": false
    },
    {
        "number": 963,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    S = set()\n    for _ in range(K):\n        L, R = map(int, stdin.readline().split())\n        S.update(range(L, R + 1))\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    MOD = 998244353\n\n    for i in range(2, N + 1):\n        for j in S:\n            if i - j >= 1:\n                dp[i] += dp[i - j]\n                dp[i] %= MOD\n\n    return str(dp[N])",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 964,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n\n    def is_possible(n: int) -> bool:\n        if n < max(x1, y1, x2, y2, x3, y3):\n            return False\n\n        for i in range(n - max(x1, y1, x2, y2, x3, y3) + 1):\n            for j in range(n - max(x1, y1, x2, y2, x3, y3) + 1):\n                if (\n                    i + x1 <= n\n                    and j + y1 <= n\n                    and i + x2 <= n\n                    and j + y2 <= n\n                    and i + x3 <= n\n                    and j + y3 <= n\n                ):\n                    return True\n        return False\n\n    for n in range(max(x1, y1, x2, y2, x3, y3), 2 * max(x1, y1, x2, y2, x3, y3) + 1):\n        if is_possible(n):\n            result = [[\"A\"] * n for _ in range(n)]\n            for i in range(x1):\n                for j in range(y1):\n                    result[i][j] = \"A\"\n            for i in range(x2):\n                for j in range(y2):\n                    result[i][j + y1] = \"B\"\n            for i in range(x3):\n                for j in range(y3):\n                    result[i + x1][j + y1 + y2] = \"C\"\n            return str(n) + \"\\n\" + \"\\n\".join([\"\".join(row) for row in result])\n    return \"-1\"",
        "test": "",
        "num_ids": 442,
        "indeed": false
    },
    {
        "number": 965,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    statuses = stdin.split('\\n')[1]\n\n    count = 0\n    for i in range(n):\n        if statuses[i] == \"I\" or statuses[i] == \"A\":\n            all_folded = True\n            for j in range(n):\n                if j != i and statuses[j] != \"F\":\n                    all_folded = False\n                    break\n            if all_folded:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 966,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin)\n    while True:\n        year += 1\n        if len(set(str(year))) == len(str(year)):\n            return str(year)",
        "test": "",
        "num_ids": 46,
        "indeed": true
    },
    {
        "number": 967,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    count = 0\n    for i in range(1, n + 1):\n        if a.index(i) != i - 1:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 968,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    def is_valid(names, handles, p):\n        for i in range(len(p) - 1):\n            if p[i] > p[i + 1]:\n                return False\n        return True\n\n    def lexicographical_order(names, handles, p):\n        for i in range(len(p) - 1):\n            if p[i] > p[i + 1]:\n                return False\n        return True\n\n    def find_handles(names, handles, p):\n        for i in range(len(names)):\n            if p[i] - 1 == i:\n                handles.append(names[i][0])\n            else:\n                handles.append(names[i][1])\n\n    def check_handles(handles, p):\n        for i in range(len(p) - 1):\n            if handles[p[i] - 1] > handles[p[i + 1] - 1]:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    names = []\n    for i in range(1, n + 1):\n        names.append(lines[i].split())\n    p = list(map(int, lines[-1].split()))\n\n    handles = []\n    find_handles(names, handles, p)\n\n    if check_handles(handles, p):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 403,
        "indeed": false
    },
    {
        "number": 969,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = -1\n    result = []\n\n    for i in range(len(t)):\n        if t[i:] == s:\n            n += 1\n            result.append((0, i))\n\n    for i in range(len(t) - 1, -1, -1):\n        if t[:i] == s:\n            n += 1\n            result.append((i, len(t)))\n\n    if n == -1:\n        return \"-1\\n\"\n\n    result.sort(key=lambda x: x[1] - x[0])\n\n    output = str(n) + \"\\n\"\n    for x, y in result:\n        output += f\"{x + 1} {y}\\n\"\n\n    return output",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 970,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, positions = map(int, stdin.split())\n    positions = sorted(positions)\n    moves = 0\n\n    for i in range(1, len(positions), 2):\n        moves += abs(positions[i] - positions[i - 1]) - 1\n\n    return str(moves)",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 971,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, d = map(int, stdin.split()[0].split())\n    oranges = list(map(int, stdin.split()[1].split()))\n\n    waste_count = 0\n    total_size = 0\n\n    for i in range(n):\n        if oranges[i] <= b:\n            total_size += oranges[i]\n            if total_size > d:\n                total_size = oranges[i]\n                waste_count += 1\n        else:\n            continue\n\n    return str(waste_count)",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 972,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(n):\n        grid.append(stdin.readline().strip())\n\n    def is_convex(x: int, y: int) -> bool:\n        dx, dy = 0, 1\n        while 0 <= x < n and 0 <= y < m:\n            if grid[x][y] == \"B\":\n                return True\n            dx, dy = dy, -dx\n            x, y = x + dx, y + dy\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \"B\" and not is_convex(i, j):\n                return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 973,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(row, col, pasture, visited):\n        if pasture[row][col] == 'W':\n            return False\n        if (row, col) in visited:\n            return True\n        visited.add((row, col))\n        for r, c in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + r, col + c\n            if 0 <= new_row < R and 0 <= new_col < C and is_safe(new_row, new_col, pasture, visited):\n                return True\n        return False\n\n    R, C = map(int, stdin.readline().split())\n    pasture = [list(stdin.readline().strip()) for _ in range(R)]\n    dogs = []\n\n    for row in range(R):\n        for col in range(C):\n            if pasture[row][col] == 'S' and not is_safe(row, col, pasture, set()):\n                return \"No\"\n\n    for row in range(R):\n        for col in range(C):\n            if pasture[row][col] == '.':\n                pasture[row][col] = 'D'\n                dogs.append((row, col))\n                break\n\n    for dog_row, dog_col in dogs:\n        for row in range(R):\n            for col in range(C):\n                if pasture[row][col] == 'S' and not is_safe(row, col, pasture, set()):\n                    pasture[dog_row][dog_col] = '.'\n                    pasture[row][col] = 'D'\n                    dogs.append((row, col))\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n\n    return \"Yes\\n\" + \"\\n\".join(\"\".join(row) for row in pasture)",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 974,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stack = []\n    remove_commands = []\n    add_commands = []\n\n    for _ in range(2 * n):\n        command = stdin.readline().strip().split()\n        if command[0] == \"add\":\n            add_commands.append(int(command[1]))\n        else:\n            remove_commands.append(None)\n\n    for i in range(n):\n        while stack and stack[-1] != add_commands[i]:\n            stack.pop()\n        if not stack:\n            remove_commands[i] = \"impossible\"\n        else:\n            stack.pop()\n\n    reorder_count = 0\n    for i in range(n):\n        if remove_commands[i] == \"impossible\":\n            reorder_count += 1\n            break\n        if i > 0 and remove_commands[i] != remove_commands[i - 1]:\n            reorder_count += 1\n\n    return str(reorder_count)",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 975,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sherlock = stdin.split('\\n')[1]\n    moriarty = stdin.split('\\n')[2]\n\n    min_flicks = 0\n    max_flicks = 0\n\n    for i in range(n):\n        if sherlock[i] != moriarty[i]:\n            if sherlock[i] < moriarty[i]:\n                max_flicks += 1\n            else:\n                min_flicks += 1\n\n    return f\"{min_flicks}\\n{max_flicks}\"",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 976,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    best_moments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        best_moments.append((l, r))\n\n    best_moments.sort(key=lambda x: x[1])\n\n    current_time = 1\n    total_minutes = 0\n\n    for i in range(n):\n        l, r = best_moments[i]\n        if l > current_time:\n            total_minutes += l - current_time\n            current_time = l\n        total_minutes += r - l + 1\n        current_time = r + 1\n        if i < n - 1 and best_moments[i + 1][0] - 1 < l:\n            total_minutes -= x\n\n    return str(total_minutes)",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 977,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(x: int) -> bool:\n        return f(x) % p != 0\n\n    def f(x: int) -> int:\n        return sum(1 for p in permutations(range(1, n + 1)) if all(x >= a[i] for i in range(n) if p[i] < p[i + 1]))\n\n    n, p = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    good_numbers = [x for x in range(1, n + 1) if is_good(x)]\n    return f\"{len(good_numbers)}\\n{' '.join(map(str, good_numbers))}\"",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 978,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline())\n    table = []\n    for _ in range(4):\n        row = stdin.readline().strip()\n        table.append(row)\n\n    def is_valid(table: list) -> bool:\n        for row in table:\n            for i in range(4):\n                if row[i] != \".\":\n                    if i == 0 or row[i - 1] == \".\":\n                        if i == 3 or row[i + 1] == \".\":\n                            return False\n        return True\n\n    if is_valid(table):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 979,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    result = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            result = (result * abs(a[i] - a[j])) % m\n\n    return str(result)",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 980,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.readline().split())\n    s_lst = [stdin.readline().strip() for _ in range(k)]\n\n    if k * n > 5000:\n        return -1\n\n    s = s_lst[0]\n    for i in range(1, k):\n        s_new = ''\n        for j in range(n):\n            if s_lst[i][j] != s[j]:\n                if s_new.count(s_lst[i][j]) == 0:\n                    s_new += s_lst[i][j]\n                else:\n                    s_new += s[j]\n            else:\n                s_new += s_lst[i][j]\n        s = s_new\n\n    if len(set(s)) == n:\n        return s\n    else:\n        return -1",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 981,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    v, a = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    max_num = -1\n\n    for i in range(1, 10):\n        if v >= a[i - 1]:\n            v -= a[i - 1]\n            max_num = i\n        else:\n            break\n\n    return str(max_num) * max_num if max_num != -1 else \"-1\"",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 982,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_buy_more(a: int, l: int, r: int) -> bool:\n        return l <= a // 2 and a <= r\n\n    def find_pack_size(l: int, r: int) -> bool:\n        for a in range(l, r + 1):\n            if can_buy_more(a, l, r):\n                return True\n        return False\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        if find_pack_size(l, r):\n            result.append('YES')\n        else:\n            result.append('NO')\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 198,
        "indeed": false
    },
    {
        "number": 983,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, r = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_value = float('-inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                max_value = max(max_value, p * a[i] + q * a[j] + r * a[k])\n\n    return str(max_value)",
        "test": "",
        "num_ids": 133,
        "indeed": true
    },
    {
        "number": 984,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tree = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find(t, x):\n        if t[1] == -1 and t[2] == -1:\n            return x != t[0]\n        if x < t[0]:\n            return find(tree[t[1]], x)\n        else:\n            return find(tree[t[2]], x)\n\n    fails = sum(find(tree[i], i) for i in range(n))\n    return str(fails)",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 985,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    bishops = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        bishops.append((x, y))\n\n    def is_attacking(bishop1: tuple, bishop2: tuple) -> bool:\n        return abs(bishop1[0] - bishop2[0]) == abs(bishop1[1] - bishop2[1])\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_attacking(bishops[i], bishops[j]):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 986,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    book_count = [0] * (n + 1)\n    for i in range(n):\n        book_count[a[i]] += 1\n\n    max_count = max(book_count)\n    cost = 0\n\n    for i in range(1, n + 1):\n        if book_count[i] == 0:\n            cost += 1\n            book_count[i] = 1\n\n    for i in range(1, n + 1):\n        if book_count[i] > k - max_count:\n            cost += k - max_count\n\n    return str(cost)",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 987,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    pairs = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    for a, b in pairs:\n        p[a - 1], p[b - 1] = p[b - 1], p[a - 1]\n\n    return \" \".join(map(str, sorted(set(p), reverse=True)))",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 988,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    classroom = [list(row) for row in stdin.split(\"\\n\")]\n    max_convenience = 0\n    max_convenience_index = (0, 0)\n\n    for i, row in enumerate(classroom):\n        for j in range(3):\n            if row[j * 3 + 1] == \".\":\n                convenience = (i + 1) * (j + 1)\n                if convenience > max_convenience:\n                    max_convenience = convenience\n                    max_convenience_index = (i, j)\n\n    i, j = max_convenience_index\n    classroom[i][j * 3 + 1] = \"P\"\n\n    return \"\\n\".join([\"\".join(row) for row in classroom])",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 989,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n\n    min_diff = a[-1] - a[0]\n\n    for i in range(n - 1):\n        min_diff = min(min_diff, a[i + 1] - a[i])\n\n    return str(min_diff)",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 990,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(painted_edges: str) -> bool:\n        for i in range(1, M + 1):\n            u, v = U[i], V[i]\n            if painted_edges[u - 1] == painted_edges[v - 1] == \"0\":\n                return False\n        return True\n\n    def count_valid_paintings(painted_edges: str, index: int) -> int:\n        if index == N - 1:\n            return is_valid(painted_edges)\n        count = 0\n        painted_edges[index] = \"0\"\n        count += count_valid_paintings(painted_edges, index + 1)\n        painted_edges[index] = \"1\"\n        count += count_valid_paintings(painted_edges, index + 1)\n        return count\n\n    lines = stdin.split(\"\\n\")\n    N, M = map(int, lines[0].split())\n    U, V = [], []\n    for i in range(1, M + 1):\n        u, v = map(int, lines[i].split())\n        U.append(u)\n        V.append(v)\n\n    painted_edges = [\"0\"] * N\n    return str(count_valid_paintings(painted_edges, 0))",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 991,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        distances = {vertex: float('infinity') for vertex in graph}\n        distances[start] = 0\n        pq = [(0, start)]\n        while pq:\n            current_distance, current_vertex = heapq.heappop(pq)\n            if current_vertex == end:\n                return current_distance\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor, weight in graph[current_vertex].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        return -1\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N, M, S = map(int, lines[0].split())\n        U, V, A, B = zip(*[map(int, line.split()) for line in lines[1:M + 1]])\n        C, D = zip(*[map(int, line.split()) for line in lines[M + 1:]])\n        return N, M, S, U, V, A, B, C, D\n\n    N, M, S, U, V, A, B, C, D = parse_input(stdin)\n    graph = defaultdict(dict)\n    for i in range(M):\n        graph[U[i]][V[i]] = A[i]\n        graph[V[i]][U[i]] = A[i]\n\n    for i in range(N):\n        graph[i + 1][0] = C[i]\n        graph[0][i + 1] = D[i]\n\n    result = []\n    for t in range(2, N + 1):\n        distance = dijkstra(graph, 1, t)\n        result.append(distance)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 490,
        "indeed": false
    },
    {
        "number": 992,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    MOD = 998244353\n\n    def f(T):\n        T = sorted(T)\n        subsets = [[]]\n        for i in range(len(T)):\n            for j in range(len(subsets)):\n                subsets.append(subsets[j] + [T[i]])\n        return sum(1 for subset in subsets if sum(A[i] for i in subset) == S)\n\n    total = 0\n    for i in range(2**N):\n        T = [j+1 for j in range(N) if i & (1<<j)]\n        total += f(T)\n        total %= MOD\n\n    return str(total)",
        "test": "",
        "num_ids": 198,
        "indeed": false
    },
    {
        "number": 993,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for l in range(1, N + 1):\n        total = 0\n        for i in range(l - 1, N):\n            total += A[i]\n            if total % M == 0:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 994,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    h = [0] * (n + 1)\n\n    for _ in range(m):\n        d, hi = map(int, stdin.readline().split())\n        if abs(h[d - 1] - hi) > 1:\n            return \"IMPOSSIBLE\"\n        h[d] = hi\n\n    return str(max(h))\n",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 995,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n\n    def min_groups(start, end):\n        if start == end:\n            return 1\n\n        min_groups_count = float('inf')\n        for i in range(start, end):\n            left_groups = min_groups(start, i)\n            right_groups = min_groups(i + 1, end)\n\n            if not left_groups or not right_groups:\n                continue\n\n            for j in range(i + 1, end + 1):\n                if is_perfect_square(arr[start] * arr[j - 1]):\n                    min_groups_count = min(min_groups_count, left_groups + right_groups)\n\n        return min_groups_count\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = min_groups(0, i)\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 996,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    layers = []\n    for _ in range(n):\n        layer = []\n        for _ in range(m):\n            layer.append(stdin.readline().strip())\n        stdin.readline()\n        layers.append(layer)\n\n    def is_critical(x, y, z):\n        if layers[x - 1][y - 1][z - 1] == \"1\":\n            return False\n        for dx, dy, dz in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n            nx, ny, nz = x + dx, y + dy, z + dz\n            if 1 <= nx <= n and 1 <= ny <= m and 1 <= nz <= k and layers[nx - 1][ny - 1][nz - 1] == \"1\":\n                return True\n        return False\n\n    critical_cpus = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            for z in range(1, k + 1):\n                if is_critical(x, y, z):\n                    critical_cpus += 1\n\n    return str(critical_cpus)",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 997,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(';')\n    a = []\n    b = []\n\n    for word in words:\n        if word.isdigit() and int(word) >= 0:\n            a.append(word)\n        else:\n            b.append(word)\n\n    if not a:\n        a_str = '-'\n    else:\n        a_str = ','.join(a)\n\n    if not b:\n        b_str = '-'\n    else:\n        b_str = ','.join(b)\n\n    return f'\"{a_str}\"\\n\"{b_str}\"'",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 998,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    l = 0\n    a = []\n\n    if n == 1:\n        l = 0\n    elif x == 1:\n        l = 2\n        a = [1, 2]\n    else:\n        l = 3\n        a = [1, 2, 1]\n\n    return f\"{l}\\n{' '.join(map(str, a))}\"",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 999,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    chess_periods = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    programming_periods = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def distance(l1, r1, l2, r2):\n        return min(abs(l1 - r2), abs(l2 - r1))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(m):\n            max_distance = max(max_distance, distance(*chess_periods[i], *programming_periods[j]))\n\n    return str(max_distance)",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1000,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    fuel_costs = list(range(1, n + 1))\n    total_cost = 0\n    current_fuel = 0\n\n    for i in range(1, n):\n        if current_fuel < 1:\n            total_cost += fuel_costs[i - 1]\n            current_fuel = v\n        current_fuel -= 1\n\n    return str(total_cost + fuel_costs[-1])",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1001,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    petya = 0\n    gena = 0\n\n    while n > 1:\n        k = 2\n        max_sum = float('-inf')\n        for i in range(2, n + 1):\n            if sum(a[:i]) > max_sum:\n                max_sum = sum(a[:i])\n                k = i\n\n        if petya <= gena:\n            petya += max_sum\n        else:\n            gena += max_sum\n\n        a = a[k:] + [max_sum]\n        n = len(a)\n\n    if petya == gena:\n        return 0\n    else:\n        return petya - gena",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1002,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    t = list(map(int, input().split()))\n\n    total_time = sum(t) + 10 * n\n    if total_time > d:\n        return -1\n\n    max_jokes = (d - total_time) // 5\n    return max_jokes",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1003,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = 0\n    pairs = n\n    while pairs > 0:\n        days += 1\n        if days % m == 0:\n            pairs += 1\n        pairs -= 1\n    return str(days)",
        "test": "",
        "num_ids": 70,
        "indeed": true
    },
    {
        "number": 1004,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_day(day: List[int]) -> bool:\n        employees = set()\n        for event in day:\n            if event > 0:\n                if event in employees:\n                    return False\n                employees.add(event)\n            else:\n                if abs(event) not in employees:\n                    return False\n                employees.remove(abs(event))\n        return True\n\n    def find_valid_partition(a: List[int], start: int, end: int) -> List[List[int]]:\n        if start == end:\n            return [[a[start]]]\n\n        partitions = []\n        for i in range(start, end):\n            for left_partition in find_valid_partition(a, start, i):\n                for right_partition in find_valid_partition(a, i + 1, end):\n                    if is_valid_day(left_partition + right_partition):\n                        partitions.append(left_partition + right_partition)\n\n        return partitions\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    partitions = find_valid_partition(a, 0, n - 1)\n\n    if not partitions:\n        return \"-1\"\n\n    days = len(partitions)\n    lengths = [len(partition) for partition in partitions]\n\n    return f\"{days}\\n{' '.join(map(str, lengths))}\"",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 1005,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_subscriptions(n: int, k: int, d: int, shows: List[int]) -> int:\n        subscriptions = set()\n        for i in range(n - d + 1):\n            subscription = set(shows[i + j] for j in range(d))\n            subscriptions.add(tuple(sorted(subscription)))\n        return len(subscriptions)\n\n    t = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n', 1)[1].split('\\n')\n    result = []\n\n    for i in range(t):\n        n, k, d = map(int, lines[i * 2].split())\n        shows = list(map(int, lines[i * 2 + 1].split()))\n        result.append(min_subscriptions(n, k, d, shows))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 1006,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    board = []\n    for i in range(n):\n        board.append(list(stdin.readline().strip()))\n\n    crosses = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '#':\n                cross = set()\n                for di, dj in [(-2, -1), (-2, 1), (2, -1), (2, 1)]:\n                    if 0 <= i + di < n and 0 <= j + dj < n and board[i + di][j + dj] == '#':\n                        cross.add((i + di, j + dj))\n                if len(cross) == 4:\n                    for di, dj in [(-1, -2), (1, -2), (-1, 2), (1, 2)]:\n                        if 0 <= i + di < n and 0 <= j + dj < n and board[i + di][j + dj] == '#' and (i + di, j + dj) not in cross:\n                            cross.add((i + di, j + dj))\n                            if len(cross) == 5:\n                                crosses.append(cross)\n\n    if len(crosses) == 0:\n        return \"NO\"\n    else:\n        return \"YES\"",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 1007,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p = map(int, stdin.split())\n    zcy_numbers = []\n\n    for i in range(1, 10 ** 4):\n        if str(i) == str(i)[::-1] and len(str(i)) % 2 == 0:\n            zcy_numbers.append(i)\n\n        if len(zcy_numbers) == k:\n            break\n\n    return sum(zcy_numbers) % p\n",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1008,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split('\\n')\n    k = int(k)\n    n = len(s)\n    if n % k != 0:\n        return \"NO\"\n    l = n // k\n    for i in range(l):\n        for j in range(i, i + l):\n            if s[j] != s[i + l - 1 - (j - i)]:\n                return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 1009,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sizes = list(map(int, stdin.split()))\n\n    total_size = sum(sizes)\n    min_size = total_size // k\n    max_size = (total_size + k - 1) // k\n\n    while min_size < max_size:\n        mid_size = (min_size + max_size + 1) // 2\n        if can_pack(sizes, k, mid_size):\n            max_size = mid_size - 1\n        else:\n            min_size = mid_size\n\n    return min_size if can_pack(sizes, k, min_size) else min_size + 1\n\ndef",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 1010,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    count = 0\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 79,
        "indeed": false
    },
    {
        "number": 1011,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    max_points_first_team = sum([3 if a_i > d else 2 for a_i in a])\n    max_points_second_team = sum([3 if b_i > d else 2 for b_i in b])\n\n    max_d = 0\n    max_points = float('-inf')\n\n    for i in range(1, max(a + b) + 1):\n        points = max_points_first_team - max_points_second_team\n        if points > max_points:\n            max_points = points\n            max_d = i\n\n    return f\"{max_points_first_team - max_points_second_team}:{max_points_second_team}\" ",
        "test": "",
        "num_ids": 220,
        "indeed": false
    },
    {
        "number": 1012,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def can_make_good_string(s: str) -> bool:\n        char_count = {}\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n\n        odd_count = 0\n        for count in char_count.values():\n            if count % 2 != 0:\n                odd_count += 1\n\n        return odd_count <= 1\n\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        s = stdin.readline().strip()\n\n        if is_palindrome(s):\n            result.append(-1)\n        elif can_make_good_string(s):\n            good_string = \"\"\n            char_count = {}\n            for char in s:\n                if char in char_count:\n                    char_count[char] += 1\n                else:\n                    char_count[char] = 1\n\n            for char, count in char_count.items():\n                if count % 2 != 0:\n                    good_string += char\n\n            for char, count in char_count.items():\n                if count % 2 == 0:\n                    good_string += char * (count // 2)\n\n            result.append(good_string)\n        else:\n            result.append(-1)\n\n    return \"\\n\".join(str(x) for x in result)",
        "test": "",
        "num_ids": 390,
        "indeed": false
    },
    {
        "number": 1013,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = []\n    for i in range(n):\n        row = list(map(int, stdin.readline().split()))\n        table.append(row)\n\n    good_cells = []\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 1:\n                good_cells.append((i, j))\n\n    operations = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i, j) not in good_cells:\n                operations += 1\n\n    return str(operations)",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 1014,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 2:\n        return \"white\\n1 2\"\n    else:\n        return \"black\"",
        "test": "",
        "num_ids": 41,
        "indeed": false
    },
    {
        "number": 1015,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_protection(shields: list, n: int) -> int:\n        protected_pairs = 0\n        for i in range(n):\n            if shields[i] == 0:\n                for j in range(i + 1, n):\n                    if shields[j] == 0:\n                        protected_pairs += 1\n                    else:\n                        break\n        return protected_pairs\n\n    def find_max_protection(shields: list, n: int, k: int) -> int:\n        max_protection = calculate_protection(shields, n)\n        for i in range(n):\n            if shields[i] == 1:\n                for j in range(i + 1, n):\n                    if shields[j] == 0:\n                        shields[j] = 1\n                        max_protection = max(max_protection, calculate_protection(shields, n))\n                        k -= 1\n                        if k == 0:\n                            return max_protection\n                        shields[j] = 0\n                    else:\n                        break\n        return max_protection\n\n    n, shields = map(int, stdin.split())\n    shields = list(map(int, shields))\n    max_protections = []\n    for k in range(n * (n - 1) // 2 + 1):\n        max_protections.append(find_max_protection(shields, n, k))\n    return \" \".join(map(str, max_protections))",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 1016,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    reactions = [tuple(map(int, input().split())) for _ in range(m)]\n    adj_list = [[] for _ in range(n + 1)]\n\n    for x, y in reactions:\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n\n    def dfs(node: int, visited: set, danger: int) -> int:\n        if node in visited:\n            return danger\n\n        visited.add(node)\n        max_danger = danger\n\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                new_danger = danger * 2 if neighbor in adj_list[node] else danger\n                max_danger = max(max_danger, dfs(neighbor, visited, new_danger))\n\n        return max_danger\n\n    max_danger = 0\n    for i in range(1, n + 1):\n        max_danger = max(max_danger, dfs(i, set(), 1))\n\n    return str(max_danger)",
        "test": "",
        "num_ids": 279,
        "indeed": false
    },
    {
        "number": 1017,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(n - 1)",
        "test": "",
        "num_ids": 52,
        "indeed": false
    },
    {
        "number": 1018,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    days = 0\n    while all(x > 0 for x in a):\n        days += 1\n        for i in range(n):\n            if days % n == i:\n                a[i] -= 1\n                if a[i] == 0:\n                    return str(i + 1)\n    return \"0\"\n\nn, a = map(int, input().split())\nprint(solution(f\"{n} {a}\")) ",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 1019,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_a = 0\n    max_b = 1\n\n    for b in range(2, n + 1):\n        for a in range(1, b):\n            if a + b == n and gcd(a, b) == 1:\n                if a > max_a or (a == max_a and b < max_b):\n                    max_a = a\n                    max_b = b\n\n    return f\"{max_a} {max_b}\"\n\ndef",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 1020,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, k = map(int, stdin.split())\n    total_cells = w * h\n    gilded_cells = 0\n\n    for i in range(k):\n        gilded_cells += (w - 4 * i) * (h - 4 * i)\n\n    return str(total_cells - gilded_cells)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 1021,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n    t = list(map(int, stdin.split('\\n')[2].split()))\n\n    for i in range(2, n - 1):\n        c[i] = c[i + 1] + c[i - 1] - c[i]\n\n    if c == t:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1022,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check(a: List[int]) -> bool:\n        for i in range(n):\n            l, r = 0, 0\n            for j in range(i):\n                if a[j] > a[i]:\n                    l += 1\n            for j in range(i + 1, n):\n                if a[j] > a[i]:\n                    r += 1\n            if l != l_i[i] or r != r_i[i]:\n                return False\n        return True\n\n    n = int(stdin.readline().strip())\n    l_i = list(map(int, stdin.readline().strip().split()))\n    r_i = list(map(int, stdin.readline().strip().split()))\n\n    if any(l > n or r > n for l, r in zip(l_i, r_i)):\n        return \"NO\"\n\n    for a in permutations(range(1, n + 1)):\n        if check(a):\n            return \"YES\\n\" + \" \".join(map(str, a))\n\n    return \"NO\"",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 1023,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    n, m, t_a, t_b, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    if k >= n + m:\n        return \"-1\"\n\n    for i in range(k):\n        if binary_search(a, b[i] - t_a):\n            a.remove(b[i] - t_a)\n\n    if not a or not b:\n        return \"-1\"\n\n    return str(max(b) + t_b)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1024,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    permutation = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_inversions(permutation):\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if permutation[i] > permutation[j]:\n                    inversions += 1\n        return inversions\n\n    def expected_inversions(n, permutation):\n        total_inversions = 0\n        for l in range(n):\n            for r in range(l, n):\n                segment = permutation[l:r + 1]\n                k = r - l + 1\n                for p in range(k):\n                    shuffled_segment = segment.copy()\n                    shuffled_segment[p:k] = segment[p + 1:k + 1]\n                    shuffled_permutation = permutation[:l] + shuffled_segment + permutation[r + 1:]\n                    total_inversions += count_inversions(shuffled_permutation)\n        return total_inversions / (n * (n + 1) // 2)\n\n    return str(expected_inversions(n, permutation))",
        "test": "",
        "num_ids": 312,
        "indeed": false
    },
    {
        "number": 1025,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def area(a, b, c):\n        x1, y1 = a\n        x2, y2 = b\n        x3, y3 = c\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    triangles = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if area(points[i], points[j], points[k]) != 0:\n                    triangles += 1\n\n    return str(triangles)",
        "test": "",
        "num_ids": 207,
        "indeed": true
    },
    {
        "number": 1026,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(start: int, end: int) -> bool:\n        if end - start != b[end] - b[start]:\n            return False\n        return True\n\n    def dfs(start: int, current_beauty: int, visited: set) -> int:\n        if start == n:\n            return current_beauty\n        max_beauty = 0\n        for i in range(start + 1, n + 1):\n            if is_valid(start, i) and i not in visited:\n                visited.add(i)\n                max_beauty = max(max_beauty, dfs(i, current_beauty + b[i], visited))\n                visited.remove(i)\n        return max_beauty\n\n    return str(dfs(0, b[0], {0}))",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 1027,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    max_score = 0\n\n    for i in range(14):\n        if a[i] > 0:\n            score = 0\n            j = (i + 1) % 14\n            while a[i] > 0:\n                a[i] -= 1\n                a[j] += 1\n                j = (j + 1) % 14\n\n            for k in range(1, 14, 2):\n                score += a[k]\n                a[k] = 0\n\n            max_score = max(max_score, score)\n\n    return str(max_score)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 1028,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k_min = (n * (n - 1)) // 2\n    k_max = (n // m) * (n // m - 1) * m + (n % m) * (n % m - 1) // 2\n    return f\"{k_min} {k_max}\"",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 1029,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    n = 1\n    while True:\n        if p % (10 ** n) == 0:\n            n += 1\n        else:\n            break\n    return str(n)",
        "test": "",
        "num_ids": 58,
        "indeed": false
    },
    {
        "number": 1030,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    pages = []\n    for i in range(p - k, p + k + 1):\n        if 1 <= i <= n:\n            pages.append(i)\n\n    if p == 1:\n        pages = pages[k:]\n    elif p == n:\n        pages = pages[:-k]\n\n    navigation = []\n    if pages[0] != 1:\n        navigation.append(\"<<\")\n    for i, page in enumerate(pages):\n        if page == p:\n            navigation.append(f\"({page})\")\n        else:\n            navigation.append(str(page))\n    if pages[-1] != n:\n        navigation.append(\">>\")\n\n    return \" \".join(navigation)",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1031,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    x = 0\n    y = 0\n    dx = 0\n    dy = 0\n    cardiogram = []\n\n    for i in range(n):\n        if i % 2 == 0:\n            dx = a[i]\n            dy = a[i]\n        else:\n            dx = a[i]\n            dy = -a[i]\n\n        for j in range(abs(dy)):\n            cardiogram.append(\" \" * x + \"/\\\\\"[i % 2] + \" \" * (2 * a[i] - x - 1) + \"\\\\/\"[i % 2] + \" \" * (n - x - 1))\n            if dy > 0:\n                y += 1\n            else:\n                y -= 1\n            x = 2 * a[i] - y\n\n        if i < n - 1:\n            cardiogram.append(\" \" * x + \"/\\\\\"[i % 2] + \" \" * (2 * a[i] - x - 1) + \"\\\\/\"[i % 2] + \" \" * (n - x - 1))\n        x = 2 * a[i]\n        y = 0\n\n    return \"\\n\".join(cardiogram)",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 1032,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(x: int) -> bool:\n        return f(x) % p != 0\n\n    def f(x: int) -> int:\n        return sum(1 for p in permutations(range(1, n + 1)) if all(x >= a[i - 1] for i in p))\n\n    n, p = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    good_numbers = [x for x in range(1, n * max(a) + 1) if is_good(x)]\n\n    return f\"{len(good_numbers)}\\n{' '.join(map(str, good_numbers))}\"",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 1033,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, H = map(int, stdin.split())\n\n    def is_valid(heights):\n        for i in range(1, len(heights)):\n            if abs(heights[i] - heights[i - 1]) > 1:\n                return False\n        return True\n\n    def count_spots(heights):\n        spots = 0\n        for h in heights:\n            if h > 0:\n                spots += 1\n        return spots\n\n    def binary_search(left, right):\n        if left == right:\n            return left\n\n        mid = (left + right) // 2\n        heights = [H - 1] + [0] * (mid - 1) + [H]\n\n        if is_valid(heights):\n            return binary_search(mid + 1, right)\n        else:\n            return binary_search(left, mid - 1)\n\n    min_spots = binary_search(1, n)\n    heights = [H - 1] + [0] * (min_spots - 1) + [H]\n    spots_occupied = count_spots(heights)\n\n    return str(spots_occupied)",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 1034,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, Z, K = map(int, stdin.split()[0].split())\n    A = list(map(int, stdin.split()[1].split()))\n    B = list(map(int, stdin.split()[2].split()))\n    C = list(map(int, stdin.split()[3].split()))\n\n    sums = []\n    for i in range(X):\n        for j in range(Y):\n            for k in range(Z):\n                sums.append(A[i] + B[j] + C[k])\n\n    sums.sort(reverse=True)\n    return \"\\n\".join(map(str, sums[:K]))",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 1035,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    divisors = []\n    for i in range(1, A + 1):\n        if A % i == 0 and B % i == 0:\n            divisors.append(i)\n    count = 0\n    for i in range(len(divisors)):\n        for j in range(i + 1, len(divisors)):\n            if gcd(divisors[i], divisors[j]) == 1:\n                count += 1\n    return str(count)\n\ndef",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1036,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n\n    def tournament(l: int, r: int) -> str:\n        if r - l == 1:\n            return s[l % n]\n        m = (l + r) // 2\n        a = tournament(l, m)\n        b = tournament(m, r)\n        if a == b:\n            return a\n        if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            return a\n        else:\n            return b\n\n    return tournament(0, 2**k)",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1037,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = list(map(int, A.split()))\n    A.sort()\n    total_happiness = 0\n\n    for i in range(N):\n        total_happiness += A[i] * abs(i - A.index(A[i]))\n\n    return str(total_happiness)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 1038,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    result = 0\n    for i in range(A, B + 1):\n        result ^= i\n    return str(result)",
        "test": "",
        "num_ids": 49,
        "indeed": false
    },
    {
        "number": 1039,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, x):\n        if parent[x] == x:\n            return x\n        parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def kruskal(edges):\n        parent = [i for i in range(N + 1)]\n        rank = [0] * (N + 1)\n        mst_edges = []\n\n        for edge in sorted(edges, key=lambda x: x[2]):\n            if union(parent, rank, edge[0], edge[1]):\n                mst_edges.append(edge)\n\n        return mst_edges\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    edges = []\n    for i in range(N - 1):\n        a, b, c = map(int, lines[i + 1].split())\n        edges.append((a, b, c))\n\n    mst_edges = kruskal(edges)\n\n    Q = int(lines[N + 1])\n    K = int(lines[N + 2])\n    queries = []\n    for i in range(Q):\n        x, y = map(int, lines[N + 3 + i].split())\n        queries.append((x, y))\n\n    results = []\n    for query in queries:\n        x, y = query\n        if find(parent, x) == find(parent, y):\n            results.append(0)\n        else:\n            length = 0\n            for edge in mst_edges:\n                if find(parent, edge[0]) == find(parent, K) and find(parent, edge[1]) == find(parent, K):\n                    length += edge[2]\n            results.append(length)\n\n    return '\\n'.join(map(str, results))",
        "test": "",
        "num_ids": 574,
        "indeed": false
    },
    {
        "number": 1040,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = stdin.split(\"\\n\")\n    N = int(N)\n    s = s.strip()\n\n    while \"fox\" in s:\n        s = s.replace(\"fox\", \"\")\n\n    return len(s)",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 1041,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    if n == 0:\n        return \"YES\"\n    if s == 0:\n        return \"NO\"\n    total = sum(s)\n    if total % n == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1042,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [[0] * (y + 1) for _ in range(x + 1)]\n    dp[1][1] = 1\n\n    for i in range(2, x + 1):\n        for j in range(1, y + 1):\n            for k in range(1, j + 1):\n                if j - k * i >= 0:\n                    dp[i][j] += dp[i][j - k * i]\n                    dp[i][j] %= mod\n\n    return str(dp[x][y])",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1043,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    a.sort()\n    bribes = 0\n\n    for i in range(n):\n        if a[i] != -1 and a[i] != i + 1:\n            bribes += a[i] - i - 1\n\n    return str(bribes)",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 1044,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_replace(cycle_length, p):\n        return p > 1 and p < cycle_length\n\n    def winner(cycles):\n        if not cycles:\n            return 2\n        for cycle_length in cycles:\n            if can_replace(cycle_length, 2):\n                return 1\n        return 2\n\n    n, *a = list(map(int, stdin.split()))\n    cycles = set()\n    result = []\n\n    for i in range(n):\n        cycles.add(a[i])\n        result.append(winner(cycles))\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 1045,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    i = 1\n    total_cubes = 0\n    while total_cubes + i + 1 <= n:\n        total_cubes += i\n        i += 1\n    return str(i - 1)",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 1046,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    calls = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(calls) != n:\n        return \"-1\"\n\n    call_set = set(calls)\n    call_set.discard(0)\n\n    if len(call_set) != len(calls) - calls.count(0):\n        return \"-1\"\n\n    return str(sum(calls.count(x) // 2 for x in call_set))",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 1047,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 0\n    result = []\n\n    while n > 0:\n        if n % 2 == 1:\n            result.append(1)\n            k += 1\n            n -= 1\n        else:\n            result.append(0)\n            n = n // 2\n\n    result.reverse()\n    return f\"{k}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 1048,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    commands = stdin.readline().strip()\n\n    max_commands = 0\n    x, y = 0, 0\n\n    for command in commands:\n        if command == 'U':\n            y += 1\n        elif command == 'D':\n            y -= 1\n        elif command == 'L':\n            x -= 1\n        elif command == 'R':\n            x += 1\n\n        if x == 0 and y == 0:\n            max_commands += 1\n\n    return str(max_commands)",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 1049,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.readline().split())\n    opponents = [list(map(int, stdin.readline().strip())) for _ in range(d)]\n\n    max_winning_streak = 0\n    current_winning_streak = 0\n\n    for i in range(d):\n        if all(opponents[i]):\n            current_winning_streak += 1\n        else:\n            max_winning_streak = max(max_winning_streak, current_winning_streak)\n            current_winning_streak = 0\n\n    max_winning_streak = max(max_winning_streak, current_winning_streak)\n\n    return str(max_winning_streak)",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1050,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n <= m and n <= k:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 45,
        "indeed": true
    },
    {
        "number": 1051,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, ranks = map(int, stdin.split())\n    ranks = sorted(ranks)\n    missing_contestants = 0\n\n    for i in range(1, 26):\n        if i not in ranks:\n            missing_contestants += 1\n        else:\n            ranks.remove(i)\n\n        if missing_contestants >= 25 - k:\n            break\n\n    return str(missing_contestants)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 1052,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    total_permutations = 0\n    for i in range(n - k + 1):\n        total_permutations += (n - k) * factorial(n - k - 1)\n    return str(total_permutations)\n\ndef",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1053,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    weight = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            weight += i ^ j\n    return str(weight)",
        "test": "",
        "num_ids": 58,
        "indeed": false
    },
    {
        "number": 1054,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    x_coords = []\n    y_coords = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        x_coords.append(x)\n        y_coords.append(y)\n\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n\n    area = width * height\n\n    return str(area)",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 1055,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, arr = map(int, stdin.split())\n    arr = sorted(arr)\n    while n > 1:\n        n //= 2\n        if n % 2 == 1:\n            n -= 1\n    return str(len(arr))",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 1056,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_turns(board, ladders, start, goal):\n        def get_next_tiles(board, ladders, current_tile, current_height):\n            next_tiles = []\n            for next_tile in [(current_tile[0] - 1, current_tile[1]), (current_tile[0], current_tile[1] + 1)]:\n                if 0 <= next_tile[0] < 10 and 0 <= next_tile[1] < 10:\n                    next_height = current_height + (1 if next_tile[0] == current_tile[0] else -1)\n                    if next_tile in ladders:\n                        if next_height >= ladders[next_tile]:\n                            next_tiles.append((ladders[next_tile], next_tile))\n                    else:\n                        next_tiles.append((next_height, next_tile))\n            return next_tiles\n\n        def min_turns_to_goal(board, ladders, current_tile, current_height, visited, min_turns):\n            if current_tile == goal:\n                return min_turns\n            if current_tile in visited and visited[current_tile] <= current_height:\n                return float('inf')\n            visited[current_tile] = current_height\n\n            next_tiles = get_next_tiles(board, ladders, current_tile, current_height)\n            min_turns_from_next_tiles = [min_turns_to_goal(board, ladders, next_tile[1], next_tile[0], visited, min_turns + 1) for next_tile in next_tiles]\n            return min(min_turns_from_next_tiles)\n\n        return min_turns_to_goal(board, ladders, start, 0, {}, 0)\n\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    ladders = {}\n    start = (9, 0)\n    goal = (0, 0)\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] != 0:\n                ladders[(i, j)] = board[i][j]\n\n    return str(get_expected_turns(board, ladders, start, goal))",
        "test": "",
        "num_ids": 617,
        "indeed": false
    },
    {
        "number": 1057,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    mod = 998244353\n    ans = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if len(set(s[i:j])) == 1:\n                ans += 1\n\n    return str(ans % mod)\n",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 1058,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(block1, block2):\n        return block1[0] == block2[1]\n\n    def flip(block):\n        return block[2], block[1], block[0]\n\n    n = int(stdin.readline())\n    blocks = []\n    for _ in range(n):\n        color1, value, color2 = map(int, stdin.readline().split())\n        blocks.append((color1, value, color2))\n\n    max_value = 0\n    for i in range(n):\n        for j in range(i, n):\n            if is_valid(blocks[i], blocks[j]):\n                for k in range(j + 1, n):\n                    if is_valid(blocks[k], blocks[k - 1]):\n                        value = sum(block[1] for block in blocks[i:k + 1])\n                        max_value = max(max_value, value)\n            if is_valid(flip(blocks[i]), blocks[j]):\n                for k in range(j + 1, n):\n                    if is_valid(blocks[k], flip(blocks[k - 1])):\n                        value = sum(block[1] for block in [flip(blocks[i])] + blocks[j:k + 1])\n                        max_value = max(max_value, value)\n\n    return str(max_value)",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 1059,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    vowels = ['a', 'e', 'i', 'o', 'u']\n\n    def is_vowelly(word: str) -> bool:\n        rows = len(word)\n        cols = len(vowels)\n        grid = [[''] * cols for _ in range(rows)]\n\n        for i in range(rows):\n            for j in range(cols):\n                grid[i][j] = word[i * cols + j]\n\n        for row in grid:\n            if not all(vowel in row for vowel in vowels):\n                return False\n\n        for j in range(cols):\n            column = [grid[i][j] for i in range(rows)]\n            if not all(vowel in column for vowel in vowels):\n                return False\n\n        return True\n\n    for i in range(1, k // len(vowels) + 1):\n        for j in range(1, k // len(vowels) + 1):\n            if i * j == k:\n                word = ''.join([vowel * i for vowel in vowels]) * j\n                if is_vowelly(word):\n                    return word\n\n    return '-1'",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 1060,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_divisible(a, b):\n        return a % b == 0 or b % a == 0\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_divisible(a[i], a[j]):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    def dfs(v, visited, graph):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u, visited, graph)\n\n    def find_max_clique(graph):\n        max_clique = 0\n        for v in range(n):\n            visited = [False] * n\n            dfs(v, visited, graph)\n            max_clique = max(max_clique, sum(visited))\n        return max_clique\n\n    return str(find_max_clique(graph))",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1061,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    one_position = None\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == 1:\n                one_position = (i, j)\n                break\n        if one_position is not None:\n            break\n\n    min_moves = float('inf')\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == 1 and (i, j) != (2, 2):\n                moves = abs(i - 2) + abs(j - 2)\n                min_moves = min(min_moves, moves)\n\n    return str(min_moves)",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 1062,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    S = stdin.readline().strip()\n    T = stdin.readline().strip()\n\n    min_distance = float('inf')\n    min_i, min_j = -1, -1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if S[i] == T[j] and S[j] == T[i]:\n                distance = n - 2 + abs(i - j)\n            else:\n                distance = n - 2 + abs(i - j) - 1\n\n            if distance < min_distance:\n                min_distance = distance\n                min_i, min_j = i, j\n\n    if min_i == -1 and min_j == -1:\n        return f\"{min_distance}\\n-1 -1\"\n    else:\n        return f\"{min_distance}\\n{min_i + 1} {min_j + 1}\"",
        "test": "",
        "num_ids": 243,
        "indeed": false
    },
    {
        "number": 1063,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence: list) -> bool:\n        for i in range(len(sequence) - 1):\n            if sequence[i] >= sequence[i + 1]:\n                return False\n        return True\n\n    def restore_sequence(sequence: list) -> list:\n        for i in range(len(sequence)):\n            for j in range(len(sequence[i])):\n                if sequence[i][j] == \"?\":\n                    for digit in range(10):\n                        new_sequence = sequence.copy()\n                        new_sequence[i] = sequence[i][:j] + str(digit) + sequence[i][j + 1:]\n                        if is_valid(new_sequence):\n                            return new_sequence\n        return None\n\n    def print_sequence(sequence: list) -> str:\n        output = \"YES\\n\"\n        for num in sequence:\n            output += str(num) + \"\\n\"\n        return output\n\n    n = int(stdin.readline().strip())\n    sequence = []\n    for _ in range(n):\n        sequence.append(stdin.readline().strip())\n\n    restored_sequence = restore_sequence(sequence)\n    if restored_sequence:\n        return print_sequence(restored_sequence)\n    else:\n        return \"NO\" ",
        "test": "",
        "num_ids": 316,
        "indeed": false
    },
    {
        "number": 1064,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    blocked_positions = set(map(int, stdin.split('\\n')[1].split()))\n    lamp_costs = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_cost = float('inf')\n\n    for power in range(1, k + 1):\n        cost = lamp_costs[power - 1]\n        current_position = 0\n        while current_position <= n - power:\n            if current_position not in blocked_positions:\n                total_cost = min(total_cost, cost)\n            current_position += 1\n\n    return str(total_cost) if total_cost != float('inf') else '-1'",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1065,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M, D = map(int, stdin.split())\n\n    x = 1\n    while x <= M:\n        if n % x == 0:\n            if n // x <= D:\n                return str(n // x)\n        x += 1\n\n    return \"0\"",
        "test": "",
        "num_ids": 75,
        "indeed": false
    },
    {
        "number": 1066,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    odd_numbers = [i for i in range(1, n + 1, 2)]\n    even_numbers = [i for i in range(2, n + 1, 2)]\n    volodya_sequence = odd_numbers + even_numbers\n    return str(volodya_sequence[k - 1])",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 1067,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n\n    nums.sort()\n\n    coins = 0\n    for i in range(n):\n        if nums[i] == 0:\n            continue\n        elif nums[i] > 0:\n            coins += nums[i] - 1\n            nums[i] = 1\n        else:\n            coins += abs(nums[i]) - 1\n            nums[i] = -1\n\n    return str(coins)",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1068,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: str, b: str, c: str) -> bool:\n        return a.lstrip('0') + b.lstrip('0') == c.lstrip('0')\n\n    n = len(stdin)\n    for i in range(1, n - 1):\n        a, b, c = stdin[:i], stdin[i:n - 1], stdin[n - 1:]\n        if is_valid(a, b, c):\n            return f\"{a}+{b}={c}\"\n\n    raise ValueError(\"No valid expression found\")\n",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1069,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(1, 5):\n        result += pow(i, n, 5)\n    return str(result)",
        "test": "",
        "num_ids": 50,
        "indeed": false
    },
    {
        "number": 1070,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    houses = list(map(int, stdin.split()))\n    max_length = 0\n    current_length = 0\n    colors = [0] * k\n\n    for i in range(n):\n        colors[houses[i] - 1] += 1\n        current_length += 1\n\n        if colors[houses[i] - 1] > 1:\n            current_length = 0\n            colors = [0] * k\n\n        max_length = max(max_length, current_length)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 1071,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, b_1, b_2, b_3, n = map(int, stdin.split())\n    total_cups = a_1 + a_2 + a_3\n    total_medals = b_1 + b_2 + b_3\n\n    if total_cups > 5 * n or total_medals > 10 * n:\n        return \"NO\"\n\n    for i in range(1, n + 1):\n        if i <= total_cups:\n            total_cups -= i\n        if i <= total_medals:\n            total_medals -= i\n\n    if total_cups == 0 and total_medals == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1072,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = [stdin.readline().strip() for _ in range(n)]\n\n    def is_good(table):\n        for i in range(1, len(table)):\n            if table[i] < table[i - 1]:\n                return False\n        return True\n\n    def remove_column(table, col_idx):\n        return [row[:col_idx] + row[col_idx + 1:] for row in table]\n\n    min_columns_to_remove = 0\n    while not is_good(table):\n        for col_idx in range(m - 1, -1, -1):\n            new_table = remove_column(table, col_idx)\n            if is_good(new_table):\n                table = new_table\n                min_columns_to_remove += 1\n                break\n\n    return str(min_columns_to_remove)",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 1073,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    commands = stdin.readline().strip()\n\n    def count_substrings(commands: str) -> int:\n        n = len(commands)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if commands[i] == 'U' and commands[j] == 'D':\n                    dp[i][j] = 4 * dp[i + 1][j - 1]\n                elif commands[i] == 'D' and commands[j] == 'U':\n                    dp[i][j] = 4 * dp[i + 1][j - 1]\n                elif commands[i] == 'L' and commands[j] == 'R':\n                    dp[i][j] = 4 * dp[i + 1][j - 1]\n                elif commands[i] == 'R' and commands[j] == 'L':\n                    dp[i][j] = 4 * dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = 0\n\n        return sum(dp[0][i] for i in range(n))\n\n    return str(count_substrings(commands))",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 1074,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = [0] * 10\n    c = [0] * 10\n    d = [0] * 10\n    e = [0] * 10\n    f = [0] * 10\n    g = [0] * 10\n    h = [0] * 10\n    i = [0] * 10\n    j = [0] * 10\n\n    for _ in range(a):\n        b[0] = (b[0] + b[1]) % 255\n        c[1] = (c[1] + c[2]) % 255\n        d[2] = (d[2] + d[3]) % 255\n        e[3] = (e[3] + e[4]) % 255\n        f[4] = (f[4] + f[5]) % 255\n        g[5] = (g[5] + g[6]) % 255\n        h[6] = (h[6] + h[7]) % 255\n        i[7] = (i[7] + i[8]) % 255\n        j[8] = (j[8] + j[9]) % 255\n        j[9] = (j[9] + b[0]) % 255\n\n        b = [c[0]] + b[:9]\n        c = [d[0]] + c[:9]\n        d = [e[0]] + d[:9]\n        e = [f[0]] + e[:9]\n        f = [g[0]] + f[:9]\n        g = [h[0]] + g[:9]\n        h = [i[0]] + h[:9]\n        i = [j[0]] + i[:9]\n        j = j[1:] + [b[0]]\n\n    return str(j[0])",
        "test": "",
        "num_ids": 476,
        "indeed": false
    },
    {
        "number": 1075,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 2:\n        return \"0 1 0\"\n    elif n % 2 == 0:\n        return -1\n    else:\n        order = [0] * n\n        for i in range(n - 1):\n            if i % 2 == 0:\n                order[i + 1] = (2 * i) % n\n            else:\n                order[i + 1] = (2 * i + 1) % n\n        order[n - 1] = 0\n        return \" \".join(map(str, order))",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 1076,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def expected_time(n, m):\n        total_cards = n + m\n        non_joker_cards = n\n        joker_cards = m\n\n        expected_time = 0\n        for i in range(1, n + 1):\n            expected_time += (total_cards - joker_cards) / total_cards * i\n            total_cards -= 1\n            non_joker_cards -= 1\n            joker_cards += 1\n\n        return expected_time\n\n    P = expected_time(n, m)\n    Q = 998244353\n\n    return str((P * pow(Q, Q - 2, Q)) % Q)\n",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 1077,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    b = [0] * (m + 1)\n    for x in a:\n        b[x] += 1\n\n    min_b = min(b[1:m + 1])\n    changes = 0\n    for i in range(1, m + 1):\n        if b[i] > min_b:\n            changes += b[i] - min_b\n            b[i] = min_b\n\n    for i in range(n):\n        if a[i] > m or a[i] == 0:\n            changes += 1\n            a[i] = 1\n\n    return f\"{min_b} {changes}\\n{' '.join(map(str, a))}\"",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 1078,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    b = []\n    for i in range(n):\n        if a[i] % 2 == 0:\n            b.append(a[i] // 2)\n        elif a[i] > 0:\n            b.append(a[i] // 2)\n        else:\n            b.append((a[i] + 1) // 2)\n    return \" \".join(map(str, b))",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1079,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    k = 0\n    while n > 0:\n        if n % 2 == 1:\n            k += 1\n            n -= 2**k\n        else:\n            k += 1\n        if n == 0:\n            return str(k)\n        elif n % 2 == 1:\n            k += 1\n            n -= 2**k\n            if n == 0:\n                return str(k)\n            else:\n                k += 1\n                n += 2**k\n    return str(k)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 1080,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            continue\n        if a[i + 1] - a[i] > 1:\n            return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1081,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    if a % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 39,
        "indeed": false
    },
    {
        "number": 1082,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            dp[j] += dp[j - i - 1]\n            dp[j] %= mod\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i:j].count(1) == j - i:\n                res += dp[j - i - 1]\n                res %= mod\n    return str(res)",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 1083,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(range(1, n + 1))\n    if n % 2 == 0:\n        mid = n // 2\n    else:\n        mid = n // 2 + 1\n    group1 = arr[:mid]\n    group2 = arr[mid:]\n    abs_diff = abs(sum(group1) - sum(group2))\n    return f\"{abs_diff}\\n{len(group1)} {' '.join(map(str, group1))}\"",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 1084,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(operations: list) -> bool:\n        for i in range(len(operations)):\n            for j in range(i + 1, len(operations)):\n                if set(operations[i][0]) & set(operations[j][0]) or set(operations[i][1]) & set(operations[j][1]):\n                    return False\n        return True\n\n    def dfs(start: int, rows: list, cols: list) -> list:\n        if start == n:\n            return [(rows, cols)]\n\n        operations = []\n        for i in range(m):\n            if all(grid[start][j] != '#' for j in range(m) if j not in cols):\n                new_cols = cols + [i]\n                new_operations = dfs(start + 1, rows, new_cols)\n                operations.extend(new_operations)\n\n        for i in range(n):\n            if all(grid[j][start] != '#' for j in range(n) if j not in rows):\n                new_rows = rows + [i]\n                new_operations = dfs(start + 1, new_rows, cols)\n                operations.extend(new_operations)\n\n        return operations\n\n    operations = dfs(0, [], [])\n    valid_operations = [op for op in operations if is_valid(op)]\n\n    return \"Yes\" if valid_operations else \"No\"",
        "test": "",
        "num_ids": 394,
        "indeed": false
    },
    {
        "number": 1085,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    for K in range(2, N + 1):\n        while N >= K:\n            if N % K == 0:\n                N //= K\n            else:\n                N -= K\n        if N == 1:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 1086,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint_grid(grid: List[List[int]]) -> List[List[int]]:\n        for i in range(H):\n            for j in range(W):\n                if i % 2 == 0:\n                    if j % 2 == 0:\n                        grid[i][j] = (A[i][j], B[i][j])\n                    else:\n                        grid[i][j] = (B[i][j], A[i][j])\n                else:\n                    if j % 2 == 0:\n                        grid[i][j] = (B[i][j], A[i][j])\n                    else:\n                        grid[i][j] = (A[i][j], B[i][j])\n        return grid\n\n    def find_unbalancedness(grid: List[List[int]]) -> int:\n        unbalancedness = 0\n        red_sum = 0\n        blue_sum = 0\n        for i in range(H):\n            for j in range(W):\n                if i == 0 and j == 0:\n                    continue\n                if i == H - 1 and j == W - 1:\n                    continue\n                if i % 2 == 0:\n                    if j % 2 == 0:\n                        red_sum += grid[i][j][0]\n                        blue_sum += grid[i][j][1]\n                    else:\n                        red_sum += grid[i][j][1]\n                        blue_sum += grid[i][j][0]\n                else:\n                    if j % 2 == 0:\n                        red_sum += grid[i][j][1]\n                        blue_sum += grid[i][j][0]\n                    else:\n                        red_sum += grid[i][j][0]\n                        blue_sum += grid[i][j][1]\n        unbalancedness = abs(red_sum - blue_sum)\n        return unbalancedness\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    A = [list(map(int, line.split())) for line in lines[1:H + 1]]\n    B = [list(map(int, line.split())) for line in lines[H + 1:H * 2 + 1]]\n\n    grid = [[(A[i][j], B[i][j]) for j in range(W)] for i in range(H)]\n    painted_grid = paint_grid(grid)\n    unbalancedness = find_unbalancedness(painted_grid)\n\n    return str(unbalancedness)",
        "test": "",
        "num_ids": 647,
        "indeed": false
    },
    {
        "number": 1087,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def xor(a, b):\n        return a ^ b\n\n    def f(X):\n        return sum(xor(X, A_i) for A_i in A)\n\n    max_f = float('-inf')\n    for X in range(K + 1):\n        max_f = max(max_f, f(X))\n\n    return str(max_f)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1088,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    def is_valid(x: int, y: int, axis: int) -> bool:\n        if axis == 0:\n            return all(matrix[i][x] + matrix[i][y] <= K for i in range(N))\n        else:\n            return all(matrix[x][i] + matrix[y][i] <= K for i in range(N))\n\n    def count_matrices(matrix: List[List[int]], N: int, K: int) -> int:\n        dp = [[0] * (K + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, N + 1):\n            for j in range(K + 1):\n                for x in range(1, i + 1):\n                    for y in range(x, i + 1):\n                        if is_valid(x - 1, y - 1, 0):\n                            dp[i][j] += dp[i - 1][j]\n                        if is_valid(x - 1, y - 1, 1):\n                            dp[i][j] += dp[i][j - matrix[x - 1][y - 1]]\n\n        return dp[N][K]\n\n    return count_matrices(matrix, N, K) % 998244353",
        "test": "",
        "num_ids": 385,
        "indeed": false
    },
    {
        "number": 1089,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def cost(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    total_cost = 0\n    for i in range(K):\n        for j in range(i + 1, K):\n            for x1 in range(1, N + 1):\n                for y1 in range(1, M + 1):\n                    for x2 in range(1, N + 1):\n                        for y2 in range(1, M + 1):\n                            if (x1, y1) != (x2, y2):\n                                total_cost += cost(x1, y1, x2, y2)\n\n    return str(total_cost % mod)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 1090,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split())\n    S = list(S)\n    total_happy = 0\n\n    for _ in range(K):\n        # Find the best operation\n        max_happy = 0\n        for l in range(1, N):\n            for r in range(l, N):\n                happy = 0\n                for i in range(l, r + 1):\n                    if (S[i - 1] == 'L' and S[i - l] == 'R') or (S[i - 1] == 'R' and S[i - l] == 'L'):\n                        happy += 1\n                if happy > max_happy:\n                    max_happy = happy\n\n        # Perform the best operation\n        for l in range(1, N):\n            for r in range(l, N):\n                happy = 0\n                for i in range(l, r + 1):\n                    if (S[i - 1] == 'L' and S[i - l] == 'R') or (S[i - 1] == 'R' and S[i - l] == 'L'):\n                        happy += 1\n                if happy == max_happy:\n                    for i in range(l, r + 1):\n                        if S[i - 1] == 'L':\n                            S[i - 1] = 'R'\n                        else:\n                            S[i - 1] = 'L'\n                    total_happy += max_happy\n                    break\n            else:\n                continue\n            break\n\n    return total_happy",
        "test": "",
        "num_ids": 395,
        "indeed": false
    },
    {
        "number": 1091,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bids = [int(x) for x in stdin.split('\\n')[1].split()]\n    winner_index = bids.index(max(bids)) + 1\n    winner_bid = max(bids)\n    second_bid = sorted(list(set(bids)))[-2]\n    if winner_bid > second_bid:\n        price_to_pay = second_bid\n    else:\n        price_to_pay = winner_bid\n    return f\"{winner_index} {price_to_pay}\"",
        "test": "",
        "num_ids": 144,
        "indeed": true
    },
    {
        "number": 1092,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    initial_lights = list(map(int, input().split()))\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if i in initial_lights:\n            dp[i] = dp[i - 1] + dp[i - 2]\n        else:\n            dp[i] = dp[i - 1]\n    return str(dp[n])\n\nn, m = map(int, input().split())\ninitial_lights = list(map(int, input().split()))\nprint(solution(f\"{n} {m}\")) ",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 1094,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    messages = stdin.split('\\n')[1:]\n    chat_list = []\n\n    for message in messages:\n        if message in chat_list:\n            chat_list.remove(message)\n        chat_list.insert(0, message)\n\n    return '\\n'.join(chat_list)",
        "test": "",
        "num_ids": 88,
        "indeed": true
    },
    {
        "number": 1095,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y1 = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    m, y2 = map(int, stdin.readline().split())\n    b = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i] == b[j]:\n                count += 1\n            elif a[i] < b[j]:\n                if (b[j] - a[i]) % (y2 - y1) == 0:\n                    count += 1\n            else:\n                if (a[i] - b[j]) % (y2 - y1) == 0:\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 1096,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    column, row = stdin[0], stdin[1]\n    column_index = ord(column) - ord('a')\n    row_index = int(row) - 1\n\n    def is_valid_move(column_move, row_move):\n        return 0 <= column_index + column_move < 8 and 0 <= row_index + row_move < 8\n\n    moves = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    count = 0\n\n    for move in moves:\n        if is_valid_move(move[0], move[1]):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 193,
        "indeed": true
    },
    {
        "number": 1097,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def construct_roads(n, t, k, a):\n        roads = []\n        dead_ends = []\n        for i in range(1, t + 1):\n            for _ in range(a[i - 1]):\n                if i == 1:\n                    dead_ends.append(n - 1)\n                else:\n                    for j in range(1, n):\n                        if j not in dead_ends and j + i <= n:\n                            roads.append((j, j + i))\n                            dead_ends.append(j + i)\n                            break\n        return roads\n\n    def check_conditions(n, t, k, a):\n        roads = construct_roads(n, t, k, a)\n        if len(roads) != n - 1:\n            return False\n        dead_ends_count = 0\n        for i in range(1, n):\n            if roads.count((i, i + 1)) == 1:\n                dead_ends_count += 1\n        return dead_ends_count == k\n\n    n, t, k = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:3 + t]))\n\n    if check_conditions(n, t, k, a):\n        roads = construct_roads(n, t, k, a)\n        output = [str(n)]\n        for road in roads:\n            output.append(\"{} {}\".format(road[0], road[1]))\n        return \"\\n\".join(output)\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 392,
        "indeed": false
    },
    {
        "number": 1098,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    alarms = sorted([time.split(':') for time in stdin.split('\\n')[1:]])\n    max_sleep_time = 0\n    for i in range(n - 1):\n        sleep_time = (int(alarms[i + 1][0]) - int(alarms[i][0])) % 24 * 60 + (int(alarms[i + 1][1]) - int(alarms[i][1])) % 60\n        max_sleep_time = max(max_sleep_time, sleep_time)\n    return f\"{max_sleep_time // 60:02d}:{max_sleep_time % 60:02d}\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1099,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, u):\n        if parent[u] == u:\n            return u\n        return find_parent(parent, parent[u])\n\n    def union_parent(parent, rank, x, y):\n        xroot = find_parent(parent, x)\n        yroot = find_parent(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    n, edges = map(int, stdin.split())\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    for u, v in edges:\n        union_parent(parent, rank, u, v)\n\n    count = 0\n    for u in range(1, n + 1):\n        if find_parent(parent, u) != find_parent(parent, 1):\n            count += 1\n\n    return str(count - 1)",
        "test": "",
        "num_ids": 280,
        "indeed": false
    },
    {
        "number": 1100,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 3:\n        return \"1\"\n    else:\n        return str((n - 1) * 3) ",
        "test": "",
        "num_ids": 45,
        "indeed": false
    },
    {
        "number": 1101,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    rooms = list(map(int, stdin.split()[1]))\n    unoccupied_rooms = [i for i in range(n) if rooms[i] == 0]\n    unoccupied_rooms.sort()\n\n    min_distance = float('inf')\n    for i in range(len(unoccupied_rooms) - k):\n        distance = unoccupied_rooms[i + k] - unoccupied_rooms[i]\n        min_distance = min(min_distance, distance)\n\n    return str(min_distance)",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 1102,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    t = list(map(int, input().split()))\n    bcd = [0] * (n + 1)\n\n    for i in range(n):\n        bcd[abs(i - a)] += t[i]\n\n    return str(sum(bcd[1:]))",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 1103,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid_subsequence(subsequence: list) -> bool:\n        occurrences = [subsequence.count(i) for i in range(1, 9)]\n        return max(occurrences) - min(occurrences) <= 1\n\n    def find_longest_subsequence(cards: list, start: int, end: int, current_sequence: list, max_length: int) -> int:\n        if start > end:\n            return max_length\n\n        if is_valid_subsequence(current_sequence):\n            max_length = max(max_length, len(current_sequence))\n\n        if start == end:\n            return max_length\n\n        current_sequence.append(cards[start])\n        max_length = find_longest_subsequence(cards, start + 1, end, current_sequence, max_length)\n        current_sequence.pop()\n\n        if cards[start] == cards[start + 1]:\n            current_sequence.append(cards[start])\n            max_length = find_longest_subsequence(cards, start + 2, end, current_sequence, max_length)\n            current_sequence.pop()\n\n        return max_length\n\n    longest_subsequence = find_longest_subsequence(cards, 0, n - 1, [], 0)\n    return str(longest_subsequence)",
        "test": "",
        "num_ids": 364,
        "indeed": false
    },
    {
        "number": 1104,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_or(a, b):\n        return a | b\n\n    def bitwise_and(a, b):\n        return a & b\n\n    def find_sequence(a, b, n):\n        if n == 1:\n            return [a[0]]\n        if n == 2:\n            return a + [bitwise_or(a[0], b[0])]\n\n        t = find_sequence(a, b, n - 1)\n        t.append(bitwise_or(t[-1], b[-1]))\n        return t\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    t = find_sequence(a, b, n)\n\n    if t[-1] != bitwise_and(t[-2], t[-1]):\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, t))",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 1105,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    data = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    data.sort(key=lambda x: (x[1], x[0]))\n\n    for i in range(1, n):\n        if data[i][1] == data[i - 1][1] and data[i][0] >= data[i - 1][0]:\n            return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1106,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    total_lights = sum(a)\n    expected_lights = 2 ** (n - 1)\n\n    additional_lights = expected_lights - total_lights\n\n    return str(additional_lights)",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 1107,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, actions = stdin.split('\\n')\n    n = int(n)\n    actions = list(actions)\n    max_juice = 0\n\n    for i in range(n):\n        current_actions = []\n        current_actions.append(actions[i])\n        for j in range(i + 1, n + i):\n            current_actions.append(actions[j % n])\n            if j >= i + 4 and all(current_actions[k] == current_actions[k - 1] for k in range(i + 3, j + 1)):\n                max_juice += 1\n                break\n\n    return str(max_juice)",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 1108,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rooms = [list(map(int, room.split())) for room in stdin.split('\\n')[1:]]\n    free_rooms = 0\n\n    for room in rooms:\n        if room[0] + 2 <= room[1]:\n            free_rooms += 1\n\n    return str(free_rooms)",
        "test": "",
        "num_ids": 93,
        "indeed": true
    },
    {
        "number": 1109,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    if n % k != 0:\n        return \"0\"\n\n    for i in range(k):\n        if a[i::k] != a[:k]:\n            break\n    else:\n        return \"0\"\n\n    changes = 0\n    for i in range(k):\n        changes += sum(1 for j in range(i, n, k) if a[j] != a[i])\n\n    return str(changes)",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1110,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"3\"\n    else:\n        return str((n - 1) * 2 + 3)",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 1111,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    w = list(map(int, stdin.readline().split()))\n    MOD = 10**9 + 7\n\n    def weight(subset):\n        return sum(w[i] for i in subset)\n\n    def partitions(n, k):\n        if k == 1:\n            yield [set(range(1, n + 1))]\n            return\n        for i in range(1, n - k + 2):\n            for p in partitions(n - i, k - 1):\n                yield [set(range(1, i + 1))] + p\n\n    total_weight = 0\n    for partition in partitions(n, k):\n        partition_weight = sum(weight(subset) for subset in partition)\n        total_weight += partition_weight\n\n    return str(total_weight % MOD)",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 1112,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magic_square(matrix):\n        magic_sum = sum(matrix[0])\n        for row in matrix:\n            if sum(row) != magic_sum:\n                return False\n        for col in range(3):\n            if sum(matrix[row][col] for row in range(3)) != magic_sum:\n                return False\n        if sum(matrix[i][i] for i in range(3)) != magic_sum:\n            return False\n        if sum(matrix[i][2 - i] for i in range(3)) != magic_sum:\n            return False\n        return True\n\n    def restore_magic_square(matrix):\n        for i in range(3):\n            for j in range(3):\n                if matrix[i][j] == 0:\n                    for num in range(1, 10**5):\n                        matrix[i][j] = num\n                        if is_magic_square(matrix):\n                            return matrix\n                        else:\n                            matrix[i][j] = 0\n\n    lines = stdin.split('\\n')\n    matrix = [[int(x) for x in line.split()] for line in lines]\n    restored_matrix = restore_magic_square(matrix)\n    return '\\n'.join(' '.join(str(x) for x in row) for row in restored_matrix)",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 1113,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def mex(arr):\n        m = 0\n        while m in arr:\n            m += 1\n        return m\n\n    for i in range(n):\n        if a[i] != mex(a[:i]):\n            return str(i + 1)\n\n    return '-1'",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 1114,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    f = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    a = [0] * m\n    for i in range(m):\n        a[i] = f.index(b[i]) + 1\n\n    if len(set(a)) == m:\n        return \"Possible\\n\" + \" \".join(map(str, a))\n    elif len(set(a)) < m:\n        return \"Ambiguity\"\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 1115,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    m = int(stdin.split()[2 + n])\n    l, r = [], []\n    for i in range(m):\n        l.append(int(stdin.split()[3 + n + i * 2]))\n        r.append(int(stdin.split()[4 + n + i * 2]))\n\n    total_time = sum(a)\n    for i in range(m):\n        if total_time <= r[i]:\n            return str(total_time)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 1116,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(r, b, k):\n        painted_planks = []\n        for i in range(10**100):\n            if i % r == 0:\n                painted_planks.append('R')\n            elif i % b == 0:\n                painted_planks.append('B')\n            else:\n                painted_planks.append('-')\n\n        for i in range(len(painted_planks)):\n            if painted_planks[i] != '-':\n                current_color = painted_planks[i]\n                consecutive_count = 1\n                for j in range(i + 1, len(painted_planks)):\n                    if painted_planks[j] == current_color:\n                        consecutive_count += 1\n                    else:\n                        break\n\n                    if consecutive_count == k:\n                        return 'REBEL'\n        return 'OBEY'\n\n    T = int(stdin.readline())\n    result = []\n    for _ in range(T):\n        r, b, k = map(int, stdin.readline().split())\n        result.append(paint_fence(r, b, k))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 303,
        "indeed": false
    },
    {
        "number": 1117,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    rectangles = []\n    for i in range(n):\n        w, h = map(int, stdin.readline().split())\n        rectangles.append((w, h))\n\n    rectangles.sort(key=lambda x: (-x[0], -x[1]))\n\n    for i in range(1, n):\n        if rectangles[i][1] > rectangles[i - 1][1]:\n            return \"NO\"\n\n    return \"YES\"\n",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 1118,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    def flood_fill(start_index, new_color):\n        current_color = colors[start_index]\n        if current_color == new_color:\n            return 0\n        change_color(start_index, new_color)\n        turns = 1\n        for i in range(start_index - 1, -1, -1):\n            if colors[i] == current_color:\n                turns += flood_fill(i, new_color)\n            else:\n                break\n        for i in range(start_index + 1, n):\n            if colors[i] == current_color:\n                turns += flood_fill(i, new_color)\n            else:\n                break\n        return turns\n\n    def change_color(start_index, new_color):\n        current_color = colors[start_index]\n        for i in range(start_index, n):\n            if colors[i] == current_color:\n                colors[i] = new_color\n            else:\n                break\n        for i in range(start_index - 1, -1, -1):\n            if colors[i] == current_color:\n                colors[i] = new_color\n            else:\n                break\n\n    min_turns = n\n    for i in range(n):\n        turns = flood_fill(i, 1)\n        min_turns = min(min_turns, turns)\n\n    return str(min_turns)",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 1119,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p_a, p_b = map(int, stdin.split())\n\n    p = 10**9 + 7\n    P = 2 * p_a * (p_a + p_b) * (p_a + p_b - 1)\n    Q = (p_a + p_b) * (p_a + p_b - 1)\n\n    return str((P * pow(Q, p - 2, p)) % p)\n",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1120,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n != 0:\n        n -= (n % 10)\n        count += 1\n    return str(count)",
        "test": "",
        "num_ids": 48,
        "indeed": false
    },
    {
        "number": 1121,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    coloring = []\n\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(colors[(i + j) % len(colors)])\n        coloring.append(\"\".join(row))\n\n    return \"\\n\".join(coloring)",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1122,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    players = [i for i in range(1, N + 1)]\n    fields = []\n\n    for i in range(M):\n        if i % 2 == 0:\n            fields.append((players[i], players[i + 1]))\n        else:\n            fields.append((players[i + 1], players[i]))\n\n    output = []\n    for field in fields:\n        output.append(\" \".join(map(str, field)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 1123,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    mod = 10**9 + 7\n    total = 0\n\n    for i in range(1, K + 1):\n        total += pow(K, N - 1, mod) * i\n        total %= mod\n\n    return str(total)",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 1124,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *a = list(map(int, stdin.split()))\n    X, x = max(a), min(a)\n\n    while X != x:\n        for i in range(N):\n            if a[i] == X:\n                a[i] = X - x\n            else:\n                a[i] = X\n        X, x = max(a), min(a)\n\n    return str(x)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 1125,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    A.sort(reverse=True)\n\n    if A[0] <= 1:\n        return -1\n\n    if N == 2:\n        return min(A[0] - 1, A[1])\n\n    for i in range(1, N):\n        if A[0] <= i:\n            return -1\n        if A[0] - i <= A[i]:\n            return i - 1\n\n    return -1",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1126,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, M = map(int, stdin.split())\n    A = [X]\n    for i in range(N-1):\n        A.append(f(A[-1]**2, M))\n    return str(sum(A))\n\ndef",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 1127,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_winner(n: int, number: str) -> int:\n        last_digit = int(number[-1])\n        if last_digit % 2 == 0:\n            return 2\n        else:\n            return 1\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        number = stdin.readline().strip()\n        result.append(check_winner(n, number))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 1128,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m = map(int, stdin.split())\n    if a % m == 0:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 42,
        "indeed": false
    },
    {
        "number": 1129,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n    x.sort()\n    if n % 2 == 0:\n        return str(x[n//2-1])\n    else:\n        return str(x[n//2])",
        "test": "",
        "num_ids": 82,
        "indeed": true
    },
    {
        "number": 1130,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    timetable = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    def count_lessons(day, start_hour, end_hour):\n        return sum(day[start_hour:end_hour + 1])\n\n    def min_hours(day, start_hour, end_hour, skipped_lessons):\n        if start_hour > end_hour:\n            return 0\n        if skipped_lessons == 0:\n            return end_hour - start_hour + 1\n        if count_lessons(day, start_hour, end_hour) <= skipped_lessons:\n            return 0\n        for i in range(start_hour, end_hour + 1):\n            if day[i] == 1:\n                return min(min_hours(day, start_hour, i - 1, skipped_lessons - 1) + min_hours(day, i + 1, end_hour, skipped_lessons),\n                             min_hours(day, start_hour, end_hour, skipped_lessons))\n\n    result = min_hours(timetable[0], 0, m - 1, k)\n    for i in range(1, n):\n        result = max(result, min_hours(timetable[i], 0, m - 1, k))\n\n    return str(result)",
        "test": "",
        "num_ids": 362,
        "indeed": false
    },
    {
        "number": 1131,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, w, x, c = map(int, stdin.split())\n\n    time = 0\n    while a >= c:\n        if b >= x:\n            b -= x\n        else:\n            a -= 1\n            b = w - (x - b)\n        time += 1\n\n    return str(time)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 1132,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Check for bus topology\n    if n == 2:\n        return \"bus topology\"\n\n    # Check for ring topology\n    if n > 2:\n        for i in range(n):\n            if len(set([x for x, y in edges if i in (x, y)])) == 2:\n                return \"ring topology\"\n\n    # Check for star topology\n    if any(len(set([x for x, y in edges if i in (x, y)])) == n - 1 for i in range(n)):\n        return \"star topology\"\n\n    return \"unknown topology\"",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 1133,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    words = [stdin.readline().strip() for _ in range(n)]\n    freq = {}\n    for word in words:\n        for letter in set(word):\n            freq[letter] = freq.get(letter, 0) + 1\n    freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    max_length = 0\n    for i in range(2):\n        if i < len(freq):\n            max_length += freq[i][1] * len(freq[i][0])\n        else:\n            break\n    return max_length ",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 1134,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    m = list(map(int, stdin.split('\\n')[1].split()))\n\n    d = [0] * n\n    for i in range(n):\n        if i == 0:\n            d[i] = m[i]\n        else:\n            d[i] = min(d[i - 1] + m[i - 1] - m[i], m[i])\n\n    return str(sum(d))",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 1135,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    decoded = \"\"\n    for i in range(n):\n        decoded += s[i]\n        decoded += s[i]\n    return decoded[:n]\n\nn = int(input())\ns = input()\nprint(solution(f\"{n} {s}\")) ",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1136,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    result = 0\n\n    for i in range(1, m + 1):\n        result += n % i\n\n    return result % mod",
        "test": "",
        "num_ids": 63,
        "indeed": false
    },
    {
        "number": 1137,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    def is_valid(s_idx, t_idx, length):\n        if s_idx + length > n or t_idx + length > m:\n            return False\n        if s[s_idx:s_idx + length] != t[t_idx:t_idx + length]:\n            return False\n        return True\n\n    def helper(s_idx, t_idx, k, current_length):\n        if k == 0:\n            return current_length\n        for i in range(s_idx + 1, n):\n            for j in range(t_idx + 1, m):\n                length = j - t_idx\n                if is_valid(i, j, length):\n                    res = helper(i + length, j + length, k - 1, current_length + length)\n                    if res is not None:\n                        return res\n        return None\n\n    result = helper(0, 0, k, 0)\n    return str(result)",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1138,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    x, y = 0, 0\n    for c in s:\n        if c == 'L':\n            x -= 1\n        elif c == 'R':\n            x += 1\n        elif c == 'U':\n            y += 1\n        elif c == 'D':\n            y -= 1\n    if x == 0 and y == 0:\n        return 0\n    else:\n        return -1\n\n    # Read input\n    s = input()\n    # Call function\n    result = solution(s)\n    # Print output\n    print(result) ",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 1139,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    intervals = []\n    for i in range(n):\n        k = int(stdin.readline())\n        row_intervals = []\n        for j in range(k):\n            l, r = map(int, stdin.readline().split())\n            row_intervals.append((l, r))\n        intervals.append(row_intervals)\n\n    def count_ones(col_sums):\n        return sum(sum(1 for x in col_sums if x == i) ** 2 for i in range(3))\n\n    col_sums = [0] * m\n    for row_intervals in intervals:\n        for l, r in row_intervals:\n            for i in range(l - 1, r):\n                col_sums[i] += 1\n\n    return str(count_ones(col_sums))",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 1140,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    flowers = sorted([int(x) for x in stdin.split('\\n')[1].split()])\n    max_diff = max(flowers[i] - flowers[i - 1] for i in range(1, n))\n    count = sum(1 for i in range(1, n) if flowers[i] - flowers[i - 1] == max_diff)\n    return f\"{max_diff} {count}\\n\"",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1141,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    for _ in range(m):\n        l, r, c_1, c_2 = stdin.readline().split()\n        l, r = int(l), int(r)\n        s = s[:l - 1] + s[l - 1:r].replace(c_1, c_2) + s[r:]\n    return s",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 1142,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_clear_waves(n, k, waves):\n        bullets_left = k\n        magazines_used = 1\n        for wave in waves:\n            if wave[2] > bullets_left:\n                return False\n            bullets_left -= wave[2]\n            if bullets_left == 0:\n                magazines_used += 1\n                bullets_left = k\n        return True\n\n    def min_bullets_needed(n, k, waves):\n        if not can_clear_waves(n, k, waves):\n            return -1\n\n        bullets_used = 0\n        magazines_used = 1\n        bullets_left = k\n\n        for wave in waves:\n            bullets_needed = wave[2]\n            if bullets_left >= bullets_needed:\n                bullets_used += bullets_needed\n                bullets_left -= bullets_needed\n            else:\n                bullets_used += bullets_needed + 1\n                magazines_used += 1\n                bullets_left = k - (bullets_needed - bullets_left)\n\n        return bullets_used + magazines_used - 1\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    waves = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(min_bullets_needed(n, k, waves))",
        "test": "",
        "num_ids": 367,
        "indeed": false
    },
    {
        "number": 1143,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def days_between(d1, d2):\n        return abs((d2 - d1).days)\n\n    def date_to_days(date):\n        year = 2013\n        month, day = map(int, date.split(' '))\n        return (datetime.date(year, month, day) - datetime.date(year, 1, 1)).days\n\n    def days_to_date(days):\n        year = 2013\n        date = datetime.date(year, 1, 1) + datetime.timedelta(days=days)\n        return f\"{date.month} {date.day}\"\n\n    n = int(stdin.readline().strip())\n    olympiads = []\n\n    for _ in range(n):\n        month, day, people, time = map(int, stdin.readline().strip().split())\n        start_date = date_to_days(f\"{month} {day - time}\")\n        end_date = date_to_days(f\"{month} {day - 1}\")\n        olympiads.append((start_date, end_date, people))\n\n    olympiads.sort()\n    jury_size = 0\n    current_date = 0\n    current_jury = []\n\n    for start, end, people in olympiads:\n        if current_date <= start:\n            current_date = start\n            current_jury = []\n\n        while days_between(days_to_date(current_date), days_to_date(end)) >= 1:\n            for jury in current_jury:\n                if jury[1] == current_date:\n                    current_jury.remove(jury)\n\n            for i in range(people):\n                if len(current_jury) < i + 1 or current_jury[i][1] < current_date:\n                    jury_size += 1\n                    current_jury.append((current_date, current_date + 1))\n                    break\n\n            current_date += 1\n\n    return str(jury_size)",
        "test": "",
        "num_ids": 508,
        "indeed": false
    },
    {
        "number": 1144,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m = stdin.split('\\n')\n    n, m = int(n), int(m)\n    s = list(s)\n    t = ['a'] * m\n\n    def is_valid(s: list, t: list, i: int) -> bool:\n        for j in range(m):\n            if s[i + j] != t[j] and s[i + j] != '?':\n                return False\n        return True\n\n    def replace(s: list, t: list, i: int) -> None:\n        for j in range(m):\n            if s[i + j] == '?':\n                s[i + j] = t[j]\n\n    count = 0\n    for i in range(n - m + 1):\n        if is_valid(s, t, i):\n            replace(s, t, i)\n            count += 1\n\n    return count",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 1145,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    badges = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    coins = 0\n    for i in range(n):\n        if i > 0 and badges[i] <= badges[i - 1]:\n            badges[i] = badges[i - 1] + 1\n            coins += 1\n    return str(coins)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1146,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buttons = [list(map(int, input().split())) for _ in range(n)]\n    bulbs = [False] * m\n\n    for button in buttons:\n        for bulb in button[1:]:\n            bulbs[bulb - 1] = True\n\n    return \"YES\" if all(bulbs) else \"NO\"",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1147,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] <= a[j]:\n                valid_numbers = [num for num in range(a[i], a[j] + 1) if num % x == 0]\n                if len(valid_numbers) == k:\n                    count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 1148,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    a.sort()\n    max_squares = 0\n    for i in range(n):\n        if a[i] > a[0]:\n            break\n        max_squares += a[0]\n        a[i] = 0\n    return str(max_squares)",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1149,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x_levels = list(map(int, stdin.split('\\n')[1].split()[1:]))\n    y_levels = list(map(int, stdin.split('\\n')[2].split()[1:]))\n\n    if set(x_levels) | set(y_levels) == set(range(1, n + 1)):\n        return \"I become the guy.\"\n    else:\n        return \"Oh, my keyboard!\"",
        "test": "",
        "num_ids": 126,
        "indeed": true
    },
    {
        "number": 1150,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_square(x1, y1, x2, y2, x3, y3, x4, y4):\n        d1 = distance(x1, y1, x2, y2)\n        d2 = distance(x2, y2, x3, y3)\n        d3 = distance(x3, y3, x4, y4)\n        d4 = distance(x4, y4, x1, y1)\n        return d1 == d2 and d2 == d3 and d3 == d4\n\n    def find_min_moves(x1, y1, a1, b1, x2, y2, a2, b2, x3, y3, a3, b3, x4, y4, a4, b4):\n        min_moves = float('inf')\n        for i in range(4):\n            for j in range(4):\n                if i != j:\n                    x, y = x1, y1\n                    for _ in range(i):\n                        x, y = y - (x - a), x + (y - b)\n                    x1, y1 = x, y\n\n                    x, y = x2, y2\n                    for _ in range(i):\n                        x, y = y - (x - a), x + (y - b)\n                    x2, y2 = x, y\n\n                    x, y = x3, y3\n                    for _ in range(i):\n                        x, y = y - (x - a), x + (y - b)\n                    x3, y3 = x, y\n\n                    x, y = x4, y4\n                    for _ in range(i):\n                        x, y = y - (x - a), x + (y - b)\n                    x4, y4 = x, y\n\n                    if is_square(x1, y1, x2, y2, x3, y3, x4, y4):\n                        min_moves = min(min_moves, i)\n\n                    x, y = x1, y1\n                    for _ in range(j):\n                        x, y = y - (x - a), x + (y - b)\n                    x1, y1 = x, y\n\n                    x, y = x2, y2\n                    for _ in range(j):\n                        x, y = y - (x - a), x + (y - b)\n                    x2, y2 = x, y\n\n                    x, y = x3, y3\n                    for _ in range(j):\n                        x, y = y - (x - a), x + (y - b)\n                    x3, y3 = x, y\n\n                    x, y = x4, y4\n                    for _ in range(j):\n                        x, y = y - (x - a), x + (y - b)\n                    x4, y4 = x, y\n\n                    if is_square(x1, y1, x2, y2, x3, y3, x4, y4):\n                        min_moves = min(min_moves, j)\n\n        return min_moves if min_moves != float('inf') else -1\n\n    n = int(stdin.readline())\n    result = []\n    for _ in range(n):\n        x1, y1, a1, b1, x2, y2, a2, b2, x3, y3, a3, b3, x4, y4, a4, b4 = map(int, stdin.readline().split())\n        result.append(find_min_moves(x1, y1, a1, b1, x2, y2, a2, b2, x3, y3, a3, b3, x4, y4, a4, b4))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 1004,
        "indeed": false
    },
    {
        "number": 1151,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, U = map(int, stdin.split())\n    E = list(map(int, input().split()))\n\n    max_efficiency = -1\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if E[k] - E[i] <= U:\n                    efficiency = (E[k] - E[j]) / (E[k] - E[i])\n                    max_efficiency = max(max_efficiency, efficiency)\n\n    return f\"{max_efficiency:.9f}\" if max_efficiency != -1 else \"-1\"",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 1152,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_submatrix(matrix, submatrix):\n        for i in range(len(submatrix)):\n            for j in range(len(submatrix[0])):\n                if submatrix[i][j] != matrix[i][j]:\n                    return False\n        return True\n\n    def invert_corners(matrix, submatrix):\n        for i in range(len(submatrix)):\n            for j in range(len(submatrix[0])):\n                if (i == 0 or i == len(submatrix) - 1) and (j == 0 or j == len(submatrix[0]) - 1):\n                    matrix[i][j] = 1 - matrix[i][j]\n\n    def can_transform(A, B):\n        for i in range(len(A) - 1):\n            for j in range(len(A[0]) - 1):\n                submatrix = [[A[i][j], A[i][j + 1]], [A[i + 1][j], A[i + 1][j + 1]]]\n                if is_submatrix(B, submatrix):\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    A = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    B = [list(map(int, line.split())) for line in lines[n + 1:n + m + 1]]\n\n    if can_transform(A, B):\n        return 'Yes'\n    else:\n        return 'No'",
        "test": "",
        "num_ids": 393,
        "indeed": false
    },
    {
        "number": 1153,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n\n    x_sum = sum(x)\n    y_sum = sum(y)\n\n    if x_sum != y_sum:\n        return \"0\"\n\n    x.sort(reverse=True)\n    y.sort(reverse=True)\n\n    i = 0\n    j = 0\n    files = 0\n\n    while i < n and j < m:\n        if x[i] == y[j]:\n            files += 1\n            i += 1\n            j += 1\n        elif x[i] > y[j]:\n            i += 1\n        else:\n            j += 1\n\n    return str(files)",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 1154,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    time = 0\n    while a:\n        potato = a.pop(0)\n        while potato > 0:\n            potato -= k\n            time += 1\n        if a:\n            time += 1\n    return str(time)",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 1155,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    prices = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        prices.append(a / b)\n    return f\"{min(prices) * m:.9f}\"",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 1156,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b_prime = list(map(int, stdin.readline().strip()))\n\n    def check_conditions(l: int, r: int) -> bool:\n        b = [0] * n\n        b[4] = 0 if all(x > r for x in a[:5]) and b[3] == b[2] == b[1] == b[0] == 1 else 1 if all(x < l for x in a[:5]) and b[3] == b[2] == b[1] == b[0] == 0 else b[3]\n        for i in range(5, n):\n            if all(x > r for x in a[i - 4:i + 1]) and b[i - 1] == b[i - 2] == b[i - 3] == b[i - 4] == 1:\n                b[i] = 0\n            elif all(x < l for x in a[i - 4:i + 1]) and b[i - 1] == b[i - 2] == b[i - 3] == b[i - 4] == 0:\n                b[i] = 1\n            else:\n                b[i] = b[i - 1]\n        return b == b_prime\n\n    l, r = -10**9, 10**9\n    while l < r:\n        mid = (l + r) // 2\n        if check_conditions(mid, 10**9):\n            l = mid + 1\n        else:\n            r = mid\n\n    return f\"{l} {r}\"",
        "test": "",
        "num_ids": 428,
        "indeed": false
    },
    {
        "number": 1157,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    neg_count = 0\n    pos_count = 0\n\n    for i in range(n):\n        neg_prod = 1\n        pos_prod = 1\n        for j in range(i, n):\n            neg_prod *= a[j]\n            pos_prod *= a[j]\n            if neg_prod < 0:\n                neg_count += 1\n            if pos_prod > 0:\n                pos_count += 1\n\n    return f\"{neg_count} {pos_count}\"",
        "test": "",
        "num_ids": 165,
        "indeed": true
    },
    {
        "number": 1158,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    utensils = list(map(int, stdin.split()))\n    utensils.sort()\n\n    min_utensils = float('inf')\n    for i in range(n - k + 1):\n        current_utensils = set()\n        for j in range(k):\n            current_utensils.add(utensils[i + j])\n        min_utensils = min(min_utensils, len(current_utensils))\n\n    return str(min_utensils)",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 1159,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def find_valid_graph(n: int) -> tuple:\n        for m in range(2, n * (n - 1) // 2 + 1):\n            if is_prime(m) and m % 2 == 1:\n                edges = set()\n                for i in range(1, n + 1):\n                    for j in range(i + 1, n + 1):\n                        if len(edges) == m:\n                            break\n                        if (i, j) not in edges and (j, i) not in edges:\n                            edges.add((i, j))\n                if len(edges) == m:\n                    return m, edges\n        return -1, set()\n\n    n = int(stdin.strip())\n    m, edges = find_valid_graph(n)\n\n    if m == -1:\n        return \"-1\"\n\n    output = [str(m)]\n    for edge in edges:\n        output.append(\" \".join(map(str, edge)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 1160,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    t_shirts = list(map(int, stdin.readline().split()))\n    n = int(stdin.readline())\n    participants = [line.strip() for line in stdin.readlines()]\n\n    # Check if it is possible to present a t-shirt to each participant\n    for participant in participants:\n        sizes = participant.split(',')\n        if len(sizes) == 1:\n            size = sizes[0]\n            if size == 'S':\n                t_shirts[0] -= 1\n            elif size == 'M':\n                t_shirts[1] -= 1\n            elif size == 'L':\n                t_shirts[2] -= 1\n            elif size == 'XL':\n                t_shirts[3] -= 1\n            elif size == 'XXL':\n                t_shirts[4] -= 1\n            elif size == 'XXXL':\n                t_shirts[5] -= 1\n            else:\n                return \"NO\"\n        elif len(sizes) == 2:\n            size1, size2 = sizes[0], sizes[1]\n            if size1 == 'S' and size2 == 'M':\n                t_shirts[0] -= 1\n                t_shirts[1] -= 1\n            elif size1 == 'M' and size2 == 'L':\n                t_shirts[1] -= 1\n                t_shirts[2] -= 1\n            elif size1 == 'L' and size2 == 'XL':\n                t_shirts[2] -= 1\n                t_shirts[3] -= 1\n            elif size1 == 'XL' and size2 == 'XXL':\n                t_shirts[3] -= 1\n                t_shirts[4] -= 1\n            elif size1 == 'XXL' and size2 == 'XXXL':\n                t_shirts[4] -= 1\n                t_shirts[5] -= 1\n            else:\n                return \"NO\"\n        else:\n            return \"NO\"\n\n    # Check if there are enough t-shirts for all participants\n    if any(t_shirts[i] < 0 for i in range(6)):\n        return \"NO\"\n\n    # Print output\n    output = [\"YES\"]\n    for participant in participants:\n        sizes = participant.split(',')\n        if len(sizes) == 1:\n            size = sizes[0]\n            output.append(size)\n        elif len(sizes) == 2:\n            size1, size2 = sizes[0], sizes[1]\n            if size1 == 'S' and size2 == 'M':\n                output.append('S' if t_shirts[0] > 0 else 'M')\n            elif size1 == 'M' and size2 == 'L':\n                output.append('M' if t_shirts[1] > 0 else 'L')\n            elif size1 == 'L' and size2 == 'XL':\n                output.append('L' if t_shirts[2] > 0 else 'XL')\n            elif size1 == 'XL' and size2 == 'XXL':\n                output.append('XL' if t_shirts[3] > 0 else 'XXL')\n            elif size1 == 'XXL' and size2 == 'XXXL':\n                output.append('XXL' if t_shirts[4] > 0 else 'XXXL')\n            else:\n                return \"NO\"\n        else:\n            return \"NO\"\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 893,
        "indeed": false
    },
    {
        "number": 1161,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    brackets = {\n        '(': ')',\n        '{': '}',\n        '[': ']',\n        '<': '>'\n    }\n\n    stack = []\n\n    for bracket in stdin:\n        if bracket in brackets.keys():\n            stack.append(bracket)\n        elif bracket in brackets.values():\n            if not stack or brackets[stack[-1]] != bracket:\n                return \"Impossible\"\n            stack.pop()\n\n    return str(len(stack))",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1162,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, s, r = map(int, stdin.split())\n    P = 1\n    Q = 1\n\n    for i in range(1, p + 1):\n        if i == 1:\n            P *= s - r + 1\n            Q *= s - r + p\n        else:\n            P *= s - r\n            Q *= s - r + p - 1\n\n    return str(P * pow(Q, -1, 998244353))",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 1163,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = []\n\n    for i in range(n + m):\n        if i % 2 == 0:\n            if n > 0:\n                result.append(\"B\")\n                n -= 1\n            else:\n                result.append(\"G\")\n                m -= 1\n        else:\n            if m > 0:\n                result.append(\"G\")\n                m -= 1\n            else:\n                result.append(\"B\")\n                n -= 1\n\n    return \"\".join(result)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1164,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    total_price = 0\n    current_price = \"\"\n    for char in stdin:\n        if char.isdigit() or char == \".\":\n            current_price += char\n        else:\n            if current_price:\n                total_price += float(current_price)\n                current_price = \"\"\n    if current_price:\n        total_price += float(current_price)\n    return f\"{total_price:.2f}\"",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1165,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    queries = [list(map(int, stdin.split()[n + 2 + i * 3:n + 2 + i * 3 + 3])) for i in range(m)]\n\n    for query in queries:\n        l, r, x = query\n        found = False\n        for i in range(l - 1, r):\n            if a[i] != x:\n                print(i + 1, end=\" \")\n                found = True\n                break\n        if not found:\n            print(-1, end=\" \")\n\n    return \"\"",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 1166,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def can_move(i, j):\n        return a[j] > a[i] and (j - i) % a[i] == 0\n\n    def play_game(turn, i):\n        if i == n - 1:\n            return \"A\" if turn else \"B\"\n        if (turn, i) in memo:\n            return memo[(turn, i)]\n\n        memo[(not turn, i)] = \"A\"\n        for j in range(i + 1, n):\n            if can_move(i, j):\n                memo[(turn, i)] = play_game(not turn, j)\n                if memo[(turn, i)] == \"A\":\n                    break\n\n        return memo[(turn, i)]\n\n    memo = {}\n    result = \"\"\n    for i in range(n):\n        result += play_game(True, i)\n\n    return result",
        "test": "",
        "num_ids": 257,
        "indeed": false
    },
    {
        "number": 1167,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(t):\n        a, b, c, d, k = map(int, stdin.split('\\n')[i + 1].split())\n        pens_needed = a // c + 1\n        pencils_needed = b // d + 1\n\n        if pens_needed + pencils_needed > k:\n            result.append(-1)\n        else:\n            result.append(f\"{pens_needed} {pencils_needed}\")\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 1168,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, heights = map(int, stdin.split())\n    heights = list(map(int, heights.split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bin(heights[i] | heights[j]).count('1') > j - i:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 1169,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_isolated = n - m\n    min_isolated = n - m - 1 if m > 0 else n\n    return f\"{min_isolated} {max_isolated}\"",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 1170,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_m_free(matrix, m):\n        for i in range(len(matrix) - m + 1):\n            for j in range(len(matrix) - m + 1):\n                if all(matrix[i + k][j + l] == 0 for k in range(m) for l in range(m)):\n                    return False\n        return True\n\n    def max_ones(n, m):\n        if n == 1:\n            return 1\n        if m == 1:\n            return n\n        if m == 2:\n            return n * n // 2\n\n        max_ones_count = 0\n        for i in range(1, n - m + 2):\n            for j in range(1, n - m + 2):\n                submatrix = [[matrix[k][l] for l in range(j, j + m)] for k in range(i, i + m)]\n                if is_m_free(submatrix, m):\n                    max_ones_count = max(max_ones_count, n * n - m * m)\n\n        return max_ones_count\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        x = int(stdin.readline().strip())\n        n = 1\n        while True:\n            if max_ones(n, n) == x:\n                result.append(f\"{n} {n}\")\n                break\n            elif max_ones(n, n) > x:\n                result.append(f\"{n - 1} {n - 1}\")\n                break\n            n += 1\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 408,
        "indeed": false
    },
    {
        "number": 1171,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *V = map(int, stdin.split())\n    V.sort()\n\n    jewels_in_hand = 0\n    max_sum = float('-inf')\n\n    for _ in range(K):\n        for i in range(N):\n            if V[i] > 0:\n                jewels_in_hand += V[i]\n                V[i] = 0\n                break\n\n        for i in range(N - 1, -1, -1):\n            if V[i] < 0:\n                jewels_in_hand += V[i]\n                V[i] = 0\n                break\n\n        max_sum = max(max_sum, jewels_in_hand)\n\n    return str(max_sum)",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1172,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    q = s.count('?')\n    total = 0\n\n    for a in range(3):\n        for b in range(3):\n            for c in range(3):\n                t = s\n                for i in range(q):\n                    t = t.replace('?', chr(ord('A') + i), 1)\n                abc_number = 0\n                n = len(t)\n                for i in range(n - 2):\n                    for j in range(i + 1, n - 1):\n                        for k in range(j + 1, n):\n                            if t[i] == 'A' and t[j] == 'B' and t[k] == 'C':\n                                abc_number += 1\n                total += abc_number\n\n    return str(total % (10**9 + 7))",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1173,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(schedule: List[List[int]]) -> bool:\n        for i in range(len(schedule)):\n            for j in range(len(schedule[i])):\n                if schedule[i][j] != -1:\n                    if schedule[i][j] == i + 1:\n                        return False\n                    for k in range(len(schedule)):\n                        if schedule[i][j] == schedule[k][i]:\n                            return False\n        return True\n\n    def find_schedule(schedule: List[List[int]], day: int) -> bool:\n        if day == N:\n            return True\n        for i in range(N):\n            for j in range(N - 1):\n                if schedule[i][j] == -1:\n                    for k in range(N - 1):\n                        if schedule[i][k] == -1 and A[i][k] != A[i][j]:\n                            schedule[i][j] = A[i][k]\n                            if find_schedule(schedule, day + 1):\n                                return True\n                            schedule[i][j] = -1\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A = []\n    for i in range(1, N + 1):\n        A.append(list(map(int, lines[i].split())))\n\n    schedule = [[-1] * (N - 1) for _ in range(N)]\n    if find_schedule(schedule, 1):\n        if is_valid(schedule):\n            return str(N)\n    return str(-1)",
        "test": "",
        "num_ids": 405,
        "indeed": false
    },
    {
        "number": 1174,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, *A = list(map(int, stdin.split()))\n    A.sort(reverse=True)\n\n    total_cost = 0\n    for i, a in enumerate(A):\n        if M == 0:\n            total_cost += a\n        else:\n            y = 0\n            while M >= 1 and a >= 1:\n                a //= 2\n                M -= 1\n                y += 1\n            total_cost += a\n            if y > 0:\n                total_cost -= y\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1175,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    pairs = 0\n\n    for y in range(L, R + 1):\n        for x in range(L, y + 1):\n            if y % x == y ^ x:\n                pairs += 1\n\n    return str(pairs % MOD)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 1176,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    A.sort()\n    B = [0] * N\n\n    for i in range(N):\n        if i % 2 == 0:\n            B[i] = A[i]\n        else:\n            B[i] = -A[i]\n\n    return str(sum(B))",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 1177,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    mod = 998244353\n\n    def f(L, R):\n        return sum(A[i] for i in range(L, R + 1))\n\n    total = 0\n    for L in range(1, N + 1):\n        for R in range(L, N + 1):\n            if f(L, R) == S:\n                total += 1\n\n    return str(total % mod)\n",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 1178,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, H = map(int, stdin.split())\n    H = list(map(int, stdin.split()))\n    H.sort(reverse=True)\n    operations = 0\n\n    for i in range(K):\n        operations += H[i]\n\n    return str(operations)",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 1179,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    identifiers = list(map(int, input().split()))\n\n    pronounced_identifiers = []\n    for i in range(n):\n        if i == 0:\n            pronounced_identifiers.append(identifiers[0])\n        else:\n            pronounced_identifiers.append(identifiers[i - 1])\n            pronounced_identifiers.append(identifiers[i])\n\n    return str(pronounced_identifiers[k - 1])\n\nn, k = map(int, input().split())\nidentifiers = list(map(int, input().split()))\n\nprint(solution(f\"{n} {k}\")) ",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 1180,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    digits = stdin.readline()\n    mod = 10**9 + 7\n\n    def dfs(start: int, pluses: int, current_sum: int, current_result: int) -> int:\n        if start == n and pluses == 0:\n            return current_sum + current_result\n        if pluses == 0:\n            return dfs(start + 1, 0, current_sum, current_result)\n        if start == n:\n            return current_result\n\n        result_without_plus = dfs(start + 1, pluses, current_sum, current_result)\n        result_with_plus = dfs(start + 1, pluses - 1, int(digits[start:start + 1]), current_result)\n\n        return (result_without_plus + result_with_plus) % mod\n\n    return dfs(0, k, 0, 0)",
        "test": "",
        "num_ids": 241,
        "indeed": false
    },
    {
        "number": 1181,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n    total_pages = sum(abs(a[i + 1] - a[i]) for i in range(m - 1))\n\n    if total_pages <= n:\n        return total_pages\n\n    min_pages = float('inf')\n    for i in range(m - 1):\n        if a[i] != a[i + 1]:\n            new_a = a[:i] + [a[i + 1]] + a[i + 2:]\n            new_a.sort()\n            new_pages = sum(abs(new_a[j + 1] - new_a[j]) for j in range(m - 1))\n            min_pages = min(min_pages, new_pages)\n\n    return min_pages",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 1182,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, n, k = map(int, stdin.split())\n    violas = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        violas.append((x, y))\n\n    def count_violas(x1, y1, x2, y2):\n        count = 0\n        for x, y in violas:\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                count += 1\n        return count\n\n    def count_pictures():\n        total_pictures = 0\n        for x1 in range(1, r + 1):\n            for y1 in range(1, c + 1):\n                for x2 in range(x1, r + 1):\n                    for y2 in range(y1, c + 1):\n                        if count_violas(x1, y1, x2, y2) >= k:\n                            total_pictures += 1\n        return total_pictures\n\n    return str(count_pictures())",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 1183,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n, x, a, v):\n        places = [0] * (v + 1)\n        for place in a:\n            if place <= v:\n                places[place] = 1\n        for i in range(1, v + 1):\n            if places[i] == 0:\n                if x == 0:\n                    return False\n                x -= 1\n                places[i] = 1\n        return True\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(t):\n        n, x = map(int, stdin.split('\\n')[i * 2 + 1].split())\n        a = list(map(int, stdin.split('\\n')[i * 2 + 2].split()))\n        left, right = 1, 100\n        while left < right:\n            mid = (left + right) // 2\n            if is_possible(n, x, a, mid):\n                left = mid + 1\n            else:\n                right = mid\n        result.append(left - 1)\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1184,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove curly brackets and split the input string by comma and space\n    letters = stdin.replace(\"{\", \"\").replace(\"}\", \"\").split(\", \")\n    \n    # Create a set of letters to get distinct values\n    distinct_letters = set(letters)\n    \n    # Return the count of distinct letters\n    return str(len(distinct_letters))",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 1185,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    p = list(map(int, stdin.split()[3:]))\n\n    p.sort()\n\n    max_sum = 0\n    for i in range(n - m * k + 1):\n        current_sum = sum(p[i + m * k - 1:])\n        max_sum = max(max_sum, current_sum)\n\n    return str(max_sum)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1186,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_permutation(n: int, condition: bool) -> List[int]:\n        if n % 2 == 0:\n            return []\n        permutation = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if condition:\n                permutation[i] = i // 2\n            else:\n                permutation[i] = i // 2 + n // 2\n        return permutation[1:]\n\n    n = int(stdin.strip())\n    p = find_permutation(n, True)\n    q = find_permutation(n, False)\n\n    if not p or not q:\n        return \"NO\\nNO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, p)) + \"\\nYES\\n\" + \" \".join(map(str, q))",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1187,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, color, vertex, visited, k):\n        if vertex not in visited:\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                if color[neighbor] == color[vertex]:\n                    return False\n                if not dfs(graph, color, neighbor, visited, k):\n                    return False\n            return True\n        return True\n\n    def bfs(graph, color, k):\n        for i in range(1, k + 1):\n            visited = set()\n            for vertex in range(1, n + 1):\n                if vertex not in visited and not dfs(graph, color, vertex, visited, k):\n                    return False\n        return True\n\n    n, m = map(int, stdin.readline().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].add(v)\n\n    k = 1\n    while not bfs(graph, {i: (i + k - 1) % m + 1 for i in range(1, n + 1)}, k):\n        k += 1\n\n    return f\"{k}\\n{' '.join(map(str, [color[i] for i in range(1, n + 1)]))}\\n\"",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 1188,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prairie_partition(x: int) -> list:\n        k = 0\n        while x > 2 ** k:\n            x -= 2 ** k\n            k += 1\n        return [2 ** i for i in range(k)] + [x]\n\n    def find_options(sequence: list) -> set:\n        options = set()\n        for i in range(1, len(sequence) + 1):\n            for subset in itertools.combinations(sequence, i):\n                partition = [p for num in subset for p in prairie_partition(num)]\n                partition.sort()\n                if partition == sequence:\n                    options.add(len(subset))\n        return options\n\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    options = find_options(sequence)\n    if not options:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(list(options))))",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 1189,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    mod = 10**6 + 3\n    dp = [0] * (n + 1)\n    dp[1] = c\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (c - 1) + dp[i - 1] * (c - 1) + dp[i - 1] * (c - 1)) % mod\n    return str(dp[n])",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 1190,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w1, h1, w2, h2 = map(int, stdin.split())\n    total_area = (w1 * h1) + (w2 * h2)\n    marked_cells = total_area + (w1 - w2) * h1\n    return str(marked_cells)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 1191,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    powers = list(map(int, stdin.readline().split()))\n    coins = list(map(int, stdin.readline().split()))\n\n    for i in range(n):\n        killed_coins = 0\n        killed_count = 0\n        for j in range(i - 1, -1, -1):\n            if powers[i] > powers[j]:\n                killed_coins += coins[j]\n                killed_count += 1\n                if killed_count >= k:\n                    break\n        coins[i] += killed_coins\n\n    return ' '.join(map(str, coins))",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 1192,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n\n    def count_inversions(p: list) -> int:\n        inversions = 0\n        for i in range(len(p)):\n            for j in range(i + 1, len(p)):\n                if p[i] > p[j]:\n                    inversions += 1\n        return inversions\n\n    def expected_inversions(n: int, k: int, p: list) -> float:\n        total_inversions = 0\n        for _ in range(k):\n            l = random.randint(1, n - 1)\n            r = random.randint(l, n)\n            p[l:r + 1] = reversed(p[l:r + 1])\n            total_inversions += count_inversions(p)\n        return total_inversions / k\n\n    return f\"{expected_inversions(n, k, p):.9f}\"",
        "test": "",
        "num_ids": 255,
        "indeed": false
    },
    {
        "number": 1193,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    speeds = sorted(list(map(int, stdin.split()[2:])), reverse=True)\n\n    max_speed = speeds[0]\n    for i in range(1, n):\n        if speeds[i] < max_speed:\n            k -= 1\n            if k == 0:\n                break\n        else:\n            max_speed = speeds[i]\n\n    return str(max_speed)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1194,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    p = list(map(int, stdin.split(\"\\n\")[1].split()))\n    q = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    def lexicographic_permutation(n: int, k: int) -> list:\n        p = []\n        for i in range(n):\n            p.append(i)\n        for i in range(n - 1, 0, -1):\n            j = k % i\n            k //= i\n            p[i], p[j] = p[j], p[i]\n        return p\n\n    def find_ord(p: list) -> int:\n        n = len(p)\n        ord_p = 0\n        for i in range(n):\n            smaller = 0\n            for j in range(i):\n                if p[j] < p[i]:\n                    smaller += 1\n            ord_p += smaller * factorial(n - 1 - i)\n        return ord_p\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    sum_ord = (find_ord(p) + find_ord(q)) % factorial(n)\n    sum_p = lexicographic_permutation(n, sum_ord)\n\n    return \" \".join(map(str, sum_p))",
        "test": "",
        "num_ids": 365,
        "indeed": false
    },
    {
        "number": 1195,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] % 2 == 0:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 1196,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    t = stdin.readline().split()\n    s = stdin.readline().split()\n\n    def decompress(compressed):\n        return ''.join([block[1] * int(block[0]) for block in compressed])\n\n    t_decompressed = decompress(t)\n    s_decompressed = decompress(s)\n\n    count = 0\n    for i in range(len(t_decompressed) - len(s_decompressed) + 1):\n        if t_decompressed[i:i + len(s_decompressed)] == s_decompressed:\n            count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 1197,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[n] = 1\n\n    for i in range(n - 1, -1, -1):\n        if stdin[i] == '?':\n            dp[i] = dp[i + 1] * 3\n        elif stdin[i] == '*':\n            dp[i] = dp[i + 1]\n        else:\n            dp[i] = dp[i + 1]\n            if i > 0:\n                dp[i] += dp[i + 1] * int(stdin[i])\n            if i < n - 1 and stdin[i + 1] != '*':\n                dp[i] += dp[i + 2] * int(stdin[i])\n\n        dp[i] %= mod\n\n    return str(dp[0])",
        "test": "",
        "num_ids": 244,
        "indeed": false
    },
    {
        "number": 1198,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def partition_sum(start, end):\n        if start == end:\n            return a[start]\n        mid = (start + end) // 2\n        left_sum = partition_sum(start, mid)\n        right_sum = partition_sum(mid + 1, end)\n        return left_sum + right_sum\n\n    def min_partition_sum(start, end):\n        if start == end:\n            return a[start]\n        mid = (start + end) // 2\n        left_sum = min_partition_sum(start, mid)\n        right_sum = min_partition_sum(mid + 1, end)\n        return min(left_sum + right_sum, partition_sum(start, end))\n\n    return str(min_partition_sum(0, n - 1))",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 1199,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    colors = list(map(int, stdin.readline().split()))\n\n    # Count the number of children with the same color\n    color_count = [0] * m\n    for color in colors:\n        color_count[color - 1] += 1\n\n    # Find the maximum number of children who can end up with a distinct-colored pair of mittens\n    max_children = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            max_children = max(max_children, color_count[i] + color_count[j])\n\n    # Find the colors for the children\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors[i] != colors[j]:\n                result.append((colors[i], colors[j]))\n                break\n\n    return f\"{max_children}\\n\" + \"\\n\".join(\" \".join(map(str, pair)) for pair in result)",
        "test": "",
        "num_ids": 262,
        "indeed": false
    },
    {
        "number": 1200,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    m = 0\n    for i in range(1, n):\n        if x[i] - x[i - 1] != x[i] - x[0]:\n            m += 1\n\n    return str(m)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1201,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    items = [list(map(int, item.split())) for item in stdin.split('\\n')[1:]]\n    items.sort(key=lambda x: (-x[2], x[1]))\n\n    saved_items = []\n    total_value = 0\n    for i in range(n):\n        if items[i][0] < items[i][1]:\n            saved_items.append(i + 1)\n            total_value += items[i][2]\n\n    return f\"{total_value}\\n{len(saved_items)}\\n{' '.join(map(str, saved_items))}\"",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 1202,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_finalists(semifinal_results: list, k: int) -> str:\n        n = len(semifinal_results)\n        finalists = [0] * n\n\n        semifinal_results.sort()\n        best_results = semifinal_results[:k]\n        worst_results = semifinal_results[n - k:]\n\n        for i in range(n):\n            if semifinal_results[i] in best_results or semifinal_results[i] in worst_results:\n                finalists[i] = 1\n\n        return \"\".join(map(str, finalists))\n\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n\n    semifinal_a = list(map(int, input_data[1].split()))\n    semifinal_b = list(map(int, input_data[n + 1].split()))\n\n    finalists_a = find_finalists(semifinal_a, 0)\n    finalists_b = find_finalists(semifinal_b, 0)\n\n    return finalists_a + \"\\n\" + finalists_b",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 1203,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, L = map(int, stdin.split())\n    depth = (H * H + L * L) / (2 * H)\n    return f\"{depth:.10f}\"",
        "test": "",
        "num_ids": 48,
        "indeed": false
    },
    {
        "number": 1204,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p, e = [], []\n    for _ in range(n):\n        p_i, e_i = map(int, input().split())\n        p.append(p_i)\n        e.append(e_i)\n\n    p.sort(reverse=True)\n    e.sort()\n\n    total_effort = 0\n    for i in range(k - 1):\n        total_effort += e.pop()\n\n    for i in range(n - k + 1):\n        if p[i] == p[k - 2]:\n            total_effort += e[i]\n\n    return str(total_effort)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 1205,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(points, origin):\n        return all(origin.distance(p) == origin.distance(-p) for p in points)\n\n    def is_good(points):\n        return is_symmetric(points, Point(0, 0))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin.readline())\n    points = set()\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.add(Point(x, y))\n\n    if any(p.x == 0 or p.y == 0 for p in points):\n        return \"-1\"\n\n    lines = set()\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            dx, dy = p2.x - p1.x, p2.y - p1.y\n            g = gcd(abs(dx), abs(dy))\n            dx, dy = dx // g, dy // g\n            lines.add((dx, dy))\n            lines.add((-dx, -dy))\n\n    good_lines = sum(1 for dx, dy in lines if is_good(set(p + Point(dx, dy) for p in points)))\n    return str(good_lines)\n\nfrom typing import Set, Tuple\n\nclass Point:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other: 'Point') -> bool:\n        return self.x == other.x and self.y == other.y\n\n    def __add__(self, other: 'Point') -> 'Point':\n        return Point(self.x + other.x, self.y + other.y)\n\n    def distance(self, other: 'Point') -> int:\n        return abs(self.x - other.x) + abs(self.y - other.y)",
        "test": "",
        "num_ids": 495,
        "indeed": false
    },
    {
        "number": 1206,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expected_value(L, R):\n        if L == R:\n            return L\n        else:\n            return (L + R) / 2\n\n    n = int(stdin.readline().strip())\n    bids = []\n    for _ in range(n):\n        L, R = map(int, stdin.readline().strip().split())\n        bids.append((L, R))\n\n    bids.sort(key=lambda x: x[1])\n    max_bid = bids[-1][1]\n    second_highest_bid = bids[-2][1] if len(bids) > 1 else 0\n\n    expected_value_ = expected_value(second_highest_bid, max_bid)\n    return f\"{expected_value_:.9f}\"",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 1207,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, neighbor):\n                    return True\n            elif not back[neighbor]:\n                return True\n        back[node] = True\n        return False\n\n    def is_acyclic(graph):\n        visited = [False] * n\n        back = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                if find_cycle(graph, i):\n                    return False\n        return True\n\n    def topological_sort(graph):\n        visited = [False] * n\n        order = []\n        for i in range(n):\n            if not visited[i]:\n                stack = [i]\n                while stack:\n                    node = stack[-1]\n                    if not visited[node]:\n                        visited[node] = True\n                        for neighbor in graph[node]:\n                            if not visited[neighbor]:\n                                stack.append(neighbor)\n                    else:\n                        order.append(stack.pop())\n        return order\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        graph[u - 1].append(v - 1)\n\n    if is_acyclic(graph):\n        order = topological_sort(graph)\n        print(m)\n    else:\n        print(-1)",
        "test": "",
        "num_ids": 403,
        "indeed": false
    },
    {
        "number": 1208,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    events = []\n    for _ in range(n):\n        event = stdin.readline().strip()\n        if event[0] == \"+\":\n            events.append(int(event[1:]))\n        elif event[0] == \"-\":\n            events.remove(int(event[1:]))\n    return str(max(set(events)))",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1209,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [float(stdin.readline().strip()) for _ in range(n)]\n\n    b = []\n    for i in range(n):\n        if a[i] == int(a[i]):\n            b.append(int(a[i]))\n        elif a[i] > 0:\n            b.append(int(a[i]) + 1)\n        else:\n            b.append(int(a[i]) - 1)\n\n    return \"\\n\".join(str(x) for x in b)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 1210,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def combinations(n, l, r):\n        if n == 1:\n            return [(l,)]\n        return [(i, j) for i in range(l, r + 1) for j in range(l, r + 1) if i != j]\n\n    def probability(s_i, s_j, p):\n        count = 0\n        for i in range(s_i, s_j + 1):\n            for j in range(s_i, s_j + 1):\n                if i * j % p == 0:\n                    count += 1\n        return count / ((s_j - s_i + 1) ** 2)\n\n    lines = stdin.split('\\n')\n    n, p = map(int, lines[0].split())\n    l = [list(map(int, lines[i].split())) for i in range(1, n + 1)]\n\n    if not is_prime(p):\n        return \"Error: p must be a prime number\"\n\n    total_dollars = 0\n    for i in range(n):\n        s_i = l[i][0]\n        for j in range(n):\n            if i != j:\n                s_j = l[j][1]\n                if s_i * s_j % p == 0:\n                    total_dollars += 1000\n\n    return str(total_dollars)",
        "test": "",
        "num_ids": 406,
        "indeed": false
    },
    {
        "number": 1211,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_hamsters = 0\n    max_box_type = 0\n\n    for i in range(K):\n        boxes = N // a[i]\n        hamsters = boxes * a[i]\n        if hamsters > max_hamsters:\n            max_hamsters = hamsters\n            max_box_type = i + 1\n\n    return f\"{max_box_type} {N // a[max_box_type - 1]}\"",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 1212,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    h = list(map(int, stdin.split()[2:]))\n    min_sum = sum(h[:k])\n    min_index = 0\n    for i in range(1, n - k + 1):\n        current_sum = sum(h[i:i + k])\n        if current_sum < min_sum:\n            min_sum = current_sum\n            min_index = i\n    return str(min_index)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 1213,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    slogan = stdin.readline().strip()\n\n    t = 0\n    result = []\n\n    for i in range(n):\n        if i < k:\n            t += 1\n            result.append(\"LEFT\")\n        elif i > k:\n            t += 1\n            result.append(\"RIGHT\")\n        else:\n            t += 1\n            result.append(f\"PRINT {slogan[i]}\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 1214,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_square(num):\n        return int(num**0.5)**2 == num\n\n    def find_sequence(x):\n        sequence = [1] * n\n        sequence[1::2] = x\n        for i in range(1, n):\n            if not is_square(sum(sequence[:i+1])):\n                return False\n        return sequence\n\n    sequence = find_sequence(x)\n\n    if sequence:\n        return \"Yes\\n\" + \" \".join(map(str, sequence))\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 1215,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str((n - 1) * (n - 2))",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 1216,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    result = []\n    i = 0\n    while i < n:\n        if s[i] in \"aeiouy\":\n            if i + 1 < n and s[i] == s[i + 1] and s[i] != \"e\" and s[i] != \"o\":\n                result.append(s[i])\n                i += 1\n            elif i + 2 < n and s[i:i + 3] in [\"eee\", \"ooo\"]:\n                result.append(s[i])\n                result.append(s[i + 1])\n                i += 2\n            else:\n                result.append(s[i])\n        else:\n            result.append(s[i])\n        i += 1\n    return \"\".join(result)",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 1217,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    b = list(map(int, stdin.split()[n + 2:n + m + 2]))\n\n    a.sort()\n\n    result = []\n    for value in b:\n        count = 0\n        for num in a:\n            if num <= value:\n                count += 1\n            else:\n                break\n        result.append(count)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 147,
        "indeed": true
    },
    {
        "number": 1218,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    if n == 2:\n        return \"-1\"\n    if n == 3:\n        return \"1\"\n    if n == 4:\n        return \"2\"\n    if n == 5:\n        return \"1\"\n    if n == 6:\n        return \"2\"\n    if n == 7:\n        return \"3\"\n    if n == 8:\n        return \"-1\"\n    if n == 9:\n        return \"2\"\n    if n == 10:\n        return \"3\"\n    if n == 11:\n        return \"4\"\n    if n == 12:\n        return \"3\"\n    if n == 13:\n        return \"4\"\n    if n == 14:\n        return \"5\"\n    if n == 15:\n        return \"4\"\n    if n == 16:\n        return \"5\"\n    if n == 17:\n        return \"6\"\n    if n == 18:\n        return \"5\"\n    if n == 19:\n        return \"6\"\n    if n == 20:\n        return \"7\"\n    if n == 21:\n        return \"6\"\n    if n == 22:\n        return \"7\"\n    if n == 23:\n        return \"8\"\n    if n == 24:\n        return \"7\"\n    if n == 25:\n        return \"8\"\n    if n == 26:\n        return \"9\"\n    if n == 27:\n        return \"8\"\n    if n == 28:\n        return \"9\"\n    if n == 29:\n        return \"10\"\n    if n == 30:\n        return \"9\"\n    if n == 31:\n        return \"10\"\n    if n == 32:\n        return \"11\"\n    if n == 33:\n        return \"10\"\n    if n == 34:\n        return \"11\"\n    if n == 35:\n        return \"12\"\n    if n == 36:\n        return \"11\"\n    if n == 37:\n        return \"12\"\n    if n == 38:\n        return \"13\"\n    if n == 39:\n        return \"12\"\n    if n == 40:\n        return \"13\"\n    if n == 41:\n        return \"14\"\n    if n == 42:\n        return \"13\"\n    if n == 43:\n        return \"14\"\n    if n == 44:\n        return \"15\"\n    if n == 45:\n        return \"14\"\n    if n == 46:\n        return \"15\"\n    if n == 47:\n        return \"16\"\n    if n == 48:\n        return \"15\"\n    if n == 49:\n        return \"16\"\n    if n == 50:\n        return \"17\"\n    if n == 51:\n        return \"16\"\n    if n == 52:\n        return \"17\"\n    if n == 53:\n        return \"18\"\n    if n == 54:\n        return \"17\"\n    if n == 55:\n        return \"18\"\n    if n == 56:\n        return \"19\"\n    if n == 57:\n        return \"18\"\n    if n == 58:\n        return \"19\"\n    if n == 59:\n        return \"20\"\n    if n == 60:\n        return \"19\"\n    if n == 61:\n        return \"20\"\n    if n == 62:\n        return \"21\"\n    if n == 63:\n        return \"20\"\n    if n == 64:\n        return \"21\"\n    if n == 65:\n        return \"22\"\n    if n == 6",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 1219,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n - 1):\n        max_power = max(a[i] + a[i + 1], a[i] + a[i + 1])\n        a[i] = -max_power\n        a.pop(i + 1)\n\n    return str(a[0])",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 1220,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[1] * n for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        graph[x - 1][y - 1] = graph[y - 1][x - 1] = 0\n\n    def dfs(v, visited):\n        if not visited[v]:\n            visited[v] = True\n            for i in range(n):\n                if graph[v][i]:\n                    dfs(i, visited)\n\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            components.append(0)\n            dfs(i, visited)\n\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j]:\n                components[-1] += 1\n\n    components.sort(reverse=True)\n    output = [str(len(components))] + [str(c) for c in components]\n    return \"\\n\".join(output)\n",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 1221,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a.sort()\n    b.sort(reverse=True)\n\n    return str(a[0] * b[0])",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 1222,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    count = 0\n    num = 1\n\n    while count < k:\n        if is_lunlun(num):\n            count += 1\n            if count == k:\n                return str(num)\n        num += 1\n\n\ndef",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 1223,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    P = list(map(int, P.split()))\n    P.sort()\n\n    def second_largest(L: int, R: int) -> int:\n        return P[R - 1] if P[R - 1] != P[L] else P[R - 2]\n\n    total_sum = 0\n    for L in range(1, N):\n        for R in range(L + 1, N + 1):\n            total_sum += second_largest(L, R)\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 1224,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1 1\"\n    for a in range(1, n):\n        for b in range(1, n):\n            if 3**a + 5**b == n:\n                return f\"{a} {b}\"\n    return \"-1\"",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 1225,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H = int(stdin)\n    count = 0\n    while H > 0:\n        if H == 1:\n            count += 1\n            break\n        elif H % 2 == 0:\n            H = H // 2\n            count += 1\n        else:\n            H = (H + 1) // 2\n            count += 2\n    return str(count)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1226,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if a == 1:\n        return str((n - b) % mod)\n    elif b == n:\n        return str((n - a) % mod)\n    else:\n        return str(((n - a) * (n - b) - (n - a - b + 1)) % mod)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 1227,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(1, N + 1):\n        digits = [int(d) for d in str(i)]\n        if K in digits:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 72,
        "indeed": false
    },
    {
        "number": 1228,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    category = \"\"\n    increase = 0\n\n    if x % 4 == 1:\n        category = \"A\"\n    elif x % 4 == 3:\n        category = \"B\"\n        increase = 1\n    elif x % 4 == 2:\n        category = \"C\"\n        increase = 2\n    else:\n        category = \"D\"\n        increase = 2\n\n    return f\"{increase} {category}\"",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1229,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    multiset = [stdin.readline().strip() for _ in range(n)]\n    coins = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_easy_to_remember(multiset: List[str]) -> bool:\n        for i in range(m):\n            char_count = defaultdict(int)\n            for string in multiset:\n                char_count[string[i]] += 1\n            if len([count for count in char_count.values() if count == 1]) != n:\n                return False\n        return True\n\n    def min_coins_to_change(multiset: List[str], coins: List[List[int]]) -> int:\n        min_coins = 0\n        for i in range(n):\n            for j in range(m):\n                if sum(coins[i][j * m + k] for k in range(m)) >= 1:\n                    min_coins += coins[i][j * m + j]\n        return min_coins\n\n    if is_easy_to_remember(multiset):\n        return 0\n    else:\n        return min_coins_to_change(multiset, coins)\n\n    stdin.close()",
        "test": "",
        "num_ids": 334,
        "indeed": false
    },
    {
        "number": 1230,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    friends = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 0:\n        return \"-1\"\n\n    if n == 1:\n        return \"0\"\n\n    max_friends = n - 1\n    min_friends = 0\n\n    for i in range(n):\n        if friends[i] > max_friends:\n            return \"-1\"\n        if friends[i] < min_friends:\n            min_friends = friends[i]\n\n    if min_friends == 0:\n        return \"0\"\n\n    possible_friends = []\n    for i in range(min_friends, max_friends + 1):\n        if i not in friends:\n            possible_friends.append(i)\n\n    return \" \".join(map(str, sorted(possible_friends)))",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 1231,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0 or b == 0:\n        return \"NO\"\n    else:\n        return \"YES\"",
        "test": "",
        "num_ids": 45,
        "indeed": false
    },
    {
        "number": 1232,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_A, n_B = map(int, stdin.split())\n    k, m = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    if k == n_A and m == n_B:\n        return \"YES\"\n\n    for i in range(k):\n        if A[i] >= B[0]:\n            return \"NO\"\n\n    return \"YES\"\n",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1233,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    permutation = list(map(int, stdin.split('\\n')[1].split()))\n\n    def insertion_sort_swaps(arr):\n        swaps = 0\n        for i in range(1, n):\n            j = i\n            while j > 0 and arr[j] < arr[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                swaps += 1\n                j -= 1\n        return swaps\n\n    min_swaps = insertion_sort_swaps(permutation)\n    min_pairs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] != permutation[j]:\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                swaps = insertion_sort_swaps(permutation)\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n\n                if swaps == min_swaps:\n                    min_pairs += 1\n\n    return f\"{min_swaps} {min_pairs}\"",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 1234,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, *a = map(int, stdin.split())\n\n    def beauty(subarray):\n        return sum(sorted(subarray)[-m:])\n\n    def split_array(a, k):\n        size = len(a) // k\n        return [a[i * size: (i + 1) * size] for i in range(k - 1)] + [a[(k - 1) * size:]]\n\n    def find_max_beauty(a, k):\n        max_beauty = 0\n        max_partition = []\n        for partition in split_array(a, k):\n            partition_beauty = beauty(partition)\n            if partition_beauty > max_beauty:\n                max_beauty = partition_beauty\n                max_partition = partition\n        return max_beauty, max_partition\n\n    max_beauty, max_partition = find_max_beauty(a, k)\n    partition_sizes = [len(subarray) for subarray in max_partition]\n    partition_indices = [sum(partition_sizes[:i]) for i in range(1, k)]\n\n    return f\"{max_beauty}\\n\" + \" \".join(map(str, partition_indices)) + \"\\n\"",
        "test": "",
        "num_ids": 318,
        "indeed": false
    },
    {
        "number": 1235,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    A = list(map(int, a.split()))\n    B = list(map(int, b.split()))\n\n    for a_i in A:\n        for b_i in B:\n            if a_i + b_i not in A and a_i + b_i not in B:\n                return f\"{a_i} {b_i}\"\n\n    return \"No solution\"",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1236,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    survivors = sum(a)\n    for i in range(n):\n        survivors -= a[i]\n        if survivors % 2 == 0:\n            return \"Stannis\"\n        if survivors == k:\n            return \"Daenerys\"\n    return \"Stannis\"",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1237,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    passengers = []\n    for _ in range(n):\n        f, t = map(int, input().split())\n        passengers.append((f, t))\n\n    passengers.sort(key=lambda x: x[1])\n    time = 0\n    for i in range(n):\n        time += passengers[i][1] - time\n        if passengers[i][0] == 0:\n            continue\n        time += passengers[i][0]\n\n    return str(time)",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1238,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    x = a[0] - 1\n    stolen = 0\n\n    for i in range(n):\n        if a[i] != x + 1:\n            stolen += a[i] - x - 1\n        x = a[i]\n\n    return str(stolen)",
        "test": "",
        "num_ids": 113,
        "indeed": true
    },
    {
        "number": 1239,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort()\n    min_distance = abs(a[1] - a[0])\n    count = 1\n    for i in range(2, n):\n        distance = abs(a[i] - a[i - 1])\n        if distance == min_distance:\n            count += 1\n        elif distance < min_distance:\n            min_distance = distance\n            count = 1\n    return f\"{min_distance} {count}\"",
        "test": "",
        "num_ids": 145,
        "indeed": true
    },
    {
        "number": 1240,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    columns = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        columns.append((l, r))\n\n    L = sum(l for l, r in columns)\n    R = sum(r for l, r in columns)\n    beauty = abs(L - R)\n\n    for i in range(n):\n        l, r = columns[i]\n        new_beauty = abs((L - l + r) - (R + l - r))\n        if new_beauty > beauty:\n            beauty = new_beauty\n            k = i + 1\n\n    return str(k) if beauty > abs(L - R) else \"0\"",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 1241,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    # Calculate the length of the longest subsegment of consecutive elements consisting of only ones\n    f_a = 0\n    temp_f_a = 0\n    for i in range(n):\n        if a[i] == 1:\n            temp_f_a += 1\n        else:\n            f_a = max(f_a, temp_f_a)\n            temp_f_a = 0\n    f_a = max(f_a, temp_f_a)\n\n    # Change no more than k zeroes to ones to maximize f(a)\n    zero_indices = [i for i in range(n) if a[i] == 0]\n    for i in zero_indices[:k]:\n        a[i] = 1\n\n    # Calculate the length of the longest subsegment of consecutive elements consisting of only ones\n    # after changing the zeroes to ones\n    f_a_ = 0\n    temp_f_a_ = 0\n    for i in range(n):\n        if a[i] == 1:\n            temp_f_a_ += 1\n        else:\n            f_a_ = max(f_a_, temp_f_a_)\n            temp_f_a_ = 0\n    f_a_ = max(f_a_, temp_f_a_)\n\n    # Print the results\n    output = f\"{f_a_}\\n{' '.join(map(str, a))}\"\n    return output",
        "test": "",
        "num_ids": 390,
        "indeed": false
    },
    {
        "number": 1242,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    result = [0] * n\n\n    for i in range(1, n):\n        if s[:i] > s[:i][::-1]:\n            result[i] = 1\n            s = s[:i][::-1] + s[i:]\n        else:\n            s = s[:i] + s[i:]\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 1243,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    matchboxes = list(map(int, stdin.split('\\n')[1].split()))\n    total_matches = sum(matchboxes)\n    avg_matches = total_matches // n\n    moves = 0\n\n    for i in range(n):\n        diff = abs(matchboxes[i] - avg_matches)\n        moves += diff\n        matchboxes[i] = avg_matches\n\n    return str(moves)",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1244,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1245,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    def generate_brackets(n: int, segments: list) -> str:\n        if n == 0:\n            return \"\"\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if (l, r) in segments:\n                    left_part = generate_brackets(n - r, segments)\n                    if left_part != \"IMPOSSIBLE\":\n                        return \"(\" + left_part + \")\" + generate_brackets(n - l - r, segments)\n        return \"IMPOSSIBLE\"\n\n    return generate_brackets(2 * n, segments)",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1246,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n = int(input())\n        operations = []\n        for _ in range(n):\n            operation, *args = input().split()\n            operations.append((operation, int(args[0]) if args else None))\n        return operations\n\n    def write_output(operations):\n        print(len(operations))\n        for operation, arg in operations:\n            print(f\"{operation} {arg}\" if arg is not None else operation)\n\n    def correct_operations(operations):\n        corrected_operations = []\n        heap = []\n\n        for operation, arg in operations:\n            if operation == \"insert\":\n                heap.append(arg)\n                corrected_operations.append((\"insert\", arg))\n            elif operation == \"getMin\":\n                if not heap:\n                    corrected_operations.append((\"insert\", arg))\n                else:\n                    while heap and heap[0] > arg:\n                        heap.pop(0)\n                    corrected_operations.append((\"getMin\", heap[0]))\n            elif operation == \"removeMin\":\n                if not heap:\n                    corrected_operations.append((\"insert\", arg))\n                else:\n                    while heap and heap[0] > arg:\n                        heap.pop(0)\n                    if heap:\n                        heap.pop(0)\n                        corrected_operations.append(\"removeMin\")\n\n        return corrected_operations\n\n    operations = read_input()\n    corrected_operations = correct_operations(operations)\n    write_output(corrected_operations)\n",
        "test": "",
        "num_ids": 381,
        "indeed": false
    },
    {
        "number": 1247,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return \"Second\"\n    return \"First\"",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 1248,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d1, d2, d3 = map(int, stdin.split())\n    return str(min(d1 + d2, d1 + d3, d2 + d3))",
        "test": "",
        "num_ids": 46,
        "indeed": false
    },
    {
        "number": 1249,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k, n, s = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    if k * n > m:\n        return \"-1\\n\"\n\n    def is_valid(flowers: List[int]) -> bool:\n        for i in range(s):\n            if b.count(b[i]) > flowers.count(b[i]):\n                return False\n        return True\n\n    def can_remove(removed: int) -> bool:\n        for i in range(0, m - k + 1, k):\n            if is_valid(a[i:i + k]):\n                return True\n        return False\n\n    for i in range(1, m - k * n + 1):\n        if can_remove(i):\n            return \"1\\n\" + \" \".join(map(str, range(i))) + \"\\n\"\n\n    return \"-1\\n\"",
        "test": "",
        "num_ids": 253,
        "indeed": false
    },
    {
        "number": 1250,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 1:\n        return -1\n    else:\n        return \" \".join([str(i) for i in range(1, n + 1)])",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 1251,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    strokes = 0\n    i = 0\n    while i < n:\n        height = a[i]\n        width = 1\n        while i + 1 < n and a[i + 1] == height:\n            width += 1\n            i += 1\n        strokes += min(height, width)\n        i += 1\n    return str(strokes)",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 1252,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, time_left: int, visited: set) -> int:\n        if u == n:\n            return 1\n        if time_left < 0:\n            return 0\n        if u in visited:\n            return 0\n        visited.add(u)\n        result = 0\n        for v, t in graph[u]:\n            result += dfs(v, time_left - t, visited)\n        visited.remove(u)\n        return result\n\n    n, m, T = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, t = map(int, stdin.split())\n        graph[u].append((v, t))\n\n    max_count = 0\n    max_path = []\n    for i in range(1, n + 1):\n        visited = set()\n        count = dfs(i, T, visited)\n        if count > max_count:\n            max_count = count\n            max_path = list(visited)\n\n    return f\"{max_count}\\n{' '.join(map(str, max_path))}\"",
        "test": "",
        "num_ids": 293,
        "indeed": false
    },
    {
        "number": 1253,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    incomes = list(map(int, input().split()))\n\n    if k % 2 == 0:\n        return sum(incomes)\n    else:\n        incomes.sort(key=abs)\n        return sum(incomes[:-1]) - sum(incomes[-1:])",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1254,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    subjects = [0] * m\n    candidates = []\n\n    for _ in range(n):\n        s, r = map(int, stdin.readline().split())\n        subjects[s - 1] += 1\n        candidates.append(r)\n\n    candidates.sort(reverse=True)\n    subjects.sort(reverse=True)\n\n    total_sum = 0\n    for i in range(min(n, m)):\n        if subjects[i] > 0 and candidates[i] > 0:\n            total_sum += candidates[i]\n        else:\n            break\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1255,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    times = []\n    for i in range(n):\n        h, m = map(int, stdin.readline().split())\n        times.append(h * 60 + m)\n\n    times.sort()\n\n    cashes = 1\n    max_cashes = 1\n    for i in range(1, n):\n        if times[i] - times[i - 1] <= 1:\n            cashes += 1\n        else:\n            cashes = 1\n        max_cashes = max(max_cashes, cashes)\n\n    return str(max_cashes)",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1256,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    numbers = [int(i) for i in stdin.split('+')]\n    sorted_numbers = sorted(numbers)\n    return '+'.join(str(x) for x in sorted_numbers)",
        "test": "",
        "num_ids": 50,
        "indeed": true
    },
    {
        "number": 1257,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_sum = n * (n * n + 1) // 2\n    print(max_sum)\n\n    table = []\n    num = 1\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(num)\n            num += 1\n        table.append(row)\n\n    for row in table:\n        print(\" \".join(map(str, row)))\n\n    return \"\"",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1258,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_permutation(q):\n        n = len(q) + 2\n        p = [0] * n\n        for i in range(n - 2):\n            for j in range(3):\n                if q[i][j] not in p:\n                    p[i + j] = q[i][j]\n                    break\n        return p\n\n    n = int(stdin.readline().strip())\n    q = []\n    for _ in range(n - 2):\n        q.append(list(map(int, stdin.readline().strip().split())))\n\n    p = find_permutation(q)\n    return \" \".join(map(str, p))",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 1259,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start):\n        visited = [False] * (n + 1)\n        stack = []\n        cycle = []\n\n        def dfs(vertex):\n            visited[vertex] = True\n            stack.append(vertex)\n\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif neighbor in stack:\n                    for index, vertex in enumerate(stack):\n                        if vertex == neighbor:\n                            cycle.extend(stack[index:])\n                            return True\n\n            stack.pop()\n            return False\n\n        dfs(start)\n        return cycle\n\n    def find_independent_set(graph):\n        visited = [False] * (n + 1)\n        independent_set = []\n\n        for vertex in range(1, n + 1):\n            if not visited[vertex]:\n                stack = [vertex]\n                while stack:\n                    current = stack.pop()\n                    if not visited[current]:\n                        visited[current] = True\n                        independent_set.append(current)\n                        for neighbor in graph[current]:\n                            stack.append(neighbor)\n\n        return independent_set\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = {i: set() for i in range(1, n + 1)}\n\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    independent_set = find_independent_set(graph)\n    cycle = find_cycle(graph, 1)\n\n    if len(cycle) >= sqrt(n):\n        return f\"2\\n{len(cycle)}\\n{' '.join(map(str, cycle))}\"\n    else:\n        independent_set = sorted(independent_set, key=lambda x: -x)\n        independent_set = independent_set[:ceil(sqrt(n))]\n        return f\"1\\n{' '.join(map(str, independent_set))}\"",
        "test": "",
        "num_ids": 535,
        "indeed": false
    },
    {
        "number": 1260,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_product(arr: List[int]) -> int:\n        max_product = float('-inf')\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                max_product = max(max_product, arr[i] * arr[j])\n        return max_product\n\n    def get_max_product_indexes(arr: List[int]) -> Tuple[int, int]:\n        max_product = float('-inf')\n        max_product_indexes = None\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] * arr[j] > max_product:\n                    max_product = arr[i] * arr[j]\n                    max_product_indexes = (i, j)\n        return max_product_indexes\n\n    def remove_element(arr: List[int], index: int) -> List[int]:\n        return arr[:index] + arr[index + 1:]\n\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    max_product = get_max_product(arr)\n    max_product_indexes = get_max_product_indexes(arr)\n\n    operations = []\n    for i in range(n - 1):\n        if max_product_indexes[0] == max_product_indexes[1]:\n            operations.append(f\"2 {max_product_indexes[0] + 1}\")\n            arr = remove_element(arr, max_product_indexes[0])\n        else:\n            operations.append(f\"1 {max_product_indexes[0] + 1} {max_product_indexes[1] + 1}\")\n            arr[max_product_indexes[1]] = arr[max_product_indexes[0] + 1] * arr[max_product_indexes[1] + 1]\n            arr = remove_element(arr, max_product_indexes[0])\n\n        max_product = get_max_product(arr)\n        max_product_indexes = get_max_product_indexes(arr)\n\n    return \"\\n\".join(operations)",
        "test": "",
        "num_ids": 558,
        "indeed": false
    },
    {
        "number": 1261,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = list(range(1, n + 1))\n    result = []\n\n    while sequence:\n        gcd = sequence[0]\n        for i in range(1, len(sequence)):\n            gcd = math.gcd(gcd, sequence[i])\n        result.append(gcd)\n        sequence.pop()\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 106,
        "indeed": false
    },
    {
        "number": 1262,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(x[a] - x[b]) + abs(y[a] - y[b])\n\n    def find_set(u):\n        if parent[u] == u:\n            return u\n        parent[u] = find_set(parent[u])\n        return parent[u]\n\n    def union(u, v):\n        u = find_set(u)\n        v = find_set(v)\n        if u == v:\n            return False\n        parent[v] = u\n        return True\n\n    def kruskal(n, edges):\n        edges.sort(key=lambda e: e[2])\n        mst = []\n        for e in edges:\n            if union(e[0], e[1]):\n                mst.append(e)\n                if len(mst) == n - 1:\n                    break\n        return mst\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    x = [0] * n\n    y = [0] * n\n    c = [0] * n\n    k = [0] * n\n\n    for i in range(n):\n        x[i], y[i] = map(int, lines[i + 1].split())\n    c = list(map(int, lines[n + 1].split()))\n    k = list(map(int, lines[n + 2].split()))\n\n    edges = [(i, j, distance(i, j) + k[i] + k[j]) for i in range(n) for j in range(i + 1, n)]\n    mst = kruskal(n, edges)\n\n    parent = list(range(n))\n    for e in mst:\n        union(e[0], e[1])\n\n    power_stations = [i for i in range(n) if find_set(i) == i]\n    power_station_cost = sum(c[i] for i in power_stations)\n\n    connections = [(e[0], e[1]) for e in mst if find_set(e[0]) != find_set(e[1])]\n    connection_cost = sum(k[i] + k[j] for i, j in connections)\n\n    total_cost = power_station_cost + connection_cost\n    return f\"{total_cost}\\n{len(power_stations)}\\n{' '.join(map(str, power_stations))}\\n{len(connections)}\\n{' '.join(f'{i} {j}' for i, j in connections)}\\n\"",
        "test": "",
        "num_ids": 630,
        "indeed": false
    },
    {
        "number": 1263,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    b = list(map(int, stdin.split()[2 + n:2 + 2 * n]))\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    i, j = 0, 0\n    total_taste = 0\n    total_calories = 0\n\n    while i < n and j < n:\n        if (total_taste + a[i]) * k >= (total_calories + b[j]) * (n - i):\n            total_taste += a[i]\n            total_calories += b[j]\n            i += 1\n            j += 1\n        elif (total_taste + a[i]) * k < (total_calories + b[j]) * (n - i):\n            total_taste += a[i]\n            i += 1\n        else:\n            total_calories += b[j]\n            j += 1\n\n        if total_taste * k == total_calories:\n            return str(total_taste)\n\n    return str(-1)",
        "test": "",
        "num_ids": 303,
        "indeed": false
    },
    {
        "number": 1264,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a))\n\n    # Calculate the number of ones before and after each index\n    ones_before = [0] * (n + 1)\n    ones_after = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        ones_before[i] = ones_before[i - 1] + a[i - 1]\n        ones_after[i] = ones_after[i - 1] + (1 - a[n - i])\n\n    # Calculate the maximum number of ones that can be obtained after exactly one move\n    max_ones = 0\n    for i in range(1, n):\n        for j in range(i, n + 1):\n            max_ones = max(max_ones, ones_before[i - 1] + ones_after[j])\n\n    return str(max_ones)",
        "test": "",
        "num_ids": 234,
        "indeed": false
    },
    {
        "number": 1265,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    n = len(a)\n    m = len(b)\n\n    if n != m:\n        return \"NO\"\n\n    for i in range(n):\n        if a[i] != b[i]:\n            if a[i] == '0' and b[i] == '1':\n                if i == 0 or a[i - 1] == b[i - 1]:\n                    return \"NO\"\n            else:\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 1266,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x1, y1, x2, y2, piece):\n        if piece == \"R\":\n            return x1 == x2 or y1 == y2\n        elif piece == \"B\":\n            return abs(x1 - x2) == abs(y1 - y2)\n        elif piece == \"Q\":\n            return is_valid_move(x1, y1, x2, y2, \"B\") or is_valid_move(x1, y1, x2, y2, \"R\")\n        return False\n\n    def is_in_check(x_king, y_king, black_pieces):\n        for piece, x, y in black_pieces:\n            if is_valid_move(x, y, x_king, y_king, piece):\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    x_king, y_king = map(int, stdin.readline().strip().split())\n    black_pieces = [tuple(stdin.readline().strip().split()) for _ in range(n)]\n\n    if is_in_check(x_king, y_king, black_pieces):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 1267,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    scores = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Remove participants with zero score\n    scores = [score for score in scores if score != 0]\n\n    # Sort the scores in descending order\n    scores.sort(reverse=True)\n\n    # Initialize the number of ways to choose a subset of participants\n    num_ways = 0\n\n    # Iterate through the scores\n    for i in range(len(scores)):\n        # If the current score is less than the previous score, break the loop\n        if i > 0 and scores[i] < scores[i - 1]:\n            break\n\n        # Update the number of ways\n        num_ways += 1\n\n    return str(num_ways)",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 1268,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_volume = sum(a)\n    max_capacity = max(b)\n\n    if total_volume <= max_capacity:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 1269,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n\n    MOD = 998244353\n\n    def count_ways(n, m, c):\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for k in range(1, j + 1):\n                    dp[i][j] += dp[i - 1][k - 1] * dp[i - 1][j - k]\n                    dp[i][j] %= MOD\n\n        return dp[m][n]\n\n    return str(count_ways(n, m, c))",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 1270,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_primes(n, primes):\n        if n == 0:\n            return primes\n        for i in range(len(primes), 0, -1):\n            if primes[i - 1] <= n and is_prime(n - primes[i - 1]):\n                return find_primes(n - primes[i - 1], primes[:i] + [n - primes[i - 1]])\n        return []\n\n    n = int(stdin.strip())\n    primes = [2]\n    k = 0\n    while n > 1:\n        for i in range(len(primes)):\n            if n % primes[i] == 0:\n                n //= primes[i]\n                k += 1\n                break\n        else:\n            primes.append(n)\n            k += 1\n            n //= primes[-1]\n\n    return f\"{k}\\n{' '.join(map(str, find_primes(n, primes)))}\"",
        "test": "",
        "num_ids": 312,
        "indeed": false
    },
    {
        "number": 1271,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split('\\n')[0].split())\n    r = list(map(int, stdin.split('\\n')[1].split()))\n    c = stdin.split('\\n')[2]\n\n    seconds = 0\n    last_color = ''\n    last_candies = 0\n    current_candies = 0\n\n    for i in range(s - 1, -1, -1):\n        if c[i] != last_color and r[i] > current_candies:\n            last_color = c[i]\n            last_candies = current_candies\n            current_candies = r[i]\n            seconds += 1\n        else:\n            return '-1'\n\n    for i in range(s, n):\n        if c[i] != last_color and r[i] > current_candies and r[i] > last_candies:\n            last_color = c[i]\n            last_candies = current_candies\n            current_candies = r[i]\n            seconds += 1\n        else:\n            return '-1'\n\n    total_candies = sum(r[i] for i in range(s, n) if c[i] != last_color)\n    total_candies += sum(r[i] for i in range(s - 1, -1, -1) if c[i] != last_color)\n\n    if total_candies < k:\n        return '-1'\n\n    return str(seconds)",
        "test": "",
        "num_ids": 382,
        "indeed": false
    },
    {
        "number": 1272,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    islands = [set() for _ in range(N + 1)]\n    inconvenience = [0] * (M + 1)\n\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        islands[A].add(B)\n        islands[B].add(A)\n\n    for i in range(1, M + 1):\n        A, B = map(int, stdin.readline().split())\n        islands[A].remove(B)\n        islands[B].remove(A)\n\n        for j in range(1, A):\n            inconvenience[i] += int(len(islands[j] & islands[A]) == 0)\n        for j in range(A + 1, B):\n            inconvenience[i] += int(len(islands[B] & islands[j]) == 0)\n        for j in range(B + 1, N + 1):\n            inconvenience[i] += int(len(islands[j] & islands[B]) == 0)\n\n    return inconvenience[1:] ",
        "test": "",
        "num_ids": 288,
        "indeed": false
    },
    {
        "number": 1273,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        N = int(input())\n        edges = []\n        for _ in range(N - 1):\n            a, b = map(int, input().split())\n            edges.append((a, b))\n        return N, edges\n\n    def color_tree(N: int, edges: list) -> tuple:\n        parent = [-1] * (N + 1)\n        color = [0] * (N + 1)\n        used_colors = [False] * N\n\n        for u, v in edges:\n            parent[v] = u\n\n        for v in range(2, N + 1):\n            u = parent[v]\n            for c in range(1, N):\n                if not used_colors[c]:\n                    if color[u] != c:\n                        color[v] = c\n                        used_colors[c] = True\n                        break\n\n        return color[1:], used_colors.count(True)\n\n    N, edges = read_input()\n    colors, min_colors = color_tree(N, edges)\n\n    output = [str(min_colors)]\n    for c in colors:\n        output.append(str(c))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 1274,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    N, M = map(int, stdin.readline().split())\n    jobs = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    jobs.sort(key=lambda x: x[0])\n\n    dp = [0] * (M + 1)\n    for i in range(N):\n        a, b = jobs[i]\n        idx = binary_search(dp, a)\n        dp[idx] = max(dp[idx], dp[idx - a] + b)\n\n    return dp[-1]",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 1275,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for a in range(1, N + 1):\n        for b in range(1, N + 1):\n            for c in range(1, N + 1):\n                d = K + a + b - c\n                if 1 <= d <= N:\n                    count += 1\n    return str(count)",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1276,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    count = 0\n\n    for i in range(N - 2):\n        for j in range(i + 1, N - 1):\n            if S[i] != S[j]:\n                for k in range(j + 1, N):\n                    if S[i] != S[k] and S[j] != S[k] and k - j != j - i:\n                        count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 1277,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, u, v, *edges = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n\n    for i in range(N - 1):\n        A, B = edges[i]\n        graph[A].append(B)\n        graph[B].append(A)\n\n    depth_u = dfs(graph, u)\n    depth_v = dfs(graph, v)\n\n    if depth_u > depth_v:\n        return str(depth_u - depth_v - 1)\n    else:\n        return str(depth_v - depth_u - 1)\n\ndef",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 1278,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    for i in range(x, n - y + 1):\n        is_not_so_rainy = True\n        for j in range(i - x, i):\n            if a[i] >= a[j]:\n                is_not_so_rainy = False\n                break\n        if is_not_so_rainy:\n            for j in range(i + 1, i + y + 1):\n                if j <= n and a[i] >= a[j]:\n                    is_not_so_rainy = False\n                    break\n        if is_not_so_rainy:\n            return str(i)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1279,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    chests = list(map(int, stdin.readline().split()))\n    keys = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if (chests[i] + keys[j]) % 2 == 1:\n                count += 1\n                chests[i] = -1\n                keys[j] = -1\n                break\n\n    return str(count)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1280,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, good_chars, k = stdin.split('\\n')\n    good_chars = [int(x) for x in good_chars]\n    k = int(k)\n\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        for j in range(k + 1):\n            if good_chars[ord(s[i]) - ord('a')]:\n                dp[i + 1][j] = dp[i][j] + dp[i][j + 1]\n            else:\n                dp[i + 1][j] = dp[i][j]\n\n    return str(dp[n][k])",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 1281,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def xor_segments(a: List[int]) -> int:\n        xor_sum = 0\n        for i in range(n - 1):\n            xor_sum += a[i] ^ a[i + 1]\n        return xor_sum\n\n    def count_ones(x: int) -> int:\n        count = 0\n        while x:\n            count += x & 1\n            x >>= 1\n        return count\n\n    max_segments = 0\n    for i in range(n):\n        a[i] ^= (1 << k) - 1\n        max_segments = max(max_segments, count_ones(xor_segments(a)))\n        a[i] ^= (1 << k) - 1\n\n    return str(max_segments)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 1282,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    boys = [i for i in range(n) if stdin[i] == 'M']\n    girls = [i for i in range(n) if stdin[i] == 'F']\n\n    if not boys or not girls:\n        return '0'\n\n    time = 0\n    while any(b < g for b, g in zip(boys, girls)):\n        boys = [i - 1 if i > 0 else n - 1 for i in boys]\n        girls = [i + 1 if i < n - 1 else 0 for i in girls]\n        time += 1\n\n    return str(time)",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 1283,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    field = [list(stdin.readline().strip()) for _ in range(n)]\n\n    max_count = 0\n    max_cell = (0, 0)\n\n    for i in range(n):\n        for j in range(n):\n            if field[i][j] == '.':\n                count = 0\n                for di in range(-k + 1, 1):\n                    for dj in range(-k + 1, 1):\n                        if di == 0 and dj == 0:\n                            continue\n                        if i + di >= 0 and i + di < n and j + dj >= 0 and j + dj < n:\n                            if all(field[i + di + ddi][j + dj + ddj] == '.' for ddi in range(k) for ddj in range(k)):\n                                count += 1\n                if count > max_count:\n                    max_count = count\n                    max_cell = (i, j)\n\n    return f\"{max_cell[0]+1} {max_cell[1]+1}\\n\"",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 1284,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a))\n    while n > 1:\n        max_sum = float('-inf')\n        max_index = -1\n        for i in range(1, n):\n            if a[i - 1] + a[i] > max_sum:\n                max_sum = a[i - 1] + a[i]\n                max_index = i\n        a[max_index - 1] = max_sum\n        a.pop(max_index)\n        n -= 1\n    return str(a[0])",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1285,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    matrix = []\n    for _ in range(n):\n        row = stdin.readline().strip()\n        binary_row = bin(int(row, 16))[2:].zfill(4 * n)\n        matrix.append(binary_row)\n\n    def is_compressible(x: int) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[i // x * x + j // x][i % x * n + j % x]:\n                    return False\n        return True\n\n    max_compressible_x = 1\n    for x in range(2, n + 1):\n        if n % x == 0 and is_compressible(x):\n            max_compressible_x = x\n\n    return str(max_compressible_x)",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 1286,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a = map(int, stdin.split())\n    n = 1\n    for i in range(k):\n        n *= a[i]\n\n    p = 1\n    q = n\n    for i in range(1, n + 1):\n        p *= (i - 1)\n        q *= (n - i + 1)\n\n    p %= 10**9 + 7\n    q %= 10**9 + 7\n\n    return f\"{p} {q}\"",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 1287,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_probability(matrix, n):\n        dp = [[0] * n for _ in range(2**n)]\n        for mask in range(2**n):\n            for i in range(n):\n                if mask & (1 << i):\n                    continue\n                new_mask = mask | (1 << i)\n                for j in range(n):\n                    if i == j or mask & (1 << j):\n                        continue\n                    dp[new_mask][i] += dp[mask][j] * matrix[j][i]\n        return dp\n\n    def get_winner_probability(matrix, n):\n        dp = get_probability(matrix, n)\n        probability = 0\n        for i in range(n):\n            probability += dp[-1][i] * matrix[i][0]\n        return probability\n\n    n = int(stdin.readline())\n    matrix = [[float(x) for x in stdin.readline().split()] for _ in range(n)]\n\n    probability = get_winner_probability(matrix, n)\n    return f\"{probability:.9f}\"",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 1288,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    a.sort()\n\n    if k % 2 == 0:\n        return str(a[k // 2 - 1])\n    else:\n        return str(a[k // 2])\n\n    # Read input\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Sort the array\n    a.sort()\n\n    # If k is even, the minimum cost is the k-th smallest element\n    if k % 2 == 0:\n        return str(a[k // 2 - 1])\n    # If k is odd, the minimum cost is the k-th smallest element\n    else:\n        return str(a[k // 2])",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 1289,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a = a.split()\n    b = b.split()\n\n    stops = {}\n    for i in range(n):\n        stops[int(a[i])] = i + 1\n\n    visited_stops = []\n    for stop in b:\n        visited_stops.append(stops[int(stop)])\n\n    length = 0\n    for i in range(1, len(visited_stops), 2):\n        length += abs(visited_stops[i] - visited_stops[i - 1])\n\n    return str(length)",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1290,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    columns = list(map(int, stdin.split()[2:]))\n    counts = [0] * n\n    points = 0\n\n    for i in range(m):\n        col = columns[i] - 1\n        counts[col] += 1\n        if all(counts):\n            points += 1\n            counts = [count - 1 for count in counts]\n            counts = [0 if count < 0 else count for count in counts]\n\n    return str(points)",
        "test": "",
        "num_ids": 139,
        "indeed": true
    },
    {
        "number": 1291,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    misha_points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    sasha_points = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def is_inside_circle(points, center):\n        for point in points:\n            if (point[0] - center[0]) ** 2 + (point[1] - center[1]) ** 2 > 2 * (10 ** 4):\n                return False\n        return True\n\n    for point in misha_points:\n        if is_inside_circle(sasha_points, point):\n            return \"YES\"\n\n    for point in sasha_points:\n        if is_inside_circle(misha_points, point):\n            return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 1292,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, visited, grid):\n        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and not visited[x][y] and grid[x][y] != \"#\":\n            return True\n        return False\n\n    def dfs(x, y, player, visited, grid, speed):\n        if not is_valid(x, y, visited, grid):\n            return 0\n\n        visited[x][y] = True\n        count = 1\n\n        for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny, visited, grid) and (nx, ny) not in player.castles:\n                player.castles.add((nx, ny))\n                count += dfs(nx, ny, player, visited, grid, speed)\n\n        return count\n\n    def play_game(grid, speeds):\n        players = [Player(i, speed) for i, speed in enumerate(speeds, 1)]\n        result = [0] * len(players)\n\n        for player in players:\n            visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n            for x, y in player.castles:\n                result[player.id - 1] += dfs(x, y, player, visited, grid, player.speed)\n\n        return result\n\n    class Player:\n        def __init__(self, id, speed):\n            self.id = id\n            self.speed = speed\n            self.castles = set()\n\n    n, m, p = map(int, stdin.readline().split())\n    speeds = list(map(int, stdin.readline().split()))\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n    result = play_game(grid, speeds)\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 497,
        "indeed": false
    },
    {
        "number": 1293,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    a = [0] * n\n    steps = 0\n\n    for i in range(n):\n        if a[i] != b[i]:\n            steps += abs(a[i] - b[i])\n            a[i] = b[i]\n\n    return str(steps)",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 1294,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        buttons = [0] * 26\n        for i in range(len(s)):\n            c = s[i]\n            index = ord(c) - ord('a')\n            buttons[index] += 1\n            if buttons[index] % 2 == 1:\n                for j in range(i + 1, len(s)):\n                    if s[j] == c:\n                        buttons[index] += 1\n                        break\n        for i in range(26):\n            if buttons[i] % 2 == 0:\n                result.append(chr(i + ord('a')))\n        result.sort()\n        res = ''.join(result)\n        print(res)\n        result.clear()",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1295,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a.append(float('inf'))\n    b.append(float('inf'))\n\n    i = j = 0\n    r = 0\n\n    while i < n:\n        while b[j] - a[i] <= r:\n            j += 1\n        r = max(r, b[j - 1] - a[i])\n        i += 1\n\n    return str(r)",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 1296,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n\n    k = 0\n    T = 0\n\n    for i in range(n):\n        if a[i] + i * k <= S:\n            k += 1\n            T += a[i] + i * k\n        else:\n            break\n\n    return f\"{k} {T}\"",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1297,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    insertions = 0\n\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            insertions += 1\n        if i < n - 1 and s[i] == s[i + 1]:\n            insertions += 1\n\n    return str(insertions)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1298,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    string = stdin.readline().strip()\n\n    while True:\n        new_string = \"\"\n        i = 0\n        while i < len(string) - 1:\n            if string[i] != string[i + 1]:\n                new_string += string[i]\n                i += 1\n            else:\n                i += 2\n        if i == len(string) - 1:\n            new_string += string[i]\n\n        if len(new_string) == len(string):\n            break\n        else:\n            string = new_string\n\n    return len(string)",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1299,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    x.sort()\n    total_absurdity = [0] * (n + 1)\n    for i in range(n):\n        total_absurdity[i + 1] = total_absurdity[i] + x[i]\n    min_absurdity = float('inf')\n    a = -1\n    b = -1\n    for i in range(n - 2 * k + 1):\n        for j in range(i + k, n - k + 1):\n            absurdity = total_absurdity[i + k] - total_absurdity[i] + total_absurdity[j + k] - total_absurdity[j]\n            if absurdity < min_absurdity:\n                min_absurdity = absurdity\n                a = i + 1\n                b = j\n    return f\"{a} {b}\"",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 1300,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    max_count = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            for k in range(-c, c + 1):\n                count = 0\n                for i in range(l, r + 1):\n                    if a[i - 1] + k == c:\n                        count += 1\n                max_count = max(max_count, count)\n\n    return str(max_count)",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 1301,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pattern = stdin.readline().strip()\n\n    pokemons = [\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]\n    matches = []\n\n    for pokemon in pokemons:\n        if len(pokemon) == n:\n            match = True\n            for i in range(n):\n                if pattern[i] != \".\":\n                    if pattern[i] != pokemon[i]:\n                        match = False\n                        break\n            if match:\n                matches.append(pokemon)\n\n    return matches[0]",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 1302,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = []\n    for i in range(1, n + 1):\n        if len(p) == k:\n            break\n        if i % n == 0:\n            continue\n        if n % i == 0:\n            p.append(i)\n    if len(p) == k:\n        return \" \".join(map(str, p))\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 1303,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q, l, r = map(int, stdin.split()[:4])\n    a = [list(map(int, stdin.split()[4 + 2 * i:6 + 2 * i])) for i in range(p)]\n    c = [list(map(int, stdin.split()[4 + 2 * p + 2 * i:6 + 2 * p + 2 * i])) for i in range(q)]\n\n    def is_online(t: int) -> bool:\n        for i in range(p):\n            if a[i][0] <= t % (a[i][1] - a[i][0]) + a[i][0] <= a[i][1]:\n                return True\n        return False\n\n    def shifted_is_online(t: int) -> bool:\n        for i in range(q):\n            if c[i][0] + t <= r and d[i][1] + t >= l and c[i][0] + t <= d[i][1] + t <= c[i][1] + t:\n                return True\n        return False\n\n    count = 0\n    for t in range(l, r + 1):\n        if is_online(t) and shifted_is_online(t):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 1304,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_field(x, y):\n        for i in range(3):\n            for j in range(3):\n                if i * 3 <= x <= i * 3 + 2 and j * 3 <= y <= j * 3 + 2:\n                    return i, j\n        return None, None\n\n    def find_empty_cells(field_x, field_y):\n        for i in range(3):\n            for j in range(3):\n                if board[field_x * 3 + i][field_y * 3 + j] == \".\":\n                    yield field_x * 3 + i, field_y * 3 + j\n\n    board = [list(line.strip()) for line in stdin.split(\"\\n\")[:9]]\n    x, y = map(int, stdin.split(\"\\n\")[-1].split())\n\n    field_x, field_y = find_field(x, y)\n    if field_x is not None and field_y is not None:\n        empty_cells = list(find_empty_cells(field_x, field_y))\n        if empty_cells:\n            for i, j in empty_cells:\n                board[i][j] = \"!\"\n        else:\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        board[i][j] = \"!\"\n    else:\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == \".\":\n                    board[i][j] = \"!\"\n\n    return \"\\n\".join(\"\".join(row) for row in board)",
        "test": "",
        "num_ids": 410,
        "indeed": false
    },
    {
        "number": 1305,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bills = list(map(int, stdin.split('\\n')[1].split()))\n    total_bills = sum(bills)\n    if total_bills % 25 != 0:\n        return \"NO\"\n    change = total_bills % 25\n    required_change = n * 25\n    if change >= required_change:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1306,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    if a.count(h) == n:\n        return 1\n\n    a.sort()\n    left, right = 0, n - 1\n    count = 0\n\n    while left <= right:\n        if a[left] < h:\n            count += a[left]\n            left += 1\n        elif a[right] > h:\n            count += a[right]\n            right -= 1\n        else:\n            break\n\n    return str(count % mod)\n",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1307,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"Ehab\"\n    elif n % 2 == 0:\n        return \"Mahmoud\"\n    else:\n        return \"Ehab\"",
        "test": "",
        "num_ids": 58,
        "indeed": true
    },
    {
        "number": 1308,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def is_isomorphic(x: int, y: int, len_: int) -> bool:\n        if len_ == 1:\n            return True\n\n        s_set = set(s[x:x + len_])\n        t_set = set(s[y:y + len_])\n\n        if len(s_set) != len(t_set):\n            return False\n\n        mapping = {}\n        for i in range(len_):\n            if s[x + i] not in mapping:\n                mapping[s[x + i]] = s[y + i]\n            elif mapping[s[x + i]] != s[y + i]:\n                return False\n\n        return True\n\n    result = []\n    for _ in range(m):\n        x, y, len_ = map(int, stdin.readline().split())\n        if is_isomorphic(x - 1, y - 1, len_):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 1309,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    weights = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    weights.sort()\n\n    tandem_kayaks = [abs(weights[2 * i] - weights[2 * i + 1]) for i in range(n - 1)]\n    single_kayaks = [0] * 2\n\n    total_instability = sum(tandem_kayaks) + sum(single_kayaks)\n\n    return str(total_instability)",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 1310,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    max_xor = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            segment_xor = 0\n            for k in range(i, j + 1):\n                segment_xor ^= arr[k]\n            max_xor = max(max_xor, segment_xor)\n\n    return str(max_xor)",
        "test": "",
        "num_ids": 132,
        "indeed": true
    },
    {
        "number": 1311,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_clique(points):\n        points.sort(key=lambda x: x[0])\n        max_clique = []\n        for i in range(len(points)):\n            clique = [points[i]]\n            j = i + 1\n            while j < len(points) and points[j][0] - points[i][0] >= points[i][1] + points[j][1]:\n                clique.append(points[j])\n                j += 1\n            max_clique.append(clique)\n        return max_clique\n\n    def max_clique_size(max_clique):\n        max_size = 0\n        for clique in max_clique:\n            max_size = max(max_size, len(clique))\n        return max_size\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, w = map(int, stdin.readline().strip().split())\n        points.append((x, w))\n\n    max_clique = find_max_clique(points)\n    max_size = max_clique_size(max_clique)\n\n    return str(max_size)",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 1312,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    min_diff = n\n    result = []\n\n    for i in range(1, m + 1):\n        if n % i == 0:\n            a_i = n // i\n            diff = a_i - result[0] if result else 0\n            if diff < min_diff:\n                min_diff = diff\n                result = [a_i] * i\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1313,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n1, n2, k1, k2 = map(int, stdin.split())\n\n    if n1 > n2:\n        return \"First\"\n    elif n1 < n2:\n        return \"Second\"\n    else:\n        if k1 > k2:\n            return \"First\"\n        elif k1 < k2:\n            return \"Second\"\n        else:\n            return \"First\"",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1314,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_treasure(obelisks, clues):\n        for p in permutations(range(len(obelisks))):\n            treasure = None\n            for i in range(len(obelisks)):\n                x, y = obelisks[p[i]]\n                a, b = clues[i]\n                t = (x + a, y + b)\n                if treasure is None:\n                    treasure = t\n                elif treasure != t:\n                    break\n            else:\n                return treasure\n        return None\n\n    n = int(stdin.readline().strip())\n    obelisks = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    clues = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    treasure = find_treasure(obelisks, clues)\n    if treasure is None:\n        return \"No solution\"\n    else:\n        return \"{} {}\".format(*treasure)",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 1315,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    money = list(map(int, stdin.split('\\n')[1].split()))\n    money.sort(reverse=True)\n\n    for i in range(n - 1):\n        if money[i] < money[i + 1]:\n            money[i], money[i + 1] = money[i + 1], money[i]\n            money[i + 1] -= 1\n\n    if money != sorted(money, reverse=True):\n        return \":\" + \"(\"\n    else:\n        return \" \".join(map(str, money))",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 1316,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def is_valid(start: int, length: int, char: str) -> bool:\n        for i in range(start, start + length):\n            if s[i] != char:\n                return False\n        return True\n\n    def helper(start: int, k: int, level: int) -> int:\n        if k == 0:\n            return level\n\n        max_level = 0\n        for i in range(start, n - k + 1):\n            char = s[i]\n            if is_valid(i, k, char):\n                max_level = max(max_level, helper(i + k, k - 1, level + 1))\n        return max_level\n\n    return str(helper(0, k, 0))",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1317,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i ** 2 + j ** 2) % m == 0:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 1318,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_table(c, p, tables):\n        for i, table in enumerate(tables, start=1):\n            if table >= c:\n                return i, table - c\n        return None, None\n\n    def accept_requests(requests, tables):\n        accepted_requests = []\n        total_money = 0\n        for i, (c, p) in enumerate(requests, start=1):\n            table_number, new_table = find_table(c, p, tables)\n            if table_number:\n                accepted_requests.append((i, table_number))\n                total_money += p\n                tables[table_number - 1] = new_table\n        return accepted_requests, total_money\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    requests = [(int(c), int(p)) for c, p in [line.split() for line in lines[1:n + 1]]]\n    k = int(lines[n + 1])\n    tables = [int(r) for r in lines[-1].split()]\n\n    accepted_requests, total_money = accept_requests(requests, tables)\n    output = [str(len(accepted_requests)), str(total_money)]\n    output.extend([' '.join(map(str, ar)) for ar in accepted_requests])\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 335,
        "indeed": false
    },
    {
        "number": 1319,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    n = 1\n    for i in p:\n        n *= i\n    divisors = [1]\n    for i in range(2, n):\n        if n % i == 0:\n            divisors.append(i)\n    product = 1\n    for i in divisors:\n        product *= i\n    return str(product % (10**9 + 7))",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 1320,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    cake = []\n    for i in range(n):\n        cake.append(list(stdin.readline().strip()))\n\n    happiness = 0\n    for i in range(n):\n        for j in range(n):\n            if cake[i][j] == 'C':\n                for k in range(n):\n                    if k != j and cake[i][k] == 'C':\n                        happiness += 1\n                for k in range(n):\n                    if k != i and cake[k][j] == 'C':\n                        happiness += 1\n\n    return str(happiness)",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 1321,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    friends = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    widths = [friend[0] for friend in friends]\n    heights = [friend[1] for friend in friends]\n    max_height = max(heights)\n    total_width = sum(widths)\n    min_size = max_height * total_width\n    return ' '.join(str(min_size - (max_height * widths[i])) for i in range(n))",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 1322,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    total_states = 0\n    for i in range(1, n + 1):\n        total_states += 2 ** (i * 2)\n    return str(total_states % (10**9 + 7))",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 1323,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_rows = sum(a) + sum(b)\n    min_operations = total_rows - min(sum(a), sum(b))\n\n    return str(min_operations)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 1324,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, a_4 = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    calories = 0\n    for i, strip in enumerate(s):\n        if strip == str(i + 1):\n            calories += [a_1, a_2, a_3, a_4][i]\n\n    return str(calories)",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1325,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    def next_char(c: str) -> str:\n        return chr((ord(c) - ord('a') + 1) % 26 + ord('a'))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def min_moves(s: str, p: int) -> int:\n        left, right = 0, len(s) - 1\n        moves = 0\n\n        while left < right:\n            if left < p <= right:\n                if s[left] != s[right]:\n                    moves += 2\n                left += 1\n                right -= 1\n            elif p <= left:\n                left += 1\n            else:\n                right -= 1\n\n        return moves\n\n    return min_moves(s, p - 1)",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 1326,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    divisors_count = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors_count[j] += 1\n    return str(sum(i * divisors_count[i] for i in range(1, n + 1)))",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1327,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    cakes = []\n    for _ in range(N):\n        x, y, z = map(int, stdin.readline().split())\n        cakes.append((x, y, z))\n\n    def calculate_score(selected_cakes):\n        total_beauty = total_tastiness = total_popularity = 0\n        for cake in selected_cakes:\n            total_beauty += cake[0]\n            total_tastiness += cake[1]\n            total_popularity += cake[2]\n        return abs(total_beauty) + abs(total_tastiness) + abs(total_popularity)\n\n    max_score = 0\n    for i in range(2 ** N):\n        selected_cakes = []\n        for j in range(N):\n            if i & (1 << j):\n                selected_cakes.append(cakes[j])\n        if len(selected_cakes) == M:\n            score = calculate_score(selected_cakes)\n            max_score = max(max_score, score)\n\n    return str(max_score)",
        "test": "",
        "num_ids": 292,
        "indeed": false
    },
    {
        "number": 1328,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M_a, M_b = map(int, lines[0].split())\n    packages = []\n    for i in range(1, N + 1):\n        a_i, b_i, c_i = map(int, lines[i].split())\n        packages.append((a_i, b_i, c_i))\n\n    packages.sort(key=lambda x: x[2])\n\n    min_price = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            a_i, b_i, c_i = packages[i]\n            a_j, b_j, c_j = packages[j]\n            total_a = a_i + a_j\n            total_b = b_i + b_j\n            if total_a % M_a == 0 and total_b % M_b == 0:\n                price = c_i + c_j\n                if price < min_price:\n                    min_price = price\n\n    return str(min_price) if min_price != float('inf') else '-1'",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1329,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    divisors = [1] * (n + 1)\n    for i in range(2, n + 1):\n        j = i\n        while j <= n:\n            divisors[j] *= i\n            j += i\n    shichi_go_count = 0\n    for i in range(1, n + 1):\n        divisor_count = 0\n        for j in range(1, n + 1):\n            if divisors[j] % i == 0:\n                divisor_count += 1\n        if divisor_count == 75:\n            shichi_go_count += 1\n    return str(shichi_go_count)",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 1330,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mex(s):\n        mx = max(s)\n        return next(i for i in range(mx + 1) if i not in s)\n\n    def update_clubs(clubs, student, day):\n        clubs[student[1]].remove(student[0])\n        if day == d:\n            return\n        if student[0] + 1 <= len(k) and k[student[0]] == day + 1:\n            update_clubs(clubs, (student[0] + 1, student[1]), day + 1)\n\n    def calculate_strength(clubs):\n        strength = []\n        for club in clubs:\n            if len(club) == 0:\n                strength.append(0)\n            else:\n                strength.append(mex(club))\n        return strength\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    p = list(map(int, lines[1].split()))\n    c = list(map(int, lines[2].split()))\n    d = int(lines[3])\n    k = list(map(int, lines[4].split()))\n\n    clubs = [[] for _ in range(m + 1)]\n    for i in range(n):\n        clubs[c[i]].append(p[i])\n\n    for i in range(d):\n        update_clubs(clubs, (1, c[0]), 0)\n\n    strength = calculate_strength(clubs[:m])\n    return '\\n'.join(map(str, strength))",
        "test": "",
        "num_ids": 384,
        "indeed": false
    },
    {
        "number": 1331,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    a = sorted(map(int, stdin.split()[1].split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] + m > 10**6:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 1332,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    coins = list(map(int, stdin.split()))\n    total_coins = sum(coins)\n    if total_coins % 5 != 0:\n        return \"-1\"\n    initial_bet = total_coins // 5\n    if initial_bet == 0:\n        return \"-1\"\n    for coin in coins:\n        if coin % initial_bet != 0:\n            return \"-1\"\n    return str(initial_bet)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1333,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    snake = []\n    for i in range(n):\n        if i % 2 == 0:\n            snake.append('#' * m)\n        else:\n            snake.append('.' * (m - 1) + '#')\n    return '\\n'.join(snake)",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1334,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    letters = sorted(set(s))\n    t = \"\"\n\n    for letter in letters:\n        if len(t) == k:\n            break\n        if letter not in t:\n            t += letter\n\n    return t\n",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1335,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = 0\n    interesting_solutions = 0\n    for i in range(n):\n        m += 1\n        for j in range(a[i]):\n            if j % k == 0:\n                caption = round(100 * m / n)\n                if caption == j + 1:\n                    interesting_solutions += 1\n    return str(interesting_solutions)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1336,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_nested(a: int, b: int) -> bool:\n        return out[a] <= in_[b]\n\n    def find_min_extra_space(start: int, end: int) -> int:\n        if start == end:\n            return 0\n        min_extra_space = float('inf')\n        for i in range(start, end):\n            if is_nested(i, end):\n                extra_space = find_min_extra_space(start, i) + find_min_extra_space(i + 1, end)\n                min_extra_space = min(min_extra_space, extra_space)\n        return min_extra_space\n\n    def count_big_enough_subsets(start: int, end: int) -> int:\n        if start == end:\n            return 1\n        count = 0\n        for i in range(start, end):\n            if is_nested(i, end):\n                count += count_big_enough_subsets(start, i) * count_big_enough_subsets(i + 1, end)\n        return count\n\n    n = int(stdin.readline().strip())\n    out = []\n    in_ = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        out.append(a)\n        in_.append(b)\n\n    min_extra_space = find_min_extra_space(0, n - 1)\n    count = count_big_enough_subsets(0, n - 1)\n    result = count * min_extra_space\n    return str(result % (10**9 + 7))",
        "test": "",
        "num_ids": 411,
        "indeed": false
    },
    {
        "number": 1337,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b, c = map(lambda x: list(map(int, x.split())), stdin.split('\\n')[1:])\n    max_very_pleased = max_almost_satisfied = -1\n    movie_index = -1\n\n    for i in range(m):\n        very_pleased = almost_satisfied = 0\n        for j in range(n):\n            if a[j] == b[i] or a[j] == c[i]:\n                if a[j] == b[i]:\n                    very_pleased += 1\n                else:\n                    almost_satisfied += 1\n\n        if very_pleased > max_very_pleased:\n            max_very_pleased = very_pleased\n            max_almost_satisfied = almost_satisfied\n            movie_index = i + 1\n        elif very_pleased == max_very_pleased:\n            if almost_satisfied > max_almost_satisfied:\n                max_almost_satisfied = almost_satisfied\n                movie_index = i + 1\n\n    return str(movie_index)",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 1338,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def f(p: List[int]) -> int:\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                total += min(p[i:j + 1])\n        return total\n\n    def next_permutation(p: List[int]) -> List[int]:\n        i = n - 2\n        while i >= 0 and p[i] >= p[i + 1]:\n            i -= 1\n        if i < 0:\n            return None\n        j = n - 1\n        while p[j] <= p[i]:\n            j -= 1\n        p[i], p[j] = p[j], p[i]\n        p[i + 1:] = reversed(p[i + 1:])\n        return p\n\n    p = list(range(1, n + 1))\n    for _ in range(m - 1):\n        p = next_permutation(p)\n\n    return \" \".join(map(str, p))",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 1339,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        segments.append((l, r))\n\n    for i, (l, r) in enumerate(segments):\n        if all(l <= c1 <= d1 <= r for c1, d1 in segments):\n            return str(i + 1)\n    return \"-1\"",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1340,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    operations = 0\n    for i in range(n):\n        j = i\n        while j < n and colors[j] == colors[i]:\n            j += 1\n        operations += j - i - 1\n\n    return str(operations)",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1341,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    position = 1\n    for instruction in t:\n        if s[position - 1] == instruction:\n            position += 1\n    return str(position)",
        "test": "",
        "num_ids": 53,
        "indeed": true
    },
    {
        "number": 1342,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    min_sets = 1\n    for i in range(1, n):\n        if a[i] - a[i - 1] > 1:\n            min_sets += 1\n\n    return str(min_sets)",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 1343,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    if k > 0:\n        storages = list(map(int, stdin.readline().split()))\n    else:\n        storages = []\n\n    min_cost = float('inf')\n    for city in range(1, n + 1):\n        if city in storages:\n            continue\n        for storage in storages:\n            cost = sum(cost for u, v, cost in roads if city in (u, v) and storage in (u, v))\n            if cost < min_cost:\n                min_cost = cost\n\n    return str(min_cost if min_cost != float('inf') else -1)",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 1344,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 144,
        "indeed": true
    },
    {
        "number": 1345,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def dfs(i, s):\n        if i == n:\n            return s if 0 <= s <= a[0] else None\n        res = dfs(i + 1, s + a[i]) or dfs(i + 1, s - a[i])\n        if res is not None:\n            res.insert(i, '+')\n        return res\n\n    res = dfs(0, 0)\n    return ''.join(res)",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 1346,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    c = [0] * (n + m - 1)\n    for i in range(n):\n        for j in range(m):\n            c[i + j] += a[i] * b[j]\n\n    for i, coef in enumerate(c):\n        if coef % p != 0:\n            return str(i)\n\n    return \"0\"",
        "test": "",
        "num_ids": 157,
        "indeed": true
    },
    {
        "number": 1347,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, words, n, synonyms = parse_input(stdin)\n    essay = ' '.join(words)\n    min_r, min_length = float('inf'), float('inf')\n\n    for i in range(n):\n        x, y = synonyms[i]\n        if x in essay:\n            new_essay = essay.replace(x, y)\n            r_count = new_essay.lower().count('r')\n            length = len(new_essay)\n\n            if r_count < min_r or (r_count == min_r and length < min_length):\n                min_r = r_count\n                min_length = length\n\n    return f\"{min_r} {min_length}\"\n\ndef",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 1348,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    d = list(map(int, stdin.split()[1].split()))\n\n    if any(x == n for x in d):\n        return \"-1\\n\"\n\n    edges = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if d[i - 1] + d[j - 1] == d[i - 1] + d[j - 1]:\n                edges.append((i, j))\n\n    output = [str(len(edges))] + [\" \".join(map(str, edge)) for edge in edges]\n    return \"\\n\".join(output) + \"\\n\"",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 1349,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def water_garden(n, k, taps):\n        taps.sort()\n        left, right = 1, taps[0]\n        time = 0\n\n        for i in range(k):\n            time = max(time, taps[i] - left)\n            left = taps[i] - 1\n            right = taps[i] + 1\n\n        time = max(time, n - right)\n\n        return time\n\n    t = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().strip().split())\n        taps = list(map(int, stdin.readline().strip().split()))\n        output.append(water_garden(n, k, taps))\n\n    return \"\\n\".join(map(str, output))\n",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 1350,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    freq = [0] * k\n    for char in s:\n        freq[ord(char) - ord('A')] += 1\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            subseq_freq = [0] * k\n            for char in s[i:j + 1]:\n                subseq_freq[ord(char) - ord('A')] += 1\n            if subseq_freq == freq:\n                max_length = max(max_length, j - i + 1)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 1351,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    for x in range(l, r + 1):\n        digits = set(str(x))\n        if len(digits) == len(str(x)):\n            return str(x)\n    return \"-1\"",
        "test": "",
        "num_ids": 68,
        "indeed": true
    },
    {
        "number": 1352,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def f(l, r):\n        return sorted([x for x in a if x < l or x > r])\n\n    count = 0\n    for l in range(1, x + 1):\n        for r in range(l, x + 1):\n            if f(l, r) == [] or (len(f(l, r)) == 1 and f(l, r)[0] == l):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1353,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    min_cost = min(n * a, (n // m) * b + n % m * a)\n    return str(min_cost)",
        "test": "",
        "num_ids": 55,
        "indeed": false
    },
    {
        "number": 1354,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, m = map(int, stdin.split()[0].split())\n    bob_moves = list(map(int, stdin.split()[2].split()))\n\n    def can_place_ships(positions):\n        positions = sorted(positions)\n        for i in range(1, len(positions)):\n            if positions[i] - positions[i - 1] < a:\n                return False\n        return True\n\n    if k == 1:\n        for i in range(1, n):\n            if can_place_ships([bob_moves[0], bob_moves[0] + i]):\n                return str(i + 1)\n        return \"-1\"\n\n    for i in range(1, n - a + 1):\n        if can_place_ships([bob_moves[0], bob_moves[0] + i]):\n            return str(i + 1)\n    return \"-1\"",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 1355,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def dot_product(a, b):\n        return a[0] * b[0] + a[1] * b[1]\n\n    def vector_length(a):\n        return (a[0] ** 2 + a[1] ** 2) ** 0.5\n\n    def is_point_in_polygon(point, polygon):\n        n = len(polygon)\n        is_inside = False\n        for i in range(n):\n            a = polygon[i]\n            b = polygon[(i + 1) % n]\n            if (a[1] <= point[1] < b[1]) or (b[1] <= point[1] < a[1]):\n                if a[0] + (point[1] - a[1]) / (b[1] - a[1]) * (b[0] - a[0]) < point[0]:\n                    is_inside = not is_inside\n        return is_inside\n\n    def intersection_length(line, polygon):\n        intersection_length = 0\n        n = len(polygon)\n        for i in range(n):\n            a = polygon[i]\n            b = polygon[(i + 1) % n]\n            intersection = [0, 0]\n            if cross_product(b - a, line[1] - line[0]) != 0:\n                k = dot_product(line[1] - line[0], a - line[0]) / cross_product(b - a, line[1] - line[0])\n                intersection = line[0] + k * (line[1] - line[0])\n            if is_point_in_polygon(intersection, polygon):\n                if cross_product(b - a, intersection - a) > 0:\n                    intersection_length += vector_length(intersection - a)\n                elif cross_product(b - a, intersection - a) < 0:\n                    intersection_length += vector_length(b - intersection)\n        return intersection_length\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.readline().split())\n        polygon = [tuple(map(float, stdin.readline().split())) for _ in range(n)]\n        lines = [tuple(map(float, stdin.readline().split())) for _ in range(m)]\n\n        result = []\n        for line in lines:\n            result.append(intersection_length(line, polygon))\n\n        return '\\n'.join(f'{length:.15f}' for length in result)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 658,
        "indeed": false
    },
    {
        "number": 1356,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = s.count('a')\n    if count > n // 2:\n        return n\n    else:\n        return count * 2 - 1",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 1357,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    time = 0\n    current_house = 1\n    for i in range(m):\n        if a[i] == current_house:\n            continue\n        distance = abs(a[i] - current_house)\n        time += distance\n        current_house = a[i]\n    return str(time)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 1358,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.readline().split())\n    strings = []\n    for _ in range(k):\n        s, a = stdin.readline().split()\n        strings.append((s, int(a)))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def get_max_palindrome_beauty(strings: list) -> int:\n        max_beauty = 0\n        for i in range(k):\n            for j in range(i + 1, k):\n                for s1, a1 in [strings[i], strings[j]]:\n                    for s2, a2 in [strings[i], strings[j]]:\n                        if s1 != s2 or s1 != s1[::-1]:\n                            continue\n                        if is_palindrome(s1 + s2):\n                            max_beauty = max(max_beauty, a1 + a2)\n        return max_beauty\n\n    return str(get_max_palindrome_beauty(strings))",
        "test": "",
        "num_ids": 273,
        "indeed": false
    },
    {
        "number": 1359,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhombus(a, b, c, d):\n        return (a, b) in roads and (b, c) in roads and (a, d) in roads and (d, c) in roads\n\n    def find_rhombi():\n        rhombi = set()\n        for a in range(1, n + 1):\n            for b in range(1, n + 1):\n                if a != b:\n                    for c in range(1, n + 1):\n                        for d in range(1, n + 1):\n                            if a != c and a != d and b != c and b != d and c != d:\n                                if is_rhombus(a, b, c, d):\n                                    rhombi.add(frozenset([a, b, c, d]))\n        return rhombi\n\n    n, m = map(int, stdin.readline().split())\n    roads = set()\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        roads.add((a, b))\n\n    rhombi = find_rhombi()\n    return str(len(rhombi))",
        "test": "",
        "num_ids": 292,
        "indeed": false
    },
    {
        "number": 1360,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    exams = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        exams.append((a, b))\n\n    exams.sort(key=lambda x: x[0])\n\n    min_day = exams[0][1]\n    for i in range(1, n):\n        min_day = max(min_day, exams[i][1])\n\n    return str(min_day)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 1361,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    d = max(a[i + 1] - a[i] for i in range(n - 1))\n    min_difficulty = float(\"inf\")\n    for i in range(1, n - 1):\n        difficulty = max(a[i + 1] - a[i - 1], a[i] - a[i - 1])\n        min_difficulty = min(min_difficulty, difficulty)\n    return str(min(d, min_difficulty))",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 1362,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, m = map(int, stdin.split()[:3])\n    top_ups = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    top_ups.sort(key=lambda x: x[0])\n    days_with_negative_balance = 0\n    balance = 0\n\n    for i in range(m):\n        if i + 1 <= top_ups[0][0]:\n            balance -= p\n        else:\n            balance -= p\n            for j in range(len(top_ups)):\n                if top_ups[j][0] <= i + 1:\n                    balance += top_ups[j][1]\n                else:\n                    break\n\n        if balance < 0:\n            days_with_negative_balance += 1\n\n    return str(days_with_negative_balance)",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 1364,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sushi = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    def is_valid(start, end):\n        left_half = sushi[start:end]\n        right_half = sushi[start + (end - start) // 2:end]\n        return len(left_half) == len(right_half) and all(x == left_half[0] for x in left_half) and all(x == right_half[0] for x in right_half)\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            if is_valid(i, j + 1):\n                max_length = max(max_length, j - i + 1)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1365,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, d: int) -> int:\n        if d > k:\n            return 0\n        res = 1\n        for v in adj[u]:\n            if v != parent[u]:\n                res *= dfs(v, d + 1)\n                res %= mod\n        return res\n\n    n, k = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    mod = 10**9 + 7\n    parent = [-1] * (n + 1)\n    return str(dfs(1, 0))",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 1366,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bottles = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    opened_brands = set()\n    for i in range(n):\n        if bottles[i][0] in opened_brands:\n            opened_brands.add(bottles[i][1])\n        elif bottles[i][1] in opened_brands:\n            opened_brands.add(bottles[i][0])\n\n    unopened_bottles = 0\n    for i in range(n):\n        if bottles[i][0] not in opened_brands and bottles[i][1] not in opened_brands:\n            unopened_bottles += 1\n\n    return str(unopened_bottles)",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 1367,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, watched_episodes = map(int, stdin.split())\n    all_episodes = set(range(1, n + 1))\n    watched_episodes = set(watched_episodes)\n    missing_episode = all_episodes - watched_episodes\n    return str(missing_episode.pop())",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 1368,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, values = map(int, stdin.split())\n    values = list(map(int, stdin.split()))[1:]\n    values.sort()\n\n    max_mean = float('-inf')\n    max_ways = 0\n\n    for i in range(A, B + 1):\n        selected_values = values[-i:]\n        mean = sum(selected_values) / len(selected_values)\n\n        if mean > max_mean:\n            max_mean = mean\n            max_ways = 1\n        elif mean == max_mean:\n            max_ways += 1\n\n    return f\"{max_mean:.6f}\\n{max_ways}\"",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 1369,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def min_radius(points):\n        min_r = float('inf')\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                r = distance(points[i][0], points[i][1], points[j][0], points[j][1]) / 2\n                min_r = min(min_r, r)\n        return min_r\n\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    return '{:.10f}'.format(min_radius(points))",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 1370,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split()[:3])\n    S = [list(map(int, row.strip())) for row in stdin.split('\\n')[1:]]\n\n    def count_white_squares(i, j):\n        return sum(S[x][y] for x in range(i, H) for y in range(j, W))\n\n    min_cuts = float('inf')\n\n    for i in range(1, H):\n        for j in range(1, W):\n            if count_white_squares(i, j) <= K:\n                continue\n\n            cuts = 1\n            if i > 1:\n                cuts += 1\n            if j > 1:\n                cuts += 1\n\n            min_cuts = min(min_cuts, cuts)\n\n    return str(min_cuts)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1371,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    S = int(stdin)\n    dp = [0] * (S + 1)\n    dp[0] = 1\n\n    for i in range(3, S + 1):\n        dp[i] = (dp[i - 3] + dp[i - 4]) % mod\n\n    return str(dp[S])",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1372,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = list(map(int, stdin.split()))\n    H = input_list[0]\n    N = input_list[1]\n    A_B = input_list[2:]\n    A = [A_B[i] for i in range(N) if i % 2 == 0]\n    B = [A_B[i] for i in range(N) if i % 2 != 0]\n\n    # Initialize variables\n    min_cost = float('inf')\n    min_cost_spell_combination = None\n\n    # Iterate through all possible spell combinations\n    for i in range(2**N):\n        # Get the spells used in this combination\n        spells_used = [j for j in range(N) if (i >> j) & 1]\n\n        # Calculate the total cost and health decrease\n        total_cost = sum([B[j] for j in spells_used])\n        total_health_decrease = sum([A[j] for j in spells_used])\n\n        # Check if this combination is a valid solution\n        if total_health_decrease >= H and total_cost < min_cost:\n            min_cost = total_cost\n            min_cost_spell_combination = spells_used\n\n    # Return the minimum total Magic Points\n    return str(min_cost)",
        "test": "",
        "num_ids": 335,
        "indeed": false
    },
    {
        "number": 1373,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * i) % mod\n    ans = 0\n    for i in range(k, n + 1):\n        ans += dp[i]\n        ans %= mod\n    return str(ans)",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 1374,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    m = []\n    for l in range(1, N + 1):\n        for r in range(l, N + 1):\n            m.append(sorted(a[l - 1:r])[(r - l) // 2])\n\n    return str(sorted(m)[(len(m) - 1) // 2])",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1375,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(2, n - 1):\n        left_sum = sum(a[:i])\n        right_sum = sum(a[i:])\n        if left_sum == right_sum:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 1376,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    sasha_distance = 0\n    dima_distance = 0\n\n    for i in range(1, n + 1):\n        sasha_distance += abs(a.index(i) - a.index(i - 1))\n        dima_distance += abs(a.index(i) - a.index(i - 1))\n\n    return str(sasha_distance + dima_distance)",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 1377,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    for i in range(n):\n        if i == 0:\n            if a[i] != 1:\n                return \"NO\"\n        else:\n            if a[i] != a[i - 1] + 1:\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1378,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    B = list(map(int, stdin.split('\\n')[1].split()))\n    P = [i for i in range(n)]\n    for i in range(n):\n        if i % 2 == 0:\n            P[B[i]] = P[i]\n        else:\n            P[B[i]] = P[i - 1]\n    return ' '.join(map(str, P))",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 1379,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    days = [0] * n\n    for i in range(n):\n        days[i] = (a[i] // m) + 1\n\n    output1 = len(set(days))\n\n    output2 = [str(x) for x in days]\n    output2 = \" \".join(output2)\n\n    return str(output1) + \"\\n\" + output2",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1380,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    heights = list(map(int, stdin.split()))\n    p = 0\n    result = []\n\n    for i in range(1, n):\n        diff = heights[i] - heights[i - 1]\n        if diff != k:\n            if diff > k:\n                p += diff - k\n                result.append(f\"+ {i} {k - diff}\")\n            else:\n                p += k - diff\n                result.append(f\"- {i} {k - diff}\")\n\n    return f\"{p}\\n\" + \"\\n\".join(result)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 1381,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, s, p = map(int, stdin.split())\n    total_sheets = k * n\n    packs = total_sheets // s\n    if total_sheets % s != 0:\n        packs += 1\n    return str(packs)",
        "test": "",
        "num_ids": 66,
        "indeed": false
    },
    {
        "number": 1382,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_cycle(cycle: set, edges: set) -> bool:\n        for edge in edges:\n            if edge[0] in cycle and edge[1] in cycle:\n                return False\n        return True\n\n    def find_cycles(n: int, edges: set, visited: set, current_vertex: int, current_cycle: set, cycles: set):\n        if current_vertex in visited:\n            return\n        visited.add(current_vertex)\n        current_cycle.add(current_vertex)\n        for neighbor in neighbors[current_vertex]:\n            if neighbor != current_vertex:\n                find_cycles(n, edges, visited, neighbor, current_cycle, cycles)\n        if len(current_cycle) % 2 != 0 and len(current_cycle) > 1:\n            cycles.add(frozenset(current_cycle))\n        current_cycle.remove(current_vertex)\n        visited.remove(current_vertex)\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    edges = set()\n    neighbors = [set() for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        a, b = map(int, lines[i].split())\n        edges.add((a, b))\n        neighbors[a].add(b)\n        neighbors[b].add(a)\n\n    visited = set()\n    cycles = set()\n    for vertex in range(1, n + 1):\n        find_cycles(n, edges, visited, vertex, set(), cycles)\n\n    t = float('inf')\n    w = 0\n    for cycle in cycles:\n        cycle_edges = set()\n        for i in range(len(cycle)):\n            a, b = tuple(sorted((cycle[i - 1], cycle[i])))\n            cycle_edges.add((a, b))\n        if len(cycle_edges) < t and is_valid_cycle(cycle, edges):\n            t = len(cycle_edges)\n            w = 1\n        elif len(cycle_edges) == t and is_valid_cycle(cycle, edges):\n            w += 1\n\n    return f\"{t} {w}\"",
        "test": "",
        "num_ids": 555,
        "indeed": false
    },
    {
        "number": 1383,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    def is_possible(x: int) -> bool:\n        for i in range(n):\n            if (a[i] + x) % m != b[i]:\n                return False\n        return True\n\n    x = 0\n    while not is_possible(x):\n        x += 1\n\n    return str(x)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1384,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = [int(i) for i in stdin.split('\\n')[1].split()]\n\n    count = 0\n    max_count = 0\n\n    for i in range(n):\n        if s[i] == 1:\n            count += 1\n            max_count = max(max_count, count)\n        elif s[i] == 0 and count > 0:\n            count += 1\n        else:\n            count = 1\n\n    return str(max_count)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1385,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lexemes = []\n    current_lexeme = \"\"\n    in_quotes = False\n    for char in stdin:\n        if char == \"\\\"\":\n            in_quotes = not in_quotes\n        elif not in_quotes and char == \" \":\n            if current_lexeme:\n                lexemes.append(current_lexeme)\n                current_lexeme = \"\"\n        else:\n            current_lexeme += char\n    if current_lexeme:\n        lexemes.append(current_lexeme)\n    output = \"\"\n    for i, lexeme in enumerate(lexemes):\n        output += f\"<{lexeme}>\"\n        if i < len(lexemes) - 1:\n            output += \"\\n\"\n    return output",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 1386,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_tilings(w, h):\n        dp = [[0] * (w + 1) for _ in range(h + 1)]\n        dp[0][1] = 1\n        dp[1][0] = 1\n\n        for i in range(1, h + 1):\n            for j in range(1, w + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                if i >= 2:\n                    dp[i][j] -= dp[i - 2][j]\n                if j >= 2:\n                    dp[i][j] -= dp[i][j - 2]\n                dp[i][j] %= MOD\n\n        return dp[h][w]\n\n    return str(count_tilings(w, h))",
        "test": "",
        "num_ids": 253,
        "indeed": false
    },
    {
        "number": 1387,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    visited = [False] * n\n    visited[0] = True\n\n    for i in range(n - 1):\n        if not visited[i]:\n            continue\n        next_cell = (i + a[i]) % n\n        if not visited[next_cell]:\n            visited[next_cell] = True\n\n    return \"YES\" if visited[t - 1] else \"NO\"",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1388,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, parent: int) -> None:\n        for v in tree[u]:\n            if v != parent:\n                dfs(v, u)\n        if u != 1:\n            for v in tree[u]:\n                if v != parent:\n                    for w in tree[u]:\n                        if w != parent and w != v:\n                            dp[u] = min(dp[u], dp[u] + a[u] * (cost[u] - 1))\n                            dp[u] = min(dp[u], dp[u] + a[u] * (cost[u] - 1))\n\n    def find_path(u: int, parent: int) -> None:\n        for v in tree[u]:\n            if v != parent:\n                find_path(v, u)\n        if u != 1:\n            for v in tree[u]:\n                if v != parent:\n                    for w in tree[u]:\n                        if w != parent and w != v:\n                            dp[u] = min(dp[u], dp[u] + a[u] * (cost[u] - 1))\n                            dp[u] = min(dp[u], dp[u] + a[u] * (cost[u] - 1))\n\n    n = int(stdin.readline())\n    a, b, c, cost = [], [], [], []\n    tree = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        a_i, b_i, c_i = map(int, stdin.readline().split())\n        a.append(a_i)\n        b.append(b_i)\n        c.append(c_i)\n        cost.append(a_i)\n    for i in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        tree[u].append(v)\n        tree[v].append(u)\n\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n    dfs(1, -1)\n    if dp[1] == float('inf'):\n        return -1\n    return dp[1]",
        "test": "",
        "num_ids": 558,
        "indeed": false
    },
    {
        "number": 1389,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    feature = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def count_pixels(feature, prefix_rectangle):\n        return sum(prefix_rectangle[i][j] * (1 if feature[i][j] == \"W\" else -1) for i in range(n) for j in range(m))\n\n    def find_min_operations(feature):\n        min_operations = float(\"inf\")\n        for i in range(n):\n            for j in range(m):\n                for k in range(i + 1, n + 1):\n                    for l in range(j + 1, m + 1):\n                        prefix_rectangle = [[0] * l for _ in range(k - i)]\n                        for x in range(i, k):\n                            for y in range(j, l):\n                                prefix_rectangle[x - i][y - j] = feature[x][y]\n                        operations = 1 + count_pixels(feature, prefix_rectangle)\n                        min_operations = min(min_operations, operations)\n        return min_operations\n\n    return str(find_min_operations(feature))",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 1390,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    puzzles = list(map(int, input().split()))\n    puzzles.sort()\n\n    min_diff = puzzles[-1] - puzzles[0]\n    for i in range(1, n):\n        min_diff = min(min_diff, puzzles[i * m // n - 1] - puzzles[(i - 1) * m // n])\n\n    return str(min_diff)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1391,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, p = map(int, stdin.split())\n    b.sort(reverse=True)\n    p.sort()\n    r = 0\n    s = 0\n\n    for i in range(n):\n        if m == 0 or a == 0:\n            break\n        if b[i] >= p[m - 1]:\n            r += 1\n            s += p[m - 1]\n            a -= p[m - 1]\n            m -= 1\n        else:\n            break\n\n    return f\"{r} {s}\"",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1392,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [int(input()) for _ in range(n)]\n    count = 0\n    for num in a:\n        digits = set(str(num))\n        if all(int(d) <= k for d in digits):\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 1393,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    m = len(t)\n\n    s_count = [0] * 52\n    t_count = [0] * 52\n\n    for i in range(n):\n        s_count[ord(s[i]) - ord('A') + 26 * (s[i].islower())] += 1\n\n    for i in range(m):\n        t_count[ord(t[i]) - ord('A') + 26 * (t[i].islower())] += 1\n\n    yays = 0\n    whoops = 0\n\n    for i in range(52):\n        yays += min(s_count[i], t_count[i])\n        whoops += max(0, s_count[i] - t_count[i])\n\n    return f\"{yays} {whoops}\"",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 1394,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin\n    n = len(t)\n    s = \"\"\n    s_prime = \"\"\n\n    for i in range(n):\n        if t[i] != 'a':\n            s += t[i]\n            s_prime += 'a'\n        else:\n            s_prime += 'a'\n\n    if s_prime in s:\n        return s\n    else:\n        return \":(`\"",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 1395,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    min_remainder = float('inf')\n    for i in range(len(str(n))):\n        shifted_n = int(str(n)[i:] + str(n)[:i])\n        min_remainder = min(min_remainder, shifted_n % m)\n    return min_remainder",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1396,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x, balls = map(int, stdin.split())\n    balls = list(map(int, balls.split()))\n\n    def destroy_balls(balls: List[int], x: int) -> int:\n        i = 0\n        count = 0\n        while i < len(balls):\n            if balls[i] == x:\n                count += 1\n                balls.pop(i)\n            else:\n                i += 1\n        return count\n\n    def process_row(balls: List[int], x: int) -> int:\n        i = 0\n        count = 0\n        while i < len(balls):\n            if balls[i] == x:\n                count += destroy_balls(balls, x)\n            else:\n                i += 1\n        return count\n\n    return str(process_row(balls, x))",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 1397,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, x):\n        if parent[x] == x:\n            return x\n        return find_parent(parent, parent[x])\n\n    def union(parent, rank, x, y):\n        xroot = find_parent(parent, x)\n        yroot = find_parent(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    n, m = map(int, stdin.readline().split())\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n    edges = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        union(parent, rank, a, b)\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if find_parent(parent, i) != find_parent(parent, j):\n                edges.append((i, j))\n\n    return f\"{len(edges)}\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in edges)",
        "test": "",
        "num_ids": 361,
        "indeed": false
    },
    {
        "number": 1398,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, measurements = map(int, stdin.split())\n    measurements = sorted(measurements)\n    min_diff = measurements[-1] - measurements[0]\n    min_erase = 0\n\n    for i in range(n - 1):\n        diff = measurements[i + 1] - measurements[i]\n        if diff >= 2 * min_diff:\n            min_erase += 1\n            min_diff = diff\n\n    return str(min_erase)",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1399,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_on_segment(p, q, r):\n        if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]):\n            return True\n        return False\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        if val > 0:\n            return 1\n        return 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        if o1 != o2 and o3 != o4:\n            return True\n\n        if o1 == 0 and is_on_segment(p1, p2, q1):\n            return True\n\n        if o2 == 0 and is_on_segment(p1, q2, q1):\n            return True\n\n        if o3 == 0 and is_on_segment(p2, p1, q2):\n            return True\n\n        if o4 == 0 and is_on_segment(p2, q1, q2):\n            return True\n\n        return False\n\n    def count_points(segments):\n        points = set()\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                if do_intersect(segments[i][0], segments[i][1], segments[j][0], segments[j][1]):\n                    points.add(tuple(segments[i][0]))\n                    points.add(tuple(segments[i][1]))\n                    points.add(tuple(segments[j][0]))\n                    points.add(tuple(segments[j][1]))\n        return len(points)\n\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        segments.append([[x1, y1], [x2, y2]])\n\n    result = count_points(segments)\n    return str(result)",
        "test": "",
        "num_ids": 654,
        "indeed": false
    },
    {
        "number": 1400,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, input().split()))\n\n    P = 1\n    Q = 1\n\n    for i in range(n):\n        p_i = (1 / 2) * (1 + (i < n - 1))\n        P *= p_i\n        Q *= p_i\n\n        P += (1 - p_i) * (i + 1)\n        Q += (1 - p_i)\n\n    E = P // Q\n\n    return f\"{E % (10**9 + 7)}\"",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 1401,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, parent):\n        if v > n:\n            return a[v], 0\n        res = [dfs(c, v) for c in graph[v] if c != parent]\n        val, cnt = 0, 0\n        for vv, cc in res:\n            val += vv\n            cnt += cc\n        if val > a[v]:\n            cnt += 1\n        return val, cnt\n\n    n, a, graph = 0, [], {}\n    for line in stdin.split('\\n'):\n        if n == 0:\n            n = int(line)\n            a = list(map(int, line.split()))\n        elif n:\n            p, c = map(int, line.split())\n            if p not in graph:\n                graph[p] = []\n            if c + 1 not in graph:\n                graph[c + 1] = []\n            graph[p].append(c + 1)\n            graph[c + 1].append(p)\n            n -= 1\n\n    return str(dfs(1, -1)[1])",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 1402,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    template1 = stdin.readline().strip()\n    template2 = stdin.readline().strip()\n\n    def count_incomparable(template1: str, template2: str) -> int:\n        def is_incomparable(s: str, w: str) -> bool:\n            for i in range(n):\n                for j in range(n):\n                    if s[i] > w[i] and s[j] < w[j]:\n                        return True\n            return False\n\n        def replace_question_marks(template: str, start: int = 0) -> int:\n            if start == n:\n                return 1\n\n            count = 0\n            if template[start] == \"?\":\n                for digit in \"0123456789\":\n                    template[start] = digit\n                    count += replace_question_marks(template, start + 1)\n                template[start] = \"?\"\n            else:\n                count += replace_question_marks(template, start + 1)\n\n            return count\n\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if template1[i] != \"?\" and template2[j] != \"?\":\n                    continue\n                template1[i], template2[j] = template2[j], template1[i]\n                if not is_incomparable(template1, template2):\n                    count += replace_question_marks(template1) * replace_question_marks(template2)\n                template1[i], template2[j] = template2[j], template1[i]\n\n        return count\n\n    MOD = 10**9 + 7\n    result = count_incomparable(template1, template2)\n    return str(result % MOD)",
        "test": "",
        "num_ids": 452,
        "indeed": false
    },
    {
        "number": 1403,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def can_swallow(i, j):\n        return a[i] > a[j] and a[i] <= a[j] + K\n\n    def swallow(i, j):\n        a[i] = a[i] + a[j]\n        a.pop(j)\n\n    def process():\n        for i in range(n):\n            for j in range(n):\n                if i != j and can_swallow(i, j):\n                    swallow(i, j)\n                    n -= 1\n                    return process()\n        return n\n\n    return str(process())",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1404,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 998244353\n\n    def count_ways(arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[0] * 201 for _ in range(n)]\n\n        for i in range(n):\n            if arr[i] != -1:\n                dp[i][arr[i]] = 1\n\n        for i in range(1, n):\n            for j in range(1, 201):\n                if dp[i - 1][j] == 0:\n                    continue\n                if j > 1:\n                    dp[i][j - 1] += dp[i - 1][j]\n                    dp[i][j - 1] %= mod\n                if j < 200:\n                    dp[i][j + 1] += dp[i - 1][j]\n                    dp[i][j + 1] %= mod\n\n        return sum(dp[-1]) % mod\n\n    return str(count_ways(arr))",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 1405,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_fibonacci_ish(seq: list) -> bool:\n        if len(seq) < 2:\n            return False\n        for i in range(2, len(seq)):\n            if seq[i] != seq[i - 1] + seq[i - 2] + 2:\n                return False\n        return True\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_fibonacci_ish(a[i:j + 1]):\n                max_length = max(max_length, j - i + 1)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 1406,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    if n % k != 0:\n        return \"-1\"\n    else:\n        students_per_bus = n // k\n        result = []\n        for day in range(d):\n            buses = [i + 1 for i in range(k)]\n            for student in range(n):\n                bus = (student + day) % k\n                result.append(str(buses[bus]))\n                buses.remove(buses[bus])\n                if len(buses) == 0:\n                    buses = [i + 1 for i in range(k)]\n            result.append(\"\\n\")\n        return \"\".join(result[:-1])",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 1407,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, stdin.readline().split())))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_prime_matrix(matrix: List[List[int]]) -> bool:\n        for row in matrix:\n            if all(is_prime(x) for x in row):\n                return True\n        for col in range(m):\n            if all(is_prime(matrix[row][col]) for row in range(n)):\n                return True\n        return False\n\n    def min_moves_to_prime(matrix: List[List[int]]) -> int:\n        moves = 0\n        for i in range(n):\n            for j in range(m):\n                if not is_prime(matrix[i][j]):\n                    moves += matrix[i][j] - 1\n                    matrix[i][j] = 1\n        return moves\n\n    if is_prime_matrix(matrix):\n        return \"0\"\n    else:\n        return str(min_moves_to_prime(matrix))",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 1408,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    books = []\n    for i in range(n):\n        t, w = map(int, stdin.readline().split())\n        books.append((t, w))\n\n    books.sort(key=lambda x: x[1], reverse=True)\n\n    total_thickness = 0\n    horizontal_width = 0\n    for t, w in books:\n        if t == 1:\n            total_thickness += 1\n        elif t == 2:\n            if horizontal_width + w <= total_thickness:\n                horizontal_width += w\n            else:\n                total_thickness += 2\n\n    return str(total_thickness)",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 1409,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    participants = list(map(int, stdin.split()))\n    participants.sort(reverse=True)\n\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for l in range(j + 1, n):\n                if participants[i] + participants[j] + participants[l] >= k:\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1410,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_painting(painting: List[int]) -> bool:\n        for u, v, w in combinations(range(n), 3):\n            if painting[u] == painting[v] == painting[w]:\n                return False\n        return True\n\n    def min_cost_good_painting(costs: List[List[int]]) -> Tuple[int, List[int]]:\n        min_cost = float('inf')\n        min_painting = []\n        for painting in product(range(3), repeat=n):\n            if is_good_painting(painting):\n                cost = sum(costs[i][color] for i, color in enumerate(painting))\n                if cost < min_cost:\n                    min_cost = cost\n                    min_painting = painting\n        return min_cost, min_painting\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    costs = [list(map(int, lines[i].split())) for i in range(1, 4)]\n    edges = [list(map(int, lines[i].split())) for i in range(4, 4 + n - 1)]\n\n    min_cost, min_painting = min_cost_good_painting(costs)\n\n    if min_cost == float('inf'):\n        return \"-1\\n\"\n    else:\n        return f\"{min_cost}\\n{' '.join(map(str, min_painting))}\\n\"",
        "test": "",
        "num_ids": 371,
        "indeed": false
    },
    {
        "number": 1411,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.readline().split())\n    contestants = []\n\n    for _ in range(n):\n        slices, happiness_1, happiness_2 = map(int, stdin.readline().split())\n        contestants.append((slices, happiness_1, happiness_2))\n\n    contestants.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    total_happiness = 0\n    pizza_1 = 0\n    pizza_2 = 0\n\n    for slices, happiness_1, happiness_2 in contestants:\n        if slices <= (s - pizza_1 * s) * 2:\n            total_happiness += slices * happiness_1\n            pizza_1 += 1\n        elif slices <= (s - pizza_1 * s - pizza_2 * s) * 2:\n            total_happiness += slices * happiness_2\n            pizza_2 += 1\n        else:\n            total_happiness += (s - pizza_1 * s - pizza_2 * s) * (happiness_1 + happiness_2)\n            pizza_1 += 1\n\n    return str(total_happiness)",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 1412,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    coupons = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    products = [0] * 1001\n    for coupon in coupons:\n        for product in range(coupon[0], coupon[1] + 1):\n            products[product] += 1\n\n    max_products = max(products)\n    result = [i for i, product in enumerate(products) if product == max_products]\n\n    return f\"{max_products}\\n{' '.join(map(str, result[:k]))}\\n\"",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 1413,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if int(s[i:j + 1]) % 2 == 0:\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 1414,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def dfs(x, y, count):\n        if table[x][y] == \"D\":\n            count += 1\n            if count == 4:\n                return True\n        if x > 0 and table[x - 1][y] == \"I\":\n            if dfs(x - 1, y, count):\n                return True\n        if y + 1 < m and table[x][y + 1] == \"M\":\n            if dfs(x, y + 1, count):\n                return True\n        if x + 1 < n and table[x + 1][y] == \"A\":\n            if dfs(x + 1, y, count):\n                return True\n        if y > 0 and table[x][y - 1] == \"D\":\n            if dfs(x, y - 1, count):\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, 0):\n                return \"Poor Inna!\"\n\n    return \"Poor Dima!\"",
        "test": "",
        "num_ids": 304,
        "indeed": false
    },
    {
        "number": 1415,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, x_0, y_0, s = stdin.split()\n    x, y, x_0, y_0 = int(x), int(y), int(x_0), int(y_0)\n    s = s.strip()\n\n    def move(x, y, direction):\n        if direction == 'L':\n            y -= 1\n        elif direction == 'R':\n            y += 1\n        elif direction == 'U':\n            x -= 1\n        elif direction == 'D':\n            x += 1\n        return x, y\n\n    def count_tests(k):\n        tests = 0\n        for i in range(x):\n            for j in range(y):\n                if (i, j) != (x_0 - 1, y_0 - 1):\n                    x_current, y_current = x_0 - 1, y_0 - 1\n                    for command in s[:k]:\n                        x_current, y_current = move(x_current, y_current, command)\n                        if (x_current, y_current) == (i, j):\n                            break\n                    else:\n                        tests += 1\n        return tests\n\n    result = [count_tests(k) for k in range(len(s) + 1)]\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 1416,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort(reverse=True)\n    total_water = 0\n    girls = n\n    boys = n\n    x = 0\n\n    for i in range(len(a)):\n        if girls > 0 and boys > 0:\n            x = a[i] // 2\n            total_water += x * (girls + boys)\n            girls -= 1\n            boys -= 1\n        elif girls > 0:\n            x = a[i]\n            total_water += x * girls\n            girls -= 1\n        else:\n            break\n\n    return f\"{total_water:.6f}\"",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 1417,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 998244353\n\n    def factorial(x):\n        res = 1\n        for i in range(1, x + 1):\n            res = (res * i) % mod\n        return res\n\n    def count_subarrays(n):\n        total_subarrays = 0\n        for i in range(1, n + 1):\n            total_subarrays = (total_subarrays + i * factorial(n - 1)) % mod\n        return total_subarrays\n\n    return str(count_subarrays(n))",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 1418,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(2, i):\n            if i % j == 0:\n                a[i] = max(a[i], a[j] + 1)\n    return \" \".join(map(str, a[2:]))",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1419,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1].split(' ')\n    max_width = 0\n\n    for i in range(len(words)):\n        if i % k == 0:\n            max_width = max(max_width, len(words[i]))\n        else:\n            max_width = max(max_width, len(words[i]) + 1)\n\n    return max_width",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1420,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort()\n\n    d = 0\n    for i in range(n - 1):\n        d = max(d, (a[i + 1] - a[i]) / 2)\n\n    return str(d)",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1421,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def dfs(graph, node, visited):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(graph, neighbor, visited)\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    edges = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n - 1)]\n\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for u, v in edges:\n        union(parent, rank, u, v)\n        graph[u].append(v)\n        graph[v].append(u)\n\n    chloe_prizes = []\n    vladik_prizes = []\n    for i in range(1, n + 1):\n        if find(parent, i) == i:\n            if a[i - 1] >= 0:\n                chloe_prizes.append(i)\n            else:\n                vladik_prizes.append(i)\n\n    chloe_sum = 0\n    vladik_sum = 0\n    chloe_visited = set()\n    vladik_visited = set()\n\n    for prize in chloe_prizes:\n        dfs(graph, prize, chloe_visited)\n\n    for prize in vladik_prizes:\n        if prize in chloe_visited:\n            continue\n        dfs(graph, prize, vladik_visited)\n\n    if not chloe_visited & vladik_visited:\n        for i in range(1, n + 1):\n            if i in chloe_visited:\n                chloe_sum += a[i - 1]\n            elif i in vladik_visited:\n                vladik_sum += a[i - 1]\n        return str(chloe_sum + vladik_sum)\n    else:\n        return \"Impossible\"\n",
        "test": "",
        "num_ids": 699,
        "indeed": false
    },
    {
        "number": 1422,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    available_weights = [int(i) for i in stdin if i == \"1\"]\n    m = int(input())\n\n    if m % 2 != 0:\n        print(\"NO\")\n        return \"\"\n\n    weights = []\n    for weight in available_weights:\n        if weight * 2 in available_weights:\n            weights.append(weight)\n            weights.append(weight * 2)\n\n    if len(weights) < m // 2:\n        print(\"NO\")\n        return \"\"\n\n    print(\"YES\")\n    for i in range(m // 2):\n        print(weights[i], end=\" \")\n    print()\n\n    return \"\"\n\nstdin = \"0000000101\"\nsolution(stdin) ",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1423,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_sequence_b(a, p):\n        n, l, r = len(a), 1, 10**9\n        sequence_c = [p[i] - i for i in range(n)]\n        sequence_b = [0] * n\n\n        for i in range(n):\n            if sequence_c[i] > r - l + 1:\n                return None\n            sequence_b[i] = sequence_c[i] + l - 1\n            l = sequence_c[i] + l\n\n        return sequence_b\n\n    n, l, r = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    p = list(map(int, stdin.readline().split()))\n\n    sequence_b = find_sequence_b(a, p)\n\n    if sequence_b is None:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sequence_b))",
        "test": "",
        "num_ids": 244,
        "indeed": false
    },
    {
        "number": 1424,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    armies = [int(x) for x in stdin.split('\\n')[1:]]\n    fedor_army = armies.pop()\n    potential_friends = 0\n\n    for army in armies:\n        diff = bin(fedor_army ^ army).count('1')\n        if diff <= k:\n            potential_friends += 1\n\n    return str(potential_friends)",
        "test": "",
        "num_ids": 124,
        "indeed": true
    },
    {
        "number": 1425,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arr: List[int]) -> bool:\n        for i in range(n):\n            if arr[i - 1] >= arr[i] + arr[(i + 1) % n]:\n                return False\n        return True\n\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if is_valid(arr):\n        return \"YES\\n\" + \" \".join(map(str, arr))\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1426,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, target):\n        visited = [False] * (n + 1)\n        queue = [(start, 0)]\n        visited[start] = True\n\n        while queue:\n            vertex, depth = queue.pop(0)\n            if vertex == target:\n                return depth\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, depth + 1))\n        return -1\n\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    s, t = map(int, stdin.readline().split())\n\n    result = bfs(graph, s, t)\n    return str(result) if result != -1 else \"-1\"",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1427,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = int(stdin.split()[0]), list(map(int, stdin.split()[1:]))\n    A.sort()\n    B = [1] * N\n    mod = 10**9 + 7\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] * B[i] != A[j] * B[j]:\n                B[j] = A[i] * B[i] // A[j]\n                if B[j] == 0:\n                    B[j] = 1\n\n    return sum(B) % mod",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 1428,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_grid(colors: List[List[int]]) -> bool:\n        for i in range(N):\n            for j in range(N):\n                for x in range(N):\n                    for y in range(N):\n                        if (i + j) % 3 == (x + y) % 3 and colors[i][j] != colors[x][y]:\n                            return False\n        return True\n\n    def min_wrongness(colors: List[List[int]]) -> int:\n        min_wrongness = 0\n        for i in range(N):\n            for j in range(N):\n                min_wrongness += D[colors[i][j] - 1][c[i][j] - 1]\n        return min_wrongness\n\n    lines = stdin.split('\\n')\n    N, C = map(int, lines[0].split())\n    D = [list(map(int, line.split())) for line in lines[1:1 + C]]\n    c = [[int(x) for x in line.split(':')] for line in lines[1 + C:]]\n\n    colors = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            colors[i][j] = c[i][j]\n\n    if is_good_grid(colors):\n        return 0\n\n    min_wrongness_value = float('inf')\n    for i in range(N):\n        for j in range(N):\n            for color in range(1, C + 1):\n                if color != c[i][j]:\n                    colors[i][j] = color\n                    wrongness = min_wrongness(colors)\n                    if wrongness < min_wrongness_value:\n                        min_wrongness_value = wrongness\n                    colors[i][j] = c[i][j]\n\n    return str(min_wrongness_value)",
        "test": "",
        "num_ids": 480,
        "indeed": false
    },
    {
        "number": 1429,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    S = S.strip()\n\n    def is_complementary(s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        for c1, c2 in zip(s1, s2):\n            if c1 == c2:\n                return False\n        return True\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            substring = S[i:j]\n            for perm in set(permutations(substring)):\n                if is_complementary(substring, ''.join(perm)):\n                    count += 1\n                    break\n\n    return str(count)",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 1430,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split())\n    S = list(map(int, S))\n    max_consecutive_hands = 0\n\n    for i in range(N):\n        current_consecutive_hands = 0\n        for j in range(i, N):\n            if S[j] == 1:\n                current_consecutive_hands += 1\n            else:\n                break\n        max_consecutive_hands = max(max_consecutive_hands, current_consecutive_hands)\n\n    return max_consecutive_hands",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1431,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_set(choices: List[int]) -> bool:\n        for i in range(1, N + 1):\n            count = sum(choices[j] for j in range(i, N, i))\n            if count % 2 != a[i]:\n                return False\n        return True\n\n    N, a = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    if any(i % 2 == 1 for i in range(1, N + 1) if a[i] == 1):\n        return \"-1\"\n\n    choices = [0] * N\n    for i in range(1, N + 1):\n        if a[i] == 1:\n            for j in range(i, N, i):\n                choices[j] = 1\n\n    if is_good_set(choices):\n        return f\"{sum(choices)}\\n{' '.join(map(str, [i + 1 for i in range(N) if choices[i] == 1]))}\"\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 1432,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = [2 * A[i] for i in range(N)]\n    A[0] -= A[-1]\n    A[-1] -= A[1]\n    A[1] -= A[2]\n    A[-2] -= A[-3]\n    return \" \".join(map(str, A))",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1433,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    plan = []\n    for _ in range(n):\n        plan.append(list(map(int, stdin.readline().split())))\n\n    def is_good_position(x, y, direction):\n        if plan[x][y] == 1:\n            return False\n\n        if direction == \"left\":\n            for i in range(y - 1, -1, -1):\n                if plan[x][i] == 1:\n                    return True\n        elif direction == \"right\":\n            for i in range(y + 1, m):\n                if plan[x][i] == 1:\n                    return True\n        elif direction == \"up\":\n            for i in range(x - 1, -1, -1):\n                if plan[i][y] == 1:\n                    return True\n        elif direction == \"down\":\n            for i in range(x + 1, n):\n                if plan[i][y] == 1:\n                    return True\n\n        return False\n\n    count = 0\n    for x in range(n):\n        for y in range(m):\n            for direction in [\"left\", \"right\", \"up\", \"down\"]:\n                if is_good_position(x, y, direction):\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 334,
        "indeed": false
    },
    {
        "number": 1434,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor_sum(adjacent_vertices):\n        result = 0\n        for vertex in adjacent_vertices:\n            result ^= vertex\n        return result\n\n    def find_edges(degrees, xor_sums):\n        edges = []\n        for i in range(len(degrees)):\n            if degrees[i] == 0:\n                continue\n            for j in range(len(degrees)):\n                if degrees[j] == 0:\n                    continue\n                if i != j and xor_sums[i] == xor_sums[j]:\n                    edges.append((i, j))\n        return edges\n\n    def print_edges(edges):\n        print(len(edges))\n        for edge in edges:\n            print(edge[0], edge[1])\n\n    n = int(stdin.readline().strip())\n    degrees = []\n    xor_sums = []\n    for _ in range(n):\n        degree, xor_sum = map(int, stdin.readline().strip().split())\n        degrees.append(degree)\n        xor_sums.append(xor_sum)\n\n    edges = find_edges(degrees, xor_sums)\n    print_edges(edges)\n\n    return \"\"",
        "test": "",
        "num_ids": 319,
        "indeed": false
    },
    {
        "number": 1435,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.readline().strip())\n    count = 0\n    while a > 0:\n        a, b = a // 10, a % 10\n        if b == 9:\n            count += 1\n        else:\n            break\n    return str(count)",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 1436,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    events = list(map(int, stdin.split('\\n')[1].split()))\n\n    free_officers = []\n    untreated_crimes = 0\n\n    for event in events:\n        if event == -1:\n            if not free_officers:\n                untreated_crimes += 1\n            else:\n                free_officers.pop()\n        else:\n            for _ in range(event):\n                free_officers.append(1)\n\n    return str(untreated_crimes)",
        "test": "",
        "num_ids": 147,
        "indeed": true
    },
    {
        "number": 1437,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    base64_digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\"\n    s = stdin\n    n = len(s)\n    s_base64 = [base64_digits.index(c) for c in s]\n    s_num = sum(base ** i * digit for i, digit, base in zip(range(n), s_base64, range(64, 1, -1)))\n\n    def count_pairs(num):\n        count = 0\n        for i in range(64):\n            for j in range(i, 64):\n                if num & (i ^ j) == num:\n                    count += 1\n        return count\n\n    return str(count_pairs(s_num) % MOD)",
        "test": "",
        "num_ids": 231,
        "indeed": false
    },
    {
        "number": 1438,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    b.sort()\n    a.sort()\n\n    if a[0] > b[0]:\n        return 0\n\n    cookies = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            cookies += b[i] // a[i]\n        else:\n            cookies += k // a[i]\n            return cookies\n\n    return cookies",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 1439,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort()\n\n    for i in range(n):\n        if a[i] % m == 0:\n            return \"YES\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] + a[j]) % m == 0:\n                return \"YES\"\n\n    return \"NO\"\n",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 1440,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort(reverse=True)\n\n    count = 0\n    for i in range(n):\n        if a[i] >= 3:\n            count += a[i] // 3\n            a[i] %= 3\n\n    return str(count)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 1441,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, throws = map(int, stdin.split())\n    mod = 10**9 + 7\n    max_throws = max(throws)\n    dp = [1] * n\n\n    for _ in range(max_throws - 1):\n        new_dp = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                new_dp[i] += dp[j]\n                new_dp[j] += dp[i]\n        dp = [x % mod for x in new_dp]\n\n    return sum(dp) % mod",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 1442,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    orders = [list(map(str, line.split())) for line in stdin.split('\\n')[1:]]\n    buy_orders = []\n    sell_orders = []\n\n    for order in orders:\n        if order[0] == 'B':\n            buy_orders.append(order)\n        else:\n            sell_orders.append(order)\n\n    buy_orders.sort(key=lambda x: (-int(x[1]), int(x[2])))\n    sell_orders.sort(key=lambda x: (int(x[1]), -int(x[2])))\n\n    order_book = buy_orders[:s] + sell_orders[:s]\n    return '\\n'.join([' '.join(order) for order in order_book])",
        "test": "",
        "num_ids": 200,
        "indeed": false
    },
    {
        "number": 1443,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lengths = list(map(int, stdin.readline().strip().split()))\n    terrains = stdin.readline().strip()\n\n    time = 0\n    stamina = 0\n    current_terrain = terrains[0]\n\n    for i in range(n):\n        length = lengths[i]\n        terrain = terrains[i]\n\n        if terrain == current_terrain:\n            if terrain == \"G\":\n                time += length * 5\n                stamina += length\n            elif terrain == \"W\":\n                time += length * 3\n                stamina += length\n            else:\n                time += length * 5\n                stamina -= length\n        else:\n            if current_terrain == \"G\" and terrain == \"W\":\n                time += 3 * stamina\n                stamina = 0\n            elif current_terrain == \"W\" and terrain == \"G\":\n                time += 5 * stamina\n                stamina = 0\n            elif current_terrain == \"G\" and terrain == \"L\":\n                time += 3 * stamina\n                stamina = 0\n            elif current_terrain == \"L\" and terrain == \"G\":\n                time += 5 * stamina\n                stamina = 0\n            elif current_terrain == \"W\" and terrain == \"L\":\n                time += 5 * stamina\n                stamina = 0\n            elif current_terrain == \"L\" and terrain == \"W\":\n                time += 3 * stamina\n                stamina = 0\n\n            current_terrain = terrain\n\n    return str(time)",
        "test": "",
        "num_ids": 393,
        "indeed": false
    },
    {
        "number": 1444,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split())\n    x = sorted(list(map(int, x.split())))\n\n    def avg_commute_time(stations, k):\n        total_distance = sum([abs(x[i] - x[j]) for i in range(len(stations)) for j in range(i + 1, len(stations))])\n        return total_distance / (k * (k - 1) / 2)\n\n    def binary_search(x, k):\n        left, right = 0, len(x) - k\n        while left < right:\n            mid = (left + right) // 2\n            if avg_commute_time(x[mid:], k) < avg_commute_time(x[mid + 1:], k):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    result = [str(i) for i in range(binary_search(x, k), n - k + 1)]\n    return \" \".join(result)",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 1445,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cubes = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(1, n - n // 2):\n        for j in range(i, n - i + 1):\n            cubes[j - 1], cubes[n - j] = cubes[n - j], cubes[j - 1]\n\n    return \" \".join(map(str, cubes))",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1446,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(u, v, visited, adj_list, cost):\n        if u == v:\n            return cost\n        visited[u] = True\n        for neighbor, c in adj_list[u]:\n            if not visited[neighbor]:\n                new_cost = find_path(neighbor, v, visited, adj_list, cost + c)\n                if new_cost != float('inf'):\n                    return new_cost\n        return float('inf')\n\n    def dijkstra(adj_list, start):\n        n = len(adj_list)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        for i in range(n):\n            u = -1\n            for j in range(n):\n                if not visited[j] and (u == -1 or dist[j] < dist[u]):\n                    u = j\n            if u == -1:\n                break\n            visited[u] = True\n            for v, c in adj_list[u]:\n                dist[v] = min(dist[v], dist[u] + c)\n        return dist\n\n    n, m, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, c = map(int, stdin.readline().split())\n        adj_list[u].append((v, c))\n        adj_list[v].append((u, c))\n\n    d = [[0] * k for _ in range(k)]\n    for i in range(k):\n        for j in range(i + 1, k):\n            if c[i] == 0 or c[j] == 0:\n                d[i][j] = -1\n                continue\n            dist = find_path(1 + sum(c[:i]), 1 + sum(c[:j]), [False] * (n + 1), adj_list, 0)\n            if dist != float('inf'):\n                d[i][j] = dist\n            else:\n                d[i][j] = -1\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if d[i][j] == -1:\n                continue\n            dist = dijkstra(adj_list, 1 + sum(c[:i]))\n            for x in range(i + 1, k):\n                d[i][x] = min(d[i][x], dist[1 + sum(c[:x])] + d[i][x])\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if d[i][j] == -1:\n                d[i][j] = -1\n            else:\n                d[i][j] -= c[i]\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if d[i][j] == -1:\n                continue\n            dist = dijkstra(adj_list, 1 + sum(c[:j]))\n            for x in range(j + 1, k):\n                d[i][x] = min(d[i][x], dist[1 + sum(c[:x])] + d[i][x])\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if d[i][j] == -1:\n                d[i][j] = -1\n            else:\n                d[i][j] -= c[j]\n\n    if all(d[i][j] != -1 for i in range(k) for j in range(i + 1, k)):\n        print(\"Yes\")\n        for i in range(k):\n            print(*d[i])\n    else:\n        print(\"No\")\n\n    return \"\"",
        "test": "",
        "num_ids": 963,
        "indeed": false
    },
    {
        "number": 1447,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = 1 / m\n    success_probability = (1 / 3) * 1 + (2 / 3) * (1 / 2)\n    return f\"{success_probability:.15f}\"",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 1448,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0].split())\n    m = int(stdin.split()[1])\n    points = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def is_inside(x, y):\n        return 0 <= x <= n and 0 <= y <= n and (y <= d or y >= n - d)\n\n    result = []\n    for x, y in points:\n        if is_inside(x, y):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 1449,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_partition(a, k, n):\n        dp = [[False] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= a[i - 1]:\n                    dp[i][j] |= dp[i - 1][j - a[i - 1]]\n        return dp[n][k]\n\n    def find_min_m(a, k, n):\n        if not can_partition(a, k, n):\n            return -1\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= a[i - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i - 1]] + 1)\n        return dp[n][k]\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n, k = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        min_m = find_min_m(a, k, n)\n        output.append(min_m)\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 1450,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1] == '0' or s[i] == s[i + 1] == '1' or s[i] == s[i + 1] == '2':\n                return False\n        return True\n\n    def min_string(s: str) -> str:\n        while not is_valid(s):\n            for i in range(len(s) - 1):\n                if s[i] == '0' and s[i + 1] == '1':\n                    s = s[:i] + '1' + s[i] + s[i + 2:]\n                    break\n                elif s[i] == '1' and s[i + 1] == '2':\n                    s = s[:i] + '2' + s[i] + s[i + 2:]\n                    break\n        return s\n\n    return min_string(stdin)",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 1451,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    numbers = list(map(int, input().split()))\n    count = 0\n\n    for num in numbers:\n        num_str = str(num)\n        lucky_digits = [digit for digit in num_str if digit in ['4', '7']]\n        if len(lucky_digits) <= k:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 1452,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.readline().split())\n    r = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n\n    MOD = 10**9 + 7\n\n    dp = [[0] * (w + 1) for _ in range(h + 1)]\n    dp[0][1] = 1\n\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            if r[i - 1] == 0 and c[j - 1] == 0:\n                dp[i][j] = 2\n            elif r[i - 1] == 0:\n                dp[i][j] = dp[i][j - 1]\n            elif c[j - 1] == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD\n\n    return str(dp[h][w])",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 1453,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    x = [0] * (n + 1)\n    for k in range(1, n + 1):\n        x[k] = float('inf')\n        for i in range(1, k + 1):\n            j = k - i\n            if j > m:\n                break\n            penalty = (i + j) * a[i]\n            x[k] = min(x[k], penalty + x[k - i])\n\n    return ' '.join(map(str, x[1:]))",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1454,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_increasing(matrix):\n        for i in range(n):\n            for j in range(1, m):\n                if matrix[i][j] <= matrix[i][j - 1]:\n                    return False\n        for j in range(m):\n            for i in range(1, n):\n                if matrix[i][j] <= matrix[i - 1][j]:\n                    return False\n        return True\n\n    def replace_zeros(matrix, i, j, value):\n        if i < n - 1 and matrix[i + 1][j] == 0:\n            return replace_zeros(matrix, i + 1, j, value)\n        if j < m - 1 and matrix[i][j + 1] == 0:\n            return replace_zeros(matrix, i, j + 1, value)\n        matrix[i][j] = value\n        return matrix\n\n    def find_max_sum(matrix):\n        max_sum = 0\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == 0:\n                    for value in range(1, 8001):\n                        new_matrix = replace_zeros(matrix, i, j, value)\n                        if is_increasing(new_matrix):\n                            max_sum = max(max_sum, sum(sum(row) for row in new_matrix))\n                        else:\n                            break\n                else:\n                    max_sum += a[i][j]\n        return max_sum\n\n    return str(find_max_sum(a)) if any(0 in row for row in a) else \"-1\"",
        "test": "",
        "num_ids": 452,
        "indeed": false
    },
    {
        "number": 1455,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = 1\n    while True:\n        if n <= m * m:\n            break\n        m += 1\n    result = [str(m)]\n    for i in range(1, n + 1):\n        result.append(f\"{i // m + 1} {i % m + 1}\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1456,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(dx, dy):\n        return 1 <= dx <= n and 1 <= dy <= n\n\n    def is_attacked(x, y):\n        for dx, dy in vectors:\n            if is_valid(x + dx, y + dy) and board[x + dx][y + dy] == 'o':\n                return True\n        return False\n\n    def print_board():\n        for row in board:\n            print(''.join(row))\n\n    n = int(stdin.readline().strip())\n    board = [list(stdin.readline().strip()) for _ in range(n)]\n\n    vectors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                if is_attacked(i, j):\n                    return 'NO'\n\n    print('YES')\n    print_board()\n\n    for dx, dy in vectors:\n        for i in range(n):\n            for j in range(n):\n                if is_valid(i + dx, j + dy) and board[i + dx][j + dy] == '.':\n                    board[i + dx][j + dy] = 'x'\n                else:\n                    board[i + dx][j + dy] = '.'\n\n    print_board()\n\n    return ''",
        "test": "",
        "num_ids": 349,
        "indeed": false
    },
    {
        "number": 1457,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    AI_name, phone_name = stdin.split('\\n')\n    min_replace = len(AI_name)\n\n    for i in range(len(AI_name) - len(phone_name) + 1):\n        if AI_name[i:i + len(phone_name)] == phone_name:\n            min_replace = min(min_replace, i + len(phone_name))\n\n    return min_replace\n",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1458,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_lexicographically_less(s1: str, s2: str) -> bool:\n        for i in range(min(len(s1), len(s2))):\n            if s1[i] < s2[i]:\n                return True\n            elif s1[i] > s2[i]:\n                return False\n        return len(s1) < len(s2)\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_lexicographically_less(s[i:j][::-1], s[i:j]):\n                return \"YES\\n{} {}\".format(i + 1, j)\n    return \"NO\"",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 1459,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, s, t = map(int, stdin.split())\n    d = [int(x) for x in d.split()]\n    s -= 1\n    t -= 1\n\n    if s == t:\n        return 0\n\n    d = d + [d[0]]\n    d_s = d[s]\n    d_t = d[t]\n\n    if d_s > d_t:\n        d_s, d_t = d_t, d_s\n\n    d_st = sum(d[s:t])\n    d_s_n = sum(d[s:-t])\n    d_n_t = sum(d[n-t:n-s])\n\n    return min(d_st, d_s_n, d_n_t)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 1460,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 2 * n + 4\n    output = [str(k)]\n\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if (i, j) != (0, 0):\n                output.append(f\"{i} {j}\")\n\n    for i in range(1, n + 1):\n        output.append(f\"{-2} {i}\")\n        output.append(f\"{-1} {i}\")\n        output.append(f\"{0} {i}\")\n        output.append(f\"{1} {i}\")\n        output.append(f\"{2} {i}\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 1461,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n    w = list(map(int, stdin.readline().split()))\n\n    def dfs(v, length):\n        if length == k:\n            return w[v]\n        if length > k:\n            return float('inf')\n        return w[v] + dfs(f[v], length + 1)\n\n    for i in range(n):\n        s = dfs(i, 1)\n        m = float('inf')\n        for j in range(k):\n            m = min(m, dfs(i, j + 1))\n        print(s, m)\n",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 1462,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = input()\n    letter_count = {}\n    for card in cards:\n        if card in letter_count:\n            letter_count[card] += 1\n        else:\n            letter_count[card] = 1\n\n    max_coins = 0\n    for letter, count in letter_count.items():\n        max_coins += count * (count - 1) // 2\n\n    return str(max_coins)",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 1463,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    grid = []\n    for i in range(n):\n        row = list(map(int, stdin.readline().split()))\n        grid.append(row)\n\n    def is_valid(x: int, y: int) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if i != x and j != y and grid[i][j] == grid[x][y] - grid[i][y] - grid[x][j]:\n                    return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != 1 and not is_valid(i, j):\n                return \"No\"\n    return \"Yes\"",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 1464,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    titles = [stdin.readline().strip() for _ in range(n)]\n\n    def is_original(title: str) -> bool:\n        for other_title in titles:\n            if title in other_title:\n                return False\n        return True\n\n    shortest_original = None\n    for i in range(1, 21):\n        for title in titles:\n            if len(title) == i and is_original(title):\n                if shortest_original is None or len(title) < len(shortest_original):\n                    shortest_original = title\n                elif len(title) == len(shortest_original) and title < shortest_original:\n                    shortest_original = title\n\n    return shortest_original\n",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 1465,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    children = list(input())\n\n    def can_finish(heads: str) -> bool:\n        for i in range(1, n):\n            if heads[i - 1] != heads[i]:\n                return True\n        return False\n\n    def next_heads(heads: str) -> str:\n        new_heads = []\n        for i in range(1, n):\n            if heads[i - 1] != heads[i]:\n                new_heads.append(heads[i - 1])\n                new_heads.append(heads[i])\n        return \"\".join(new_heads)\n\n    def find_pairs(heads: str) -> List[Tuple[int, int]]:\n        pairs = []\n        for i in range(1, n):\n            if heads[i - 1] != heads[i]:\n                pairs.append((i - 1, i))\n        return pairs\n\n    def perform_move(heads: str, pairs: List[Tuple[int, int]]) -> str:\n        new_heads = list(heads)\n        for i, j in pairs:\n            new_heads[i] = \"L\" if heads[i] == \"R\" else \"R\"\n            new_heads[j] = \"L\" if heads[j] == \"R\" else \"R\"\n        return \"\".join(new_heads)\n\n    def find_solution() -> str:\n        heads = \"\".join(children)\n        for _ in range(k):\n            if not can_finish(heads):\n                return \"-1\"\n            pairs = find_pairs(heads)\n            heads = perform_move(heads, pairs)\n        return \"\\n\".join(f\"{len(pairs)} {' '.join(map(str, [i for i, _ in pairs]))}\" for pairs in find_pairs(heads))\n\n    return find_solution()",
        "test": "",
        "num_ids": 482,
        "indeed": false
    },
    {
        "number": 1466,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def kruskal(n, m, k, edges):\n        parent = [i for i in range(n + 1)]\n        rank = [0] * (n + 1)\n        edges.sort(key=lambda x: x[2])\n        result = []\n\n        for edge in edges:\n            if union(parent, rank, edge[0], edge[1]):\n                result.append(edge)\n                if len(result) == k:\n                    break\n\n        return result\n\n    def shortest_path(n, edges):\n        graph = [[0] * n for _ in range(n)]\n        for edge in edges:\n            graph[edge[0] - 1][edge[1] - 1] = edge[2]\n            graph[edge[1] - 1][edge[0] - 1] = edge[2]\n\n        dp = [float('inf')] * n\n        dp[0] = 0\n        visited = [False] * n\n\n        for _ in range(n - 1):\n            vertex = -1\n            for i in range(n):\n                if not visited[i] and (vertex == -1 or dp[i] < dp[vertex]):\n                    vertex = i\n            visited[vertex] = True\n\n            for i in range(n):\n                if not visited[i] and graph[vertex][i] != 0 and dp[vertex] + graph[vertex][i] < dp[i]:\n                    dp[i] = dp[vertex] + graph[vertex][i]\n\n        good_vertices = [i for i in range(n) if dp[i] != float('inf')]\n        return good_vertices\n\n    lines = stdin.split('\\n')\n    n, m, k = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:m + 1]]\n\n    kruskal_edges = kruskal(n, m, k, edges)\n    good_vertices = shortest_path(n, kruskal_edges)\n\n    output = [str(len(good_vertices))] + [str(i) for i in good_vertices]\n    return '\\n'.join(output) + '\\n' ",
        "test": "",
        "num_ids": 725,
        "indeed": false
    },
    {
        "number": 1467,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(segments: list) -> bool:\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                xor = 0\n                for k in range(len(segments[i])):\n                    xor ^= segments[i][k]\n                for k in range(len(segments[j])):\n                    xor ^= segments[j][k]\n                if xor == 0:\n                    return False\n        return True\n\n    def dfs(start: int, segments: list) -> int:\n        if start == n:\n            if is_valid(segments):\n                return len(segments)\n            else:\n                return -1\n\n        max_segments = -1\n        for i in range(start, n):\n            if i > start and a[i] == a[i - 1]:\n                continue\n            segments.append(a[start:i + 1])\n            max_segments = max(max_segments, dfs(i + 1, segments))\n            segments.pop()\n\n        return max_segments\n\n    return str(dfs(0, []))",
        "test": "",
        "num_ids": 323,
        "indeed": false
    },
    {
        "number": 1468,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    hashtags = [str(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid_hashtag(hashtag: str) -> bool:\n        if len(hashtag) == 0:\n            return False\n        if hashtag[0] != '#':\n            return False\n        for char in hashtag[1:]:\n            if not char.islower():\n                return False\n        return True\n\n    def lexicographically_not_greater(a: str, b: str) -> bool:\n        m, k = len(a), len(b)\n        for i in range(min(m, k)):\n            if a[i] < b[i]:\n                return True\n            elif a[i] > b[i]:\n                return False\n        return m <= k\n\n    def find_min_suffix_to_delete(hashtag: str, suffix: int) -> int:\n        while suffix > 0 and not is_valid_hashtag(hashtag[:-suffix]):\n            suffix -= 1\n        return suffix\n\n    def find_optimal_solution(hashtags: list) -> list:\n        hashtags.sort(key=lambda x: x[1:])\n        min_suffix_to_delete = [0] * n\n        for i in range(n):\n            min_suffix_to_delete[i] = find_min_suffix_to_delete(hashtags[i], min_suffix_to_delete[i - 1])\n        for i in range(n - 1, 0, -1):\n            if lexicographically_not_greater(hashtags[i][:-min_suffix_to_delete[i]], hashtags[i - 1][:-min_suffix_to_delete[i - 1]]):\n                min_suffix_to_delete[i - 1] = min_suffix_to_delete[i]\n        return [hashtag[:-suffix] for hashtag, suffix in zip(hashtags, min_suffix_to_delete)]\n\n    result = find_optimal_solution(hashtags)\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 558,
        "indeed": false
    },
    {
        "number": 1469,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.strip())\n    N = 8\n    M = 10\n    output = f\"{N} {M}\\n\"\n    output += \"1 2 0\\n2 3 0\\n3 4 0\\n1 5 0\\n2 6 0\\n3 7 0\\n4 8 0\\n5 6 1\\n6 7 1\\n7 8 1\\n\"\n    return output",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1470,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x <= 6:\n        return \"0\"\n    elif x == 7:\n        return \"1\"\n    elif x % 6 == 0:\n        return str(x // 6)\n    else:\n        return str(solution(str(x % 6)))",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1471,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find_parent(parent, parent[u])\n        return parent[u]\n\n    def union_parent(parent, u, v):\n        u = find_parent(parent, u)\n        v = find_parent(parent, v)\n        if u != v:\n            parent[u] = v\n\n    N, edges = int(stdin.splitlines()[0]), stdin.splitlines()[1:]\n    parent = list(range(N + 1))\n    for u, v, w in edges:\n        union_parent(parent, u, v)\n\n    color = [0] * (N + 1)\n    for u in range(1, N + 1):\n        if color[find_parent(parent, u)] == 0:\n            color[u] = 1\n\n    return \"\\n\".join(map(str, color[1:]))",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 1472,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    adj_list = [[] for _ in range(N + 1)]\n\n    for i in range(1, N):\n        adj_list[i].append(i + 1)\n        adj_list[i + 1].append(i)\n\n    adj_list[X].append(Y)\n    adj_list[Y].append(X)\n\n    visited = [False] * (N + 1)\n    distances = [0] * (N + 1)\n\n    def bfs(source: int, distance: int) -> int:\n        queue = [(source, distance)]\n        count = 0\n\n        while queue:\n            node, dist = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                distances[node] = dist\n                count += 1\n\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, dist + 1))\n\n        return count\n\n    result = []\n    for k in range(1, N):\n        count = bfs(1, 0)\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 309,
        "indeed": false
    },
    {
        "number": 1473,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    neighbors = {}\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        neighbors[i + 1] = (a, b)\n\n    queue = []\n    for i in range(n):\n        if neighbors[i + 1][0] == 0 and neighbors[i + 1][1] != 0:\n            queue.append(i + 1)\n            break\n\n    while len(queue) < n:\n        last_id = queue[-1]\n        next_id = neighbors[last_id][1]\n        queue.append(next_id)\n\n    return \" \".join(map(str, queue))\n",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 1474,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) * (h[i - 2] - 1)\n        dp[i] %= 1000000007\n    return str(dp[n])",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 1475,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, k, x = map(int, stdin.split())\n    digits = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    count = 1\n    for i in range(n):\n        current_digit = digits[i]\n        occurrences = digits.count(current_digit)\n        count *= occurrences\n        count %= mod\n\n    result = pow(count, b, mod)\n    return result if k == 0 else 0",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 1476,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\\n1\"\n    elif n % 2 == 0:\n        k = n - 2\n        return f\"{k}\\n{' '.join(map(str, range(1, k + 1, 2)))}\\n\"\n    else:\n        k = n - 1\n        return f\"{k}\\n{' '.join(map(str, range(1, k + 1, 2)))}\\n\"",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 1477,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def topological_sort(graph, node, visited, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                topological_sort(graph, neighbor, visited, stack)\n        stack.append(node)\n\n    def get_dependency_graph(N, M, E, dependencies):\n        dependency_graph = [[] for _ in range(N)]\n        for dependency in dependencies:\n            T1, T2 = map(int, dependency.split())\n            dependency_graph[T1].append(T2)\n        return dependency_graph\n\n    def get_tasks_by_processor(N, E, dependency_graph):\n        main_tasks = [i for i in range(N) if E[i] == 0]\n        coprocessor_tasks = [i for i in range(N) if i not in main_tasks]\n        for task in main_tasks:\n            for neighbor in dependency_graph[task]:\n                if neighbor in coprocessor_tasks:\n                    raise ValueError(\"Main processor task cannot depend on coprocessor task\")\n        return main_tasks, coprocessor_tasks\n\n    def count_minimal_calls(N, M, E, dependencies):\n        dependency_graph = get_dependency_graph(N, M, E, dependencies)\n        main_tasks, coprocessor_tasks = get_tasks_by_processor(N, E, dependency_graph)\n\n        visited = [False] * N\n        stack = []\n        for task in coprocessor_tasks:\n            if not visited[task]:\n                topological_sort(dependency_graph, task, visited, stack)\n\n        calls = 0\n        current_tasks = []\n        for task in reversed(stack):\n            if task in coprocessor_tasks:\n                current_tasks.append(task)\n            elif task in main_tasks:\n                if current_tasks:\n                    calls += 1\n                    current_tasks = []\n                main_tasks.remove(task)\n\n        if current_tasks:\n            calls += 1\n\n        return calls\n\n    N, M = map(int, stdin.readline().split())\n    E = list(map(int, stdin.readline().split()))\n    dependencies = [stdin.readline() for _ in range(M)]\n\n    result = count_minimal_calls(N, M, E, dependencies)\n    return str(result) ",
        "test": "",
        "num_ids": 585,
        "indeed": false
    },
    {
        "number": 1478,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_comments(comments_feed: str) -> list:\n        comments = []\n        for comment in comments_feed.split(','):\n            comment_parts = comment.split(',')\n            comments.append({\n                'text': comment_parts[0],\n                'replies': int(comment_parts[1]),\n                'children': comment_parts[2:]\n            })\n        return comments\n\n    def build_comments_tree(comments: list) -> list:\n        comments_tree = []\n        for comment in comments:\n            if not comment['children']:\n                comments_tree.append(comment)\n            else:\n                for child in comment['children']:\n                    for c in comments:\n                        if c['text'] == child:\n                            c['parent'] = comment['text']\n                            break\n        return comments_tree\n\n    def find_max_depth(comments_tree: list, depth: int = 0) -> int:\n        max_depth = depth\n        for comment in comments_tree:\n            if comment.get('children'):\n                max_depth = max(max_depth, find_max_depth(comment['children'], depth + 1))\n        return max_depth\n\n    def print_comments(comments_tree: list, depth: int) -> str:\n        output = ''\n        if depth == 0:\n            for comment in comments_tree:\n                output += comment['text'] + ' '\n            output = output.strip()\n        else:\n            for comment in comments_tree:\n                output += print_comments(comment.get('children', []), depth - 1)\n        return output\n\n    comments_feed = parse_comments(stdin)\n    comments_tree = build_comments_tree(comments_feed)\n    max_depth = find_max_depth(comments_tree)\n    output = str(max_depth) + '\\n'\n    output += print_comments(comments_tree, max_depth)\n    return output",
        "test": "",
        "num_ids": 464,
        "indeed": false
    },
    {
        "number": 1479,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    park = [list(stdin.readline().strip()) for _ in range(n)]\n    spider_positions = [(i, j) for i in range(n) for j in range(m) if park[i][j] != \".\"]\n    spider_directions = {\"L\": (-1, 0), \"R\": (1, 0), \"U\": (0, -1), \"D\": (0, 1)}\n    spider_moves = [(i, j + 1) if park[i][j] in \"LR\" else (i + 1, j) for i, j in spider_positions]\n    spider_counts = [0] * m\n\n    for i, j in spider_positions:\n        dx, dy = spider_directions[park[i][j]]\n        x, y = i + dx, j + dy\n        if 0 <= x < n and 0 <= y < m:\n            spider_counts[j] += 1\n\n    return \" \".join(map(str, spider_counts))",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 1480,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    children = list(range(1, n + 1))\n    leaders = []\n    eliminated = []\n\n    for i in range(k):\n        a_i = int(input())\n        leader_index = children.index(leaders[-1]) if leaders else 0\n        eliminated_index = (leader_index + a_i) % n\n        eliminated.append(children[eliminated_index])\n        leaders.append(children[eliminated_index - 1])\n        children.remove(children[eliminated_index])\n\n    return \" \".join(map(str, eliminated))",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 1481,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(list(stdin.readline().strip()))\n\n    def count_adjacent_os(board: list, i: int, j: int) -> int:\n        adjacent_os = 0\n        for x, y in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            if 0 <= i + x < n and 0 <= j + y < n:\n                if board[i + x][j + y] == 'o':\n                    adjacent_os += 1\n        return adjacent_os\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x' and count_adjacent_os(board, i, j) % 2 != 0:\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 253,
        "indeed": false
    },
    {
        "number": 1482,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    segments = list(map(int, input().split()))\n\n    result = []\n    for i in range(k):\n        result.append([segments[i]] + [j for j in range(1, n * k + 1) if j != segments[i] and j not in segments])\n\n    return \" \".join(map(str, [x for y in result for x in y]))",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 1483,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    result = []\n\n    for a in range(1, n + 1):\n        current = a\n        while True:\n            if p[current - 1] == current:\n                break\n            current = p[current - 1]\n        result.append(current)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 1484,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    MOD = 998244353\n\n    def is_bad(l: int, r: int) -> bool:\n        if (r - l + 1) % 2 == 0:\n            return False\n        for i in range(1, (r - l + 1) // 2 + 1):\n            if a[l + i:r - i + 1] != a[l:l + i] or a[l + i:r - i + 1] != a[r - i + 1:r + 1]:\n                return False\n        return True\n\n    def count_good_arrays(i: int, replaced: int) -> int:\n        if i == n:\n            return 1\n        if a[i] != -1:\n            return count_good_arrays(i + 1, replaced)\n        result = 0\n        for j in range(1, k + 1):\n            a[i] = j\n            if not is_bad(i, i):\n                result += count_good_arrays(i + 1, replaced)\n                result %= MOD\n        a[i] = -1\n        return result\n\n    return str(count_good_arrays(0, 0) % MOD)",
        "test": "",
        "num_ids": 342,
        "indeed": false
    },
    {
        "number": 1485,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def count_cards(x, y):\n        gray_count = y - x\n        white_count = 0\n        gray_and_white_count = 0\n\n        for i in range(n):\n            if a[i] % 2 == 0:\n                white_count += 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] == a[j]:\n                    gray_and_white_count += 1\n\n        return gray_count + white_count + 2 * gray_and_white_count\n\n    result = 0\n    for x in range(1, m):\n        for y in range(x + 1, m + 1):\n            result += count_cards(x, y)\n\n    return str(result)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 1486,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    x = list(map(int, x.split()))\n    res = []\n\n    for i in range(n):\n        min_cost = float('inf')\n        max_cost = 0\n        for j in range(n):\n            if i != j:\n                cost = abs(x[i] - x[j])\n                min_cost = min(min_cost, cost)\n                max_cost = max(max_cost, cost)\n        res.append((min_cost, max_cost))\n\n    return '\\n'.join(['{} {}'.format(r[0], r[1]) for r in res])",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 1487,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    p = ''\n\n    for i in range(n):\n        if s[i] != t[i]:\n            p += '1'\n        else:\n            p += '0'\n\n    if p.count('1') % 2 == 0:\n        return p\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1488,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    total_distance = 0\n    for i in range(n):\n        total_distance += abs(a[i] - a[i - 1])\n\n    numerator = total_distance * 2\n    denominator = (n - 1) * n\n\n    return f\"{numerator} {denominator}\"",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1489,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    vertical_lines = set()\n    horizontal_lines = set()\n\n    for x, y in points:\n        vertical_lines.add(x)\n        horizontal_lines.add(y)\n\n    return (len(vertical_lines) + 1) * (len(horizontal_lines) + 1) % (10**9 + 7)",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 1490,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    a.sort()\n    k = 0\n    result = []\n    for i in range(1, 10**9):\n        if i not in a and i <= m:\n            result.append(i)\n            k += 1\n            if k == n:\n                break\n    return f\"{k}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1491,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a.sort()\n    count_square = 0\n    count_not_square = 0\n    for i in range(n):\n        if (i + 1) ** 2 <= a[i]:\n            count_square += 1\n        else:\n            count_not_square += 1\n    return str(min(count_square, count_not_square))",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 1492,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    forest = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(x: int, y: int) -> int:\n        queue = [(x, y)]\n        visited = set()\n        time = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny) and (nx, ny) not in visited and forest[nx][ny] == \".\":\n                        forest[nx][ny] = \"X\"\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n            time += 1\n\n        return time\n\n    max_time = 0\n    for i in range(n):\n        for j in range(m):\n            if forest[i][j] == \"X\":\n                forest[i][j] = \".\"\n                time = bfs(i, j)\n                max_time = max(max_time, time)\n\n    return f\"{max_time}\\n{''.join([''.join(row) + '\\n' for row in forest])}\"",
        "test": "",
        "num_ids": 400,
        "indeed": false
    },
    {
        "number": 1493,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(row, col, color):\n        if board[row][col] == \".\":\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < n and 0 <= new_col < m and board[new_row][new_col] == color:\n                    return False\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == \".\":\n                if is_valid(i, j, \"W\"):\n                    board[i][j] = \"W\"\n                elif is_valid(i, j, \"B\"):\n                    board[i][j] = \"B\"\n                else:\n                    board[i][j] = \"-\"\n\n    return \"\\n\".join([\"\".join(row) for row in board])",
        "test": "",
        "num_ids": 289,
        "indeed": false
    },
    {
        "number": 1494,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p = stdin.split(\"\\n\")\n    n = len(s)\n    m = len(p)\n    dp = [0] * (n + 1)\n    for i in range(n - m + 1):\n        if s[i:i + m] == p:\n            dp[i + m] = dp[i] + 1\n        else:\n            dp[i + m] = dp[i]\n    return \" \".join(str(x) for x in dp)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 1495,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a.sort()\n    operations = 0\n\n    for i in range(1, n):\n        operations += abs(a[i] - a[0])\n\n    return str(operations)",
        "test": "",
        "num_ids": 64,
        "indeed": false
    },
    {
        "number": 1496,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def convert_to_burles(cost, exchange_rate):\n        return cost * exchange_rate\n\n    def find_min_day_index(n, m, k, s, a, b, gadgets):\n        min_day_index = -1\n        for i in range(n):\n            burles_per_dollar = a[i]\n            burles_per_pound = b[i]\n\n            for j in range(m):\n                gadget_type, gadget_cost = gadgets[j]\n\n                if gadget_type == 1:\n                    cost_in_burles = convert_to_burles(gadget_cost, burles_per_dollar)\n                else:\n                    cost_in_burles = convert_to_burles(gadget_cost, burles_per_pound)\n\n                if cost_in_burles <= s:\n                    s -= cost_in_burles\n                    k -= 1\n\n                    if k == 0:\n                        min_day_index = i + 1\n                        break\n\n            if k == 0:\n                break\n\n        return min_day_index\n\n    def find_gadgets(n, m, k, s, a, b, gadgets, min_day_index):\n        result = []\n        burles_per_dollar = a[min_day_index - 1]\n        burles_per_pound = b[min_day_index - 1]\n\n        for j in range(m):\n            gadget_type, gadget_cost = gadgets[j]\n\n            if gadget_type == 1:\n                cost_in_burles = convert_to_burles(gadget_cost, burles_per_dollar)\n            else:\n                cost_in_burles = convert_to_burles(gadget_cost, burles_per_pound)\n\n            if cost_in_burles <= s:\n                s -= cost_in_burles\n                k -= 1\n                result.append((j + 1, min_day_index))\n\n            if k == 0:\n                break\n\n        return result\n\n    lines = stdin.split('\\n')\n    n, m, k, s = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n    gadgets = [list(map(int, line.split())) for line in lines[3:]]\n\n    min_day_index = find_min_day_index(n, m, k, s, a, b, gadgets)\n\n    if min_day_index == -1:\n        return '-1\\n'\n\n    gadgets_result = find_gadgets(n, m, k, s, a, b, gadgets, min_day_index)\n\n    output = [str(min_day_index)]\n    for gadget in gadgets_result:\n        output.append(' '.join(map(str, gadget)))\n\n    return '\\n'.join(output) + '\\n'",
        "test": "",
        "num_ids": 776,
        "indeed": false
    },
    {
        "number": 1497,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    room = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n    max_clean_rows = 0\n\n    for col in range(n):\n        clean_count = 0\n        dirty_count = 0\n        for row in range(n):\n            if room[row][col] == 1:\n                clean_count += 1\n            else:\n                dirty_count += 1\n        if clean_count > dirty_count:\n            max_clean_rows = max(max_clean_rows, clean_count)\n        else:\n            max_clean_rows = max(max_clean_rows, dirty_count)\n\n    return str(max_clean_rows)",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1498,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_available(servers, t, k):\n        return servers[-k:] == [0] * k\n\n    def perform_task(servers, t, k, d):\n        servers[-k:] = [i + 1 for i in range(k)]\n        for i in range(d):\n            servers[t + i] = 0\n\n    def busy_servers(servers, t):\n        return sum(servers[t - 1:t + 1])\n\n    n, q = map(int, stdin.readline().split())\n    servers = [0] * n\n    result = []\n\n    for _ in range(q):\n        t, k, d = map(int, stdin.readline().split())\n        if is_available(servers, t, k):\n            perform_task(servers, t, k, d)\n            result.append(str(busy_servers(servers, t)))\n        else:\n            result.append(\"-1\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 251,
        "indeed": false
    },
    {
        "number": 1499,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = []\n    for i in range(1, n + 1):\n        result.append(i * 2 - 1)\n        result.append(i * 2)\n    for i in range(n + 1, m + 1):\n        result.append(i)\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1501,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    p = stdin.readline().strip()\n    y = list(map(int, stdin.readline().split()))\n\n    mod = 10**9 + 7\n\n    def count_substrings(s: str, p: str) -> int:\n        m, n = len(p), len(s)\n        p_hash = hash(p)\n        p_pow = [1]\n        for i in range(n):\n            p_pow.append(p_pow[-1] * 26 % mod)\n\n        s_hash, s_pow = 0, 1\n        for i in range(m):\n            s_hash = (s_hash * 26 + ord(s[i])) % mod\n            s_pow = s_pow * 26 % mod\n\n        result = 0\n        for i in range(m - 1, n):\n            if s_hash == p_hash and (i - m + 1) in y:\n                result = (result + p_pow[i - m + 1]) % mod\n            s_hash = (s_hash + mod - ord(s[i - m + 1]) * s_pow) % mod\n\n        return result\n\n    result = 0\n    for i in range(26):\n        s = p + chr(ord('a') + i)\n        result += count_substrings(s, p)\n        result %= mod\n\n    return str(result)",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 1502,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    return str(2**a - 1)",
        "test": "",
        "num_ids": 24,
        "indeed": false
    },
    {
        "number": 1503,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    perms = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def common_prefix_suffix(a, b):\n        common_prefix = 0\n        while common_prefix < n and a[common_prefix] == b[common_prefix]:\n            common_prefix += 1\n        common_suffix = 0\n        while common_suffix < n and a[-common_suffix - 1] == b[-common_suffix - 1]:\n            common_suffix += 1\n        return common_prefix, common_suffix\n\n    def count_ways(common_prefix, common_suffix):\n        if common_prefix == 0 and common_suffix == 0:\n            return 1\n        return (common_prefix + 1) * (common_suffix + 1)\n\n    common_prefix, common_suffix = common_prefix_suffix(perms[0], perms[1])\n    for i in range(2, m):\n        new_common_prefix, new_common_suffix = common_prefix_suffix(perms[0], perms[i])\n        common_prefix = min(common_prefix, new_common_prefix)\n        common_suffix = min(common_suffix, new_common_suffix)\n\n    return count_ways(common_prefix, common_suffix)",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 1504,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def intersection_length(a, b, c, d):\n        return max(0, min(a[1], c[1]) - max(a[0], c[0]))\n\n    def total_intersection(a, b, c, d, k):\n        total = 0\n        for i in range(len(a)):\n            total += intersection_length([a[i], b[i]], [c[i], d[i]])\n        return total\n\n    def min_steps(n, k, l1, r1, l2, r2):\n        a = [[l1, r1] for _ in range(n)]\n        b = [[l2, r2] for _ in range(n)]\n        if total_intersection(a, b, a, b, k) >= k:\n            return 0\n        steps = 0\n        while total_intersection(a, b, a, b, k) < k:\n            for i in range(n):\n                if a[i][0] > b[i][0]:\n                    a[i][0] -= 1\n                else:\n                    a[i][1] += 1\n                if b[i][0] > a[i][0]:\n                    b[i][0] -= 1\n                else:\n                    b[i][1] += 1\n            steps += 1\n        return steps\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        n, k = map(int, stdin.readline().strip().split())\n        l1, r1 = map(int, stdin.readline().strip().split())\n        l2, r2 = map(int, stdin.readline().strip().split())\n        result.append(min_steps(n, k, l1, r1, l2, r2))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 466,
        "indeed": false
    },
    {
        "number": 1505,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    px, py, vx, vy, a, b, c, d = map(int, stdin.split())\n\n    # Calculate the coordinates of the arrow points\n    tip_x = px + vx * a\n    tip_y = py + vy * a\n\n    base_left_x = px - b * vy\n    base_left_y = py + b * vx\n\n    base_right_x = px + b * vy\n    base_right_y = py - b * vx\n\n    rect_left_x = px - c * vx\n    rect_left_y = py + c * vy\n\n    rect_right_x = px + c * vx\n    rect_right_y = py - c * vy\n\n    # Output the coordinates of the arrow points\n    output = f\"{tip_x:.10f} {tip_y:.10f}\\n\"\n    output += f\"{base_left_x:.10f} {base_left_y:.10f}\\n\"\n    output += f\"{base_right_x:.10f} {base_right_y:.10f}\\n\"\n    output += f\"{rect_left_x:.10f} {rect_left_y:.10f}\\n\"\n    output += f\"{px:.10f} {py:.10f}\\n\"\n    output += f\"{rect_right_x:.10f} {rect_right_y:.10f}\\n\"\n    output += f\"{tip_x:.10f} {tip_y:.10f}\\n\"\n\n    return output",
        "test": "",
        "num_ids": 406,
        "indeed": false
    },
    {
        "number": 1506,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 10**9 + 7\n    f_a = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            f_a += a[M - 1]\n            M = i\n    return str(f_a % mod)",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1507,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    entrances = list(stdin.split()[1])\n    doors = [0] * 26\n\n    for i in range(n):\n        entrance = ord(entrances[i]) - 65\n        doors[entrance] += 1\n\n        if sum(doors) > k:\n            return \"YES\"\n\n        for j in range(26):\n            if doors[j] == 0:\n                continue\n            if i >= doors[j]:\n                doors[j] -= 1\n\n    return \"NO\"",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1508,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = sorted(list(map(int, stdin.split(\"\\n\")[1].split())), reverse=True)\n    x = []\n    for i in range(n):\n        if a[i] > 0:\n            x.append(a[i])\n        else:\n            x.append(a[i] - 1)\n            x.append(a[i] + 1)\n    return \" \".join(map(str, x))",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1509,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def f(l, r):\n        return sum(1 for x in a if l <= x <= r)\n\n    result = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            result += f(l, r)\n\n    return str(result)",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1510,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a.sort()\n    b.sort(reverse=True)\n\n    operations = 0\n\n    for i in range(n):\n        if a[i] < b[i]:\n            operations += b[i] - a[i]\n\n    return str(operations)",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 1511,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    instructions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    locked_cores = set()\n    locked_cells = set()\n    core_lock_cycle = [0] * n\n\n    for cycle in range(1, m + 1):\n        cells_to_lock = set()\n        for core_id, core_instructions in enumerate(instructions, 1):\n            if core_id in locked_cores:\n                continue\n\n            instruction = core_instructions[(cycle - 1) % m]\n            if instruction == 0:\n                continue\n\n            if instruction in cells_to_lock:\n                locked_cores.add(core_id)\n                core_lock_cycle[core_id - 1] = cycle\n            else:\n                cells_to_lock.add(instruction)\n\n    return '\\n'.join(map(str, core_lock_cycle))",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1512,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    records = []\n    for i in range(n):\n        record = True\n        for j in range(i):\n            if p[j] >= p[i]:\n                record = False\n                break\n        if record:\n            records.append(p[i])\n\n    if len(records) == n:\n        return str(min(p))\n    else:\n        for i in range(n):\n            if p[i] not in records:\n                return str(p[i])",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 1513,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    broken_segments = sorted(map(int, stdin.split('\\n')[1].split()))\n\n    def binary_search(length: int) -> bool:\n        pieces_used = 1\n        current_position = broken_segments[0]\n        for i in range(1, n):\n            if broken_segments[i] - current_position > length:\n                pieces_used += 1\n                current_position = broken_segments[i]\n        return pieces_used <= k\n\n    left, right = 1, m\n    while left < right:\n        mid = (left + right) // 2\n        if binary_search(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return str(left)",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 1514,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_permutation(b, c):\n        p = [0] * (n - 1)\n        for i in range(n - 1):\n            if b[i] == c[i]:\n                p[i] = i + 1\n            elif b[i] == b[i + 1]:\n                p[i] = i + 2\n            else:\n                p[i] = i + 1\n        return p\n\n    def recover_array(b, c, p):\n        a = [0] * n\n        for i in range(n - 1):\n            if p[i] == i + 1:\n                a[i] = b[i]\n                a[i + 1] = c[i]\n            elif p[i] == i + 2:\n                a[i] = c[i]\n                a[i + 1] = b[i]\n        a[0] = b[0]\n        a[n - 1] = c[n - 2]\n        return a\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    b_prime = list(map(int, stdin[1].split()))\n    c_prime = list(map(int, stdin[2].split()))\n\n    if len(b_prime) != n - 1 or len(c_prime) != n - 1:\n        return -1\n\n    p = find_permutation(b_prime, c_prime)\n    if p[0] == 0:\n        return -1\n\n    a = recover_array(b_prime, c_prime, p)\n    return ' '.join(map(str, a))",
        "test": "",
        "num_ids": 413,
        "indeed": false
    },
    {
        "number": 1515,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x = map(int, stdin.split())\n    if p == 1:\n        return \"Impossible\"\n    else:\n        result = \"1\" + \"0\" * (p - 1)\n        return result",
        "test": "",
        "num_ids": 57,
        "indeed": false
    },
    {
        "number": 1516,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    mod = 998244353\n    result = 0\n\n    for i in range(n):\n        for j in range(n):\n            p = len(str(a[i]))\n            q = len(str(a[j]))\n\n            if p >= q:\n                f = \"\"\n                for k in range(p - q + 1):\n                    f += str(a[i])[k]\n                for k in range(p - q + 1, p):\n                    f += str(a[j])[k - p + q]\n                for k in range(p - 1, p - q - 1, -1):\n                    f += str(a[i])[k]\n                f += str(a[j])[-1]\n            else:\n                f = \"\"\n                for k in range(q - p):\n                    f += str(a[j])[k]\n                for k in range(q - p, q - 1):\n                    f += str(a[i])[k - q + p]\n                for k in range(q - 2, p - 1, -1):\n                    f += str(a[j])[k]\n                f += str(a[i])[-1]\n\n            result += int(f)\n            result %= mod\n\n    return str(result)",
        "test": "",
        "num_ids": 361,
        "indeed": false
    },
    {
        "number": 1517,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 1000000007\n    result = 0\n\n    for i in range(1, n + 1):\n        result += (n - 1) * i * (2 * n - i) // 2\n\n    return str(result % mod)\n",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 1518,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def sort_array(a: List[int]) -> int:\n        n = len(a)\n        operations = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    operations.append((i, j))\n                    a[i], a[j] = a[j], a[i]\n        return operations\n\n    def find_operations(a: List[int]) -> Tuple[int, List[Tuple[int, int]]]:\n        n = len(a)\n        operations = []\n        k = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (j - i + 1) == 2 or (j - i + 1) == 3:\n                    if a[i] > a[j]:\n                        operations.append((i, j))\n                        a[i], a[j] = a[j], a[i]\n                        k += 1\n        return k, operations\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    k, operations = find_operations(a)\n\n    output = [str(k)]\n    for operation in operations:\n        output.append(f\"{operation[0] + 1} {operation[1] + 1}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 434,
        "indeed": false
    },
    {
        "number": 1519,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, a = map(int, stdin.split()[:3])\n    customers = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    customers.sort(key=lambda x: x[0])\n\n    breaks = 0\n    current_time = 0\n    for customer in customers:\n        if current_time + a <= customer[0]:\n            breaks += 1\n            current_time += a\n        if current_time + customer[1] > L:\n            return str(breaks)\n        current_time += customer[1]\n\n    while current_time + a <= L:\n        breaks += 1\n        current_time += a\n\n    return str(breaks)",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 1520,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    strings = []\n    for _ in range(n):\n        strings.append(stdin.readline().strip())\n\n    def string_multiplication(s: str, t: str) -> str:\n        return t + s[0] + t.join(s[1:]) + t\n\n    def string_beauty(s: str) -> int:\n        max_length = 1\n        current_length = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n        return max(max_length, current_length)\n\n    result = strings[0]\n    for i in range(1, n):\n        result = string_multiplication(result, strings[i])\n\n    return str(string_beauty(result))\n",
        "test": "",
        "num_ids": 242,
        "indeed": false
    },
    {
        "number": 1521,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, n = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()[1:]))\n    inserted = set()\n    for i, num in enumerate(numbers):\n        if h(num, p) in inserted:\n            return str(i)\n        inserted.add(h(num, p))\n    return \"-1\"\n\ndef",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 1522,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    keys_needed = 0\n    keys_in_hand = set()\n\n    for i in range(0, 2 * n - 2, 2):\n        door_type = s[i]\n        next_room_key_type = s[i + 1]\n\n        if door_type.lower() != next_room_key_type:\n            if next_room_key_type not in keys_in_hand:\n                keys_needed += 1\n            keys_in_hand.add(next_room_key_type)\n\n    return str(keys_needed)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1523,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    b = list(map(int, stdin.split()[2 + n:2 + 2 * n]))\n\n    total_time = 0\n    jobs = [0] * k\n\n    for i in range(n):\n        if jobs[a[i] - 1] == 0:\n            jobs[a[i] - 1] = 1\n        else:\n            total_time += b[i]\n\n    return str(total_time)",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 1524,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    N = len(S)\n    children = [0] * N\n    children[0] = 1\n    children[-1] = 1\n\n    for _ in range(10**100):\n        for i in range(N):\n            if S[i] == 'L':\n                children[i - 1] += children[i]\n                children[i] = 0\n            elif S[i] == 'R':\n                children[i + 1] += children[i]\n                children[i] = 0\n\n    return ' '.join(map(str, children))",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1525,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    mod = 1_000_000_007\n\n    def count_amidakuji(H: int, W: int, K: int) -> int:\n        dp = [[0] * (H + 1) for _ in range(W + 1)]\n        dp[1][1] = 1\n\n        for w in range(2, W + 1):\n            for h in range(1, H + 1):\n                for k in range(1, h + 1):\n                    dp[w][h] += dp[w - 1][h - k]\n                    dp[w][h] %= mod\n\n        return dp[W][H]\n\n    amidakuji_count = count_amidakuji(H, W, K)\n    return str(amidakuji_count)",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 1526,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    count = 0\n\n    while A != B or B != C:\n        if A == B and B == C:\n            break\n        elif A == B:\n            C += 1\n            count += 1\n        elif B == C:\n            A += 1\n            count += 1\n        elif A == C:\n            B += 2\n            count += 1\n        else:\n            A += 2\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1527,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.readline().split())\n    maze = [list(stdin.readline().strip()) for _ in range(H)]\n    start_row, start_col = 0, 0\n    goal_row, goal_col = H - 1, W - 1\n\n    def is_valid(row, col):\n        return 0 <= row < H and 0 <= col < W and maze[row][col] == '.'\n\n    def bfs(start_row, start_col, goal_row, goal_col):\n        visited = [[False] * W for _ in range(H)]\n        visited[start_row][start_col] = True\n        queue = [(start_row, start_col)]\n        distance = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                row, col = queue.pop(0)\n                if row == goal_row and col == goal_col:\n                    return distance\n\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_row, new_col = row + dr, col + dc\n                    if is_valid(new_row, new_col) and not visited[new_row][new_col]:\n                        visited[new_row][new_col] = True\n                        queue.append((new_row, new_col))\n\n            distance += 1\n\n        return -1\n\n    return str(bfs(start_row, start_col, goal_row, goal_col))",
        "test": "",
        "num_ids": 386,
        "indeed": false
    },
    {
        "number": 1528,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    total_layers = 2 ** (N + 1) - 1\n    patties_per_layer = 2 ** N\n\n    if X > total_layers:\n        return \"Error: X should be less than or equal to the total number of layers in the burger.\"\n\n    patties_in_bottom_x_layers = X * patties_per_layer\n\n    return str(patties_in_bottom_x_layers)",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 1529,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    result = []\n    for _ in range(n):\n        sentence = stdin.readline().strip()\n        if sentence.endswith(\"lala.\") and not sentence.startswith(\"miao.\"):\n            result.append(\"Freda's\")\n        elif sentence.startswith(\"miao.\") and not sentence.endswith(\"lala.\"):\n            result.append(\"Rainbow's\")\n        else:\n            result.append(\"OMG>.< I don't know!\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1531,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Calculate the total esthetic appeal of the woodland belt\n    total_appeal = sum(a)\n\n    # Find the trees with equal esthetic appeal\n    equal_trees = []\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            equal_trees.append(i + 1)\n\n    # Calculate the maximum possible esthetic appeal\n    max_appeal = total_appeal - min(a[0] + a[n - 1], a[0], a[n - 1])\n\n    # Calculate the number of trees to cut down\n    k = n - 2\n    for i in range(n - 1):\n        if a[i] + a[i + 1] <= max_appeal:\n            k = min(k, i + 1, n - i - 2)\n\n    # Calculate the esthetic appeal after cutting down the trees\n    cut_down_trees = [i for i in range(1, n + 1) if i not in equal_trees and i not in [1, n]]\n    for i in range(k):\n        total_appeal -= a[cut_down_trees[i] - 1]\n\n    return f\"{max_appeal} {k}\\n{' '.join(map(str, cut_down_trees[:k]))}\\n\"",
        "test": "",
        "num_ids": 369,
        "indeed": false
    },
    {
        "number": 1532,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    I = [0] * (n - 1)\n\n    for k in range(2, n + 1):\n        I[k - 2] = 1\n        for i in range(2, k // 2 + 1):\n            if k % i == 0:\n                I[k - 2] = max(I[k - 2], i)\n        I[k - 2] = gcd(I[k - 2], k - I[k - 2])\n\n    return \" \".join(map(str, I))\n\ndef",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1533,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    names = [stdin.readline().strip() for _ in range(n)]\n    seen = set()\n    result = []\n\n    for name in names:\n        if name in seen:\n            result.append(\"YES\")\n        else:\n            seen.add(name)\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 1534,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    count_a = stdin.count('a')\n    count_b = stdin.count('b')\n\n    if count_a == 0 or count_b == 0:\n        return len(stdin)\n\n    if count_a == count_b:\n        return len(stdin) - 1\n\n    if count_a > count_b:\n        return len(stdin) - (count_a - count_b)\n\n    return len(stdin) - (count_b - count_a)",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 1535,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_0, y_0 = map(int, stdin.split()[:3])\n    stormtroopers = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_on_line(x1, y1, x2, y2):\n        return (x1 - x2) * (y1 - y2) == 0\n\n    count = 0\n    for x, y in stormtroopers:\n        if is_on_line(x, y, x_0, y_0):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1536,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_perfectly_balanced(a, b, c):\n        return min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and \\\n               min(a[1], b[1]) <= c[1] <= max(a[1], b[1]) and \\\n               min(a[2], b[2]) <= c[2] <= max(a[2], b[2])\n\n    def find_pair(points, removed):\n        for i in range(len(points)):\n            if i in removed:\n                continue\n            for j in range(i + 1, len(points)):\n                if j in removed:\n                    continue\n                if not is_perfectly_balanced(points[i], points[j], points[k]):\n                    return i, j\n        return None\n\n    def remove_points(points, removed, pairs):\n        for i in range(len(points) // 2):\n            pair = find_pair(points, removed)\n            if pair is None:\n                break\n            removed.add(pair[0])\n            removed.add(pair[1])\n            pairs.append(pair)\n\n    n = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    removed = set()\n    pairs = []\n    remove_points(points, removed, pairs)\n\n    return '\\n'.join(' '.join(map(str, pair)) for pair in pairs)",
        "test": "",
        "num_ids": 374,
        "indeed": false
    },
    {
        "number": 1537,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def count_white_lines(board: List[List[str]]) -> int:\n        white_rows = sum(all(cell == 'W' for cell in row) for row in board)\n        white_cols = sum(all(board[i][j] == 'W' for i in range(n)) for j in range(n))\n        return white_rows + white_cols\n\n    max_white_lines = 0\n    for i in range(n - k + 1):\n        for j in range(n - k + 1):\n            erased_board = [row.copy() for row in board]\n            for r in range(i, i + k):\n                for c in range(j, j + k):\n                    erased_board[r][c] = 'W'\n            max_white_lines = max(max_white_lines, count_white_lines(erased_board))\n\n    return str(max_white_lines)",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 1538,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    boxes = sorted(list(map(int, stdin.split('\\n')[1].split())), reverse=True)\n\n    visible_boxes = 0\n    for i in range(n):\n        if visible_boxes >= n - i:\n            break\n        if i == 0 or boxes[i] < boxes[i - 1]:\n            visible_boxes += 1\n\n    return str(visible_boxes)",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 1539,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    l = list(map(int, stdin.split('\\n')[1].split()))\n    d = list(map(int, stdin.split('\\n')[2].split()))\n\n    l.sort()\n    d.sort()\n\n    if n == 1:\n        return str(d[0])\n    elif n == 2:\n        if l[0] == l[1]:\n            return str(0)\n        else:\n            return str(d[0] + d[1])\n    else:\n        max_length = l[-1]\n        max_length_count = l.count(max_length)\n        if max_length_count > n // 2:\n            return str(0)\n        else:\n            energy = 0\n            for i in range(n - 1, n - max_length_count - 1, -1):\n                energy += d[i]\n            return str(energy)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 1540,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = [[int(x) for x in stdin.readline().split()] for _ in range(n)]\n    log = [list(map(int, stdin.readline().split())) for _ in range(k)]\n\n    notifications = [0] * n\n    for x, y in log:\n        for i in range(n):\n            if a[i][y - 1] and i != x - 1:\n                notifications[i] += 1\n\n    return \" \".join(map(str, notifications))",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 1541,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    pivot = s.index(\"^\")\n    left_weights = 0\n    right_weights = 0\n\n    for i in range(pivot):\n        if s[i].isdigit():\n            left_weights += int(s[i])\n\n    for i in range(pivot + 1, len(s)):\n        if s[i].isdigit():\n            right_weights += int(s[i])\n\n    if left_weights > right_weights:\n        return \"left\"\n    elif left_weights < right_weights:\n        return \"right\"\n    else:\n        return \"balance\"",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 1542,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, q, m = map(int, stdin.split())\n    x = sorted(x)\n    m = list(map(int, m.split()))\n    result = []\n\n    for i in range(q):\n        count = 0\n        for j in range(n):\n            if m[i] >= x[j]:\n                count += 1\n            else:\n                break\n        result.append(count)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1543,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_closest_disputed_city(cities, index):\n        left, right = index - 1, index + 1\n        while left >= 0 or right < len(cities):\n            if left >= 0 and cities[left][1] == 'P':\n                return left\n            if right < len(cities) and cities[right][1] == 'P':\n                return right\n            left -= 1\n            right += 1\n        return -1\n\n    def find_min_cost(cities):\n        total_cost = 0\n        for i in range(len(cities)):\n            if cities[i][1] == 'P':\n                continue\n            closest_disputed_city = find_closest_disputed_city(cities, i)\n            if closest_disputed_city == -1:\n                continue\n            total_cost += abs(cities[i][0] - cities[closest_disputed_city][0])\n        return total_cost\n\n    n = int(stdin.readline().strip())\n    cities = [tuple(map(str, stdin.readline().strip().split())) for _ in range(n)]\n\n    byteland_cities = [city for city in cities if city[1] == 'B']\n    berland_cities = [city for city in cities if city[1] == 'R']\n    disputed_cities = [city for city in cities if city[1] == 'P']\n\n    byteland_min_cost = find_min_cost(byteland_cities + disputed_cities)\n    berland_min_cost = find_min_cost(berland_cities + disputed_cities)\n\n    return str(byteland_min_cost + berland_min_cost)",
        "test": "",
        "num_ids": 433,
        "indeed": false
    },
    {
        "number": 1544,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str((2 ** 5) * (3 ** 3))",
        "test": "",
        "num_ids": 29,
        "indeed": false
    },
    {
        "number": 1545,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    a = list(map(int, stdin.readline().strip().split()))\n\n    mod = 10**9 + 7\n\n    def count_ways(start: int, end: int, max_len: int) -> int:\n        if max_len == 0:\n            return 1\n        if start >= end:\n            return 0\n        count = 0\n        for i in range(start, end):\n            if i - start + 1 > max_len:\n                break\n            if s[i] == s[start]:\n                continue\n            count += count_ways(i + 1, end, max_len - (i - start + 1))\n        return count\n\n    def max_len(start: int, end: int, max_len: int) -> int:\n        if max_len == 0:\n            return 0\n        if start >= end:\n            return 0\n        max_sub = 0\n        for i in range(start, end):\n            if i - start + 1 > max_len:\n                break\n            if s[i] == s[start]:\n                continue\n            max_sub = max(max_sub, i - start + 1 + max_len(i + 1, end, max_len - (i - start + 1)))\n        return max_sub\n\n    def min_substrings(start: int, end: int, max_len: int) -> int:\n        if max_len == 0:\n            return 0\n        if start >= end:\n            return 0\n        min_sub = float('inf')\n        for i in range(start, end):\n            if i - start + 1 > max_len:\n                break\n            if s[i] == s[start]:\n                continue\n            min_sub = min(min_sub, min_substrings(i + 1, end, max_len - (i - start + 1)))\n        return min_sub + 1\n\n    ways = count_ways(0, n, a[ord(s[0]) - ord('a')])\n    max_sub = max_len(0, n, a[ord(s[0]) - ord('a')])\n    min_sub = min_substrings(0, n, a[ord(s[0]) - ord('a')])\n\n    return f\"{ways % mod}\\n{max_sub}\\n{min_sub}\"",
        "test": "",
        "num_ids": 601,
        "indeed": false
    },
    {
        "number": 1546,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(order: list) -> bool:\n        for i in range(n):\n            a, b = order[i], order[(i + 1) % n]\n            if (a, b) not in pairs and (b, a) not in pairs:\n                return False\n        return True\n\n    for order in permutations(range(1, n + 1)):\n        if is_valid(order):\n            return ' '.join(map(str, order))\n\n    return '-1'",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 1547,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    table = [[0] * m for _ in range(n)]\n\n    for i in range(k):\n        query = stdin.split()[3 + i]\n        if query[0] == '1':\n            r, a = map(int, query[1:].split())\n            for j in range(m):\n                if table[r - 1][j] == 0:\n                    table[r - 1][j] = a\n                else:\n                    table[r - 1][j] = a\n        elif query[0] == '2':\n            c, a = map(int, query[1:].split())\n            for i in range(n):\n                if table[i][c - 1] == 0:\n                    table[i][c - 1] = a\n                else:\n                    table[i][c - 1] = a\n\n    return '\\n'.join([' '.join(map(str, row)) for row in table])",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1548,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sticks = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(sticks: list) -> bool:\n        for i in range(len(sticks) - 1):\n            if sticks[i] == sticks[i + 1]:\n                return False\n        return True\n\n    def get_max_distance(sticks: list) -> int:\n        max_distance = 0\n        for stick in sticks:\n            max_distance += stick * stick\n        return max_distance\n\n    sticks.sort(reverse=True)\n    if is_valid(sticks):\n        return str(get_max_distance(sticks))\n    else:\n        for i in range(len(sticks) - 1):\n            if sticks[i] == sticks[i + 1]:\n                sticks.pop(i + 1)\n                break\n        return str(get_max_distance(sticks))",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 1549,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    olympiads = list(map(int, stdin.split()[3:n + 3]))\n    years = list(map(int, stdin.split()[n + 3:n + 3 + q]))\n\n    host_cities = [0] * m\n    for i in range(n):\n        host_cities[olympiads[i] - 1] += 1\n\n    for i in range(n, len(years) + n):\n        host_cities_copy = host_cities.copy()\n        for j in range(m):\n            if host_cities_copy[j] == min(host_cities_copy):\n                host_cities[j] += 1\n                olympiads.append(j + 1)\n                break\n\n    result = []\n    for year in years:\n        result.append(olympiads[year - 1])\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1550,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    digits = list(stdin.readline().strip())\n\n    # Convert digits to integers\n    for i in range(n):\n        digits[i] = int(digits[i])\n\n    # Add 1 to all digits\n    for i in range(n):\n        digits[i] += 1\n        if digits[i] == 10:\n            digits[i] = 0\n\n    # Shift digits to the right\n    digits.sort()\n\n    # Convert digits back to strings\n    for i in range(n):\n        digits[i] = str(digits[i])\n\n    return \"\".join(digits)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 1551,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(t: float) -> bool:\n        for x, v, t_i in people:\n            if t_i == 1:\n                if x - v * t <= 0:\n                    return False\n            else:\n                if x + v * t >= 10**6:\n                    return False\n        return True\n\n    def find_min_time() -> float:\n        left, right = 0.0, 10**6\n        while right - left > 10**-6:\n            mid = (left + right) / 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid\n        return right\n\n    n, s = map(int, stdin.readline().split())\n    people = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    return f\"{find_min_time():.16f}\"",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 1552,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_teams(n, t):\n        teams = []\n        programmers = []\n        mathematicians = []\n        sportsmen = []\n\n        for i in range(n):\n            if t[i] == 1:\n                programmers.append(i + 1)\n            elif t[i] == 2:\n                mathematicians.append(i + 1)\n            else:\n                sportsmen.append(i + 1)\n\n        for p in programmers:\n            for m in mathematicians:\n                if p != m:\n                    for s in sportsmen:\n                        if p != s and m != s:\n                            teams.append((p, m, s))\n\n        return teams\n\n    n = int(stdin.split('\\n')[0])\n    t = list(map(int, stdin.split('\\n')[1].split()))\n\n    teams = find_teams(n, t)\n\n    if not teams:\n        return '0'\n    else:\n        output = [str(len(teams))] + [f'{team[0]} {team[1]} {team[2]}' for team in teams]\n        return '\\n'.join(output)",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 1553,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n\n    shelves = [0] * (h + 1)\n    for i in range(n):\n        for j in range(a[i], h + 1):\n            if shelves[j] == 0:\n                shelves[j] = i + 1\n                break\n            elif j > 0 and shelves[j - 1] == shelves[j]:\n                shelves[j - 1] = i + 1\n                break\n\n    return str(max(shelves))",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1554,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pearls = list(map(int, stdin.split('\\n')[1].split()))\n\n    segments = []\n    current_segment = [1, 1]\n\n    for i in range(2, n + 1):\n        if pearls[i - 1] == pearls[current_segment[-1] - 1]:\n            current_segment[-1] = i\n        else:\n            segments.append(current_segment)\n            current_segment = [i, i]\n\n    segments.append(current_segment)\n\n    if len(segments) == 1 and segments[0] == [1, n]:\n        return \"-1\\n\"\n\n    output = str(len(segments)) + \"\\n\"\n    for segment in segments:\n        output += \" \".join(map(str, segment)) + \"\\n\"\n\n    return output",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 1555,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def evaluate(i: int, j: int, value: int) -> bool:\n        if a[i][j] == \">\":\n            return value > dish_values[j]\n        elif a[i][j] == \"<\":\n            return value < dish_values[j]\n        else:\n            return value == dish_values[j]\n\n    dish_values = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \">\":\n                dish_values[j] = max(dish_values[j], dish_values[i] + 1)\n            elif a[i][j] == \"<\":\n                dish_values[i] = min(dish_values[i], dish_values[j] - 1)\n\n    for i in range(n):\n        for j in range(m):\n            if not evaluate(i, j, dish_values[i]):\n                return \"No\"\n\n    return \"Yes\"\n",
        "test": "",
        "num_ids": 294,
        "indeed": false
    },
    {
        "number": 1556,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(k):\n        min_index = a.index(min(a))\n        a[min_index] += x\n\n    for i in range(n):\n        a[i] = (a[i] + x) % x\n\n    return ' '.join(map(str, a))",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1557,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, a_1, c_1 = map(int, stdin.split()[0].split())\n    h_2, a_2 = map(int, stdin.split()[1].split())\n\n    n = 0\n    while h_1 > 0 and h_2 > 0:\n        if h_1 <= a_2:\n            h_2 -= h_1\n            h_1 = 0\n        else:\n            h_1 -= a_2\n            h_2 = 0\n        n += 1\n\n    if h_1 <= 0:\n        return f\"{n}\\n{'STRIKE' * (n - 1)}\\nHEAL\"\n    else:\n        return f\"{n}\\n{'STRIKE' * n}\"",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1558,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, avg = map(int, stdin.split())\n    exams = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        exams.append((a, b))\n\n    total_grade = 0\n    essays_count = 0\n\n    for exam in exams:\n        a, b = exam\n        if a < r:\n            grade = a + b\n            if grade > r:\n                grade = r\n            total_grade += grade\n        else:\n            total_grade += a\n\n    average = total_grade / n\n\n    if average >= avg:\n        return \"0\"\n\n    for exam in exams:\n        a, b = exam\n        if a < r:\n            grade = a + b\n            if grade > r:\n                grade = r\n            if grade >= avg:\n                essays_count += b\n\n    return str(essays_count)",
        "test": "",
        "num_ids": 231,
        "indeed": false
    },
    {
        "number": 1559,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A = map(int, stdin.split())\n    P = 1\n    while len(str(P)) < L:\n        P *= 10\n    X = A + 1\n    while True:\n        if str(X) == str(X)[0] * len(str(X)):\n            return str(X)\n        X += 1 ",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 1560,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, line = stdin.split('\\n')\n    n = int(n)\n\n    if n == 1:\n        return 0\n\n    count_b = line.count('b')\n    count_r = line.count('r')\n\n    if count_b == n or count_r == n:\n        return 2\n\n    if count_b % 2 == 0 and count_r % 2 == 0:\n        return 0\n    else:\n        return 1",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1561,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    classroom = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_consecutive_empty_seats(row_or_col, index, k):\n        if index + k > len(row_or_col):\n            return False\n        for i in range(index, index + k):\n            if row_or_col[i] != '.':\n                return False\n        return True\n\n    def count_ways_to_arrange_seats(classroom, k):\n        ways = 0\n        for i in range(n):\n            for j in range(m):\n                if classroom[i][j] == '.':\n                    if is_consecutive_empty_seats(classroom[i], j, k):\n                        ways += 1\n                    if is_consecutive_empty_seats(list(zip(*classroom))[j], i, k):\n                        ways += 1\n        return ways\n\n    return str(count_ways_to_arrange_seats(classroom, k))",
        "test": "",
        "num_ids": 275,
        "indeed": false
    },
    {
        "number": 1562,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split())\n    treasures = []\n    for _ in range(k):\n        r, c = map(int, input().split())\n        treasures.append((r, c))\n    safe_columns = list(map(int, input().split()))\n\n    def is_safe(column):\n        return column in safe_columns\n\n    def min_moves_to_collect_treasures(start_row, start_col, treasures):\n        min_moves = 0\n        collected_treasures = set()\n        for treasure in treasures:\n            if treasure in collected_treasures:\n                continue\n            row, col = treasure\n            if row < start_row or (row == start_row and col <= start_col):\n                continue\n            moves_to_reach_treasure = (row - start_row) * 2 + abs(col - start_col)\n            min_moves += moves_to_reach_treasure\n            start_row, start_col = treasure\n            collected_treasures.add(treasure)\n        return min_moves\n\n    min_moves = float('inf')\n    for col in safe_columns:\n        moves = min_moves_to_collect_treasures(1, col, treasures)\n        min_moves = min(min_moves, moves)\n\n    return str(min_moves)",
        "test": "",
        "num_ids": 344,
        "indeed": false
    },
    {
        "number": 1563,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    colors = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    max_diversity = -1\n    max_color = None\n\n    for color in set(colors):\n        diversity = 0\n        for i in range(1, n + 1):\n            if colors[i - 1] == color:\n                for neighbor in graph[i]:\n                    if colors[neighbor - 1] != color:\n                        diversity += 1\n        if diversity > max_diversity:\n            max_diversity = diversity\n            max_color = color\n\n    return str(max_color)",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 1564,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if s == t:\n        return \"0\\n\"\n\n    diff_count = sum(c1 != c2 for c1, c2 in zip(s, t))\n    if diff_count % 2 != 0:\n        return \"-1\\n\"\n\n    diff_count //= 2\n    swaps = []\n\n    for i in range(n):\n        if s[i] != t[i]:\n            for j in range(n):\n                if s[i] == t[j] and t[i] == s[j]:\n                    swaps.append((i + 1, j + 1))\n                    s = s[:i] + t[j] + s[i + 1:]\n                    t = t[:j] + s[i] + t[j + 1:]\n                    break\n\n        if len(swaps) == diff_count:\n            break\n\n    if len(swaps) == diff_count:\n        return f\"{diff_count}\\n\" + \"\\n\".join(\" \".join(map(str, swap)) for swap in swaps) + \"\\n\"\n    else:\n        return \"-1\\n\"",
        "test": "",
        "num_ids": 318,
        "indeed": false
    },
    {
        "number": 1565,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l = int(stdin.split('\\n')[0])\n    n = int(stdin.split('\\n')[1])\n    min_sum = float('inf')\n    for i in range(1, l):\n        a, b = int(str(n)[:i]), int(str(n)[i:])\n        if a == 0 or b == 0:\n            continue\n        min_sum = min(min_sum, a + b)\n    return str(min_sum)",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1566,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_contamination(contamination_levels, x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if contamination_levels[i][j] != 1:\n                    return False\n        return True\n\n    def find_lair(contamination_levels):\n        N = len(contamination_levels)\n        for x1 in range(N):\n            for y1 in range(N):\n                for x2 in range(x1, N):\n                    for y2 in range(y1, N):\n                        if check_contamination(contamination_levels, x1, y1, x2, y2):\n                            return True\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    contamination_levels = [list(map(int, line)) for line in lines[1:]]\n\n    if find_lair(contamination_levels):\n        return 'Yes'\n    else:\n        return 'No'",
        "test": "",
        "num_ids": 282,
        "indeed": false
    },
    {
        "number": 1567,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            for x in range(1, j + 1):\n                dp[i][j] += dp[i - 1][x - 1]\n                dp[i][j] %= mod\n\n    return str(dp[k][n])",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1568,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B, C, T = map(int, stdin.split())\n    t = list(map(int, input().split()))\n\n    unread_messages = [A] * n\n    points = 0\n\n    for i in range(T):\n        points += C * sum(unread_messages)\n\n        for j in range(n):\n            if t[j] == i:\n                points += unread_messages[j]\n                unread_messages[j] -= B\n\n    return str(points)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 1569,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(start, end, graph):\n        visited = [False] * (n + 1)\n        distance = [float('inf')] * (n + 1)\n        distance[start] = 0\n\n        queue = [(start, 0)]\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return distance[end]\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, working in graph[node]:\n                    if not visited[neighbor] and working:\n                        distance[neighbor] = min(distance[neighbor], distance[node] + 1)\n                        queue.append((neighbor, distance[neighbor]))\n        return float('inf')\n\n    def find_affected_roads(start, end, graph):\n        visited = [False] * (n + 1)\n        distance = [float('inf')] * (n + 1)\n        distance[start] = 0\n\n        queue = [(start, 0)]\n        affected_roads = []\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return affected_roads\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, working in graph[node]:\n                    if not visited[neighbor]:\n                        if not working:\n                            affected_roads.append((node, neighbor, 1))\n                        else:\n                            distance[neighbor] = min(distance[neighbor], distance[node] + 1)\n                            queue.append((neighbor, distance[neighbor]))\n        return affected_roads\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [[] for _ in range(n + 1)]\n\n    for i in range(1, m + 1):\n        x, y, z = map(int, lines[i].split())\n        graph[x].append((y, z))\n        graph[y].append((x, z))\n\n    shortest_path = find_shortest_path(1, n, graph)\n    affected_roads = find_affected_roads(1, n, graph)\n\n    return f\"{len(affected_roads)}\\n\" + '\\n'.join(f\"{x} {y} {z}\" for x, y, z in affected_roads)",
        "test": "",
        "num_ids": 604,
        "indeed": false
    },
    {
        "number": 1570,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, w = map(int, stdin.split())\n    total_cost = (k * (w * (w + 1)) // 2)\n    if n >= total_cost:\n        return \"0\"\n    else:\n        return str(total_cost - n)",
        "test": "",
        "num_ids": 70,
        "indeed": true
    },
    {
        "number": 1571,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n, m = len(s), len(t)\n    MOD = 998244353\n\n    def is_magic_spell(a: str) -> bool:\n        for i in range(m):\n            if a[i:i + m] != t:\n                return False\n        return True\n\n    def dfs(s: str, depth: int, a: str) -> int:\n        if depth == n:\n            return int(is_magic_spell(a))\n        return dfs(s[1:], depth + 1, a + s[0]) % MOD + dfs(s[1:], depth + 1, a + s[0] + s[0]) % MOD\n\n    return str(dfs(s, 0, \"\"))",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 1572,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 2, n + 1):\n            if all(a[k] == a[k - 1] - 1 + a[k - 2] - 2 for k in range(i + 2, j + 1)):\n                max_len = max(max_len, j - i)\n\n    return str(max_len)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1573,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.readline().split())\n    friends = []\n    for _ in range(n):\n        m, s = map(int, stdin.readline().split())\n        friends.append((m, s))\n\n    friends.sort(key=lambda x: x[0])\n    max_friendship = float('-inf')\n\n    for i in range(n):\n        if i > 0 and friends[i][0] - friends[i - 1][0] >= d:\n            break\n        max_friendship = max(max_friendship, friends[i][1])\n\n    for i in range(1, n):\n        if friends[i][0] - friends[i - 1][0] >= d:\n            max_friendship = max(max_friendship, friends[i][1] + friends[i - 1][1])\n\n    return str(max_friendship)",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 1574,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and j not in graph[i]:\n                for k in range(1, n + 1):\n                    if k != i and k != j and k not in graph[i] and k not in graph[j]:\n                        print(0)\n                        return\n\n    min_sum = float('inf')\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and j not in graph[i]:\n                for k in range(1, n + 1):\n                    if k != i and k != j and k not in graph[i] and k not in graph[j]:\n                        recognition = len(graph[i]) + len(graph[j]) + len(graph[k])\n                        min_sum = min(min_sum, recognition)\n\n    return str(min_sum) if min_sum != float('inf') else '-1'",
        "test": "",
        "num_ids": 327,
        "indeed": false
    },
    {
        "number": 1575,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    ts, tf, t, n, *visitors = list(map(int, stdin.split()))\n    visitors = sorted(visitors)\n\n    if n == 1:\n        return str(visitors[0])\n\n    min_time = float('inf')\n    for i in range(n):\n        if i == 0:\n            if visitors[i] >= ts:\n                time = visitors[i] + t\n            else:\n                time = ts + t\n        elif i == n - 1:\n            time = visitors[i] + t\n            if time > tf:\n                time = tf\n        else:\n            time = visitors[i] + t\n\n        if time < min_time:\n            min_time = time\n\n    return str(min_time)",
        "test": "",
        "num_ids": 186,
        "indeed": false
    },
    {
        "number": 1576,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = \"\"\n    for i in range(len(stdin)):\n        if i % 2 == 0:\n            s = stdin[i] + s\n        else:\n            s = s + stdin[i]\n    return s",
        "test": "",
        "num_ids": 59,
        "indeed": false
    },
    {
        "number": 1577,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    anton = s.count('A')\n    danik = n - anton\n    if anton > danik:\n        return \"Anton\"\n    elif danik > anton:\n        return \"Danik\"\n    else:\n        return \"Friendship\"",
        "test": "",
        "num_ids": 86,
        "indeed": true
    },
    {
        "number": 1578,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    return str(N - 1)",
        "test": "",
        "num_ids": 22,
        "indeed": false
    },
    {
        "number": 1579,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_dots(x, y):\n        return (x, y, dots.get((x, y), 0))\n\n    def is_valid(a, b, c, d):\n        return (a, b) in dots and (a, d) in dots and (c, b) in dots and (c, d) in dots\n\n    def add_dot(a, b, c, d):\n        if is_valid(a, b, c, d):\n            x, y = a, d\n            if (x, y) in dots:\n                return False\n            dots[(x, y)] = 1\n            return True\n        return False\n\n    N = int(stdin.readline().strip())\n    dots = {}\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        dots[(x, y)] = 1\n\n    max_operations = 0\n    for a, b, count_ab in sorted(dots.items(), key=lambda x: x[1]):\n        for c, d, count_cd in sorted(dots.items(), key=lambda x: x[1]):\n            if a == c or b == d:\n                continue\n            if add_dot(a, b, c, d):\n                max_operations += 1\n\n    return str(max_operations)",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 1580,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n\n    def find_cost(n: int, m: int, x: List[int], y: List[int], z: List[int]) -> int:\n        cost = 0\n        for i in range(1, n + 1):\n            if i not in x and i not in y:\n                cost += 1\n        return cost\n\n    input_list = list(map(int, stdin.split()))\n    n, m = input_list[0], input_list[1]\n    x, y, z = input_list[2:2 + m], input_list[2 + m:2 + 2 * m], input_list[2 + 2 * m:]\n\n    return str(find_cost(n, m, x, y, z))",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 1581,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    n, k = map(int, stdin.split())\n    dp = [1] * (k + 1)\n\n    for i in range(2, k + 1):\n        for j in range(1, i):\n            if j * dp[i - j] <= n:\n                dp[i] += dp[i - j]\n                dp[i] %= mod\n\n    return str(dp[k])",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1582,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if str(i)[-1] == str(j)[0] and str(i)[0] == str(j)[-1]:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1583,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x = map(int, stdin.split())\n\n    volume = a * a * b\n    height = x / (a * a)\n\n    if height >= b:\n        return \"0.0000000000\"\n\n    max_angle = degrees(asin(height / b))\n\n    return f\"{max_angle:.10f}\"\n",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1584,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *L = list(map(int, stdin.split()))\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if L[i] < L[j] + L[k] and L[j] < L[k] + L[i] and L[k] < L[i] + L[j]:\n                    count += 1\n    return str(count)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1585,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    if X == Y:\n        return \"1\"\n    if X == 1:\n        return \"2\"\n    if X % 2 == 0:\n        return \"2\"\n    return \"1\"",
        "test": "",
        "num_ids": 66,
        "indeed": false
    },
    {
        "number": 1586,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(2, n + 1, 2):\n        power = 2\n        while i * (2 ** power) <= n:\n            count += 1\n            power += 1\n    return str(count)",
        "test": "",
        "num_ids": 73,
        "indeed": false
    },
    {
        "number": 1587,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, stones = int(stdin.split('\\n')[0]), list(stdin.split('\\n')[1])\n    operations = 0\n\n    for i in range(N):\n        if stones[i] == 'W' and i > 0 and stones[i - 1] == 'R':\n            operations += 1\n            if i > 1 and stones[i - 2] == 'W':\n                stones[i - 1], stones[i - 2] = stones[i - 2], stones[i - 1]\n            else:\n                stones[i - 1] = 'W' if stones[i - 1] == 'R' else 'R'\n\n    return str(operations)",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 1588,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subset(s, X):\n        Y = []\n        for i in range(1, s + 1):\n            if i not in X:\n                Y.append(i)\n        return Y\n\n    def check_equality(X, Y, s):\n        sum_X = sum(x - 1 for x in X)\n        sum_Y = sum(s - y for y in Y)\n        return sum_X == sum_Y\n\n    n = int(stdin.split('\\n')[0])\n    X = list(map(int, stdin.split('\\n')[1].split()))\n    s = max(X)\n\n    Y = find_subset(s, X)\n    if check_equality(X, Y, s):\n        return f\"{len(Y)}\\n{' '.join(map(str, Y))}\"\n    else:\n        raise ValueError(\"No solution found\")",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1589,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    lights = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if lights[i][2 * j - 1] == 1 or lights[i][2 * j] == 1:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 1590,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    MOD = 10**9 + 7\n    total_sum = 0\n\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            b = a[l - 1:r]\n            b.sort()\n            f = sum(b[i] * (i + 1) for i in range(len(b)))\n            total_sum += f\n            total_sum %= MOD\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 161,
        "indeed": true
    },
    {
        "number": 1591,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = [int(stdin.readline()) for _ in range(n)]\n\n    # Count the number of students with each favorite drink type\n    counts = [0] * (k + 1)\n    for i in range(n):\n        counts[a[i]] += 1\n\n    # Choose the optimal number of sets\n    sets = (n + 1) // 2\n\n    # Distribute the sets optimally\n    max_students = 0\n    for i in range(1, k + 1):\n        max_students += min(sets, counts[i])\n\n    return str(max_students)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1592,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    tasks = []\n    for i in range(n):\n        t, c = map(int, stdin.readline().split())\n        tasks.append((t, c))\n\n    queue = []\n    last_sent = 0\n    max_queue_size = 0\n\n    for task in tasks:\n        while queue and queue[0][0] <= task[0]:\n            last_sent = max(last_sent, queue.pop(0)[0] + 1)\n\n        queue.append(task)\n        max_queue_size = max(max_queue_size, len(queue))\n\n    while queue:\n        last_sent = max(last_sent, queue.pop(0)[0] + 1)\n\n    return f\"{last_sent} {max_queue_size}\"",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 1593,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    locations = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    total_population = sum([loc[2] for loc in locations])\n    if total_population + s < 10**6:\n        return \"-1\"\n\n    def is_megacity(radius):\n        population = s\n        for loc in locations:\n            x, y, k = loc\n            if (x**2 + y**2)**0.5 <= radius:\n                population += k\n        return population >= 10**6\n\n    left, right = 0, 10**4\n    while abs(right - left) > 10**-6:\n        mid = (left + right) / 2\n        if is_megacity(mid):\n            right = mid\n        else:\n            left = mid\n\n    return f\"{right:.6f}\"",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 1594,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    playlist = []\n    for _ in range(n):\n        c, t = map(int, stdin.readline().split())\n        playlist.extend([i + 1 for i in range(c)])\n    moments = list(map(int, stdin.readline().split()))\n\n    result = []\n    for moment in moments:\n        for i, song in enumerate(playlist):\n            if moment <= sum(t for j in range(i + 1) if playlist[j] == song):\n                result.append(song)\n                break\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1595,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    sum, limit = map(int, stdin.split())\n\n    def lowbit(x):\n        return 2 ** bin(x)[::-1].find('1')\n\n    ans = []\n    for i in range(1, limit + 1):\n        if lowbit(i) <= sum:\n            ans.append(i)\n            sum -= lowbit(i)\n        if sum == 0:\n            break\n\n    if sum != 0:\n        return \"-1\\n\"\n    else:\n        return f\"{len(ans)}\\n{' '.join(map(str, ans))}\\n\"",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1596,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        if s[i - 1] == 'w':\n            dp[i] = dp[i - 1] + dp[i - 1] * 25 % mod\n        elif s[i - 1] == 'm':\n            dp[i] = dp[i - 1] + dp[i - 1] * 25 % mod\n        else:\n            dp[i] = dp[i - 1] + dp[i - 1] * 26 % mod\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1597,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    students = [stdin.readline().strip() for _ in range(n)]\n    pseudonyms = [stdin.readline().strip() for _ in range(n)]\n\n    def lcp(a: str, b: str) -> int:\n        length = min(len(a), len(b))\n        result = 0\n        for i in range(length):\n            if a[i] == b[i]:\n                result += 1\n            else:\n                break\n        return result\n\n    quality = sum(lcp(students[i], pseudonyms[i]) for i in range(n))\n\n    return f\"{quality}\\n\" + \"\\n\".join(f\"{i + 1} {j + 1}\" for i, j in enumerate(sorted(range(n), key=lambda x: lcp(students[x], pseudonyms[x]), reverse=True)))\n",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 1598,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    t = ['0'] * n\n\n    for i in range(n):\n        if s[i] == '1':\n            t[i] = '1'\n        else:\n            t[i] = '0'\n\n    return ''.join(t)",
        "test": "",
        "num_ids": 79,
        "indeed": false
    },
    {
        "number": 1599,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m = stdin.split(\"\\n\")\n    n = len(s)\n    m = int(m)\n    s = s.replace(\".\", \"0\")\n    s = s.replace(\"#\", \"1\")\n    s = list(map(int, s))\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + s[i]\n\n    result = []\n    for _ in range(m):\n        l, r = map(int, input().split())\n        result.append(prefix_sum[r] - prefix_sum[l - 1])\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 1600,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = list(map(int, stdin.split('\\n')[1].split()))\n\n    heights.sort()\n\n    blocks = []\n    current_block = [heights[0]]\n\n    for i in range(1, n):\n        if heights[i] == heights[i - 1] + 1:\n            current_block.append(heights[i])\n        else:\n            blocks.append(current_block)\n            current_block = [heights[i]]\n\n    blocks.append(current_block)\n\n    return str(len(blocks))",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1601,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_perfectly_balanced(a, b, c):\n        return min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and \\\n               min(a[1], b[1]) <= c[1] <= max(a[1], b[1]) and \\\n               min(a[2], b[2]) <= c[2] <= max(a[2], b[2])\n\n    def find_pair(points, indices):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if all(not is_perfectly_balanced(points[i], points[j], points[k]) for k in range(len(points)) if k not in (i, j)):\n                    return i, j\n        return None\n\n    n = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    indices = list(range(1, n + 1))\n    pairs = []\n\n    for _ in range(n // 2):\n        i, j = find_pair(points, indices)\n        pairs.append((indices[i], indices[j]))\n        indices.remove(indices[i])\n        indices.remove(indices[j - 1])\n        points.pop(i)\n        points.pop(j - 1)\n\n    return '\\n'.join(' '.join(map(str, pair)) for pair in pairs)",
        "test": "",
        "num_ids": 376,
        "indeed": false
    },
    {
        "number": 1602,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_or(x: int, y: int) -> int:\n        return x | y\n\n    def f(x: int, y: int) -> int:\n        return bitwise_or(x, y) - y\n\n    def find_max_value(arr: List[int]) -> int:\n        max_value = float('-inf')\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                temp_arr = arr.copy()\n                temp_arr[i], temp_arr[j] = temp_arr[j], temp_arr[i]\n                temp_value = f(f(temp_arr[-2], temp_arr[-1]), temp_arr[-3])\n                for k in range(len(temp_arr) - 4, -1, -1):\n                    temp_value = f(temp_value, temp_arr[k])\n                max_value = max(max_value, temp_value)\n        return max_value\n\n    def reorder_array(arr: List[int]) -> List[int]:\n        max_value = find_max_value(arr)\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                temp_arr = arr.copy()\n                temp_arr[i], temp_arr[j] = temp_arr[j], temp_arr[i]\n                temp_value = f(f(temp_arr[-2], temp_arr[-1]), temp_arr[-3])\n                for k in range(len(temp_arr) - 4, -1, -1):\n                    temp_value = f(temp_value, temp_arr[k])\n                if temp_value == max_value:\n                    return temp_arr\n\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    result = reorder_array(arr)\n    return ' '.join(map(str, result)) ",
        "test": "",
        "num_ids": 489,
        "indeed": false
    },
    {
        "number": 1603,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            left = arr[:mid]\n            right = arr[mid:]\n\n            merge_sort(left)\n            merge_sort(right)\n\n            i = j = k = 0\n\n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n                k += 1\n\n            while i < len(left):\n                arr[k] = left[i]\n                i += 1\n                k += 1\n\n            while j < len(right):\n                arr[k] = right[j]\n                j += 1\n                k += 1\n\n    n = int(stdin.readline().strip())\n    costs = list(map(int, stdin.readline().strip().split()))\n    m = int(stdin.readline().strip())\n    merge_sort(costs)\n    u_costs = sorted(set(costs))\n\n    result = []\n    for _ in range(m):\n        type_, l, r = map(int, stdin.readline().strip().split())\n        if type_ == 1:\n            result.append(sum(costs[l - 1:r]))\n        else:\n            result.append(sum(u_costs[l - 1:r]))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 395,
        "indeed": false
    },
    {
        "number": 1604,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n, k = map(int, stdin.readline().split())\n    lamps = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    periods = [lamp[1] - lamp[0] + 1 for lamp in lamps]\n    lcm_periods = periods[0]\n    for i in range(1, k):\n        lcm_periods = lcm(lcm_periods, periods[i])\n\n    answer = 0\n    for i in range(lcm_periods):\n        count = 0\n        for j in range(n):\n            if (i + lamps[j][0]) % periods[j] == 0:\n                count += 1\n        if count >= k:\n            answer += 1\n\n    return str(answer % 998244353)",
        "test": "",
        "num_ids": 266,
        "indeed": false
    },
    {
        "number": 1605,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    even_count = 0\n    odd_count = 0\n\n    for i in range(len(stdin)):\n        for j in range(i, len(stdin)):\n            substring = stdin[i:j + 1]\n            merged_substring = \"\"\n            prev_char = \"\"\n\n            for char in substring:\n                if char != prev_char:\n                    merged_substring += char\n                    prev_char = char\n\n            if merged_substring == merged_substring[::-1]:\n                if (j - i + 1) % 2 == 0:\n                    even_count += 1\n                else:\n                    odd_count += 1\n\n    return f\"{even_count} {odd_count}\"\n",
        "test": "",
        "num_ids": 178,
        "indeed": true
    },
    {
        "number": 1606,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *matrix = [line.split() for line in stdin.split('\\n')]\n    n = int(n)\n    matrix = [[int(x) for x in row] for row in matrix]\n\n    def unusual_square(matrix):\n        return sum(sum(matrix[i][i] for i in range(n)) % 2 for j in range(n)) % 2\n\n    unusual_squares = []\n    for query in stdin.split('\\n')[n + 1:]:\n        command, *args = query.split()\n        command = int(command)\n        if command == 3:\n            unusual_squares.append(unusual_square(matrix))\n        elif command == 1:\n            i = int(args[0]) - 1\n            for j in range(n):\n                matrix[i][j] = (matrix[i][j] + 1) % 2\n        elif command == 2:\n            j = int(args[0]) - 1\n            for i in range(n):\n                matrix[i][j] = (matrix[i][j] + 1) % 2\n\n    return ''.join(str(x) for x in unusual_squares)",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 1607,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 998244353\n\n    dp = [[0, 0] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n        for j in range(2, k + 1):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            dp[i][j] %= MOD\n\n    return str(dp[n][k])",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 1608,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        dp[i + 1] = (dp[i] * 2) % mod\n        for j in range(i + 1, n):\n            if all(gcd(a[i:j + 1]) == 1):\n                dp[j + 1] = (dp[j + 1] + dp[i]) % mod\n    return str(dp[n])\n\ndef",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 1609,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    numbers.sort()\n\n    for i in range(n):\n        if numbers[i] != i + 1:\n            for j in range(i + 1, n):\n                if numbers[j] == i + 1:\n                    numbers[i], numbers[j] = numbers[j], numbers[i]\n                    break\n\n    return ' '.join(map(str, numbers))",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1610,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    for i in range(n, 0, -1):\n        if k > 0:\n            result.append(i)\n            k -= 1\n        else:\n            result.append(n - len(result) + 1)\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1611,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    l = list(map(int, stdin.split('\\n')[1].split()))\n    l.sort()\n    z = 1\n    for i in range(n):\n        if l[i] <= z:\n            z += l[i]\n        else:\n            break\n    return str(z)",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 1612,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    result = []\n\n    for i in range(n):\n        line = stdin.readline().split()\n        m = int(line[0])\n        a = set(map(int, line[1:]))\n\n        if len(a) == m:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 107,
        "indeed": false
    },
    {
        "number": 1614,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    heights = list(map(int, input().split()))\n\n    min_width = sum(1 if height <= h else 2 for height in heights)\n\n    return str(min_width)",
        "test": "",
        "num_ids": 64,
        "indeed": false
    },
    {
        "number": 1615,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    def is_divisible(segments, k):\n        total_range = sum(r - l + 1 for l, r in segments)\n        return total_range % k == 0\n\n    def can_be_divided(segments, k):\n        total_range = sum(r - l + 1 for l, r in segments)\n        for l, r in segments:\n            if (r - l + 1) % k == 0:\n                total_range -= (r - l + 1)\n            else:\n                total_range -= (r - l + 1) // k * k\n        return total_range % k == 0\n\n    if is_divisible(segments, k):\n        return 0\n    elif can_be_divided(segments, k):\n        return 1\n    else:\n        return -1\n\n    # Read input\n    n, k = map(int, input().split())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    # Check if the value of the set of Polo's segments is already divisible by k\n    total_range = sum(r - l + 1 for l, r in segments)\n    if total_range % k == 0:\n        print(0)\n    else:\n        # Check if the value of the set of Polo's segments can be made divisible by k by widening some segments\n        for i in range(n):\n            l, r = segments[i]\n            if (r - l + 1) % k == 0:\n                total_range -= (r - l + 1)\n            else:\n                total_range -= (r - l + 1) // k * k\n            if total_range % k == 0:\n                print(1)\n                break\n        else:\n            print(-1) ",
        "test": "",
        "num_ids": 517,
        "indeed": false
    },
    {
        "number": 1616,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_perfect_square(num):\n        return int(num**0.5)**2 == num\n\n    def divisors(num):\n        divisors_list = []\n        for i in range(1, num + 1):\n            if num % i == 0:\n                divisors_list.append(i)\n        return len(divisors_list)\n\n    min_length = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            product = 1\n            for k in range(i, j + 1):\n                product *= a[k]\n            if divisors(product) <= 7 and is_perfect_square(product):\n                min_length = min(min_length, j - i + 1)\n\n    return str(min_length) if min_length != float('inf') else '-1'",
        "test": "",
        "num_ids": 251,
        "indeed": false
    },
    {
        "number": 1617,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    fun_values = set()\n\n    for k in range(1, n + 1):\n        ball_pos = 1\n        touched_people = set()\n\n        while ball_pos not in touched_people:\n            touched_people.add(ball_pos)\n            ball_pos = (ball_pos + k) % n\n\n        fun_value = sum(touched_people)\n        fun_values.add(fun_value)\n\n    return \" \".join(map(str, sorted(fun_values)))\n",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1618,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, boxes = parse_input(stdin)\n    staircase = [0] * n\n    for box in boxes:\n        height = get_height(staircase, box)\n        update_staircase(staircase, box, height)\n    return \" \".join(str(height) for _, height in boxes)\n\ndef",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 1619,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_well_connected(polygon1, polygon2):\n        def count_crossings(p1, p2, p3, q1, q2, q3):\n            def cross_product(a, b):\n                return a[0] * b[1] - a[1] * b[0]\n\n            def is_collinear(a, b, c):\n                return (a[0] - b[0]) * (a[1] - c[1]) == (a[1] - b[1]) * (a[0] - c[0])\n\n            def is_between(a, b, c):\n                return a <= b <= c or c <= b <= a\n\n            p1, p2, p3, q1, q2, q3 = map(lambda x: (x[0], x[1]), (p1, p2, p3, q1, q2, q3))\n\n            if is_collinear(p1, p2, p3) or is_collinear(q1, q2, q3):\n                return 0\n\n            p1_p2 = cross_product(p1, p2)\n            p2_p3 = cross_product(p2, p3)\n            q1_q2 = cross_product(q1, q2)\n            q2_q3 = cross_product(q2, q3)\n\n            crossings = 0\n            if p1_p2 * p2_p3 > 0 and p1_p2 * q1_q2 > 0 and p1_p2 * q2_q3 > 0:\n                crossings += 1\n            if p1_p2 * p2_p3 < 0 and p1_p2 * q1_q2 < 0 and p1_p2 * q2_q3 < 0:\n                crossings -= 1\n\n            if q1_q2 * q2_q3 > 0 and q1_q2 * p1_p2 > 0 and q1_q2 * p2_p3 > 0:\n                crossings += 1\n            if q1_q2 * q2_q3 < 0 and q1_q2 * p1_p2 < 0 and q1_q2 * p2_p3 < 0:\n                crossings -= 1\n\n            return crossings\n\n        crossings = 0\n        for i in range(len(polygon1)):\n            p1, p2 = polygon1[i], polygon1[(i + 1) % len(polygon1)]\n            for j in range(len(polygon2)):\n                q1, q2 = polygon2[j], polygon2[(j + 1) % len(polygon2)]\n                crossings += count_crossings(p1, p2, q1, q2, q1, q2)\n\n        return crossings\n\n    def read_polygon(n):\n        polygon = []\n        for _ in range(n):\n            x, y, z = map(int, input().split())\n            polygon.append((x, y, z))\n        return polygon\n\n    n = int(input())\n    polygon1 = read_polygon(n)\n    m = int(input())\n    polygon2 = read_polygon(m)\n\n    return \"YES\" if is_well_connected(polygon1, polygon2) else \"NO\"",
        "test": "",
        "num_ids": 812,
        "indeed": false
    },
    {
        "number": 1620,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return 'a' * (n // 2) + 'b' * (n // 2)\n    else:\n        return 'a' * (n // 2) + 'b' * (n // 2 + 1)\n\n    # Read input\n    n = int(input())\n    print(solution(str(n))) ",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 1621,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = map(str, stdin.readline().split())\n    w = list(map(int, stdin.readline().split()))\n\n    s_len = len(s)\n    total_len = s_len + k\n\n    s_value = sum(w[ord(c) - ord('a')] * (i + 1) for i, c in enumerate(s))\n\n    max_value = s_value\n    for i in range(total_len):\n        for j in range(i + 1, total_len):\n            for c in range(26):\n                new_s = s[:i] + chr(c + ord('a')) + s[i:j] + chr(c + ord('a')) + s[j:]\n                new_s_value = f(new_s, w)\n                max_value = max(max_value, new_s_value)\n\n    return max_value\n\ndef",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 1622,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    bosses = [0] * (n + 1)\n    signed_documents = []\n\n    for _ in range(m):\n        event, *args = map(int, input().split())\n\n        if event == 1:\n            x, y = args\n            bosses[x] = y\n        elif event == 2:\n            x = args[0]\n            while bosses[x] != 0:\n                signed_documents.append(x)\n                x = bosses[x]\n        elif event == 3:\n            x, i = args\n            print(\"YES\" if signed_documents.count(x) >= i else \"NO\")\n\n    return \"\"",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 1623,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    min_sum = n\n    max_sum = n * (n + 1) // 2\n    if l == 1:\n        min_sum = n - r + 1\n    if r == n:\n        max_sum = n * (n + 1) // 2\n    return f\"{min_sum} {max_sum}\"",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 1624,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort(reverse=True)\n    m = (n + 1) // 2\n    s = sum(a[:m])\n    ans = s * s\n    for i in range(m, n):\n        s += a[i] - a[i - m]\n        ans += s * s\n    return str(ans)",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1625,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def max_beauty(matrix, n):\n        if n == 0:\n            return max(matrix)\n        else:\n            max_val = max(matrix)\n            submatrices = [\n                matrix[i : i + 2 ** (n - 1) - 1]\n                for i in range(0, len(matrix), 2 ** (n - 1) - 1)\n            ]\n            submatrices = [\n                [\n                    submatrices[j][k]\n                    for k in range(0, len(submatrices[0]), 2 ** (n - 1) - 1)\n                ]\n                for j in range(len(submatrices))\n            ]\n            return max_val + sum(\n                max_beauty(submatrix, n - 1) for submatrix in submatrices\n            )\n\n    matrix = [[] for _ in range(2 ** n)]\n    for i in range(2 ** n):\n        for j in range(2 ** n):\n            matrix[i].append(numbers.pop(0))\n\n    return str(max_beauty(matrix, n))",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 1626,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    mod = 10**9 + 7\n    total = 9**k\n\n    for i in range(n // k):\n        if a[i] != 0:\n            total -= 9**(k - 1) // a[i] + (b[i] == 0)\n\n    return str(total % mod)\n",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1627,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge(arr, left, mid, right):\n        i, j = left, mid + 1\n        temp = []\n        while i <= mid and j <= right:\n            if arr[i] < arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n        while i <= mid:\n            temp.append(arr[i])\n            i += 1\n        while j <= right:\n            temp.append(arr[j])\n            j += 1\n        arr[left:right + 1] = temp\n\n    def merge_sort(arr, left, right):\n        if left < right:\n            mid = (left + right) // 2\n            merge_sort(arr, left, mid)\n            merge_sort(arr, mid + 1, right)\n            merge(arr, left, mid, right)\n\n    n = int(stdin.readline().strip())\n    heights = list(map(int, stdin.readline().strip().split()))\n\n    merge_sort(heights, 0, n - 1)\n\n    operations = []\n    for i in range(1, n, 2):\n        if heights[i - 1] > heights[i]:\n            heights[i - 1], heights[i] = heights[i], heights[i - 1]\n            operations.append((i, i + 1))\n\n    for i in range(2, n, 2):\n        if heights[i - 2] > heights[i]:\n            heights[i - 2], heights[i] = heights[i], heights[i - 2]\n            operations.append((i - 1, i))\n\n    if not operations:\n        return \"\"\n\n    output = []\n    for operation in operations:\n        output.append(\"{} {}\".format(operation[0], operation[1]))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 482,
        "indeed": false
    },
    {
        "number": 1628,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    while True:\n        y_index = stdin.find('yx')\n        x_index = stdin.find('xy')\n\n        if y_index == -1 and x_index == -1:\n            break\n\n        if y_index != -1 and (x_index == -1 or y_index < x_index):\n            stdin = stdin[:y_index] + 'x' + stdin[y_index + 1] + 'y' + stdin[y_index + 2:]\n        else:\n            stdin = stdin[:x_index] + stdin[x_index + 2:]\n\n    return stdin",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 1629,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    balls = list(map(int, input().split()))\n\n    initial_balls = [0] * n\n    current_box = x\n    for i in range(1, n + 1):\n        initial_balls[current_box - 1] += i\n        current_box = (current_box + 1) % n\n\n    for i in range(n):\n        if initial_balls[i] == balls[i]:\n            continue\n        elif initial_balls[i] > balls[i]:\n            diff = initial_balls[i] - balls[i]\n            initial_balls[i] -= diff\n            for j in range(i + 1, n):\n                if initial_balls[j] >= diff:\n                    initial_balls[j] -= diff\n                    break\n                else:\n                    diff -= initial_balls[j]\n                    initial_balls[j] = 0\n        else:\n            diff = balls[i] - initial_balls[i]\n            initial_balls[i] += diff\n            for j in range(i + 1, n):\n                if balls[j] >= diff:\n                    balls[j] -= diff\n                    break\n                else:\n                    diff -= balls[j]\n                    balls[j] = 0\n\n    return \" \".join(map(str, initial_balls))",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 1630,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(short_name, team_name, hometown_name):\n        if short_name == team_name[:3]:\n            return True\n        if short_name[:2] == team_name[:2] and short_name[2] == hometown_name[0]:\n            return True\n        return False\n\n    def find_short_name(team_name, hometown_name):\n        for i in range(len(team_name)):\n            for j in range(len(hometown_name)):\n                short_name = team_name[:3] + hometown_name[j]\n                if len(short_name) == 3 and short_name.isupper() and is_valid(short_name, team_name, hometown_name):\n                    return short_name\n        return None\n\n    def is_unique(short_names):\n        return len(set(short_names)) == len(short_names)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    clubs = lines[1:n+1]\n    short_names = []\n\n    for club in clubs:\n        team_name, hometown_name = club.split()\n        short_name = find_short_name(team_name, hometown_name)\n        if short_name is None:\n            return 'NO'\n        short_names.append(short_name)\n\n    if is_unique(short_names):\n        return 'YES\\n' + '\\n'.join(short_names)\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 382,
        "indeed": false
    },
    {
        "number": 1631,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted_lexicographically(names: list, alphabet: str) -> bool:\n        for i in range(len(names) - 1):\n            name1 = names[i]\n            name2 = names[i + 1]\n            for j in range(min(len(name1), len(name2))):\n                char1 = name1[j]\n                char2 = name2[j]\n                if alphabet.index(char1) > alphabet.index(char2):\n                    return False\n                elif alphabet.index(char1) < alphabet.index(char2):\n                    break\n            else:\n                if len(name1) > len(name2):\n                    return False\n        return True\n\n    def find_order(names: list) -> str:\n        for permutation in itertools.permutations('abcdefghijklmnopqrstuvwxyz'):\n            alphabet = ''.join(permutation)\n            if is_sorted_lexicographically(names, alphabet):\n                return alphabet\n        return \"Impossible\"\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    names = lines[1:n + 1]\n    return find_order(names)",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 1632,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    a.sort()\n\n    # Probability that Jerry has a higher total\n    p = 0\n\n    # Case 1: Andrew wins rounds 1 and 2, Jerry wins round 3\n    if a[0] + a[1] > a[2]:\n        p += 1 / 3\n\n    # Case 2: Andrew wins round 1, Jerry wins rounds 2 and 3\n    if a[0] < a[1] + a[2]:\n        p += 1 / 3\n\n    # Case 3: Andrew wins round 2, Jerry wins rounds 1 and 3\n    if a[1] < a[0] + a[2]:\n        p += 1 / 3\n\n    return round(p, 10)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 1633,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    moves = [list(map(int, line.split())) for line in stdin.split('\\n')[1:k+1]]\n\n    def is_2x2_square(i, j):\n        return (\n            (i > 0 and j > 0 and field[i-1][j-1] == '#') and\n            (i > 0 and field[i-1][j] == '#') and\n            (j > 0 and field[i][j-1] == '#') and\n            (field[i][j] == '#')\n        )\n\n    field = [['.' for _ in range(m)] for _ in range(n)]\n    for move_num, (i, j) in enumerate(moves, start=1):\n        if is_2x2_square(i, j):\n            return str(move_num)\n        field[i-1][j-1] = '#'\n\n    return '0'",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 1634,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    c1, c2, c3, c4 = map(int, stdin.split('\\n')[0].split())\n    n, m = map(int, stdin.split('\\n')[1].split())\n    a = list(map(int, stdin.split('\\n')[2].split()))\n    b = list(map(int, stdin.split('\\n')[3].split()))\n\n    min_cost = float('inf')\n\n    # Ticket type 1\n    for i in range(n):\n        min_cost = min(min_cost, a[i] * c1)\n    for i in range(m):\n        min_cost = min(min_cost, b[i] * c1)\n\n    # Ticket type 2\n    for i in range(n):\n        min_cost = min(min_cost, c2 + a[i] * c1)\n    for i in range(m):\n        min_cost = min(min_cost, c2 + b[i] * c1)\n\n    # Ticket type 3\n    min_cost = min(min_cost, c3 + sum(a) * c1 + sum(b) * c1)\n\n    # Ticket type 4\n    min_cost = min(min_cost, c4 + sum(a) * c1 + sum(b) * c1)\n\n    return str(min_cost)",
        "test": "",
        "num_ids": 334,
        "indeed": false
    },
    {
        "number": 1635,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    last_visit = {}\n    max_last_visit = -1\n    result = -1\n\n    for i in range(n):\n        if a[i] not in last_visit:\n            last_visit[a[i]] = i\n        else:\n            last_visit[a[i]] = i\n\n        if last_visit[a[i]] > max_last_visit:\n            max_last_visit = last_visit[a[i]]\n            result = a[i]\n\n    return str(result)",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 1636,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_aesthetically_pleasing(numbering: List[int]) -> bool:\n        for i in range(len(numbering)):\n            x, y = points[i]\n            for j in range(i + 1, len(numbering)):\n                x2, y2 = points[j]\n                if x <= x2 and y <= y2 and numbering[i] > numbering[j]:\n                    return False\n        return True\n\n    def find_numbering(w: List[int], index: int, numbering: List[int]) -> bool:\n        if index == len(w):\n            return True\n        for i in range(len(numbering)):\n            if i not in numbering[:index] and s(points[i]) == w[index]:\n                numbering[index] = i\n                if find_numbering(w, index + 1, numbering):\n                    return True\n                numbering[index] = -1\n        return False\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n    w = list(map(int, lines[n + 1].split()))\n\n    points.sort(key=lambda x: (x[1] - x[0], x[0]))\n    points = [(0, 0)] + points\n    numbering = [-1] * n\n\n    if find_numbering(w, 0, numbering):\n        if is_aesthetically_pleasing(numbering):\n            return \"YES\\n\" + '\\n'.join(f\"{points[i][0]} {points[i][1]}\" for i in range(n) if numbering[i] != -1)\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 448,
        "indeed": false
    },
    {
        "number": 1637,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> str:\n        return stdin.readline().strip()\n\n    def read_int() -> int:\n        return int(read_line())\n\n    n, m = read_int(), read_int()\n    x, y = [read_int() for _ in range(n)], [read_int() for _ in range(n)]\n    u, v = [read_int() for _ in range(m)], [read_int() for _ in range(m)]\n\n    # Create a set of pairs of people who don't like to cooperate\n    dislike_pairs = set(zip(u, v))\n\n    # Initialize the scores for each participant\n    scores = [0] * n\n\n    # Iterate through all possible pairs of people\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the pair is not in the dislike set\n            if (i, j) not in dislike_pairs and (j, i) not in dislike_pairs:\n                # Assign the first task to the person with the higher score on the first problem\n                if x[i] > x[j]:\n                    first_task = (i, j)\n                else:\n                    first_task = (j, i)\n\n                # Assign the second task to the person with the higher score on the second problem\n                if y[i] > y[j]:\n                    second_task = (i, j)\n                else:\n                    second_task = (j, i)\n\n                # Update the scores for the participants\n                scores[first_task[0]] += x[first_task[1]]\n                scores[first_task[1]] += x[first_task[0]]\n                scores[second_task[0]] += y[second_task[1]]\n                scores[second_task[1]] += y[second_task[0]]\n\n    # Return the scores for each participant\n    return \" \".join(map(str, scores))",
        "test": "",
        "num_ids": 482,
        "indeed": false
    },
    {
        "number": 1638,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    limits = list(map(int, stdin.split('\\n')[1].split()))\n\n    floors = [min(limits[i], limits[i - 1] + 1) if i > 0 else limits[0] for i in range(n)]\n\n    for i in range(1, n - 1):\n        floors[i] = min(floors[i], limits[i - 1] + 1, limits[i + 1] + 1)\n\n    return ' '.join(map(str, floors))",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 1639,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 144,
        "indeed": true
    },
    {
        "number": 1640,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def d(x, y):\n        return y - x if abs(x - y) > 1 else 0\n\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            result += d(a[i], a[j])\n\n    return str(result)",
        "test": "",
        "num_ids": 115,
        "indeed": true
    },
    {
        "number": 1641,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_reach_cinema(car_price, car_fuel_capacity, gas_stations, s, t):\n        for gas_station in gas_stations:\n            if car_fuel_capacity >= 6:\n                if gas_station <= 3:\n                    car_fuel_capacity -= 6\n                else:\n                    car_fuel_capacity -= 2\n            else:\n                car_fuel_capacity -= 2\n\n            if car_fuel_capacity < 0:\n                return False\n\n        return (s - gas_stations[-1]) / 2 <= t - 3 * (len(gas_stations) + 1)\n\n    params = list(map(int, stdin.split()))\n    n, k, s, t = params[0], params[1], params[2], params[3]\n    cars = [(c, v) for c, v in zip(params[4:4 + n:2], params[5:5 + n:2])]\n    gas_stations = params[4 + n:4 + n + k]\n\n    min_price = float('inf')\n    for car_price, car_fuel_capacity in cars:\n        if can_reach_cinema(car_price, car_fuel_capacity, gas_stations, s, t):\n            min_price = min(min_price, car_price)\n\n    return str(min_price) if min_price != float('inf') else '-1' ",
        "test": "",
        "num_ids": 367,
        "indeed": false
    },
    {
        "number": 1642,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def cross_product(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def is_convex(polygon, n):\n        for i in range(n):\n            if cross_product(polygon[i - 2], polygon[i - 1], polygon[i]) >= 0:\n                return False\n        return True\n\n    def find_max_distance(polygon, n):\n        max_distance = 0\n        for i in range(n):\n            a, b = polygon[i - 1], polygon[i]\n            for j in range(i + 1, n + i - 1):\n                c, d = polygon[j - 1], polygon[j]\n                if cross_product(a, b, c) * cross_product(a, b, d) <= 0 and cross_product(c, d, a) * cross_product(c, d, b) <= 0:\n                    max_distance = max(max_distance, distance(a, c), distance(a, d), distance(b, c), distance(b, d))\n        return max_distance\n\n    n = int(stdin.readline())\n    polygon = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    if not is_convex(polygon, n):\n        return \"The polygon is not convex.\"\n\n    max_distance = find_max_distance(polygon, n)\n    return f\"{max_distance:.10f}\"",
        "test": "",
        "num_ids": 445,
        "indeed": false
    },
    {
        "number": 1643,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    t = ['0'] * n\n    for i in range(n):\n        if stdin[i] == '1':\n            t[i] = '1'\n        else:\n            t[i] = '0'\n    return ''.join(t)\n\ndef",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 1644,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rings = [list(map(int, i.split())) for i in stdin.split('\\n')[1:]]\n    rings.sort(key=lambda x: x[1], reverse=True)\n    max_height = 0\n    for i in range(n):\n        if i == 0:\n            max_height += rings[i][2]\n        else:\n            if rings[i][1] < rings[i-1][0]:\n                max_height += rings[i][2]\n            else:\n                break\n    return str(max_height)",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 1645,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_good(subarray):\n        return sum(subarray) != 0\n\n    def count_good_subarrays(a):\n        count = 0\n        for i in range(len(a)):\n            for j in range(i, len(a) + 1):\n                if is_good(a[i:j]):\n                    count += 1\n        return count\n\n    return str(count_good_subarrays(a))",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 1646,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    def is_correct(s: str) -> bool:\n        if s == '':\n            return False\n        if s == '0':\n            return True\n        if s[0] == '0':\n            return False\n        return is_correct(s[1:])\n\n    def swap_adjacent(s: str) -> str:\n        return ''.join([s[i - 1] if i % 2 == 0 else s[i] for i in range(len(s))])\n\n    def replace_11(s: str) -> str:\n        return s.replace('11', '1')\n\n    def val(s: str) -> int:\n        return int(s, 2)\n\n    def min_correct_string(s: str) -> str:\n        if is_correct(s):\n            return s\n        s_swap = swap_adjacent(s)\n        s_replace = replace_11(s)\n        if val(s_swap) < val(s_replace):\n            return min_correct_string(s_swap)\n        else:\n            return min_correct_string(s_replace)\n\n    return min_correct_string(s)",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 1647,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    valya_pullover = stdin.readline().strip()\n    tolya_tshirt = stdin.readline().strip()\n\n    spells = []\n    mana_cost = 0\n\n    for i in range(n):\n        if valya_pullover[i] != tolya_tshirt[i]:\n            mana_cost += 1\n            spells.append((valya_pullover[i], tolya_tshirt[i]))\n\n    return f\"{mana_cost}\\n\" + \"\\n\".join([\" \".join(spell) for spell in spells])",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 1648,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    dp = [0] * (k + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        if i <= k:\n            dp[i] = dp[i - 1] * 2\n        else:\n            dp[i] = dp[i - 1] + dp[i - k - 1]\n\n    mod = 10**9 + 7\n    result = [dp[i] % mod for i in range(1, k + 1)]\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 1649,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    total_deliciousness = A + B + C + D\n    \n    for i in range(4):\n        for j in range(i+1, 4):\n            if total_deliciousness - (A if i == 0 else 0) - (B if i == 1 else 0) - (C if i == 2 else 0) - (D if i == 3 else 0) - (A if j == 0 else 0) - (B if j == 1 else 0) - (C if j == 2 else 0) - (D if j == 3 else 0) == 0:\n                return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 1650,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.strip(), 2)\n    mod = 10**9 + 7\n    count = 0\n\n    for a in range(L + 1):\n        for b in range(L - a + 1):\n            if a + b <= L and a + b == a ^ b:\n                count += 1\n                count %= mod\n\n    return str(count)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1651,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P = map(int, stdin.split())\n    for i in range(1, S // 2 + 1):\n        j = S - i\n        if i * j == P:\n            return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 1652,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin\n    T = \"\"\n    while S:\n        if S.endswith(\"dream\"):\n            T += \"dream\"\n            S = S[:-5]\n        elif S.endswith(\"dreamer\"):\n            T += \"dreamer\"\n            S = S[:-7]\n        elif S.endswith(\"erase\"):\n            T += \"erase\"\n            S = S[:-5]\n        elif S.endswith(\"eraser\"):\n            T += \"eraser\"\n            S = S[:-6]\n        else:\n            return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 151,
        "indeed": true
    },
    {
        "number": 1653,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T, Q = stdin.split('\\n')\n    Q = int(Q)\n    queries = [list(map(int, query.split())) for query in stdin.split('\\n')[2:]]\n\n    def is_possible(source: str, target: str) -> bool:\n        if source == target:\n            return True\n\n        if len(source) < len(target):\n            return False\n\n        for i in range(len(source) - len(target) + 1):\n            if source[i:i + len(target)] == target:\n                return True\n            if source[i:i + len(target)] == 'AAA':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'AAB':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'ABA':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'ABC':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'ACB':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'BAC':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'BCA':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'CAB':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n            if source[i:i + len(target)] == 'CBA':\n                if is_possible(source[:i] + source[i + 1:], target):\n                    return True\n        return False\n\n    result = []\n    for query in queries:\n        a, b, c, d = query\n        source = S[a - 1:b]\n        target = T[c - 1:d]\n        result.append('1' if is_possible(source, target) else '0')\n\n    return ''.join(result)",
        "test": "",
        "num_ids": 629,
        "indeed": false
    },
    {
        "number": 1654,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s = list(s)\n    t = list(t)\n    suitability = 0\n    max_suitability = 0\n    result = []\n\n    def is_intersecting(a: str, b: str) -> bool:\n        for i in range(len(a)):\n            if a[i] == b[i] and a[i] != '?':\n                return True\n        return False\n\n    def count_non_intersecting_occurrences(a: str, b: str) -> int:\n        count = 0\n        for i in range(len(a) - len(b) + 1):\n            if not is_intersecting(a[i:i + len(b)], b):\n                count += 1\n        return count\n\n    def swap(a: str, i: int, j: int) -> str:\n        temp = list(a)\n        temp[i], temp[j] = temp[j], temp[i]\n        return ''.join(temp)\n\n    def find_max_suitability(s: str, t: str, suitability: int, max_suitability: int, result: list) -> None:\n        if '?' not in s:\n            non_intersecting_occurrences = count_non_intersecting_occurrences(s, t)\n            if non_intersecting_occurrences > max_suitability:\n                max_suitability = non_intersecting_occurrences\n                result.clear()\n                result.append(s)\n            elif non_intersecting_occurrences == max_suitability:\n                result.append(s)\n            return\n\n        for i in range(len(s)):\n            if s[i] == '?':\n                for j in range(ord('a'), ord('z') + 1):\n                    s[i] = chr(j)\n                    find_max_suitability(s, t, suitability, max_suitability, result)\n                s[i] = '?'\n\n    find_max_suitability(s, t, suitability, max_suitability, result)\n    return result[0]",
        "test": "",
        "num_ids": 525,
        "indeed": false
    },
    {
        "number": 1655,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lengths = list(map(int, stdin.split('\\n')[1].split()))\n\n    alive = [True] * n\n\n    for i in range(n):\n        for j in range(i - lengths[i], i):\n            if alive[j]:\n                alive[j] = False\n\n    return str(sum(alive))",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1656,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    wow_factor = 0\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == \"vvv\":\n            wow_factor += 1\n            i += 3\n        else:\n            i += 1\n    return str(wow_factor)",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 1657,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    devices = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        devices.append((a, b))\n\n    devices.sort(key=lambda x: x[1] / x[0])\n\n    time = 0\n    for i in range(n):\n        time += devices[i][1] / devices[i][0]\n\n    for i in range(n):\n        if devices[i][1] / devices[i][0] <= time:\n            time = devices[i][1] / (devices[i][0] - p)\n        else:\n            break\n\n    return f\"{time:.10f}\"",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 1658,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    d = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    def count_nodes(x, n, d):\n        total = 0\n        for i in range(n):\n            total += pow(sum(d[:i + 1]), x, mod)\n            total -= pow(sum(d[:i + 1]) - d[i], x, mod)\n        return total % mod\n\n    return str(count_nodes(x, n, d))",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1659,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    queue = list(map(lambda x: int(x.strip('+-')), stdin.split()))\n    ice_cream = x\n    distressed_kids = 0\n\n    for i in range(n):\n        if queue[i] > 0:\n            ice_cream += queue[i]\n        else:\n            if abs(queue[i]) <= ice_cream:\n                ice_cream -= abs(queue[i])\n            else:\n                distressed_kids += 1\n\n    return f\"{ice_cream} {distressed_kids}\"",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1660,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.readline().split())\n        graph[u].append((v, w))\n\n    def dfs(node, prev_weight):\n        if not graph[node]:\n            return 0\n        max_trail = 0\n        for next_node, weight in graph[node]:\n            if weight > prev_weight:\n                max_trail = max(max_trail, dfs(next_node, weight) + 1)\n        return max_trail\n\n    max_trail = 0\n    for i in range(1, n + 1):\n        max_trail = max(max_trail, dfs(i, -1))\n\n    return str(max_trail)",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 1661,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    a = list(map(int, stdin.readline().split()))\n\n    games_bought = 0\n    i = 0\n    j = 0\n\n    while i < n and j < m:\n        if c[i] <= a[j]:\n            games_bought += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n\n    return str(games_bought)",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1662,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def is_stairs(seq):\n        for i in range(1, len(seq)):\n            if seq[i] - seq[i - 1] != 1:\n                return False\n        return True\n\n    max_len = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            if is_stairs(b[i:j + 1]):\n                max_len = max(max_len, j - i + 1)\n\n    return str(max_len) + '\\n' + ' '.join(map(str, b[:max_len]))",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1663,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    total_sum = 0\n    modulo = 10**9 + 7\n\n    for i in range(len(str(n))):\n        for j in range(i, len(str(n))):\n            if int(str(n)[:i] + str(n)[j+1:]) > 0:\n                total_sum += int(str(n)[:i] + str(n)[j+1:])\n\n    return total_sum % modulo",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 1664,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    lines = [stdin.readline().strip() for _ in range(n)]\n\n    # Check if the program is already minimal\n    if all(line.startswith(\"res=\") for line in lines):\n        return f\"{n}\\n{'\\n'.join(lines)}\"\n\n    # Remove lines that don't affect the result\n    lines = [line for line in lines if not line.startswith(\"tmp=\")]\n\n    # Combine lines that assign to the same variable\n    combined_lines = []\n    assigned_variables = set()\n    for line in lines:\n        if \"=\" not in line:\n            combined_lines.append(line)\n        else:\n            lvalue, rvalue = line.split(\"=\")\n            if lvalue in assigned_variables:\n                continue\n            assigned_variables.add(lvalue)\n            combined_lines.append(line)\n\n    # Remove redundant lines\n    res_value = None\n    for line in reversed(combined_lines):\n        if line.startswith(\"res=\"):\n            res_value = line.split(\"=\")[1]\n            break\n\n    if res_value is not None:\n        for line in reversed(combined_lines):\n            if line.startswith(res_value):\n                combined_lines.remove(line)\n                break\n\n    # Remove unnecessary variables\n    used_variables = set()\n    for line in combined_lines:\n        if \"=\" not in line:\n            continue\n        lvalue, rvalue = line.split(\"=\")\n        used_variables.add(lvalue)\n        for var in rvalue:\n            if var.isalpha():\n                used_variables.add(var)\n\n    for line in reversed(combined_lines):\n        if line.startswith(\"res=\"):\n            continue\n        if line.split(\"=\")[0] not in used_variables:\n            combined_lines.remove(line)\n\n    # Remove unnecessary operations\n    for line in combined_lines:\n        if \"=\" not in line:\n            continue\n        lvalue, rvalue = line.split(\"=\")\n        if rvalue.count(\"$\") == 1:\n            rvalue = rvalue.replace(\"$\", \"\")\n        if rvalue.count(\"^\") == 1:\n            rvalue = rvalue.replace(\"^\", \"\")\n        if rvalue.count(\"#\") == 1:\n            rvalue = rvalue.replace(\"#\", \"\")\n        if rvalue.count(\"&\") == 1:\n            rvalue = rvalue.replace(\"&\", \"\")\n        combined_lines[combined_lines.index(line)] = f\"{lvalue}={rvalue}\"\n\n    # Remove lines that don't affect the result\n    lines = [line for line in combined_lines if not line.startswith(\"tmp=\")]\n\n    return f\"{len(lines)}\\n{'\\n'.join(lines)}\"",
        "test": "",
        "num_ids": 695,
        "indeed": false
    },
    {
        "number": 1665,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_mex(node, parent, mex_set):\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                mex_set.union(get_mex(neighbor, node, mex_set))\n        return mex_set\n\n    def dfs(node, parent, labels, mex_set):\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, labels, mex_set)\n                labels[node].union(labels[neighbor])\n        labels[node].union(mex_set - labels[node])\n\n    n = int(stdin.readline().strip())\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        tree[u].append(v)\n        tree[v].append(u)\n\n    mex_set = set(range(n - 1))\n    labels = [set() for _ in range(n + 1)]\n    dfs(1, 0, labels, mex_set)\n\n    return \" \".join(map(str, [min(labels[node]) for node in range(2, n + 1)]))",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 1666,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    n = 0\n    for c in range(a, x + 1):\n        for d in range(b, y + 1):\n            if c + d - a - b >= (x - a) + (y - b):\n                n += 1\n    output = [f\"{c} {d}\" for c in range(a, x + 1) for d in range(b, y + 1) if c + d - a - b >= (x - a) + (y - b)]\n    return f\"{n}\\n\" + \"\\n\".join(output)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 1667,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    distances = list(map(int, stdin.split('\\n')[1].split()))\n\n    distances.sort()\n\n    max_locations = 0\n    k = 0\n\n    for i in range(1, distances[-1] + 1):\n        locations = 0\n        current_location = 0\n        for j in range(n):\n            if distances[j] >= i:\n                locations += 1\n                current_location = j\n        if locations > max_locations:\n            max_locations = locations\n            k = i\n\n    return str(k)",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 1668,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def change_pin(pin: str, index: int) -> str:\n        digits = set(pin)\n        for digit in digits:\n            new_pin = pin[:index] + digit + pin[index + 1:]\n            if new_pin != pin:\n                return new_pin\n        return pin\n\n    def make_unique(pins: list) -> int:\n        changes = 0\n        unique_pins = set()\n        for pin in pins:\n            while pin in unique_pins:\n                changes += 1\n                for i in range(4):\n                    pin = change_pin(pin, i)\n                    if pin not in unique_pins:\n                        break\n            unique_pins.add(pin)\n        return changes\n\n    test_cases = stdin.split('\\n')\n    test_cases = test_cases[1:]\n    result = []\n\n    for i in range(0, len(test_cases), 5):\n        n = int(test_cases[i])\n        pins = test_cases[i + 1 : i + 1 + n]\n        changes = make_unique(pins)\n        result.append(str(changes))\n        result.extend(pins)\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 1669,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        reserved_tokens = lines[1].split()\n        m = int(lines[2])\n        source_code = lines[3:]\n        return n, reserved_tokens, m, source_code\n\n    def minify_source(source_code: list, reserved_tokens: list) -> str:\n        def parse_line(line: str) -> list:\n            tokens = []\n            i = 0\n            while i < len(line):\n                if line[i] == '#':\n                    break\n                elif line[i] == ' ':\n                    i += 1\n                elif line[i].isdigit():\n                    j = i\n                    while j < len(line) and line[j].isdigit():\n                        j += 1\n                    tokens.append(line[i:j])\n                    i = j\n                elif line[i].isalpha() or line[i] == '_' or line[i] == '$':\n                    j = i\n                    while j < len(line) and (line[j].isalpha() or line[j].isdigit() or line[j] == '_' or line[j] == '$'):\n                        j += 1\n                    token = line[i:j]\n                    if token not in reserved_tokens:\n                        tokens.append(token)\n                    else:\n                        tokens.append(token)\n                    i = j\n            return tokens\n\n        def rename_words(tokens: list) -> list:\n            word_tokens = [token for token in tokens if token[0].isalpha()]\n            target_words = [word for word in 'abcdefghijklmnopqrstuvwxyz']\n            target_words += [f'{word}{letter}' for word in target_words for letter in 'abcdefghijklmnopqrstuvwxyz']\n            target_words = [word for word in target_words if word not in reserved_tokens]\n            word_map = {}\n            for i, word in enumerate(word_tokens):\n                if word not in word_map:\n                    word_map[word] = target_words[i]\n            return [word_map.get(token, token) for token in tokens]\n\n        minified_source = []\n        for line in source_code:\n            tokens = parse_line(line)\n            renamed_tokens = rename_words(tokens)\n            minified_source.append(' '.join(renamed_tokens))\n        return '\\n'.join(minified_source)\n\n    n, reserved_tokens, m, source_code = parse_input(stdin)\n    minified_source = minify_source(source_code, reserved_tokens)\n    return minified_source ",
        "test": "",
        "num_ids": 690,
        "indeed": false
    },
    {
        "number": 1670,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    home_team, away_team = stdin.split('\\n')[:2]\n    n = int(stdin.split('\\n')[2])\n    fouls = stdin.split('\\n')[3:]\n\n    yellow_cards = {}\n    red_cards = {}\n\n    for foul in fouls:\n        minute, team, player, card_type = foul.split()\n        minute = int(minute)\n        player = int(player)\n\n        if card_type == 'y':\n            if team == 'h':\n                if player not in yellow_cards:\n                    yellow_cards[player] = minute\n            else:\n                if player not in yellow_cards:\n                    yellow_cards[player] = minute\n        else:\n            if team == 'h':\n                if player not in red_cards:\n                    red_cards[player] = minute\n            else:\n                if player not in red_cards:\n                    red_cards[player] = minute\n\n    for player, minute in yellow_cards.items():\n        if player in red_cards:\n            if red_cards[player] > minute:\n                print(home_team, player, red_cards[player])\n        else:\n            print(home_team, player, minute)\n\n    for player, minute in red_cards.items():\n        if player not in yellow_cards:\n            print(away_team, player, minute)\n\n    return \"\"",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 1671,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    m = sorted(m)\n    if n == 1:\n        return \"0\"\n    elif n % 2 == 0:\n        return str(max(m[n//2-1], m[n//2]) - min(m[n//2-1], m[n//2]))\n    else:\n        return str(m[n//2] - m[n//2-1])",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1672,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    magnets = stdin.split('\\n')[1:]\n    groups = []\n    current_group = []\n\n    for i in range(n):\n        if i == 0 or magnets[i] == magnets[i - 1]:\n            current_group.append(i)\n        else:\n            groups.append(current_group)\n            current_group = [i]\n\n    groups.append(current_group)\n    return str(len(groups))",
        "test": "",
        "num_ids": 127,
        "indeed": true
    },
    {
        "number": 1673,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.sort()\n    beauty_sum = 0\n\n    for i in range(n - k + 1):\n        beauty_sum += a[i + k - 1] - a[i]\n\n    return beauty_sum % 998244353",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1674,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    damage = list(map(int, stdin.readline().split()))\n    hits = stdin.readline().strip()\n\n    dp = [0] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + damage[i - 1]\n\n    for i in range(n - 1, 0, -1):\n        if hits[i] == hits[i - 1]:\n            continue\n        for j in range(i - k, i):\n            dp[i] = max(dp[i], dp[j] + damage[i - 1])\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 1675,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    teams = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    home_kit_games = [0] * n\n    away_kit_games = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if teams[i][0] != teams[j][1]:\n                    home_kit_games[i] += 1\n                else:\n                    away_kit_games[i] += 1\n                if teams[i][1] != teams[j][0]:\n                    home_kit_games[j] += 1\n                else:\n                    away_kit_games[j] += 1\n\n    result = []\n    for i in range(n):\n        result.append(f\"{home_kit_games[i]} {away_kit_games[i]}\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 1676,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(query, server_status, queue):\n        if server_status[\"is_free\"] and not queue:\n            server_status[\"is_free\"] = False\n            return query[\"end_time\"]\n        elif not server_status[\"is_free\"] and len(queue) < server_status[\"max_queue_size\"]:\n            queue.append(query)\n            return -1\n        else:\n            return -1\n\n    def update_server_status(server_status, queue):\n        if not queue:\n            server_status[\"is_free\"] = True\n        else:\n            server_status[\"is_free\"] = False\n            queue.sort(key=lambda x: x[\"start_time\"])\n\n    def process_queries(queries, server_status, queue):\n        result = []\n        for query in queries:\n            if query[\"start_time\"] > server_status[\"current_time\"]:\n                server_status[\"current_time\"] = query[\"start_time\"]\n            query_result = process_query(query, server_status, queue)\n            if query_result != -1:\n                server_status[\"current_time\"] = query_result\n            result.append(query_result)\n            update_server_status(server_status, queue)\n        return result\n\n    lines = stdin.split(\"\\n\")\n    n, b = map(int, lines[0].split())\n    queries = [{\"start_time\": int(t), \"end_time\": int(t) + int(d), \"process_time\": int(d)} for t, d in [map(int, line.split()) for line in lines[1:n + 1]]]\n    server_status = {\"is_free\": True, \"current_time\": 0, \"max_queue_size\": b}\n    queue = []\n    result = process_queries(queries, server_status, queue)\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 464,
        "indeed": false
    },
    {
        "number": 1677,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_almost_arithmetic(seq: list) -> bool:\n        if len(seq) < 2:\n            return True\n        for i in range(2, len(seq)):\n            if seq[i] - seq[i - 1] != seq[i - 1] - seq[i - 2]:\n                return False\n        return True\n\n    max_length = 1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_almost_arithmetic(b[i:j]):\n                max_length = max(max_length, j - i)\n\n    return str(max_length)",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1678,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.append(0)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    segments = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] < t:\n                segments += 1\n    return str(segments)",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1679,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    decoded_number = 0\n    current_digit = 0\n    current_ones = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            decoded_number += current_digit * (10 ** current_ones)\n            current_digit = 0\n            current_ones = 0\n        else:\n            current_digit += 1\n            current_ones += 1\n\n    decoded_number += current_digit * (10 ** current_ones)\n\n    return str(decoded_number)",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1680,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bin(a[i] ^ a[j]).count('1') == k:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 105,
        "indeed": true
    },
    {
        "number": 1681,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    paper_colors, garland_colors = stdin.split('\\n')\n    paper_count = [paper_colors.count(c) for c in set(paper_colors)]\n    garland_count = [garland_colors.count(c) for c in set(garland_colors)]\n\n    total_area = 0\n    for i in range(len(paper_count)):\n        if paper_count[i] >= garland_count[i]:\n            total_area += garland_count[i]\n        else:\n            return '-1'\n\n    return str(total_area)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 1682,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    a.sort()\n    b.sort()\n\n    total_cost = 0\n    for i in range(k):\n        total_cost += a[i]\n    for i in range(k, n):\n        total_cost += b[i]\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1683,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def f(x, y):\n        p, q = len(str(x)), len(str(y))\n        if p >= q:\n            return int(str(x)[:p - q + 1] + str(y) + str(x)[p - q + 1:])\n        else:\n            return int(str(y)[:q - p] + str(x) + str(y)[q - p:])\n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result += f(a[i], a[j])\n\n    return str(result % 998244353)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 1684,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    segments = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def is_rotational_symmetry(k: int) -> bool:\n        for a, b in segments:\n            if (a + k) % n != (b + k) % n:\n                return False\n        return True\n\n    for k in range(1, n):\n        if is_rotational_symmetry(k):\n            return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 1685,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    queries = []\n    for _ in range(q):\n        u_i = int(stdin.readline())\n        s_i = stdin.readline().strip()\n        queries.append((u_i, s_i))\n\n    def get_parent(vertex: int) -> int:\n        return vertex // 2\n\n    def get_left_child(vertex: int) -> int:\n        return vertex * 2\n\n    def get_right_child(vertex: int) -> int:\n        return vertex * 2 + 1\n\n    def process_path(vertex: int, path: str) -> int:\n        for char in path:\n            if char == 'L' and vertex > 1 and vertex % 2 == 0:\n                vertex = get_left_child(vertex)\n            elif char == 'R' and vertex > 1 and vertex % 2 == 1:\n                vertex = get_right_child(vertex)\n            elif char == 'U':\n                vertex = get_parent(vertex)\n        return vertex\n\n    result = []\n    for u_i, s_i in queries:\n        result.append(process_path(u_i, s_i))\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 324,
        "indeed": false
    },
    {
        "number": 1686,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_ip(ip: str) -> bool:\n        for octet in ip.split('.'):\n            if not octet.isdigit() or not 0 <= int(octet) <= 255 or (octet[0] == '0' and len(octet) > 1):\n                return False\n        return True\n\n    def is_valid_subnet_mask(mask: str) -> bool:\n        if not is_valid_ip(mask):\n            return False\n        binary_mask = ''.join([format(int(octet), '08b') for octet in mask.split('.')])\n        if not binary_mask.startswith('11111111') or not binary_mask.endswith('00000000'):\n            return False\n        return True\n\n    def get_network_address(ip: str, mask: str) -> str:\n        ip_binary = ''.join([format(int(octet), '08b') for octet in ip.split('.')])\n        mask_binary = ''.join([format(int(octet), '08b') for octet in mask.split('.')])\n        network_binary = ''.join([str(int(ip_bit) & int(mask_bit)) for ip_bit, mask_bit in zip(ip_binary, mask_binary)])\n        network_octets = [str(int(network_binary[i:i + 8], 2)) for i in range(0, 32, 8)]\n        return '.'.join(network_octets)\n\n    def count_ones(mask: str) -> int:\n        return sum(int(octet) for octet in mask.split('.'))\n\n    n, k = map(int, stdin.readline().split())\n    ip_addresses = [stdin.readline().strip() for _ in range(n)]\n\n    for mask_binary in range(2 ** 32):\n        mask = '.'.join([str(mask_binary >> i & 0xFF) for i in range(24, -1, -8)])\n        if not is_valid_subnet_mask(mask):\n            continue\n        networks = set()\n        for ip in ip_addresses:\n            network = get_network_address(ip, mask)\n            networks.add(network)\n        if len(networks) == k:\n            return mask\n\n    return '-1'",
        "test": "",
        "num_ids": 586,
        "indeed": false
    },
    {
        "number": 1687,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(1, max(a) + 1):\n        if all(x % i == 0 for x in a):\n            return str(i)\n    return '-1'",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 1688,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    coolnesses = list(map(int, stdin.readline().strip().split()))\n\n    def max_coolness(played_tracks):\n        return max(coolnesses[i] for i in played_tracks)\n\n    def will_turn_off(start_track):\n        played_tracks = set()\n        current_track = start_track\n        while current_track not in played_tracks:\n            played_tracks.add(current_track)\n            current_track = (current_track + 1) % n\n            if coolnesses[current_track] < max_coolness(played_tracks) // 2:\n                return len(played_tracks)\n        return -1\n\n    result = [will_turn_off(i) for i in range(n)]\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 1689,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_empty_seats(bus_config: list) -> list:\n        empty_seats = []\n        for i, row in enumerate(bus_config):\n            for j in range(0, 4, 2):\n                if row[j] == 'O' and row[j + 1] == 'O':\n                    empty_seats.append((i, j))\n        return empty_seats\n\n    def print_bus_config(bus_config: list, empty_seats: list) -> str:\n        output = []\n        for i, row in enumerate(bus_config):\n            if (i, 0) in empty_seats:\n                row = '+' + row[1:]\n            if (i, 2) in empty_seats:\n                row = row[:3] + '+' + row[4:]\n            output.append(row)\n        return '\\n'.join(output)\n\n    n = int(stdin.readline().strip())\n    bus_config = [list(stdin.readline().strip()) for _ in range(n)]\n\n    empty_seats = find_empty_seats(bus_config)\n\n    if not empty_seats:\n        return \"NO\"\n\n    for i, (row, col) in enumerate(empty_seats):\n        if (row, col + 2) in empty_seats:\n            empty_seats[i] = (row, col + 2)\n            break\n\n    if (row, col + 2) not in empty_seats:\n        return \"NO\"\n\n    return \"YES\\n\" + print_bus_config(bus_config, empty_seats) ",
        "test": "",
        "num_ids": 401,
        "indeed": false
    },
    {
        "number": 1690,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort(reverse=True)\n    total = 0\n\n    for i in range(n):\n        total += a[i]\n        for j in range(i + 1, n):\n            if a[j] >= a[i]:\n                total -= a[i]\n                break\n\n    return str(total)",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 1691,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    for i in range(n):\n        if i == 0:\n            sections = 2\n        elif i % 2 == 0:\n            sections += 1\n        else:\n            sections += 2\n        result.append(sections)\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 1692,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            if int(s[i:j + 1]) % 4 == 0:\n                count += 1\n\n    return count\n",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1693,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    limits = list(map(int, stdin.split('\\n')[1].split()))\n\n    floors = [min(limits[i], limits[i - 1] + 1) if i > 0 else limits[0] for i in range(n)]\n\n    for i in range(1, n - 1):\n        floors[i] = min(floors[i], limits[i - 1] + 1, limits[i + 1] + 1)\n\n    return ' '.join(map(str, floors))",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 1694,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, f = map(int, stdin.split()[:4])\n    watch_steps = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    actions = ['X'] * (m + 1)\n    actions[0] = 'X' if s == 1 else 'L'\n    actions[m] = 'X' if f == n else 'R'\n\n    for i in range(m):\n        t, l, r = watch_steps[i]\n        if s in range(l, r + 1):\n            actions[t - 1] = 'X'\n        elif s < l:\n            actions[t - 1] = 'L'\n        else:\n            actions[t - 1] = 'R'\n\n    return ''.join(actions[1:])",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 1695,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    answers = [stdin.readline().strip() for _ in range(n)]\n    points = list(map(int, stdin.readline().split()))\n\n    max_score = 0\n    for i in range(m):\n        max_score += max(points[i] * answers.count(answers[j][i]) for j in range(n))\n\n    return str(max_score)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 1696,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    centers = []\n    for i in range(k):\n        x, y = map(int, stdin.split()[3 + 2 * i:3 + 2 * (i + 1)])\n        centers.append((x, y))\n\n    def is_neighbour(x1, y1, x2, y2):\n        return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1\n\n    def find_min_time(x, y):\n        time = 0\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        queue = [(x, y)]\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                cx, cy = queue.pop(0)\n                if not visited[cx - 1][cy - 1]:\n                    visited[cx - 1][cy - 1] = True\n                    for x2, y2 in centers:\n                        if is_neighbour(cx, cy, x2, y2):\n                            queue.append((x2, y2))\n            time += 1\n        return time\n\n    min_time = float('inf')\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if (x, y) not in centers:\n                centers.append((x, y))\n                min_time = min(min_time, find_min_time(x, y))\n                centers.pop()\n\n    return str(min_time)",
        "test": "",
        "num_ids": 406,
        "indeed": false
    },
    {
        "number": 1697,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    board = []\n    for _ in range(n):\n        board.append(stdin.readline().strip())\n\n    def is_cycle(x, y, color):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        if board[x][y] != color:\n            return False\n        if x == 0 and y == 0:\n            return True\n        board[x] = board[x][:y] + '0' + board[x][y + 1:]\n        return (\n            is_cycle(x - 1, y, color)\n            or is_cycle(x + 1, y, color)\n            or is_cycle(x, y - 1, color)\n            or is_cycle(x, y + 1, color)\n        )\n\n    for i in range(n):\n        for j in range(m):\n            if is_cycle(i, j, board[i][j]):\n                return \"Yes\"\n    return \"No\"\n",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 1698,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    floors = list(map(int, stdin.split()[2:]))\n    floors.sort()\n\n    total_time = 0\n    current_floor = 1\n    current_people = 0\n\n    for i in range(n):\n        total_time += abs(current_floor - floors[i])\n        current_floor = floors[i]\n        current_people += 1\n\n        if current_people == k or i == n - 1:\n            total_time += abs(current_floor - 1)\n            current_people = 0\n            current_floor = 1\n\n    return str(total_time)",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 1699,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            table[i][j] = (i + 1) * (j + 1)\n\n    return '\\n'.join([' '.join(map(str, row)) for row in table])",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1700,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_rbs(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def nesting_depth(s: str) -> int:\n        depth = 0\n        max_depth = 0\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n                depth += 1\n                max_depth = max(max_depth, depth)\n            else:\n                if not stack:\n                    return -1\n                stack.pop()\n                depth -= 1\n        return max_depth if not stack else -1\n\n    def find_coloring(s: str) -> str:\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                r = s[:i] + \"0\" * (j - i + 1) + \"1\" * (len(s) - j - 1)\n                b = \"1\" * (i) + \"0\" * (j - i + 1) + \"1\" * (len(s) - j - 1)\n                if is_rbs(r) and is_rbs(b):\n                    return r + b\n        return None\n\n    def min_nesting_depth(s: str) -> int:\n        r_depth = nesting_depth(s)\n        b_depth = nesting_depth(\"1\" * len(s))\n        return max(r_depth, b_depth)\n\n    coloring = find_coloring(s)\n    if coloring is None:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(min_nesting_depth(coloring))",
        "test": "",
        "num_ids": 474,
        "indeed": false
    },
    {
        "number": 1701,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    servers = {}\n    for _ in range(n):\n        name, ip = stdin.readline().split()\n        servers[ip] = name\n\n    commands = []\n    for _ in range(m):\n        command, ip = stdin.readline().strip().split(\" \")\n        commands.append(f\"{command} {ip}; #{servers[ip]}\")\n\n    return \"\\n\".join(commands)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1702,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_points(solvers_fraction):\n        if solvers_fraction >= 1 / 32:\n            return 3000\n        elif solvers_fraction >= 1 / 16:\n            return 2500\n        elif solvers_fraction >= 1 / 8:\n            return 2000\n        elif solvers_fraction >= 1 / 4:\n            return 1500\n        elif solvers_fraction >= 1 / 2:\n            return 1000\n        else:\n            return 500\n\n    def get_points(solvers_fraction, time):\n        max_points = get_max_points(solvers_fraction)\n        return max_points * (1 - time / 250)\n\n    def can_beat_petya(n, participant_data, petya_data):\n        petya_points = 0\n        vasya_points = 0\n\n        for i in range(1, n + 1):\n            for j in range(1, 6):\n                if participant_data[i - 1][j - 1] != -1:\n                    time = participant_data[i - 1][j - 1]\n                    if i == 1:\n                        solvers_fraction = (petya_data[j - 1] + 1) / (time + 1)\n                        petya_points += get_points(solvers_fraction, time)\n                    else:\n                        solvers_fraction = (petya_data[j - 1] + 2) / (time + 1)\n                        petya_points += get_points(solvers_fraction, time)\n                if i == 1:\n                    solvers_fraction = 1 / (time + 1)\n                    vasya_points += get_points(solvers_fraction, time)\n\n        return vasya_points > petya_points\n\n    def find_min_new_accounts(n, participant_data, petya_data):\n        min_new_accounts = float('inf')\n        for i in range(1, n + 1):\n            for j in range(1, 6):\n                if participant_data[i - 1][j - 1] == -1:\n                    for k in range(1, 1000001):\n                        new_participant_data = participant_data.copy()\n                        new_participant_data[i - 1][j - 1] = k\n                        if can_beat_petya(n, new_participant_data, petya_data):\n                            min_new_accounts = min(min_new_accounts, k)\n                            break\n        return min_new_accounts if min_new_accounts != float('inf') else -1\n\n    n = int(stdin.readline())\n    participant_data = []\n    petya_data = [0] * 5\n\n    for i in range(n):\n        data = list(map(int, stdin.readline().split()))\n        participant_data.append(data)\n        if i == 1:\n            petya_data = data\n\n    min_new_accounts = find_min_new_accounts(n, participant_data, petya_data)\n    return str(min_new_accounts)",
        "test": "",
        "num_ids": 849,
        "indeed": false
    },
    {
        "number": 1703,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    sequences = [stdin.readline().strip() for _ in range(n)]\n\n    def is_regular(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j or is_regular(sequences[i]):\n                if is_regular(sequences[i] + sequences[j]):\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 1704,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(digit, k):\n        count = digit.count('1')\n        return count == k or count == k + 1\n\n    def get_max_number(digits, k):\n        max_number = ''\n        for digit in digits:\n            if is_valid(digit, k):\n                max_number += '9'\n            else:\n                max_number += '8'\n        return max_number\n\n    n, k = map(int, stdin.readline().strip().split())\n    digits = [stdin.readline().strip() for _ in range(n)]\n\n    max_number = get_max_number(digits, k)\n    if max_number[0] == '8':\n        return '-1'\n    return max_number",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 1705,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    doors = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    left_closed = 0\n    right_closed = 0\n    k = 0\n\n    for i in range(n):\n        if doors[i] == 0:\n            left_closed += 1\n        else:\n            right_closed += 1\n\n        if left_closed == 0 or right_closed == 0:\n            k = i + 1\n            break\n\n    return str(k)",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 1706,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    k = 0\n    result = s\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def reverse_substring(s: str, i: int) -> str:\n        return s[:i] + s[i:][::-1]\n\n    while not is_palindrome(result) and k < 30:\n        for i in range(2, n):\n            if is_palindrome(reverse_substring(result, i)):\n                result = reverse_substring(result, i)\n                k += 1\n                print(\"L\", i)\n                break\n\n        for i in range(n - 1, 1, -1):\n            if is_palindrome(reverse_substring(result, i)):\n                result = reverse_substring(result, i)\n                k += 1\n                print(\"R\", i)\n                break\n\n    return str(k)",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 1707,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    choices = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(choices[i] - choices[j]) == abs(choices[i] + choices[j]):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 1708,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n    r = a.copy()\n    total_cost = []\n\n    for _ in range(m):\n        t, d = map(int, stdin.readline().split())\n        cost = 0\n        for _ in range(d):\n            min_r = float('inf')\n            min_i = -1\n            for i in range(n):\n                if r[i] > 0 and r[i] < min_r:\n                    min_r = r[i]\n                    min_i = i\n            if min_i == -1:\n                cost += c[t - 1]\n            else:\n                cost += c[min_i]\n                r[min_i] -= 1\n        total_cost.append(cost)\n\n    return '\\n'.join(map(str, total_cost))",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 1709,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    p = [[0] * (m + 1) for _ in range(n)]\n\n    for i in range(n):\n        p[i] = list(map(int, stdin.readline().split()))\n\n    def dfs(start, color, beauty):\n        if beauty == k:\n            return 0\n        if start == n:\n            return float('inf')\n        if c[start] != 0:\n            return dfs(start + 1, color, beauty)\n\n        ans = float('inf')\n        for i in range(1, m + 1):\n            if color != i:\n                ans = min(ans, p[start][i] + dfs(start + 1, i, beauty + 1))\n        return ans\n\n    res = dfs(0, 0, 0)\n    return str(res) if res != float('inf') else '-1'",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 1710,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            subsegment = arr[i:j + 1]\n            p = 1\n            s = 0\n            for num in subsegment:\n                p *= num\n                s += num\n            if p // s == k:\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 1711,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 998244353\n\n    def count_ascending_sequences(n: int, m: int) -> int:\n        dp = [0] * (m + 1)\n        dp[1] = 1\n        for i in range(2, m + 1):\n            for j in range(1, i):\n                dp[i] += dp[j]\n            dp[i] += 1\n        return sum(dp[i] for i in range(1, m + 1)) * (m - 1)\n\n    def count_descending_sequences(n: int, m: int) -> int:\n        dp = [0] * (m + 1)\n        dp[m] = 1\n        for i in range(m - 1, 0, -1):\n            for j in range(i + 1, m + 1):\n                dp[i] += dp[j]\n            dp[i] += 1\n        return sum(dp[i] for i in range(1, m)) * (m - 1)\n\n    return str(count_ascending_sequences(n, m) * count_descending_sequences(n, m) % mod)",
        "test": "",
        "num_ids": 319,
        "indeed": false
    },
    {
        "number": 1712,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    result = []\n    for i in range(n):\n        v_time = (i + 1) / x\n        o_time = (i + 1) / y\n\n        if v_time + 1 / x >= a[i]:\n            result.append(\"Vanya\")\n        elif o_time + 1 / y >= a[i]:\n            result.append(\"Vova\")\n        else:\n            result.append(\"Both\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1713,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n\n    if s == t:\n        return \"0\"\n\n    for i in range(n):\n        if p[i] == s:\n            s = i + 1\n        if p[i] == t:\n            t = i + 1\n\n    if s == t:\n        return \"0\"\n\n    for i in range(n):\n        if p[p[i] - 1] == s:\n            s = p[i]\n            break\n\n    if s == t:\n        return \"1\"\n\n    for i in range(n):\n        if p[p[p[i] - 1] - 1] == s:\n            s = p[p[i] - 1]\n            break\n\n    if s == t:\n        return \"2\"\n\n    return \"-1\"",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 1714,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = []\n    for i in range(1, n + 1):\n        a.append(i)\n        a.append(n + 1 - i)\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 1715,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, Q = map(int, stdin.split()[0:3])\n    s = list(map(int, stdin.split()[3:3 + A]))\n    t = list(map(int, stdin.split()[3 + A:3 + A + B]))\n    x = list(map(int, stdin.split()[3 + A + B:3 + A + B + Q]))\n\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def find_min_distance(x_i):\n        shrine_index = binary_search(s, x_i)\n        temple_index = binary_search(t, x_i)\n\n        if shrine_index == 0:\n            min_distance_to_shrine = s[0] - x_i\n        else:\n            min_distance_to_shrine = s[shrine_index] - s[shrine_index - 1] + (x_i - s[shrine_index - 1])\n\n        if temple_index == 0:\n            min_distance_to_temple = t[0] - x_i\n        else:\n            min_distance_to_temple = t[temple_index] - t[temple_index - 1] + (x_i - t[temple_index - 1])\n\n        return min_distance_to_shrine + min_distance_to_temple\n\n    result = []\n    for x_i in x:\n        result.append(find_min_distance(x_i))\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 475,
        "indeed": false
    },
    {
        "number": 1716,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = map(int, stdin.split()[0:3])\n    trains = [list(map(int, stdin.split()[3 * i + 3:3 * i + 5])) for i in range(M)]\n    queries = [list(map(int, stdin.split()[3 * M + 3 * i:3 * M + 3 * i + 2])) for i in range(Q)]\n\n    result = []\n    for query in queries:\n        p, q = query\n        count = 0\n        for train in trains:\n            if p <= train[0] and train[1] <= q:\n                count += 1\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 1717,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    x = 10**13\n    for i in range(N, 1, -1):\n        if x % i != 1:\n            x -= (x % i) + 1\n    return str(x)",
        "test": "",
        "num_ids": 66,
        "indeed": false
    },
    {
        "number": 1718,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    A.sort()\n    count = 0\n    for i in range(N - K + 1):\n        if A[i] != A[i + K - 1]:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1719,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 4\n    dp[1] = 16\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * 13 + dp[i - 2] * 3) % mod\n    return str(dp[n])",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1720,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x1, y1, x2, y2 = map(int, stdin.split())\n    field = [list(input()) for _ in range(n)]\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m and field[x - 1][y - 1] == '.'\n\n    def bfs(start, end):\n        queue = [start]\n        visited = set(start)\n        steps = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                if (x, y) == end:\n                    return steps\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny) and (nx, ny) not in visited:\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n            steps += 1\n        return -1\n\n    result = bfs((x1, y1), (x2, y2))\n    return str(result)",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 1721,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    # Count the number of swaps needed to reverse the string\n    swaps = 0\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            swaps += 1\n\n    return swaps",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1722,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    names = [stdin.readline().strip() for _ in range(n)]\n\n    first_letters = {}\n    for name in names:\n        first_letter = name[0]\n        if first_letter in first_letters:\n            first_letters[first_letter] += 1\n        else:\n            first_letters[first_letter] = 1\n\n    x = sum(first_letters.values())\n    for count in first_letters.values():\n        x -= count * (count - 1) // 2\n\n    return str(x)",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 1723,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, depth):\n        left_depth = depth + 1\n        right_depth = depth + 1\n        for child in tree[node]:\n            if child != parent:\n                left, right = dfs(child, node, depth + 1)\n                if left > right:\n                    left, right = right, left\n                left_depth = max(left_depth, left)\n                right_depth = max(right_depth, right)\n        return left_depth, right_depth\n\n    def build_tree(edges):\n        tree = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        return tree\n\n    def find_min_vertex_cover(tree):\n        even_depth, odd_depth = dfs(1, -1, 0)\n        return min(even_depth, odd_depth)\n\n    n = int(stdin.strip())\n    if n == 2:\n        return \"-1\\n1 2\"\n\n    # First tree\n    edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 7), (4, 8)]\n    tree = build_tree(edges)\n    min_vertex_cover = find_min_vertex_cover(tree)\n    if min_vertex_cover != 3:\n        first_section = \"-1\\n\"\n    else:\n        first_section = \"\\n\".join(f\"{u} {v}\" for u, v in edges) + \"\\n\"\n\n    # Second tree\n    edges = [(1, 2), (1, 3), (2, 4), (2, 5), (2, 6), (3, 7), (6, 8)]\n    tree = build_tree(edges)\n    min_vertex_cover = find_min_vertex_cover(tree)\n    if min_vertex_cover != 3:\n        second_section = \"-1\\n\"\n    else:\n        second_section = \"\\n\".join(f\"{u} {v}\" for u, v in edges) + \"\\n\"\n\n    return first_section + second_section",
        "test": "",
        "num_ids": 555,
        "indeed": false
    },
    {
        "number": 1724,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m, 2)\n\n    def f(x: int) -> int:\n        result = 0\n        for i in range(n):\n            if x & (1 << i):\n                result += a[i]\n        return result\n\n    max_value = float('-inf')\n    for x in range(m + 1):\n        max_value = max(max_value, f(x))\n\n    return str(max_value)",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 1725,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    matrix = [list(map(int, stdin.split()[i + 3:i + 4 + m])) for i in range(3, 3 + n)]\n\n    min_moves = float('inf')\n    for i in range(n):\n        for j in range(m):\n            target = matrix[i][j] + d\n            count = 0\n            for k in range(n):\n                for l in range(m):\n                    if matrix[k][l] != target:\n                        count += 1\n            min_moves = min(min_moves, count)\n\n    return str(min_moves) if min_moves != float('inf') else '-1'",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 1726,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    work_times = list(map(int, input().split()))\n\n    total_seconds = 0\n    for work_time in work_times:\n        total_seconds += work_time\n\n    days_to_read = total_seconds // t + 1\n    return str(days_to_read)\n\nn, t = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(solution(f\"{n} {t}\")) ",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 1727,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    trees = []\n    for i in range(n):\n        x, h = map(int, stdin.readline().split())\n        trees.append((x, h))\n\n    trees.sort(key=lambda x: x[0])\n\n    def is_valid(tree1, tree2):\n        if tree1[0] - tree1[1] >= tree2[0] - tree2[1]:\n            return True\n        if tree1[0] + tree1[1] <= tree2[0] + tree2[1]:\n            return True\n        return False\n\n    count = 0\n    for i in range(n):\n        if i == 0:\n            if is_valid(trees[i], trees[i + 1]):\n                count += 1\n        elif i == n - 1:\n            if is_valid(trees[i - 1], trees[i]):\n                count += 1\n        else:\n            if is_valid(trees[i - 1], trees[i]) and is_valid(trees[i], trees[i + 1]):\n                count += 1\n            elif is_valid(trees[i - 1], trees[i]) or is_valid(trees[i], trees[i + 1]):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 327,
        "indeed": false
    },
    {
        "number": 1728,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p, *c = map(int, stdin.split())\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        tree[p[i - 2]].append(i)\n\n    def dfs(node, color):\n        if not tree[node]:\n            return 0\n        steps = 1\n        for child in tree[node]:\n            if c[child - 1] != color:\n                steps += dfs(child, c[child - 1])\n            else:\n                steps += dfs(child, color)\n        return steps\n\n    return str(dfs(1, c[0]))",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 1729,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    result = []\n\n    def run_program(s: str) -> List[int]:\n        cp = 0\n        dp = 1\n        digits = [int(d) for d in s if d.isdigit()]\n        output = [0] * 10\n\n        while 0 <= cp < len(s):\n            if s[cp] == \"<\":\n                dp = -1\n            elif s[cp] == \">\":\n                dp = 1\n            elif s[cp].isdigit():\n                digit = int(s[cp])\n                output[digit] += 1\n                if digit == 0:\n                    digits.remove(digit)\n                else:\n                    digits[digits.index(digit)] -= 1\n            cp += dp\n\n        return output\n\n    for _ in range(q):\n        l, r = map(int, stdin.readline().split())\n        result.append(run_program(\"\".join(s[l - 1:r])))\n\n    return \"\\n\".join(\" \".join(map(str, output)) for output in result)\n",
        "test": "",
        "num_ids": 296,
        "indeed": false
    },
    {
        "number": 1730,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, parent):\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                if find_cycle(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    def dfs(node, visited, parent, cycle):\n        visited[node] = True\n        cycle.append(node)\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node, cycle):\n                    return True\n        if parent and not find_cycle(node, visited, parent):\n            cycle.pop()\n            return False\n        return True\n\n    n, m, k = map(int, stdin.readline().split())\n    adjacency_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n\n    for node in range(1, n + 1):\n        if len(adjacency_list[node]) < k:\n            continue\n        visited = [False] * (n + 1)\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                cycle = []\n                if dfs(neighbor, visited, node, cycle):\n                    return f\"{len(cycle)}\\n{' '.join(map(str, cycle))}\"\n    return \"No cycle found\"",
        "test": "",
        "num_ids": 404,
        "indeed": false
    },
    {
        "number": 1731,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_pairs(n: int, m: int) -> int:\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[0][1] = 1\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod\n                if i == j:\n                    dp[i][j] -= dp[i - 1][j - 1]\n\n        return dp[m][n]\n\n    return str(count_pairs(n, m))",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 1732,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    l = list(map(int, stdin.split('\\n')[1].split()))\n    c = list(map(int, stdin.split('\\n')[2].split()))\n\n    if n == 1:\n        return -1\n\n    l.sort(reverse=True)\n    c.sort()\n\n    total_cost = sum(c[:2])\n    max_jump = l[0] * 2\n\n    for i in range(2, n):\n        if l[i] > max_jump:\n            total_cost += c[i]\n            max_jump += l[i] * 2\n\n    if max_jump < float('inf'):\n        return str(total_cost)\n    else:\n        return -1",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 1733,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, prev):\n        if node == y:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != prev and neighbor not in visited:\n                if not dfs(neighbor, visited, node):\n                    return False\n        visited.remove(node)\n        return True\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                if i == x or j == x:\n                    continue\n                visited = set()\n                if dfs(i, visited, -1):\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 1734,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    phone_numbers = [stdin.readline().strip() for _ in range(n)]\n\n    def is_substring(subseq, seq):\n        return subseq in seq\n\n    def find_shortest_substring(phone_number):\n        for i in range(1, len(phone_number)):\n            for j in range(len(phone_number) - i + 1):\n                subseq = phone_number[j:j + i]\n                if all(is_substring(subseq, phone) for phone in phone_numbers if phone != phone_number):\n                    return subseq\n        return \"\"\n\n    shortest_substrings = [find_shortest_substring(phone_number) for phone_number in phone_numbers]\n\n    return \"\\n\".join(shortest_substrings)\n",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1735,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n % 2 == 1:\n        return \"Yes\"\n    for i in range(n // 2):\n        if s[2 * i] != s[2 * i + 1]:\n            return \"Yes\"\n    return \"No\"",
        "test": "",
        "num_ids": 78,
        "indeed": false
    },
    {
        "number": 1736,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    i = 0\n    books_read = 0\n    while i < n and (i + t) < n:\n        if a[i] <= t:\n            t -= a[i]\n            books_read += 1\n        i += 1\n    return str(books_read)\n\nn, t = map(int, input().split())\na = list(map(int, input().split()))\nprint(solution(n, t, a)) ",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1737,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def find_dependencies(project, version, visited, dependencies):\n        if (project, version) in visited:\n            return\n        visited.add((project, version))\n        for dependency in dependencies[(project, version)]:\n            find_dependencies(dependency[0], dependency[1], visited, dependencies)\n\n    def resolve_collisions(projects):\n        result = []\n        for project, versions in projects.items():\n            if len(versions) > 1:\n                versions.sort(key=lambda x: x[1], reverse=True)\n                result.append((project, versions[0][0], versions[0][1]))\n            else:\n                result.append((project, versions[0][0], versions[0][1]))\n        return result\n\n    def find_project_dependencies(project, version, dependencies):\n        visited = set()\n        find_dependencies(project, version, visited, dependencies)\n        return visited\n\n    def build_dependencies(projects):\n        dependencies = defaultdict(list)\n        for project, version in projects:\n            for dependency in projects[(project, version)]:\n                dependencies[(project, version)].append(dependency)\n        return dependencies\n\n    def read_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        projects = {}\n        for i in range(1, n * 2, 2):\n            project, version = lines[i].split()\n            version = int(version)\n            projects[(project, version)] = [(x.split()[0], int(x.split()[1])) for x in lines[i + 1].split()]\n        return projects\n\n    projects = read_input(stdin)\n    dependencies = build_dependencies(projects)\n    project, version = list(projects.keys())[0]\n    visited = find_project_dependencies(project, version, dependencies)\n    resolved_collisions = resolve_collisions(visited)\n    result = [project for project, version, _ in resolved_collisions if project != \"a\"]\n    result.sort()\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 504,
        "indeed": false
    },
    {
        "number": 1738,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = n - i\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i:j] == s[j:i + j - i]:\n                dp[i + j - i] = min(dp[i + j - i], dp[i] + j - i)\n    return dp[n - 1]",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1739,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    s = sum(x ** -a_i for a_i in a)\n    t = sum(x ** -a_i for a_i in range(n + 1))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = gcd(s, t) % (10**9 + 7)\n\n    return str(result)",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 1740,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph):\n        visited = [False] * len(graph)\n        q = []\n        for i in range(len(graph)):\n            if not visited[i]:\n                q.append(i)\n                while q:\n                    u = q.pop(0)\n                    visited[u] = True\n                    for v in graph[u]:\n                        if not visited[v]:\n                            q.append(v)\n        return visited\n\n    def dfs(graph, start, visited, order):\n        for v in graph[start]:\n            if not visited[v]:\n                visited[v] = True\n                dfs(graph, v, visited, order)\n        order.append(start)\n\n    def topological_sort(graph):\n        visited = find_cycle(graph)\n        order = []\n        for i in range(len(graph)):\n            if not visited[i]:\n                dfs(graph, i, visited, order)\n        return order[::-1]\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().split())\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n\n    order = topological_sort(graph)\n    return \" \".join(map(str, order + [order[0]]))",
        "test": "",
        "num_ids": 356,
        "indeed": false
    },
    {
        "number": 1741,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def min_radius(lairs):\n        min_r = float('inf')\n        for lair in lairs:\n            r = distance(0, 0, lair[0], lair[1])\n            min_r = min(min_r, r)\n        return min_r\n\n    def max_radius(lairs):\n        max_r = float('-inf')\n        for lair in lairs:\n            r = distance(0, 0, lair[0], lair[1])\n            max_r = max(max_r, r)\n        return max_r\n\n    def is_possible(lairs):\n        min_r = min_radius(lairs)\n        max_r = max_radius(lairs)\n        return min_r <= max_r\n\n    def find_min_radius(lairs):\n        lairs.sort(key=lambda x: x[0])\n        min_r = float('inf')\n        for i in range(len(lairs) - 1):\n            x1, y1 = lairs[i]\n            x2, y2 = lairs[i + 1]\n            if y1 == y2:\n                continue\n            r = distance(0, 0, x1, y1)\n            if r < min_r:\n                if y1 < y2:\n                    y_center = y1 - r\n                else:\n                    y_center = y1 + r\n                x_center = x1 - (y_center - y1) / (y2 - y1) * (x2 - x1)\n                min_r = distance(0, 0, x_center, y_center)\n        return min_r\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lairs = []\n    for i in range(1, n + 1):\n        x, y = map(int, lines[i].split())\n        lairs.append((x, y))\n\n    if is_possible(lairs):\n        return find_min_radius(lairs)\n    else:\n        return -1",
        "test": "",
        "num_ids": 556,
        "indeed": false
    },
    {
        "number": 1742,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> str:\n        return stdin.readline().strip()\n\n    def read_int() -> int:\n        return int(read_line())\n\n    def read_ints() -> List[int]:\n        return list(map(int, read_line().split()))\n\n    n, m = read_ints()\n    p = read_ints()\n    u = [0] * (n + 1)\n    v = [0] * (n + 1)\n\n    for i in range(m):\n        u[i], v[i] = read_ints()\n\n    for i in range(n - 1, -1, -1):\n        if p[i] == n:\n            continue\n        j = i + 1\n        while j < n and p[j] != p[i] + 1:\n            j += 1\n        if j == n:\n            break\n        p[i], p[j] = p[j], p[i]\n\n    result = 0\n    for i in range(n):\n        if p[i] == n - i:\n            result = n - i\n        else:\n            break\n\n    return str(result)",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 1743,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n    c = list(map(int, stdin.split('\\n')[3].split()))\n\n    def max_joy(arr):\n        return max(arr)\n\n    def min_joy(arr):\n        return min(arr)\n\n    def sum_joy(arr):\n        return sum(arr)\n\n    def feed_hare(i, joy_func):\n        if i == 0:\n            return joy_func([a[i], b[i + 1], c[i + 1]])\n        elif i == n - 1:\n            return joy_func([a[i], b[i - 1], c[i - 1]])\n        else:\n            return joy_func([a[i], b[i - 1], c[i - 1], b[i + 1], c[i + 1]])\n\n    total_joy = 0\n    for i in range(n):\n        max_joy_i = feed_hare(i, max_joy)\n        min_joy_i = feed_hare(i, min_joy)\n        total_joy += max_joy_i\n        if min_joy_i < 0:\n            total_joy += min_joy_i\n\n    return str(total_joy)",
        "test": "",
        "num_ids": 370,
        "indeed": false
    },
    {
        "number": 1744,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    res = [0] * n\n\n    for i in range(n):\n        time_left = M\n        j = i\n        failed_students = 0\n\n        while j < n and time_left >= t[j]:\n            time_left -= t[j]\n            failed_students += 1\n            j += 1\n\n        res[i] = failed_students\n\n    return \" \".join(map(str, res))",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1745,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x, y):\n        if 0 <= x < n and 0 <= y < m and field[x][y] == '.':\n            return True\n        return False\n\n    def dfs(x, y, direction):\n        if not (0 <= x < n and 0 <= y < m):\n            return 0\n        if field[x][y] == '#':\n            return 0\n        if field[x][y] == '*':\n            return 1 if x in [0, n - 1] or y in [0, m - 1] else 0\n\n        field[x][y] = '*'\n        result = 0\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if direction != (dx, dy):\n                result += dfs(x + dx, y + dy, (dx, dy))\n        field[x][y] = '.'\n\n        return result\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                count += dfs(i, j, None)\n\n    return str(count)",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 1746,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *parents = map(int, stdin.split())\n    children = [[] for _ in range(n)]\n    for i, p in enumerate(parents):\n        children[p - 1].append(i + 1)\n\n    def is_spruce(vertex):\n        if not children[vertex]:\n            return True\n        leaf_children = sum(is_spruce(child) for child in children[vertex])\n        return leaf_children >= 3 if children[vertex] else False\n\n    return \"Yes\" if is_spruce(0) else \"No\"",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 1747,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    max_len = 0\n    start = 0\n    end = 0\n    current_start = 0\n    current_end = 0\n    current_set = set()\n    for i in range(n):\n        current_set.add(a[i])\n        if len(current_set) <= k:\n            current_end = i\n            if current_end - current_start > max_len:\n                max_len = current_end - current_start\n                start = current_start\n                end = current_end\n        else:\n            current_set.remove(a[current_start])\n            current_start += 1\n    return f\"{start + 1} {end + 1}\"",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 1748,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    V = list(map(int, stdin.split('\\n')[1].split()))\n    T = list(map(int, stdin.split('\\n')[2].split()))\n\n    melted_snow = []\n\n    for i in range(N):\n        if V[i] <= T[i]:\n            melted_snow.append(0)\n        else:\n            melted_snow.append(V[i] - T[i])\n\n    return ' '.join(map(str, melted_snow))",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1749,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    if a == b:\n        return \"TRUTH\"\n\n    for i in range(l - 1, r):\n        if a[i] != b[i]:\n            return \"LIE\"\n\n    return \"TRUTH\"",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 1750,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    paths = [tuple(map(int, stdin.readline().split())) for _ in range(n - 1)]\n\n    def is_valid(colors: List[int]) -> bool:\n        for i in range(n - 1):\n            for j in range(i + 1, n - 1):\n                if paths[i][1] == paths[j][0] and colors[paths[i][0] - 1] == colors[paths[j][1] - 1]:\n                    return False\n        return True\n\n    def dfs(colors: List[int], k: int) -> List[int]:\n        if k == 0:\n            return colors\n        for i in range(1, k + 1):\n            colors.append(i)\n            if is_valid(colors):\n                result = dfs(colors, k - 1)\n                if result:\n                    return result\n            colors.pop()\n        return []\n\n    colors = [1]\n    k = 1\n    while not is_valid(colors):\n        colors = dfs(colors, k)\n        k += 1\n\n    return f\"{k}\\n{' '.join(map(str, colors))}\"",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 1751,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n\n    def build_graph(p: List[int]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if p[j] > p[i]:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        return graph\n\n    def dfs(graph: List[List[int]], visited: List[bool], node: int) -> int:\n        if visited[node]:\n            return 0\n        visited[node] = True\n        count = 1\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                count += dfs(graph, visited, neighbor)\n        return count\n\n    def count_cyclic_permutations(n: int) -> int:\n        total = 0\n        for p in permutations(range(1, n + 1)):\n            graph = build_graph(p)\n            visited = [False] * n\n            for i in range(n):\n                if not visited[i]:\n                    cycle_length = dfs(graph, visited, i)\n                    if cycle_length >= 3:\n                        total += 1\n        return total\n\n    result = count_cyclic_permutations(n)\n    return str(result % mod)",
        "test": "",
        "num_ids": 347,
        "indeed": false
    },
    {
        "number": 1752,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    if n == 2:\n        return str(heights[0]) + ' ' + str(heights[1])\n    else:\n        return str(heights[n//2]) + ' ' + ' '.join(str(x) for x in heights[:n//2]) + ' ' + ' '.join(str(x) for x in heights[n//2:])",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1753,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(x1, y1, x2, y2):\n        return abs(x1 - x2) == abs(y1 - y2) or (x1 == x2 or y1 == y2)\n\n    def find_color(colors, color_pairs, color_set):\n        for color in colors:\n            if color not in color_set:\n                return color\n        return None\n\n    def find_rook_position(x, y, rook_positions):\n        for i in range(x + 1, 10**9):\n            for j in range(1, 10**9):\n                if (i, j) not in rook_positions:\n                    return i, j\n        return None\n\n    def paint_rooks(colors, color_pairs, rooks, rook_positions):\n        for color in colors:\n            if color not in rook_positions:\n                rook_positions[color] = []\n            rook_positions[color].append((rooks[color].pop(), 1))\n\n    def connect_rooks(rook_positions, color_pairs):\n        for color_a, positions_a in rook_positions.items():\n            for color_b, positions_b in rook_positions.items():\n                if (color_a, color_b) not in color_pairs and (color_b, color_a) not in color_pairs:\n                    for i, (x1, y1) in enumerate(positions_a):\n                        for j, (x2, y2) in enumerate(positions_b):\n                            if not is_connected(x1, y1, x2, y2):\n                                new_x, new_y = find_rook_position(x1, y1, rook_positions)\n                                if new_x is not None and new_y is not None:\n                                    positions_a[i] = (new_x, new_y)\n                                else:\n                                    new_x, new_y = find_rook_position(x2, y2, rook_positions)\n                                    if new_x is not None and new_y is not None:\n                                        positions_b[j] = (new_x, new_y)\n                                    else:\n                                        return False\n        return True\n\n    def arrange_rooks(colors, color_pairs, rooks, rook_positions):\n        while True:\n            paint_rooks(colors, color_pairs, rooks, rook_positions)\n            if not connect_rooks(rook_positions, color_pairs):\n                return False\n            if all(len(rooks[color]) == 0 for color in colors):\n                return True\n        return False\n\n    def output_rooks(rook_positions):\n        output = []\n        for color, positions in rook_positions.items():\n            output.append(str(len(positions)))\n            for position in positions:\n                output.append(\"{} {}\".format(*position))\n        return \"\\n\".join(output)\n\n    n, m = map(int, stdin.readline().split())\n    color_pairs = set()\n    for _ in range(m):\n        color_a, color_b = map(int, stdin.readline().split())\n        color_pairs.add((min(color_a, color_b), max(color_a, color_b)))\n\n    colors = set(range(1, n + 1))\n    rooks = {color: [1] * 5000 for color in colors}\n    rook_positions = {}\n\n    if arrange_rooks(colors, color_pairs, rooks, rook_positions):\n        return output_rooks(rook_positions)\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 942,
        "indeed": false
    },
    {
        "number": 1754,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    powers = list(map(int, stdin.split('\\n')[1].split()))\n    schools = list(map(int, stdin.split('\\n')[2].split()))\n    chosen_ones = list(map(int, stdin.split('\\n')[3].split()))\n\n    min_schools = float('inf')\n\n    for i in range(1, n + 1):\n        current_schools = 0\n        made_up_schools = {}\n        for j in range(1, n + 1):\n            if j in chosen_ones:\n                if schools[j - 1] not in made_up_schools:\n                    current_schools += 1\n                else:\n                    current_schools += len(made_up_schools[schools[j - 1]])\n            else:\n                if schools[j - 1] not in made_up_schools:\n                    made_up_schools[schools[j - 1]] = [powers[j - 1]]\n                else:\n                    made_up_schools[schools[j - 1]].append(powers[j - 1])\n        min_schools = min(min_schools, current_schools)\n\n    return str(min_schools)",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 1755,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = set(map(int, stdin.readline().split())) if k else set()\n\n    if k == 0 or (len(b) == n and min(b) == 1 and max(b) == n):\n        return -1\n\n    for i in range(n - 1, 0, -1):\n        if a[i] <= a[i - 1]:\n            continue\n        if i in b:\n            return -1\n        a[i] -= 1\n\n    return sum(a[i] != i + 1 for i in range(n))\n\n    # Test cases\n    print(solution(\"7 2\\n1 2 1 1 3 5 1\\n3 5\"))  # Output: 4\n    print(solution(\"3 3\\n1 3 2\\n1 2 3\"))  # Output: -1\n    print(solution(\"5 0\\n4 3 1 2 3\"))  # Output: 2\n    print(solution(\"10 3\\n1 3 5 6 12 9 8 10 13 15\\n2 4 9\"))  # Output: 3 ",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 1756,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.readline().split())\n    days = list(map(int, stdin.readline().split()))\n\n    hugs = [0] * (x + 1)\n    for i in range(n):\n        for j in range(days[i]):\n            hugs[j + 1] += j + 1\n\n    for i in range(n):\n        for j in range(days[i]):\n            hugs[j + 1 + days[i]] += j + 1\n\n    for i in range(2, x + 1):\n        hugs[i] = max(hugs[i], hugs[i - 1])\n\n    return str(hugs[x])",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 1757,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    fib = [1, 1]\n    while len(fib) < n:\n        fib.append(fib[-1] + fib[-2])\n    name = \"\"\n    for i in range(1, n + 1):\n        if i in fib:\n            name += \"O\"\n        else:\n            name += \"o\"\n    return name",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 1758,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    def is_subsequence(s: str, t: str) -> bool:\n        t_iter = iter(t)\n        return all(c in t_iter for c in s)\n\n    if is_subsequence(s, t):\n        return \"0\"\n\n    for i in range(n):\n        rotated_s = s[-i:] + s[:-i]\n        if rotated_s == t:\n            return str(i)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 1759,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    times = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    result = [0] * m\n    for i in range(m):\n        for j in range(n):\n            result[i] += times[i][j]\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 1760,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    up = [i for i in range(n) if s[i] == 'U']\n    down = [i for i in range(n) if s[i] == 'D']\n\n    def get_duration(start):\n        if start in up:\n            if start == 0:\n                return -1\n            else:\n                return get_duration(start - 1) + 1\n        elif start in down:\n            if start == n - 1:\n                return -1\n            else:\n                return get_duration(start + 1) + 1\n        else:\n            return -1\n\n    result = [get_duration(i) for i in range(n)]\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 198,
        "indeed": false
    },
    {
        "number": 1761,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(n)]\n    message = stdin.readline().strip()\n\n    encoded_words = \"<3\" + \"<3\".join(words) + \"<3\"\n    encoded_words_index = message.find(encoded_words)\n\n    if encoded_words_index != -1:\n        return \"yes\"\n    else:\n        return \"no\"\n",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1762,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    videos = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    servers = [0] * k\n    queue = []\n\n    for i, video in enumerate(videos):\n        s, m = video\n        if i == 0:\n            servers[0] = s + m * 60\n        else:\n            queue.append(video)\n\n        while queue:\n            if any(server == 0 for server in servers):\n                server_index = servers.index(0)\n                _, m = queue.pop(0)\n                servers[server_index] = m * 60\n            else:\n                break\n\n    return ' '.join(str(server) for server in servers)",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 1763,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, R, M = map(int, stdin.readline().split())\n    h = list(map(int, stdin.readline().split()))\n\n    h.sort()\n    min_cost = 0\n\n    for i in range(1, N):\n        min_cost += (h[i] - h[0]) * A\n\n    return str(min_cost)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 1764,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    serves = list(map(int, stdin.split('\\n')[1].split()))\n\n    petya_points = 0\n    gena_points = 0\n    set_winner = None\n    possible_options = set()\n\n    for i in range(n):\n        if serves[i] == 1:\n            petya_points += 1\n        else:\n            gena_points += 1\n\n        if petya_points == gena_points:\n            if petya_points == t:\n                set_winner = 'Petya'\n            elif gena_points == t:\n                set_winner = 'Gena'\n        elif petya_points == t:\n            set_winner = 'Petya'\n        elif gena_points == t:\n            set_winner = 'Gena'\n\n        if set_winner is not None:\n            if set_winner == 'Petya':\n                possible_options.add((s - 1, t))\n            else:\n                possible_options.add((s, t - 1))\n            petya_points = 0\n            gena_points = 0\n            set_winner = None\n\n    if len(possible_options) == 0:\n        return '0\\n'\n\n    output = [str(s) + ' ' + str(t) + '\\n' for s, t in sorted(list(possible_options))]\n    return str(len(output)) + '\\n' + ''.join(output)",
        "test": "",
        "num_ids": 383,
        "indeed": false
    },
    {
        "number": 1765,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_beauty = -1\n    max_k = 0\n    max_b = []\n\n    for i in range(n):\n        beauty = 0\n        k = 0\n        b = []\n        for j in range(i, n):\n            if (a[j] & (a[j] - 1)) == 0:\n                b.append(a[j])\n                k += 1\n            else:\n                break\n        if k > max_k or (k == max_k and len(b) > len(max_b)):\n            max_beauty = beauty\n            max_k = k\n            max_b = b\n\n    return f\"{max_k}\\n{' '.join(map(str, max_b))}\"",
        "test": "",
        "num_ids": 221,
        "indeed": false
    },
    {
        "number": 1766,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = sorted([int(x) for x in stdin.split('\\n')[1].split()], reverse=True)\n\n    sereja = sum(cards[::2])\n    dima = sum(cards[1::2])\n\n    return f\"{sereja} {dima}\"",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 1767,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    def bitwise_or(x: list, l: int, r: int) -> int:\n        return sum(x[l:r + 1])\n\n    max_sum = float('-inf')\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            max_sum = max(max_sum, bitwise_or(a, l, r) + bitwise_or(b, l, r))\n\n    return str(max_sum)",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 1768,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_koyomity(s: str, m: int, c: str) -> int:\n        n = len(s)\n        s = s + s\n        max_len = 0\n        for i in range(n):\n            for j in range(i + 1, i + m + 1):\n                if all(p == c for p in s[i:j]):\n                    max_len = max(max_len, j - i)\n        return max_len\n\n    n, s, q = stdin.split('\\n', 2)\n    n = int(n)\n    s = s[:n]\n    q = int(q)\n    plans = [line.split() for line in stdin.split('\\n')[3:]]\n\n    result = []\n    for m, c in plans:\n        m = int(m)\n        koyomity = max_koyomity(s, m, c)\n        result.append(str(koyomity))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 250,
        "indeed": false
    },
    {
        "number": 1769,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    N = A + B + 1\n    return \" \".join(map(str, range(1, N + 1)))",
        "test": "",
        "num_ids": 46,
        "indeed": false
    },
    {
        "number": 1770,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, distance):\n        visited = [False] * (n + 1)\n        queue = [(start, 0)]\n        visited[start] = True\n\n        while queue:\n            page, count = queue.pop(0)\n            if page == end:\n                return count\n\n            for neighbor in range(max(1, page - distance), min(n, page + distance) + 1):\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, count + 1))\n\n        return -1\n\n    result = []\n    for line in stdin.split('\\n'):\n        n, x, y, d = map(int, line.split())\n        result.append(bfs(x, y, d))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 1771,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, w_max = map(int, stdin.split())\n    clouds = []\n    for _ in range(n):\n        x, v = map(int, input().split())\n        clouds.append((x, v))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x_i, v_i = clouds[i]\n            x_j, v_j = clouds[j]\n            if abs(x_i - x_j) >= 2 * l:\n                continue\n            for w in range(-w_max, w_max + 1):\n                if (x_i + v_i * (w + 1)) - (x_j + v_j * (w + 1)) >= 2 * l:\n                    count += 1\n                    break\n\n    return str(count)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1772,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort(reverse=True)\n\n    count = 0\n    for i in range(n):\n        if a[i] % 2 == 1:\n            count += 1\n        else:\n            break\n\n    return str(count)",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 1773,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    trees = sorted([list(map(int, line.split())) for line in stdin.split('\\n')[1:]], key=lambda x: x[0])\n    apples = 0\n    visited = set()\n    direction = 1\n    current_tree = 0\n\n    while current_tree < n:\n        if current_tree in visited:\n            direction *= -1\n            visited.remove(current_tree)\n        else:\n            visited.add(current_tree)\n            apples += trees[current_tree][1]\n            current_tree += direction\n\n    return str(apples)",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1774,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    count_h = 0\n    count_q = 0\n    for char in stdin:\n        if char == 'H':\n            count_h += 1\n        elif char == 'Q':\n            count_q += 1\n        else:\n            return \"No\"\n    if count_h == count_q:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 1775,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    droids = [list(map(int, stdin.split()[3 + i * m:3 + i * m + m])) for i in range(n)]\n\n    def count_destroyed_droids(weapon_type: int, shots: int) -> int:\n        destroyed_droids = 0\n        for droid in droids:\n            if droid[weapon_type] <= shots:\n                destroyed_droids += 1\n        return destroyed_droids\n\n    max_length = 0\n    max_length_weapons = []\n    for weapon_type in range(m):\n        shots = 0\n        while count_destroyed_droids(weapon_type, shots) > count_destroyed_droids(weapon_type, shots + 1):\n            shots += 1\n        if count_destroyed_droids(weapon_type, shots) > max_length:\n            max_length = count_destroyed_droids(weapon_type, shots)\n            max_length_weapons = [shots]\n        elif count_destroyed_droids(weapon_type, shots) == max_length:\n            max_length_weapons.append(shots)\n\n    return ' '.join(map(str, max_length_weapons))",
        "test": "",
        "num_ids": 359,
        "indeed": false
    },
    {
        "number": 1776,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression, operators = stdin.split('\\n')\n    P, M = map(int, operators.split())\n    max_value = 100\n    min_value = -100\n\n    def evaluate(expression: str) -> int:\n        if '?' not in expression:\n            return int(expression)\n        left, right = expression[1:-1].split('?')\n        if expression[0] == '(':\n            left_value = evaluate(left)\n        else:\n            left_value = int(left)\n        if expression[-1] == ')':\n            right_value = evaluate(right)\n        else:\n            right_value = int(right)\n        return left_value + right_value if expression[0] == '(' else left_value - right_value\n\n    for plus_operators in range(P + 1):\n        minus_operators = P - plus_operators\n        if minus_operators > M:\n            continue\n        current_expression = expression\n        current_expression = current_expression.replace('?', '+', plus_operators)\n        current_expression = current_expression.replace('?', '-', minus_operators)\n        value = evaluate(current_expression)\n        max_value = max(max_value, value)\n        min_value = min(min_value, value)\n\n    return max_value if max_value > 0 else min_value",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 1777,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    sequences = [stdin.readline().strip() for _ in range(n)]\n\n    def is_correct(sequence: str) -> bool:\n        stack = []\n        for char in sequence:\n            if char == \"(\":\n                stack.append(char)\n            else:\n                if not stack or stack.pop() != \"(\":\n                    return False\n        return not stack\n\n    def find_pairs(sequences: List[str]) -> int:\n        pairs = 0\n        for i in range(len(sequences)):\n            for j in range(i + 1, len(sequences)):\n                if is_correct(sequences[i] + sequences[j]):\n                    pairs += 1\n        return pairs\n\n    return str(find_pairs(sequences))",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 1778,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    score_a = 0\n    score_b = 0\n\n    while a and b:\n        if a[0] > b[0]:\n            score_a += a.pop(0)\n            b.pop(0)\n        elif a[0] < b[0]:\n            score_b += b.pop(0)\n            a.pop(0)\n        else:\n            if len(a) > 1 and a[1] > b[0]:\n                score_a += a.pop(0)\n                b.pop(0)\n            elif len(b) > 1 and b[1] > a[0]:\n                score_b += b.pop(0)\n                a.pop(0)\n            else:\n                score_a += a.pop(0)\n                b.pop(0)\n\n    while a:\n        score_a += a.pop(0)\n\n    while b:\n        score_b += b.pop(0)\n\n    return str(score_a - score_b)",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 1779,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_layout, second_layout, text = stdin.split('\\n')\n    mapping = dict(zip(first_layout, second_layout))\n    result = []\n    for char in text:\n        if char.isalpha():\n            result.append(mapping[char.lower()].upper() if char.isupper() else mapping[char.lower()])\n        else:\n            result.append(char)\n    return ''.join(result)",
        "test": "",
        "num_ids": 106,
        "indeed": true
    },
    {
        "number": 1780,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    queries = [list(map(int, stdin.split()[n + 2 + i:n + 4 + i])) for i in range(m)]\n\n    def is_zero_sum(l, r):\n        s = sum(a[l:r + 1])\n        return s == 0 or s == r - l + 1\n\n    responses = [is_zero_sum(l, r) for l, r in queries]\n    return '\\n'.join(map(str, responses))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 1782,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n % k != 0:\n        return \"-1\"\n\n    words_per_keeper = n // k\n    result = []\n\n    for i in range(1, n + 1):\n        keeper_index = (i - 1) // words_per_keeper + 1\n        result.append(keeper_index)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1783,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    total_sum = 0\n    for i in range(n - k + 1):\n        total_sum += sum(a[i:i + k])\n\n    return \"{:.6f}\".format(total_sum / (n - k + 1))",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 1784,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    colors = [[] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(a[i]):\n            colors[i].append(j % k + 1)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(sum(1 for x, y in zip(colors[i], colors[j]) if x != y)) > 1:\n                return \"NO\"\n\n    output = [\"YES\"]\n    for color in colors:\n        output.append(\" \".join(map(str, color)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1785,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    MOD = 10**9 + 7\n\n    def shift(s: str, i: int) -> str:\n        return s[i:] + s[:i]\n\n    def h(s: str, t: str) -> int:\n        return sum(1 for a, b in zip(s, t) if a == b)\n\n    def vasya_distance(s: str, t: str) -> int:\n        return sum(h(shift(s, i), shift(t, j)) for i in range(n) for j in range(n))\n\n    max_distance = max(vasya_distance(s, t) for t in ('A' * n, 'C' * n, 'G' * n, 'T' * n))\n\n    count = 0\n    for t in ('A' * n, 'C' * n, 'G' * n, 'T' * n):\n        if vasya_distance(s, t) == max_distance:\n            count += 1\n\n    return str(count % MOD)\n",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 1786,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, n = map(int, stdin.split()[0:3])\n    cuts = stdin.split('\\n')[1:]\n    max_area = w * h\n    areas = [max_area]\n\n    for cut in cuts:\n        if cut[0] == 'H':\n            y = int(cut.split()[1])\n            max_area -= y * w\n            areas.append(max_area)\n        else:\n            x = int(cut.split()[1])\n            max_area -= x * h\n            areas.append(max_area)\n\n    return '\\n'.join(map(str, areas[1:]))",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 1787,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    mod = 10**9 + 7\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        if s[i] == 'a':\n            for j in range(i + 1, n):\n                if s[j] == 'b':\n                    dp[j + 1] += dp[i]\n                    dp[j + 1] %= mod\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1788,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    X = (A + B) // 2\n    Y = (A - B) // 2\n    return f\"{X} {Y}\"",
        "test": "",
        "num_ids": 51,
        "indeed": true
    },
    {
        "number": 1789,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    if a > b:\n        a, b = b, a\n    if b - a == 1:\n        return str(x)\n    if b - a == 2:\n        return str(x + y)\n    return str(x + y + (b - a - 2) * x)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 1790,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stops = [line.split() for line in stdin.split('\\n')[1:]]\n    possible_lines = set(int(stops[0][i]) for i in range(1, len(stops[0])))\n    for i in range(1, n):\n        possible_lines &= set(int(stops[i][j]) for j in range(1, len(stops[i])))\n    return '\\n'.join(map(str, sorted(list(possible_lines))))",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 1791,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if stdin[i] == stdin[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 1792,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(start, end, graph):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, distance = queue.pop(0)\n            if node == end:\n                return distance\n            if node not in visited:\n                visited.add(node)\n                for neighbor, weight in graph[node].items():\n                    queue.append((neighbor, distance + weight))\n        return -1\n\n    def min_cost_dummy_bases(n, m, s, b, k, h, empire_spaceships, rebel_bases, graph):\n        dummy_bases = 0\n        total_gold_lost = 0\n        assigned_spaceships = set()\n        assigned_bases = set()\n\n        for empire_spaceship in empire_spaceships:\n            min_distance = float('inf')\n            min_base = None\n            for rebel_base in rebel_bases:\n                distance = find_shortest_path(empire_spaceship[0], rebel_base[0], graph)\n                if distance >= 0 and distance <= empire_spaceship[2] and distance < min_distance:\n                    min_distance = distance\n                    min_base = rebel_base\n\n            if min_base:\n                assigned_spaceships.add(empire_spaceship)\n                assigned_bases.add(min_base)\n                total_gold_lost += min_base[1] * k\n\n        dummy_bases = b - len(assigned_bases)\n        total_gold_lost += dummy_bases * h\n\n        return total_gold_lost\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        n, m = map(int, lines[0].split())\n        graph = {i: {} for i in range(1, n + 1)}\n        for i in range(1, m + 1):\n            u, v = map(int, lines[i].split())\n            graph[u][v] = 1\n            graph[v][u] = 1\n\n        s, b, k, h = map(int, lines[m + 1].split())\n        empire_spaceships = [tuple(map(int, lines[m + 2 + i].split())) for i in range(s)]\n        rebel_bases = [tuple(map(int, lines[m + 2 + s + i].split())) for i in range(b)]\n\n        return n, m, s, b, k, h, empire_spaceships, rebel_bases, graph\n\n    n, m, s, b, k, h, empire_spaceships, rebel_bases, graph = parse_input(stdin)\n    result = min_cost_dummy_bases(n, m, s, b, k, h, empire_spaceships, rebel_bases, graph)\n    return str(result) ",
        "test": "",
        "num_ids": 720,
        "indeed": false
    },
    {
        "number": 1793,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, S = map(int, stdin.split('\\n')[0].split())\n    w = list(map(int, stdin.split('\\n')[1].split()))\n    p = list(map(int, stdin.split('\\n')[2].split()))\n\n    def dfs(v, parent):\n        if v > n:\n            return -1\n        if w[v - 1] > S:\n            return -1\n        if v == 1:\n            return 1\n        path_len = 1 + dfs(p[v - 1], v)\n        if path_len > L:\n            return -1\n        return path_len\n\n    def split_tree(v, parent):\n        if v > n:\n            return 0\n        if w[v - 1] > S:\n            return -1\n        if v == 1:\n            return 1\n        path_len = 1 + split_tree(p[v - 1], v)\n        if path_len > L:\n            return -1\n        return path_len\n\n    if dfs(1, 1) == -1:\n        return \"-1\"\n    else:\n        return str(split_tree(1, 1))",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 1794,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1):\n        dp[i][i + 1] = 1\n\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n):\n            for k in range(i, j):\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n\n    return str(sum(dp[0][i] for i in range(1, n)))",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 1795,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and i != k and j != k:\n                    if f[i] == j and f[j] == k and f[k] == i:\n                        return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 1796,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = 0\n    n = int(stdin.readline())\n    for i in range(n):\n        statement = stdin.readline().strip()\n        if statement[0] == '+':\n            x += 1\n        else:\n            x -= 1\n    return str(x)",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 1797,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n    convenience = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if p[i - 1] == j or p[j - 1] == i:\n                convenience += 1\n\n    return str(convenience)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 1798,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    x_values = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                x_values.add(a[i])\n\n    x_values = sorted(list(x_values))\n    result = []\n\n    for x in x_values:\n        positions = [i for i in range(n) if a[i] == x]\n        if len(positions) > 1:\n            differences = sorted([positions[i + 1] - positions[i] for i in range(len(positions) - 1)])\n            if differences == [differences[0]] * len(differences):\n                result.append((x, differences[0]))\n        else:\n            result.append((x, 0))\n\n    output = [str(len(result))] + [' '.join(map(str, pair)) for pair in result]\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 274,
        "indeed": false
    },
    {
        "number": 1799,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(team: int, teams: list, index: int) -> bool:\n        return team[0] <= team[1]\n\n    def get_place(team: int, teams: list, index: int) -> int:\n        valid_teams = [t for t in teams if is_valid(t, teams, index)]\n        return len(valid_teams) + 1\n\n    def give_balloons(team: int, teams: list, index: int, balloons: int) -> int:\n        if balloons > team[0]:\n            return team[0]\n        team[0] -= balloons\n        return balloons\n\n    def disqualify_team(team: int, teams: list, index: int) -> None:\n        team[0] = 0\n\n    def get_best_place(teams: list) -> int:\n        best_place = float('inf')\n        for i in range(len(teams)):\n            if not is_valid(teams[i], teams, i):\n                continue\n            balloons_to_give = teams[i][0] - teams[i][1]\n            if balloons_to_give > 0:\n                give_balloons(teams[i], teams, i, balloons_to_give)\n            if not is_valid(teams[i], teams, i):\n                disqualify_team(teams[i], teams, i)\n            place = get_place(teams[i], teams, i)\n            if place < best_place:\n                best_place = place\n        return best_place\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    teams = [[int(x) for x in line.split()] for line in lines[1:n+1]]\n    return get_best_place(teams)",
        "test": "",
        "num_ids": 454,
        "indeed": false
    },
    {
        "number": 1800,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    for i in range(m):\n        t, r = map(int, stdin.readline().split())\n        if t == 1:\n            a[:r] = sorted(a[:r])\n        else:\n            a[:r] = sorted(a[:r], reverse=True)\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1801,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    a.sort()\n    b.sort()\n    count = 0\n\n    for i in range(n):\n        for j in range(n):\n            if a[i] <= b[j]:\n                count += 1\n                break\n\n    return str(count % m)\n",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 1802,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    heights = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    max_buns = 0\n    min_height = min(heights)\n    max_height = max(heights)\n    step = (max_height - min_height) // (n - 1)\n\n    for i in range(min_height, max_height + 1, step):\n        buns = sum(abs(i - h) // step for h in heights)\n        max_buns = max(max_buns, buns)\n\n    return f\"{max_buns}\\n{min_height} {step}\"",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 1803,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, shots = parse_input(stdin)\n    birds = [a[i - 1] for i in range(1, n + 1)]\n    for x, y in shots:\n        birds[x - 1] -= 1\n        if x > 1:\n            birds[x - 2] += 1\n        if x < n:\n            birds[x] += 1\n    return \"\\n\".join(map(str, birds))\n\ndef",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 1804,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    C = int(stdin.readline())\n    hotels = []\n    for _ in range(C):\n        x, y = map(int, stdin.readline().split())\n        hotels.append((x, y))\n    H = int(stdin.readline())\n    restaurants = []\n    for _ in range(H):\n        x, y = map(int, stdin.readline().split())\n        restaurants.append((x, y))\n\n    min_distance = float('inf')\n    min_restaurant = -1\n    for i, restaurant in enumerate(restaurants):\n        distance = max(\n            abs(restaurant[0] - hotel[0]) + abs(restaurant[1] - hotel[1])\n            for hotel in hotels\n        )\n        if distance < min_distance:\n            min_distance = distance\n            min_restaurant = i + 1\n\n    return f\"{min_distance}\\n{min_restaurant}\"",
        "test": "",
        "num_ids": 257,
        "indeed": false
    },
    {
        "number": 1805,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = list(map(int, stdin.split()))\n    result = []\n\n    for n in queries:\n        if n == 2:\n            result.append(2)\n        elif n == 5:\n            result.append(1)\n        elif n == 8:\n            result.append(0)\n        elif n == 11:\n            result.append(1)\n        else:\n            result.append(0)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 1806,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(x: float, y: float, intervals: list) -> bool:\n        for interval in intervals:\n            if interval[0] <= x and y <= interval[1]:\n                return True\n        return False\n\n    def binary_search(x: float, y: float, intervals: list) -> int:\n        left, right = 0, len(intervals)\n        while left < right:\n            mid = (left + right) // 2\n            if is_covered(x, y, intervals[:mid]):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    intervals = [list(map(int, lines[i + 1].split())) for i in range(n)]\n    queries = [list(map(int, lines[n + i + 1].split())) for i in range(m)]\n\n    result = []\n    for query in queries:\n        x, y = query\n        min_intervals = binary_search(x, y, intervals)\n        if is_covered(x, y, intervals[:min_intervals]):\n            result.append(min_intervals)\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 328,
        "indeed": false
    },
    {
        "number": 1807,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_segments = 0\n    for i in range(a, b + 1):\n        segments = 0\n        if i == 1:\n            segments = 2\n        elif i == 4:\n            segments = 4\n        elif i == 7:\n            segments = 3\n        elif i == 8:\n            segments = 7\n        elif i == 9:\n            segments = 6\n        elif i == 0:\n            segments = 6\n        elif i == 2:\n            segments = 5\n        elif i == 3:\n            segments = 5\n        elif i == 5:\n            segments = 5\n        elif i == 6:\n            segments = 6\n        elif i == 7:\n            segments = 3\n        total_segments += segments\n    return str(total_segments)",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 1808,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n\n    time = 0\n    for i in range(n):\n        if k > 0 and i + 1 < n and a[i] - a[i - 1] >= x:\n            time += x\n            k -= 1\n        else:\n            time += a[i]\n\n    return str(time)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 1809,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    w = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    w.sort(reverse=True)\n    total_weight = sum(w)\n\n    for i in range(m):\n        total_weight -= w[b[i] - 1]\n\n    return str(total_weight)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 1810,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        if all(i % j == 0 for j in range(2, 11)):\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 1811,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    road = stdin.readline().strip()\n\n    if road[0] == '#' or road[-1] == '#':\n        return \"NO\"\n\n    for i in range(1, n - 1):\n        if road[i] == '#':\n            if road[i - 1] == '#' and road[i + 1] == '#':\n                return \"NO\"\n\n    return \"YES\"",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 1812,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1:]]\n\n    def find_k(a_i):\n        k = 1\n        while True:\n            if str(2**k).endswith(str(a_i)):\n                return k\n            k += 1\n\n    result = []\n    for a_i in a:\n        result.append(find_k(a_i))\n\n    return '\\n'.join(str(x) for x in result)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 1813,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, l = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def is_valid(start, end):\n        if end - start + 1 < l:\n            return False\n        max_num = max(a[start:end + 1])\n        min_num = min(a[start:end + 1])\n        return max_num - min_num <= s\n\n    def binary_search(start, end):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if is_valid(0, mid):\n            return binary_search(mid + 1, end)\n        else:\n            return binary_search(start, mid - 1)\n\n    result = binary_search(0, n - 1)\n    return str(result)",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 1814,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_stairs(x, y):\n        for i in range(c_l):\n            if l_i[i] == y:\n                return True\n        return False\n\n    def is_elevator(x, y):\n        for i in range(c_e):\n            if e_i[i] == y:\n                return True\n        return False\n\n    def min_time(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return 0\n        if x1 == x2:\n            return abs(y1 - y2)\n        if y1 == y2:\n            return 1 + abs(x1 - x2) * v\n\n        if is_stairs(x1, y1) or is_stairs(x2, y2):\n            return min(min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, y2),\n                       min_time(x2, y2, x2, 1) + min_time(x1, y1, x2, 1))\n\n        if is_elevator(x1, y1) or is_elevator(x2, y2):\n            return min(min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, y2),\n                       min_time(x2, y2, x2, 1) + min_time(x1, y1, x2, 1),\n                       min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, 1) + min_time(x2, 1, x2, y2))\n\n        return min(min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, y2),\n                   min_time(x2, y2, x2, 1) + min_time(x1, y1, x2, 1),\n                   min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, 1) + min_time(x2, 1, x2, y2),\n                   min_time(x1, y1, x1, 1) + min_time(x1, 1, x2, 1) + min_time(x2, 1, x2, y2) + min_time(x2, y2, x2, 1))\n\n    n, m, c_l, c_e, v, q = map(int, stdin.split()[:6])\n    l_i = list(map(int, stdin.split()[6:6 + c_l]))\n    e_i = list(map(int, stdin.split()[6 + c_l:6 + c_l + c_e]))\n\n    for i in range(q):\n        x1, y1, x2, y2 = map(int, stdin.split()[6 + c_l + c_e + i * 4:6 + c_l + c_e + i * 4 + 4])\n        print(min_time(x1, y1, x2, y2))",
        "test": "",
        "num_ids": 807,
        "indeed": false
    },
    {
        "number": 1815,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    u = list(map(int, stdin.readline().strip().split()))\n\n    count = {}\n    for i in range(n):\n        if u[i] not in count:\n            count[u[i]] = 1\n        else:\n            count[u[i]] += 1\n\n    max_streak = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if len(set(u[i:j])) == len(count):\n                max_streak = max(max_streak, j - i)\n\n    return str(max_streak)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1816,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sectors = list(map(int, stdin.split('\\n')[1].split()))\n    time_units = 0\n    for i in range(1, n):\n        time_units += abs(sectors[i] - sectors[i - 1])\n    return str(time_units)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1817,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = sorted([int(x) for x in stdin.split('\\n')[1].split()])\n\n    if len(set(a)) == 1:\n        return str(a[0])\n    else:\n        return str(a[n // 2])",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 1818,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    f = [0] * (2 * 10**9 + 1)\n\n    for i in range(n):\n        x = a[i]\n        while x > 1:\n            f[x] = f[x // 2] + 1\n            x //= 2\n        f[x] = 0\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if f[a[i]] == f[a[j]]:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 1819,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def wipe_number(n: int, x: int) -> int:\n        for i in range(1, n + 1):\n            if x <= i:\n                return i\n            x -= i\n        return -1\n\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    result = [wipe_number(n, x) for n, x in queries]\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1820,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def find_indices(a):\n        n = len(a)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if not is_valid_triangle(a[i], a[j], a[k]):\n                        return [i + 1, j + 1, k + 1]\n        return -1\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        result.append(find_indices(a))\n\n    return \"\\n\".join(str(res) for res in result)\n",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 1821,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    notes = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_melody(subseq):\n        for i in range(len(subseq) - 1):\n            if abs(subseq[i + 1] - subseq[i]) != 1 and (subseq[i + 1] % 7) != (subseq[i] % 7):\n                return False\n        return True\n\n    def max_length_melody(start, end):\n        if start >= end:\n            return 0\n        if (start, end) in memo:\n            return memo[(start, end)]\n\n        memo[(start, end)] = max_length_melody(start + 1, end)\n        for i in range(start + 1, end):\n            if is_melody(notes[start:i + 1]) and is_melody(notes[i + 1:end]):\n                memo[(start, end)] = max(memo[(start, end)], len(notes[start:i + 1]) + len(notes[i + 1:end]))\n\n        return memo[(start, end)]\n\n    memo = {}\n    return str(max_length_melody(0, n))",
        "test": "",
        "num_ids": 318,
        "indeed": false
    },
    {
        "number": 1822,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    queue = [x]\n    for i in range(n):\n        if a[i] == 0:\n            queue.append(i + 1)\n    return \"\\n\".join(map(str, sorted(queue)))",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 1823,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    stresses = [0] * k\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] != a[j]:\n                stresses[a[i] - 1] += 1\n\n    min_stress = min(stresses)\n    min_genre = stresses.index(min_stress) + 1\n\n    return str(min_genre)",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 1824,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n    c = list(map(int, stdin.split('\\n')[3].split()))\n\n    for i in range(n):\n        if a[i] not in b:\n            error1 = a[i]\n            break\n\n    for j in range(n - 1):\n        if b[j] not in c:\n            error2 = b[j]\n            break\n\n    return str(error1) + ' ' + str(error2)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 1825,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t_strings = []\n    for _ in range(n):\n        t_i, k_i, *x_i = stdin.readline().strip().split()\n        k_i = int(k_i)\n        x_i = [int(x) for x in x_i]\n        t_strings.append((t_i, k_i, x_i))\n\n    s = [\"\"] * (sum(k_i for _, k_i, _ in t_strings) + 1)\n    for t_i, k_i, x_i in t_strings:\n        for j in range(k_i):\n            s[x_i[j] + j] = t_i\n\n    return \"\".join(s)",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 1826,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n\n    count = 0\n    i = 0\n    while i < n - 1:\n        if sequence[i:i+2] in ['RU', 'UR']:\n            count += 1\n            i += 2\n        else:\n            i += 1\n\n    return n - count",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 1828,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_dangerous(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return False\n        if x1 == x2:\n            return y1 < y2\n        if y1 == y2:\n            return x1 < x2\n        return False\n\n    def count_dangerous_turns(n, points):\n        dangerous_turns = 0\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            x2, y2 = points[i + 1]\n            if is_dangerous(x1, y1, x2, y2):\n                dangerous_turns += 1\n        return dangerous_turns\n\n    n = int(stdin.readline().strip())\n    points = [tuple(map(int, line.split())) for line in stdin]\n    return str(count_dangerous_turns(n, points))",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 1829,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    poland_ball = set(stdin.readline().strip() for _ in range(n))\n    enemy_ball = set(stdin.readline().strip() for _ in range(m))\n\n    if len(poland_ball) > len(enemy_ball):\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1830,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    board = [[0] * n for _ in range(n)]\n    result = []\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        board[x - 1][y - 1] = 1\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 0:\n                    count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1831,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    connectors = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def is_valid(connector, used_connectors):\n        a, b = connector\n        if a == 1 or b == 1:\n            return True\n        for c in used_connectors:\n            if a in c or b in c:\n                return True\n        return False\n\n    for i in range(m):\n        if not is_valid(connectors[i], connectors[:i] + connectors[i + 1:]):\n            return \"no\"\n    return \"yes\"",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 1832,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcp(s1, s2):\n        n = min(len(s1), len(s2))\n        for i in range(n):\n            if s1[i] != s2[i]:\n                return i\n        return n\n\n    def generate_strings(a):\n        s = []\n        for i in range(len(a) + 1):\n            if i == 0:\n                s.append(\"\")\n            else:\n                s.append(s[i - 1] + chr(97 + i - 1))\n        return s\n\n    def find_strings(a):\n        s = generate_strings(a)\n        for i in range(1, len(s)):\n            if lcp(s[i - 1], s[i]) != a[i - 1]:\n                return None\n        return s\n\n    t = int(stdin.readline().strip())\n    output = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        strings = find_strings(a)\n        if strings:\n            output.extend(strings)\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 1833,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] % (j - i) == 0:\n                dp[j] += dp[i]\n                dp[j] %= mod\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 1834,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        if i % 2 == 0:\n            if a[i] < a[i - 1]:\n                a[i], a[i - 1] = a[i - 1], a[i]\n        else:\n            if a[i] > a[i - 1]:\n                a[i], a[i - 1] = a[i - 1], a[i]\n\n    return ' '.join(map(str, a)) if all(a[i] >= a[i - 1] for i in range(1, n) if i % 2 == 0) else 'Impossible'",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 1835,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def can_make_palindrome(s1: str, s2: str) -> bool:\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                if s1[i] == '0' and s2[i] == '1':\n                    s1 = s1[:i] + '1' + s1[i + 1:]\n                elif s1[i] == '1' and s2[i] == '0':\n                    s1 = s1[:i] + '0' + s1[i + 1:]\n                else:\n                    return False\n        return is_palindrome(s1)\n\n    def max_palindromic_strings(strings: List[str]) -> int:\n        n = len(strings)\n        dp = [[0] * n for _ in range(1 << n)]\n\n        for i in range(n):\n            dp[1 << i][i] = 1\n\n        for mask in range(1 << n):\n            for i in range(n):\n                if mask & (1 << i) == 0:\n                    continue\n                for j in range(n):\n                    if i == j or mask & (1 << j) == 0:\n                        continue\n                    if can_make_palindrome(strings[i], strings[j]):\n                        dp[mask][i] = max(dp[mask][i], dp[mask ^ (1 << i)][j] + 1)\n\n        return max(dp[-1])\n\n    Q = int(stdin.readline())\n    result = []\n\n    for _ in range(Q):\n        n = int(stdin.readline())\n        strings = [stdin.readline().strip() for _ in range(n)]\n        result.append(max_palindromic_strings(strings))\n\n    return '\\n'.join(map(str, result)) ",
        "test": "",
        "num_ids": 496,
        "indeed": false
    },
    {
        "number": 1836,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_beauty(n, m, edges):\n        def dfs(node, visited, tail):\n            if node not in visited:\n                visited.add(node)\n                tail.append(node)\n                for neighbor in adj[node]:\n                    dfs(neighbor, visited, tail)\n\n        def is_valid_tail(tail):\n            for i in range(1, len(tail)):\n                if tail[i] <= tail[i - 1]:\n                    return False\n            return True\n\n        def paint_spines(tail):\n            spines = 0\n            for node in tail:\n                for neighbor in adj[node]:\n                    if neighbor not in tail:\n                        spines += 1\n            return spines\n\n        adj = [set() for _ in range(n + 1)]\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n\n        max_beauty = 0\n        for i in range(1, n + 1):\n            visited = set()\n            tail = []\n            dfs(i, visited, tail)\n            if is_valid_tail(tail):\n                spines = paint_spines(tail)\n                max_beauty = max(max_beauty, len(tail) * spines)\n\n        return max_beauty\n\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    return str(find_max_beauty(n, m, edges))",
        "test": "",
        "num_ids": 397,
        "indeed": false
    },
    {
        "number": 1837,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    fixed_points = sum(1 for i in range(n) if a[i] == i)\n\n    swaps = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                a[i], a[j] = a[j], a[i]\n                swaps += 1\n                if swaps == 1:\n                    fixed_points += 1\n                break\n\n    return str(fixed_points)",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 1838,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_synonym(word1, word2):\n        return (word1, word2) in synonyms or (word2, word1) in synonyms\n\n    def is_antonym(word1, word2):\n        return (word1, word2) in antonyms or (word2, word1) in antonyms\n\n    def is_opposite(word1, word2):\n        return is_synonym(word1, word2) and is_antonym(word1, word2)\n\n    def add_relation(word1, word2, relation):\n        if relation == 1:\n            synonyms.add((word1, word2))\n        else:\n            antonyms.add((word1, word2))\n\n    def check_relation(word1, word2):\n        if is_synonym(word1, word2):\n            return 1\n        elif is_antonym(word1, word2):\n            return 2\n        else:\n            return 3\n\n    n, m, q = map(int, stdin.readline().split())\n    words = stdin.readline().split()\n    synonyms = set()\n    antonyms = set()\n\n    for i in range(m):\n        t, word1, word2 = stdin.readline().split()\n        t = int(t)\n        if is_opposite(word1, word2):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            add_relation(word1, word2, t)\n\n    for i in range(q):\n        word1, word2 = stdin.readline().split()\n        print(check_relation(word1, word2))\n\n    return \"\"",
        "test": "",
        "num_ids": 420,
        "indeed": false
    },
    {
        "number": 1839,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_asphalted(i, j, asphalted_roads):\n        return (i, j) in asphalted_roads or (j, i) in asphalted_roads\n\n    def asphalt_roads(i, j, asphalted_roads):\n        asphalted_roads.add((i, j))\n\n    def get_intersections(n):\n        intersections = []\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                intersections.append((i, j))\n        return intersections\n\n    def get_work_schedule(n, intersections):\n        work_schedule = []\n        for i in range(n):\n            for j in range(n):\n                work_schedule.append((i + 1, j + 1))\n        return work_schedule\n\n    def get_days_with_road_works(n, work_schedule, intersections):\n        asphalted_roads = set()\n        days_with_road_works = set()\n\n        for i, intersection in enumerate(work_schedule):\n            h, v = intersection\n            if not is_asphalted(h, v, asphalted_roads):\n                asphalt_roads(h, v, asphalted_roads)\n                days_with_road_works.add(i + 1)\n\n        return sorted(list(days_with_road_works))\n\n    n = int(stdin.readline().strip())\n    intersections = get_intersections(n)\n    work_schedule = get_work_schedule(n, intersections)\n    days_with_road_works = get_days_with_road_works(n, work_schedule, intersections)\n\n    return \" \".join(map(str, days_with_road_works))",
        "test": "",
        "num_ids": 464,
        "indeed": false
    },
    {
        "number": 1840,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, b = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    d = []\n    g = []\n    for i in range(b):\n        d_i, g_i = map(int, stdin.readline().split())\n        d.append(d_i)\n        g.append(g_i)\n\n    max_gold = []\n    for i in range(s):\n        max_gold.append(0)\n        for j in range(b):\n            if a[i] >= d[j]:\n                max_gold[i] += g[j]\n\n    return \" \".join(map(str, max_gold))",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 1841,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    l = [int(stdin.readline()) for _ in range(m)]\n\n    ans = []\n    for i in l:\n        distinct_numbers = set(a[i - 1:])\n        for j in range(i, n):\n            distinct_numbers.add(a[j])\n        ans.append(len(distinct_numbers))\n\n    return \"\\n\".join(map(str, ans))",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 1842,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    delta = b ** 2 - 4 * a * c\n    x1 = (-b + delta ** 0.5) / (2 * a)\n    x2 = (-b - delta ** 0.5) / (2 * a)\n    return f\"{max(x1, x2):.15f}\\n{min(x1, x2):.15f}\"",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 1843,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i])\n        sum = 0\n        for j in range(1, n + 1):\n            if (j & (j - 1)) == 0:\n                sum -= j\n            else:\n                sum += j\n        result.append(sum)\n    return '\\n'.join(str(i) for i in result)",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 1844,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return -1\n\n    a.sort()\n\n    for i in range(n):\n        if a[i] == 1:\n            return 1\n\n    for i in range(n - 1):\n        if gcd(a[i], a[i + 1]) == 1:\n            return 2\n\n    for i in range(n - 2):\n        if gcd(a[i], a[i + 1]) == 1 and gcd(a[i], a[i + 2]) == 1:\n            return 3\n\n    return -1",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 1845,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    powers = list(map(int, stdin.split('\\n')[1].split()))\n\n    total_power = sum(powers)\n    for i in range(n):\n        for j in range(n):\n            if powers[i] % powers[j] == 0:\n                total_power = min(total_power, total_power - powers[i] + powers[i] // powers[j] * powers[j])\n\n    return str(total_power)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 1846,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    t = list(map(int, t.split()))\n\n    if n < 2:\n        return 0\n\n    if t[0] >= 0 or t[-1] >= 0:\n        return -1\n\n    negative_count = 0\n    positive_count = 0\n    negative_index = -1\n    positive_index = -1\n\n    for i in range(n):\n        if t[i] < 0:\n            negative_count += 1\n            negative_index = i\n        else:\n            positive_count += 1\n            positive_index = i\n\n    if negative_count == 0 or positive_count == 0:\n        return -1\n\n    if negative_index < positive_index:\n        return negative_count + positive_count - 1\n    else:\n        return negative_count + positive_count\n\n\ndef",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 1847,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_allowed(x, y):\n        for r, a, b in segments:\n            if r == x and a <= y <= b:\n                return True\n        return False\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), distance = queue.pop(0)\n            if (x, y) == end:\n                return distance\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_x, new_y = x + dx, y + dy\n                    if 1 <= new_x <= 10**9 and 1 <= new_y <= 10**9 and is_allowed(new_x, new_y):\n                        queue.append(((new_x, new_y), distance + 1))\n\n        return -1\n\n    x_0, y_0, x_1, y_1 = map(int, stdin.split()[:4])\n    n = int(stdin.split()[4])\n    segments = [list(map(int, stdin.split()[5 + i * 3:8 + i * 3])) for i in range(n)]\n\n    return str(bfs((x_0, y_0), (x_1, y_1)))",
        "test": "",
        "num_ids": 359,
        "indeed": false
    },
    {
        "number": 1848,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    happy_count = 0\n    for i in range(n - 1):\n        if a[i] + 1 < a[i + 1]:\n            happy_count += 1\n\n    return str(happy_count)",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 1849,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 998244353\n    result = []\n\n    for i in range(1, n + 1):\n        count = 0\n        for j in range(10 ** (i - 1), 10 ** i):\n            j_str = str(j).zfill(i)\n            for k in range(i):\n                block_length = 1\n                while k + block_length < i and j_str[k + block_length] == j_str[k]:\n                    block_length += 1\n                count += 1\n                k += block_length - 1\n        result.append(count % mod)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 1850,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_rank(n, d, s, p):\n        points = [0] * n\n        points[d - 1] = p[d - 1]\n        for i in range(n):\n            if i != d - 1:\n                points[i] = s[i] + p[i]\n        points.sort(reverse=True)\n        return points.index(p[d - 1]) + 1\n\n    n, d = map(int, stdin.readline().split())\n    s = list(map(int, stdin.readline().split()))\n    p = list(map(int, stdin.readline().split()))\n\n    return str(find_best_rank(n, d, s, p))\n",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 1851,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    days = 0\n    read_pages = set()\n    for i in range(n):\n        if i not in read_pages:\n            days += 1\n            read_pages.add(i)\n            while i not in read_pages:\n                i += 1\n                read_pages.add(i)\n    return str(days)",
        "test": "",
        "num_ids": 98,
        "indeed": false
    },
    {
        "number": 1852,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tree(n: int, edges: List[Tuple[int, int]]) -> bool:\n        graph = defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            height = 0\n            min_node = node\n            for child in graph[node]:\n                if child != parent:\n                    h, min_child = dfs(child, node)\n                    height = max(height, h + 1)\n                    min_node = min(min_node, min_child)\n            return height, min_node\n\n        try:\n            dfs(1, -1)\n        except RecursionError:\n            return False\n\n        return True\n\n    def find_parent(n: int, edges: List[Tuple[int, int]], removed: int) -> int:\n        graph = defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            height = 0\n            min_node = node\n            for child in graph[node]:\n                if child != parent:\n                    h, min_child = dfs(child, node)\n                    height = max(height, h + 1)\n                    min_node = min(min_node, min_child)\n            return height, min_node\n\n        def find_path(node: int, target: int) -> List[int]:\n            path = [node]\n            while node != target:\n                node = next(iter(graph[node]))\n                path.append(node)\n            return path\n\n        def lca(u: int, v: int) -> int:\n            path_u = find_path(1, u)\n            path_v = find_path(1, v)\n            i = 0\n            while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n                i += 1\n            return path_u[i - 1]\n\n        parent = lca(removed, 1)\n        return parent\n\n    def process_case(stdin: str) -> str:\n        n, *edges = map(int, stdin.split())\n        edges = [(u, v) for u, v in zip(edges[::2], edges[1::2])]\n\n        if not is_valid_tree(n, edges):\n            return \"0\\n\"\n\n        ans = []\n        for removed in range(2, 2 ** n):\n            parent = find_parent(n, edges, removed)\n            if parent == removed:\n                continue\n            ans.append(parent)\n\n        return f\"{len(ans)}\\n{' '.join(map(str, sorted(ans)))}\\n\"\n\n    cases = stdin.split(\"\\n\\n\")[:-1]\n    return \"\\n\".join(process_case(case) for case in cases) ",
        "test": "",
        "num_ids": 763,
        "indeed": false
    },
    {
        "number": 1853,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compare(a, b):\n        if a < b:\n            return \"less\"\n        elif a > b:\n            return \"greater\"\n        else:\n            return \"equal\"\n\n    def find_arrays(n, pairs):\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                if i != j:\n                    first_array = [x for x in range(1, n + 1) if x != i and x != j]\n                    first_array.insert(i - 1, i)\n                    first_array.insert(j - 1, j)\n\n                    second_array = [x for x in range(1, n + 1) if x != i and x != j]\n                    second_array.insert(i - 1, i)\n                    second_array.insert(j - 1, i)\n\n                    if all(compare(first_array[a - 1], first_array[b - 1]) == compare(second_array[a - 1], second_array[b - 1]) for a, b in pairs):\n                        return first_array, second_array\n        return None, None\n\n    n, m = map(int, stdin.split())\n    pairs = [tuple(map(int, input().split())) for _ in range(m)]\n\n    first_array, second_array = find_arrays(n, pairs)\n\n    if first_array and second_array:\n        return \"YES\\n\" + \" \".join(map(str, first_array)) + \"\\n\" + \" \".join(map(str, second_array))\n    else:\n        return \"NO\" ",
        "test": "",
        "num_ids": 411,
        "indeed": false
    },
    {
        "number": 1854,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def construct_graph(n, a):\n        graph = []\n        for i in range(n):\n            graph.append([])\n            for j in range(n):\n                if i != j:\n                    graph[i].append(j)\n        return graph\n\n    def is_valid(graph, n, a):\n        for i in range(n):\n            if len(graph[i]) > a[i]:\n                return False\n        return True\n\n    def find_diameter(graph, n):\n        visited = [False] * n\n        max_dist = 0\n\n        def dfs(node, dist):\n            nonlocal max_dist\n            if dist > max_dist:\n                max_dist = dist\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, dist + 1)\n\n        dfs(0, 0)\n        visited = [False] * n\n        dfs(max_dist, 0)\n        return max_dist\n\n    def output_graph(graph, n):\n        edges = []\n        for i in range(n):\n            for j in graph[i]:\n                if (j, i) not in edges:\n                    edges.append((i, j))\n        return edges\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n\n    graph = construct_graph(n, a)\n    if not is_valid(graph, n, a):\n        return \"NO\"\n\n    diameter = find_diameter(graph, n)\n    edges = output_graph(graph, n)\n\n    output = [\"YES\", str(diameter), str(len(edges))]\n    for edge in edges:\n        output.append(\" \".join(map(str, edge)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 1855,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n\n    def max_partition_value(p, k):\n        p.sort()\n        partitions = []\n        for i in range(1, k + 1):\n            partitions.append([[i, p[i - 1]]])\n\n        for i in range(k, n):\n            new_partitions = []\n            for j in range(k):\n                if i - k + j + 1 >= p[i]:\n                    new_partitions.append(partitions[j] + [[p[i], i - k + j + 1]])\n            partitions = new_partitions\n\n        max_value = 0\n        count = 0\n        for partition in partitions:\n            value = sum(max(p[l - 1:r]) for l, r in partition)\n            if value > max_value:\n                max_value = value\n                count = 1\n            elif value == max_value:\n                count += 1\n\n        return max_value, count\n\n    max_value, count = max_partition_value(p, k)\n    return f\"{max_value} {count % 998244353}\\n\"",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 1856,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    passwords = [stdin.readline().strip() for _ in range(n)]\n\n    def is_equivalent(a: str, b: str) -> bool:\n        for i in range(len(a)):\n            if a[i] in b:\n                return True\n        return False\n\n    def find_equivalent_passwords(password: str) -> set:\n        equivalent_passwords = set()\n        for p in passwords:\n            if is_equivalent(password, p):\n                equivalent_passwords.add(p)\n        return equivalent_passwords\n\n    def find_min_passwords(password: str) -> int:\n        visited = set()\n        queue = [password]\n        count = 0\n\n        while queue:\n            count += 1\n            for _ in range(len(queue)):\n                current_password = queue.pop(0)\n                visited.add(current_password)\n                equivalent_passwords = find_equivalent_passwords(current_password)\n                for p in equivalent_passwords:\n                    if p not in visited:\n                        queue.append(p)\n\n        return count\n\n    min_passwords = float('inf')\n    for password in passwords:\n        min_passwords = min(min_passwords, find_min_passwords(password))\n\n    return str(min_passwords)",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 1857,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str(factorial(2 * n) // (factorial(n) ** 2))\n\ndef",
        "test": "",
        "num_ids": 38,
        "indeed": false
    },
    {
        "number": 1858,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin)\n    if n == 1:\n        return \"No\"\n\n    S1 = [1]\n    S2 = list(range(2, n + 1))\n\n    if gcd(sum(S1), sum(S2)) > 1:\n        return f\"Yes\\n{len(S1)} {' '.join(map(str, S1))}\\n{len(S2)} {' '.join(map(str, S2))}\\n\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1859,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    subtractions = 0\n\n    while n != 0:\n        for i in range(2, n + 1):\n            if n % i == 0:\n                n -= i\n                subtractions += 1\n                break\n\n    return str(subtractions)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 1860,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_offices = 0\n\n    for i in range(1, n + 1):\n        max_offices += 9 * (i // 2)\n\n    return str(max_offices)",
        "test": "",
        "num_ids": 63,
        "indeed": false
    },
    {
        "number": 1861,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    cards = [stdin.readline().strip() for _ in range(n)]\n\n    def is_set(a: str, b: str, c: str) -> bool:\n        for i in range(k):\n            if len(set([a[i], b[i], c[i]])) not in [1, 3]:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for l in range(j + 1, n):\n                if is_set(cards[i], cards[j], cards[l]):\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 186,
        "indeed": false
    },
    {
        "number": 1862,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, socks = map(int, stdin.split())\n    socks = list(zip(socks[::2], socks[1::2]))\n    socks.sort()\n    max_socks = 0\n    current_socks = set()\n\n    for sock in socks:\n        if sock[0] not in current_socks:\n            current_socks.add(sock[0])\n        else:\n            current_socks.remove(sock[0])\n\n        if sock[1] not in current_socks:\n            current_socks.add(sock[1])\n        else:\n            current_socks.remove(sock[1])\n\n        max_socks = max(max_socks, len(current_socks))\n\n    return str(max_socks)",
        "test": "",
        "num_ids": 198,
        "indeed": false
    },
    {
        "number": 1863,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_solution(eggs, a_prices, g_prices, index, a_sum, g_sum):\n        if index == len(eggs):\n            if abs(a_sum - g_sum) <= 500:\n                return \"\".join(result)\n            else:\n                return None\n\n        for i in range(index, len(eggs)):\n            if i > index:\n                if eggs[i] == eggs[index]:\n                    continue\n            result.append(\"A\" if a_prices[i] < g_prices[i] else \"G\")\n            new_a_sum = a_sum + a_prices[i]\n            new_g_sum = g_sum + g_prices[i]\n            if find_solution(eggs, a_prices, g_prices, i + 1, new_a_sum, new_g_sum) is not None:\n                return \"\".join(result)\n            result.pop()\n            a_sum = a_sum + a_prices[i]\n            g_sum = g_sum + g_prices[i]\n\n        return None\n\n    n = int(stdin.readline().strip())\n    eggs = []\n    a_prices = []\n    g_prices = []\n    for _ in range(n):\n        a, g = map(int, stdin.readline().strip().split())\n        eggs.append(a + g)\n        a_prices.append(a)\n        g_prices.append(g)\n\n    result = []\n    solution = find_solution(eggs, a_prices, g_prices, 0, 0, 0)\n    if solution is None:\n        return \"-1\"\n    else:\n        return solution",
        "test": "",
        "num_ids": 433,
        "indeed": false
    },
    {
        "number": 1864,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort(reverse=True)\n\n    total = 0\n    for i in range(n):\n        total += a[i] * (i + 1)\n\n    for i in range(n):\n        if total % a[i] != 0:\n            return str(total)\n        total -= a[i] * (n - i)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 1865,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    swaps = []\n    sorted_arr = sorted(arr)\n\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            for j in range(i + 1, n):\n                if arr[j] == sorted_arr[i]:\n                    swaps.append((i, j))\n                    arr[i], arr[j] = arr[j], arr[i]\n                    break\n\n    return f\"{len(swaps)}\\n\" + \"\\n\".join([\" \".join(map(str, swap)) for swap in swaps])",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 1866,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    q = min(n - 1, 5 * 10**5)\n    pairs = []\n\n    for i in range(1, n):\n        pairs.append((i, i + 1))\n\n    output = [str(q)]\n    for x, y in pairs:\n        output.append(f\"{x} {y}\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 106,
        "indeed": false
    },
    {
        "number": 1867,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    beauty = max(arr.count(x) for x in arr)\n    l, r = 0, n - 1\n    while arr.count(arr[l]) != beauty and l < r:\n        l += 1\n    while arr.count(arr[r]) != beauty and l < r:\n        r -= 1\n    return f\"{l + 1} {r + 1}\\n\"",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 1868,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a_size = map(int, stdin.readline().split())\n    b = list(map(int, stdin.readline().split()))\n\n    mod = 998244353\n\n    def count_distinct_strings(n: int, m: int, a_size: int, b: List[int]) -> int:\n        dp = [1] * (n + 1)\n\n        for k in b:\n            if k > n:\n                continue\n            temp = [0] * (n + 1)\n            for i in range(k, n + 1):\n                temp[i] = dp[i - k]\n                for j in range(i - k, i):\n                    temp[i] += dp[j]\n                    temp[i] %= mod\n            dp = temp\n\n        return dp[n]\n\n    result = count_distinct_strings(n, m, a_size, b)\n\n    return str(result)",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 1869,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n\n    count = 0\n    i = 0\n    while i < n:\n        if a[i] == i + 1:\n            count += 1\n            i += 1\n        else:\n            break\n\n    l = i\n    r = i\n\n    while l < n and r < n:\n        if a[r] == a[l] + 1:\n            r += 1\n        else:\n            l = r\n\n        if r - l + 1 > count:\n            count += 1\n        else:\n            count += r - l + 1\n            l = r\n\n    return str(count)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 1870,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.readline().split())\n    t = list(map(int, stdin.readline().split()))\n\n    words = []\n    for i in range(n):\n        if not words or t[i] - t[i - 1] <= c:\n            words.append(i)\n        else:\n            words = [i]\n\n    return str(len(words))",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 1871,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    c = list(map(int, input().split()))\n\n    time = 0\n    for i in range(n):\n        time += c[i] * x\n        x = max(1, x - 1)\n\n    return str(time)",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 1872,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    pi = 22 / 7\n    area = n * r * r * pi / 2\n    return f\"{area:.15f}\"",
        "test": "",
        "num_ids": 53,
        "indeed": false
    },
    {
        "number": 1873,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    books = list(map(int, input().split()))\n    genres = [0] * m\n    for book in books:\n        genres[book - 1] += 1\n    total = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            total += genres[i] * genres[j]\n    return str(total)",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 1874,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_3, l_4, l_5 = map(int, stdin.split())\n\n    def volume_pyramid(base_edge_length, height):\n        return (base_edge_length ** 2 * height) / 12\n\n    triangular_pyramid_volume = volume_pyramid(l_3, l_3)\n    quadrangular_pyramid_volume = volume_pyramid(l_4, l_4)\n    pentagonal_pyramid_volume = volume_pyramid(l_5, l_5)\n\n    total_volume = triangular_pyramid_volume + quadrangular_pyramid_volume + pentagonal_pyramid_volume\n\n    return f\"{total_volume:.9f}\"",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 1875,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area(a, b, c, d):\n        return abs(cross_product(a, b, c) + cross_product(b, c, d) + cross_product(c, d, a) + cross_product(d, a, b)) / 2\n\n    n = int(stdin.readline())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if all(cross_product(points[x], points[y], points[z]) != 0 for x, y, z in ((i, j, k), (j, k, l), (k, l, i), (l, i, j))):\n                        max_area = max(max_area, area(points[i], points[j], points[k], points[l]))\n\n    return f\"{max_area:.6f}\"",
        "test": "",
        "num_ids": 377,
        "indeed": false
    },
    {
        "number": 1876,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    black_edges = []\n    for _ in range(n - 1):\n        u, v, x = map(int, stdin.readline().split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        if x == 1:\n            black_edges.append((u, v))\n\n    @lru_cache(maxsize=None)\n    def dfs(node: int, depth: int) -> int:\n        if depth == 0:\n            return 1\n        result = 0\n        for neighbor in adj_list[node]:\n            if (node, neighbor) in black_edges:\n                result += dfs(neighbor, depth - 1)\n                result %= 10**9 + 7\n        return result\n\n    total = 0\n    for i in range(1, n + 1):\n        total += dfs(i, k)\n        total %= 10**9 + 7\n\n    return str(total)",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1877,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    S = stdin.readline().strip()\n\n    x, y = 0, 0\n    coins = 0\n\n    for move in S:\n        if move == 'U':\n            y += 1\n            if x == y:\n                coins += 1\n        else:\n            x += 1\n            if x == y:\n                coins += 1\n\n    return str(coins)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 1878,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rectangles = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    table = [[0] * 101 for _ in range(101)]\n\n    for x1, y1, x2, y2 in rectangles:\n        for i in range(y1, y2 + 1):\n            for j in range(x1, x2 + 1):\n                table[i][j] += 1\n\n    return str(sum(sum(row) for row in table))",
        "test": "",
        "num_ids": 145,
        "indeed": true
    },
    {
        "number": 1879,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, sx, sy, ex, ey = map(int, stdin.split()[0:5])\n    wind_directions = stdin.split()[1]\n\n    x, y = sx, sy\n    time = 0\n\n    for direction in wind_directions:\n        if direction == \"E\":\n            x += 1\n        elif direction == \"S\":\n            y -= 1\n        elif direction == \"W\":\n            x -= 1\n        elif direction == \"N\":\n            y += 1\n\n        time += 1\n\n        if x == ex and y == ey:\n            return str(time)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 1880,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = list(stdin)\n    shuffled_num = [num[0], num[2], num[4], num[3], num[1]]\n    shuffled_num = int(\"\".join(shuffled_num))\n    result = shuffled_num ** 5\n    return str(result)[-5:]",
        "test": "",
        "num_ids": 80,
        "indeed": true
    },
    {
        "number": 1881,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    pixels = list(map(int, stdin.readline().split()))\n\n    # Divide the color range [0, 255] into groups of consecutive colors\n    groups = []\n    for i in range(0, 256, k):\n        groups.append(list(range(i, i + k)))\n\n    # Assign one color in each group to be the group's key\n    keys = [min(group) for group in groups]\n\n    # Replace the color of each pixel with that color's assigned group key\n    posterized_pixels = [keys[pixel // k] for pixel in pixels]\n\n    # Return the lexicographically smallest possible array\n    return \" \".join(map(str, posterized_pixels))",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 1882,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    n, T = map(int, stdin.readline().split())\n    a_t = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    a_t.sort(key=lambda x: x[1])\n\n    total_time = 0\n    score = 0\n    result = []\n\n    for i in range(n):\n        if total_time + a_t[i][1] <= T:\n            total_time += a_t[i][1]\n            index = binary_search(a_t, (score + 1, a_t[i][0]))\n            score = max(score, index)\n            result.append(i + 1)\n\n    return f\"{score}\\n{len(result)}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 295,
        "indeed": false
    },
    {
        "number": 1883,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    types = list(map(int, stdin.readline().strip().split()))\n    tracks = list(map(int, stdin.readline().strip().split()))\n\n    hotel_index = types.index(1)\n    path = [hotel_index + 1]\n    k = 1\n\n    while k < n:\n        if types[hotel_index - k] == 0:\n            path.append(hotel_index - k + 1)\n            k += 1\n        elif tracks[hotel_index - k] == hotel_index - k:\n            path.append(hotel_index - k + 1)\n            k += 1\n        else:\n            break\n\n    path.reverse()\n    output = f\"{k}\\n{' '.join(map(str, path))}\"\n    return output",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1884,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_servers(x1, x2, c, n):\n        servers_1 = []\n        servers_2 = []\n        for i in range(n):\n            if c[i] >= x1 and c[i] >= x2:\n                servers_1.append(i)\n                servers_2.append(i)\n            elif c[i] >= x1:\n                servers_1.append(i)\n            elif c[i] >= x2:\n                servers_2.append(i)\n        return servers_1, servers_2\n\n    def deploy_services(x1, x2, c, n):\n        servers_1, servers_2 = find_servers(x1, x2, c, n)\n        if not servers_1 or not servers_2:\n            return False, [], []\n        k1 = len(servers_1)\n        k2 = len(servers_2)\n        return True, servers_1, servers_2\n\n    def print_output(yes_or_no, k1, k2, servers_1, servers_2):\n        print(yes_or_no)\n        if yes_or_no == \"Yes\":\n            print(f\"{k1} {k2}\")\n            print(\" \".join(map(str, servers_1)))\n            print(\" \".join(map(str, servers_2)))\n\n    n, x1, x2 = map(int, stdin.split()[0].split())\n    c = list(map(int, stdin.split()[1].split()))\n\n    yes_or_no, servers_1, servers_2 = deploy_services(x1, x2, c, n)\n    if yes_or_no:\n        print_output(\"Yes\", len(servers_1), len(servers_2), servers_1, servers_2)\n    else:\n        print_output(\"No\", 0, 0, [], [])",
        "test": "",
        "num_ids": 462,
        "indeed": false
    },
    {
        "number": 1885,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 5:\n        return \"0\"\n    elif n > 7:\n        return \"Too many resumes\"\n    else:\n        return str((n * (n - 1)) // 2)",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 1886,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.capitalize()",
        "test": "",
        "num_ids": 11,
        "indeed": false
    },
    {
        "number": 1887,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    h1 = list(map(int, stdin.readline().strip().split()))\n    h2 = list(map(int, stdin.readline().strip().split()))\n\n    h1.sort(reverse=True)\n    h2.sort(reverse=True)\n\n    max_height = 0\n    for i in range(n):\n        max_height += h1[i]\n        if i < n - 1:\n            max_height += h2[i + 1]\n\n    return str(max_height)",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 1888,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    debts = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    total_debt = sum(d[2] for d in debts)\n    min_debt = total_debt\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if debts[i][0] != debts[j][0] and debts[i][1] != debts[j][1]:\n                new_debt = total_debt - debts[i][2] - debts[j][2] + abs(debts[i][2] - debts[j][2])\n                min_debt = min(min_debt, new_debt)\n\n    return str(min_debt)",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 1889,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.readline().split())\n    grid = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    max_score = 0\n\n    for _ in range(q):\n        i, j = map(int, stdin.readline().split())\n        i -= 1\n        j -= 1\n\n        if grid[i][j] == 0:\n            grid[i][j] = 1\n        else:\n            grid[i][j] = 0\n\n        for row in grid:\n            score = 0\n            current_score = 0\n\n            for cell in row:\n                if cell == 1:\n                    current_score += 1\n                else:\n                    current_score = 0\n\n                score = max(score, current_score)\n\n            max_score = max(max_score, score)\n\n        print(max_score)\n\n    return \"\" ",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 1890,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = stdin.split(\"\\n\")\n    k = int(k)\n    n = len(a) * k\n    total_ways = 2 ** n\n    magic_number_ways = 0\n\n    for i in range(n):\n        magic_number = int(a * k)\n        magic_number = magic_number // 10 ** (n - i - 1)\n        if magic_number % 5 == 0:\n            magic_number_ways += total_ways // 2\n        total_ways = total_ways // 10\n\n    return str(magic_number_ways % (10**9 + 7))",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1891,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    base = list(map(int, input().split()))\n    base.sort()\n\n    def destroy(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return A\n        mid = (start + end) // 2\n        return max(destroy(start, mid), destroy(mid + 1, end), (base[end] - base[start] + 1) * B)\n\n    return str(destroy(0, len(base) - 1))",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1892,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    commands = [c == \"f\" for c in stdin.read().splitlines()]\n\n    MOD = 10**9 + 7\n    dp = [0] * n\n    dp[0] = 1\n\n    for i in range(1, n):\n        if commands[i]:\n            dp[i] = dp[i-1]\n            if not commands[i-1]:\n                dp[i] += dp[i-2]\n        else:\n            dp[i] = dp[i-1]\n\n        dp[i] %= MOD\n\n    return str(dp[-1])",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 1893,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    transistors = n * (1.000000011 ** t)\n    return f\"{transistors:.15f}\"",
        "test": "",
        "num_ids": 54,
        "indeed": false
    },
    {
        "number": 1894,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    house = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_empty(x, y):\n        return house[x][y] == '.'\n\n    def is_bricks(x, y):\n        return house[x][y] == '+'\n\n    def is_concrete(x, y):\n        return house[x][y] == '#'\n\n    def next_cell(x, y, direction):\n        if direction == 'R':\n            y += 1\n        else:\n            y -= 1\n        return x, y\n\n    def change_direction(direction):\n        return 'R' if direction == 'L' else 'L'\n\n    def count_seconds(x, y, direction):\n        seconds = 0\n        while x > 0:\n            if is_empty(x, y):\n                x, y = next_cell(x, y, direction)\n                seconds += 1\n            elif is_bricks(x, y):\n                house[x][y] = '.'\n                direction = change_direction(direction)\n                x, y = next_cell(x, y, direction)\n                seconds += 1\n            elif is_concrete(x, y):\n                direction = change_direction(direction)\n                x, y = next_cell(x, y, direction)\n                seconds += 1\n            else:\n                return \"Never\"\n        return seconds\n\n    result = count_seconds(n, 0, 'R')\n    return result if result != \"Never\" else \"Never\"",
        "test": "",
        "num_ids": 393,
        "indeed": false
    },
    {
        "number": 1895,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(n):\n        event = input().split()\n        if event[0] == '1':\n            events.append(('1', None))\n        else:\n            events.append(('2', event[1]))\n\n    max_happy_friends = 0\n    current_handle = ''\n    happy_friends = set()\n\n    for event in events:\n        if event[0] == '1':\n            max_happy_friends = max(max_happy_friends, len(happy_friends))\n            current_handle = ''\n            happy_friends = set()\n        else:\n            if event[1] == current_handle:\n                happy_friends.add(event[1])\n            else:\n                current_handle = event[1]\n\n    max_happy_friends = max(max_happy_friends, len(happy_friends))\n\n    return str(max_happy_friends)",
        "test": "",
        "num_ids": 255,
        "indeed": false
    },
    {
        "number": 1896,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hexagons = 1\n    for i in range(1, n + 1):\n        hexagons += 3 * i\n    return str(hexagons)",
        "test": "",
        "num_ids": 53,
        "indeed": false
    },
    {
        "number": 1897,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOUY\"\n    s = stdin.upper()\n    n = len(s)\n    simple_prettiness = sum(1 for c in s if c in vowels) / n\n    total_prettiness = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j + 1]\n            total_prettiness += simple_prettiness * len(substring)\n    return f\"{total_prettiness:.7f}\"",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 1898,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hate = \"I hate\"\n    love = \"I love\"\n    sentence = \"\"\n    for i in range(n):\n        if i % 2 == 0:\n            sentence += hate\n        else:\n            sentence += love\n        if i != n - 1:\n            sentence += \" that \"\n    return sentence",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 1899,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def find_kth_statistic(arr, k):\n        if k > len(arr):\n            return -1\n        return arr[k - 1]\n\n    def find_multiset(a, segments):\n        multiset = []\n        for i in range(len(a)):\n            for segment in segments:\n                if segment[0] <= i <= segment[1]:\n                    multiset.append(a[i])\n                    break\n        return multiset\n\n    lines = stdin.split(\"\\n\")\n    n, s, m, k = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = [list(map(int, lines[i].split())) for i in range(2, 2 + s)]\n\n    multiset = find_multiset(a, segments)\n    if len(multiset) < k:\n        return -1\n\n    sorted_multiset = merge_sort(multiset)\n    return find_kth_statistic(sorted_multiset, k)",
        "test": "",
        "num_ids": 446,
        "indeed": false
    },
    {
        "number": 1900,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    line = [0] * n\n    for i in range(n):\n        line[i] = a[i]\n\n    for i in range(m):\n        for j in range(n - k + 1):\n            if all(line[j + l] == line[j] for l in range(k)):\n                for l in range(k):\n                    line[j + l] = 0\n\n    return str(sum(line))",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 1901,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    adj = [[] for _ in range(n)]\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n\n    visited = [False] * n\n    q = [(0, 0)]  # (cost, node)\n\n    while q:\n        cost, node = heapq.heappop(q)\n        if visited[node]:\n            continue\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                heapq.heappush(q, (cost + c[neighbor], neighbor))\n\n    return str(max(c))",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 1902,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    prefixes = set()\n    for word in words:\n        for i in range(1, len(word) + 1):\n            prefixes.add(word[:i])\n\n    total_clicks = 0\n    for word in words:\n        for i in range(1, len(word) + 1):\n            if word[:i] in prefixes:\n                total_clicks += 1\n            else:\n                total_clicks += len(word) - i + 1\n                break\n\n    return total_clicks",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 1903,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split('\\n')[0].split())\n    physics_cups = sorted([list(map(int, line.split())) for line in stdin.split('\\n')[1:1+n]], key=lambda x: (-x[0], -x[1]))\n    informatics_cups = sorted([list(map(int, line.split())) for line in stdin.split('\\n')[1+n:1+n+m]], key=lambda x: (-x[0], -x[1]))\n\n    def find_max_significance(cups, d):\n        total_significance = 0\n        for i, (significance, width) in enumerate(cups):\n            if width <= d:\n                total_significance += significance\n                d -= width\n            else:\n                return total_significance\n        return total_significance\n\n    max_significance = 0\n    for i, (significance, width) in enumerate(physics_cups):\n        if width <= d:\n            max_significance += significance\n            d -= width\n        else:\n            break\n\n    max_significance += find_max_significance(informatics_cups, d)\n\n    return str(max_significance)",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 1904,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_easy(subseq: str) -> bool:\n        return \"hard\" not in subseq\n\n    def ambiguity(i: int) -> int:\n        return a[i]\n\n    def find_min_ambiguity(start: int, end: int) -> int:\n        if start > end:\n            return float(\"inf\")\n        if is_easy(s[start:end]):\n            return 0\n        min_ambiguity = float(\"inf\")\n        for i in range(start, end):\n            left_ambiguity = find_min_ambiguity(start, i - 1)\n            right_ambiguity = find_min_ambiguity(i + 1, end)\n            total_ambiguity = left_ambiguity + right_ambiguity + ambiguity(i)\n            min_ambiguity = min(min_ambiguity, total_ambiguity)\n        return min_ambiguity\n\n    return find_min_ambiguity(0, n - 1)",
        "test": "",
        "num_ids": 281,
        "indeed": false
    },
    {
        "number": 1905,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.readline().split())\n    operations = [list(map(int, stdin.readline().split())) for _ in range(q)]\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for op in operations:\n        if op[0] == 1:\n            row = op[1] - 1\n            matrix[row] = [matrix[row][-1]] + matrix[row][:-1]\n        elif op[0] == 2:\n            col = op[1] - 1\n            for i in range(n):\n                matrix[i][col] = matrix[(i + 1) % n][col]\n        else:\n            row, col, value = op[1:]\n            matrix[row - 1][col - 1] = value\n\n    return '\\n'.join([' '.join(map(str, row)) for row in matrix])\n",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 1906,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        if all(i % j != 0 for j in range(2, 11)):\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 1907,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area_of_polygon(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def is_inside(p, C_i):\n        return distance(p, C_i) <= r_i\n\n    def find_intersection_points(C_i, C_j):\n        p1, p2 = C_i, C_j\n        r1, r2 = r_i, r_j\n\n        d = distance(p1, p2)\n        if d > r1 + r2:\n            return None\n        if d < abs(r1 - r2):\n            return None\n\n        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n        h = (r1 ** 2 - a ** 2) ** 0.5\n\n        p3 = ((p1[0] + p2[0]) / 2 + (p2[1] - p1[1]) * h / d,\n              (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * h / d)\n\n        p4 = ((p1[0] + p2[0]) / 2 - (p2[1] - p1[1]) * h / d,\n              (p1[1] + p2[1]) / 2 + (p2[0] - p1[0]) * h / d)\n\n        return p3, p4\n\n    def find_spaciousness(C_i, C_j):\n        p1, p2 = C_i, C_j\n        r1, r2 = r_i, r_j\n\n        d = distance(p1, p2)\n        if d > r1 + r2:\n            return 0\n        if d < abs(r1 - r2):\n            return area_of_polygon([p1, p2, (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2])\n\n        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n        h = (r1 ** 2 - a ** 2) ** 0.5\n\n        p3 = ((p1[0] + p2[0]) / 2 + (p2[1] - p1[1]) * h / d,\n              (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * h / d)\n\n        p4 = ((p1[0] + p2[0]) / 2 - (p2[1] - p1[1]) * h / d,\n              (p1[1] + p2[1]) / 2 + (p2[0] - p1[0]) * h / d)\n\n        return area_of_polygon([p1, p3, p4]) + area_of_polygon([p2, p3, p4])\n\n    n = int(stdin.readline())\n    dancers = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        dancers.append((x, y, r))\n\n    max_spaciousness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            C_i, C_j = dancers[i], dancers[j]\n            p1, p2 = C_i[:2], C_j[:2]\n            r1, r2 = C_i[2], C_j[2]\n\n            if distance(p1, p2) > r1 + r",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 1908,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_survive(order: List[int]) -> bool:\n        food_count = [int(x) for x in stdin.split('\\n')[1].split()]\n        friend_prefs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n        for i in order:\n            x, y = friend_prefs[i - 1]\n            if food_count[x - 1] > 0 and food_count[y - 1] > 0:\n                food_count[x - 1] -= 1\n                food_count[y - 1] -= 1\n            elif food_count[x - 1] > 0:\n                food_count[x - 1] -= 1\n            elif food_count[y - 1] > 0:\n                food_count[y - 1] -= 1\n            else:\n                return False\n        return True\n\n    def generate_orders(n: int, m: int) -> List[List[int]]:\n        if n == m:\n            return [[i + 1] for i in range(n)]\n        else:\n            orders = []\n            for i in range(1, n + 1):\n                for order in generate_orders(n, m - 1):\n                    if not (i in order or (m - i + 1) in order):\n                        orders.append([i] + order)\n            return orders\n\n    n, m = map(int, stdin.split('\\n')[0].split())\n    orders = generate_orders(m, m)\n\n    for order in orders:\n        if can_survive(order):\n            return f\"ALIVE\\n{' '.join(map(str, order))}\"\n    return \"DEAD\" ",
        "test": "",
        "num_ids": 433,
        "indeed": false
    },
    {
        "number": 1909,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    total_power = [0] * (n + 1)\n    for i in range(1, n + 1):\n        total_power[i] = total_power[i - 1] + a[i - 1]\n\n    min_power = float('inf')\n    min_task = 0\n\n    for i in range(1, n + 1):\n        current_power = total_power[i - 1] + (total_power[n] - total_power[i - 1]) // (k - 1)\n        if current_power < min_power:\n            min_power = current_power\n            min_task = i\n\n    return str(min_task)",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 1910,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    total_spaces = 2 * n - 2\n    total_cars = n * 4\n\n    if total_cars > total_spaces:\n        return \"0\"\n\n    # Calculate the number of combinations for each make\n    combinations = []\n    for i in range(1, n + 1):\n        combinations.append(comb(total_cars, i))\n\n    # Calculate the total number of combinations\n    total_combinations = 1\n    for c in combinations:\n        total_combinations *= c\n\n    return str(total_combinations)\n\ndef",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 1911,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    min_cost = float('inf')\n\n    for i in range(n // k):\n        cost = sum(a[j] - a[i * k + j] for j in range(k))\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost)",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 1912,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def can_make_palindrome(r: int, g: int, b: int, w: int) -> bool:\n        if r % 2 != g % 2 or r % 2 != b % 2:\n            return False\n        if r % 2 == 0:\n            return True\n        return w % 2 == 0\n\n    lines = stdin.splitlines()\n    T = int(lines[0])\n    outputs = []\n    for i in range(1, T + 1):\n        r, g, b, w = map(int, lines[i].split())\n        if can_make_palindrome(r, g, b, w):\n            outputs.append(\"Yes\")\n        else:\n            outputs.append(\"No\")\n\n    return \"\\n\".join(outputs)",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 1913,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tanks = list(map(int, stdin.split('\\n')[1].split()))\n    product = 1\n\n    for tank in tanks:\n        if tank == 0:\n            product = 0\n            break\n        elif tank % 2 == 1 or tank % 5 == 0:\n            product = 0\n            break\n        else:\n            product *= tank\n\n    return str(product)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 1914,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    t = lines[0]\n    n = int(lines[1])\n    s = lines[2:]\n\n    def f(t: str, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(t):\n            if t[i:i+len(s)] == s:\n                count += 1\n                i += len(s)\n            else:\n                i += 1\n        return count\n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result += f(t, s[i] + s[j])\n\n    return str(result)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1915,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    max_value = 0\n    for i in range(2, n + 1):\n        for j in range(2, n + 1):\n            value = i * j\n            if value > max_value:\n                max_value = value\n    return str(max_value)",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 1916,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    c = []\n    for i in range(n):\n        j = i % m\n        c.append(a[i] & b[j])\n\n    return bin(sum(c))[2:].count('1')",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 1917,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(b):\n        return sum(b[i] * (a[i] - b[i] ** 2) for i in range(n))\n\n    def dfs(i, rem, curr_sum):\n        if i == n:\n            if rem == 0:\n                res.append(curr_sum[:])\n        else:\n            for j in range(a[i] + 1):\n                if rem - j >= 0:\n                    curr_sum[i] = j\n                    dfs(i + 1, rem - j, curr_sum)\n\n    res = []\n    dfs(0, k, [0] * n)\n    max_f = float('-inf')\n    max_b = None\n    for b in res:\n        curr_f = f(b)\n        if curr_f > max_f:\n            max_f = curr_f\n            max_b = b\n\n    return ' '.join(map(str, max_b))",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 1918,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, teams = map(lambda x: x.strip(), stdin.split('\\n'))\n    n, p, teams = int(n), list(map(int, p.split())), teams\n\n    def count_strength(teams: str, flip: bool) -> int:\n        strength = 0\n        for i in range(n):\n            if (flip and teams[i] == 'B') or (not flip and teams[i] == 'A'):\n                strength += p[i]\n        return strength\n\n    max_strength = count_strength(teams, False)\n    for i in range(1, n):\n        max_strength = max(max_strength, count_strength(teams, True))\n\n    return str(max_strength)",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 1919,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n % 2 == 0:\n        return \"1\"\n    else:\n        return \"2\"",
        "test": "",
        "num_ids": 53,
        "indeed": false
    },
    {
        "number": 1920,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    friends = stdin.split('\\n')[1:]\n    male_friends = []\n    female_friends = []\n\n    for i in range(n):\n        if friends[i][0] == 'M':\n            male_friends.append((int(friends[i].split()[1]), int(friends[i].split()[2])))\n        else:\n            female_friends.append((int(friends[i].split()[1]), int(friends[i].split()[2])))\n\n    male_friends.sort(key=lambda x: x[1])\n    female_friends.sort(key=lambda x: x[1])\n\n    max_people = 0\n    i = 0\n    j = 0\n\n    while i < len(male_friends) and j < len(female_friends):\n        if male_friends[i][1] < female_friends[j][1]:\n            i += 1\n        elif male_friends[i][1] > female_friends[j][1]:\n            j += 1\n        else:\n            max_people = max(max_people, male_friends[i][1] - male_friends[i][0] + 1 + female_friends[j][1] - female_friends[j][0] + 1)\n            i += 1\n            j += 1\n\n    return str(max_people)",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 1921,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, sx, sy, fx, fy = map(int, stdin.split()[:6])\n    inst_locs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), time = queue.pop(0)\n            if (x, y) == end:\n                return time\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                queue.extend([((x+1, y), time+1), ((x-1, y), time+1), ((x, y+1), time+1), ((x, y-1), time+1)])\n\n        return -1\n\n    def shortest_path(start, end, inst_locs):\n        min_time = float('inf')\n\n        for inst_loc in inst_locs:\n            if inst_loc[0] == start[0] or inst_loc[1] == start[1]:\n                min_time = min(min_time, bfs(start, inst_loc) + bfs(inst_loc, end))\n\n        return min_time\n\n    return str(shortest_path((sx, sy), (fx, fy), inst_locs))",
        "test": "",
        "num_ids": 339,
        "indeed": false
    },
    {
        "number": 1922,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    return str(N * M - (N + M - 2) ** 2)",
        "test": "",
        "num_ids": 37,
        "indeed": false
    },
    {
        "number": 1923,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *L = list(map(int, stdin.split()))\n    L.sort()\n    total_ingredients = 0\n\n    for i in range(0, 2 * N, 2):\n        total_ingredients += L[i]\n\n    return str(total_ingredients)",
        "test": "",
        "num_ids": 77,
        "indeed": true
    },
    {
        "number": 1924,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def f(r, c):\n        if r == 0 or c == 0:\n            return 1\n        if r == 1 or c == 1:\n            return min(r, c)\n        return (f(r - 1, c) + f(r, c - 1)) % MOD\n\n    result = 0\n    for i in range(r_1, r_2 + 1):\n        for j in range(c_1, c_2 + 1):\n            result += f(i, j)\n            result %= MOD\n\n    return str(result)\n",
        "test": "",
        "num_ids": 186,
        "indeed": false
    },
    {
        "number": 1925,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, N = map(int, stdin.split())\n    max_value = 0\n\n    for x in range(N + 1):\n        value = (A * x) // B - A * (x // B)\n        max_value = max(max_value, value)\n\n    return str(max_value)",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 1926,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_violations(k):\n        violations = 0\n        for i in range(k, n):\n            parent = (i - 1) // k\n            if parent > 0 and a[i] < a[parent]:\n                violations += 1\n        return violations\n\n    result = [count_violations(k) for k in range(1, n)]\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 1927,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    p = list(range(1, n + 1))\n    positions = [[] for _ in range(n)]\n\n    for i in range(m):\n        j = a[i] - 1\n        positions[j].append(p.index(a[i]))\n        p.insert(0, p.pop(p.index(a[i])))\n\n    result = []\n    for i in range(n):\n        min_pos = min(positions[i])\n        max_pos = max(positions[i])\n        result.append((min_pos, max_pos))\n\n    return \"\\n\".join(\" \".join(map(str, pair)) for pair in result)",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1928,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    penalty = 0\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = {start}\n\n        while queue:\n            cell, length = queue.pop(0)\n            if cell == end:\n                return length\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = cell[0] + dx, cell[1] + dy\n                if is_valid(new_x, new_y) and (new_x, new_y) not in visited and matrix[new_x - 1][new_y - 1] == 0:\n                    visited.add((new_x, new_y))\n                    queue.append(((new_x, new_y), length + 1))\n\n        return None\n\n    for _ in range(k):\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 0:\n                    path_length = bfs((1, 1), (i + 1, j + 1))\n                    if path_length is not None:\n                        matrix[i][j] = 1\n                        penalty += path_length\n                        print(f\"({i+1},{j+1})\")\n                        break\n            else:\n                continue\n            break\n\n    return str(penalty)",
        "test": "",
        "num_ids": 410,
        "indeed": false
    },
    {
        "number": 1929,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = map(int, stdin.split())\n    severities = list(map(int, input().split()))\n    severities.sort()\n\n    count = 0\n    for i in range(n - c + 1):\n        if severities[i + c - 1] <= t:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 1930,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        inv_count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    inv_count += 1\n        return inv_count\n\n    def expected_inversions(n, arr):\n        total_permutations = factorial(n)\n        valid_permutations = 0\n        for i in range(n):\n            if arr[i] != -1:\n                valid_permutations += factorial(n - 1)\n        return valid_permutations / total_permutations * count_inversions(arr)\n\n    def factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result\n\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    result = expected_inversions(n, arr)\n    P = int(result)\n    Q = 998244353\n    return str(P * pow(Q - 2, Q - 10, Q))",
        "test": "",
        "num_ids": 299,
        "indeed": false
    },
    {
        "number": 1931,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_pyramid(n: int) -> int:\n        pyramids = 0\n        while n > 0:\n            h = 1\n            while (h * (h + 1)) // 2 <= n:\n                h += 1\n            h -= 1\n            pyramids += 1\n            n -= (h * (h + 1)) // 2\n        return pyramids\n\n    test_cases = list(map(int, stdin.split()))\n    test_cases.pop(0)\n    return '\\n'.join(map(str, [build_pyramid(n) for n in test_cases])) ",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 1932,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    polyhedrons = {\n        \"Tetrahedron\": 4,\n        \"Cube\": 6,\n        \"Octahedron\": 8,\n        \"Dodecahedron\": 12,\n        \"Icosahedron\": 20\n    }\n    total_faces = 0\n    for i in range(1, n+1):\n        polyhedron = stdin.split('\\n')[i]\n        total_faces += polyhedrons[polyhedron]\n    return str(total_faces)",
        "test": "",
        "num_ids": 142,
        "indeed": true
    },
    {
        "number": 1933,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    score = 0\n    replacements = 0\n\n    for j in range(m):\n        i = n\n        for ind, row in enumerate(a):\n            if row[j] == 1:\n                i = min(i, ind + 1)\n        if i <= n:\n            count = a[i - 1:i - 1 + min(k, n - i + 1)][j].count(1)\n            score += count\n            if count > 0:\n                replacements += 1\n\n    return f\"{score} {replacements}\"",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 1934,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    queries = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def min_distance(l, r):\n        min_dist = float('inf')\n        for i in range(l, r):\n            for j in range(i + 1, r + 1):\n                if a[i] == a[j]:\n                    min_dist = min(min_dist, abs(i - j))\n        return min_dist if min_dist != float('inf') else -1\n\n    result = []\n    for l, r in queries:\n        result.append(min_distance(l - 1, r - 1))\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1935,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    d = list(map(int, stdin.readline().split()))\n    g, r = map(int, stdin.readline().split())\n\n    if n == 1:\n        return 2 * g\n\n    d.sort()\n    d = [0] + d + [n]\n\n    time = 0\n    pos = 0\n    direction = 1\n\n    for i in range(len(d) - 1):\n        if d[i] <= pos < d[i + 1]:\n            if pos == d[i] and direction == -1:\n                time += g\n            else:\n                time += g + r\n        else:\n            return -1\n\n        if d[i] == pos:\n            direction = 1\n        elif d[i + 1] == pos:\n            direction = -1\n\n        if direction == 1:\n            pos += 1\n        else:\n            pos -= 1\n\n        if pos == n:\n            return time\n\n    return -1",
        "test": "",
        "num_ids": 262,
        "indeed": false
    },
    {
        "number": 1936,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_x_y(l, r):\n        for x in range(l, r):\n            for y in range(x + 1, r + 1):\n                if l <= lcm(x, y) <= r:\n                    return x, y\n        return -1, -1\n\n    t = int(stdin.split('\\n', 1)[0])\n    result = []\n\n    for _ in range(t):\n        l, r = map(int, stdin.split())\n        x, y = find_x_y(l, r)\n        result.append(f\"{x} {y}\")\n\n    return '\\n'.join(result)\n",
        "test": "",
        "num_ids": 219,
        "indeed": false
    },
    {
        "number": 1937,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    a = [0] * n\n    for i in range(n // 2):\n        a[i] = b[i] - b[n // 2 + i]\n    for i in range(n // 2, n):\n        a[i] = a[n - i - 1]\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 1938,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    segments = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def f(l, r):\n        return r - l + 1\n\n    def intersect(a, b):\n        return [max(a[0], b[0]), min(a[1], b[1])]\n\n    def sum_f(indices):\n        intersection = segments[indices[0]]\n        for i in indices[1:]:\n            intersection = intersect(intersection, segments[i])\n        return f(intersection[0], intersection[1])\n\n    result = 0\n    for indices in combinations(range(n), k):\n        result += sum_f(indices)\n        result %= 1000000007\n\n    return str(result)",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 1939,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                table[i][j] = k // n\n            else:\n                table[i][j] = k // (n - 1)\n\n    for i in range(n):\n        for j in range(n):\n            if table[i][j] < 0:\n                table[i][j] += k\n\n    return '\\n'.join([' '.join(map(str, row)) for row in table])",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 1940,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    pebbles = list(map(int, stdin.split()[1].split()))\n    pebbles.sort(reverse=True)\n    days = 0\n    pocket1 = pocket2 = 0\n\n    for i in range(n):\n        if pocket1 + pebbles[i] <= k:\n            pocket1 += pebbles[i]\n        elif pocket2 + pebbles[i] <= k:\n            pocket2 += pebbles[i]\n        else:\n            days += 1\n            pocket1 = pocket2 = 0\n            i -= 1\n\n        days += pebbles[i] // k\n        if pebbles[i] % k != 0:\n            days += 1\n\n    return str(days)",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 1941,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split()[0:3])\n    queries = [list(map(int, query.split())) for query in stdin.split('\\n')[1:]]\n    result = []\n\n    for query in queries:\n        l, t, m = query\n        r = l - 1\n        eaten_count = 0\n        karafses = [A + (i - 1) * B for i in range(l, t + 1)]\n\n        while eaten_count <= m and r < t:\n            r += 1\n            if r in karafses:\n                karafses.remove(r)\n                eaten_count += 1\n\n        if eaten_count > m:\n            result.append(-1)\n        else:\n            result.append(r)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 1942,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(n: int, l: int, r: int) -> List[int]:\n        cycle = [1] * (n + 1)\n        cycle[0] = 1\n        for i in range(1, n):\n            cycle[i] = cycle[i - 1] + 1 if cycle[i - 1] < n else 1\n        return cycle[l:r + 1]\n\n    T = int(stdin.split('\\n', 1)[0])\n    result = []\n    for _ in range(T):\n        n, l, r = map(int, stdin.split('\\n', 1)[0].split())\n        result.append(' '.join(map(str, find_cycle(n, l, r))))\n        stdin = stdin.split('\\n', 1)[1]\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 1943,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_score(probabilities, bracket):\n        score = 0\n        for i in range(len(bracket)):\n            if i == 0:\n                score += probabilities[bracket[i] - 1][2 * bracket[i] - 1]\n            else:\n                score += probabilities[bracket[i] - 1][2 * bracket[i] - 1] * 2**(i - 1)\n        return score\n\n    def dfs(probabilities, bracket, team, round_num, max_score):\n        if round_num == len(probabilities):\n            expected_score = get_expected_score(probabilities, bracket)\n            max_score[0] = max(max_score[0], expected_score)\n            return\n\n        if team <= 2**round_num:\n            bracket.append(team)\n            dfs(probabilities, bracket, team + 1, round_num + 1, max_score)\n            bracket.pop()\n\n        if team <= 2**(round_num + 1) - 1:\n            bracket.append(team)\n            dfs(probabilities, bracket, team + 1, round_num + 1, max_score)\n            bracket.pop()\n\n    N = int(stdin.readline().strip())\n    probabilities = [list(map(int, stdin.readline().strip().split())) for _ in range(2**N)]\n\n    max_score = [0]\n    dfs(probabilities, [], 1, 0, max_score)\n    return f\"{max_score[0]:.9f}\"",
        "test": "",
        "num_ids": 402,
        "indeed": false
    },
    {
        "number": 1944,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    laptops = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    laptops.sort(key=lambda x: x[0])\n    laptops.sort(key=lambda x: x[1], reverse=True)\n\n    for i in range(n - 1):\n        if laptops[i][0] < laptops[i + 1][0] and laptops[i][1] > laptops[i + 1][1]:\n            return \"Happy Alex\"\n    return \"Poor Alex\"",
        "test": "",
        "num_ids": 157,
        "indeed": true
    },
    {
        "number": 1945,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    requests = [line.split() for line in stdin.split('\\n')[1:]]\n    users = {}\n    for old, new in requests:\n        if old in users:\n            users[old] = new\n        else:\n            users[new] = old\n    changed_users = [user for user in users if user != users[user]]\n    output = [f\"{len(changed_users)}\"]\n    for user in changed_users:\n        output.append(f\"{users[user]} {user}\")\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 1946,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    chem_forces = []\n    top_chemist = []\n\n    for i in range(n):\n        a_i, x_i = map(int, stdin.readline().split())\n        chem_forces.append((a_i, x_i))\n\n    for i in range(m):\n        b_j, y_j = map(int, stdin.readline().split())\n        top_chemist.append((b_j, y_j))\n\n    chem_forces.sort(key=lambda x: x[1], reverse=True)\n    top_chemist.sort(key=lambda x: x[1], reverse=True)\n\n    total_income = 0\n    i = j = 0\n\n    while i < n and j < m:\n        if chem_forces[i][0] < top_chemist[j][0]:\n            total_income += chem_forces[i][1]\n            i += 1\n        elif chem_forces[i][0] > top_chemist[j][0]:\n            total_income += top_chemist[j][1]\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    while i < n:\n        total_income += chem_forces[i][1]\n        i += 1\n\n    while j < m:\n        total_income += top_chemist[j][1]\n        j += 1\n\n    return str(total_income)",
        "test": "",
        "num_ids": 383,
        "indeed": false
    },
    {
        "number": 1947,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(n, a, p, d, l):\n        a[p - 1] += d\n        a.sort(reverse=True)\n        time = 0\n        for i in range(n):\n            if a[i] > l:\n                time += 1\n            else:\n                break\n        return time\n\n    def read_input(stdin: str) -> tuple:\n        n, m, l = map(int, stdin.split()[0:3])\n        a = list(map(int, stdin.split()[3:3 + n]))\n        return n, a, m, l\n\n    n, a, m, l = read_input(stdin)\n    result = []\n    for i in range(m):\n        query = stdin.split()[3 + n + i]\n        if query[0] == '0':\n            result.append(process_query(n, a.copy(), 1, 0, l))\n        else:\n            p, d = map(int, query[1:].split())\n            process_query(n, a, p, d, l)\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 1948,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n\n    def dfs(node, parent):\n        nonlocal depth\n        depth = max(depth, node)\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, node)\n\n    depth = 0\n    dfs(1, -1)\n    dfs(x, -1)\n    return (depth - 1) * 2",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 1949,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for _ in range(k):\n        min_non_zero = min(filter(lambda x: x > 0, a))\n        if min_non_zero == float('inf'):\n            print(0)\n        else:\n            print(min_non_zero)\n            a = [x - min_non_zero if x > 0 else 0 for x in a]\n\n    return \"\"",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 1950,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = list(map(int, stdin.split()))\n    colors.sort()\n    penalty = 0\n    for i in range(n):\n        penalty += colors[i] * (i + 1)\n    return str(penalty)",
        "test": "",
        "num_ids": 63,
        "indeed": false
    },
    {
        "number": 1951,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    events = []\n    for _ in range(2 * n):\n        event = stdin.readline().strip().split()\n        if event[0] == '+':\n            events.append(('+', None))\n        else:\n            events.append(('-', int(event[1])))\n\n    shurikens = []\n    for event in events:\n        if event[0] == '+':\n            if not shurikens:\n                shurikens.append(1)\n            else:\n                shurikens.append(shurikens[-1] + 1)\n        else:\n            if event[1] == shurikens[0]:\n                shurikens.pop(0)\n            else:\n                return \"NO\"\n\n    if not shurikens:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 1952,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_distribute(c: List[int], sizes: List[int]) -> bool:\n        for i, s in enumerate(sizes):\n            if s >= i + 1 and c[i] == 0:\n                return False\n        return True\n\n    def find_min_testcases(n: int, k: int, c: List[int], m: List[int]) -> int:\n        ans = 0\n        sizes = [0] * (k + 1)\n        for i in range(n):\n            if sizes[m[i]] == 0:\n                ans += 1\n            sizes[m[i]] += 1\n\n        for i in range(k, -1, -1):\n            while sizes[i] > 0:\n                if can_distribute(c, sizes):\n                    return ans\n                sizes[i] -= 1\n                ans += 1\n        return ans\n\n    def print_testcases(n: int, k: int, c: List[int], m: List[int]) -> str:\n        ans = find_min_testcases(n, k, c, m)\n        sizes = [0] * (k + 1)\n        result = [[] for _ in range(ans)]\n        idx = 0\n\n        for i in range(n):\n            if sizes[m[i]] == 0:\n                idx += 1\n            sizes[m[i]] += 1\n            result[idx - 1].append(m[i])\n\n        for i in range(k, -1, -1):\n            while sizes[i] > 0:\n                if can_distribute(c, sizes):\n                    break\n                sizes[i] -= 1\n                idx += 1\n                result[idx - 1].append(i)\n\n        output = [f\"{len(result[i])} {' '.join(map(str, result[i]))}\" for i in range(ans)]\n        return '\\n'.join([str(ans)] + output)\n\n    stdin_list = stdin.split('\\n')\n    n, k = map(int, stdin_list[0].split())\n    m = list(map(int, stdin_list[1].split()))\n    c = list(map(int, stdin_list[2].split()))\n\n    return print_testcases(n, k, c, m) ",
        "test": "",
        "num_ids": 569,
        "indeed": false
    },
    {
        "number": 1953,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    times = list(map(int, stdin.split('\\n')[1].split()))\n    times.sort()\n    total_time = sum(times)\n    max_not_disappointed = 0\n    current_time = 0\n    for i in range(n):\n        current_time += times[i]\n        if current_time <= total_time - current_time:\n            max_not_disappointed += 1\n        else:\n            break\n    return str(max_not_disappointed)",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 1954,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def nCr(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    def count_ways(n, f):\n        return nCr(n - 1, f - 1) % (10**9 + 7)\n\n    queries = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = [count_ways(n, f) for n, f in queries]\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 1955,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    exams = list(map(int, stdin.readline().split()))\n    prep_days = list(map(int, stdin.readline().split()))\n\n    if len(exams) != n or len(prep_days) != m:\n        return -1\n\n    exams_dict = {}\n    for i in range(n):\n        if exams[i] != 0:\n            exams_dict[exams[i]] = i\n\n    days_to_pass = [0] * m\n    for i in range(m):\n        if i + 1 not in exams_dict:\n            return -1\n        days_to_pass[i] = exams_dict[i + 1] - prep_days[i] + 1\n\n    days_to_pass.sort(reverse=True)\n\n    total_days = 0\n    for i in range(m):\n        total_days += days_to_pass[i]\n\n    return total_days",
        "test": "",
        "num_ids": 255,
        "indeed": false
    },
    {
        "number": 1956,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_win(s, e):\n        if s > e:\n            return True\n        if s == e:\n            return False\n        if s % 2 == 0 and s + 1 > e:\n            return False\n        if s % 2 == 1 and 2 * s > e:\n            return False\n        return True\n\n    def can_lose(s, e):\n        if s > e:\n            return False\n        if s == e:\n            return True\n        if s % 2 == 0 and s + 1 > e:\n            return True\n        if s % 2 == 1 and 2 * s > e:\n            return True\n        return False\n\n    t = int(stdin.readline().strip())\n    lee_win = 1\n    lee_lose = 1\n\n    for i in range(t):\n        s, e = map(int, stdin.readline().strip().split())\n        if can_win(s, e):\n            lee_win = 1\n        else:\n            lee_win = 0\n\n        if can_lose(s, e):\n            lee_lose = 1\n        else:\n            lee_lose = 0\n\n    return f\"{lee_win} {lee_lose}\"",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 1957,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split()[0:3])\n    sizes = list(map(int, stdin.split()[3:]))\n\n    total_size = sum(sizes)\n    min_holes_to_block = n\n\n    for i in range(n):\n        if i == 0:\n            continue\n        if sizes[i] == 0:\n            continue\n        current_flow = (A * sizes[i]) / total_size\n        if current_flow >= B:\n            min_holes_to_block = min(min_holes_to_block, i)\n\n    return str(min_holes_to_block)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 1958,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    total_apples = 0\n    for i in range(n):\n        if stdin.split()[i + 1] == \"halfplus\":\n            total_apples += 1\n        else:\n            total_apples += 2\n    total_money = (total_apples * p) // 2\n    return str(total_money)",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 1959,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    even_count = sum(1 for x in a if x % 2 == 0)\n    odd_count = sum(1 for x in a if x % 2 != 0)\n\n    if even_count != odd_count:\n        return \"-1\"\n\n    exchanges = 0\n    result = []\n    for i in range(n):\n        if a[i] % 2 == 0:\n            exchanges += 1\n            result.append(a[i] // 2)\n        else:\n            exchanges += 1\n            result.append((a[i] + 1) // 2)\n\n    return f\"{exchanges}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 1960,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if a[i] > a[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    result = []\n    for i in range(n):\n        if lis[i] == 1 and lds[i] == 1:\n            result.append('1')\n        elif lis[i] == lds[i]:\n            result.append('2')\n        else:\n            result.append('3')\n\n    return ''.join(result)",
        "test": "",
        "num_ids": 273,
        "indeed": false
    },
    {
        "number": 1961,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    signature = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x, y):\n        if 0 <= x < n and 0 <= y < m:\n            return True\n        return False\n\n    def paint(x, y):\n        for i in range(3):\n            for j in range(3):\n                if (i != 1 or j != 1) and is_valid(x + i - 1, y + j - 1) and signature[x + i - 1][y + j - 1] == '.':\n                    signature[x + i - 1][y + j - 1] = '#'\n\n    for i in range(n):\n        for j in range(m):\n            if signature[i][j] == '.':\n                paint(i, j)\n\n    for row in signature:\n        if '#' in row:\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 248,
        "indeed": false
    },
    {
        "number": 1962,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split()[0].split())\n    staves = sorted(map(int, stdin.split()[1].split()))\n\n    if n * k != len(staves):\n        return \"0\"\n\n    barrels = [staves[i:i + k] for i in range(0, n * k, k)]\n    volumes = [min(barrel) for barrel in barrels]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(volumes[i] - volumes[j]) > l:\n                return \"0\"\n\n    return str(sum(volumes))",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 1963,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    l_values = []\n    r_values = []\n    max_r_minus_l = 0\n\n    for j in range(n):\n        l = j\n        r = j\n        while l >= 0 and r < n and all(a[k] % a[j] == 0 for k in range(l, r + 1)):\n            if r - l > max_r_minus_l:\n                max_r_minus_l = r - l\n                l_values = [l + 1]\n                r_values = [r + 1]\n            elif r - l == max_r_minus_l:\n                l_values.append(l + 1)\n                r_values.append(r + 1)\n            r += 1\n        while l >= 0 and r >= 0 and all(a[k] % a[j] == 0 for k in range(l, r + 1)):\n            if r - l > max_r_minus_l:\n                max_r_minus_l = r - l\n                l_values = [l + 1]\n                r_values = [r + 1]\n            elif r - l == max_r_minus_l:\n                l_values.append(l + 1)\n                r_values.append(r + 1)\n            l -= 1\n\n    return f\"{len(l_values)}\\n{max_r_minus_l}\\n{' '.join(map(str, sorted(l_values)))}\\n\"",
        "test": "",
        "num_ids": 400,
        "indeed": false
    },
    {
        "number": 1964,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    k = list(map(int, stdin.split('\\n')[1].split()))\n    m = [list(map(int, stdin.split('\\n')[i+2].split())) for i in range(n)]\n\n    min_time = float('inf')\n    for i in range(n):\n        time = k[i] * 5 + 15\n        if time < min_time:\n            min_time = time\n\n    return str(min_time)",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 1965,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_contests(n: int, x: int, a: List[int]) -> int:\n        a.sort()\n        infected = [False] * n\n        infected[0] = True\n        min_contests = 0\n\n        for i in range(1, n):\n            if a[i] == x:\n                infected[i] = True\n                min_contests += 1\n\n        for i in range(n):\n            if not infected[i]:\n                left, right = i - 1, i + 1\n                while left >= 0 or right < n:\n                    if left >= 0 and infected[left]:\n                        if a[left] == a[i] + 1:\n                            infected[i] = True\n                            min_contests += 1\n                            break\n                        left -= 1\n                    if right < n and infected[right]:\n                        if a[right] == a[i] - 1:\n                            infected[i] = True\n                            min_contests += 1\n                            break\n                        right += 1\n\n        return min_contests\n\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, x = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        result.append(find_min_contests(n, x, a))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 377,
        "indeed": false
    },
    {
        "number": 1966,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[int]]) -> bool:\n        n = len(board)\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == -1:\n                    continue\n                count = 0\n                for di, dj in [(-2, -1), (-2, 1), (2, -1), (2, 1)]:\n                    if 0 <= i + di < n and 0 <= j + dj < n and board[i + di][j + dj] == board[i][j]:\n                        count += 1\n                if count < 2:\n                    return False\n        return True\n\n    def dfs(board: List[List[int]], i: int, j: int, color: int) -> None:\n        n = len(board)\n        for di, dj in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            if 0 <= i + di < n and 0 <= j + dj < n and board[i + di][j + dj] == -1:\n                board[i + di][j + dj] = color\n                dfs(board, i + di, j + dj, color)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    pieces = []\n    for i in range(4):\n        piece = []\n        for j in range(n):\n            piece.append(list(map(int, lines[1 + i * (n + 1) + j])))\n        pieces.append(piece)\n\n    min_recolor = float('inf')\n    for color in [0, 1]:\n        for i in range(4):\n            board = [[-1] * n for _ in range(n)]\n            for j in range(n):\n                for k in range(n):\n                    if pieces[i][j][k] == color:\n                        board[j][k] = color\n            dfs(board, 0, 0, 1 - color)\n            if is_valid(board):\n                min_recolor = min(min_recolor, sum(row.count(-1) for row in board))\n\n    return str(min_recolor)",
        "test": "",
        "num_ids": 578,
        "indeed": false
    },
    {
        "number": 1967,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.readline().split())\n    image = [list(stdin.readline().strip()) for _ in range(h)]\n\n    # Rotate 90 degrees clockwise\n    rotated_image = [[image[j][w - i - 1] for j in range(h)] for i in range(w)]\n\n    # Flip horizontally\n    flipped_image = [row[::-1] for row in rotated_image]\n\n    # Zoom in twice\n    zoomed_image = [[pixel * 4 for pixel in row] for row in flipped_image]\n\n    return '\\n'.join([''.join(row) for row in zoomed_image])\n",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 1968,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.readline().split())\n    sellers = []\n    for i in range(n):\n        k, *prices = map(int, stdin.readline().split())\n        for j in range(k):\n            if prices[j] <= v:\n                sellers.append(i + 1)\n                v -= prices[j]\n                break\n    return f\"{len(sellers)}\\n{' '.join(map(str, sellers))}\"",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 1969,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_cross(i, j):\n        if i < 1 or i > n - 2 or j < 1 or j > n - 2:\n            return False\n        if matrix[i - 1][j - 1] == 'X' and matrix[i - 1][j + 1] == 'X' and matrix[i + 1][j - 1] == 'X' and matrix[i + 1][j + 1] == 'X':\n            return True\n        return False\n\n    crosses = 0\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            if is_cross(i, j):\n                crosses += 1\n\n    return str(crosses)",
        "test": "",
        "num_ids": 219,
        "indeed": false
    },
    {
        "number": 1970,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(board, row, col, direction):\n        if direction == 1:\n            return board[row + 2][col + 2] != '#' and board[row + 2][col - 2] != '#'\n        elif direction == 2:\n            return board[row - 2][col + 2] != '#' and board[row - 2][col - 2] != '#'\n        elif direction == 3:\n            return board[row + 2][col + 2] != '#' and board[row - 2][col + 2] != '#'\n        else:\n            return board[row + 2][col - 2] != '#' and board[row - 2][col - 2] != '#'\n\n    def move_semiknights(board, knight1, knight2, direction1, direction2):\n        if direction1 == 1:\n            board[knight1[0] + 2][knight1[1] + 2] = 'K'\n            board[knight1[0] + 2][knight1[1] - 2] = 'K'\n        elif direction1 == 2:\n            board[knight1[0] - 2][knight1[1] + 2] = 'K'\n            board[knight1[0] - 2][knight1[1] - 2] = 'K'\n        elif direction1 == 3:\n            board[knight1[0] + 2][knight1[1] + 2] = 'K'\n            board[knight1[0] - 2][knight1[1] + 2] = 'K'\n        else:\n            board[knight1[0] + 2][knight1[1] - 2] = 'K'\n            board[knight1[0] - 2][knight1[1] - 2] = 'K'\n\n        if direction2 == 1:\n            board[knight2[0] + 2][knight2[1] + 2] = 'K'\n            board[knight2[0] + 2][knight2[1] - 2] = 'K'\n        elif direction2 == 2:\n            board[knight2[0] - 2][knight2[1] + 2] = 'K'\n            board[knight2[0] - 2][knight2[1] - 2] = 'K'\n        elif direction2 == 3:\n            board[knight2[0] + 2][knight2[1] + 2] = 'K'\n            board[knight2[0] - 2][knight2[1] + 2] = 'K'\n        else:\n            board[knight2[0] + 2][knight2[1] - 2] = 'K'\n            board[knight2[0] - 2][knight2[1] - 2] = 'K'\n\n    def find_semiknights(board):\n        knight1 = None\n        knight2 = None\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'K':\n                    if knight1 is None:\n                        knight1 = (i, j)\n                    else:\n                        knight2 = (i, j)\n        return knight1, knight2\n\n    def find_good_squares(board):\n        good_squares = []\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] != '#':\n                    good_squares.append((i, j))\n        return good_squares\n\n    def can_meet(board, knight1, knight2, good_squares):\n        if knight1 is None or knight2 is None:\n            return False\n\n        def dfs(board, knight1, knight2, visited):\n            if knight1 == knight2:\n                return True\n\n            for direction in range(1, 5):\n                if is_valid_move(board, knight1[0], knight1[1], direction):\n                    move_semiknights(board",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 1971,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    if sorted(p) != list(range(1, n + 1)):\n        return \"-1\"\n\n    q = [0] * n\n    for i in range(n):\n        q[p[i] - 1] = i + 1\n\n    return \" \".join(map(str, q))",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 1972,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(a, x, y, t):\n        if t == 1:\n            for i in range(x, 500001, x):\n                a[i % 500000] += y\n        else:\n            return sum(a[i] for i in range(y, 500000, x))\n\n    a = [0] * 500000\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for t, x, y in queries:\n        if t == 2:\n            print(process_query(a, x, y, t))\n        else:\n            process_query(a, x, y, t)\n\n    return ''",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1973,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    u = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = {}\n    for i in range(n):\n        if u[i] not in count:\n            count[u[i]] = 1\n        else:\n            count[u[i]] += 1\n\n    max_count = max(count.values())\n    min_count = min(count.values())\n\n    if max_count == min_count:\n        return str(n)\n\n    for i in range(n - 1, 0, -1):\n        if count[u[i]] == max_count:\n            count[u[i]] -= 1\n        elif count[u[i]] == min_count:\n            count[u[i]] += 1\n        else:\n            continue\n\n        if count[u[i]] == max_count or count[u[i]] == min_count:\n            return str(i)\n\n    return \"1\"",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 1974,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(robbers, searchlights):\n        for r in robbers:\n            for s in searchlights:\n                if r[0] <= s[0] and r[1] <= s[1]:\n                    return False\n        return True\n\n    def min_moves(robbers, searchlights):\n        moves = 0\n        while not is_safe(robbers, searchlights):\n            moves += 1\n            for i in range(len(robbers)):\n                robbers[i] = (robbers[i][0] + 1, robbers[i][1] + 1)\n        return moves\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    robbers = [tuple(map(int, lines[i + 1].split())) for i in range(n)]\n    searchlights = [tuple(map(int, lines[i + n + 1].split())) for i in range(m)]\n\n    return str(min_moves(robbers, searchlights))",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 1975,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    output = []\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            output.append(f\"{i} {j}\")\n\n    return f\"{len(output)}\\n\" + \"\\n\".join(output)",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 1976,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.readline().split())\n    pixels = []\n    for i in range(q):\n        x, y, t = map(int, stdin.readline().split())\n        pixels.append((x, y, t))\n\n    pixels.sort(key=lambda x: x[2])\n\n    def is_broken(x1, y1, x2, y2):\n        for x, y, t in pixels:\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                return True\n        return False\n\n    for x1, y1, t in pixels:\n        if is_broken(x1, y1, x1 + k - 1, y1 + k - 1):\n            return str(t)\n\n    return \"-1\"",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 1977,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x, y):\n        if 0 <= x < n and 0 <= y < n:\n            return True\n        return False\n\n    def dfs(x, y, k, path):\n        if k < 0:\n            return \"\"\n        if x == n - 1 and y == n - 1:\n            return \"\".join(path)\n\n        dx = [0, 1]\n        dy = [1, 0]\n\n        for i in range(2):\n            nx, ny = x + dx[i], y + dy[i]\n            if is_valid(nx, ny):\n                path.append(matrix[nx][ny])\n                matrix[nx][ny] = \"a\"\n                res = dfs(nx, ny, k - 1, path)\n                if res:\n                    return res\n                matrix[nx][ny] = path.pop()\n\n        return \"\"\n\n    return dfs(0, 0, k, [matrix[0][0]])",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 1978,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(subseq, seq):\n        it = iter(seq)\n        return all(c in it for c in subseq)\n\n    def bfs(graph, start, end):\n        queue = [(start, [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if vertex == end:\n                return path\n            for next_vertex in range(len(graph[vertex])):\n                if graph[vertex][next_vertex] == 1 and next_vertex not in path:\n                    queue.append((next_vertex, path + [next_vertex]))\n        return None\n\n    def find_shortest_good_subsequence(graph, path):\n        start, end = path[0], path[-1]\n        shortest_path = bfs(graph, start, end)\n        if shortest_path is None:\n            return None\n\n        good_subsequences = []\n        for i in range(len(shortest_path) - 1):\n            for j in range(i + 1, len(shortest_path)):\n                subseq = shortest_path[i:j + 1]\n                if is_subsequence(subseq, path):\n                    good_subsequences.append(subseq)\n\n        min_length = min(len(subseq) for subseq in good_subsequences)\n        min_length_subsequences = [subseq for subseq in good_subsequences if len(subseq) == min_length]\n\n        return min_length_subsequences[0]\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    adjacency_matrix = [list(map(int, line)) for line in lines[1:n + 1]]\n    m = int(lines[n + 1])\n    path = list(map(int, lines[n + 2].split()))\n\n    shortest_good_subsequence = find_shortest_good_subsequence(adjacency_matrix, path)\n    if shortest_good_subsequence is None:\n        return f\"0\\n\"\n\n    return f\"{len(shortest_good_subsequence)}\\n{' '.join(map(str, shortest_good_subsequence))}\\n\"",
        "test": "",
        "num_ids": 553,
        "indeed": false
    },
    {
        "number": 1979,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def count_pairs(a, b):\n        return sum(1 for i in range(n) if a[i] == b[i])\n\n    max_pairs = count_pairs(a, b)\n\n    for k in range(1, n):\n        a_shifted = a[k:] + a[:k]\n        b_shifted = b[k:] + b[:k]\n        max_pairs = max(max_pairs, count_pairs(a_shifted, b_shifted))\n\n    return str(max_pairs)",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 1980,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gap(l, r):\n        return max((d[r + 1] - d[i]) ** 2 for i in range(l, r))\n\n    n, a = map(int, stdin.split())\n    d, c = [], []\n    for _ in range(n):\n        di, ci = map(int, input().split())\n        d.append(di)\n        c.append(ci)\n\n    profit = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        profit[i] = a + c[i]\n        for j in range(i + 1, n):\n            profit[i] = max(profit[i], profit[j] + gap(i, j) + a * (j - i))\n\n    return str(profit[0])",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 1981,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    cat_vertices = set(i for i, has_cat in enumerate(map(int, stdin.split('\\n')[1].split())) if has_cat)\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent):\n        if not graph[node]:\n            return [1]\n        result = []\n        for child in graph[node]:\n            if child != parent:\n                result.extend(dfs(child, node))\n        return result\n\n    def is_valid(path):\n        for i in range(len(path) - m):\n            if all(path[j] in cat_vertices for j in range(i, i + m + 1)):\n                return False\n        return True\n\n    def count_valid_paths(node, parent):\n        if not graph[node]:\n            return 1\n        result = 0\n        for child in graph[node]:\n            if child != parent:\n                paths = dfs(child, node)\n                if is_valid(paths):\n                    result += 1\n        return result\n\n    return str(count_valid_paths(1, None))",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 1982,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_odd(n: int) -> bool:\n        return n % 2 != 0\n\n    def is_sum_of_k_odds(n: int, k: int) -> bool:\n        odds = [i for i in range(1, n + 1, 2)]\n        for i in range(len(odds)):\n            for j in range(i + 1, len(odds)):\n                if is_odd(n - odds[i] - odds[j]):\n                    return True\n        return False\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        n, k = map(int, stdin.split('\\n')[i].split())\n        if is_sum_of_k_odds(n, k):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 1983,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def longest_increasing_subsequence(arr):\n        tails = [0] * len(arr)\n        size = 0\n        for x in arr:\n            i = binary_search(tails, x)\n            tails[i] = x\n            size = max(size, i + 1)\n        return size\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    output = []\n    for i in range(1, t + 1):\n        n = int(lines[2 * i - 1])\n        a = list(map(int, lines[2 * i].split()))\n        new_array = a * n\n        result = longest_increasing_subsequence(new_array)\n        output.append(str(result))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 296,
        "indeed": false
    },
    {
        "number": 1984,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.readline().split())\n    levels = []\n    for _ in range(k):\n        level = []\n        for _ in range(n):\n            level.append(stdin.readline().strip())\n        levels.append(level)\n\n    # Initialize the difference matrix\n    diff_matrix = [[0] * k for _ in range(k)]\n    for i in range(k):\n        for j in range(i):\n            diff_count = 0\n            for x in range(n):\n                for y in range(m):\n                    if levels[i][x][y] != levels[j][x][y]:\n                        diff_count += 1\n            diff_matrix[i][j] = diff_count\n            diff_matrix[j][i] = diff_count\n\n    # Initialize the transfer matrix\n    transfer_matrix = [[0] * k for _ in range(k)]\n    for i in range(k):\n        transfer_matrix[i][i] = 1\n\n    # Calculate the minimum traffic\n    total_traffic = 0\n    for i in range(k):\n        min_traffic = float('inf')\n        min_index = -1\n        for j in range(i):\n            if diff_matrix[i][j] * w + transfer_matrix[j][i] < min_traffic:\n                min_traffic = diff_matrix[i][j] * w + transfer_matrix[j][i]\n                min_index = j\n        total_traffic += min_traffic\n        transfer_matrix[i][i] = 1\n        if min_index != -1:\n            transfer_matrix[i][min_index] = 1\n\n    # Generate the output\n    output = [str(total_traffic)]\n    for i in range(k):\n        min_traffic = float('inf')\n        min_index = -1\n        for j in range(i):\n            if diff_matrix[i][j] * w + transfer_matrix[j][i] < min_traffic:\n                min_traffic = diff_matrix[i][j] * w + transfer_matrix[j][i]\n                min_index = j\n        if min_index == -1:\n            output.append(f\"{i + 1} 0\")\n        else:\n            output.append(f\"{i + 1} {min_index + 1}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 596,
        "indeed": false
    },
    {
        "number": 1985,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    options = set()\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            options.add(sum(b[i:j]))\n\n    count = 0\n    for score in options:\n        if all(score + sum(a[:i]) in options for i in range(1, k + 1)):\n            count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 1986,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    restaurants = []\n    for _ in range(n):\n        f, t = map(int, stdin.readline().split())\n        restaurants.append((f, t))\n\n    max_joy = float('-inf')\n    for f, t in restaurants:\n        if t > k:\n            joy = f - (t - k)\n        else:\n            joy = f\n        max_joy = max(max_joy, joy)\n\n    return str(max_joy)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 1987,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_1, c_2 = map(int, stdin.split())\n    visitors = list(map(int, input()))\n    adults = [i for i in range(n) if visitors[i] == 1]\n    pupils = [i for i in range(n) if visitors[i] == 0]\n    min_price = float('inf')\n\n    for i in range(1, len(pupils) + 1):\n        groups = [pupils[j:j + i] for j in range(0, len(pupils), i)]\n        if all(len(group) == len(set(group)) for group in groups):\n            price = sum(c_1 + c_2 * (len(group) - 1) ** 2 for group in groups)\n            for group in groups:\n                price += c_1\n            min_price = min(min_price, price)\n\n    return str(min_price)",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 1988,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i * 2 - 1])\n        s = stdin.split('\\n')[i * 2]\n\n        min_s = s\n        min_k = 1\n\n        for k in range(1, n + 1):\n            modified_s = s\n            for j in range(0, n - k + 1):\n                modified_s = modified_s[:j] + modified_s[j:j + k][::-1] + modified_s[j + k:]\n\n            if modified_s < min_s:\n                min_s = modified_s\n                min_k = k\n\n        result.append(min_s + '\\n' + str(min_k))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 223,
        "indeed": true
    },
    {
        "number": 1989,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    f = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        f[i][i + 1] = 1 if a[i] == a[i + 1] else 0\n\n    for l in range(n - 1, 0, -1):\n        for i in range(l - 1, -1, -1):\n            for j in range(i + 1, l + 1):\n                f[i][j] = f[i][j - 1] + f[j][i + 1]\n\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if f[1][i + 1] > f[j][n] and f[1][j] > f[i + 1][n]:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 1990,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1]\n\n    def is_correct_text(text: str) -> bool:\n        stack = []\n        for char in text:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def count_colors(text: str) -> int:\n        stack = []\n        colors = {}\n        color = 1\n        for i, char in enumerate(text):\n            if char == '(':\n                stack.append(i)\n            elif char == ')':\n                start = stack.pop()\n                if start in colors:\n                    colors[i] = colors[start]\n                else:\n                    colors[i] = color\n                    colors[start] = color\n                    color += 1\n        return color - 1\n\n    cursor = 0\n    text = ''\n    result = []\n\n    for command in commands:\n        if command == 'L':\n            cursor = max(0, cursor - 1)\n        elif command == 'R':\n            cursor += 1\n            if len(text) < cursor:\n                text += ' '\n        else:\n            text = text[:cursor] + command + text[cursor + 1:]\n            cursor += 1\n\n        if is_correct_text(text):\n            result.append(count_colors(text))\n        else:\n            result.append(-1)\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 385,
        "indeed": false
    },
    {
        "number": 1991,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        n = len(arr)\n        if n <= 1:\n            return 0\n        mid = n // 2\n        left_inv = count_inversions(arr[:mid])\n        right_inv = count_inversions(arr[mid:])\n        split_inv = merge_sort_split_inv(arr)\n        return left_inv + right_inv + split_inv\n\n    def merge_sort_split_inv(arr):\n        n = len(arr)\n        if n <= 1:\n            return 0\n        mid = n // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        left_inv = merge_sort_split_inv(left)\n        right_inv = merge_sort_split_inv(right)\n        split_inv = merge_split_inv(left, right)\n        return left_inv + right_inv + split_inv\n\n    def merge_split_inv(left, right):\n        i = j = 0\n        count = 0\n        n_left, n_right = len(left), len(right)\n        result = []\n        while i < n_left and j < n_right:\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                count += n_left - i\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return count\n\n    def min_special_exchanges(arr):\n        n = len(arr)\n        if n <= 1:\n            return 0\n        if arr == sorted(arr):\n            return 0\n        return count_inversions(arr) // 2\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        arr = list(map(int, stdin.readline().strip().split()))\n        result.append(min_special_exchanges(arr))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 522,
        "indeed": false
    },
    {
        "number": 1992,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    def find_screen(icon_id):\n        for i in range(n):\n            if a[i] == icon_id:\n                return (i // k) + 1\n\n    gestures = 0\n    for app in b:\n        screen_num = find_screen(app)\n        gestures += screen_num - 1\n        gestures += 1\n\n    return str(gestures)",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 1993,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    field = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def dfs(x: int, y: int) -> int:\n        if not (0 <= x < n and 0 <= y < m and field[x][y] == '.'):\n            return 0\n        field[x][y] = '*'\n        return 1 + dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1)\n\n    output = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if field[i][j] == '*':\n                row.append(str(dfs(i, j) % 10))\n            else:\n                row.append('.')\n        output.append(''.join(row))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 1994,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    prefix_suffix = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i:j] == s[n - j + i:] and s[i:j] in s:\n                prefix_suffix.append((j - i, s.count(s[i:j])))\n    prefix_suffix.sort()\n    k = len(prefix_suffix)\n    output = [str(k)]\n    for l, c in prefix_suffix:\n        output.append(f\"{l} {c}\")\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 1995,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m, *queries = stdin.split('\\n')\n    m = int(m)\n    queries = [list(map(int, query.split())) for query in queries]\n\n    for query in queries:\n        l, r, k = query\n        k %= (r - l + 1)\n        s = s[:l - 1] + s[r - k:r] + s[l:r - k] + s[l - 1:l - k - 1:-1]\n\n    return s\n",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 1996,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    actions = stdin.split('\\n')[1:]\n\n    shock_count = 0\n    selected_letter = None\n    unique_letter = None\n    guessed_letters = set()\n\n    for action in actions:\n        if action[0] == '.':\n            if selected_letter is not None and selected_letter in action[2:]:\n                shock_count += 1\n        elif action[0] == '!':\n            if unique_letter is None:\n                unique_letter = set(action[2:])\n            else:\n                unique_letter &= set(action[2:])\n            if selected_letter is not None and selected_letter in action[2:]:\n                shock_count += 1\n        else:\n            guessed_letters.add(action[2])\n            if unique_letter is not None and len(unique_letter - guessed_letters) == 1:\n                selected_letter = unique_letter - guessed_letters\n\n    return shock_count",
        "test": "",
        "num_ids": 250,
        "indeed": false
    },
    {
        "number": 1997,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    def dfs(node, depth):\n        if not graph[node]:\n            return depth\n        return max(dfs(child, depth + 1) for child in graph[node])\n\n    max_depth = dfs(1, 0)\n    min_depth = dfs(1, 0)\n\n    for u, v in edges:\n        if len(graph[u]) == 1:\n            min_depth = min(min_depth, max_depth - dfs(v, 1))\n\n    return f\"{max_depth} {min_depth}\"",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 1998,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    ships = [0] * n\n    shots = list(map(int, list(stdin.strip())))\n\n    for i in range(n):\n        if shots[i] == 1:\n            for j in range(max(0, i - b + 1), min(n, i + 1)):\n                ships[j] += 1\n\n    answer = []\n    for i in range(n):\n        if ships[i] > 0:\n            answer.append(i + 1)\n\n    return f\"{len(answer)}\\n{' '.join(map(str, answer))}\"",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 1999,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    while True:\n        count_dict = {}\n        for num in arr:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n\n        min_val = min(count_dict, key=count_dict.get)\n\n        if count_dict[min_val] < 2:\n            break\n\n        indices = [i for i, x in enumerate(arr) if x == min_val]\n        arr.pop(indices[0])\n        arr.pop(indices[1] - 1)\n        arr.insert(indices[1] - 1, 2 * min_val)\n\n    return f\"{len(arr)}\\n{' '.join(map(str, arr))}\"",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 2000,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] + a[j]) & (a[i] + a[j] - 1) == 0:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 113,
        "indeed": true
    },
    {
        "number": 2001,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline()))\n    mod = 10**9 + 7\n\n    def max_enjoyment(l, r):\n        left = [0] * n\n        right = [0] * n\n        for i in range(l, r):\n            left[i] = (left[i - 1] if i > l else 0) + x[i]\n        for i in range(r - 1, l - 1, -1):\n            right[i] = (right[i + 1] if i < r - 1 else 0) + x[i]\n        max_e = 0\n        for i in range(l, r):\n            max_e = max(max_e, left[i - 1] + right[i + 1])\n        return max_e\n\n    result = []\n    for _ in range(q):\n        l, r = map(int, stdin.readline().split())\n        result.append(max_enjoyment(l, r))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 2002,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lca(u, v):\n        while u != v:\n            if depth[u] > depth[v]:\n                u = parent[u]\n            else:\n                v = parent[v]\n        return u\n\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    parent = [-1] * n\n    depth = [0] * n\n    stack = [(1, 0)]\n    while stack:\n        u, d = stack.pop()\n        parent[u] = parent[u] if parent[u] != -1 else 1\n        depth[u] = d\n        for v in adj[u]:\n            if parent[v] == -1:\n                stack.append((v, d + 1))\n\n    total = 0\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n            l = lca(u, v)\n            total += gcd(x[u], x[v])\n            total %= 10**9 + 7\n            if l != u and l != v:\n                total -= gcd(x[u], x[l]) + gcd(x[v], x[l])\n                total %= 10**9 + 7\n\n    return str(total)",
        "test": "",
        "num_ids": 437,
        "indeed": false
    },
    {
        "number": 2003,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A = [0]\n    max_xor = {0: 0}\n    for line in stdin.split('\\n')[1:]:\n        command, x = line.split()\n        x = int(x)\n        if command == '+':\n            A.append(x)\n            max_xor[x] = x ^ 0\n            for y in A:\n                if y != x:\n                    max_xor[x] = max(max_xor[x], max_xor[y])\n        elif command == '-':\n            A.remove(x)\n            del max_xor[x]\n        else:\n            print(max_xor[x])\n\n    return ''",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 2004,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = n // 2\n    k = [i * 2 for i in range(1, m + 1)]\n    if n % 2 == 1:\n        k.append(n)\n    return f\"{m}\\n{' '.join(map(str, k))}\"",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 2005,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, n1, n2 = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort(reverse=True)\n\n    sum1 = sum(a[:n1])\n    sum2 = sum(a[n1:n1 + n2])\n    mean1 = sum1 / n1\n    mean2 = sum2 / n2\n\n    return f\"{max(mean1, mean2):.10f}\"",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 2006,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(row, col):\n        return 0 <= row < n and 0 <= col < m\n\n    def find_dwarves():\n        dwarves = []\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'G':\n                    dwarves.append((i, j))\n        return dwarves\n\n    def move_dwarves(dwarves):\n        for i, j in dwarves:\n            if matrix[i][j + 1] == 'S':\n                return True\n        for i, j in dwarves:\n            if j + 1 == m - 1:\n                return True\n        new_dwarves = []\n        for i, j in dwarves:\n            if is_valid(i, j + 1) and matrix[i][j + 1] != 'G':\n                new_dwarves.append((i, j + 1))\n        return new_dwarves\n\n    dwarves = find_dwarves()\n    moves = 0\n\n    while dwarves:\n        moves += 1\n        dwarves = move_dwarves(dwarves)\n        if isinstance(dwarves, bool) and dwarves:\n            return str(moves)\n\n    return '-1'",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 2007,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        graph[x].append(y)\n\n    def dfs(node, visited, path_value):\n        if node not in visited:\n            visited.add(node)\n            path_value[0] = max(path_value[0], 1)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path_value)\n                path_value[0] += 1\n\n        if node == start:\n            return path_value[0]\n\n    max_value = -1\n    for i in range(1, n + 1):\n        start = i\n        max_value = max(max_value, dfs(start, set(), [0]))\n\n    return str(max_value)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2008,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    students = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        students.append((a, b, i + 1))\n\n    students.sort(key=lambda x: x[0] * (n - x[2]) + x[1] * (x[2] - 1))\n\n    total_dissatisfaction = 0\n    for i, (a, b, position) in enumerate(students):\n        total_dissatisfaction += a * (position - 1) + b * (n - position)\n\n    return str(total_dissatisfaction)",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 2009,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(grid, start, end):\n        n = len(grid)\n        visited = [[False] * n for _ in range(n)]\n        queue = [(start, 0)]\n        visited[start[0]][start[1]] = True\n\n        while queue:\n            (r, c), dist = queue.pop(0)\n            if (r, c) == end:\n                return dist\n\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r < n and 0 <= new_c < n and not visited[new_r][new_c] and grid[new_r][new_c] == \"0\":\n                    visited[new_r][new_c] = True\n                    queue.append(((new_r, new_c), dist + 1))\n\n        return -1\n\n    def min_cost(grid, start, end):\n        n = len(grid)\n        min_cost = float(\"inf\")\n\n        for sr in range(n):\n            for sc in range(n):\n                for tr in range(n):\n                    for tc in range(n):\n                        if grid[sr][sc] == \"0\" and grid[tr][tc] == \"0\":\n                            cost = (sr - tr) ** 2 + (sc - tc) ** 2\n                            dist = bfs(grid, (sr, sc), (tr, tc))\n                            if dist != -1:\n                                min_cost = min(min_cost, cost)\n\n        return min_cost if min_cost != float(\"inf\") else 0\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    start = tuple(map(int, lines[1].split()))\n    end = tuple(map(int, lines[2].split()))\n    grid = lines[3:]\n\n    return str(min_cost(grid, start, end))",
        "test": "",
        "num_ids": 501,
        "indeed": false
    },
    {
        "number": 2010,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    for _ in range(m):\n        t, *args = map(int, stdin.readline().split())\n        if t == 1:\n            v, x = args\n            a[v - 1] = x\n        elif t == 2:\n            y = args[0]\n            for i in range(n):\n                a[i] += y\n        else:\n            q = args[0]\n            print(a[q - 1])",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 2011,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def consolidate(a, b, c, d, z):\n        debts[a][b] -= z\n        debts[c][d] -= z\n        debts[a][c] += z\n        debts[b][d] += z\n\n    def minimize_debt(n, m, debts):\n        for i in range(m):\n            u, v, d = map(int, stdin.readline().split())\n            debts[u][v] += d\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j:\n                    consolidate(i, j, i, j, debts[i][j])\n\n        output = []\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j and debts[i][j] > 0:\n                    output.append((i, j, debts[i][j]))\n\n        return output\n\n    n, m = map(int, stdin.readline().split())\n    debts = [[0] * (n + 1) for _ in range(n + 1)]\n\n    output = minimize_debt(n, m, debts)\n\n    result = [str(len(output))] + [\" \".join(map(str, row)) for row in output]\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 2012,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n\n    s = []\n    for i in range(n):\n        if c[i] == 0:\n            continue\n        char = chr(97 + i)\n        s.append(char * c[i])\n\n    return ''.join(s)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 2013,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    start_positions = []\n    final_positions = []\n\n    for _ in range(k):\n        sx, sy = map(int, stdin.readline().split())\n        start_positions.append((sx, sy))\n\n    for _ in range(k):\n        fx, fy = map(int, stdin.readline().split())\n        final_positions.append((fx, fy))\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def get_neighbors(x, y):\n        return [\n            (x, y - 1),\n            (x, y + 1),\n            (x - 1, y),\n            (x + 1, y)\n        ]\n\n    def bfs(start_positions, final_positions):\n        visited = set()\n        queue = []\n\n        for i in range(len(start_positions)):\n            queue.append((start_positions[i], final_positions[i], 0))\n\n        while queue:\n            (x, y), (fx, fy), steps = queue.pop(0)\n            visited.add((x, y))\n\n            if (x, y) == (fx, fy):\n                continue\n\n            for nx, ny in get_neighbors(x, y):\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    queue.append(((nx, ny), (fx, fy), steps + 1))\n\n        return visited\n\n    visited = bfs(start_positions, final_positions)\n\n    if len(visited) == k * 2:\n        return -1\n\n    def backtrack(start_positions, final_positions, visited):\n        operations = []\n        queue = []\n\n        for i in range(len(start_positions)):\n            queue.append((start_positions[i], final_positions[i], \"\"))\n\n        while queue:\n            (x, y), (fx, fy), steps = queue.pop(0)\n\n            if (x, y) == (fx, fy):\n                continue\n\n            for nx, ny in get_neighbors(x, y):\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    queue.append(((nx, ny), (fx, fy), steps + 1))\n                    visited.add((nx, ny))\n                    operations.append(steps + 1)\n\n        return operations\n\n    operations = backtrack(start_positions, final_positions, visited)\n    actions = []\n\n    for op in operations:\n        if op % 4 == 0:\n            actions.append(\"U\")\n        elif op % 4 == 1:\n            actions.append(\"D\")\n        elif op % 4 == 2:\n            actions.append(\"L\")\n        else:\n            actions.append(\"R\")\n\n    return f\"{len(operations)}\\n{''.join(actions)}\"",
        "test": "",
        "num_ids": 769,
        "indeed": false
    },
    {
        "number": 2014,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    permutations = []\n    for _ in range(k):\n        permutations.append(list(map(int, input().split())))\n\n    def lcs(a, b):\n        dp = [[0] * (len(a) + 1) for _ in range(len(b) + 1)]\n        for i in range(1, len(b) + 1):\n            for j in range(1, len(a) + 1):\n                if b[i - 1] == a[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]\n\n    result = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            result = max(result, lcs(permutations[i], permutations[j]))\n\n    return str(result)",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 2015,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r, g, b):\n        if r == 0 or g == 0 or b == 0:\n            return True\n        if r > g + b or g > r + b or b > r + g:\n            return False\n        return True\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        r, g, b = map(int, stdin.readline().split())\n        if is_valid(r, g, b):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 2016,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_able_to_win(t, h, x, y, m):\n        damage = 0\n        time_passed = 0\n        mana_spent = 0\n\n        while time_passed < t and damage < h and mana_spent <= m:\n            damage += x\n            mana_spent += y\n            time_passed += 1\n\n        return damage >= h and time_passed <= t\n\n    def process_query(query, j, m):\n        k, a, b = query\n        if k == 1:\n            x = (a + j) % 10**6 + 1\n            y = (b + j) % 10**6 + 1\n            return x, y\n        else:\n            t = (a + j) % 10**6 + 1\n            h = (b + j) % 10**6 + 1\n            return is_able_to_win(t, h, x, y, m)\n\n    q, m = map(int, stdin.split())\n    x, y = 0, 0\n    j = 0\n    result = []\n\n    for i in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, y = process_query(query, j, m)\n        else:\n            j += 1 if process_query(query, j, m) else 0\n            result.append(\"YES\" if j > 0 else \"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 382,
        "indeed": false
    },
    {
        "number": 2017,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    swaps = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    p = [i for i in range(1, 1000001)]\n\n    for a, b in swaps:\n        p[a-1], p[b-1] = p[b-1], p[a-1]\n\n    inversions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if p[i] > p[j]:\n                inversions += 1\n\n    return str(inversions)",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 2018,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    walls = set()\n\n    for i in range(1, n + 1):\n        walls.add((1, i))\n\n    for i in range(1, m + 1):\n        walls.add((2, i))\n\n    for i in range(1, n):\n        walls.add((1, i))\n        walls.add((1, i + n))\n\n    for i in range(1, m):\n        walls.add((2, i))\n        walls.add((2, i + m))\n\n    for i in range(q):\n        sx, sy, ex, ey = map(int, input().split())\n        if (sx, sy) == (1, 1) and (ex, ey) == (2, 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, 1) and (ex, ey) == (1, 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, 1) and (ex, ey) == (1, 2):\n            print(\"YES\")\n        elif (sx, sy) == (1, 2) and (ex, ey) == (1, 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, 1) and (ex, ey) == (2, 2):\n            print(\"YES\")\n        elif (sx, sy) == (2, 2) and (ex, ey) == (2, 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, 1) and (ex, ey) == (2, 2):\n            print(\"YES\")\n        elif (sx, sy) == (2, 2) and (ex, ey) == (1, 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, 2) and (ex, ey) == (2, 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, 1) and (ex, ey) == (1, 2):\n            print(\"YES\")\n        elif (sx, sy) == (1, 1) and (ex, ey) == (1, n):\n            print(\"YES\")\n        elif (sx, sy) == (1, n) and (ex, ey) == (1, 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, 1) and (ex, ey) == (1, n + 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, n + 1) and (ex, ey) == (1, 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, n) and (ex, ey) == (1, n + 1):\n            print(\"YES\")\n        elif (sx, sy) == (1, n + 1) and (ex, ey) == (1, n):\n            print(\"YES\")\n        elif (sx, sy) == (2, 1) and (ex, ey) == (2, m):\n            print(\"YES\")\n        elif (sx, sy) == (2, m) and (ex, ey) == (2, 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, 1) and (ex, ey) == (2, m + 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, m + 1) and (ex, ey) == (2, 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, m) and (ex, ey) == (2, m + 1):\n            print(\"YES\")\n        elif (sx, sy) == (2, m + 1) and (ex, ey) == (2, m):\n            print(\"YES\")\n        elif (sx, sy) in walls or (ex, ey) in walls:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n    return \"\"",
        "test": "",
        "num_ids": 1014,
        "indeed": false
    },
    {
        "number": 2019,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        s = stdin.split('\\n')[i+1]\n        if len(s) == 1:\n            print(\"DA\")\n        else:\n            for j in range(len(s)-1):\n                if s[j] != s[j+1]:\n                    print(\"DA\")\n                    break\n            else:\n                print(\"NET\")",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 2020,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    clocks = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    x_sorted = sorted(clocks, key=lambda x: x[0])\n    y_sorted = sorted(clocks, key=lambda x: x[1])\n\n    x_segments = []\n    y_segments = []\n\n    for i in range(n):\n        if i == 0:\n            x_segments.append(x_sorted[i][0])\n            y_segments.append(y_sorted[i][1])\n        else:\n            if x_sorted[i][0] != x_sorted[i - 1][0]:\n                x_segments.append(x_sorted[i][0])\n            if y_sorted[i][1] != y_sorted[i - 1][1]:\n                y_segments.append(y_sorted[i][1])\n\n    x_segments.append(x_sorted[-1][0] + 1)\n    y_segments.append(y_sorted[-1][1] + 1)\n\n    return min(len(x_segments), len(y_segments))",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 2021,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, q = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    q = list(map(int, q.split()))\n\n    min_cost = [0] * m\n\n    for i in range(m):\n        q_i_cost = sum(sorted(a)[:q[i] - 1])\n        remaining_cost = sum(sorted(a)[q[i] - 1:])\n        min_cost[i] = q_i_cost + remaining_cost\n\n    return \" \".join(map(str, min_cost))",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 2022,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start, visited, length, path):\n        if length > k:\n            return None\n        if start in visited:\n            if length >= k and start == path[0]:\n                return path\n            return None\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                found = find_cycle(graph, neighbor, visited, length + 1, path)\n                if found:\n                    return found\n                path.pop()\n        visited.remove(start)\n        return None\n\n    def find_independent_set(graph, start, visited, size, set):\n        if size > len(graph):\n            return None\n        if start in visited:\n            return set\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                set.append(neighbor)\n                found = find_independent_set(graph, neighbor, visited, size + 1, set)\n                if found:\n                    return found\n                set.pop()\n        visited.remove(start)\n        return None\n\n    def build_graph(n, edges):\n        graph = {i: [] for i in range(1, n + 1)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return graph\n\n    lines = stdin.split('\\n')\n    n, m, k = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:m + 1]]\n    graph = build_graph(n, edges)\n\n    independent_set = find_independent_set(graph, 1, set(), 0, [])\n    if independent_set:\n        independent_set = sorted(independent_set, key=lambda x: -len(graph[x]))\n        if len(independent_set) >= len(graph) // 2:\n            return f\"1\\n{' '.join(map(str, independent_set[:len(graph) // 2]))}\\n\"\n\n    cycle = find_cycle(graph, 1, set(), 0, [1])\n    if cycle:\n        return f\"2\\n{len(cycle) - 1}\\n{' '.join(map(str, cycle))}\\n\"\n\n    return \"0\\n\"",
        "test": "",
        "num_ids": 582,
        "indeed": false
    },
    {
        "number": 2023,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def copy_subsegment(a, b, x, y, k):\n        for i in range(k):\n            b[y + i] = a[x + i]\n\n    def get_value(b, x):\n        return b[x]\n\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    result = []\n    for _ in range(m):\n        t = int(stdin.readline())\n        if t == 1:\n            x, y, k = map(int, stdin.readline().split())\n            copy_subsegment(a, b, x, y, k)\n        elif t == 2:\n            x = int(stdin.readline())\n            result.append(get_value(b, x))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 2024,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    MOD = 998244353\n\n    def count_emotional_orders(order: List[int]) -> int:\n        happy = 0\n        sad = 0\n        max_weight = 0\n\n        for i in order:\n            if a[i - 1] >= 2 * max_weight:\n                happy += 1\n            elif 2 * a[i - 1] <= max_weight:\n                sad += 1\n            max_weight = max(max_weight, a[i - 1])\n\n        return happy + sad\n\n    total = 0\n    for order in permutations(range(1, n + 1)):\n        total += count_emotional_orders(order)\n        total %= MOD\n\n    return str(total)",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 2025,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def count_composites(n: int) -> int:\n        if n <= 1:\n            return 0\n        if n <= 3:\n            return 1\n        if is_prime(n):\n            return 0\n        count = 1\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                count += 1\n                while n % i == 0:\n                    n //= i\n            i += 1\n        if n > 1:\n            count += 1\n        return count\n\n    queries = [int(line) for line in stdin.splitlines()[1:]]\n    results = []\n    for n in queries:\n        if n <= 3:\n            results.append(-1)\n        else:\n            results.append(count_composites(n))\n    return \"\\n\".join(str(result) for result in results)",
        "test": "",
        "num_ids": 332,
        "indeed": false
    },
    {
        "number": 2026,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    movements = stdin.split('\\n')[1]\n\n    x, y = 0, 0\n    points = set()\n\n    for move in movements:\n        if move == 'R':\n            x += 1\n        elif move == 'L':\n            x -= 1\n        elif move == 'U':\n            y += 1\n        elif move == 'D':\n            y -= 1\n        points.add((x, y))\n\n    return str(len(points))",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2027,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i] + i * (i + 1) // 2\n\n    return \" \".join(map(str, b))",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 2028,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod_pow(base, exponent, modulus):\n        result = 1\n        base = base % modulus\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            exponent = exponent // 2\n            base = (base * base) % modulus\n        return result\n\n    def factorial(n, mod):\n        if n == 0:\n            return 1\n        else:\n            return (n * factorial(n - 1, mod)) % mod\n\n    def inv(x, mod):\n        return mod_pow(x, mod - 2, mod)\n\n    def count_assignments(n, desk_pairs, mod=10**9 + 7):\n        total_assignments = factorial(2 * n, mod)\n        repeated_assignments = 0\n\n        desk_counts = {}\n        for desk1, desk2 in desk_pairs:\n            if desk1 == desk2:\n                continue\n            if desk1 not in desk_counts:\n                desk_counts[desk1] = 0\n            if desk2 not in desk_counts:\n                desk_counts[desk2] = 0\n            desk_counts[desk1] += 1\n            desk_counts[desk2] += 1\n\n        for count in desk_counts.values():\n            repeated_assignments += factorial(count, mod)\n\n        return (total_assignments - repeated_assignments * inv(2, mod)) % mod\n\n    N = int(stdin.readline().strip())\n    desk_pairs = [list(map(int, line.strip().split())) for line in stdin]\n\n    return str(count_assignments(N, desk_pairs))",
        "test": "",
        "num_ids": 449,
        "indeed": false
    },
    {
        "number": 2029,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(n - 1)]\n\n    def dfs(node, parent, weight):\n        nonlocal diameter\n        for neighbor, other_weight in edges[node - 1]:\n            if neighbor != parent:\n                next_weight = weight + other_weight\n                dfs(neighbor, node, next_weight)\n                diameter = max(diameter, next_weight)\n\n    diameter = 0\n    dfs(1, -1, 0)\n\n    return str(diameter)",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 2030,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    max_a_b = list(map(float, stdin.split('\\n')[1].split()))\n    min_a_b = list(map(float, stdin.split('\\n')[2].split()))\n\n    a = [0] * (n + 1)\n    b = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == j:\n                a[i] = max_a_b[i - 1]\n                b[i] = min_a_b[i - 1]\n            elif i < j:\n                a[i] += max_a_b[i - 1]\n                b[j] += min_a_b[i - 1]\n            else:\n                a[i] += max_a_b[j - 1]\n                b[j] += min_a_b[j - 1]\n\n    return ' '.join(map(str, a[1:])) + '\\n' + ' '.join(map(str, b[1:]))",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 2031,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_optimal(subseq, k, total_sum):\n        if len(subseq) != k:\n            return False\n        if total_sum != max_sum:\n            return False\n        if any(subseq[i] > subseq[i + 1] for i in range(k - 1)):\n            return False\n        return True\n\n    def find_optimal_subseq(a, k):\n        max_sum = sum(sorted(a, reverse=True)[:k])\n        for subseq in itertools.combinations(a, k):\n            if is_optimal(subseq, k, sum(subseq)):\n                return subseq\n        return None\n\n    n, a, m = map(int, stdin.split('\\n', 2)[:3])\n    a = list(map(int, stdin.split('\\n', 2)[1].split()))\n    requests = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    result = []\n    for k, pos in requests:\n        optimal_subseq = find_optimal_subseq(a, k)\n        if optimal_subseq is None:\n            result.append(0)\n        else:\n            result.append(optimal_subseq[pos - 1])\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 2032,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(k, i, dp):\n        if dp[k][i] != -1:\n            return dp[k][i]\n        if i == n:\n            return 0\n        res = float('-inf')\n        if k >= a[i]:\n            res = max(res, dfs(k - a[i] + b[i], i + 1, dp) + c[i] * (i in d))\n        res = max(res, dfs(k, i + 1, dp))\n        dp[k][i] = res\n        return res\n\n    def is_possible(stdin):\n        n, m, k = map(int, stdin.readline().split())\n        a, b, c = [0] * n, [0] * n, [0] * n\n        for i in range(n):\n            a[i], b[i], c[i] = map(int, stdin.readline().split())\n        u, v = [0] * m, [0] * m\n        for i in range(m):\n            u[i], v[i] = map(int, stdin.readline().split())\n        d = set()\n        for i in range(1, n):\n            for j in range(i):\n                if any(u[k] == i + 1 and v[k] == j + 1 for k in range(m)):\n                    d.add(j)\n        for i in range(n):\n            if i not in d and k < a[i]:\n                return False\n        return True\n\n    if not is_possible(stdin):\n        return \"-1\\n\"\n\n    n, m, k = map(int, stdin.readline().split())\n    a, b, c = [0] * n, [0] * n, [0] * n\n    for i in range(n):\n        a[i], b[i], c[i] = map(int, stdin.readline().split())\n    u, v = [0] * m, [0] * m\n    for i in range(m):\n        u[i], v[i] = map(int, stdin.readline().split())\n    d = set()\n    for i in range(1, n):\n        for j in range(i):\n            if any(u[k] == i + 1 and v[k] == j + 1 for k in range(m)):\n                d.add(j)\n\n    dp = [[-1] * n for _ in range(k + 1)]\n    res = dfs(k, 0, dp)\n    return f\"{res}\\n\" ",
        "test": "",
        "num_ids": 647,
        "indeed": false
    },
    {
        "number": 2033,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(roads):\n        graph = defaultdict(list)\n        for u, v in roads:\n            graph[u].append(v)\n        return graph\n\n    def find_shortest_path(graph, start, end):\n        queue = [(start, [])]\n        visited = set()\n        while queue:\n            node, path = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == end:\n                    return path\n                for neighbor in graph[node]:\n                    queue.append((neighbor, path))\n        return None\n\n    def count_rebuilds(graph, path):\n        rebuilds = 0\n        for i in range(1, len(path) - 1):\n            shortest_path = find_shortest_path(graph, path[i], path[-1])\n            if shortest_path is not None and path[i + 1] not in shortest_path:\n                rebuilds += 1\n        return rebuilds\n\n    n, m, k = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    path = list(map(int, stdin.readline().split()))\n\n    graph = build_graph(roads)\n    min_rebuilds = count_rebuilds(graph, path)\n    max_rebuilds = min_rebuilds + len(path) - 3\n\n    return f\"{min_rebuilds} {max_rebuilds}\" ",
        "test": "",
        "num_ids": 395,
        "indeed": false
    },
    {
        "number": 2034,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    graph = [[] for _ in range(n + 1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    separate_cities = 0\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            separate_cities += 1\n            dfs(i)\n\n    return str(separate_cities)",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 2035,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def can_see_tent(x1, y1, x2, y2):\n        return distance(x1, y1, x2, y2) <= 1\n\n    def count_students(x, y):\n        return sum(can_see_tent(s_x, s_y, x, y) for s_x, s_y in students)\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, s_x, s_y = map(int, input_data[0].split())\n    students = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    max_count = 0\n    max_x, max_y = None, None\n    for x in range(1000001):\n        for y in range(1000001):\n            if (x, y) == (s_x, s_y):\n                continue\n            count = count_students(x, y)\n            if count > max_count:\n                max_count = count\n                max_x, max_y = x, y\n\n    return f\"{max_count}\\n{max_x} {max_y}\"",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 2036,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, S_x, S_y = map(int, stdin.split())\n    visited = set()\n    stack = [(S_x, S_y)]\n\n    while stack:\n        x, y = stack.pop()\n        if (x, y) not in visited:\n            visited.add((x, y))\n            print(x, y)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in visited:\n                stack.append((nx, ny))\n\n    return \"\"",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2037,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    difficulties = list(map(int, stdin.split()[2:]))\n    pool = []\n    result = []\n\n    for difficulty in difficulties:\n        if difficulty not in pool:\n            pool.append(difficulty)\n            if len(pool) == n:\n                result.append(1)\n                pool = []\n            else:\n                result.append(0)\n        else:\n            result.append(0)\n\n    return ''.join(map(str, result))",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2038,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    m = 0\n    swaps = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(i - j) >= n // 2 and p[i] > p[j]:\n                swaps.append((i, j))\n                p[i], p[j] = p[j], p[i]\n                m += 1\n\n    return f\"{m}\\n\" + '\\n'.join([' '.join(map(str, swap)) for swap in swaps])",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 2039,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    extrema_count = 0\n\n    for i in range(1, n - 1):\n        if (a[i] < a[i - 1] and a[i] < a[i + 1]) or (a[i] > a[i - 1] and a[i] > a[i + 1]):\n            extrema_count += 1\n\n    return str(extrema_count)",
        "test": "",
        "num_ids": 142,
        "indeed": true
    },
    {
        "number": 2040,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = [int(x) for x in stdin.split('\\n')[1:]]\n\n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def generate_sequence(start: int) -> List[int]:\n        a = [start]\n        for i in range(1, n):\n            a.append(a[-1] + 1)\n        return a\n\n    def is_valid_sequence(a: List[int]) -> bool:\n        for i in range(n):\n            if sum_of_digits(a[i]) != b[i]:\n                return False\n        return True\n\n    for start in range(1, 301):\n        a = generate_sequence(start)\n        if is_valid_sequence(a):\n            return '\\n'.join(str(x) for x in a)\n\n    assert False, \"No valid sequence found\"",
        "test": "",
        "num_ids": 245,
        "indeed": false
    },
    {
        "number": 2041,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_optimal(subseq, k, total_sum):\n        if len(subseq) != k:\n            return False\n        if total_sum != max_sum:\n            return False\n        for i in range(k):\n            for j in range(i + 1, k):\n                if subseq[i] > subseq[j]:\n                    return False\n        return True\n\n    def find_optimal_subseq(a, k):\n        max_sum = sum(sorted(a, reverse=True)[:k])\n        for i in range(n - k + 1):\n            for j in range(i + k, n + 1):\n                subseq = a[i:j]\n                total_sum = sum(subseq)\n                if is_optimal(subseq, k, total_sum):\n                    return subseq\n        return None\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    m = int(lines[2])\n    requests = [list(map(int, line.split())) for line in lines[3:]]\n\n    result = []\n    for k, pos in requests:\n        optimal_subseq = find_optimal_subseq(a, k)\n        result.append(optimal_subseq[pos - 1])\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 344,
        "indeed": false
    },
    {
        "number": 2042,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m and matrix[x - 1][y - 1] == '.'\n\n    def dfs(x, y):\n        if not is_valid(x, y):\n            return 0\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1)\n\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    matrix = [list(stdin.split('\\n')[i]) for i in range(1, n + 1)]\n\n    for _ in range(k):\n        x, y = map(int, stdin.split('\\n')[n + 1 + _].split())\n        visited = set()\n        print(dfs(x, y))\n\n    return ''",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2043,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    count = 0\n    for i in range(len(t) - len(s) + 1):\n        if t[i:i + len(s)] == s:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 2044,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    pages = [0] * n\n    current_page = 1\n    current_page_names = 0\n\n    for i in range(n):\n        while a[i] > 0:\n            if current_page_names + a[i] <= m:\n                current_page_names += a[i]\n                a[i] = 0\n            else:\n                pages[i] = current_page\n                current_page += 1\n                current_page_names = a[i] % m\n                a[i] = a[i] // m\n\n    return \" \".join(map(str, pages))",
        "test": "",
        "num_ids": 186,
        "indeed": false
    },
    {
        "number": 2045,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = stdin.readline().strip().split()\n\n    compressed_word = words[0]\n    for i in range(1, n):\n        prefix_len = 0\n        for j in range(1, min(len(compressed_word), len(words[i]) + 1)):\n            if compressed_word[-j:] == words[i][:j]:\n                prefix_len = j\n            else:\n                break\n        compressed_word += words[i][prefix_len:]\n\n    return compressed_word",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 2046,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sizes = list(map(int, stdin.split('\\n')[1].split()))\n    snacktower = []\n    for i in range(n):\n        if not snacktower or sizes[i] < snacktower[-1]:\n            snacktower.append(sizes[i])\n        else:\n            j = 0\n            while j < len(snacktower) and sizes[i] > snacktower[j]:\n                j += 1\n            snacktower.insert(j, sizes[i])\n        print(snacktower[i] if i < len(snacktower) else \"\")",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2047,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n    transformations = [list(map(int, stdin.readline().strip().split())) for _ in range(n - 1)]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            x, k = transformations[j - 1]\n            if x == i + 1:\n                b[i] += a[j] // k\n            elif x == j + 1:\n                b[j] += a[i] // k\n\n    for i in range(n):\n        if b[i] < a[i]:\n            return \"NO\"\n    return \"YES\"",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 2048,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = list(map(int, stdin.split('\\n')[1].split()))\n    c = list(map(int, stdin.split('\\n')[2].split()))\n\n    min_cost = float('inf')\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            if s[i] < s[j]:\n                for k in range(j + 1, n):\n                    if s[j] < s[k]:\n                        min_cost = min(min_cost, c[i] + c[j] + c[k])\n\n    return str(min_cost) if min_cost != float('inf') else '-1'",
        "test": "",
        "num_ids": 187,
        "indeed": true
    },
    {
        "number": 2049,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    result = []\n\n    for i in range(m):\n        l, r = map(int, stdin.readline().split())\n        subsegment = a[l - 1:r]\n        is_ladder = True\n\n        for i in range(len(subsegment) - 1):\n            if subsegment[i] > subsegment[i + 1]:\n                is_ladder = False\n                break\n\n        if is_ladder:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2050,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def is_valid_set(s: set) -> bool:\n        for i in s:\n            for j in s:\n                if i != j and gcd(i, j) != k:\n                    return False\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    m = 1\n    while True:\n        if n * k <= m:\n            break\n        m += 1\n\n    result = []\n    for _ in range(n):\n        s = set()\n        while len(s) < 4:\n            s.add(m)\n            m += 1\n        while not is_valid_set(s):\n            s.remove(min(s))\n            s.add(m)\n            m += 1\n        result.append(sorted(list(s)))\n\n    output = [str(m)]\n    for s in result:\n        output.append(\" \".join(map(str, s)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 2051,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> List[int]:\n        return list(map(int, stdin.readline().strip().split()))\n\n    n, m, k = read_line()\n    current_colors = read_line()\n    instructions = [read_line() for _ in range(m)]\n\n    # Count the number of socks for each color\n    color_count = [0] * k\n    for color in current_colors:\n        color_count[color - 1] += 1\n\n    # Count the number of socks for each color in the instructions\n    instruction_color_count = [0] * k\n    for l, r in instructions:\n        instruction_color_count[current_colors[l - 1] - 1] += 1\n        instruction_color_count[current_colors[r - 1] - 1] += 1\n\n    # Calculate the minimum number of socks to change colors\n    min_socks_to_change = sum(abs(color_count[i] - instruction_color_count[i]) for i in range(k)) // 2\n\n    return str(min_socks_to_change)",
        "test": "",
        "num_ids": 274,
        "indeed": false
    },
    {
        "number": 2052,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    dp = [0] * w\n    for i in range(w):\n        if i == 0:\n            dp[i] = a[i]\n        elif i < l:\n            dp[i] = dp[i - 1] + a[i]\n        else:\n            dp[i] = max(dp[i - 1], dp[i - l] + a[i])\n    return str(dp[-1])",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 2053,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_sum(arr):\n        return sum(arr)\n\n    def find_min_diff(a, b, k):\n        a_sum = get_sum(a)\n        b_sum = get_sum(b)\n        min_diff = abs(a_sum - b_sum)\n        swaps = []\n\n        for i in range(len(a)):\n            for j in range(len(b)):\n                if k == 0:\n                    break\n                new_a = a.copy()\n                new_b = b.copy()\n                new_a[i], new_b[j] = new_b[j], new_a[i]\n                new_a_sum = get_sum(new_a)\n                new_b_sum = get_sum(new_b)\n                new_diff = abs(new_a_sum - new_b_sum)\n\n                if new_diff < min_diff:\n                    min_diff = new_diff\n                    swaps = [(i + 1, j + 1)]\n                    k -= 1\n                elif new_diff == min_diff and k > 0:\n                    swaps.append((i + 1, j + 1))\n                    k -= 1\n\n        return min_diff, swaps\n\n    n, a, m, b = stdin.split(\"\\n\")\n    n, m = int(n), int(m)\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    min_diff, swaps = find_min_diff(a, b, 2)\n\n    output = [str(min_diff), str(len(swaps))]\n    for swap in swaps:\n        output.append(\" \".join(map(str, swap)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 446,
        "indeed": false
    },
    {
        "number": 2054,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_emeralds(a, b):\n        swords = min(b // 2, a)\n        shovels = min(a // 2, b)\n        return swords + shovels\n\n    cases = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    output = []\n    for a, b in cases[1:]:\n        output.append(str(get_max_emeralds(a, b)))\n    return '\\n'.join(output)\n",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2055,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_coverage(n, a, b):\n        total_coverage = sum(b)\n        for i in range(n):\n            if a[i] > b[i]:\n                return False\n            if i < n - 1:\n                total_coverage -= b[i] + b[i + 1]\n            else:\n                total_coverage -= b[i] + b[0]\n        return total_coverage >= 0\n\n    test_cases = stdin.split('\\n')\n    t = int(test_cases[0])\n    for i in range(1, t + 1):\n        n = int(test_cases[i * 3 - 2])\n        a = list(map(int, test_cases[i * 3 - 1].split()))\n        b = list(map(int, test_cases[i * 3].split()))\n        if check_coverage(n, a, b):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n",
        "test": "",
        "num_ids": 244,
        "indeed": false
    },
    {
        "number": 2056,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x = a[i]\n            y = a[j]\n            a[i] = x & y\n            a[j] = x | y\n\n    return str(sum(map(lambda x: x ** 2, a)))",
        "test": "",
        "num_ids": 117,
        "indeed": true
    },
    {
        "number": 2057,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    t = list(map(int, stdin.split('\\n')[1].split()))\n\n    rooms = set()\n    current_room = 0\n    for i in range(n):\n        if t[i] >= i:\n            rooms.add(current_room)\n            current_room = i\n        else:\n            current_room = t[i]\n\n    rooms.add(current_room)\n    return str(len(rooms))",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 2058,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    n = len(a)\n    m = len(b)\n    total_distance = 0\n\n    for i in range(m - n + 1):\n        distance = 0\n        for j in range(n):\n            if a[j] != b[i + j]:\n                distance += 1\n        total_distance += distance\n\n    return str(total_distance)",
        "test": "",
        "num_ids": 105,
        "indeed": true
    },
    {
        "number": 2059,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    k = 0\n    while True:\n        if all(k * abs(i - j) <= min(a[i], a[j]) for i in range(n) for j in range(n)):\n            k += 1\n        else:\n            break\n\n    return str(k - 1)",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 2060,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1:]))\n    result = []\n    for i in range(n):\n        a = (x[i] // 3)\n        b = (x[i] // 7)\n        if x[i] == a * 3 + b * 7:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 2061,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and not visited[x][y]\n\n    def dfs(x, y):\n        if not is_valid(x, y):\n            return False\n        visited[x][y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(x + dx, y + dy)\n        return True\n\n    n, m, k = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n\n    lakes = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' or visited[i][j]:\n                continue\n            if not (i == 0 or i == n - 1 or j == 0 or j == m - 1):\n                dfs(i, j)\n                lakes.append(sum(row.count('.') for row in grid[1:-1]))\n\n    lakes.sort()\n    min_cells = sum(lakes[:-k])\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and not visited[i][j]:\n                grid[i][j] = '*'\n\n    return f\"{min_cells}\\n{''.join(row)}\\n\" * n",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 2062,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    powers = list(map(int, stdin.split('\\n')[1].split()))\n\n    total_power = sum(powers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if powers[j] % powers[i] == 0:\n                total_power -= powers[j] // powers[i] * powers[i]\n\n    return str(total_power)",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 2063,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort()\n\n    for i in range(m):\n        a[i] += 1\n\n    return str(a[0])",
        "test": "",
        "num_ids": 79,
        "indeed": false
    },
    {
        "number": 2064,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    max_num = 0\n    for i in range(1, 10):\n        num_of_sections = sum(int(digit) for digit in str(i))\n        if num_of_sections <= n:\n            max_num = i\n        else:\n            break\n    return str(max_num)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 2065,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_ancestor(ancestor, descendant):\n        if ancestor == descendant:\n            return True\n        for father, child in relations:\n            if child == descendant and father == ancestor:\n                return True\n            if child == ancestor and father == descendant:\n                return False\n        return False\n\n    def find_candidates(wishes):\n        candidates = []\n        for i, wish in enumerate(wishes):\n            if wish == (i + 1):\n                candidates.append(wish)\n            else:\n                for candidate in candidates:\n                    if is_ancestor(candidate, wish):\n                        break\n                else:\n                    candidates.append(wish)\n        return candidates\n\n    def check_wishes(candidates, wishes):\n        for i, wish in enumerate(wishes):\n            if wish != (i + 1) and not is_ancestor(candidates[i], wish):\n                return False\n        return True\n\n    n, m = map(int, stdin.readline().split())\n    relations = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    wishes = list(map(int, stdin.readline().split()))\n\n    candidates = find_candidates(wishes)\n\n    if check_wishes(candidates, wishes):\n        return f\"{len(candidates)}\\n\" + \"\\n\".join(map(str, candidates))\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 2066,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        s = stdin.readline().strip()\n        if len(s) == 1:\n            result.append(s)\n            continue\n\n        for i in range(len(s) - 1):\n            if abs(ord(s[i]) - ord(s[i + 1])) == 1:\n                s = s[:i] + s[i + 1] + s[i] + s[i + 2:]\n\n        result.append(s)\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 2067,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return False\n        if x1 == x2:\n            return True\n        if y1 == y2:\n            return True\n        return False\n\n    def is_blocked(x1, y1, x2, y2, vertical_spells, horizontal_spells):\n        for v in vertical_spells:\n            if x1 < v <= x2:\n                return True\n        for h in horizontal_spells:\n            if h[0] <= x1 <= x2 <= h[1] and y1 == h[2]:\n                return True\n        return False\n\n    def bfs(start, target, vertical_spells, horizontal_spells):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), depth = queue.pop(0)\n            if (x, y) == target:\n                return depth\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            for v in vertical_spells:\n                if x < v < x + 2:\n                    queue.append(((v - 1, y), depth + 1))\n                    queue.append(((v + 1, y), depth + 1))\n\n            for h in horizontal_spells:\n                if h[0] <= x <= x + 1 <= h[1] and y == h[2]:\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        new_x, new_y = x + dx, y + dy\n                        if 1 <= new_x <= 10**9 and 1 <= new_y < 10**9 and not is_blocked(new_x, new_y, new_x + dx, new_y + dy, vertical_spells, horizontal_spells):\n                            queue.append(((new_x, new_y), depth + 1))\n\n    n, m = map(int, stdin.readline().split())\n    vertical_spells = [int(x) for x in stdin.readline().split()]\n    horizontal_spells = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.readline().split())\n        horizontal_spells.append((x1, x2, y))\n\n    start = (1, 1)\n    target = (1, 10**9)\n    min_spells_to_remove = float('inf')\n\n    for v in vertical_spells:\n        new_vertical_spells = [x for x in vertical_spells if x != v]\n        if not is_valid_move(start[0], start[1], start[0], start[1]) and not is_blocked(start[0], start[1], start[0], start[1], new_vertical_spells, horizontal_spells):\n            min_spells_to_remove = min(min_spells_to_remove, 1)\n        else:\n            depth = bfs(start, target, new_vertical_spells, horizontal_spells)\n            if depth is not None:\n                min_spells_to_remove = min(min_spells_to_remove, 1)\n\n    for h in horizontal_spells:\n        new_horizontal_spells = [x for x in horizontal_spells if x != h]\n        if not is_valid_move(start[0], start[1], start[0], start[1]) and not is_blocked(start[0], start[1], start[0], start[1], vertical_spells, new_horizontal_spells):\n            min_spells_to_remove = min(min_spells_to_remove, 1)\n        else:\n            depth = bfs(start, target, vertical_spells, new_horizontal_spells)\n            if depth is not None:\n                min_spells_to_remove = min(min_spells_to_remove, 1)\n\n    return str(min_spells_to_remove)",
        "test": "",
        "num_ids": 1020,
        "indeed": false
    },
    {
        "number": 2068,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    reposts = {}\n    for _ in range(n):\n        name1, _, name2 = stdin.readline().strip().lower().partition(\"reposted\")\n        if name2 not in reposts:\n            reposts[name2] = set()\n        reposts[name2].add(name1)\n        for chain in reposts.values():\n            if name1 in chain:\n                chain.add(name2)\n    return max(len(chain) for chain in reposts.values())",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2069,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    foe_pairs = set()\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        foe_pairs.add((min(a, b), max(a, b)))\n\n    def is_valid(x: int, y: int) -> bool:\n        for a, b in foe_pairs:\n            if a <= x <= y <= b or a <= y <= x <= b:\n                return False\n        return True\n\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(x, n + 1):\n            if is_valid(x, y):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2070,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    x_values = list(map(int, stdin.readline().split()))\n    s = stdin.readline().strip()\n\n    # Calculate the sum of values of all letters (assigned by A), except for the first and the last one\n    total_sum = sum(x_values[ord(s[i]) - ord('a')] for i in range(1, len(s) - 1))\n\n    # Find the substrings that are interesting to B\n    interesting_substrings = 0\n    for i in range(len(s) - 1):\n        for j in range(i + 2, len(s) + 1):\n            if s[i] == s[j - 1] and total_sum == 0:\n                interesting_substrings += 1\n\n    return str(interesting_substrings)",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 2071,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    dp = [[0, 0] for _ in range(n)]\n    dp[0] = [a[0], b[0]]\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][1] + a[i], dp[i - 1][0] + a[i])\n        dp[i][1] = max(dp[i - 1][0] + b[i], dp[i - 1][1] + b[i])\n\n    return str(max(dp[-1][0], dp[-1][1]))",
        "test": "",
        "num_ids": 209,
        "indeed": false
    },
    {
        "number": 2072,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n    v = list(map(int, stdin.split('\\n')[2].split()))\n\n    max_time = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            time = max(abs(x[i] - x[j]) / v[i], abs(x[i] - x[j]) / v[j])\n            max_time = min(max_time, time)\n\n    return '{:.9f}'.format(max_time)",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 2073,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    mod = 10**9 + 7\n    total = 2**n\n\n    for i in range(1, n):\n        if a[i] == i + 1:\n            total -= 2**(i - 1) * 2**(n - i - 1)\n\n    return str(total % mod)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 2074,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    c = []\n    for _ in range(n):\n        c.append(list(map(int, stdin.readline().split())))\n\n    max_cost = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(n):\n                if i != k:\n                    max_cost = max(max_cost, min(c[i][j], c[k][j]))\n\n    for j in range(m):\n        for i in range(n):\n            for k in range(m):\n                if j != k:\n                    max_cost = max(max_cost, min(c[i][j], c[i][k]))\n\n    return str(max_cost)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 2075,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    MOD = 10**9 + 7\n\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for bracket in brackets:\n            if bracket == '(':\n                stack.append(bracket)\n            else:\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def count_valid_pairs(s: str, n: int, m: int) -> int:\n        total_pairs = 0\n        for i in range(m, n + 1):\n            for j in range(i - m + 1):\n                p = '(' * j\n                q = ')' * (i - j - m)\n                if is_valid(p + s + q):\n                    total_pairs += 1\n        return total_pairs\n\n    return str(count_valid_pairs(s, n, m))",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 2076,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_stones(a, b, c):\n        if a == 0:\n            return 0\n        if b == 0:\n            return 0\n        if c == 0:\n            return 0\n\n        stones = 0\n        while a >= 1 and b >= 2 and c >= 2:\n            stones += 2\n            a -= 1\n            b -= 2\n            c -= 2\n\n        while b >= 1 and c >= 2:\n            stones += 1\n            b -= 1\n            c -= 2\n\n        return stones\n\n    t = int(stdin.split('\\n')[0])\n    test_cases = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    results = [get_max_stones(*test_case) for test_case in test_cases]\n\n    return '\\n'.join(map(str, results))",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 2077,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> str:\n        return stdin.readline().strip()\n\n    def read_int() -> int:\n        return int(read_line())\n\n    def read_ints() -> List[int]:\n        return list(map(int, read_line().split()))\n\n    n, m = read_ints()\n    graph = defaultdict(set)\n    for _ in range(m):\n        a, b = read_ints()\n        graph[a].add(b)\n        graph[b].add(a)\n\n    desired_topics = read_ints()\n\n    def is_valid(order: List[int]) -> bool:\n        used_topics = defaultdict(set)\n        for blog_id in order:\n            available_topics = set(range(1, n + 1)) - used_topics[blog_id]\n            if not available_topics:\n                return False\n            chosen_topic = min(available_topics)\n            used_topics[blog_id].add(chosen_topic)\n            for neighbor in graph[blog_id]:\n                used_topics[neighbor].add(chosen_topic)\n        return True\n\n    for order in permutations(range(1, n + 1)):\n        if is_valid(order):\n            return \" \".join(map(str, order))\n    return \"-1\"",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 2078,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    horizontal_segments = []\n    vertical_segments = []\n\n    for _ in range(n):\n        y, lx, rx = map(int, stdin.readline().split())\n        horizontal_segments.append((y, lx, rx))\n\n    for _ in range(m):\n        x, ly, ry = map(int, stdin.readline().split())\n        vertical_segments.append((x, ly, ry))\n\n    horizontal_segments.sort()\n    vertical_segments.sort()\n\n    pieces = 1\n    prev_y = 0\n    prev_x = 0\n\n    for segment in horizontal_segments:\n        y, lx, rx = segment\n        pieces *= y - prev_y\n        prev_y = y\n\n        if lx > prev_x:\n            pieces += 1\n        prev_x = rx\n\n    for segment in vertical_segments:\n        x, ly, ry = segment\n        pieces *= x - prev_x\n        prev_x = x\n\n        if ly > prev_y:\n            pieces += 1\n        prev_y = ry\n\n    if prev_y < 10**6:\n        pieces *= 10**6 - prev_y\n        pieces += 1\n\n    if prev_x < 10**6:\n        pieces *= 10**6 - prev_x\n        pieces += 1\n\n    return str(pieces)",
        "test": "",
        "num_ids": 372,
        "indeed": false
    },
    {
        "number": 2079,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    seats = list(map(int, stdin.readline().strip().split()))\n    passengers = stdin.readline().strip()\n\n    rows = [0] * n\n    introverts = [i for i, p in enumerate(passengers) if p == '0']\n    extroverts = [i for i, p in enumerate(passengers) if p == '1']\n\n    for i in introverts:\n        min_width = min(seats)\n        row = seats.index(min_width)\n        rows[row] = i + 1\n        seats[row] = float('inf')\n\n    for i in extroverts:\n        max_width = max(seats)\n        row = seats.index(max_width)\n        rows[row] = i + 1\n        seats[row] = float('-inf')\n\n    return ' '.join(map(str, rows))",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 2080,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    n = [int(x) for x in stdin.split('\\n')[1:]]\n    result = []\n\n    for i in range(q):\n        edges = n[i] * (n[i] - 1) // 2\n        bridges = edges // 2\n        result.append(edges - bridges)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 2081,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    imbalance_value = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            imbalance_value += max(a[i:j + 1]) - min(a[i:j + 1])\n\n    return str(imbalance_value)",
        "test": "",
        "num_ids": 111,
        "indeed": true
    },
    {
        "number": 2082,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_animal(p, q, a, roads):\n        visited = [False] * (len(a) + 1)\n        stack = [(p, 0)]\n        min_animal = float('inf')\n\n        while stack:\n            curr, depth = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                if curr == q:\n                    min_animal = min(min_animal, depth)\n                else:\n                    for neighbor in roads[curr]:\n                        if not visited[neighbor]:\n                            stack.append((neighbor, depth + min(a[curr], a[neighbor])))\n\n        return min_animal\n\n    def find_f(p, q, a, roads):\n        return find_min_animal(p, q, a, roads) + find_min_animal(q, p, a, roads)\n\n    def find_average_f(n, m, a, roads):\n        total_f = 0\n        count = 0\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j:\n                    total_f += find_f(i, j, a, roads)\n                    count += 1\n\n        return total_f / count\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    roads = [[] for _ in range(n + 1)]\n\n    for i in range(m):\n        x, y = map(int, lines[i + 2].split())\n        roads[x].append(y)\n        roads[y].append(x)\n\n    average_f = find_average_f(n, m, a, roads)\n    return f\"{average_f:.6f}\"",
        "test": "",
        "num_ids": 472,
        "indeed": false
    },
    {
        "number": 2083,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_mean(a_t: int, mean: float, c: float) -> float:\n        return (mean + a_t / T) / c\n\n    def calculate_exact_mean(a_t: int, p_j: int, T: int) -> float:\n        return sum(a_t[p_j - T + 1:p_j + 1]) / T\n\n    def relative_error(approx: float, real: float) -> float:\n        return abs(approx - real) / real\n\n    lines = stdin.splitlines()\n    n, T, c = map(float, lines[0].split())\n    a_t = list(map(int, lines[1].split()))\n    m = int(lines[2])\n    p_j = list(map(int, lines[3].split()))\n\n    mean = 0.0\n    result = []\n\n    for j in range(m):\n        exact_mean = calculate_exact_mean(a_t, p_j[j], T)\n        approx_mean = calculate_mean(a_t[p_j[j]], mean, c)\n        error = relative_error(approx_mean, exact_mean)\n\n        result.append(f\"{exact_mean:.5f} {approx_mean:.5f} {error:.5f}\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 2084,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort()\n\n    count = 0\n    for i in range(n - k + 1):\n        count += a[i + k - 1] - a[i]\n\n    return str(count)",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 2085,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def bit_count(x: int, i: int) -> int:\n        return bin(x).count(str(i))\n\n    def subsequence_value(k: int) -> int:\n        return sum(2**i for i in range(31) if bit_count(k, i) >= max(1, k - 2))\n\n    max_value = 0\n    for k in range(1, n + 1):\n        max_value = max(max_value, subsequence_value(k))\n\n    return str(max_value)",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 2086,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, s, f = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    max_participants = 0\n    result = 0\n\n    for i in range(s, f):\n        participants = sum([a[j] for j in range(1, n + 1) if i - j >= 0 and i - j <= n])\n        if participants > max_participants:\n            max_participants = participants\n            result = i\n\n    return str(result)",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2087,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    result = 0\n    for a in range(1, A + 1):\n        for b in range(1, B + 1):\n            for c in range(1, C + 1):\n                result += a * b * c\n    return str(result % 998244353)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 2088,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, colors):\n        if node not in visited:\n            visited.add(node)\n            for child in tree[node]:\n                if child != parent:\n                    dfs(child, node, colors)\n            subtree_colors = set()\n            for child in tree[node]:\n                if child != parent:\n                    subtree_colors.add(colors[child])\n            if len(subtree_colors) == len(tree[node]) - 1:\n                happy.add(node)\n\n    def find_min_colors(k):\n        colors_count = 0\n        while len(happy) < k:\n            colors_count += 1\n            for node in range(1, n + 1):\n                if node not in visited:\n                    dfs(node, None, [colors_count - 1] * n)\n        return colors_count\n\n    n = int(stdin.readline().strip())\n    tree = {i: set() for i in range(1, n + 1)}\n    for i, parent in enumerate(map(int, stdin.readline().strip().split())):\n        tree[parent].add(i + 2)\n        tree[i + 2].add(parent)\n\n    visited = set()\n    happy = set()\n    result = [0] * n\n    for i in range(1, n + 1):\n        result[i - 1] = find_min_colors(i)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 367,
        "indeed": false
    },
    {
        "number": 2089,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    adj_list = [[] for _ in range(n)]\n\n    for u, v in roads:\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    visited = [False] * n\n    distances = [0] * n\n    queue = [s - 1]\n\n    while queue:\n        current = queue.pop(0)\n        if not visited[current]:\n            visited[current] = True\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    distances[neighbor] = distances[current] + 1\n                    queue.append(neighbor)\n\n    not_connected = 0\n    for u in range(n):\n        for v in range(n):\n            if u != v and v not in adj_list[u]:\n                if distances[u] + 1 < distances[v]:\n                    not_connected += 1\n\n    return str(not_connected)",
        "test": "",
        "num_ids": 299,
        "indeed": false
    },
    {
        "number": 2090,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    songs = []\n    for _ in range(n):\n        t, b = map(int, stdin.readline().split())\n        songs.append((t, b))\n\n    songs.sort(key=lambda x: (x[0] * x[1], x[1]))\n\n    max_pleasure = 0\n    for i in range(k):\n        max_pleasure += songs[i][0]\n    max_pleasure *= songs[k - 1][1]\n\n    return str(max_pleasure)",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 2091,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_longest_palindrome(s: str) -> str:\n        longest_palindrome = \"\"\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                if is_palindrome(substring) and substring in s:\n                    if len(substring) > len(longest_palindrome):\n                        longest_palindrome = substring\n        return longest_palindrome\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        longest_palindrome = find_longest_palindrome(s)\n        result.append(longest_palindrome)\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 233,
        "indeed": false
    },
    {
        "number": 2092,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(soldiers, traps, location):\n        for trap in traps:\n            if trap[0] == location and any(soldier.agility < trap[2] for soldier in soldiers):\n                return False\n        return True\n\n    def disarm_traps(traps, location):\n        for i, trap in enumerate(traps):\n            if trap[1] == location:\n                traps.pop(i)\n                return\n\n    def move(soldiers, traps, location, squad_location, time_left):\n        if time_left < 0:\n            return False\n        if location == n + 1:\n            return True\n        if squad_location == location and is_safe(soldiers, traps, location):\n            for i in range(max(0, location - 1), min(location + 2, n + 1)):\n                if move(soldiers, traps, i, i, time_left - 1):\n                    return True\n        else:\n            for i in range(max(0, location - 1), min(location + 2, n + 1)):\n                if i == location:\n                    continue\n                if move(soldiers, traps, i, squad_location, time_left - 1):\n                    return True\n        return False\n\n    stdin_list = stdin.split('\\n')\n    m, n, k, t = map(int, stdin_list[0].split())\n    a = list(map(int, stdin_list[1].split()))\n    traps = [list(map(int, stdin_list[i + 2].split())) for i in range(k)]\n\n    soldiers = [Soldier(agility) for agility in a]\n    max_soldiers = 0\n\n    for i in range(1, m + 1):\n        for combo in itertools.combinations(soldiers, i):\n            if any(soldier.agility < trap[2] for trap in traps for soldier in combo):\n                continue\n            if move(combo, traps.copy(), 0, 0, t):\n                max_soldiers = max(max_soldiers, len(combo))\n\n    return str(max_soldiers)\n\nclass Soldier:\n    def __init__(self, agility):\n        self.agility = agility",
        "test": "",
        "num_ids": 577,
        "indeed": false
    },
    {
        "number": 2093,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                count += 1\n            elif a[i] < a[j]:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 2094,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    h = list(map(int, stdin.readline().split()))\n    mod = 998244353\n\n    def shift_answers(answers):\n        shifted_answers = [0] * n\n        for i in range(n):\n            shifted_answers[i] = answers[(i + 1) % n]\n        return shifted_answers\n\n    def count_points(answers):\n        points = 0\n        for i in range(n):\n            if answers[i] == h[i]:\n                points += 1\n        return points\n\n    total_answer_suits = k ** n\n    valid_answer_suits = 0\n\n    for i in range(total_answer_suits):\n        answers = [i // (k ** j) % k + 1 for j in range(n)]\n        shifted_answers = shift_answers(answers)\n        if count_points(answers) < count_points(shifted_answers):\n            valid_answer_suits += 1\n\n    return str(valid_answer_suits % mod)",
        "test": "",
        "num_ids": 288,
        "indeed": false
    },
    {
        "number": 2095,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, stdin.readline().split())))\n\n    good_cars = []\n    for i in range(n):\n        is_good = True\n        for j in range(n):\n            if matrix[i][j] == 1 or matrix[i][j] == 2:\n                is_good = False\n                break\n        if is_good:\n            good_cars.append(i + 1)\n\n    return f\"{len(good_cars)}\\n{' '.join(map(str, sorted(good_cars)))}\"",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2096,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cubes = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def get_four_digit_numbers(heap1, heap2):\n        four_digit_numbers = set()\n        for cube1 in heap1:\n            for cube2 in heap2:\n                four_digit_numbers.add(cube1 * 100 + cube2)\n        return four_digit_numbers\n\n    max_four_digit_numbers = 0\n    max_heap_split = []\n\n    for i in range(1, n + 1):\n        heap1 = cubes[:i]\n        heap2 = cubes[i:]\n        four_digit_numbers = len(get_four_digit_numbers(heap1, heap2))\n\n        if four_digit_numbers > max_four_digit_numbers:\n            max_four_digit_numbers = four_digit_numbers\n            max_heap_split = [1] * i + [2] * (2 * n - i)\n\n    return f\"{max_four_digit_numbers}\\n{' '.join(map(str, max_heap_split))}\"",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2097,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: List[int]) -> bool:\n        s = sum(a)\n        p = 1\n        for x in a:\n            p *= x\n        return s != 0 and p != 0\n\n    def min_steps(a: List[int]) -> int:\n        if is_valid(a):\n            return 0\n        steps = 0\n        while sum(a) == 0 or all(x < 0 for x in a):\n            a = [x + 1 for x in a]\n            steps += 1\n        return steps\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        output.append(min_steps(a))\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 2098,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    n = int(stdin.readline().strip())\n    pairs = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        pairs.append((a, b))\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    edges = []\n\n    for a, b in pairs:\n        if union(parent, rank, a, b):\n            edges.append((find(parent, a), find(parent, b)))\n\n    if len(edges) == n - 1:\n        return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, edge)) for edge in edges)\n    else:\n        return \"NO\"\n",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 2099,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_time(time_str):\n        h, m, s = map(int, time_str.split(':'))\n        return h * 3600 + m * 60 + s\n\n    def format_time(seconds):\n        h, seconds = divmod(seconds, 3600)\n        m, seconds = divmod(seconds, 60)\n        return f\"{h:02d}:{m:02d}:{seconds:02d}\"\n\n    def find_max_users(n, M, T, times):\n        times = [parse_time(t) for t in times]\n        times.sort()\n        users = set()\n        max_users = 0\n        current_users = set()\n\n        for time in times:\n            current_users.add(time)\n            while len(current_users) > M:\n                current_users.remove(min(current_users))\n            max_users = max(max_users, len(current_users))\n\n        return max_users\n\n    def assign_user_ids(n, M, T, times):\n        times = [parse_time(t) for t in times]\n        times.sort()\n        users = set()\n        user_ids = {}\n        current_users = set()\n\n        for time in times:\n            if time not in user_ids:\n                users.add(time)\n                current_users.add(time)\n                while len(current_users) > M:\n                    current_users.remove(min(current_users))\n                user_ids[time] = len(users)\n            yield user_ids[time]\n\n    input_data = stdin.split('\\n')\n    n, M, T = map(int, input_data[0].split())\n    times = input_data[1:]\n\n    max_users = find_max_users(n, M, T, times)\n    if max_users > M:\n        return \"No solution\"\n    else:\n        user_ids = assign_user_ids(n, M, T, times)\n        return '\\n'.join(map(str, user_ids))",
        "test": "",
        "num_ids": 516,
        "indeed": false
    },
    {
        "number": 2100,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    left_doors = []\n    right_doors = []\n\n    for i in range(n):\n        l, r = map(int, stdin.readline().split())\n        left_doors.append(l)\n        right_doors.append(r)\n\n    t = 0\n    if sum(left_doors) % 2 == 1:\n        t += 1\n    if sum(right_doors) % 2 == 1:\n        t += 1\n\n    return str(t)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2101,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B = map(int, stdin.split())\n    r_sticks = list(map(int, input().split()))\n    g_sticks = list(map(int, input().split()))\n    b_sticks = list(map(int, input().split()))\n\n    r_sticks.sort(reverse=True)\n    g_sticks.sort(reverse=True)\n    b_sticks.sort(reverse=True)\n\n    total_area = 0\n    for i in range(R):\n        for j in range(G):\n            for k in range(B):\n                if i != j and j != k and k != i:\n                    total_area += r_sticks[i] * g_sticks[j]\n                    total_area += r_sticks[i] * b_sticks[k]\n                    total_area += g_sticks[j] * b_sticks[k]\n\n    return str(total_area)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 2102,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(int, stdin.split()))\n    a = input_data[0:6]\n    n = input_data[6]\n    b = input_data[7:]\n\n    # Calculate the difference\n    max_diff = float('-inf')\n    min_diff = float('inf')\n\n    for note in b:\n        for i in range(6):\n            if note >= a[i]:\n                fret = note - a[i]\n                max_diff = max(max_diff, fret)\n                min_diff = min(min_diff, fret)\n\n    return str(max_diff - min_diff)",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 2103,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if any(a[i] > i for i in range(n)):\n        return \"-1\"\n\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n        for j in range(i):\n            if b[j] >= a[i]:\n                b[j] += 1\n\n    return \" \".join(map(str, b))",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 2104,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    pairs = []\n\n    if (r - l + 1) % 2 != 0:\n        return \"NO\"\n\n    for i in range(l, r + 1, 2):\n        if i == l:\n            pairs.append((i, i + 1))\n        elif i == r:\n            pairs.append((i, i - 1))\n        else:\n            pairs.append((i, i + 1))\n            pairs.append((i, i - 1))\n\n    return \"YES\\n\" + \"\\n\".join(f\"{pair[0]} {pair[1]}\" for pair in pairs)\n",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2105,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().split()\n    t = stdin.readline().split()\n    q = int(stdin.readline())\n    year_names = []\n\n    for i in range(q):\n        year = int(stdin.readline())\n        name = \"\"\n        for j in range(year):\n            if j % (n + m) < n:\n                name += s[j % n]\n            else:\n                name += t[j % m]\n        year_names.append(name)\n\n    return year_names\n",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 2106,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.readline().split())\n    d = list(map(int, stdin.readline().split()))\n    s = list(map(int, stdin.readline().split()))\n\n    total_time = 0\n    fuel = s[0]\n    current_city = 0\n\n    while current_city < len(d):\n        if fuel < d[current_city]:\n            fuel += s[current_city]\n            total_time += k * 60\n        total_time += d[current_city] * 60\n        fuel -= d[current_city]\n        current_city += 1\n\n    return str(total_time)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2107,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split('\\n')[0].split())\n    guitar = [list(map(int, stdin.split('\\n')[i].split())) for i in range(1, n + 1)]\n    song = list(map(int, stdin.split('\\n')[-1].split()))\n\n    def get_complexity(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    max_complexity = 0\n    for i in range(s - 1):\n        for j in range(i + 1, s):\n            complexity = get_complexity(*guitar[song[i] - 1], *guitar[song[j] - 1])\n            max_complexity = max(max_complexity, complexity)\n\n    return str(max_complexity)",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 2108,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(labels: List[int]) -> bool:\n        for i in range(len(labels)):\n            for j in range(i + 1, len(labels)):\n                if abs(labels[i] - labels[j]) != 1:\n                    return False\n        return True\n\n    def backtrack(start: int, labels: List[int], used: List[int]) -> bool:\n        if start == len(labels):\n            return True\n\n        for label in range(1, 4):\n            if used[label] < labels[start]:\n                labels[start] = label\n                used[label] += 1\n                if is_valid(labels) and backtrack(start + 1, labels, used):\n                    return True\n                used[label] -= 1\n                labels[start] = 0\n\n        return False\n\n    n, m = map(int, stdin.readline().split())\n    n1, n2, n3 = map(int, stdin.readline().split())\n    edges = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    labels = [0] * n\n    used = [0, 0, 0]\n    used[1] = n1\n    used[2] = n2\n    used[3] = n3\n\n    if backtrack(0, labels, used):\n        return \"YES\\n\" + \"\".join(map(str, labels))\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 362,
        "indeed": false
    },
    {
        "number": 2109,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    first_set = []\n    second_set = []\n    third_set = []\n\n    for num in arr:\n        if num < 0:\n            first_set.append(num)\n        elif num > 0:\n            second_set.append(num)\n        else:\n            third_set.append(num)\n\n    return f\"{len(first_set)} {' '.join(str(x) for x in first_set)}\\n{len(second_set)} {' '.join(str(x) for x in second_set)}\\n{len(third_set)} {' '.join(str(x) for x in third_set)}\\n\"",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 2110,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_t(n, h, m, k, h_i, m_i):\n        canceled_trains = []\n        min_canceled_trains = float('inf')\n        optimal_t = -1\n\n        for t in range(k):\n            canceled_trains_count = 0\n            for i in range(n):\n                if h_i[i] == 0 and m_i[i] < t:\n                    canceled_trains_count += 1\n\n            if canceled_trains_count < min_canceled_trains:\n                min_canceled_trains = canceled_trains_count\n                optimal_t = t\n\n        return min_canceled_trains, optimal_t\n\n    def main():\n        lines = stdin.split('\\n')\n        params = list(map(int, lines[0].split()))\n        n, h, m, k = params\n        h_i = []\n        m_i = []\n\n        for i in range(1, n + 1):\n            train_params = list(map(int, lines[i].split()))\n            h_i.append(train_params[0])\n            m_i.append(train_params[1])\n\n        min_canceled_trains, optimal_t = find_optimal_t(n, h, m, k, h_i, m_i)\n        canceled_trains = []\n\n        for i in range(n):\n            if h_i[i] == 0 and m_i[i] < optimal_t:\n                canceled_trains.append(i + 1)\n\n        return f\"{min_canceled_trains} {optimal_t}\\n{len(canceled_trains)} {' '.join(map(str, canceled_trains))}\\n\"\n\n    return main()",
        "test": "",
        "num_ids": 467,
        "indeed": false
    },
    {
        "number": 2111,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    chocolate_bar = [[1] * n for _ in range(n)]\n    for _ in range(q):\n        x, y, direction = stdin.readline().split()\n        x, y = int(x), int(y)\n        if direction == 'U':\n            for i in range(y - 1, -1, -1):\n                if sum(chocolate_bar[i]) == 0:\n                    break\n                eaten_pieces = sum(chocolate_bar[i])\n                chocolate_bar[i] = [0] * n\n                print(eaten_pieces)\n        elif direction == 'L':\n            for i in range(x - 1, -1, -1):\n                if chocolate_bar[y - 1][i] == 0:\n                    break\n                eaten_pieces = i + 1\n                for j in range(y - 1, -1, -1):\n                    chocolate_bar[j][i] = 0\n                print(eaten_pieces)\n\n    return \"\"",
        "test": "",
        "num_ids": 280,
        "indeed": false
    },
    {
        "number": 2112,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, k, y = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    def berserk(a, i, j):\n        if a[i] > a[j]:\n            a.pop(j)\n        else:\n            a.pop(i)\n        return a\n\n    def fireball(a, i, j):\n        a = a[:i] + a[i + j + 1:]\n        return a\n\n    def is_equal(a, b):\n        if len(a) != len(b):\n            return False\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                return False\n        return True\n\n    def find_subsequence(a, b):\n        for i in range(len(a) - len(b) + 1):\n            if is_equal(a[i:i + len(b)], b):\n                return i\n        return -1\n\n    mana = 0\n    while not is_equal(a, b):\n        index = find_subsequence(a, b)\n        if index != -1:\n            mana += x * (len(b) - 1)\n            a = fireball(a, index, len(b) - 1)\n        else:\n            for i in range(len(a) - 1):\n                if a[i] != a[i + 1]:\n                    mana += y\n                    a = berserk(a, i, i + 1)\n                    break\n            else:\n                return -1\n\n    return mana",
        "test": "",
        "num_ids": 430,
        "indeed": false
    },
    {
        "number": 2113,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [(int(x[0]), int(x[1])) for x in [line.split() for line in stdin.split('\\n')[1:n-1]]]\n    nodes = set([x[0] for x in edges] + [x[1] for x in edges])\n    if len(nodes) != n:\n        return \"0\"\n    for i in range(1, n+1):\n        if i not in nodes:\n            return \"0\"\n    visited = set()\n    def dfs(node, color):\n        visited.add(node)\n        for neighbor in [x[1] if x[0] == node else x[0] for x in edges if node in x]:\n            if neighbor not in visited:\n                if dfs(neighbor, not color):\n                    return True\n            elif neighbor in visited and color == (node in [x[0] for x in edges if x[1] == neighbor]):\n                return True\n        return False\n    ans = 0\n    for node in nodes:\n        if node not in visited:\n            if dfs(node, True):\n                ans += 1\n    return str(ans)",
        "test": "",
        "num_ids": 290,
        "indeed": false
    },
    {
        "number": 2114,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[int]]) -> bool:\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] != i * N + j + 1:\n                    return False\n        return True\n\n    def find_min(board: List[List[int]], visited: List[int]) -> int:\n        min_value = float('inf')\n        min_index = -1\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] != -1 and visited[board[i][j] - 1] == 0 and board[i][j] < min_value:\n                    min_value = board[i][j]\n                    min_index = i * N + j\n        return min_index\n\n    def rook_move(board: List[List[int]], visited: List[int]) -> int:\n        vuns = 0\n        i, j = 0, 0\n        while i < N and j < N:\n            if board[i][j] != -1 and visited[board[i][j] - 1] == 0:\n                vuns += 1\n                visited[board[i][j] - 1] = 1\n                i, j = 0, 0\n            else:\n                i += 1\n                if i == N:\n                    i = 0\n                    j += 1\n        return vuns\n\n    def queen_move(board: List[List[int]], visited: List[int]) -> int:\n        vuns = 0\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] != -1 and visited[board[i][j] - 1] == 0:\n                    vuns += 1\n                    visited[board[i][j] - 1] = 1\n        return vuns\n\n    N = int(stdin.strip())\n    if N == 1:\n        return -1\n\n    board = [[i * N + j + 1 for j in range(N)] for i in range(N)]\n    visited = [0] * (N * N)\n\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 1:\n                visited[0] = 1\n                break\n\n    while not is_valid(board):\n        min_index = find_min(board, visited)\n        if min_index == -1:\n            return -1\n        i, j = divmod(min_index, N)\n        board[i][j] = -1\n        rook_vuns = rook_move(board, visited)\n        queen_vuns = queen_move(board, visited)\n        if rook_vuns < queen_vuns:\n            return '\\n'.join(' '.join(str(x) for x in row) for row in board)\n        else:\n            board[i][j] = min_index + 1\n            visited[min_index] = 0\n\n    return -1",
        "test": "",
        "num_ids": 745,
        "indeed": false
    },
    {
        "number": 2115,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    i = 0\n    while i < len(a) - 1:\n        if a[i] == a[i + 1]:\n            j = i + 2\n            while j < len(a) and a[j] == a[i]:\n                j += 1\n            a.pop(j - 1)\n            a.pop(i)\n            a.insert(i, a[i] + 1)\n        else:\n            i += 1\n\n    return f\"{len(a)}\\n{' '.join(map(str, a))}\"",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 2116,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    total_time = 0\n\n    for i in range(n):\n        order = list(map(int, stdin.readline().split()))\n        time_taken = 0\n\n        for j in range(m):\n            item = order[j]\n            pos = p.index(item)\n            time_taken += pos\n            p.insert(0, p.pop(pos))\n\n        total_time += time_taken\n\n    return str(total_time)",
        "test": "",
        "num_ids": 155,
        "indeed": false
    },
    {
        "number": 2117,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, edges = parse_input(stdin)\n    return \" \".join(str(max_planets(N, edges, k)) for k in range(1, N + 1))\n\ndef",
        "test": "",
        "num_ids": 49,
        "indeed": false
    },
    {
        "number": 2118,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if k > n * (n - 1) // 2:\n        return \"-1\"\n\n    a = list(range(1, n + 1))\n    for i in range(k):\n        a[i], a[i + 1] = a[i + 1], a[i]\n\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 2119,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, l, r = map(int, stdin.split())\n    MOD = 998244353\n\n    def is_beautiful(partition: str) -> bool:\n        return partition[0] != '0'\n\n    def generate_partitions(number: int, lower_bound: int, upper_bound: int) -> int:\n        dp = [[0] * (upper_bound + 1) for _ in range(number + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, number + 1):\n            for j in range(lower_bound, upper_bound + 1):\n                for k in range(1, j + 1):\n                    if i - k >= 0 and j - k >= 0:\n                        dp[i][j] += dp[i - k][j - k]\n                        dp[i][j] %= MOD\n\n        return dp[number][upper_bound]\n\n    beautiful_partitions = generate_partitions(a, l, r)\n\n    for i in range(1, l):\n        beautiful_partitions -= generate_partitions(a, i, r)\n        beautiful_partitions %= MOD\n\n    return str(beautiful_partitions)",
        "test": "",
        "num_ids": 314,
        "indeed": false
    },
    {
        "number": 2120,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    v = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    visited = [False] * (n + 1)\n    energy = [0] * (n + 1)\n\n    def dfs(node: int) -> int:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                energy[neighbor] += v[node - 1]\n                dfs(neighbor)\n\n    dfs(1)\n    return str(sum(energy[1:]))",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 2121,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited, depth):\n        if depth >= k:\n            return float('inf')\n        if node in visited:\n            return 0\n        visited.add(node)\n        min_a = float('inf')\n        for neighbor in graph[node]:\n            min_a = min(min_a, dfs(neighbor, visited, depth + 1))\n        return min(min_a, a[node - 1])\n\n    return str(max(dfs(i, set(), 1) for i in range(1, n + 1)))",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 2122,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    book_requests = list(map(int, stdin.split()[2:]))\n    book_requests = [book_requests[i % n] for i in range(k)]\n    book_count = {}\n    max_count = 0\n\n    for book in book_requests:\n        if book in book_count:\n            book_count[book] += 1\n        else:\n            book_count[book] = 1\n\n        if book_count[book] > max_count:\n            max_count = book_count[book]\n\n    return str(max_count)",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 2123,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *heights = map(int, stdin.split())\n    energy = 0\n    dollars_paid = 0\n\n    for i in range(n):\n        if energy < 0:\n            dollars_paid += -energy + 1\n            energy += -energy + 1\n\n        energy += heights[i] - heights[i] + 1\n\n    return str(dollars_paid)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 2124,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_mentioned(username, text):\n        return ' ' + username.lower() + ' ' in text.lower()\n\n    def recover_senders(messages):\n        result = []\n        prev_sender = None\n        for message in messages:\n            sender, text = message.split(':', 1)\n            if sender == '?':\n                if prev_sender is not None:\n                    result.append(prev_sender + ':' + text)\n                else:\n                    return None\n            else:\n                if prev_sender is not None and prev_sender != sender:\n                    result.append(prev_sender + ':' + text)\n                result.append(sender + ':' + text)\n                if is_mentioned(sender, text):\n                    return None\n                prev_sender = sender\n        return result\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        usernames = stdin.readline().split()\n        m = int(stdin.readline())\n        messages = [stdin.readline().strip() for _ in range(m)]\n\n        recovered_messages = recover_senders(messages)\n        if recovered_messages is None:\n            result.append(\"Impossible\")\n        else:\n            result.extend(recovered_messages)\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 2125,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    colors = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid_flag(top, middle, bottom):\n        return (top != middle) and (middle != bottom)\n\n    def count_flags(row, col):\n        flags = 0\n        for i in range(row - 2):\n            for j in range(col - 2):\n                if is_valid_flag(colors[i][j], colors[i + 1][j], colors[i + 2][j]):\n                    flags += 1\n        return flags\n\n    total_flags = 0\n    for i in range(n - 2):\n        for j in range(m - 2):\n            if is_valid_flag(colors[i][j], colors[i][j + 1], colors[i][j + 2]):\n                total_flags += count_flags(i + 3, j + 3)\n\n    return str(total_flags)",
        "test": "",
        "num_ids": 255,
        "indeed": false
    },
    {
        "number": 2126,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.readline().split())\n    front_view = list(map(int, stdin.readline().split()))\n    left_view = list(map(int, stdin.readline().split()))\n    top_view = []\n    for i in range(n):\n        top_view.append(list(map(int, stdin.readline().split())))\n\n    # Initialize the toy bricks matrix\n    toy_bricks = [[0 for _ in range(m)] for _ in range(n)]\n\n    # Fill the toy bricks matrix based on the front view\n    for j in range(m):\n        max_height = front_view[j]\n        for i in range(n):\n            if max_height > 0:\n                toy_bricks[i][j] = max_height\n                max_height -= 1\n\n    # Fill the toy bricks matrix based on the left view\n    for i in range(n):\n        max_height = left_view[i]\n        for j in range(m):\n            if max_height > 0:\n                toy_bricks[i][j] = max_height\n                max_height -= 1\n\n    # Fill the toy bricks matrix based on the top view\n    for i in range(n):\n        for j in range(m):\n            if top_view[i][j] == 1 and toy_bricks[i][j] == 0:\n                toy_bricks[i][j] = 1\n\n    # Output the toy bricks matrix\n    output = \"\"\n    for i in range(n):\n        for j in range(m):\n            output += str(toy_bricks[i][j]) + \" \"\n        output += \"\\n\"\n\n    return output",
        "test": "",
        "num_ids": 441,
        "indeed": false
    },
    {
        "number": 2127,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    bills = []\n    for i in range(n):\n        query = queries[i].split(' ')\n        if query[0] == '+':\n            bills.append((int(query[1]), int(query[2])))\n        elif query[0] == '?':\n            h, w = int(query[1]), int(query[2])\n            fits = True\n            for bill in bills:\n                if not (bill[0] <= h and bill[1] <= w) and not (bill[1] <= h and bill[0] <= w):\n                    fits = False\n                    break\n            print(\"YES\" if fits else \"NO\")",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 2128,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n    dp = [0] * (n + 1)\n    dp[1] = 100 - p[0]\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] * (100 - p[i - 1]) + dp[i - 1] * p[i - 1]\n    return str(dp[n])",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2129,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited):\n        if start not in visited:\n            visited.add(start)\n            for neighbor in graph[start]:\n                dfs(graph, neighbor, visited)\n            return True\n        return False\n\n    def is_valid(graph, n):\n        visited = set()\n        for i in range(1, n + 1):\n            if dfs(graph, i, visited):\n                visited = set()\n            else:\n                return False\n        return True\n\n    def create_graph(roads, n):\n        graph = {i: [] for i in range(1, n + 1)}\n        for road in roads:\n            u, v = map(int, road.split())\n            graph[u].append(v)\n        return graph\n\n    def orient_roads(graph, n):\n        roads = []\n        for i in range(1, n + 1):\n            for j in graph[i]:\n                roads.append(f\"{i} {j}\\n\")\n        return roads\n\n    t = int(stdin.readline())\n    output = []\n\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        roads = [stdin.readline().strip() for _ in range(m)]\n        graph = create_graph(roads, n)\n\n        if is_valid(graph, n):\n            output.append(str(n))\n            output.extend(orient_roads(graph, n))\n        else:\n            output.append(\"0\")\n\n    return \"\\n\".join(output) + \"\\n\" ",
        "test": "",
        "num_ids": 392,
        "indeed": false
    },
    {
        "number": 2130,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_increasing(sequence: List[int]) -> bool:\n        for i in range(1, len(sequence)):\n            if sequence[i] <= sequence[i - 1]:\n                return False\n        return True\n\n    def find_permutation(b: List[int]) -> List[int]:\n        n = len(b)\n        a = [0] * n\n        a[0] = b[0]\n\n        for i in range(1, n):\n            a[i] = b[i] ^ a[i - 1]\n\n        for perm in permutations(b):\n            if is_increasing(a):\n                return list(perm)\n\n        return None\n\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"Yes\\n\" + str(b[0])\n\n    permutation = find_permutation(b)\n\n    if permutation:\n        return \"Yes\\n\" + \" \".join(map(str, permutation))\n    else:\n        return \"No\"\n",
        "test": "",
        "num_ids": 280,
        "indeed": false
    },
    {
        "number": 2131,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, visited):\n        if start == end:\n            return [[start]]\n        visited.add(start)\n        paths = []\n        for neighbor in tree[start]:\n            if neighbor not in visited:\n                sub_paths = find_path(neighbor, end, visited)\n                for sub_path in sub_paths:\n                    paths.append([start] + sub_path)\n        visited.remove(start)\n        return paths\n\n    def is_valid_decomposition(paths):\n        for i in range(len(paths)):\n            for j in range(i + 1, len(paths)):\n                if not set(paths[i]) & set(paths[j]):\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    tree = {i: [] for i in range(1, n + 1)}\n    for i in range(1, n):\n        a, b = map(int, lines[i].split())\n        tree[a].append(b)\n        tree[b].append(a)\n\n    paths = []\n    for start in range(1, n + 1):\n        for end in range(1, n + 1):\n            if start != end:\n                paths.extend(find_path(start, end, set()))\n\n    valid_paths = [path for path in paths if is_valid_decomposition(path)]\n\n    if not valid_paths:\n        return \"No\"\n    else:\n        output = [\"Yes\", str(len(valid_paths))]\n        for path in valid_paths:\n            output.append(str(path[0]) + \" \" + str(path[-1]))\n        return '\\n'.join(output)",
        "test": "",
        "num_ids": 425,
        "indeed": false
    },
    {
        "number": 2132,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    events = stdin.split('\\n')[1:]\n\n    speed_limit = 0\n    overtake_allowed = True\n    no_overtake_allowed = False\n    no_speed_limit = False\n\n    violations = 0\n\n    for event in events:\n        event_type, *params = event.split()\n        event_type = int(event_type)\n\n        if event_type == 1:\n            new_speed = int(params[0])\n            if no_speed_limit and new_speed > speed_limit:\n                violations += 1\n            speed_limit = new_speed\n        elif event_type == 2:\n            if not overtake_allowed:\n                violations += 1\n        elif event_type == 3:\n            new_speed_limit = int(params[0])\n            if not no_speed_limit and new_speed_limit < speed_limit:\n                violations += 1\n            speed_limit = new_speed_limit\n        elif event_type == 4:\n            overtake_allowed = True\n        elif event_type == 5:\n            overtake_allowed = False\n            no_overtake_allowed = True\n        elif event_type == 6:\n            no_overtake_allowed = False\n\n    return str(violations)",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 2133,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n\n        if u_root == v_root:\n            return False\n\n        if rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n        elif rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += 1\n\n        return True\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    colors = [int(color) for color in lines[1].split()]\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n\n    for i in range(2, n + 1):\n        u, v = map(int, lines[i].split())\n        union(parent, rank, u, v)\n\n    black_root = find(parent, 1)\n    white_root = find(parent, 2)\n\n    if black_root == white_root:\n        return 0\n\n    black_count = colors.count(0)\n    white_count = colors.count(1)\n\n    if black_root == 1:\n        return min(black_count, white_count)\n    else:\n        return min(black_count, white_count)",
        "test": "",
        "num_ids": 413,
        "indeed": false
    },
    {
        "number": 2134,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_calm(a, b):\n        for i in range(len(a)):\n            if a[i] & b[i] == a[i]:\n                return False\n        return True\n\n    def find_max_sum(n, a, b):\n        max_sum = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_calm(a[i], a[j]):\n                    max_sum = max(max_sum, b[i] + b[j])\n        return max_sum\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    return str(find_max_sum(n, a, b))",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 2135,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r1, c1, r2, c2, grid):\n        if r1 == r2:\n            return grid[r1 - 1][c1 - 1] == '.' and grid[r1 - 1][c2 - 1] == '.'\n        elif c1 == c2:\n            return grid[r1 - 1][c1 - 1] == '.' and grid[r2 - 1][c1 - 1] == '.'\n        return False\n\n    def count_ways(r1, c1, r2, c2, grid):\n        if r1 == r2:\n            return c2 - c1 + 1\n        elif c1 == c2:\n            return r2 - r1 + 1\n        return 0\n\n    lines = stdin.split('\\n')\n    h, w = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:h + 1]]\n    q = int(lines[h + 1])\n    queries = [list(map(int, line.split())) for line in lines[h + 2:]]\n\n    result = []\n    for query in queries:\n        r1, c1, r2, c2 = query\n        if is_valid(r1, c1, r2, c2, grid):\n            result.append(count_ways(r1, c1, r2, c2, grid))\n        else:\n            result.append(0)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 375,
        "indeed": false
    },
    {
        "number": 2136,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x: int, y: int) -> bool:\n        return 1 <= x <= n and 1 <= y <= n\n\n    def find_path(x: int, y: int, digit: int) -> bool:\n        if x == n and y == n:\n            return True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (grid[nx][ny] == digit or grid[nx][ny] == 'S' or grid[nx][ny] == 'F'):\n                if find_path(nx, ny, digit):\n                    return True\n\n        return False\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 'S' or grid[i][j] == 'F':\n                    continue\n\n                for digit in ['0', '1']:\n                    if find_path(i, j, digit):\n                        grid[i][j] = '1' if grid[i][j] == '0' else '0'\n                        break\n\n        inverted_cells = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == '1']\n        output.append(str(len(inverted_cells)) + '\\n' + '\\n'.join(f\"{i + 1} {j + 1}\" for i, j in inverted_cells))\n\n    return '\\n\\n'.join(output) + '\\n'",
        "test": "",
        "num_ids": 471,
        "indeed": false
    },
    {
        "number": 2137,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def line_intersection(a1, b1, a2, b2):\n        return (a1 * b2) / (a2 * b1)\n\n    def get_experience_value(x1, v1, x2, v2):\n        if v1 == v2:\n            return 0\n        t = line_intersection(v1, x1, v2, x2)\n        if t < 0:\n            return 0\n        return 1\n\n    def get_ghost_kind_experience_value(ghosts):\n        experience_value = 0\n        for i in range(len(ghosts)):\n            for j in range(i + 1, len(ghosts)):\n                experience_value += get_experience_value(ghosts[i][0], ghosts[i][1], ghosts[j][0], ghosts[j][1])\n        return experience_value\n\n    def main():\n        n, a, b = map(int, stdin.readline().split())\n        ghosts = []\n        for _ in range(n):\n            x, vx, vy = map(int, stdin.readline().split())\n            ghosts.append((x, vx, vy))\n\n        experience_value = get_ghost_kind_experience_value(ghosts)\n        return str(experience_value)\n\n    return main() ",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 2138,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    d = list(map(int, stdin.split('\\n')[1].split()))\n\n    m = sum(d)\n    edges = []\n\n    for i in range(1, n + 1):\n        for j in range(d[i - 1]):\n            edges.append((i, j + 1))\n\n    output = [str(m)]\n    for edge in edges:\n        output.append(f\"{edge[0]} {edge[1]}\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 141,
        "indeed": false
    },
    {
        "number": 2139,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if \"bear\" in s[i:j+1]:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 70,
        "indeed": true
    },
    {
        "number": 2140,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m, *a = list(map(str.strip, stdin.split()))\n    m = int(m)\n    a = list(map(int, a))\n\n    for i in range(m):\n        s = s[:a[i] - 1] + s[a[i] - 1:2 * a[i] - 1:-1] + s[2 * a[i] - 1:]\n\n    return s",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 2141,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = [['.' for _ in range(n)] for _ in range(n)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < n\n\n    def can_attack(x1: int, y1: int, x2: int, y2: int) -> bool:\n        return (abs(x1 - x2) == 2 and abs(y1 - y2) == 1) or (abs(x1 - x2) == 1 and abs(y1 - y2) == 2)\n\n    def count_duels(x: int, y: int) -> int:\n        duels = 0\n        for i in range(n):\n            for j in range(n):\n                if is_valid(i, j) and can_attack(x, y, i, j):\n                    duels += 1\n        return duels\n\n    max_duels = 0\n    for i in range(n):\n        for j in range(n):\n            duels = count_duels(i, j)\n            if duels > max_duels:\n                max_duels = duels\n                board[i][j] = 'W' if (i + j) % 2 == 0 else 'B'\n\n    return '\\n'.join([''.join(row) for row in board])",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 2142,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(a, b):\n        i = j = 0\n        while i < len(a) and j < len(b):\n            if a[i] == b[j]:\n                i += 1\n            j += 1\n        return i == len(a)\n\n    def find_smallest_subsequence(a, b):\n        for k in range(1, min(len(a), len(b)) + 1):\n            for i in range(len(a) - k + 1):\n                for j in range(len(b) - k + 1):\n                    if is_subsequence(a[i:i + k], b[j:j + k]):\n                        return a[i:i + k]\n        return None\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n        subsequence = find_smallest_subsequence(a, b)\n        if subsequence:\n            result.append(\"YES\")\n            result.append(f\"{len(subsequence)} {' '.join(map(str, subsequence))}\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 2143,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sweets = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sweets[i] + sweets[j] != sweets[n - 1] + sweets[n - 2]:\n                count += 1\n                break\n\n    return str(count)",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 2144,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def count_appropriate_x(a, m):\n        count = 0\n        for x in range(m):\n            if gcd(a, m) == gcd(a + x, m):\n                count += 1\n        return count\n\n    T = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(T):\n        a, m = map(int, stdin.split('\\n')[i + 1].split())\n        result.append(count_appropriate_x(a, m))\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 2145,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    def is_greater_than_one(n: int) -> bool:\n        return n > 1\n\n    def spell_1(n: int) -> int:\n        return n - 1\n\n    def spell_2(n: int) -> int:\n        return n * 3 // 2\n\n    def can_obtain(x: int, y: int) -> bool:\n        if x == y:\n            return True\n        if is_even(x) and is_greater_than_one(x):\n            return can_obtain(spell_1(x), y) or can_obtain(spell_2(x), y)\n        if is_even(x):\n            return can_obtain(spell_2(x), y)\n        if is_greater_than_one(x):\n            return can_obtain(spell_1(x), y)\n        return False\n\n    lines = stdin.split('\\n')\n    T = int(lines[0])\n    results = []\n    for i in range(1, T + 1):\n        x, y = map(int, lines[2 * i - 1].split())\n        if can_obtain(x, y):\n            results.append('YES')\n        else:\n            results.append('NO')\n    return '\\n'.join(results)",
        "test": "",
        "num_ids": 348,
        "indeed": false
    },
    {
        "number": 2146,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    m = [0] * (n + 1)\n    for i in range(2, n + 1):\n        m[i] = min(m[i - 1] + abs(i - 1), m[i - 2] + 1)\n        if a[i - 1] == i:\n            m[i] = min(m[i], m[i - 1])\n    return ' '.join(map(str, m[1:]))",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 2147,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_rules(rules, n):\n        server_processes = [4] * n\n        for rule in rules:\n            a, b, c = rule\n            server_processes[a - 1] -= 1\n            server_processes[b - 1] += 1\n            server_processes[c - 1] += 1\n            if any(processes > 9 for processes in server_processes):\n                return False\n        return True\n\n    def generate_rules(n):\n        rules = []\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j:\n                    rules.append((i, i, j))\n        return rules\n\n    def is_valid(rules, n):\n        for i in range(1, 4 * n + 1):\n            if i not in rules:\n                return False\n        return True\n\n    def find_permutation(rules, n):\n        permutation = []\n        for i in range(1, 4 * n + 1):\n            if i not in rules:\n                permutation.append(i)\n            else:\n                permutation.append(rules.index(i) + 1)\n        return permutation\n\n    n = int(stdin.readline().strip())\n    rules = []\n    for _ in range(4 * n):\n        a, b, c = map(int, stdin.readline().strip().split())\n        rules.append((a, b, c))\n\n    if not is_valid(rules, n):\n        return \"NO\"\n\n    if check_rules(rules, n):\n        return \"YES\\n\" + \" \".join(map(str, find_permutation(rules, n)))\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 436,
        "indeed": false
    },
    {
        "number": 2148,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n\n    y = [10**100] * n\n\n    for i in range(n):\n        for j in range(i):\n            dy = (x[i] - x[j]) ** 2 + (y[j] - r) ** 2\n            if dy <= r ** 2:\n                y[i] = min(y[i], y[j] - r)\n        dy = y[i] - r\n        if dy <= 0:\n            y[i] = 0\n\n    return \" \".join(map(str, y))",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 2149,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    h = list(map(int, stdin.readline().split()))\n    mod = 998244353\n\n    def is_valid(ans_suit):\n        points = 0\n        for i in range(n):\n            if ans_suit[i] == h[(i + 1) % n]:\n                points += 1\n        return points > 0\n\n    valid_ans_suits = 0\n    for i in range(1, k + 1):\n        ans_suit = [(j + i) % k for j in h]\n        if is_valid(ans_suit):\n            valid_ans_suits += 1\n\n    return str(valid_ans_suits % mod)",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2150,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    a = [0] * n\n    a[0] = b[0]\n\n    for i in range(1, n):\n        a[i] = b[i] + a[i - 1]\n\n    return ' '.join(map(str, a))",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 2151,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_division(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] >= s[i + 1]:\n                return False\n        return True\n\n    def find_valid_division(s: str) -> str:\n        if len(s) == 1:\n            return \"NO\"\n\n        for i in range(1, len(s)):\n            if is_valid_division(s[:i]) and is_valid_division(s[i:]):\n                return f\"YES\\n2\\n{s[:i]}\\n{s[i:]}\"\n\n        return \"NO\"\n\n    queries = stdin.split(\"\\n\")[1:-1]\n    result = []\n\n    for query in queries:\n        n, s = query.split(\"\\n\")\n        result.append(find_valid_division(s))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 231,
        "indeed": false
    },
    {
        "number": 2152,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    p = [int(x) for x in stdin.split('\\n')[n+1:]]\n    total_cost = 0\n    for i in range(n):\n        total_cost += a[i] * p[i]\n    return str(total_cost)",
        "test": "",
        "num_ids": 106,
        "indeed": false
    },
    {
        "number": 2153,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = list(map(int, stdin.split('\\n')[1].split()))\n\n    jumps = 0\n    current_height = heights[0]\n\n    for i in range(1, n):\n        if heights[i] > current_height:\n            jumps += 1\n            current_height = heights[i]\n\n    return str(jumps)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 2154,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    prices = list(map(int, lines[1].split()))\n\n    max_profit = 0\n    min_price = float('inf')\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return str(max_profit)",
        "test": "",
        "num_ids": 109,
        "indeed": false
    },
    {
        "number": 2155,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_matrix(t, a):\n        for n in range(1, int(t ** 0.5) + 1):\n            if t % n == 0:\n                m = t // n\n                matrix = [[0] * m for _ in range(n)]\n                for i in range(n):\n                    for j in range(m):\n                        matrix[i][j] = manhattan_distance(i, j, x, y)\n                if matrix[x - 1][y - 1] == 0:\n                    return n, m, x, y\n        return -1, -1, -1, -1\n\n    t = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    n, m, x, y = find_matrix(t, a)\n\n    if n == -1:\n        return \"-1\\n\"\n    else:\n        return f\"{n} {m}\\n{x} {y}\\n\"",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2156,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(sequence: List[int]) -> int:\n        n = len(sequence)\n        k = 0\n        while n != 1:\n            n //= 2\n            k += 1\n        candies = 0\n        while len(sequence) > 1:\n            new_sequence = []\n            for i in range(0, len(sequence), 2):\n                if i + 1 < len(sequence):\n                    pair_sum = sequence[i] + sequence[i + 1]\n                    if pair_sum >= 10:\n                        candies += 1\n                    new_sequence.append(pair_sum % 10)\n                else:\n                    new_sequence.append(sequence[i])\n            sequence = new_sequence\n        return candies\n\n    n, sequence, q, *queries = list(map(str.strip, stdin.split()))\n    n = int(n)\n    sequence = list(map(int, sequence))\n    q = int(q)\n    queries = [list(map(int, query.split())) for query in queries]\n\n    result = []\n    for query in queries:\n        l, r = query\n        result.append(f(sequence[l - 1:r]))\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 314,
        "indeed": false
    },
    {
        "number": 2157,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    queries = [list(map(int, stdin.readline().split())) for _ in range(q)]\n\n    a.sort()\n\n    total_sum = 0\n    for l, r in queries:\n        total_sum += sum(a[l - 1:r])\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 2158,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_cost(n, connections):\n        max_cost = 0\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    cost = find_cost(i, j, connections)\n                    if cost > max_cost:\n                        max_cost = cost\n        return max_cost\n\n    def find_cost(start, end, connections):\n        if start == end:\n            return 0\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, cost = queue.pop(0)\n            if node == end:\n                return cost\n            if node not in visited:\n                visited.add(node)\n                for neighbor, neighbor_cost in connections[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, cost + neighbor_cost))\n        return -1\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        connections = {i: [] for i in range(n)}\n        for line in lines[1:]:\n            u, v, c = map(int, line.split())\n            connections[u].append((v, c))\n            connections[v].append((u, c))\n        return n, connections\n\n    n, connections = parse_input(stdin)\n    max_cost = find_max_cost(n, connections)\n    return str(max_cost)",
        "test": "",
        "num_ids": 358,
        "indeed": false
    },
    {
        "number": 2159,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    intervals = []\n    for i in range(n):\n        for j in range(i, n):\n            interval = colors[i:j+1]\n            intervals.append(interval)\n\n    counts = [0] * n\n    for interval in intervals:\n        dominant_color = max(set(interval), key=interval.count)\n        counts[dominant_color - 1] += 1\n\n    return ' '.join(map(str, counts))",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 2160,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if abs(i - j) > 1:\n                valid = True\n                for q in range(k):\n                    if x[q] == i and q == 0:\n                        valid = False\n                        break\n                    if x[q] == j and q == k - 1:\n                        valid = False\n                        break\n                if valid:\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 2161,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    phone_books = stdin.split('\\n')[1:]\n    friends = {}\n\n    for book in phone_books:\n        name, num_phones, *phones = book.split()\n        num_phones = int(num_phones)\n        phones = [phones[i:i + 2] for i in range(0, len(phones), 2)]\n\n        if name not in friends:\n            friends[name] = set()\n\n        for i in range(num_phones):\n            if i > 0 and phones[i - 1][1] == phones[i][1][-len(phones[i - 1][1]):]:\n                continue\n            friends[name].add(phones[i][1])\n\n    output = [f\"{name} {len(friends[name])} {' '.join(friends[name])}\" for name in sorted(friends)]\n    return f\"{len(output)}\\n\" + '\\n'.join(output)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2162,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    k1, k2, k3 = map(int, lines[0].split())\n    a1 = list(map(int, lines[1].split()))\n    a2 = list(map(int, lines[2].split()))\n    a3 = list(map(int, lines[3].split()))\n\n    a1.sort()\n    a2.sort()\n    a3.sort()\n\n    moves = 0\n\n    # Move problems from a1 to a3\n    for i in range(k1):\n        if a1[i] > a3[0]:\n            moves += 1\n\n    # Move problems from a2 to a3\n    for i in range(k2):\n        if a2[i] > a3[0]:\n            moves += 1\n\n    # Move problems from a3 to a1\n    for i in range(k3):\n        if a3[i] < a1[0]:\n            moves += 1\n\n    return str(moves)",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2163,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total = 0\n\n    for i in range(1, m + 1):\n        total += pow(i, n, MOD)\n\n    return str(total % MOD)",
        "test": "",
        "num_ids": 74,
        "indeed": false
    },
    {
        "number": 2164,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_longest_palindrome(s: str) -> str:\n        longest_palindrome = \"\"\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                if is_palindrome(substring) and substring in s:\n                    if len(substring) > len(longest_palindrome):\n                        longest_palindrome = substring\n        return longest_palindrome\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        longest_palindrome = find_longest_palindrome(s)\n        result.append(longest_palindrome)\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 233,
        "indeed": false
    },
    {
        "number": 2165,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    t = list(map(int, stdin.split('\\n')[2].split()))\n\n    x = [T * a[i] / t[i] if t[i] != 0 else 0 for i in range(n)]\n    x_sum = sum(x)\n\n    if x_sum == 0:\n        return \"0.000000000000000\"\n    else:\n        return f\"{x_sum / n:.13f}\"",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 2166,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, permutation = map(int, stdin.split())\n    mod = 10**9 + 7\n    total_permutations = factorial(n, mod)\n    permutations_with_fixed_points = 0\n\n    for i in range(n):\n        if permutation[i] != -1 and permutation[i] != i + 1:\n            permutations_with_fixed_points += factorial(n - 1, mod)\n\n    return str(total_permutations - permutations_with_fixed_points)\n\ndef",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 2167,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_count = 0\n    for i in range(n):\n        count = arr.count(arr[i])\n        max_count = max(max_count, count)\n\n    return str(max_count)",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 2168,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_companies(company1, company2):\n        max_salary1 = max(company1)\n        max_salary2 = max(company2)\n        if max_salary1 == max_salary2:\n            return company1 + company2\n        else:\n            return None\n\n    def find_min_increase(companies):\n        total_increase = 0\n        while len(companies) > 1:\n            merged_company = merge_companies(companies[0], companies[1])\n            if merged_company:\n                companies.pop(0)\n                companies.pop(0)\n                companies.insert(0, merged_company)\n            else:\n                max_salary1 = max(companies[0])\n                max_salary2 = max(companies[1])\n                increase = max(max_salary1, max_salary2) - min(max_salary1, max_salary2)\n                total_increase += increase\n                companies[0] = [salary + increase for salary in companies[0]]\n                companies[1] = [salary + increase for salary in companies[1]]\n        return total_increase\n\n    n = int(stdin.readline())\n    companies = []\n    for _ in range(n):\n        company = list(map(int, stdin.readline().split()))\n        companies.append(company[1:])\n\n    min_increase = find_min_increase(companies)\n    return str(min_increase)",
        "test": "",
        "num_ids": 383,
        "indeed": false
    },
    {
        "number": 2169,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_sum(i, j, D, L, R):\n        x, y = i, j\n        total = 0\n        while True:\n            total += abs(x - i) + abs(y - j)\n            x, y = divmod(x * y + D, H * W)\n            if x == R:\n                break\n        return total\n\n    H, W, D, *A, Q, *L_R = map(int, stdin.split())\n    A = [A[i:i + W] for i in range(0, len(A), W)]\n\n    return \"\\n\".join(str(get_sum(i, j, D, L, R)) for i, j, L, R in zip(range(H), cycle(range(W)), L_R[::2], L_R[1::2]))",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 2170,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_pairs(n: int, m: int) -> int:\n        if n == 1:\n            return m * (m - 1) // 2\n        else:\n            total_pairs = 0\n            for i in range(1, m):\n                pairs_with_i = count_pairs(n - 1, m - 1)\n                total_pairs += pairs_with_i\n            return total_pairs % mod\n\n    return str(count_pairs(n, m))",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 2171,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    if a == 0:\n        return \"yes\"\n    elif a == 1:\n        return \"yes\"\n    elif a == 2:\n        return \"no\"\n    elif a == 3:\n        return \"yes\"\n    else:\n        for i in range(4, a + 1, 3):\n            if i not in [4, 7]:\n                return \"no\"\n        return \"yes\"",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 2172,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    words = [stdin.readline().strip().split() for _ in range(m)]\n    lecture = stdin.readline().strip().split()\n    translation = {a: b for a, b in words}\n    result = []\n    for word in lecture:\n        result.append(word if len(word) <= len(translation[word]) else translation[word])\n    return \" \".join(result)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 2173,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    a.sort()\n    b = [0] * n\n\n    for i in range(n):\n        b[i] = a[i] - i\n\n    for i in range(n):\n        if b[i] <= 0:\n            b[i] = 1\n        else:\n            break\n\n    return ' '.join(map(str, b))",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 2174,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        count += abs(i + 1 - a[i])\n\n    return str(count)",
        "test": "",
        "num_ids": 76,
        "indeed": false
    },
    {
        "number": 2175,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, queries = parse_input(stdin)\n    vessels = [0] * n\n    overflow = [0] * n\n\n    for query in queries:\n        if query[0] == 1:\n            pour_water(query[1], query[2], vessels, overflow, n)\n        elif query[0] == 2:\n            print(vessels[query[1] - 1] + overflow[query[1] - 1], end=\" \")\n\n    return \"\"\n\ndef",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 2176,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_sequence(s: list) -> bool:\n        sorted_first = sorted(s, key=lambda x: x[0])\n        sorted_second = sorted(s, key=lambda x: x[1])\n        return sorted_first != s and sorted_second != s\n\n    def count_permutations(n: int, modulo: int = 998244353) -> int:\n        return (factorial(n, modulo) * inv(2, modulo)) % modulo\n\n    def factorial(n: int, modulo: int = 998244353) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % modulo\n        return result\n\n    def inv(x: int, modulo: int = 998244353) -> int:\n        return pow(x, modulo - 2, modulo)\n\n    n = int(stdin.readline().strip())\n    s = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        s.append((a, b))\n\n    if is_good_sequence(s):\n        return str(count_permutations(n))\n    else:\n        return \"0\"",
        "test": "",
        "num_ids": 330,
        "indeed": false
    },
    {
        "number": 2177,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def conc(a: int, b: int) -> int:\n        return int(str(a) + str(b))\n\n    def is_valid_pair(a: int, b: int) -> bool:\n        return a * b + a + b == conc(a, b)\n\n    def count_valid_pairs(A: int, B: int) -> int:\n        count = 0\n        for a in range(1, A + 1):\n            for b in range(1, B + 1):\n                if is_valid_pair(a, b):\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n    for i in range(1, t + 1):\n        A, B = map(int, lines[i].split())\n        result.append(count_valid_pairs(A, B))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 2178,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    stack = a.copy()\n    result = []\n\n    for i in range(n):\n        count = 0\n        for j in range(len(stack)):\n            if stack[j] == b[i]:\n                count += 1\n                break\n            count += 1\n        result.append(count)\n        stack = stack[count:]\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 2179,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n\n        if u_root == v_root:\n            return False\n\n        if rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n        elif rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += 1\n\n        return True\n\n    def kruskal(n, edges):\n        parent = [i for i in range(n)]\n        rank = [0] * n\n        mst_edges = []\n        edges.sort(key=lambda x: x[2])\n\n        for u, v, w in edges:\n            if union(parent, rank, u - 1, v - 1):\n                mst_edges.append((u, v, w))\n\n        return mst_edges\n\n    def find_shortest_path_tree(n, edges, u):\n        edges_with_u = [e for e in edges if u in e[:2]]\n        other_vertices = [v for v in range(1, n + 1) if v != u]\n        mst_edges = kruskal(n, edges)\n        total_weight = sum(e[2] for e in mst_edges)\n\n        for v in other_vertices:\n            shortest_path_length = float('inf')\n            for e in edges_with_u:\n                if v in e[:2]:\n                    shortest_path_length = min(shortest_path_length, e[2])\n            total_weight += shortest_path_length\n\n        return total_weight, [i + 1 for i, e in enumerate(edges) if e in mst_edges]\n\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    u = int(stdin.readline())\n\n    total_weight, tree_edges = find_shortest_path_tree(n, edges, u)\n    return f\"{total_weight}\\n{' '.join(map(str, tree_edges))}\" ",
        "test": "",
        "num_ids": 627,
        "indeed": false
    },
    {
        "number": 2180,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    num_coders = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i % 2 == 0:\n                if j % 2 == 0:\n                    board[i][j] = 'C'\n                    num_coders += 1\n            else:\n                if j % 2 != 0:\n                    board[i][j] = 'C'\n                    num_coders += 1\n\n    output = f\"{num_coders}\\n\"\n    for row in board:\n        output += ''.join(row) + '\\n'\n\n    return output.strip()",
        "test": "",
        "num_ids": 192,
        "indeed": true
    },
    {
        "number": 2181,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(float, stdin.split()[0].strip().split())\n    n = int(stdin.split()[1].strip())\n\n    for i in range(1, n + 1):\n        angle = (i * d / a) * 2 * 180 / 3.141592653589793\n        x = i * d * cos(angle)\n        y = i * d * sin(angle)\n        print(f\"{x:.10f} {y:.10f}\")\n\n    return \"\"",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 2182,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_divisible_by_60(num: str) -> bool:\n        for i in range(len(num) - 1):\n            if num[i] > num[i + 1]:\n                return False\n        return int(num) % 60 == 0\n\n    def has_valid_permutation(num: str) -> bool:\n        for perm in permutations(num):\n            if is_divisible_by_60(\"\".join(perm)):\n                return True\n        return False\n\n    def main(stdin: str) -> List[str]:\n        n = int(stdin.readline().strip())\n        numbers = [stdin.readline().strip() for _ in range(n)]\n\n        result = []\n        for num in numbers:\n            if has_valid_permutation(num):\n                result.append(\"red\")\n            else:\n                result.append(\"cyan\")\n\n        return result\n\n    return \"\\n\".join(main(stdin)) ",
        "test": "",
        "num_ids": 243,
        "indeed": false
    },
    {
        "number": 2184,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    functions = [stdin.readline().strip() for _ in range(n)]\n\n    def find_expression(function: str) -> str:\n        pass\n\n    return [find_expression(function) for function in functions]\n\n    # Implement the find_expression function to solve the problem\n",
        "test": "",
        "num_ids": 83,
        "indeed": false
    },
    {
        "number": 2185,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_make_equal(a: List[int], b: List[int]) -> bool:\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                return False\n        return True\n\n    def find_diff(a: List[int], b: List[int]) -> Tuple[int, int]:\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                return i, b[i] - a[i]\n        return -1, -1\n\n    def perform_operation(a: List[int], l: int, r: int, k: int) -> List[int]:\n        for i in range(l - 1, r):\n            a[i] += k\n        return a\n\n    def is_possible(a: List[int], b: List[int]) -> bool:\n        if can_make_equal(a, b):\n            return True\n\n        index, diff = find_diff(a, b)\n        if index == -1:\n            return False\n\n        for i in range(index, len(a)):\n            if a[i] + diff > b[i]:\n                return False\n\n        for i in range(index - 1, -1, -1):\n            if a[i] + diff < b[i]:\n                return False\n\n        return True\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(lines[i * 3 - 2])\n        a = list(map(int, lines[i * 3 - 1].split()))\n        b = list(map(int, lines[i * 3].split()))\n\n        if is_possible(a, b):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result) ",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 2186,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    memory = stdin.split('\\n')[1:n+1]\n    queries = stdin.split('\\n')[n+1:]\n    result = []\n\n    for query in queries:\n        found = False\n        for mem in memory:\n            diff_count = 0\n            for i in range(len(mem)):\n                if mem[i] != query[i]:\n                    diff_count += 1\n            if diff_count == 1:\n                found = True\n                break\n        if found:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 2187,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_operations(arr):\n        n = len(arr)\n        operations = 0\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and arr[j] == arr[j - 1]:\n                j += 1\n            if j < n and arr[j] < arr[j - 1]:\n                return -1\n            operations += j - i - 1\n            i = j\n        return operations\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        arr = list(map(int, stdin.readline().strip().split()))\n        result = min_operations(arr)\n        output.append(str(result))\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 2188,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_sequence(sequence: List[int]) -> bool:\n        for i in range(1, len(sequence) - 1, 2):\n            if sequence[i] <= sequence[i + 1]:\n                return False\n        for i in range(0, len(sequence) - 1, 2):\n            if sequence[i] >= sequence[i + 1]:\n                return False\n        return True\n\n    def find_max_subset(pairs: List[Tuple[int, int]], index_subset: List[int]) -> int:\n        if len(index_subset) == len(pairs):\n            sequence = [pairs[i][0] for i in index_subset] + [pairs[i][1] for i in index_subset]\n            if is_good_sequence(sequence):\n                return len(index_subset)\n            else:\n                return 0\n\n        max_length = 0\n        for i in range(len(pairs)):\n            if i not in index_subset:\n                index_subset.append(i)\n                max_length = max(max_length, find_max_subset(pairs, index_subset))\n                index_subset.pop()\n\n        return max_length\n\n    n = int(stdin.readline().strip())\n    pairs = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    max_length = find_max_subset(pairs, [])\n    index_subset = []\n    find_max_subset(pairs, index_subset)\n\n    return f\"{max_length}\\n{' '.join(map(str, index_subset))}\"",
        "test": "",
        "num_ids": 402,
        "indeed": false
    },
    {
        "number": 2189,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        v, u = map(int, stdin.readline().split())\n        graph[v].append(u)\n\n    def dfs(node, visited, order):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, order)\n        order.append(node)\n\n    visited = [False] * (n + 1)\n    order = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, order)\n\n    labels = [0] * (n + 1)\n    for i, node in enumerate(order):\n        labels[node] = i + 1\n\n    return \" \".join(map(str, labels[1:]))\n",
        "test": "",
        "num_ids": 241,
        "indeed": false
    },
    {
        "number": 2190,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] * a[j] == pow(a[i] * a[j], 1 / k):\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 2191,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def count_sets(x: int) -> int:\n        sets = 0\n        current_set = []\n        for i in range(n):\n            if s[i] == '?':\n                current_set.append(i)\n            elif s[i] == '0':\n                current_set.append(i)\n                if len(current_set) == x:\n                    sets += 1\n                    current_set = []\n            else:\n                current_set.append(i)\n                if len(current_set) == x:\n                    sets += 1\n                    current_set = []\n        return sets\n\n    result = []\n    for x in range(1, n + 1):\n        result.append(count_sets(x))\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 224,
        "indeed": false
    },
    {
        "number": 2192,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    W = []\n    for _ in range(n):\n        W.append(list(map(int, stdin.readline().strip().split())))\n\n    A = [[0 for _ in range(n)] for _ in range(n)]\n    B = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                A[i][j] = W[i][j] / 2\n                B[i][j] = -W[i][j] / 2\n            else:\n                A[i][j] = W[i][j]\n                B[i][j] = -W[i][j]\n\n    output = \"\"\n    for i in range(n):\n        for j in range(n):\n            output += f\"{A[i][j]:.8f} \"\n        output += \"\\n\"\n    for i in range(n):\n        for j in range(n):\n            output += f\"{B[i][j]:.8f} \"\n        output += \"\\n\"\n\n    return output.strip()",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2193,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path: List[int], schedule: str) -> bool:\n        for i in range(len(path) - 1):\n            u, v = path[i], path[i + 1]\n            if (u, v) not in roads:\n                return False\n            if (schedule[u - 1] != roads[(u, v)]) and (schedule[v - 1] != roads[(u, v)][::-1]):\n                return False\n        return True\n\n    def dfs(start: int, visited: Set[int], path: List[int], schedule: str) -> int:\n        if start == n:\n            return 0 if is_valid_path(path, schedule) else float('inf')\n        if len(path) > m + 1:\n            return float('inf')\n        min_length = float('inf')\n        for next_city in range(1, n + 1):\n            if next_city not in visited and (next_city not in roads or (next_city in roads and roads[next_city][-1] == schedule[start - 1])):\n                visited.add(next_city)\n                path.append(next_city)\n                min_length = min(min_length, dfs(next_city, visited, path, schedule))\n                path.pop()\n                visited.remove(next_city)\n        return min_length + 1\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    roads = {}\n    for i in range(1, m + 1):\n        u, v, t = map(int, lines[i].split())\n        roads.setdefault((u, v), str(t))\n        roads.setdefault((v, u), str(t ^ 1))\n\n    min_length = float('inf')\n    min_schedule = ''\n    for schedule in product('01', repeat=n):\n        schedule = ''.join(schedule)\n        visited = {1}\n        path = [1]\n        length = dfs(1, visited, path, schedule)\n        if length < min_length:\n            min_length = length\n            min_schedule = schedule\n\n    if min_length == float('inf'):\n        return '-1\\n'\n    else:\n        return f'{min_length}\\n{min_schedule}\\n' ",
        "test": "",
        "num_ids": 578,
        "indeed": false
    },
    {
        "number": 2194,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def replace(x, k):\n        a[x - 1] = k\n\n    def reverse(k):\n        for i in range(1, 2 ** k + 1):\n            left = (i - 1) * (2 ** k) + 1\n            right = i * (2 ** k)\n            a[left - 1:right] = a[left - 1:right][::-1]\n\n    def swap(k):\n        for i in range(1, 2 ** k + 1):\n            left = (2 * i - 2) * (2 ** k) + 1\n            right = (2 * i - 1) * (2 ** k)\n            a[left - 1:right], a[right:right + (right - left + 1)] = a[right:right + (right - left + 1)], a[left - 1:right]\n\n    def sum_query(l, r):\n        return sum(a[l - 1:r])\n\n    n, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    for _ in range(q):\n        query = stdin.readline().strip().split()\n        if query[0] == \"1\":\n            replace(int(query[1]), int(query[2]))\n        elif query[0] == \"2\":\n            reverse(int(query[1]))\n        elif query[0] == \"3\":\n            swap(int(query[1]))\n        elif query[0] == \"4\":\n            print(sum_query(int(query[1]), int(query[2])))\n\n    return \"\"",
        "test": "",
        "num_ids": 408,
        "indeed": false
    },
    {
        "number": 2195,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(x: int, y: int, a: int, b: int) -> int:\n        if x == y == 0:\n            return 0\n        if x == y:\n            return (x - y) * a\n        else:\n            return min((x - y) * a + (abs(x - y) - 1) * b, (y - x) * a + (abs(x - y) - 1) * b)\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        x, y, a, b = map(int, stdin.split('\\n')[i].split())\n        result.append(find_min_cost(x, y, a, b))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 2196,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_a = max(a)\n    v = max_a + 1\n\n    return str(v - 1)",
        "test": "",
        "num_ids": 69,
        "indeed": false
    },
    {
        "number": 2197,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    p = list(map(float, stdin.split()[2:]))\n\n    def nim_sum(piles):\n        nim_sum = 0\n        for pile in piles:\n            nim_sum ^= pile\n        return nim_sum\n\n    def nim_strategy(piles):\n        nim_sum = nim_sum(piles)\n        if nim_sum == 0:\n            return True\n        for i in range(len(piles)):\n            if piles[i] & (piles[i] ^ nim_sum) != 0:\n                return True\n        return False\n\n    winning_positions = 0\n    for i in range(n):\n        for j in range(x + 1):\n            piles = [0] * n\n            piles[i] = j\n            if nim_strategy(piles):\n                winning_positions += p[j]\n\n    return str(winning_positions)",
        "test": "",
        "num_ids": 250,
        "indeed": false
    },
    {
        "number": 2198,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    f = 0\n    for i in range(m):\n        x, c = stdin.readline().strip().split()\n        x, c = int(x), str(c)\n        if c == \".\":\n            f += s.count(\"..\")\n            s = s[:x - 1] + \".\" + s[x:]\n        else:\n            s = s[:x - 1] + c + s[x:]\n        print(f)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2199,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mean(s):\n        return sum(s) / len(s)\n\n    def max_minus_mean(s):\n        return max(s) - mean(s)\n\n    def add_to_set(x):\n        if not S:\n            S.add(x)\n        else:\n            S.add(max(x, max(S)))\n\n    S = set()\n    result = []\n\n    for line in stdin.split('\\n'):\n        if line.startswith('1'):\n            x = int(line.split()[1])\n            add_to_set(x)\n        elif line.startswith('2'):\n            result.append(round(max_minus_mean(S), 10))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 2200,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, *x = list(map(int, stdin.split()))\n    result = []\n\n    for i in range(n):\n        tokens_to_save = 0\n        for j in range(i + 1, n):\n            tokens_to_save += x[j]\n        money = (tokens_to_save * a) // b\n        result.append(tokens_to_save - money)\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2201,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n, m = map(int, stdin.split())\n    gas_stations = []\n    for i in range(m):\n        x, p = map(int, input().split())\n        gas_stations.append((x, p))\n\n    gas_stations.sort()\n    fuel_cost = 0\n    current_fuel = n\n    last_station = 0\n\n    for i in range(m):\n        if current_fuel == 0:\n            break\n\n        x, p = gas_stations[i]\n\n        if x - last_station > current_fuel:\n            break\n\n        fuel_needed = x - max(0, x - n - last_station)\n        fuel_cost += fuel_needed * p\n        current_fuel -= fuel_needed\n        last_station = x\n\n    if d - last_station > current_fuel:\n        return -1\n\n    fuel_needed = d - last_station\n    fuel_cost += fuel_needed * p\n    current_fuel -= fuel_needed\n\n    if current_fuel < 0:\n        return -1\n\n    return fuel_cost\n",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 2202,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def score(seq, p):\n        return sum(seq) % p\n\n    def max_score(A, p):\n        n = len(A)\n        max_score = 0\n        for i in range(1, n):\n            left_score = score(A[:i], p)\n            right_score = score(A[i:], p)\n            total_score = left_score + right_score\n            if total_score > max_score:\n                max_score = total_score\n        return max_score\n\n    N, p = map(int, stdin.split()[0].split())\n    A = list(map(int, stdin.split()[1].split()))\n\n    return str(max_score(A, p))",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 2203,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_ancestor(u: int, v: int) -> bool:\n        return u == v or (u < v and v <= 2 * u)\n\n    def find_common_ancestor(u: int, v: int) -> int:\n        while u != v:\n            if u < v:\n                v = (v - 1) // 2\n            else:\n                u = (u - 1) // 2\n        return u\n\n    def is_contradictory(h: int, q: int, questions: list) -> bool:\n        for i in range(h):\n            nodes_in_level = 2 ** i\n            for j in range(nodes_in_level):\n                u = 2 ** h - 1 - j\n                for k in range(i + 1, h + 1):\n                    v = 2 ** k - 1\n                    if is_ancestor(u, v):\n                        common_ancestor = find_common_ancestor(u, v)\n                        if common_ancestor != u:\n                            for question in questions:\n                                if question[0] == k and question[1] <= common_ancestor and common_ancestor <= question[2]:\n                                    if question[3] == 1 and u < question[1] or question[3] == 0 and u > question[2]:\n                                        return True\n        return False\n\n    def find_exit(h: int, q: int, questions: list) -> int:\n        possible_exits = set(range(2 ** h - 1, 2 ** (h + 1) - 1))\n        for i in range(h):\n            nodes_in_level = 2 ** i\n            for j in range(nodes_in_level):\n                u = 2 ** h - 1 - j\n                for k in range(i + 1, h + 1):\n                    v = 2 ** k - 1\n                    if is_ancestor(u, v):\n                        common_ancestor = find_common_ancestor(u, v)\n                        if common_ancestor != u:\n                            for question in questions:\n                                if question[0] == k and question[1] <= common_ancestor and common_ancestor <= question[2]:\n                                    if question[3] == 1 and u < question[1] or question[3] == 0 and u > question[2]:\n                                        possible_exits.discard(v)\n        return possible_exits\n\n    lines = stdin.split('\\n')\n    h, q = map(int, lines[0].split())\n    questions = [list(map(int, line.split())) for line in lines[1:q + 1]]\n\n    if is_contradictory(h, q, questions):\n        return \"Game cheated!\"\n    else:\n        possible_exits = find_exit(h, q, questions)\n        if len(possible_exits) == 1:\n            return str(possible_exits.pop())\n        else:\n            return \"Data not sufficient!\"",
        "test": "",
        "num_ids": 755,
        "indeed": false
    },
    {
        "number": 2204,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_happiness(n: int, m: int, a: List[int], b: List[int]) -> int:\n        dp = [[0] * (n + 1) for _ in range(m)]\n\n        for i in range(m):\n            dp[i][0] = 0\n\n        for i in range(1, n + 1):\n            for j in range(m):\n                dp[j][i] = dp[j][i - 1]\n                if i > 0:\n                    for k in range(m):\n                        if k != j:\n                            dp[j][i] = max(dp[j][i], dp[k][i - 1] + a[j] + (i - 1) * b[j])\n\n        return max(dp[j][n] for j in range(m))\n\n    t = int(stdin.split('\\n', 1)[0])\n    result = []\n\n    for case in stdin.split('\\n\\n')[1:]:\n        case = case.split('\\n')\n        n, m = map(int, case[0].split())\n        a, b = [], []\n\n        for i in range(1, m + 1):\n            a_i, b_i = map(int, case[i].split())\n            a.append(a_i)\n            b.append(b_i)\n\n        result.append(max_happiness(n, m, a, b))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 2205,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    p = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    q = []\n    for i in range(n):\n        mod_sum = sum([i % j for j in range(1, n + 1)])\n        q.append(p[i] ^ mod_sum)\n\n    Q = 0\n    for qi in q:\n        Q ^= qi\n\n    return str(Q)",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 2206,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod_pow(base, exponent, modulus):\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent //= 2\n        return result\n\n    def count_ways(n, adj):\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 1\n\n        for i in range(1, n):\n            for j in range(1, n):\n                if adj[i][j]:\n                    for k in range(n):\n                        if k != i and k != j:\n                            dp[i][j] += dp[i][k] * dp[k][j]\n\n        return dp[0][n - 1]\n\n    def count_ways_mod(n, adj):\n        MOD = 10**9 + 7\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 1\n\n        for i in range(1, n):\n            for j in range(1, n):\n                if adj[i][j]:\n                    for k in range(n):\n                        if k != i and k != j:\n                            dp[i][j] += dp[i][k] * dp[k][j]\n                            dp[i][j] %= MOD\n\n        return dp[0][n - 1]\n\n    n = int(stdin.readline().strip())\n    adj = [[int(x) for x in line.strip().split()] for line in stdin]\n\n    # print(count_ways(n, adj))\n    return str(count_ways_mod(n, adj))",
        "test": "",
        "num_ids": 461,
        "indeed": false
    },
    {
        "number": 2207,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    wall = [list(stdin.readline().strip()) for _ in range(R)]\n    visited = [[False] * C for _ in range(R)]\n    segments = 0\n\n    def dfs(r, c):\n        if r < 0 or r >= R or c < 0 or c >= C or visited[r][c]:\n            return\n        visited[r][c] = True\n        if wall[r][c] == 'B':\n            dfs(r - 1, c)\n            dfs(r + 1, c)\n            dfs(r, c - 1)\n            dfs(r, c + 1)\n\n    for r in range(R):\n        for c in range(C):\n            if not visited[r][c] and wall[r][c] == 'B':\n                dfs(r, c)\n                segments += 1\n\n    return str(segments)",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 2208,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    count = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            if max(a[l - 1:r]) == min(b[:r]):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 2209,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = []\n    for _ in range(n):\n        strings.append(stdin.readline().strip())\n\n    def count_noise(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] == 's' and s[i + 1] == 'h':\n                count += 1\n        return count\n\n    def max_noise(strings: List[str]) -> int:\n        max_noise = 0\n        for i in range(len(strings)):\n            for j in range(i, len(strings)):\n                noise = count_noise(strings[i] + strings[j])\n                if noise > max_noise:\n                    max_noise = noise\n        return max_noise\n\n    def swap(strings: List[str], i: int, j: int) -> None:\n        strings[i], strings[j] = strings[j], strings[i]\n\n    def permutations(strings: List[str], index: int, max_noise: int) -> int:\n        if index == len(strings) - 1:\n            return max_noise\n\n        for i in range(index, len(strings)):\n            swap(strings, index, i)\n            max_noise = max(max_noise, permutations(strings, index + 1, max_noise))\n            swap(strings, index, i)\n\n        return max_noise\n\n    return permutations(strings, 0, max_noise(strings))",
        "test": "",
        "num_ids": 387,
        "indeed": false
    },
    {
        "number": 2210,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_leaf(tree, node):\n        return len(tree[node]) <= 1\n\n    def remove_node(tree, node):\n        for neighbor in tree[node]:\n            tree[neighbor].remove(node)\n        del tree[node]\n\n    def find_winner(tree, x):\n        if len(tree) == 1:\n            return \"Ashish\"\n\n        if x in tree:\n            if is_leaf(tree, x):\n                remove_node(tree, x)\n                return \"Ayush\"\n            else:\n                remove_node(tree, x)\n                return find_winner(tree, max(tree, key=lambda k: len(tree[k])))\n        else:\n            return find_winner(tree, max(tree, key=lambda k: len(tree[k])))\n\n    num_testcases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(num_testcases):\n        n, x = map(int, stdin.readline().strip().split())\n        tree = {i: set() for i in range(1, n + 1)}\n\n        for _ in range(n - 1):\n            u, v = map(int, stdin.readline().strip().split())\n            tree[u].add(v)\n            tree[v].add(u)\n\n        result.append(find_winner(tree, x))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 360,
        "indeed": false
    },
    {
        "number": 2211,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split(\"\\n\")\n    n = int(n)\n    rules = []\n    for _ in range(n):\n        p, l, r = stdin.split()\n        l = int(l)\n        r = int(r)\n        rules.append((p, l, r))\n\n    def is_good_substring(t: str) -> bool:\n        for p, l, r in rules:\n            if p.count(t) < l or p.count(t) > r:\n                return False\n        return True\n\n    good_substrings = set()\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i : j + 1]\n            if is_good_substring(substring):\n                good_substrings.add(substring)\n\n    return len(good_substrings)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 2212,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    nums = list(range(1, n * n + 1))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = nums.pop(nums.index(n * n - (n - i)))\n            else:\n                matrix[i][j] = nums.pop(nums.index(matrix[i][i] + matrix[j][j] - matrix[i][j] - matrix[j][i]))\n\n    for row in matrix:\n        print(\" \".join(str(x) for x in row))\n\n    return \"\"",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 2213,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    arrays = [list(map(int, stdin.split()[3 + i * m:3 + i * m + m])) for i in range(n)]\n\n    def is_sorted(array, order):\n        for i in range(len(array) - 1):\n            if order == 0 and array[i] > array[i + 1]:\n                return False\n            elif order == 1 and array[i] < array[i + 1]:\n                return False\n        return True\n\n    def sort_arrays(pairs):\n        for i, j in pairs:\n            for array in arrays:\n                if array[i - 1] > array[j - 1]:\n                    array[i - 1], array[j - 1] = array[j - 1], array[i - 1]\n\n    pairs = []\n    for i in range(1, m):\n        for j in range(i + 1, m + 1):\n            pairs.append((i, j))\n\n    sort_arrays(pairs)\n\n    if all(is_sorted(array, k) for array in arrays):\n        return str(len(pairs)) + '\\n' + '\\n'.join([' '.join(map(str, pair)) for pair in pairs])\n    else:\n        return \"No solution found\\n\"",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 2214,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    def is_good(a: List[List[int]]) -> bool:\n        for r1 in range(n):\n            for r2 in range(r1, n):\n                for c1 in range(m):\n                    for c2 in range(c1, m):\n                        if (r2 - r1 + 1) % 2 == 0 and (r2 - r1 + 1) // 2 == (a[r2][c2] - a[r1 - 1][c2] - a[r2][c1 - 1] + a[r1 - 1][c1 - 1]) % 2:\n                            return False\n        return True\n\n    def count_changes(a: List[List[int]]) -> int:\n        changes = 0\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == 1:\n                    a[i][j] = 0\n                    changes += 1\n                    if is_good(a):\n                        return changes\n                    a[i][j] = 1\n                elif a[i][j] == 0:\n                    a[i][j] = 1\n                    changes += 1\n                    if is_good(a):\n                        return changes\n                    a[i][j] = 0\n        return -1\n\n    result = count_changes(a)\n    return str(result)",
        "test": "",
        "num_ids": 391,
        "indeed": false
    },
    {
        "number": 2215,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    segments = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def calculate_beauty(flowers: str) -> int:\n        total_beauty = 0\n        for l, r in segments:\n            segment_beauty = flowers[l - 1:r].count(\"0\") * flowers[l - 1:r].count(\"1\")\n            total_beauty += segment_beauty\n        return total_beauty\n\n    max_beauty = -1\n    max_flowers = \"\"\n\n    for i in range(2 ** n):\n        flowers = bin(i)[2:].zfill(n)\n        beauty = calculate_beauty(flowers)\n        if beauty > max_beauty:\n            max_beauty = beauty\n            max_flowers = flowers\n\n    return max_flowers",
        "test": "",
        "num_ids": 234,
        "indeed": false
    },
    {
        "number": 2216,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    output = []\n\n    def is_valid(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2) == 1\n\n    def dfs(x, y, length, path):\n        if length == 2 * k:\n            output.append(path)\n            return\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in path:\n                dfs(nx, ny, length + 1, path + [(nx, ny)])\n\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            dfs(x, y, 0, [(x, y)])\n\n    for i in range(k):\n        print(len(output[i]), end=' ')\n        for x, y in output[i]:\n            print(x, y, end=' ')\n        print()\n\n    return None",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 2217,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def divisors(n: int) -> List[int]:\n        divs = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divs.append(i)\n        return divs\n\n    def weight(x: int, y: int) -> int:\n        return len([d for d in divisors(x) if d != y and x // d == y and is_prime(x // d)])\n\n    def shortest_paths(v: int, u: int) -> int:\n        graph = defaultdict(list)\n        for x in range(1, D + 1):\n            for y in range(1, x + 1):\n                if x % y == 0:\n                    graph[x].append((y, weight(x, y)))\n        visited = set()\n        queue = [(v, 0, 0)]  # (vertex, weight, depth)\n        while queue:\n            vertex, weight, depth = queue.pop(0)\n            if vertex == u:\n                return depth\n            if (vertex, weight) not in visited:\n                visited.add((vertex, weight))\n                for neighbor, edge_weight in graph[vertex]:\n                    if weight + edge_weight <= 998244353:\n                        queue.append((neighbor, weight + edge_weight, depth + 1))\n        return -1\n\n    D, q = map(int, stdin.split('\\n')[0].split())\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    result = [shortest_paths(v, u) for v, u in queries]\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 536,
        "indeed": false
    },
    {
        "number": 2218,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subsets(s, n, k):\n        subsets = []\n        for i in range(1, 2**n):\n            subset = []\n            for j in range(n):\n                if i & (1 << j):\n                    subset.append(s[j])\n            if len(set(subset)) == k:\n                subsets.append(subset)\n        return subsets\n\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    subsets = find_subsets(a, n, k)\n\n    output = []\n    for subset in subsets:\n        output.append(f\"{len(subset)} {' '.join(map(str, subset))}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 2219,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_steps(n, k):\n        steps = 0\n        while n > 0:\n            if n % k == 0:\n                n //= k\n            else:\n                n -= 1\n            steps += 1\n        return steps - 1\n\n    queries = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    results = [min_steps(n, k) for n, k in queries]\n    return \"\\n\".join(map(str, results))\n",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 2220,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    a.sort(reverse=True)\n    max_happiness = 0\n    happiness = 0\n    prev_emote = -1\n    emote_count = 0\n\n    for i in range(n):\n        if emote_count < m:\n            if a[i] != prev_emote or emote_count >= k:\n                happiness += a[i]\n                max_happiness = max(max_happiness, happiness)\n                prev_emote = a[i]\n                emote_count = 1\n            else:\n                emote_count += 1\n\n    return str(max_happiness)",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 2221,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, n = map(int, stdin.split()[:5])\n    s = stdin.split()[-1]\n\n    dx = [1, -1, 0, 0]\n    dy = [0, 0, 1, -1]\n\n    def move(x, y, direction):\n        return x + dx[direction], y + dy[direction]\n\n    def check_destination(x, y):\n        return x == x2 and y == y2\n\n    days = 0\n    while days < n:\n        x, y = move(x1, y1, \"URDL\".index(s[days % n]))\n        if check_destination(x, y):\n            return str(days + 1)\n        days += 1\n\n    return \"-1\"",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 2222,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    operations = list(map(int, stdin.readline().strip().split()))\n    parents = list(map(int, stdin.readline().strip().split()))\n\n    tree = [[] for _ in range(n)]\n    for i in range(1, n):\n        tree[parents[i - 1]].append(i)\n\n    def dfs(node):\n        if not tree[node]:\n            return 1\n        children_values = [dfs(child) for child in tree[node]]\n        if operations[node] == 0:\n            return min(children_values)\n        else:\n            return max(children_values)\n\n    return str(dfs(0))",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 2223,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_root(parent, u):\n        while parent[u] != u:\n            u = parent[u]\n        return u\n\n    def union(parent, rank, x, y):\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def dfs(graph, visited, u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(graph, visited, v)\n\n    n = int(stdin.readline().strip())\n    edges = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n - 1)]\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    for u, v in edges:\n        union(parent, rank, u, v)\n\n    components = []\n    visited = [False] * (n + 1)\n    for u in range(1, n + 1):\n        if not visited[u]:\n            component = []\n            dfs(graph, visited, u)\n            for i in range(1, n + 1):\n                if visited[i]:\n                    component.append(i)\n            components.append(component)\n\n    even_components = [c for c in components if len(c) % 2 == 0]\n    odd_components = [c for c in components if len(c) % 2 != 0]\n\n    if not odd_components:\n        return 0\n\n    min_edges = n - 1\n    for c in odd_components:\n        for u in c:\n            for v in graph[u]:\n                if v in c:\n                    min_edges += 1\n                    break\n\n    for c in even_components:\n        for u in c:\n            for v in graph[u]:\n                if v in c:\n                    min_edges -= 1\n                    break\n\n    return min_edges if min_edges >= 0 else -1",
        "test": "",
        "num_ids": 638,
        "indeed": false
    },
    {
        "number": 2224,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[0:3])\n    p = list(map(int, stdin.split()[3:3 + m]))\n    paths = [list(map(int, stdin.split()[i:i + 2])) for i in range(3 + m, len(stdin.split()))]\n\n    graph = [[] for _ in range(n + 1)]\n    for path in paths:\n        graph[path[0]].append(path[1])\n        graph[path[1]].append(path[0])\n\n    visited = [False] * (n + 1)\n    reachable_settlements = set()\n\n    def dfs(node, distance):\n        visited[node] = True\n        if distance <= d:\n            reachable_settlements.add(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, distance + 1)\n\n    for p_i in p:\n        for i in range(1, n + 1):\n            if not visited[i]:\n                dfs(i, 0)\n        visited = [False] * (n + 1)\n        reachable_settlements.add(p_i)\n\n    return str(len(reachable_settlements))",
        "test": "",
        "num_ids": 325,
        "indeed": false
    },
    {
        "number": 2225,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    v = a[0]\n\n    for i in range(1, 2 ** n):\n        v |= a[i]\n\n    for _ in range(m):\n        p, b = map(int, stdin.readline().split())\n        a[p - 1] = b\n        v = b\n\n        for i in range(1, 2 ** n):\n            if (i - 1) % 2 == 0:\n                v |= a[i]\n            else:\n                v ^= a[i]\n\n        print(v)\n",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 2226,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split('\\n')[0].split())\n    graph = [[0] * n for _ in range(n)]\n    for i in range(m):\n        v, u, w = map(int, stdin.split('\\n')[i + 1].split())\n        graph[v - 1][u - 1] = w\n        graph[u - 1][v - 1] = w\n\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(1, n + 1):\n        for j in range(n):\n            if graph[i][j] != 0:\n                dp[j + 1] = (dp[j + 1] + dp[i]) % mod\n\n    result = 0\n    for i in range(1, q + 1):\n        result = (result + dp[i]) % mod\n\n    return str(result)",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 2227,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i:i+7] == \"heavymet\":\n            count += 1\n            if i + 7 < len(stdin) and stdin[i+7] == \"a\":\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 2228,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    data = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    alive_count = {}\n    max_alive = 0\n    max_year = None\n\n    for birth, death in data:\n        for year in range(birth, death):\n            alive_count[year] = alive_count.get(year, 0) + 1\n            if alive_count[year] > max_alive:\n                max_alive = alive_count[year]\n                max_year = year\n            elif alive_count[year] == max_alive and year < max_year:\n                max_year = year\n\n    return f\"{max_year} {max_alive}\"",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 2229,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = a.copy()\n\n    for i in range(n):\n        if b[i] < 2:\n            b[i] = 2\n\n    for i in range(n):\n        if i == 0 or GCD(b[i], b[i - 1]) == 1:\n            continue\n        b[i] = b[i - 1] + 1\n        j = i - 1\n        while j >= 0 and b[j] < b[i]:\n            b[j] = b[i] + 1\n            j -= 1\n\n    return ' '.join(map(str, b))\n\ndef",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 2230,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bags = [i for i in range(1, n**2 + 1)]\n    result = []\n\n    for i in range(n):\n        brother_bags = []\n        for j in range(i, n**2, n):\n            brother_bags.append(bags[j])\n        result.append(brother_bags)\n\n    output = \"\"\n    for i in range(n):\n        output += \" \".join(str(x) for x in result[i]) + \"\\n\"\n\n    return output.strip()",
        "test": "",
        "num_ids": 143,
        "indeed": false
    },
    {
        "number": 2231,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_value(sticks):\n        sticks.sort()\n        min_value = float('inf')\n        for i in range(len(sticks) - 3):\n            for j in range(i + 1, len(sticks) - 2):\n                for k in range(j + 1, len(sticks) - 1):\n                    for l in range(k + 1, len(sticks)):\n                        area = sticks[i] * sticks[j]\n                        perimeter = 2 * (sticks[i] + sticks[j])\n                        value = perimeter ** 2 / area\n                        if area == sticks[k] * sticks[l]:\n                            if value < min_value:\n                                min_value = value\n                                min_sticks = [sticks[i], sticks[j], sticks[k], sticks[l]]\n        return min_sticks\n\n    def process_case(n, sticks):\n        return \" \".join(str(x) for x in get_min_value(sticks))\n\n    T = int(stdin.readline())\n    output = []\n    for _ in range(T):\n        n = int(stdin.readline())\n        sticks = list(map(int, stdin.readline().split()))\n        output.append(process_case(n, sticks))\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 345,
        "indeed": false
    },
    {
        "number": 2232,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(u, v):\n        path = [v]\n        while path[-1] != u:\n            path.append(parent[path[-1]])\n        return path[::-1]\n\n    def lca(u, v):\n        if u == v:\n            return u\n        path_u = find_path(u, root)\n        path_v = find_path(v, root)\n        i = 0\n        while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n            i += 1\n        return path_u[i - 1]\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n\n    parent = [0] * (n + 1)\n    root = 1\n    for u, v in edges:\n        parent[v] = u\n\n    max_common = 0\n    max_length = 0\n    result = []\n\n    for i in range(len(edges) - 1):\n        u1, v1 = edges[i]\n        for j in range(i + 1, len(edges)):\n            u2, v2 = edges[j]\n            if lca(u1, v2) != root and lca(u2, v1) != root:\n                path1 = find_path(u1, v1)\n                path2 = find_path(u2, v2)\n                common = len(set(path1) & set(path2))\n                length = len(path1) + len(path2)\n                if common > max_common or (common == max_common and length > max_length):\n                    max_common = common\n                    max_length = length\n                    result = [(u1, v1), (u2, v2)]\n\n    return f\"{result[0][0]} {result[0][1]}\\n{result[1][0]} {result[1][1]}\"",
        "test": "",
        "num_ids": 504,
        "indeed": false
    },
    {
        "number": 2233,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_swap_equal(s: str, t: str) -> bool:\n        if s == t:\n            return True\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    return True\n        return False\n\n    def is_swap_possible(s: str, t: str) -> bool:\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] != t[j]:\n                    if is_swap_equal(s[:i] + t[j] + s[i + 1:], t[:j] + s[i] + t[j + 1:]):\n                        return True\n        return False\n\n    k = int(stdin.readline().strip())\n    result = []\n    for _ in range(k):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        if is_swap_possible(s, t):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 295,
        "indeed": false
    },
    {
        "number": 2234,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_B(n, k):\n        if k == 0:\n            return 0\n        if n == 0:\n            return k\n        if n == k:\n            return 0\n        if n > k:\n            return n - k\n        else:\n            return k - n\n\n    def find_min_steps(n, k):\n        if k == 0:\n            return 0\n        if n == 0:\n            return k\n        if n == k:\n            return 0\n        if n > k:\n            return n - k\n        else:\n            return k - n\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    outputs = []\n    for i in range(1, t + 1):\n        n, k = map(int, lines[i].split())\n        outputs.append(find_min_steps(n, k))\n\n    return '\\n'.join(map(str, outputs))",
        "test": "",
        "num_ids": 234,
        "indeed": false
    },
    {
        "number": 2235,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    trips = [int(t) for t in stdin.split('\\n')[1:]]\n    total_cost = 0\n    result = []\n\n    for i in range(n):\n        if i < n - 1:\n            time_diff = trips[i + 1] - trips[i]\n        else:\n            time_diff = 1\n\n        if i == 0:\n            total_cost += 20\n        elif i == 1:\n            total_cost += 20\n        elif i == 2:\n            total_cost += 10\n        elif time_diff <= 90:\n            total_cost += 20\n        elif time_diff <= 1440:\n            total_cost += 50\n        else:\n            total_cost += 120\n\n        result.append(total_cost - 20 * i)\n\n    return '\\n'.join(str(r) for r in result)",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2236,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    a.sort()\n    operations = 0\n    for i in range(n):\n        if a[i] != 0:\n            operations += abs(a[i])\n            if i > 0:\n                a[i - 1] -= a[i]\n            if i < n - 1:\n                a[i + 1] += a[i]\n            a[i] = 0\n    return str(operations)",
        "test": "",
        "num_ids": 124,
        "indeed": false
    },
    {
        "number": 2237,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magical(x: int, S: set) -> bool:\n        perm = [0] * (2 ** x)\n        for i in range(2 ** x):\n            perm[i] = i\n            for j in range(i):\n                if (perm[i] ^ perm[j]) in S:\n                    perm[i] = i ^ j\n                    break\n            else:\n                return False\n        return True\n\n    n = int(stdin.readline().strip())\n    S = set(map(int, stdin.readline().strip().split()))\n\n    x = 0\n    while not is_magical(x, S):\n        x += 1\n\n    if x == 0:\n        return \"0\\n0\\n\"\n\n    magical_perm = [0] * (2 ** x)\n    for i in range(2 ** x):\n        magical_perm[i] = i\n        for j in range(i):\n            if (magical_perm[i] ^ magical_perm[j]) in S:\n                magical_perm[i] = i ^ j\n                break\n\n    output = f\"{x}\\n\"\n    output += \" \".join(map(str, magical_perm)) + \"\\n\"\n    return output",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 2238,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = \"\"\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            result += \"*\" + \"D\" * n + \"*\" + \"\\n\"\n        elif i == (n - 1) // 2:\n            result += \"*\" * (n - 2) + \"D\" + \"*\" * (n - 2) + \"\\n\"\n        else:\n            result += \"*\" * (n - i - 1) + \"D\" * (2 * i + 1) + \"*\" * (n - i - 1) + \"\\n\"\n    return result[:-1]",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 2239,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1:]))\n    result = []\n    for i in range(t):\n        n = (x[i] + 5) // 6\n        result.append(n)\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 88,
        "indeed": false
    },
    {
        "number": 2240,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    r0 = set(t) - set('0')\n    r1 = set(t) - set('1')\n    pairs = len(r0) * len(r1)\n    return str(pairs)",
        "test": "",
        "num_ids": 65,
        "indeed": false
    },
    {
        "number": 2241,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    joy = 0\n\n    for i in range(n):\n        if b[i] > a[i]:\n            joy -= 1\n        else:\n            joy += a[i] * b[i]\n\n    return str(joy)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2242,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            if int(s[i:j + 1]) % 2019 == 0:\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 2243,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_k_largest(arr: List[int], k: int) -> List[int]:\n        return sorted(range(len(arr)), key=lambda x: arr[x])[-k:]\n\n    def is_in_display(online_friends: List[int], id_: int) -> bool:\n        return id_ in online_friends\n\n    def handle_query(query: str, online_friends: List[int], t_values: List[int]) -> str:\n        query_type, id_ = map(int, query.split())\n        if query_type == 1:\n            online_friends.append(id_)\n            online_friends = sorted(online_friends, key=lambda x: t_values[x], reverse=True)\n            online_friends = online_friends[:k]\n        elif query_type == 2:\n            return \"YES\" if is_in_display(online_friends, id_) else \"NO\"\n        return \"\"\n\n    stdin_list = stdin.split(\"\\n\")\n    n, k, q = map(int, stdin_list[0].split())\n    t_values = list(map(int, stdin_list[1].split()))\n    online_friends = []\n\n    result = []\n    for query in stdin_list[2:]:\n        output = handle_query(query, online_friends, t_values)\n        if output:\n            result.append(output)\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 364,
        "indeed": false
    },
    {
        "number": 2244,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    cycle = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n            elif neighbor != parent and not visited[neighbor - 1]:\n                cycle.append(neighbor)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, -1)\n            if cycle:\n                break\n\n    if cycle:\n        return \"-1\"\n\n    result = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, -1)\n            result.extend(cycle[::-1])\n            result.append(i)\n\n    return \" \".join(map(str, result))\n",
        "test": "",
        "num_ids": 304,
        "indeed": false
    },
    {
        "number": 2245,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_winner(n, k):\n        if n == 0:\n            return \"Bob\"\n        elif n == 1:\n            return \"Alice\"\n        else:\n            if k == 3:\n                return \"Alice\"\n            elif k == 4:\n                return \"Bob\"\n            else:\n                return \"Alice\"\n\n    T = int(stdin.split(\"\\n\")[0])\n    games = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:1 + T]]\n\n    winners = []\n    for game in games:\n        n, k = game\n        winner = find_winner(n, k)\n        winners.append(winner)\n\n    return \"\\n\".join(winners)\n",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2246,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, roads = int(stdin.split(\"\\n\", 1)[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(n)]\n    for u, v in roads:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    def dfs(node, visited):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        paths = [dfs(neighbor, visited) for neighbor in graph[node] if not visited[neighbor]]\n        return 1 + sum(paths) / len(paths) if paths else 1\n\n    return f\"{dfs(0, [False] * n)}\"",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 2247,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_chocolate_bars(s, a, b, c):\n        total_cost = 0\n        chocolate_bars = 0\n        while total_cost <= s:\n            total_cost += a * c\n            chocolate_bars += a\n            a += b\n        return chocolate_bars - b\n\n    t = int(stdin.split('\\n')[0])\n    testcases = stdin.split('\\n')[1:]\n    output = []\n\n    for i in range(t):\n        s, a, b, c = map(int, testcases[i].split())\n        output.append(max_chocolate_bars(s, a, b, c))\n\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 2248,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = [1]\n    max_distance = 0\n\n    while queue:\n        current_node = queue.pop(0)\n        for neighbor in graph[current_node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                max_distance = max(max_distance, current_node - neighbor)\n\n    return str(max_distance)",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 2249,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    a.sort()\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] != a[j]:\n                count += 1\n\n    return str(count)\n",
        "test": "",
        "num_ids": 99,
        "indeed": false
    },
    {
        "number": 2250,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_logical(s: str) -> bool:\n        n = len(s)\n        for i in range(n):\n            if s[i] == 'L':\n                if (i == 0 and s[n - 1] != 'R') or (i > 0 and s[i - 1] != 'R'):\n                    return False\n            elif s[i] == 'R':\n                if (i == n - 1 and s[0] != 'L') or (i < n - 1 and s[i + 1] != 'L'):\n                    return False\n        return True\n\n    def min_talk(s: str) -> int:\n        n = len(s)\n        min_talk = n\n        for i in range(n):\n            if s[i] == 'L':\n                if i == 0:\n                    s_new = 'R' * (n - 1)\n                else:\n                    s_new = s[:i] + 'R' + s[i + 1:]\n                if is_logical(s_new):\n                    min_talk = min(min_talk, n - i)\n            elif s[i] == 'R':\n                if i == n - 1:\n                    s_new = 'L' * (n - 1)\n                else:\n                    s_new = s[:i] + 'L' + s[i + 1:]\n                if is_logical(s_new):\n                    min_talk = min(min_talk, n - i)\n        return min_talk\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        result.append(min_talk(s))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 462,
        "indeed": false
    },
    {
        "number": 2251,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_color(u, v, color, graph, visited):\n        if u == v:\n            return True\n        visited[u] = True\n        for neighbor, c in graph[u]:\n            if not visited[neighbor] and c == color:\n                if find_color(neighbor, v, color, graph, visited):\n                    return True\n        return False\n\n    def bfs(u, v, graph):\n        visited = [False] * (n + 1)\n        color_count = 0\n        for color in range(1, m + 1):\n            if find_color(u, v, color, graph, visited):\n                color_count += 1\n        return color_count\n\n    stdin_list = stdin.split('\\n')\n    n, m = map(int, stdin_list[0].split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, stdin_list[i + 1].split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    q = int(stdin_list[m + 1])\n    result = []\n    for i in range(q):\n        u, v = map(int, stdin_list[m + i + 2].split())\n        result.append(bfs(u, v, graph))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 2252,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    result = []\n\n    for _ in range(m):\n        l, r, x = map(int, stdin.readline().split())\n        if p[x - 1] == x:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n        p_sorted = sorted(p[l - 1:r])\n        for i in range(l - 1, r):\n            p[i] = p_sorted[i - l + 1]\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 2253,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    suffixes = [\"po\", \"desu\", \"masu\", \"mnida\"]\n    lang = [\"FILIPINO\", \"JAPANESE\", \"JAPANESE\", \"KOREAN\"]\n    for line in stdin.split('\\n')[1:]:\n        for i in range(len(suffixes)):\n            if line.endswith(suffixes[i]):\n                print(lang[i])\n                break",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 2254,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_good(l, r):\n        xor_sum = 0\n        for i in range(l, r + 1):\n            xor_sum ^= a[i]\n        return xor_sum == 0\n\n    def count_pairs(l, r):\n        if l == r:\n            return 1 if is_good(l, r) else 0\n        else:\n            mid = (l + r) // 2\n            return count_pairs(l, mid) + count_pairs(mid + 1, r)\n\n    return str(count_pairs(1, n))",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 2255,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited, sequence):\n        visited.add(node)\n        sequence.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, sequence)\n\n    visited = set()\n    sequence = []\n    dfs(1, visited, sequence)\n    return ' '.join(map(str, sorted(sequence)))",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 2256,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_distance(n, x, a, b):\n        if a < b:\n            a, b = b, a\n        if b == 1:\n            return n - 1\n        if b == n:\n            return n - 1\n        if a == n:\n            return n - 1\n        if a == 1:\n            return n - 1\n        return n - 1\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(t):\n        n, x, a, b = map(int, stdin.split('\\n')[i + 1].split())\n        result.append(max_distance(n, x, a, b))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 2257,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, y1, x2, y2 = map(int, stdin.split()[0:5])\n    flowers = [list(map(int, line.split())) for line in stdin.split()[5:]]\n\n    def distance(flower, fountain):\n        return (flower[0] - fountain[0]) ** 2 + (flower[1] - fountain[1]) ** 2\n\n    r1_min = r2_min = 0\n    r1_max = r2_max = float('inf')\n\n    while r1_min <= r1_max and r2_min <= r2_max:\n        r1 = (r1_min + r1_max) // 2\n        r2 = (r2_min + r2_max) // 2\n\n        watered = all(\n            distance(flower, (x1, y1)) <= r1 ** 2 or distance(flower, (x2, y2)) <= r2 ** 2\n            for flower in flowers\n        )\n\n        if watered:\n            r1_max = r1 - 1\n            r2_max = r2 - 1\n        else:\n            r1_min = r1 + 1\n            r2_min = r2 + 1\n\n    return str(min(r1_max ** 2 + r2_max ** 2, r1_min ** 2 + r2_min ** 2))",
        "test": "",
        "num_ids": 355,
        "indeed": false
    },
    {
        "number": 2258,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    def find_inversion(arr):\n        inversions = []\n        for i in range(len(arr) - 1):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    inversions.append((i + 1, j + 1))\n        return inversions\n\n    def find_cycle(inversions):\n        visited = set()\n        for u, v in inversions:\n            if u not in visited:\n                cycle = set()\n                while u not in cycle:\n                    cycle.add(u)\n                    visited.add(u)\n                    u = next(v for v in inversions if u in v)\n                return cycle\n        return None\n\n    def find_hamiltonian_path(inversions):\n        n = len(inversions)\n        adj_matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if inversions[i][1] == inversions[j][0]:\n                    adj_matrix[i][j] = 1\n\n        path = [0] * n\n        for i in range(n):\n            if sum(adj_matrix[i]) == n - 1:\n                path[0] = i\n                break\n\n        for i in range(n - 1):\n            for j in range(n):\n                if adj_matrix[path[i]][j] and j not in path:\n                    path[i + 1] = j\n                    break\n\n        return path if len(set(path)) == n else None\n\n    def find_magical_paper(a):\n        inversions = find_inversion(a)\n        cycle = find_cycle(inversions)\n        if cycle:\n            return sorted(inversions, key=lambda x: x[0])\n        else:\n            path = find_hamiltonian_path(inversions)\n            if path:\n                return [inversions[i] for i in path]\n            else:\n                return []\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if is_sorted(a):\n        return \"-1\"\n    else:\n        magical_paper = find_magical_paper(a)\n        if magical_paper:\n            output = [str(len(magical_paper))] + [\" \".join(map(str, pair)) for pair in magical_paper]\n            return \"\\n\".join(output)\n        else:\n            return \"-1\"",
        "test": "",
        "num_ids": 665,
        "indeed": false
    },
    {
        "number": 2259,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def bubbleSortGraph():\n        graph = set()\n        swapped = True\n        while swapped:\n            swapped = False\n            for i in range(n - 1):\n                if a[i] > a[i + 1]:\n                    graph.add((a[i], a[i + 1]))\n                    a[i], a[i + 1] = a[i + 1], a[i]\n                    swapped = True\n        return graph\n\n    graph = bubbleSortGraph()\n    independent_set = set()\n    vertices = set(a)\n\n    while vertices:\n        vertex = vertices.pop()\n        if vertex not in independent_set:\n            independent_set.add(vertex)\n            for neighbor in graph:\n                if vertex in neighbor:\n                    neighbor_ = neighbor - {vertex}\n                    if neighbor_ in graph:\n                        graph.remove(neighbor_)\n                    vertices.discard(neighbor_)\n\n    return str(len(independent_set))",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 2260,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"00\"\n    elif n == 1:\n        return \"25\"\n    else:\n        last_two_digits = 25\n        for i in range(2, n + 1):\n            last_two_digits = (last_two_digits * 25) % 100\n        return str(last_two_digits).zfill(2)",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 2261,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    n = 2 ** k\n    vectors = []\n\n    for i in range(n):\n        vector = []\n        for j in range(k):\n            if (i >> j) & 1:\n                vector.append(-1)\n            else:\n                vector.append(1)\n        vectors.append(vector)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and all(vectors[i][l] * vectors[j][l] == 0 for l in range(k)):\n                for l in range(k):\n                    print(\"*\" if vectors[i][l] == -1 else \"+\", end=\"\")\n                print()\n\n    return \"\"",
        "test": "",
        "num_ids": 181,
        "indeed": false
    },
    {
        "number": 2262,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1].split()\n    roots = set()\n\n    for word in words:\n        root = ''.join(sorted(set(word)))\n        roots.add(root)\n\n    return str(len(roots))",
        "test": "",
        "num_ids": 78,
        "indeed": true
    },
    {
        "number": 2263,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cost(roads, c1, c2, c3):\n        return roads[c1][c2] + roads[c2][c3] + roads[c3][c1]\n\n    def find_triples(n):\n        return [(i, j, k) for i in range(1, n + 1) for j in range(1, n + 1) for k in range(1, n + 1) if len(set([i, j, k])) == 3]\n\n    def build_roads(n, roads, changes):\n        for change in changes:\n            r, w = change\n            roads[r[0]][r[1]] = w\n        return roads\n\n    def expected_cost(n, roads, changes):\n        triples = find_triples(n)\n        costs = []\n        for triple in triples:\n            c1, c2, c3 = triple\n            cost = find_cost(roads, c1, c2, c3)\n            costs.append(cost)\n        expected = sum(costs) / len(costs)\n        return expected\n\n    def main(stdin: str) -> str:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        roads = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n):\n            a, b, l = map(int, lines[i].split())\n            roads[a][b] = l\n            roads[b][a] = l\n\n        q = int(lines[n])\n        changes = [list(map(int, line.split())) for line in lines[n + 1:n + q + 1]]\n        roads = build_roads(n, roads, changes)\n        costs = [expected_cost(n, roads, changes[:i]) for i in range(1, q + 1)]\n        return \"\\n\".join(f\"{cost:.10f}\" for cost in costs)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 495,
        "indeed": false
    },
    {
        "number": 2264,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_segment(segments: List[List[int]]) -> int:\n        segments.sort(key=lambda x: x[1])\n        shortest_length = float('inf')\n        for i in range(len(segments) - 1):\n            if segments[i][1] > segments[i + 1][0]:\n                shortest_length = min(shortest_length, segments[i + 1][0] - segments[i][1])\n        return shortest_length\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        segments = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n        output.append(find_shortest_segment(segments))\n\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 2265,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    n = len(a)\n    m = len(b)\n    count = 0\n\n    for i in range(n - m + 1):\n        c = a[i:i + m]\n        diff = sum(int(x) != int(y) for x, y in zip(b, c))\n        if diff % 2 == 0:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 114,
        "indeed": true
    },
    {
        "number": 2266,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_police_stations(graph, n, k, p_list):\n        police_stations = [False] * n\n        for p in p_list:\n            police_stations[p - 1] = True\n        return police_stations\n\n    def find_distances(graph, n, k, p_list):\n        distances = [False] * n\n        for i in range(n):\n            if not p_list[i]:\n                distances[i] = bfs(graph, i)\n        return distances\n\n    def bfs(graph, start):\n        visited = [False] * n\n        queue = [(start, 0)]\n        visited[start] = True\n\n        while queue:\n            node, depth = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, depth + 1))\n\n        return visited\n\n    def find_roads_to_shut(graph, n, k, d, p_list, police_stations, distances):\n        roads_to_shut = []\n        for i in range(n - 1):\n            u, v = graph[i]\n            if not (police_stations[u - 1] and police_stations[v - 1]) and distances[u - 1] and distances[v - 1]:\n                roads_to_shut.append(i)\n        return roads_to_shut\n\n    def build_graph(n, edges):\n        graph = [[] for _ in range(n)]\n        for i, (u, v) in enumerate(edges):\n            graph[u - 1].append(v)\n            graph[v - 1].append(u)\n        return graph\n\n    def main(stdin):\n        n, k, d = map(int, stdin.readline().split())\n        p_list = list(map(int, stdin.readline().split()))\n        edges = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n\n        graph = build_graph(n, edges)\n        police_stations = find_police_stations(graph, n, k, p_list)\n        distances = find_distances(graph, n, k, p_list)\n        roads_to_shut = find_roads_to_shut(graph, n, k, d, p_list, police_stations, distances)\n\n        return len(roads_to_shut), roads_to_shut\n\n    s, roads = main(stdin)\n    return f\"{s}\\n{' '.join(map(str, roads))}\"",
        "test": "",
        "num_ids": 662,
        "indeed": false
    },
    {
        "number": 2267,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = []\n    for _ in range(n):\n        strings.append(stdin.readline().strip())\n\n    strings.sort(key=lambda x: (len(x), x))\n    result = ''.join(strings)\n\n    return result",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 2268,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    name = stdin.readline().strip()\n    for _ in range(m):\n        x, y = stdin.readline().strip().split()\n        name = name.replace(x, '_').replace(y, x).replace('_', y)\n    return name",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 2269,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1:]\n    result = []\n\n    for i in range(t):\n        if '1' not in s[i] or '2' not in s[i] or '3' not in s[i]:\n            result.append(0)\n            continue\n\n        min_len = float('inf')\n        for j in range(len(s[i])):\n            for k in range(j + 1, len(s[i]) + 1):\n                substring = s[i][j:k]\n                if '1' in substring and '2' in substring and '3' in substring:\n                    min_len = min(min_len, k - j)\n\n        result.append(min_len)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 210,
        "indeed": true
    },
    {
        "number": 2270,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, q, events = int(stdin.split(\"\\n\")[0]), tuple(map(int, stdin.split(\"\\n\")[1].split())), int(stdin.split(\"\\n\")[2]), list(map(lambda x: x.split(), stdin.split(\"\\n\")[3:]))\n    planks = [0] * (max(a) + 1)\n    for i in a:\n        planks[i] += 1\n    for event in events:\n        if event[0] == \"+\":\n            planks[int(event[1])] += 1\n        else:\n            planks[int(event[1])] -= 1\n        if sum(planks) % 4 != 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")",
        "test": "",
        "num_ids": 193,
        "indeed": false
    },
    {
        "number": 2271,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    edges = [tuple(map(int, line.split())) for line in stdin]\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(n)]\n    for a, b in edges:\n        adj_list[a - 1].append(b)\n        adj_list[b - 1].append(a)\n\n    # Count lifelines\n    lifelines = 0\n    for i in range(n):\n        for j in adj_list[i]:\n            for k in adj_list[i]:\n                if j != k and k in adj_list[j - 1]:\n                    lifelines += 1\n\n    return str(lifelines)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2272,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(a: int, b: int, c: int, d: int) -> bool:\n        return c < a < d or c < b < d\n\n    def find_path(start: int, end: int) -> bool:\n        visited = [False] * (len(intervals) + 1)\n        stack = [(start, 0)]\n\n        while stack:\n            curr, curr_interval = stack.pop()\n            visited[curr] = True\n\n            if curr == end:\n                return True\n\n            for next_interval in range(curr_interval + 1, len(intervals)):\n                if not visited[next_interval] and is_valid_move(intervals[curr][0], intervals[curr][1], intervals[next_interval][0], intervals[next_interval][1]):\n                    stack.append((next_interval, next_interval))\n\n        return False\n\n    intervals = []\n    output = []\n\n    for line in stdin.split('\\n'):\n        query = list(map(int, line.split()))\n\n        if query[0] == 1:\n            intervals.append((query[1], query[2]))\n        elif query[0] == 2:\n            output.append(\"YES\" if find_path(query[1] - 1, query[2] - 1) else \"NO\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 2273,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(v1, v2, v3):\n        for i in range(1, n + 1):\n            if i in v1:\n                for j in range(1, n + 1):\n                    if j in v2 and (i, j) not in edges:\n                        return False\n            elif i in v2:\n                for j in range(1, n + 1):\n                    if j in v3 and (i, j) not in edges:\n                        return False\n        return True\n\n    def find_vertex_sets(v1, v2, v3):\n        for i in range(1, n + 1):\n            if i not in v1 and i not in v2 and i not in v3:\n                if len(v1) < len(v2):\n                    v1.append(i)\n                elif len(v2) < len(v3):\n                    v2.append(i)\n                else:\n                    v3.append(i)\n\n    n, m = map(int, stdin.readline().split())\n    edges = set()\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        edges.add((a, b))\n        edges.add((b, a))\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                v1 = [i, j]\n                v2 = [k]\n                v3 = []\n                find_vertex_sets(v1, v2, v3)\n                if is_valid(v1, v2, v3):\n                    result = [-1] * n\n                    for v in range(1, n + 1):\n                        if v in v1:\n                            result[v - 1] = 1\n                        elif v in v2:\n                            result[v - 1] = 2\n                        else:\n                            result[v - 1] = 3\n                    return \" \".join(map(str, result))\n    return \"-1\"",
        "test": "",
        "num_ids": 528,
        "indeed": false
    },
    {
        "number": 2274,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_cases = int(stdin.split('\\n')[0])\n    result = []\n\n    for case in range(n_cases):\n        n, m = map(int, stdin.split('\\n')[1 + case * (n + 1)].split())\n        grid = [list(stdin.split('\\n')[2 + case * (n + 1) + i]) for i in range(n)]\n\n        # Check if the grid is already functional\n        if is_functional(grid, n, m):\n            result.append(0)\n            continue\n\n        # Try changing each cell and check if the grid becomes functional\n        min_changes = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 'C':\n                    grid[i][j] = 'R' if grid[i][j] == 'D' else 'D'\n                    if is_functional(grid, n, m):\n                        min_changes = min(min_changes, 1)\n                    grid[i][j] = 'C'\n\n        # If no changes make the grid functional, the answer is -1\n        result.append(-1 if min_changes == float('inf') else min_changes)\n\n    return '\\n'.join(map(str, result))\n\ndef",
        "test": "",
        "num_ids": 319,
        "indeed": false
    },
    {
        "number": 2275,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n    for i in range(t):\n        k, s = stdin.readline().split()\n        k = int(k)\n        s = s.strip()\n        angry_students = 0\n        for j in range(k):\n            if s[j] == \"A\":\n                angry_students += 1\n            if j == k - 1 or s[j + 1] == \"A\":\n                angry_students += 1\n        result.append(angry_students)\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 2276,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    a = list(map(int, stdin.readline().strip().split()))\n\n    total_points = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j <= n and s[i] == s[j - 1]:\n            j += 1\n        total_points += a[j - i - 1]\n        s = s[:i] + s[j - 1:]\n        n -= j - i - 1\n        i = max(0, i - 1)\n\n    return str(total_points)",
        "test": "",
        "num_ids": 166,
        "indeed": false
    },
    {
        "number": 2277,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            left = arr[:mid]\n            right = arr[mid:]\n\n            merge_sort(left)\n            merge_sort(right)\n\n            i = j = k = 0\n\n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n                k += 1\n\n            while i < len(left):\n                arr[k] = left[i]\n                i += 1\n                k += 1\n\n            while j < len(right):\n                arr[k] = right[j]\n                j += 1\n                k += 1\n\n    def count_inversions(arr):\n        inversions = 0\n        for i in range(len(arr)):\n            inversions += arr.count(i + 1) - 1\n        return inversions\n\n    n, a, m, queries = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m)\n    queries = [list(map(int, query.split())) for query in queries.split('\\n')]\n\n    merge_sort(a)\n    inversions = count_inversions(a)\n    result = []\n\n    for query in queries:\n        l, r = query\n        l -= 1\n        r -= 1\n        a[l:r + 1] = reversed(a[l:r + 1])\n        inversions = count_inversions(a)\n        result.append('odd' if inversions % 2 else 'even')\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 461,
        "indeed": false
    },
    {
        "number": 2278,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_m_cute(a, b, m):\n        def generate_sequence(a, b, m, k):\n            if k == 1:\n                return [a]\n            prev_seq = generate_sequence(a, b, m, k - 1)\n            seq = [prev_seq[0]]\n            for i in range(1, k):\n                r = min(m, b - prev_seq[i - 1])\n                seq.append(prev_seq[i - 1] + r)\n            return seq\n\n        for k in range(2, 51):\n            seq = generate_sequence(a, b, m, k)\n            if seq[-1] == b:\n                return seq\n        return None\n\n    queries = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    output = []\n\n    for a, b, m in queries:\n        seq = is_m_cute(a, b, m)\n        if seq:\n            output.append(f\"{len(seq)} {' '.join(map(str, seq))}\")\n        else:\n            output.append(\"-1\")\n\n    return \"\\n\".join(output)\n",
        "test": "",
        "num_ids": 295,
        "indeed": false
    },
    {
        "number": 2279,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strengths = [list(map(int, line.strip().split())) for line in stdin]\n\n    teammates = [0] * (2 * n)\n\n    for i in range(1, n + 1):\n        max_strength = 0\n        max_teammate = 0\n        for j in range(1, i):\n            if strengths[i][j - 1] > max_strength and teammates[j] == 0:\n                max_strength = strengths[i][j - 1]\n                max_teammate = j\n        teammates[i] = max_teammate\n        teammates[max_teammate] = i\n\n    return \" \".join(map(str, teammates))",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 2280,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_ladder(planks, k):\n        base_length = sum(sorted(planks)[-2:])\n        if base_length < k + 1:\n            return False\n        steps_length = sum(sorted(planks)[:k])\n        return steps_length >= k\n\n    def find_max_k(planks):\n        left, right = 0, len(planks)\n        while left <= right:\n            mid = (left + right) // 2\n            if is_ladder(planks, mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    T = int(stdin.readline())\n    result = []\n    for _ in range(T):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(find_max_k(a))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 2281,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(range(1, n + 1)) * 2\n    a.sort(key=lambda x: (x - n, -x))\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 2282,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    commands = stdin.readline().strip()\n\n    positions = set()\n    x = 0\n\n    for command in commands:\n        if command == 'L':\n            x -= 1\n        elif command == 'R':\n            x += 1\n        positions.add(x)\n\n    return str(len(positions))",
        "test": "",
        "num_ids": 95,
        "indeed": false
    },
    {
        "number": 2283,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        v, u, w = map(int, stdin.split())\n        graph[v].append((u, w))\n        graph[u].append((v, w))\n\n    def dfs(vertex, visited, subgraph):\n        visited[vertex] = True\n        subgraph.add(vertex)\n        for neighbor, weight in graph[vertex]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, subgraph)\n\n    max_weight = float('-inf')\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        subgraph = set()\n        dfs(i, visited, subgraph)\n        subgraph_weight = sum(a[vertex - 1] for vertex in subgraph)\n        for vertex in subgraph:\n            for neighbor, weight in graph[vertex]:\n                if neighbor in subgraph:\n                    subgraph_weight -= weight\n        max_weight = max(max_weight, subgraph_weight)\n\n    return str(max_weight)",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 2284,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    a.sort()\n    b.sort()\n\n    cost = 0\n    for i in range(k):\n        cost += a[i] + b[i]\n\n    return str(cost)",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 2285,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expand_short_address(short_address: str) -> str:\n        full_address = \"\"\n        blocks = short_address.split(\"::\")\n        if len(blocks) == 1:\n            full_address = blocks[0]\n        else:\n            missing_blocks = 8 - (len(blocks[0].split(\":\")) + len(blocks[1].split(\":\")))\n            full_address = blocks[0]\n            for i in range(missing_blocks):\n                full_address += \":0000\"\n            full_address += \":\" + blocks[1]\n        return full_address\n\n    def restore_full_address(short_address: str) -> str:\n        full_address = expand_short_address(short_address)\n        blocks = full_address.split(\":\")\n        for i in range(len(blocks)):\n            if len(blocks[i]) < 4:\n                blocks[i] = \"0\" * (4 - len(blocks[i])) + blocks[i]\n        return \":\".join(blocks)\n\n    n = int(stdin.readline().strip())\n    short_addresses = [stdin.readline().strip() for _ in range(n)]\n    full_addresses = [restore_full_address(short_address) for short_address in short_addresses]\n    return \"\\n\".join(full_addresses)",
        "test": "",
        "num_ids": 340,
        "indeed": false
    },
    {
        "number": 2286,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_permutations(n: int, wise_men: List[List[int]]) -> int:\n        def generate_permutations(n: int, current: List[int], result: List[List[int]]):\n            if len(current) == n:\n                result.append(current[:])\n                return\n            for i in range(n):\n                if not wise_men[current[-1]][i]:\n                    current.append(i)\n                    generate_permutations(n, current, result)\n                    current.pop()\n\n        permutations = []\n        generate_permutations(n, [0], permutations)\n        return len(permutations)\n\n    def generate_binary_strings(n: int, wise_men: List[List[int]]) -> List[str]:\n        result = []\n        for i in range(2 ** (n - 1)):\n            binary_string = \"\"\n            for j in range(1, n):\n                binary_string += str(wise_men[j - 1][j] ^ 1)\n            result.append(binary_string)\n        return result\n\n    def count_permutations_for_binary_strings(n: int, binary_strings: List[str], wise_men: List[List[int]]) -> List[int]:\n        result = [0] * (2 ** (n - 1))\n        for i, binary_string in enumerate(binary_strings):\n            for j, permutation in enumerate(generate_permutations(n, [0], [])):\n                current_binary_string = \"\"\n                for k in range(1, n):\n                    current_binary_string += str(wise_men[permutation[k - 1]][permutation[k]] ^ 1)\n                if current_binary_string == binary_string:\n                    result[i] += 1\n        return result\n\n    def main(stdin: str) -> str:\n        n, *wise_men_input = stdin.split(\"\\n\")\n        n = int(n)\n        wise_men = [[int(x) for x in row] for row in wise_men_input]\n\n        binary_strings = generate_binary_strings(n, wise_men)\n        permutation_count = count_permutations(n, wise_men)\n        result = count_permutations_for_binary_strings(n, binary_strings, wise_men)\n\n        return \" \".join(str(x) for x in result)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 604,
        "indeed": false
    },
    {
        "number": 2287,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        s = stdin.readline().strip()\n        zero_count = s.count('0')\n        if '1' not in s:\n            result.append(zero_count)\n        else:\n            zero_in_ones = 0\n            start_index = s.index('1')\n            end_index = s.rindex('1')\n\n            for i in range(start_index, end_index + 1):\n                if s[i] == '0':\n                    zero_in_ones += 1\n\n            result.append(zero_count - zero_in_ones)\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2288,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_sort(a: List[int], b: List[int]) -> bool:\n        for i in range(len(a) - 1):\n            if a[i] > a[i + 1] and b[i] == b[i + 1]:\n                return False\n        return True\n\n    def swap(a: List[int], b: List[int], i: int, j: int) -> None:\n        a[i], a[j] = a[j], a[i]\n        b[i], b[j] = b[j], b[i]\n\n    for _ in range(int(stdin.pop(0))):\n        n = int(stdin.pop(0))\n        a = list(map(int, stdin.pop(0).split()))\n        b = list(map(int, stdin.pop(0).split()))\n\n        if can_sort(a, b):\n            print(\"Yes\")\n        else:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if b[i] != b[j]:\n                        swap(a, b, i, j)\n                        if can_sort(a, b):\n                            print(\"Yes\")\n                            break\n                else:\n                    continue\n                break\n            else:\n                print(\"No\")\n",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 2289,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    k = list(map(int, stdin.readline().split()))\n\n    for i in range(q):\n        for j in range(n):\n            if a[j] <= k[i]:\n                a[j] = 0\n            else:\n                a[j] -= k[i]\n\n        while a and a[0] == 0:\n            a.pop(0)\n\n        print(len(a))\n\n    return \"\"",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2290,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        t = parent[i]\n        if t < 0:\n            return i\n        t = find(parent, t)\n        parent[i] = t\n        return t\n\n    def merge(parent, size, x, y):\n        x = find(parent, x)\n        y = find(parent, y)\n        if x == y:\n            return False\n        if size[x] < size[y]:\n            x, y = y, x\n        parent[y] = x\n        size[x] += size[y]\n        return True\n\n    def kruskal(n, edges):\n        parent = [-1] * (n + 1)\n        size = [1] * (n + 1)\n        edges.sort(key=lambda e: e[2])\n        added = []\n        for u, v, w in edges:\n            if merge(parent, size, u, v):\n                added.append((u, v, w))\n        return added\n\n    n, m = map(int, stdin.readline().split())\n    edges = [list(map(int, stdin.readline().split())) + [i] for i in range(m)]\n    added_edges = kruskal(n, edges)\n\n    for u, v, w in added_edges:\n        for l in range(1, u):\n            for r in range(v + 1, n + 1):\n                if not merge(parent, size, l, r):\n                    return w\n    return 0",
        "test": "",
        "num_ids": 372,
        "indeed": false
    },
    {
        "number": 2291,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_xor = float('inf')\n\n    for i in range(n):\n        current_xor = 0\n        for j in range(n):\n            if i != j:\n                current_xor ^= a[j]\n        max_xor = min(max_xor, current_xor)\n\n    return str(max_xor)",
        "test": "",
        "num_ids": 126,
        "indeed": false
    },
    {
        "number": 2292,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap(a: List[int], k: int) -> List[int]:\n        return a[:k] + a[-k:]\n\n    def is_valid(a: List[int], b: List[int]) -> bool:\n        for k in range(1, (n + 1) // 2 + 1):\n            if swap(a, k) == b:\n                return True\n        return False\n\n    lines = stdin.splitlines()\n    t = int(lines[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(lines[i * 3 - 2])\n        a = list(map(int, lines[i * 3 - 1].split()))\n        b = list(map(int, lines[i * 3].split()))\n\n        if is_valid(a, b):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 2293,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    dora_buys = [list(map(int, stdin.readline().split()))[1:] for _ in range(m)]\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    for i in range(n):\n        a_i = 1\n        while True:\n            dora_lcm = a_i\n            swiper_lcm = a_i\n            for j in range(m):\n                if i + 1 in dora_buys[j]:\n                    dora_lcm = lcm(dora_lcm, a_i)\n                else:\n                    swiper_lcm = lcm(swiper_lcm, a_i)\n            if dora_lcm > swiper_lcm:\n                break\n            a_i += 1\n\n        if a_i == n:\n            return \"impossible\"\n\n    return \"possible\"",
        "test": "",
        "num_ids": 294,
        "indeed": false
    },
    {
        "number": 2294,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    queries = [list(map(int, query.split())) for query in stdin.split('\\n')[1:]]\n    multiset = {}\n    time_machine = {}\n\n    for query in queries:\n        a, t, x = query\n        if a == 1:\n            if t not in time_machine:\n                time_machine[t] = {'add': [], 'remove': [], 'count': []}\n            time_machine[t]['add'].append(x)\n        elif a == 2:\n            if t not in time_machine:\n                time_machine[t] = {'add': [], 'remove': [], 'count': []}\n            time_machine[t]['remove'].append(x)\n        else:\n            if t not in time_machine:\n                time_machine[t] = {'add': [], 'remove': [], 'count': []}\n            time_machine[t]['count'].append(x)\n\n    for t in sorted(time_machine.keys()):\n        for x in time_machine[t]['add']:\n            if x not in multiset:\n                multiset[x] = 0\n            multiset[x] += 1\n        for x in time_machine[t]['remove']:\n            if x in multiset:\n                multiset[x] -= 1\n        for x in time_machine[t]['count']:\n            print(multiset.get(x, 0))\n\n    return ''",
        "test": "",
        "num_ids": 362,
        "indeed": false
    },
    {
        "number": 2295,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def expected_unique_elements(l, r):\n        if l > r:\n            l, r = r, l\n        unique_elements = set(a[l - 1:r])\n        return len(unique_elements)\n\n    expected_value = sum([expected_unique_elements(i, j) for i in range(1, n + 1) for j in range(1, n + 1)]) / (n * n)\n\n    return f\"{expected_value:.6f}\"",
        "test": "",
        "num_ids": 158,
        "indeed": true
    },
    {
        "number": 2296,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def rotate(x, y, angle):\n        return x * angle, y * angle\n\n    def angle_between_vectors(x1, y1, x2, y2):\n        dot_product = x1 * x2 + y1 * y2\n        denominator = distance(0, 0, x1, y1) * distance(0, 0, x2, y2)\n        return math.acos(dot_product / denominator)\n\n    def find_center_of_mass(vertices):\n        center_x, center_y = 0, 0\n        area = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            cross_product = x1 * y2 - x2 * y1\n            center_x += (x1 + x2) * cross_product\n            center_y += (y1 + y2) * cross_product\n            area += cross_product\n        area = abs(area) / 2\n        center_x = center_x / (6 * area)\n        center_y = center_y / (6 * area)\n        return center_x, center_y\n\n    def find_moment_of_inertia(center_of_mass, vertices):\n        moment_of_inertia = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            cross_product = x1 * y2 - x2 * y1\n            moment_of_inertia += (\n                cross_product\n                * (\n                    (x1 ** 2 + y1 ** 2)\n                    + (x1 * x2 + y1 * y2)\n                )\n            )\n        moment_of_inertia = abs(moment_of_inertia) / 12\n        return moment_of_inertia\n\n    def find_max_distance(center_of_mass, vertices):\n        max_distance = 0\n        for x, y in vertices:\n            max_distance = max(max_distance, distance(x, y, center_of_mass[0], center_of_mass[1]))\n        return max_distance\n\n    def find_max_pin_distance(center_of_mass, vertices):\n        max_pin_distance = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            cross_product = x1 * y2 - x2 * y1\n            if cross_product < 0:\n                max_pin_distance = max(max_pin_distance, abs(cross_product))\n        return max_pin_distance\n\n    def find_max_angle(center_of_mass, vertices):\n        max_angle = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            angle = angle_between_vectors(x1 - center_of_mass[0], y1 - center_of_mass[1], x2 - center_of_mass[0], y2 - center_of_mass[1])\n            max_angle = max(max_angle, angle)\n        return max_angle\n\n    def find_max_angular_momentum(center_of_mass, vertices):\n        angular_momentum = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            cross_product = x1 * y2 - x2 * y1\n            angular_momentum += cross_product * (x1 ** 2 + y1 ** 2)\n        angular_momentum = abs(angular_momentum) / 2\n        return angular_momentum\n\n    def find_max_torque(center_of_mass, vertices",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 2297,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sum(l, r):\n        if l % 2 == 1:\n            return (r - l + 1) * (l + r) // 2\n        else:\n            return (r - l + 1) * (l + r) // 2 - (r - l + 1) * l\n\n    queries = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = []\n\n    for l, r in queries:\n        if l == r:\n            result.append(l * (-1) ** (l + 1))\n        else:\n            result.append(calculate_sum(l, r))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 182,
        "indeed": false
    },
    {
        "number": 2298,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x: int, a: int, b: int) -> bool:\n        return (x % a) % b != (x % b) % a\n\n    def count_valid_numbers(l: int, r: int, a: int, b: int) -> int:\n        return sum(1 for x in range(l, r + 1) if is_valid(x, a, b))\n\n    test_cases = stdin.strip().split('\\n')\n    result = []\n\n    for test_case in test_cases:\n        a, b, q, *queries = map(int, test_case.split())\n        query_results = []\n\n        for i in range(0, len(queries), 2):\n            l, r = queries[i], queries[i + 1]\n            query_results.append(count_valid_numbers(l, r, a, b))\n\n        result.append(query_results)\n\n    return '\\n'.join(' '.join(map(str, res)) for res in result)\n",
        "test": "",
        "num_ids": 253,
        "indeed": false
    },
    {
        "number": 2299,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = []\n    for _ in range(n):\n        table.append(list(map(int, stdin.readline().split())))\n    k = int(stdin.readline())\n    result = []\n    for _ in range(k):\n        l, r = map(int, stdin.readline().split())\n        is_sorted = False\n        for j in range(m):\n            for i in range(l - 1, r - 1):\n                if table[i][j] > table[i + 1][j]:\n                    break\n                if i == r - 2:\n                    is_sorted = True\n                    break\n            if is_sorted:\n                break\n        result.append(\"Yes\" if is_sorted else \"No\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 2300,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(i: int) -> int:\n        if i <= 1:\n            return 1\n        return f(i - 1) - 1 + f(i - 2)\n\n    def calculate_sum(a: List[int], l: int, r: int) -> int:\n        return sum(a[l:r]) % 1000000000\n\n    def increase_value(a: List[int], l: int, r: int, d: int) -> None:\n        for i in range(l - 1, r):\n            a[i] += d\n\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    for _ in range(m):\n        t = int(stdin.readline())\n        if t == 1:\n            x, v = map(int, stdin.readline().split())\n            a[x - 1] = v\n        elif t == 2:\n            l, r = map(int, stdin.readline().split())\n            print(calculate_sum(a, l - 1, r))\n        elif t == 3:\n            l, r, d = map(int, stdin.readline().split())\n            increase_value(a, l, r + 1, d)\n\n    return \"\"",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 2301,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    prices = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_cheap(i: int) -> bool:\n        return i > 0 and i < n - 1 and prices[i] < prices[i - 1] and prices[i] < prices[i + 1]\n\n    cheap_spheres = [i for i in range(n) if is_cheap(i)]\n    cheap_spheres_count = len(cheap_spheres)\n\n    cheap_spheres_prices = [prices[i] for i in cheap_spheres]\n    cheap_spheres_prices.sort()\n\n    return f\"{cheap_spheres_count}\\n{' '.join(map(str, cheap_spheres_prices))}\"",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 2302,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_turns(n: int, a: List[int], q: int, updates: List[Tuple[int, int, int]]) -> List[int]:\n        milestones = []\n        for i in range(q):\n            s, t, u = updates[i]\n            for j in range(len(milestones)):\n                if milestones[j][0] == s and milestones[j][1] == t:\n                    milestones.pop(j)\n                    break\n            if u != 0:\n                milestones.append((s, t, u))\n            turns = float('inf')\n            for i in range(n):\n                if a[i] > 0:\n                    turns = min(turns, (a[i] - 1) // t + 1)\n            for s, t, u in milestones:\n                if a[s] >= t:\n                    a[u] += 1\n            for i in range(n):\n                if a[i] > 0:\n                    turns = min(turns, (a[i] - 1) // t + 1)\n            yield turns\n\n    input_list = list(map(int, stdin.split()))\n    n, a, q = input_list[0], input_list[1:n + 1], input_list[n + 1]\n    updates = [tuple(input_list[i:i + 3]) for i in range(n + 2, len(input_list), 3)]\n    result = list(min_turns(n, a, q, updates))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 401,
        "indeed": false
    },
    {
        "number": 2303,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.strip().split()\n    return \" \".join(reversed(words))",
        "test": "",
        "num_ids": 25,
        "indeed": false
    },
    {
        "number": 2304,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start):\n        visited = [False] * len(graph)\n        q = [(start, 0)]\n        while q:\n            node, dist = q.pop(0)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    q.append((neighbor, dist + weight))\n                elif dist + weight < min_dist[neighbor]:\n                    min_dist[neighbor] = dist + weight\n                    if neighbor in path:\n                        path.remove(neighbor)\n                    path.append(neighbor)\n                    if neighbor == start:\n                        return True\n        return False\n\n    def bellman_ford(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        for _ in range(len(graph) - 1):\n            for node in range(len(graph)):\n                for neighbor, weight in graph[node]:\n                    if dist[node] != float('inf') and dist[node] + weight < dist[neighbor]:\n                        dist[neighbor] = dist[node] + weight\n        for node in range(len(graph)):\n            for neighbor, weight in graph[node]:\n                if dist[node] != float('inf') and dist[node] + weight < dist[neighbor]:\n                    return None\n        return dist\n\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        L, R, D = map(int, stdin.readline().split())\n        graph[L - 1].append((R - 1, D))\n        graph[R - 1].append((L - 1, -D))\n\n    min_dist = [float('inf')] * N\n    path = []\n    for i in range(N):\n        if find_cycle(graph, i):\n            return \"No\"\n        if min_dist[i] == float('inf'):\n            min_dist[i] = 0\n        if i in path:\n            path.remove(i)\n            path.append(i)\n\n    dist = bellman_ford(graph, 0)\n    if dist is None:\n        return \"No\"\n    return \"Yes\"",
        "test": "",
        "num_ids": 582,
        "indeed": false
    },
    {
        "number": 2305,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, parent: int) -> tuple:\n        vis = [False] * (n + 1)\n        vis[u] = True\n        subtree = [u]\n        for v in adj[u]:\n            if v != parent:\n                subtree.extend(dfs(v, u))\n        return subtree\n\n    def count_paths(u: int, color: int) -> int:\n        vis = [False] * (n + 1)\n        vis[u] = True\n        count = 0\n        for v in adj[u]:\n            if not vis[v]:\n                if color_map[v] == color:\n                    count += 1\n                count += count_paths(v, color)\n        return count\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    color_map = list(map(int, lines[1].split()))\n    adj = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        u, v = map(int, lines[i].split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    subtree = dfs(1, -1)\n    result = []\n    for k in range(1, n + 1):\n        count = 0\n        for u in subtree:\n            if color_map[u] == k:\n                count += 1\n            count += count_paths(u, k)\n        result.append(count)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 387,
        "indeed": false
    },
    {
        "number": 2306,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t, v = map(int, stdin.split())\n    total_time = sum(t)\n    max_distance = 0\n\n    for i in range(1, N + 1):\n        acceleration_time = t[0]\n        acceleration = (v[i] - v[i - 1]) / acceleration_time\n\n        if abs(acceleration) > 1:\n            break\n\n        acceleration_distance = v[i - 1] * acceleration_time + 0.5 * acceleration * (acceleration_time ** 2)\n        max_distance += acceleration_distance\n\n        for j in range(1, N):\n            constant_velocity_time = t[j] - t[j - 1]\n            constant_velocity_distance = v[j] * constant_velocity_time\n            max_distance += constant_velocity_distance\n\n        deceleration_time = t[-1] - t[-2]\n        deceleration = (v[-1] - v[-2]) / deceleration_time\n\n        if abs(deceleration) > 1:\n            break\n\n        deceleration_distance = v[-1] * deceleration_time + 0.5 * deceleration * (deceleration_time ** 2)\n        max_distance += deceleration_distance\n\n        if i == N:\n            return '{:.12f}'.format(max_distance)\n\n    return '0.0000000000000'",
        "test": "",
        "num_ids": 366,
        "indeed": false
    },
    {
        "number": 2307,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    even_count = 0\n    odd_count = 0\n\n    for i in range(N):\n        if A[i] % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    if even_count > odd_count:\n        return \"READY FOR BATTLE\"\n    else:\n        return \"NOT READY\"",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 2308,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_to_decimal(binary: str) -> int:\n        decimal = 0\n        for digit in binary:\n            decimal = decimal * 2 + int(digit)\n        return decimal\n\n    def decimal_to_binary(decimal: int) -> str:\n        if decimal == 0:\n            return \"0\"\n        binary = \"\"\n        while decimal > 0:\n            binary = str(decimal % 2) + binary\n            decimal //= 2\n        return binary\n\n    def reverse_binary(binary: str) -> str:\n        return binary[::-1]\n\n    def find_min_lexicographically(x: str, y: str) -> int:\n        x_decimal = binary_to_decimal(x)\n        y_decimal = binary_to_decimal(y)\n        k = 0\n        while True:\n            s_k = x_decimal + y_decimal * (2 ** k)\n            s_k_binary = decimal_to_binary(s_k)\n            rev_k = reverse_binary(s_k_binary)\n            if rev_k < decimal_to_binary(x_decimal):\n                return k\n            k += 1\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        x = stdin.readline().strip()\n        y = stdin.readline().strip()\n        result.append(find_min_lexicographically(x, y))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 378,
        "indeed": false
    },
    {
        "number": 2309,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_vowels(word: str) -> int:\n        vowels = \"aeiou\"\n        return sum(1 for char in word if char in vowels)\n\n    def is_beautiful_lyric(line1: str, line2: str) -> bool:\n        words1 = line1.split()\n        words2 = line2.split()\n        return (\n            count_vowels(words1[0]) == count_vowels(words2[0])\n            and count_vowels(words1[1]) == count_vowels(words2[1])\n            and words1[0][-1] == words2[0][-1]\n            and words1[1][-1] == words2[1][-1]\n        )\n\n    def find_beautiful_lyrics(words: List[str], used_words: Set[str]) -> List[str]:\n        lyrics = []\n        for i, word1 in enumerate(words):\n            if word1 in used_words:\n                continue\n            for j, word2 in enumerate(words):\n                if j <= i or word2 in used_words:\n                    continue\n                for k, word3 in enumerate(words):\n                    if k <= j or word3 in used_words:\n                        continue\n                    for l, word4 in enumerate(words):\n                        if l <= k or word4 in used_words:\n                            continue\n                        line1 = f\"{word1} {word2}\"\n                        line2 = f\"{word3} {word4}\"\n                        if is_beautiful_lyric(line1, line2):\n                            lyrics.append(f\"{line1}\\n{line2}\\n\")\n                            used_words.add(word1)\n                            used_words.add(word2)\n                            used_words.add(word3)\n                            used_words.add(word4)\n        return lyrics\n\n    n = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(n)]\n\n    lyrics = find_beautiful_lyrics(words, set())\n    m = len(lyrics)\n\n    output = [str(m)] + lyrics\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 556,
        "indeed": false
    },
    {
        "number": 2310,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_run_out(m, k, a, observations):\n        available = [True] * k\n        for j, (t, r) in enumerate(observations):\n            if t > 0:\n                available[t - 1] = False\n            if r == 1 and sum(a) <= m + j:\n                return \"N\" * k\n        result = []\n        for i in range(k):\n            if available[i] and sum(a) <= m + i:\n                result.append(\"Y\")\n            else:\n                result.append(\"N\")\n        return \"\".join(result)\n\n    def process_input_set(stdin: str) -> str:\n        lines = stdin.split(\"\\n\")\n        m, k = map(int, lines[1].split())\n        a = list(map(int, lines[2].split()))\n        observations = [list(map(int, line.split())) for line in lines[3:]]\n        return can_run_out(m, k, a, observations)\n\n    input_sets = stdin.split(\"\\n\\n\")\n    result = [process_input_set(input_set) for input_set in input_sets[1:]]\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 301,
        "indeed": false
    },
    {
        "number": 2311,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n\n    def count_ones(x1, x2, y1, y2):\n        return sum(c[i][y1:y2+1] for i in range(x1, x2+1))\n\n    result = 0\n    for x1 in range(n):\n        for x2 in range(x1, n):\n            for y1 in range(m):\n                for y2 in range(y1, m):\n                    if count_ones(x1, x2, y1, y2) == k:\n                        result += 1\n\n    return str(result)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 2312,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_wrong(a: List[int], n: int) -> bool:\n        sums = [0] * (n + 1)\n        for i in range(n):\n            sums[i + 1] = sums[i] + a[i]\n\n        for i in range(1, n - 1):\n            for j in range(i + 1, n):\n                if sums[i] == sums[j] and sums[j] == sums[i + 1] - sums[j]:\n                    return True\n        return False\n\n    def process_case(b: List[int]) -> str:\n        a = [2 ** x for x in b]\n        if is_wrong(a, len(a)):\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(cases):\n        n = int(stdin.readline().strip())\n        b = list(map(int, stdin.readline().strip().split()))\n        output.append(process_case(b))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 278,
        "indeed": false
    },
    {
        "number": 2313,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n\n    p = 1\n    q = 1\n    for k in range(1, n + 1):\n        min_expected_value = float(\"inf\")\n        for i in range(n):\n            mimics = [False] * n\n            mimics[i] = True\n            for j in range(k - 1):\n                mimics[j % n] = True\n            expected_value = sum(c[i] for i in range(n) if not mimics[i % n])\n            if expected_value < min_expected_value:\n                min_expected_value = expected_value\n        p *= min_expected_value\n        q *= lcm(q, min_expected_value)\n\n    p %= 998244353\n    q %= 998244353\n    result = [str(p * pow(q, -1, 998244353)) for _ in range(n)]\n    return \" \".join(result) + \" 0\"",
        "test": "",
        "num_ids": 342,
        "indeed": false
    },
    {
        "number": 2314,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_logo(matrix, r1, c1, r2, c2):\n        for i in range(r1, r2 - 3):\n            for j in range(c1, c2 - 3):\n                if matrix[i][j] == 'R' and matrix[i][j + 1] == 'G' and matrix[i + 1][j] == 'Y' and matrix[i + 1][j + 1] == 'B':\n                    return True\n        return False\n\n    def count_valid_logos(matrix, r1, c1, r2, c2):\n        count = 0\n        for i in range(r1, r2 - 3):\n            for j in range(c1, c2 - 3):\n                if matrix[i][j] == 'R' and matrix[i][j + 1] == 'G' and matrix[i + 1][j] == 'Y' and matrix[i + 1][j + 1] == 'B':\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    n, m, q = map(int, lines[0].split())\n    matrix = [list(line) for line in lines[1:n + 1]]\n    options = [list(map(int, line.split())) for line in lines[n + 1:n + q + 1]]\n\n    result = []\n    for r1, c1, r2, c2 in options:\n        if is_valid_logo(matrix, r1, c1, r2, c2):\n            result.append(count_valid_logos(matrix, r1, c1, r2, c2))\n        else:\n            result.append(0)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 438,
        "indeed": false
    },
    {
        "number": 2315,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_pair(l, r):\n        for y in range(r, l - 1, -1):\n            for x in range(l, y):\n                if y % x == 0:\n                    return x, y\n        return None\n\n    T = int(stdin.readline())\n    output = []\n\n    for _ in range(T):\n        l, r = map(int, stdin.readline().split())\n        pair = find_pair(l, r)\n        output.append(f\"{pair[0]} {pair[1]}\\n\")\n\n    return \"\".join(output)\n",
        "test": "",
        "num_ids": 151,
        "indeed": false
    },
    {
        "number": 2316,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def void_absorption(h):\n        return (h // 2) + 10\n\n    def lightning_strike(h):\n        return h - 10\n\n    def can_defeat_dragon(x, n, m):\n        if n == 0 and m == 0:\n            return False\n\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i == 0 and j == 0:\n                    continue\n\n                h = x\n                for _ in range(i):\n                    h = void_absorption(h)\n                for _ in range(j):\n                    h = lightning_strike(h)\n\n                if h <= 0:\n                    return True\n\n        return False\n\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        x, n, m = map(int, stdin.readline().split())\n        if can_defeat_dragon(x, n, m):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 289,
        "indeed": false
    },
    {
        "number": 2317,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split()[0].split())\n    y = list(map(int, stdin.split()[1].split()))\n    y_prime = list(map(int, stdin.split()[2].split()))\n    l = list(map(int, stdin.split()[3].split()))\n\n    min_distance = float('inf')\n    min_west_point = -1\n    min_east_point = -1\n\n    for i in range(n):\n        for j in range(m):\n            distance = abs(y[i]) + abs(a - y_prime[j]) + l[j]\n            if distance < min_distance:\n                min_distance = distance\n                min_west_point = i + 1\n                min_east_point = j + 1\n\n    return f\"{min_west_point} {min_east_point}\"",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2318,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = stdin.split('\\n')[1:]\n    result = []\n\n    for i in range(n):\n        s, t = pairs[i*2], pairs[i*2+1]\n        if len(s) > len(t):\n            result.append(\"NO\")\n            continue\n\n        for j in range(len(s)):\n            if s[j] != t[j]:\n                result.append(\"NO\")\n                break\n        else:\n            result.append(\"YES\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 2319,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(s: str, l: int, r: int) -> str:\n        return s[:l] + s[r:] + s[l:r]\n\n    def is_substring(s: str, t: str) -> bool:\n        return s in t\n\n    def min_operations(s: str, t: str) -> int:\n        if s == t:\n            return 0\n\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if is_substring(rotate(s, i, j), t):\n                    return 1 + min_operations(rotate(s, i, j), t)\n        return -1\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        result.append(min_operations(s, t))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 2320,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(s: str, t: str) -> bool:\n        s_dict = {}\n        for char in s:\n            s_dict[char] = s_dict.get(char, 0) + 1\n        \n        for char in t:\n            if char not in s_dict or s_dict[char] == 0:\n                return False\n            s_dict[char] -= 1\n        \n        return True\n\n    def min_moves(s: str, t: str) -> int:\n        if not is_possible(s, t):\n            return -1\n        \n        moves = 0\n        i = 0\n        while i < len(s) and s[i] == t[i]:\n            i += 1\n        moves += i\n\n        j = len(s) - 1\n        while j >= 0 and s[j] == t[j]:\n            j -= 1\n        moves += len(s) - j - 1\n\n        return moves\n\n    q = int(stdin.readline().strip())\n    result = []\n    for _ in range(q):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        result.append(min_moves(s, t))\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 2321,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n\n        if n == 1:\n            result.append(0)\n            continue\n\n        count_left = s.count('<')\n        count_right = s.count('>')\n\n        if count_left == 1 and count_right == 1:\n            result.append(0)\n            continue\n\n        if count_left == 0 or count_right == 0:\n            result.append(n - 1)\n            continue\n\n        if count_left == 1 or count_right == 1:\n            result.append(n - 2)\n            continue\n\n        result.append(n - 3)\n\n    return '\\n'.join(map(str, result))\n",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 2323,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, tuning, q, *queries = map(int, stdin.split())\n    matrix = [[i + j for j in range(10**18 + 1)] for i in tuning]\n    result = []\n\n    for l, r in queries:\n        pitches = set()\n        for string in matrix:\n            pitches.update(string[l : r + 1])\n        result.append(len(pitches))\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 2324,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    palindromic_characteristics = [0] * n\n\n    for i in range(n):\n        dp[i][i] = 1\n        palindromic_characteristics[1] += 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 1\n                    palindromic_characteristics[2] += 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n            for k in range(3, length + 1):\n                if dp[i][j] == k:\n                    palindromic_characteristics[k] += 1\n\n    return ' '.join(map(str, palindromic_characteristics))\n",
        "test": "",
        "num_ids": 320,
        "indeed": false
    },
    {
        "number": 2325,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_factorizations(x: int, y: int) -> int:\n        if x == 1:\n            return 1\n        if y == 1:\n            return 1\n        if x == y:\n            return 1\n        if x % y == 0:\n            return (count_factorizations(x // y, y) + count_factorizations(x, y - 1)) % (10**9 + 7)\n        else:\n            return count_factorizations(x, y - 1)\n\n    q = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, q + 1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        result.append(count_factorizations(x, y))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 2326,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_good_array(sub_arr):\n        if sub_arr[0] != len(sub_arr) - 1 or sub_arr[0] < 1:\n            return False\n        for i in range(1, len(sub_arr)):\n            if sub_arr[i] < 0:\n                return False\n        return True\n\n    def count_good_subsequences(arr):\n        n = len(arr)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                sub_arr = arr[i:j]\n                if is_good_array(sub_arr):\n                    dp[j] += dp[i]\n            dp[i + 1] %= 998244353\n\n        return dp[n]\n\n    return str(count_good_subsequences(arr))",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 2327,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bin_diff(a: int, b: int) -> int:\n        return bin(a ^ b).count('1')\n\n    def unfairness(n: int) -> int:\n        return sum(bin_diff(i, i + 1) for i in range(n - 1))\n\n    t = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n')[1:]\n    output = [str(unfairness(int(line))) for line in lines]\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 2328,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f_k(x, a, k):\n        d = sorted([abs(x - a_i) for a_i in a])\n        return d[k]\n\n    def binary_search(a, k):\n        left, right = min(a), max(a)\n        while left < right:\n            mid = (left + right) // 2\n            if f_k(mid, a, k) > f_k(mid + 1, a, k):\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    T = int(stdin.readline())\n    output = []\n    for _ in range(T):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        output.append(binary_search(a, k))\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 2329,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_towers(towers, a, b):\n        return sorted([*towers[a], *towers[b]], reverse=True)\n\n    def calculate_difficulty(towers):\n        difficulty = 0\n        for i in range(len(towers) - 1):\n            for j in range(i + 1, len(towers)):\n                if towers[i][-1] < towers[j][-1]:\n                    difficulty += 1\n                    break\n        return difficulty\n\n    n, m = map(int, stdin.readline().split())\n    tower_indices = list(map(int, stdin.readline().split()))\n    towers = [[] for _ in range(m)]\n\n    for i, index in enumerate(tower_indices):\n        towers[index - 1].append(i + 1)\n\n    difficulties = [calculate_difficulty(towers)]\n\n    for _ in range(m - 1):\n        a, b = map(int, stdin.readline().split())\n        towers[a - 1] = merge_towers(towers, a - 1, b - 1)\n        difficulties.append(calculate_difficulty(towers))\n\n    return \"\\n\".join(map(str, difficulties))",
        "test": "",
        "num_ids": 329,
        "indeed": false
    },
    {
        "number": 2330,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_private(fridge_status, n, m):\n        for i in range(1, n + 1):\n            if fridge_status[i] == 0:\n                return False\n            if fridge_status[i] == 2:\n                return False\n        return True\n\n    def dfs(fridge_status, n, m, cost, ans):\n        if cost >= ans[0]:\n            return\n        if m == 0:\n            if is_private(fridge_status, n, m):\n                ans[0] = min(ans[0], cost)\n            return\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j and fridge_status[i] != 2 and fridge_status[j] != 2:\n                    fridge_status[i] = max(fridge_status[i], 1)\n                    fridge_status[j] = max(fridge_status[j], 1)\n                    dfs(fridge_status, n, m - 1, cost + weights[i - 1] + weights[j - 1], ans)\n                    fridge_status[i] = 0\n                    fridge_status[j] = 0\n\n    T = int(stdin.readline().strip())\n    output = []\n    for _ in range(T):\n        n, m = map(int, stdin.readline().strip().split())\n        weights = list(map(int, stdin.readline().strip().split()))\n        fridge_status = [0] * (n + 1)\n        ans = [float('inf')]\n        dfs(fridge_status, n, m, 0, ans)\n        if ans[0] == float('inf'):\n            output.append(-1)\n        else:\n            output.append(ans[0])\n            fridge_status = [0] * (n + 1)\n            ans = [float('inf')]\n            dfs(fridge_status, n, m, 0, ans)\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    if i != j and fridge_status[i] != 2 and fridge_status[j] != 2:\n                        fridge_status[i] = max(fridge_status[i], 1)\n                        fridge_status[j] = max(fridge_status[j], 1)\n                        dfs(fridge_status, n, m - 1, cost + weights[i - 1] + weights[j - 1], ans)\n                        fridge_status[i] = 0\n                        fridge_status[j] = 0\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    if i != j and fridge_status[i] != 2 and fridge_status[j] != 2:\n                        fridge_status[i] = max(fridge_status[i], 1)\n                        fridge_status[j] = max(fridge_status[j], 1)\n                        dfs(fridge_status, n, m - 1, cost + weights[i - 1] + weights[j - 1], ans)\n                        fridge_status[i] = 0\n                        fridge_status[j] = 0\n            output.append(ans[0])\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    if i != j and fridge_status[i] != 2 and fridge_status[j] != 2:\n                        fridge_status[i] = max(fridge_status[i], 1)\n                        fridge_status[j] = max(fridge_status[j], 1)\n                        dfs(fridge_status, n, m - 1, cost + weights[i - 1] + weights[j - 1], ans)\n                        fridge_status[i] = 0\n                        fridge_status[j] = 0\n            output.append(ans[",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 2331,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_white(i: int, a: int, b: int) -> bool:\n        if i == 0:\n            return True\n        if i >= a and is_white(i - a, a, b):\n            return True\n        if i >= b and is_white(i - b, a, b):\n            return True\n        return False\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(t):\n        a, b = map(int, stdin.split('\\n')[i + 1].split())\n        if any(is_white(j, a, b) for j in range(a * b, a * b + 100)):\n            result.append(\"Infinite\")\n        else:\n            result.append(\"Finite\")\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 2332,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.readline().split())\n    words = stdin.readline().split()\n    costs = list(map(int, stdin.readline().split()))\n    groups = []\n    for _ in range(k):\n        x, *indices = map(int, stdin.readline().split())\n        groups.append(set(indices))\n    message = stdin.readline().split()\n\n    def find_group(word_index):\n        for i, group in enumerate(groups):\n            if word_index in group:\n                return i\n        return -1\n\n    total_cost = 0\n    for word in message:\n        word_index = words.index(word)\n        group_index = find_group(word_index)\n        if group_index != -1:\n            for other_word_index in groups[group_index]:\n                if other_word_index != word_index:\n                    total_cost += costs[other_word_index]\n        total_cost += costs[word_index]\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 266,
        "indeed": false
    },
    {
        "number": 2333,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_subpermutation(l: int, r: int) -> bool:\n        freq = [0] * (n + 1)\n        for i in range(l, r + 1):\n            freq[a[i]] += 1\n        return all(f == 1 for f in freq[1:r - l + 2])\n\n    subpermutations = 0\n    for l in range(n):\n        for r in range(l, n):\n            if is_subpermutation(l, r):\n                subpermutations += 1\n\n    return str(subpermutations)",
        "test": "",
        "num_ids": 188,
        "indeed": true
    },
    {
        "number": 2334,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def split_bitcoins(N, a, x, f):\n        total_fee = 0\n        for i in range(N):\n            while a[i] > x:\n                a[i] -= x\n                a.append(x)\n                total_fee += f\n            if a[i] > 0:\n                total_fee += f\n        return total_fee\n\n    N, a, x, f = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    x, f = map(int, input().split())\n\n    return str(split_bitcoins(N, a, x, f))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2335,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, color):\n        visited[start] = True\n        for neighbor, c in graph[start]:\n            if not visited[neighbor] and c != color:\n                dfs(neighbor, color)\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        p, c = stdin.readline().strip().split()\n        points.append((int(p), c))\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][1] != points[j][1]:\n                graph[i].append((j, points[i][1]))\n                graph[j].append((i, points[j][1]))\n\n    visited = [False] * n\n    cost = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, points[i][1])\n            cost += 1\n\n    return cost ",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2336,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def count_admissible(l, r, recipes, k):\n        count = 0\n        for i in range(l, r + 1):\n            if binary_search(recipes, i) != -1:\n                count += 1\n        return count >= k\n\n    def process_query(a, b, recipes, k):\n        count = 0\n        for i in range(a, b + 1):\n            if count_admissible(i, i, recipes, k):\n                count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    n, k, q = map(int, lines[0].split())\n    recipes = []\n    for i in range(1, n + 1):\n        l, r = map(int, lines[i].split())\n        recipes.append((l, r))\n\n    output = []\n    for i in range(n + 1, n + 1 + q):\n        a, b = map(int, lines[i].split())\n        output.append(process_query(a, b, recipes, k))\n\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 380,
        "indeed": false
    },
    {
        "number": 2337,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    b.sort()\n    a.sort()\n\n    if n > m:\n        return str(n - m)\n\n    i = 0\n    j = 0\n    count = 0\n\n    while i < n and j < m:\n        if b[j] >= a[i]:\n            i += 1\n            j += 1\n        else:\n            count += 1\n            j += 1\n\n    return str(max(0, n - i) + count)",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 2338,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def move(x, y, direction):\n        if direction == \"R\":\n            return x + 1, y\n        elif direction == \"L\":\n            return x - 1, y\n        elif direction == \"U\":\n            return x, y + 1\n        elif direction == \"D\":\n            return x, y - 1\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    def is_valid_move(x, y, direction, bombs):\n        new_x, new_y = move(x, y, direction)\n        return (new_x, new_y) not in bombs\n\n    def find_path(start, end, bombs):\n        visited = set()\n        queue = [(start, [])]\n        while queue:\n            (x, y), path = queue.pop(0)\n            if (x, y) == end:\n                return path\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for direction in \"RLUD\":\n                if is_valid_move(x, y, direction, bombs):\n                    new_x, new_y = move(x, y, direction)\n                    queue.append(((new_x, new_y), path + [direction]))\n        return None\n\n    n = int(stdin.readline().strip())\n    bombs = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    start = (0, 0)\n    operations = []\n    for bomb_x, bomb_y in bombs:\n        path = find_path(start, (bomb_x, bomb_y), bombs)\n        if path is None:\n            return \"IMPOSSIBLE\"\n        for direction in path:\n            operations.append(f\"1 1 {direction}\")\n        operations.append(\"2\")\n        operations.append(\"3\")\n        start = (0, 0)\n\n    return f\"{len(operations)}\\n\" + \"\\n\".join(operations)",
        "test": "",
        "num_ids": 492,
        "indeed": false
    },
    {
        "number": 2339,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_max_gcd(a):\n        n = len(a)\n        dp = [0] * n\n        dp[0] = a[0]\n        for i in range(1, n):\n            dp[i] = lcm(dp[i - 1], a[i])\n        return dp\n\n    def find_permutation(a, dp):\n        n = len(a)\n        b = [0] * n\n        for i in range(n - 1, -1, -1):\n            b[i] = dp[i] // a[i]\n            dp[i] = a[i]\n        return b\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        dp = find_max_gcd(a)\n        b = find_permutation(a, dp)\n        output.append(\" \".join(map(str, b)))\n\n    return \"\\n\".join(output)\n",
        "test": "",
        "num_ids": 344,
        "indeed": false
    },
    {
        "number": 2340,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_move(x: int, h: int) -> bool:\n        return 0 <= x <= h\n\n    def can_fall(x: int, y: int) -> bool:\n        return abs(x - y) <= 2\n\n    def find_min_crystals(h: int, n: int, platforms: List[int], memo: Dict[Tuple[int, int], int]) -> int:\n        if (h, n) in memo:\n            return memo[(h, n)]\n\n        if n == 0:\n            if can_move(h, h):\n                memo[(h, n)] = 0\n                return 0\n            else:\n                memo[(h, n)] = float('inf')\n                return float('inf')\n\n        min_crystals = float('inf')\n        for i in range(n):\n            if can_move(platforms[i], h):\n                new_platforms = platforms[:i] + platforms[i + 1:]\n                new_n = n - 1\n                crystals_used = 1\n\n                if not can_move(platforms[i] - 1, h):\n                    new_platforms.append(platforms[i] - 1)\n                    new_n += 1\n                    crystals_used += 1\n\n                new_platforms.sort(reverse=True)\n                min_crystals = min(min_crystals, crystals_used + find_min_crystals(h, new_n, new_platforms, memo))\n\n        memo[(h, n)] = min_crystals\n        return min_crystals\n\n    queries = [line.strip().split() for line in stdin.strip().split('\\n')]\n    result = []\n\n    for i in range(1, len(queries), 2):\n        h, n = map(int, queries[i])\n        platforms = list(map(int, queries[i + 1]))\n        memo = {}\n        result.append(find_min_crystals(h, n, platforms, memo))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 534,
        "indeed": false
    },
    {
        "number": 2341,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    colors = {}\n    for i in range(n):\n        line = stdin.readline().strip()\n        for j in range(m):\n            if line[j] not in colors:\n                colors[line[j]] = 1\n            else:\n                colors[line[j]] += 1\n\n    count = 0\n    for color in colors:\n        count += colors[color]\n\n    return str(count)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 2342,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, n, m, good_people, bad_people):\n        def dfs(x, y):\n            if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '#' or (x, y) in bad_people:\n                return False\n            if (x, y) in good_people:\n                return True\n            if grid[x][y] == '.':\n                grid[x][y] = '#'\n            if dfs(x - 1, y) or dfs(x + 1, y) or dfs(x, y - 1) or dfs(x, y + 1):\n                return True\n            grid[x][y] = '.'\n            return False\n\n        return dfs(0, 0)\n\n    def process_test_case(stdin):\n        n, m = map(int, stdin.readline().split())\n        grid = [list(stdin.readline().strip()) for _ in range(n)]\n        good_people = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'G']\n        bad_people = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']\n        return is_valid(grid, n, m, good_people, bad_people)\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        if process_test_case(stdin):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n    return result\n",
        "test": "",
        "num_ids": 404,
        "indeed": false
    },
    {
        "number": 2343,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n, k):\n        if k == 0:\n            return True\n        if n == 1:\n            return False\n        if k % 2 == 1:\n            return False\n        return is_possible(n - 1, k // 2)\n\n    def find_path_length(n):\n        return n - 1\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n, k = map(int, stdin.split('\\n')[i].split())\n        if is_possible(n, k):\n            result.append(f\"YES {find_path_length(n)}\")\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 2344,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    offers = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def simulate(offer_index, burles):\n        if offer_index == n:\n            return burles\n        i = offer_index\n        a, b, k = offers[i]\n        rest_burles = burles - a\n        if rest_burles < 0:\n            return float('-inf')\n        return max(simulate(i + 1, rest_burles), simulate(i + 1, burles + a - b) + b * k)\n\n    return str(simulate(0, 0))",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 2345,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subset(arr: List[int]) -> List[int]:\n        n = len(arr)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if arr[i] + arr[j] + arr[k] == 0:\n                        return [i + 1, j + 1, k + 1]\n        return []\n\n    def parse_input(stdin: str) -> List[List[int]]:\n        lines = stdin.split(\"\\n\")\n        n_tests = int(lines[0])\n        tests = []\n        i = 1\n        for _ in range(n_tests):\n            n = int(lines[i])\n            arr = list(map(int, lines[i + 1].split()))\n            tests.append((n, arr))\n            i += 2\n        return tests\n\n    tests = parse_input(stdin)\n    output = []\n    for n, arr in tests:\n        subset = find_subset(arr)\n        output.append(str(len(subset)))\n        output.append(\" \".join(map(str, subset)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 299,
        "indeed": false
    },
    {
        "number": 2346,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_children(parent, children_list):\n        children = []\n        for i in range(len(parent)):\n            if parent[i] == children_list:\n                children.append(i)\n        return children\n\n    def find_ancestors(vertex, parent):\n        ancestors = []\n        while vertex != -1:\n            ancestors.append(vertex)\n            vertex = parent[vertex]\n        return ancestors\n\n    def can_delete(vertex, parent, children, c):\n        ancestors = find_ancestors(vertex, parent)\n        for ancestor in ancestors:\n            if c[ancestor] == 0:\n                return False\n        for child in children[vertex]:\n            if c[child] == 1:\n                return False\n        return True\n\n    def delete_vertex(vertex, parent, children, c):\n        for child in children[vertex]:\n            parent[child] = parent[vertex]\n        parent[vertex] = -1\n        c[vertex] = -1\n\n    n = int(stdin.readline().strip())\n    parent = [-1] * n\n    children = [[] for _ in range(n)]\n    c = [0] * n\n\n    for i in range(n):\n        p, c_i = map(int, stdin.readline().strip().split())\n        c[i] = c_i\n        if p != -1:\n            parent[i] = p\n            children[p].append(i)\n\n    vertices_to_delete = []\n    for i in range(n):\n        if can_delete(i, parent, children, c):\n            vertices_to_delete.append(i)\n\n    for vertex in sorted(vertices_to_delete):\n        delete_vertex(vertex, parent, children, c)\n\n    if not vertices_to_delete:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(vertices_to_delete)))",
        "test": "",
        "num_ids": 487,
        "indeed": false
    },
    {
        "number": 2347,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        p = stdin.split('\\n')[2*i+1]\n        h = stdin.split('\\n')[2*i+2]\n        s1 = h.split(p)[0]\n        s2 = h.split(p)[1]\n        p_shuffled = ''.join(random.sample(p, len(p)))\n        if s1 + p_shuffled + s2 == h:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2348,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    hex_num = stdin.strip()\n    decimal_num = int(hex_num, 16)\n    binary_num = bin(decimal_num)[2:]\n    binary_num = binary_num.rjust(24, '0')\n    binary_num = list(map(int, binary_num))\n    binary_num[12] = 1 - binary_num[12]\n    binary_num = ''.join(map(str, binary_num))\n    decimal_num = int(binary_num, 2)\n    return decimal_num",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2349,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def possible_increments(n: int) -> List[int]:\n        increments = set()\n        for k in range(1, n + 1):\n            increment = n // k\n            increments.add(increment)\n        return sorted(list(increments))\n\n    t = int(stdin.split('\\n')[0])\n    test_cases = [int(x) for x in stdin.split('\\n')[1:t + 1]]\n\n    output = []\n    for n in test_cases:\n        increments = possible_increments(n)\n        output.append(str(len(increments)))\n        output.append(' '.join(str(x) for x in increments))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 2350,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gaz_giz(x, y):\n        if x == 1 and y == 1:\n            return 1\n        if x > 1:\n            return gaz_giz(x - 1, y) + gaz_giz(x - 1, y + 1)\n        return gaz_giz(x, y + 1)\n\n    def sum_on_path(x1, y1, x2, y2):\n        total_sum = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                total_sum += gaz_giz(i, j)\n        return total_sum\n\n    def count_different_sums(x1, y1, x2, y2):\n        total_sum = sum_on_path(x1, y1, x2, y2)\n        return total_sum - (x2 - x1 + y2 - y1) * gaz_giz(x1, y1)\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        output.append(count_different_sums(x1, y1, x2, y2))\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 350,
        "indeed": false
    },
    {
        "number": 2351,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, len_ = map(int, stdin.split()[0].split())\n    arr = list(map(int, stdin.split()[1].split()))\n\n    mod = 998244353\n\n    def count_ways(arr, k, len_):\n        ways = [0] * (k + 1)\n        for i in range(1, k + 1):\n            ways[i] = 1\n\n        for i in range(len(arr)):\n            if arr[i] == -1:\n                temp_ways = [0] * (k + 1)\n                for j in range(1, k + 1):\n                    temp_ways[j] = ways[j - 1] + ways[j]\n                    temp_ways[j] %= mod\n                ways = temp_ways\n            else:\n                temp_ways = [0] * (k + 1)\n                for j in range(1, k + 1):\n                    if j != arr[i]:\n                        temp_ways[j] = ways[j]\n                    else:\n                        temp_ways[j] = ways[j - 1]\n                    temp_ways[j] %= mod\n                ways = temp_ways\n\n        return ways[k]\n\n    return str(count_ways(arr, k, len_))",
        "test": "",
        "num_ids": 329,
        "indeed": false
    },
    {
        "number": 2352,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sheet: List[List[str]], r1: int, c1: int, r2: int, c2: int) -> bool:\n        if r1 == r2:\n            for c in range(min(c1, c2), max(c1, c2) + 1):\n                if sheet[r1][c] != '.':\n                    return False\n            return True\n        elif c1 == c2:\n            for r in range(min(r1, r2), max(r1, r2) + 1):\n                if sheet[r][c1] != '.':\n                    return False\n            return True\n        return False\n\n    def find_empty_cells(sheet: List[List[str]]) -> List[Tuple[int, int]]:\n        empty_cells = []\n        for r, row in enumerate(sheet):\n            for c, cell in enumerate(row):\n                if cell == '.':\n                    empty_cells.append((r, c))\n        return empty_cells\n\n    def draw_snakes(sheet: List[List[str]], empty_cells: List[Tuple[int, int]], k: int) -> List[List[int]]:\n        snakes = []\n        for i in range(k):\n            for r, c in empty_cells:\n                if i == 0 and r == 0 and c == 0:\n                    sheet[r][c] = 'a'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 1 and r == 0 and c == 1:\n                    sheet[r][c] = 'b'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 2 and r == 1 and c == 0:\n                    sheet[r][c] = 'c'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 3 and r == 1 and c == 1:\n                    sheet[r][c] = 'd'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 4 and r == 2 and c == 0:\n                    sheet[r][c] = 'e'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 5 and r == 2 and c == 1:\n                    sheet[r][c] = 'f'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 6 and r == 3 and c == 0:\n                    sheet[r][c] = 'g'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 7 and r == 3 and c == 1:\n                    sheet[r][c] = 'h'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 8 and r == 4 and c == 0:\n                    sheet[r][c] = 'i'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 9 and r == 4 and c == 1:\n                    sheet[r][c] = 'j'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 10 and r == 5 and c == 0:\n                    sheet[r][c] = 'k'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 11 and r == 5 and c == 1:\n                    sheet[r][c] = 'l'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 12 and r == 6 and c == 0:\n                    sheet[r][c] = 'm'\n                    snakes.append([r, c, r, c])\n                    break\n                elif i == 13 and r == 6 and c == 1:\n                    sheet[r][c] = 'n'\n                    snakes.append([r,",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 2353,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_total_sleep_time(a, b, c, d):\n        total_sleep_time = 0\n        current_sleep_time = 0\n        current_alarm_time = b\n\n        while current_sleep_time < a:\n            current_sleep_time += d\n            total_sleep_time += d\n            current_alarm_time += c\n\n            if current_alarm_time >= a:\n                return -1\n\n        return total_sleep_time\n\n    testcases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(testcases):\n        a, b, c, d = map(int, stdin.readline().strip().split())\n        total_sleep_time = get_total_sleep_time(a, b, c, d)\n        output.append(str(total_sleep_time))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 2354,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                board[i][j] = (i * n + j + 1)\n            else:\n                board[i][j] = (i * n + j + 1) + int(n * (n + 1) / 2)\n\n    result = []\n    for _ in range(q):\n        x, y = map(int, input().split())\n        result.append(board[x - 1][y - 1])\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2355,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_edges(n: int, p: int) -> List[Tuple[int, int]]:\n        edges = []\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                edges.append((i, j))\n        return edges\n\n    def is_p_interesting(n: int, p: int, edges: List[Tuple[int, int]]) -> bool:\n        if len(edges) != 2 * n + p:\n            return False\n\n        for k in range(1, n + 1):\n            subgraph_edges = [edge for edge in edges if edge[0] <= k and edge[1] <= k]\n            if len(subgraph_edges) > 2 * k + p:\n                return False\n\n        return True\n\n    tests = [tuple(map(int, line.split())) for line in stdin.split('\\n') if line]\n    output = []\n\n    for n, p in tests:\n        edges = generate_edges(n, p)\n        if is_p_interesting(n, p, edges):\n            output.extend([' '.join(map(str, edge)) for edge in edges])\n\n    return '\\n'.join(output)\n",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 2356,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(a: List[int]) -> bool:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if j - a[j] == i - a[i]:\n                    return False\n        return True\n\n    def shuffle(a: List[int]) -> List[int]:\n        a_copy = a.copy()\n        random.shuffle(a_copy)\n        return a_copy\n\n    def find_good_shuffle(a: List[int]) -> List[int]:\n        for _ in range(1000):\n            shuffled = shuffle(a)\n            if is_good(shuffled):\n                return shuffled\n        return None\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        shuffled = find_good_shuffle(a)\n        output.append(\" \".join(map(str, shuffled)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2357,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dominated_subarray(a: List[int]) -> int:\n        n = len(a)\n        if n < 2:\n            return -1\n\n        num_occurrences = Counter(a)\n        max_occurrence = max(num_occurrences.values())\n        max_occurrence_num = -1\n\n        for num, occ in num_occurrences.items():\n            if occ == max_occurrence:\n                max_occurrence_num = num\n                break\n\n        if max_occurrence_num == -1:\n            return -1\n\n        left, right = 0, n - 1\n        while left < right:\n            if a[left] != max_occurrence_num:\n                left += 1\n            if a[right] != max_occurrence_num:\n                right -= 1\n\n        return right - left + 1\n\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        result.append(dominated_subarray(a))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 2358,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_simple(s: str) -> bool:\n        n = len(s)\n        if n % 2 == 0 and s.count('(') == n // 2 and s.count(')') == n // 2:\n            return True\n        return False\n\n    def find_operations(s: str) -> List[Tuple[int, List[int]]]:\n        operations = []\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_simple(s[i:j]):\n                    operations.append((j - i, list(range(i, j))))\n        return operations\n\n    def apply_operation(s: str, operation: Tuple[int, List[int]]) -> str:\n        m, indices = operation\n        s_list = list(s)\n        for i in sorted(indices, reverse=True):\n            s_list.pop(i)\n        return ''.join(s_list)\n\n    def min_operations(s: str) -> int:\n        if is_simple(s):\n            return 0\n        operations = find_operations(s)\n        min_ops = float('inf')\n        for operation in operations:\n            new_s = apply_operation(s, operation)\n            ops = min_operations(new_s) + 1\n            min_ops = min(min_ops, ops)\n        return min_ops\n\n    def find_min_operations(s: str) -> List[Tuple[int, List[int]]]:\n        if is_simple(s):\n            return []\n        operations = find_operations(s)\n        min_ops = float('inf')\n        min_ops_seq = []\n        for operation in operations:\n            new_s = apply_operation(s, operation)\n            ops = find_min_operations(new_s) + [operation]\n            if len(ops) < min_ops:\n                min_ops = len(ops)\n                min_ops_seq = ops\n        return min_ops_seq\n\n    min_ops = min_operations(stdin)\n    min_ops_seq = find_min_operations(stdin)\n\n    return f\"{min_ops}\\n\" + '\\n'.join([f\"{len(op[1])}\" + ' '.join(map(str, op[1])) for op in min_ops_seq])",
        "test": "",
        "num_ids": 589,
        "indeed": false
    },
    {
        "number": 2359,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cups(h, c, t):\n        min_diff = abs(t - c)\n        min_cups = 1\n        max_diff = abs(h - t)\n        max_cups = 1\n\n        while max_diff > min_diff:\n            min_diff = abs(t - c)\n            min_cups += 1\n            c = (c + h) / 2\n\n            max_diff = abs(h - t)\n            max_cups += 1\n            h = (h + c) / 2\n\n        return min_cups\n\n    def parse_input(stdin: str) -> List[Tuple[int, int, int]]:\n        lines = stdin.split(\"\\n\")\n        testcases = int(lines[0])\n        inputs = []\n        for i in range(1, testcases + 1):\n            h, c, t = map(int, lines[i].split())\n            inputs.append((h, c, t))\n        return inputs\n\n    inputs = parse_input(stdin)\n    outputs = []\n    for h, c, t in inputs:\n        min_cups = find_min_cups(h, c, t)\n        outputs.append(str(min_cups))\n\n    return \"\\n\".join(outputs)",
        "test": "",
        "num_ids": 321,
        "indeed": false
    },
    {
        "number": 2360,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(t):\n        n = int(stdin.split('\\n')[1 + i * (n + 1)])\n        students = [(int(l), int(r)) for l, r in [line.split() for line in stdin.split('\\n')[2 + i * (n + 1):2 + i * (n + 1) + n]]]\n        students.sort(key=lambda x: (x[0], -x[1]))\n\n        queue = []\n        for j in range(n):\n            if not queue:\n                queue.append((j, students[j][0], students[j][1]))\n            else:\n                last_student = queue[-1]\n                if students[j][0] >= last_student[2]:\n                    queue.append((j, students[j][0], students[j][1]))\n                else:\n                    queue[-1] = (j, students[j][0], students[j][1])\n\n            while queue and queue[0][2] <= j:\n                queue.pop(0)\n\n            if not queue:\n                result.append(0)\n            else:\n                result.append(queue[0][1])\n\n        result.append('\\n')\n\n    return ' '.join(map(str, result[:-1]))",
        "test": "",
        "num_ids": 332,
        "indeed": false
    },
    {
        "number": 2361,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_points(n, m, k):\n        players = [0] * k\n        jokers = m // k\n        plain_cards = (n - m) // k\n\n        for i in range(k):\n            players[i] = jokers\n\n        for i in range(plain_cards):\n            for j in range(k):\n                players[j] += 1\n\n        max_jokers = max(players)\n        winners = [i for i in range(k) if players[i] == max_jokers]\n\n        if len(winners) == 1:\n            return max_jokers - (max(players) - jokers)\n        else:\n            return 0\n\n    tests = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, tests + 1):\n        n, m, k = map(int, stdin.split('\\n')[i].split())\n        result.append(get_points(n, m, k))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 2362,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lca(u, v):\n        while u != v:\n            if dep[u] < dep[v]:\n                u, v = v, u\n            v = par[v]\n        return u\n\n    def dist(u, v):\n        return dep[u] + dep[v] - 2 * dep[lca(u, v)]\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    edges = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n - 1)]\n\n    par = [-1] * n\n    dep = [0] * n\n    for u, v in edges:\n        par[v] = u\n        dep[v] = dep[u] + 1\n\n    res = 0\n    for u, v in edges:\n        if gcd(a[u], a[v]) > 1:\n            res = max(res, dist(u, v))\n\n    return str(res) if res > 0 else \"0\"",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 2363,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = [list(map(int, pair.split())) for pair in stdin.split('\\n')[1:]]\n    result = []\n    for pair in pairs:\n        a, b = pair\n        count = 0\n        while a != 0 and b != 0:\n            if a > b:\n                a -= b\n                count += 1\n            else:\n                b -= a\n                count += 1\n        result.append(count)\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2364,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    p = 0\n    mod = 998244353\n\n    for i in range(1, n):\n        p += (a[i] - a[i - 1]) * (2 ** (n - 1 - i))\n        p %= mod\n\n    return str(p * 2 ** (n - 1) % mod)",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 2365,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse(expression):\n        if expression[0] == 't':\n            return True\n        elif expression[0] == 'f':\n            return False\n        elif expression[0] == '!':\n            return not parse(expression[2:-1])\n        elif expression[0] == '&':\n            return all(parse(e) for e in expression[2:-1].split(','))\n        elif expression[0] == '|':\n            return any(parse(e) for e in expression[2:-1].split(','))\n\n    return str(parse(stdin)).lower()",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2366,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    d = {}\n    for i in range(N):\n        if A[i] not in d:\n            d[A[i]] = [i]\n        else:\n            d[A[i]].append(i)\n\n    result = []\n    for k in range(1, N + 1):\n        count = 0\n        for i in range(1, N):\n            if i in d[A[k - 1]]:\n                continue\n            count += len(d[A[i]])\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 2367,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, A, B = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    dp = [[0] * W for _ in range(H)]\n    dp[0][0] = 1\n\n    for i in range(H):\n        for j in range(W):\n            if i == H - 1 and j == W - 1:\n                continue\n\n            if i < H - A and j < W - B:\n                if i + 1 < H:\n                    dp[i + 1][j] += dp[i][j]\n                    dp[i + 1][j] %= mod\n                if j + 1 < W:\n                    dp[i][j + 1] += dp[i][j]\n                    dp[i][j + 1] %= mod\n\n    return str(dp[H - 1][W - 1])",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 2368,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    edges = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    for x, y in edges:\n        if a[x - 1] == b[x - 1] and a[y - 1] == b[y - 1]:\n            continue\n        elif a[x - 1] == b[x - 1] and a[y - 1] != b[y - 1]:\n            a[y - 1] += 1\n            a[x - 1] -= 1\n        elif a[x - 1] != b[x - 1] and a[y - 1] == b[y - 1]:\n            a[x - 1] += 1\n            a[y - 1] -= 1\n        else:\n            a[x - 1] += 1\n            a[y - 1] -= 1\n\n    if a == b:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 296,
        "indeed": false
    },
    {
        "number": 2369,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    A.sort()\n    mod = 10**9 + 7\n    total = 0\n    nCr = 1\n    for i in range(K):\n        total += A[N - 1 - i] - A[i]\n        nCr = (nCr * (N - i)) // i if i > 0 else nCr\n    total *= nCr\n    return str(total % mod)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 2370,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        n = len(graph)\n        visited = [False] * n\n        weights = [float('inf')] * n\n        weights[start] = 0\n        path = [0] * n\n\n        while not all(visited):\n            min_weight = float('inf')\n            min_index = -1\n            for i in range(n):\n                if not visited[i] and weights[i] < min_weight:\n                    min_weight = weights[i]\n                    min_index = i\n\n            if min_index == -1:\n                return False\n\n            visited[min_index] = True\n\n            for neighbor, weight in enumerate(graph[min_index]):\n                if not visited[neighbor] and weights[min_index] + weight < weights[neighbor]:\n                    weights[neighbor] = weights[min_index] + weight\n                    path[neighbor] = min_index\n\n        return weights, path\n\n    def find_cycle(path, start, end):\n        cycle = [end]\n        while end != start:\n            end = path[end]\n            cycle.append(end)\n        return cycle\n\n    def is_valid_network(graph, dist):\n        n = len(graph)\n        for i in range(n):\n            for j in range(n):\n                if dist[i][j] != dijkstra(graph, i)[0][j]:\n                    return False\n        return True\n\n    def find_shortest_length(graph, dist):\n        n = len(graph)\n        min_length = float('inf')\n        for perm in permutations(range(1, n)):\n            path_length = 0\n            prev = 0\n            for city in perm:\n                path_length += dist[prev][city]\n                prev = city\n            path_length += dist[prev][0]\n            min_length = min(min_length, path_length)\n        return min_length\n\n    def main():\n        n = int(stdin.readline().strip())\n        dist = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n        if not is_valid_network(dist, dist):\n            return -1\n\n        return find_shortest_length(dist, dist)\n\n    return main()",
        "test": "",
        "num_ids": 567,
        "indeed": false
    },
    {
        "number": 2371,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Z, W, *a = list(map(int, stdin.split()))\n    a = a[::-1]\n\n    X_draws = 0\n    Y_draws = 0\n\n    while a:\n        if X_draws == Y_draws:\n            X_draws += 1\n        else:\n            Y_draws += 1\n\n        if not a:\n            break\n\n        if X_draws % 2 == 1:\n            a.pop()\n        else:\n            a.pop(0)\n\n    score = abs(Z - W)\n    return str(score)",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 2372,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, H, W):\n        return 1 <= x <= H and 1 <= y <= W\n\n    def bfs(maze, start, end, H, W):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), steps = queue.pop(0)\n            if (x, y) == end:\n                return steps\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny, H, W) and maze[nx - 1][ny - 1] == \".\":\n                        queue.append(((nx, ny), steps + 1))\n\n        return -1\n\n    lines = stdin.split(\"\\n\")\n    H, W = map(int, lines[0].split())\n    C_h, C_w, D_h, D_w = map(int, lines[1].split())\n    maze = [list(line) for line in lines[2:]]\n\n    return str(bfs(maze, (C_h, C_w), (D_h, D_w), H, W))",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 2373,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n    count = 0\n\n    for i in range(N):\n        if p[i] != i + 1:\n            count += 1\n            j = p.index(i + 1)\n            p[i], p[j] = p[j], p[i]\n\n    return str(count)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 2374,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cut_bombs(bombs, cords):\n        for cord in cords:\n            for bomb in bombs:\n                if cord[0] <= bomb[0] <= cord[1]:\n                    bomb[1] ^= 1\n\n    def count_activated_bombs(bombs):\n        return sum(bomb[1] for bomb in bombs)\n\n    N, M = map(int, stdin.readline().split())\n    bombs = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    cords = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    cut_bombs(bombs, cords)\n\n    if count_activated_bombs(bombs) == 0:\n        return f\"{len(cords)}\\n\" + \" \".join(str(cord + 1) for cord in range(len(cords)))\n    else:\n        return \"-1\"",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 2375,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n\n    while X > 0 and Y > 0:\n        if X > Y:\n            X -= 2 * Y\n            Y += Y\n        else:\n            Y -= 2 * X\n            X += X\n\n    if X == 0:\n        return \"Brown\"\n    else:\n        return \"Alice\"",
        "test": "",
        "num_ids": 94,
        "indeed": true
    },
    {
        "number": 2376,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.readline().split())\n    items = []\n    for _ in range(N):\n        w, v = map(int, stdin.readline().split())\n        items.append((w, v))\n\n    items.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    total_value = 0\n    for item in items:\n        if item[0] <= W:\n            total_value += item[1]\n            W -= item[0]\n\n    return str(total_value)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2377,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = map(int, stdin.split())\n    a, b = [], []\n    for _ in range(N):\n        a_i, b_i = map(int, input().split())\n        a.append(a_i)\n        b.append(b_i)\n\n    def binary_search(katana_list):\n        left, right = 0, sum(katana_list)\n        while left <= right:\n            mid = (left + right) // 2\n            total_damage = 0\n            for katana in katana_list:\n                total_damage += min(mid // katana, 1) * katana\n            if total_damage >= H:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    result = binary_search(a)\n    for i in range(N):\n        if b[i] > 0:\n            result = binary_search(a[:i] + a[i+1:])\n            if result <= H // b[i]:\n                result += H // b[i]\n            else:\n                result += 1\n\n    return str(result)",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 2378,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_parent(parent, u):\n        while parent[u] != u:\n            u = parent[u]\n        return u\n\n    def union_parent(parent, rank, x, y):\n        x = find_parent(parent, x)\n        y = find_parent(parent, y)\n\n        if x == y:\n            return False\n\n        if rank[x] < rank[y]:\n            parent[x] = y\n        elif rank[x] > rank[y]:\n            parent[y] = x\n        else:\n            parent[y] = x\n            rank[x] += 1\n        return True\n\n    def get_subtree(parent, u):\n        subtree = set()\n        stack = [u]\n        while stack:\n            u = stack.pop()\n            subtree.add(u)\n            for v in adj[u]:\n                if v not in subtree and v != parent[u]:\n                    stack.append(v)\n        return subtree\n\n    N = int(stdin.readline().strip())\n    adj = [[] for _ in range(N + 1)]\n    parent = [i for i in range(N + 1)]\n    rank = [0] * (N + 1)\n\n    for _ in range(N - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        union_parent(parent, rank, u, v)\n\n    black_vertices = set()\n    for i in range(1, N + 1):\n        if i not in black_vertices:\n            subtree = get_subtree(parent, i)\n            black_vertices.update(subtree)\n\n    total_vertices = set(range(1, N + 1))\n    white_vertices = total_vertices - black_vertices\n    holeyness = len(white_vertices)\n\n    numerator = holeyness * (2 ** (N - 1) - 1)\n    denominator = 2 ** N - 1\n    g = gcd(numerator, denominator)\n    numerator //= g\n    denominator //= g\n\n    mod = 10**9 + 7\n    result = (numerator * mod_inverse(denominator, mod)) % mod\n\n    return str(result)\n\ndef",
        "test": "",
        "num_ids": 614,
        "indeed": false
    },
    {
        "number": 2379,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C, S = map(int, stdin.split()[0:3]), stdin.split()[3]\n    workdays = []\n    i = 0\n    while i < N:\n        if S[i] == 'o' and i not in workdays:\n            workdays.append(i)\n            for j in range(i + 1, i + C + 1):\n                if j < N:\n                    workdays.append(j)\n            i += C + 1\n        else:\n            i += 1\n    return '\\n'.join(map(str, sorted(workdays[:K])))",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 2380,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    B = []\n    C = []\n    for i in range(M):\n        B_i, C_i = map(int, stdin.readline().split())\n        B.append(B_i)\n        C.append(C_i)\n\n    A.sort(reverse=True)\n    for i in range(M):\n        for j in range(B[i]):\n            if A:\n                A.pop()\n        if A:\n            A[-1] = C[i]\n\n    return sum(A)",
        "test": "",
        "num_ids": 165,
        "indeed": false
    },
    {
        "number": 2381,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    A.sort()\n\n    modulo = 10**9 + 7\n    max_product = 1\n\n    for i in range(K):\n        max_product *= A.pop()\n        max_product %= modulo\n\n    return str(max_product)",
        "test": "",
        "num_ids": 108,
        "indeed": false
    },
    {
        "number": 2382,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = sorted(S)\n\n    def helper(health, slimes, index):\n        if index == len(S):\n            return health == slimes\n\n        if slimes >= S[index]:\n            if helper(health, slimes - S[index], index + 1):\n                return True\n\n        if health >= S[index]:\n            if helper(health - S[index], slimes, index + 1):\n                return True\n\n        return False\n\n    if helper(S[0], 0, 1):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 160,
        "indeed": false
    },
    {
        "number": 2383,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *bricks = list(map(int, stdin.split()))\n    bricks.sort()\n    K = N\n    for i in range(N - 1):\n        if bricks[i] == i + 1:\n            K -= 1\n        else:\n            break\n    return str(N - K)",
        "test": "",
        "num_ids": 80,
        "indeed": false
    },
    {
        "number": 2384,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = list(map(int, A.split()))\n    if N % 2 == 0:\n        return max(sum(A[::2]), sum(A[1::2]))\n    else:\n        return max(sum(A[::2]), sum(A[1::2]) + A[N-1])",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 2385,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_adjacent_vertex(vertex: int, visited: set, graph: dict) -> int:\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                return neighbor\n        return -1\n\n    def dfs(vertex: int, visited: set, graph: dict) -> None:\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, graph)\n\n    N = int(stdin.readline().strip())\n    graph = {i: [] for i in range(1, N + 1)}\n    for _ in range(N - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    output = []\n    for k in range(1, N + 1):\n        visited = set()\n        dfs(k, visited, graph)\n        remaining_vertices = set(graph.keys()) - visited\n        for vertex in remaining_vertices:\n            adjacent_vertex = find_adjacent_vertex(vertex, visited, graph)\n            if adjacent_vertex != -1:\n                graph[vertex].append(adjacent_vertex)\n                graph[adjacent_vertex].append(vertex)\n                visited.add(vertex)\n                visited.add(adjacent_vertex)\n\n        output.append(len(visited))\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 378,
        "indeed": false
    },
    {
        "number": 2386,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = list(map(int, A.split()))\n    A.sort()\n    sadness = float('inf')\n\n    for b in range(A[0], A[-1] + 1):\n        current_sadness = 0\n        for i in range(N):\n            current_sadness += abs(A[i] - (b + i))\n        sadness = min(sadness, current_sadness)\n\n    return str(sadness)",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2387,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    N = int(stdin.split('\\n', 1)[0])\n    S = stdin.split('\\n', 1)[1].split('\\n', N)[:N]\n\n    for s in S:\n        if not is_valid(s):\n            return \"No\"\n\n    return \"Yes\"",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 2388,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_active(x: int, d: int, robots: List[int]) -> bool:\n        for robot in robots:\n            if x <= robot < x + d:\n                return True\n        return False\n\n    def count_active_robots(robots: List[int], distances: List[int]) -> int:\n        count = 0\n        for i, robot in enumerate(robots):\n            if is_active(robot, distances[i], robots):\n                count += 1\n        return count\n\n    def process_robots(robots: List[int], distances: List[int]) -> List[int]:\n        while count_active_robots(robots, distances):\n            for i, robot in enumerate(robots):\n                if is_active(robot, distances[i], robots):\n                    robots.remove(robot)\n                    break\n        return robots\n\n    def count_possible_sets(robots: List[int], distances: List[int]) -> int:\n        result = 0\n        for i in range(len(robots) + 1):\n            result += count_combinations(robots, i)\n        return result\n\n    def count_combinations(robots: List[int], k: int) -> int:\n        if k == 0 or k == len(robots):\n            return 1\n        return count_combinations(robots[:-1], k - 1) + count_combinations(robots[:-1], k)\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    X = [int(line.split()[0]) for line in lines[1:]]\n    D = [int(line.split()[1]) for line in lines[1:]]\n\n    robots = list(range(1, N + 1))\n    robots = process_robots(robots, D)\n    result = count_possible_sets(robots, D) % 998244353\n\n    return str(result)",
        "test": "",
        "num_ids": 494,
        "indeed": false
    },
    {
        "number": 2389,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a, b, c):\n        return a >= 0 and b >= 0 and c >= 0\n\n    def find_choice(a, b, c, s):\n        if s == \"AB\":\n            if is_valid(a + 1, b - 1, c):\n                return \"A\"\n            elif is_valid(a - 1, b + 1, c):\n                return \"B\"\n        elif s == \"AC\":\n            if is_valid(a + 1, b, c - 1):\n                return \"A\"\n            elif is_valid(a - 1, b, c + 1):\n                return \"C\"\n        elif s == \"BC\":\n            if is_valid(a, b + 1, c - 1):\n                return \"B\"\n            elif is_valid(a, b - 1, c + 1):\n                return \"C\"\n        return None\n\n    lines = stdin.split(\"\\n\")\n    N, A, B, C = map(int, lines[0].split())\n    choices = lines[1:]\n\n    if N > len(choices):\n        return \"No\"\n\n    for i in range(N):\n        choice = find_choice(A, B, C, choices[i])\n        if choice is None:\n            return \"No\"\n        if choice == \"A\":\n            A += 1\n        elif choice == \"B\":\n            B += 1\n        else:\n            C += 1\n\n    return \"Yes\" + \"\\n\" + \"\\n\".join(choices)",
        "test": "",
        "num_ids": 381,
        "indeed": false
    },
    {
        "number": 2390,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.readline().split())\n    sushi = []\n    for _ in range(N):\n        x, v = map(int, stdin.readline().split())\n        sushi.append((x, v))\n\n    sushi.sort()\n    total_nutrition = 0\n    total_energy = 0\n\n    for i in range(N):\n        if i == 0:\n            distance = sushi[i][0]\n        else:\n            distance = sushi[i][0] - sushi[i - 1][0]\n\n        total_nutrition += sushi[i][1]\n        total_energy += distance\n\n    distance = C - sushi[N - 1][0]\n    total_energy += distance\n\n    return str(total_nutrition - total_energy)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2391,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def generate_new_sequence(a: list, k: int, x: int) -> list:\n        n = len(a)\n        return [a[(i + k) % n] ^ x for i in range(n)]\n\n    def find_pairs(a: list, b: list) -> list:\n        pairs = []\n        n = len(a)\n        for k in range(n):\n            for x in range(2**30):\n                new_sequence = generate_new_sequence(a, k, x)\n                if new_sequence == b:\n                    pairs.append((k, x))\n        return pairs\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    a = input_data[1:n+1]\n    b = input_data[n+1:]\n\n    pairs = find_pairs(a, b)\n    return \"\\n\".join(f\"{k} {x}\" for k, x in pairs)",
        "test": "",
        "num_ids": 266,
        "indeed": false
    },
    {
        "number": 2392,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_rainbow_arrays(n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n // 7 + 1):\n            dp[i * 7] = (dp[i * 7] + dp[i * 7 - 1] + dp[i * 7 - 2] + dp[i * 7 - 3] + dp[i * 7 - 4] + dp[i * 7 - 5] + dp[i * 7 - 6]) % MOD\n\n        return dp[n]\n\n    n = int(stdin.strip())\n    return str(count_rainbow_arrays(n))",
        "test": "",
        "num_ids": 205,
        "indeed": false
    },
    {
        "number": 2393,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_liked(s: str) -> bool:\n        for i in range(len(s) - 2):\n            if s[i:i + 3] in [\"one\", \"two\"]:\n                return False\n        return True\n\n    def min_removals(s: str) -> int:\n        if is_liked(s):\n            return 0\n\n        min_removals_count = len(s)\n        for i in range(len(s) - 2):\n            if s[i:i + 3] in [\"one\", \"two\"]:\n                new_s = s[:i] + s[i + 1:]\n                min_removals_count = min(min_removals_count, 1 + min_removals(new_s))\n\n        return min_removals_count\n\n    def positions_to_remove(s: str) -> List[int]:\n        positions = []\n        for i in range(len(s) - 2):\n            if s[i:i + 3] in [\"one\", \"two\"]:\n                new_s = s[:i] + s[i + 1:]\n                if min_removals(new_s) == min_removals(s) - 1:\n                    positions.append(i + 1)\n\n        return positions\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        min_removals_count = min_removals(s)\n        positions = positions_to_remove(s)\n        output.append(str(min_removals_count))\n        if min_removals_count > 0:\n            output.append(\" \".join(map(str, positions)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 448,
        "indeed": false
    },
    {
        "number": 2394,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(n - 1)]\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent, depth):\n        dp[node] = depth\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, depth + 1)\n\n    def f(s, t):\n        if dp[s] % 2 == dp[t] % 2:\n            return min(dp[s], dp[t])\n        else:\n            return min(dp[s], dp[t]) + 1\n\n    dp = [0] * (n + 1)\n    dfs(1, 0, 0)\n\n    total = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            total += f(i, j)\n\n    return str(total)",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 2395,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(s: str, t: str) -> bool:\n        s_iter = iter(s)\n        return all(c in s_iter for c in t)\n\n    def find_period(s: str) -> int:\n        for k in range(1, len(s) // 2 + 1):\n            if all(s[i] == s[i + k] for i in range(len(s) - k)):\n                return k\n        return len(s)\n\n    def find_shortest_s(t: str) -> str:\n        for length in range(1, 2 * len(t) + 1):\n            for s in ('0' * length, '1' * length):\n                if is_subsequence(s, t) and find_period(s) == length:\n                    return s\n        return t\n\n    T = int(stdin.readline())\n    result = []\n    for _ in range(T):\n        t = stdin.readline().strip()\n        s = find_shortest_s(t)\n        result.append(s)\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 276,
        "indeed": false
    },
    {
        "number": 2396,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline())\n    coordinates = []\n    for _ in range(m):\n        coordinates.append(eval(stdin.readline().strip()))\n\n    counts = [1] * m\n    for i in range(m):\n        for j in range(i + 1, m):\n            if coordinates[i] == coordinates[j]:\n                counts[i] += 1\n                counts[j] += 1\n\n    return \" \".join(map(str, counts))",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 2397,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    a.sort()\n\n    cost = 0\n    for i in range(k):\n        cost += a[i] * (i + 1)\n        cost -= a[n - i - 1] * (k - i)\n\n    return str(cost)",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 2398,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_walk(a, b, c, d, x, y, x1, y1, x2, y2):\n        if x1 <= x <= x2 and y1 <= y <= y2:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.readline().strip().split())\n        x, y, x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        result.append(check_walk(a, b, c, d, x, y, x1, y1, x2, y2))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 198,
        "indeed": false
    },
    {
        "number": 2399,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(a, b, s):\n        n = len(s)\n        for i in range(n - a + 1):\n            if s[i:i + a].count('.') == a:\n                s = s[:i] + 'X' * a + s[i + a:]\n                break\n        else:\n            return \"NO\"\n\n        for i in range(n - b + 1):\n            if s[i:i + b].count('.') == b:\n                s = s[:i] + 'X' * b + s[i + b:]\n                break\n        else:\n            return \"YES\"\n\n        return check_win(a, b, s)\n\n    queries = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(queries):\n        a, b = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n        result.append(check_win(a, b, s))\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 258,
        "indeed": false
    },
    {
        "number": 2400,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def has_integer_intersection(p, q):\n        d = gcd(p, q)\n        return p // d == -q // d\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        p = list(map(int, stdin.readline().split()))\n        m = int(stdin.readline())\n        q = list(map(int, stdin.readline().split()))\n\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if has_integer_intersection(p[i], q[j]):\n                    count += 1\n        result.append(str(count))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 227,
        "indeed": false
    },
    {
        "number": 2401,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def guess_number(N, R, numbers):\n        if R == 1:\n            return numbers[0]\n        elif R == N:\n            return numbers[-1]\n        else:\n            return numbers[R - 2]\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        N, R = map(int, stdin.readline().strip().split())\n        numbers = list(map(int, stdin.readline().strip().split()))\n        result.append(str(guess_number(N, R, numbers)))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 2402,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_max_place(n, x, y):\n        min_place = max(x, y)\n        max_place = n - min(x, y) + 1\n        return min_place, max_place\n\n    def main(stdin: str) -> str:\n        lines = stdin.split('\\n')\n        t = int(lines[0])\n        results = []\n        for i in range(1, t + 1):\n            n, x, y = map(int, lines[i].split())\n            min_place, max_place = find_min_max_place(n, x, y)\n            results.append(f\"{min_place} {max_place}\")\n        return \"\\n\".join(results)\n\n    return main(stdin)",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 2403,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i: int, visited: set, a: list, b: list, ans: int, memo: dict) -> int:\n        if i == -1:\n            return ans\n        if i in visited:\n            return memo[i]\n        visited.add(i)\n        res = 0\n        for j in range(n):\n            if j not in visited:\n                res = max(res, dfs(b[j], visited, a, b, ans + a[i], memo))\n        memo[i] = res\n        visited.remove(i)\n        return res\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    memo = {}\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dfs(i, set(), a, b, 0, memo))\n\n    order = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            dfs(i, visited, a, b, 0, memo)\n            order.append(i + 1)\n\n    return f\"{ans}\\n{' '.join(map(str, order))}\"",
        "test": "",
        "num_ids": 326,
        "indeed": false
    },
    {
        "number": 2404,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    mary_jokes = [\n        \"There was once young lass called Mary,\",\n        \"Whose jokes were occasionally scary.\",\n        \"On this April's Fool\",\n        \"Fixed limerick rules\",\n        \"Allowed her to trip the unwary.\"\n    ]\n\n    def is_valid_limerick(lines):\n        if len(lines) != 5:\n            return False\n        for i in range(4):\n            if lines[i][-1] != ',':\n                return False\n            if lines[i][-2] != ' ':\n                return False\n        if lines[4][-1] != '.':\n            return False\n        if lines[0][-3] != ' ' or lines[1][-3] != ' ':\n            return False\n        if lines[2][-3] != ' ' or lines[3][-3] != ' ':\n            return False\n        return True\n\n    def generate_limericks(lines, current_line, current_word, rhymes):\n        if current_line == 4:\n            if current_word == 0:\n                return 0\n            if current_word == 1 and lines[current_line][-2] == 'e':\n                return 1\n            return 0\n        if current_word == 2:\n            if current_line == 0:\n                return 0\n            if current_line == 1 and lines[current_line][-2] == 'e':\n                return 1\n            return 0\n        if current_word == 3:\n            if current_line == 2:\n                return 0\n            if current_line == 3 and lines[current_line][-2] == 'e':\n                return 1\n            return 0\n        return 0\n\n    def fill_limerick(lines, current_line, current_word, rhymes):\n        if current_line == 4:\n            if current_word == 0:\n                return [line + '.' for line in lines]\n            if current_word == 1 and lines[current_line][-2] == 'e':\n                return [line + '.' for line in lines]\n            return []\n        if current_word == 2:\n            if current_line == 0:\n                return []\n            if current_line == 1 and lines[current_line][-2] == 'e':\n                return []\n            return []\n        if current_word == 3:\n            if current_line == 2:\n                return []\n            if current_line == 3 and lines[current_line][-2] == 'e':\n                return []\n            return []\n        return []\n\n    def generate_mary_jokes(a):\n        mary_jokes[1] = mary_jokes[1][:-1] + str(a) + '.'\n        return mary_jokes\n\n    def solve(a):\n        mary_jokes = generate_mary_jokes(a)\n        valid_limericks = []\n        for limerick in generate_limericks(mary_jokes, 0, 0, {}):\n            if is_valid_limerick(limerick):\n                valid_limericks.append(limerick)\n        return len(valid_limericks)\n\n    return solve(a) ",
        "test": "",
        "num_ids": 805,
        "indeed": false
    },
    {
        "number": 2405,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, q = map(int, stdin.split()[:5])\n    updates = [list(map(int, stdin.split())) for _ in range(q)]\n    orders = [0] * (n + 1)\n    production = [b] * (n + 1)\n\n    for update in updates:\n        if len(update) == 3:\n            d, a = update[1:]\n            orders[d] += a\n        else:\n            p = update[1]\n            total_orders = sum(orders[:p])\n            total_production = sum(production[p:p + k])\n            total_orders += min(total_production, orders[p + k])\n            yield total_orders\n\n    for i in range(n):\n        production[i + 1] = a\n\n    for p in range(n - k + 1, 0, -1):\n        total_orders = sum(orders[:p])\n        total_production = sum(production[p:p + k])\n        total_orders += min(total_production, orders[p + k])\n        yield total_orders\n",
        "test": "",
        "num_ids": 272,
        "indeed": false
    },
    {
        "number": 2406,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = list(map(int, stdin.split('\\n')[1].split()))\n\n    while True:\n        changed = False\n        for i in range(n - 1):\n            if heights[i] + 2 <= heights[i + 1]:\n                heights[i] += 1\n                heights[i + 1] -= 1\n                changed = True\n        if not changed:\n            break\n\n    return ' '.join(map(str, heights))",
        "test": "",
        "num_ids": 133,
        "indeed": true
    },
    {
        "number": 2407,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_shots(n, r, x):\n        x.sort()\n        shots = 0\n        while x:\n            shots += 1\n            target = x.pop(0)\n            killed = [i for i in x if i <= target]\n            x = [i for i in x if i > target]\n            for i in killed:\n                x.append(i - r)\n            x.sort()\n        return shots\n\n    queries = [line.strip().split() for line in stdin.strip().split('\\n')]\n    q = int(queries[0][0])\n    result = []\n    for i in range(1, q + 1):\n        n, r = map(int, queries[i][0].split())\n        x = list(map(int, queries[i][1].split()))\n        result.append(min_shots(n, r, x))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 233,
        "indeed": false
    },
    {
        "number": 2408,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersecting(a, b, c, d):\n        if a == c or a == d or b == c or b == d:\n            return False\n        if (a < c < b or a < d < b) or (c < a < d or c < b < d):\n            return True\n        return False\n\n    def count_intersections(poles):\n        intersections = 0\n        for i in range(len(poles)):\n            for j in range(i + 1, len(poles)):\n                if is_intersecting(*poles[i], *poles[j]):\n                    intersections += 1\n        return intersections\n\n    n = int(stdin.readline().strip())\n    poles = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    return str(count_intersections(poles))",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 2409,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_koa_reach_island(n, k, l, d, p):\n        for t in range(2 * k):\n            for x in range(n + 1):\n                if d[x] + p[t] > l:\n                    continue\n                if x == n:\n                    return True\n        return False\n\n    def parse_input(stdin: str) -> List[str]:\n        lines = stdin.splitlines()\n        n_test_cases = int(lines[0])\n        test_cases = []\n        i = 1\n        while n_test_cases > 0:\n            n, k, l = map(int, lines[i].split())\n            d = list(map(int, lines[i + 1].split()))\n            p = [0] * (2 * k)\n            for j in range(k):\n                p[j] = j + 1\n                p[j + k] = k - j\n            test_cases.append((n, k, l, d, p))\n            i += 2\n            n_test_cases -= 1\n        return test_cases\n\n    test_cases = parse_input(stdin)\n    results = []\n    for n, k, l, d, p in test_cases:\n        if can_koa_reach_island(n, k, l, d, p):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    return \"\\n\".join(results)",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 2410,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_happy(n: int, a: List[int]) -> bool:\n        total_tastiness = sum(a)\n        for i in range(1, n):\n            if total_tastiness - a[i] <= total_tastiness - a[0]:\n                return False\n        return True\n\n    test_cases = int(stdin.split('\\n')[0])\n    stdin = stdin.split('\\n')[1:]\n    result = []\n\n    for i in range(test_cases):\n        n = int(stdin[i * 2].split(' ')[0])\n        a = list(map(int, stdin[i * 2 + 1].split(' ')))\n        if is_happy(n, a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 2411,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersecting(a, b, c, d):\n        if a == c or a == d or b == c or b == d:\n            return False\n        if (a < c < b or a < d < b) or (c < a < d or c < b < d):\n            return True\n        return False\n\n    def count_intersections(poles):\n        intersections = 0\n        for i in range(len(poles)):\n            for j in range(i + 1, len(poles)):\n                if is_intersecting(*poles[i], *poles[j]):\n                    intersections += 1\n        return intersections\n\n    n = int(stdin.readline().strip())\n    poles = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    return str(count_intersections(poles))",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 2412,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if len(s) != n:\n        raise ValueError(\"Invalid input: length of string s must be equal to n\")\n\n    if n < 11:\n        return \"NO\"\n\n    if s[0] != '8':\n        return \"NO\"\n\n    for i in range(1, n):\n        if s[i] == '8':\n            return \"YES\"\n\n    return \"NO\"\n",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 2413,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(t):\n        n, staircases = stdin.split('\\n')[1 + i * 2:3 + i * 2]\n        n = int(n)\n        staircases = [int(x) for x in staircases]\n\n        max_rooms = n * 2 - sum(staircases)\n        result.append(str(max_rooms))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 2414,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n    for i in range(1, t + 1):\n        a, b = map(int, lines[i].split())\n        result.append(a + b)\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 81,
        "indeed": true
    },
    {
        "number": 2415,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    if len(stdin) == 1:\n        return \"YES\" if stdin in vowels else \"NO\"\n    elif len(stdin) == 2:\n        return \"YES\" if stdin[0] in vowels and stdin[1] in vowels else \"NO\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 2416,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def is_possible(a):\n        if len(set(a)) == 1:\n            return True\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                for k in range(j + 1, len(a)):\n                    if xor(a[i], a[j]) == a[k]:\n                        return True\n        return False\n\n    def find_operations(a):\n        operations = []\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                for k in range(j + 1, len(a)):\n                    if xor(a[i], a[j]) == a[k]:\n                        operations.append((i, j, k))\n        return operations\n\n    def perform_operations(a, operations):\n        for i, j, k in operations:\n            a[i], a[j], a[k] = xor(a[i], a[j], a[k]), xor(a[i], a[j], a[k]), xor(a[i], a[j], a[k])\n        return a\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if is_possible(a):\n        operations = find_operations(a)\n        if len(operations) <= n:\n            return \"YES\\n{}\\n{}\".format(len(operations), \"\\n\".join([\" \".join(map(str, op)) for op in operations]))\n    return \"NO\"",
        "test": "",
        "num_ids": 412,
        "indeed": false
    },
    {
        "number": 2417,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_overtaking(a, b):\n        overtaking = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] < a[j] and b[i] > b[j]:\n                    overtaking[i] += 1\n        return overtaking\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    overtaking = find_overtaking(a, b)\n    cars_to_be_fined = sum(1 for c in overtaking if c > 0)\n\n    return str(cars_to_be_fined)",
        "test": "",
        "num_ids": 202,
        "indeed": false
    },
    {
        "number": 2418,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_non_decreasing(seq):\n        return all(seq[i] >= seq[i - 1] for i in range(1, len(seq)))\n\n    def is_non_increasing(seq):\n        return all(seq[i] <= seq[i - 1] for i in range(1, len(seq)))\n\n    def find_min_max(a, changes):\n        b = [0] * len(a)\n        c = [0] * len(a)\n        for l, r, x in changes:\n            for i in range(l - 1, r):\n                a[i] += x\n\n        for i in range(len(a)):\n            b[i] = max(0, a[i])\n            c[i] = max(0, -a[i])\n\n        if is_non_decreasing(b) and is_non_increasing(c):\n            return max(b[i], c[i])\n        else:\n            return float('inf')\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    q = int(lines[2])\n    changes = [list(map(int, line.split())) for line in lines[3:]]\n\n    result = [find_min_max(a, changes[:i]) for i in range(q + 1)]\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 362,
        "indeed": false
    },
    {
        "number": 2419,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def min_operations(a, b):\n        return lcm(a, b) - a\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t + 1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        output.append(min_operations(a, b))\n\n    return '\\n'.join(map(str, output))\n",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2420,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.readline().split())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    max_points = 0\n    for x0, y0 in points:\n        count = sum(1 for x, y in points if abs(x - x0) + abs(y - y0) <= r)\n        max_points = max(max_points, count)\n\n    return str(max_points)",
        "test": "",
        "num_ids": 121,
        "indeed": false
    },
    {
        "number": 2421,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(x, y, c):\n        if x == 0 and y == 0:\n            return 0\n        min_cost = float('inf')\n        if x > 0:\n            min_cost = min(min_cost, find_min_cost(x - 1, y, c) + c[2])\n        if y > 0:\n            min_cost = min(min_cost, find_min_cost(x, y - 1, c) + c[1])\n        if x < 0:\n            min_cost = min(min_cost, find_min_cost(x + 1, y, c) + c[3])\n        if y < 0:\n            min_cost = min(min_cost, find_min_cost(x, y + 1, c) + c[0])\n        if x > y:\n            min_cost = min(min_cost, find_min_cost(x - 1, y + 1, c) + c[4])\n        if x < y:\n            min_cost = min(min_cost, find_min_cost(x + 1, y - 1, c) + c[5])\n        return min_cost\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        x, y = map(int, stdin.readline().strip().split())\n        c = list(map(int, stdin.readline().strip().split()))\n        min_cost = find_min_cost(x, y, c)\n        output.append(str(min_cost))\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 407,
        "indeed": false
    },
    {
        "number": 2422,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_apartments(windows: int) -> str:\n        for i in range(windows // 3 + 1):\n            for j in range(windows // 5 + 1):\n                for k in range(windows // 7 + 1):\n                    if i * 3 + j * 5 + k * 7 == windows:\n                        return f\"{i} {j} {k}\\n\"\n        return \"-1\\n\"\n\n    cases = int(stdin.split('\\n')[0])\n    windows = stdin.split('\\n')[1:]\n\n    output = []\n    for n in windows:\n        output.append(count_apartments(int(n)))\n\n    return ''.join(output)",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 2423,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(graph, visited, neighbor)\n\n    def is_remote(graph, node):\n        visited = set()\n        dfs(graph, visited, node)\n        return len(visited) == 1\n\n    N, lines = map(int, stdin.split('\\n', 1)[0].split())\n    graph = {i: set() for i in range(1, N + 1)}\n\n    for line in lines.split('\\n'):\n        u, v = map(int, line.split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    remote_planets = 0\n    for node in graph:\n        if is_remote(graph, node):\n            remote_planets += 1\n\n    return str(remote_planets)",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 2424,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def inv(x, mod):\n        return pow(x, mod - 2, mod)\n\n    n = int(stdin.readline().strip())\n    total_items = 0\n    item_count = [0] * (10 ** 6 + 1)\n    for i in range(n):\n        line = list(map(int, stdin.readline().strip().split()))\n        k_i = line[0]\n        items = line[1:]\n        total_items += k_i\n        for item in items:\n            item_count[item] += 1\n\n    valid_prob = 0\n    for i in range(1, n + 1):\n        for j in range(1, total_items + 1):\n            for z in range(1, n + 1):\n                if j <= item_count[j]:\n                    valid_prob += 1\n            total_items -= 1\n            item_count[j] -= 1\n\n    x = valid_prob\n    y = n ** 3 * total_items\n    mod = 998244353\n    y_inv = inv(y, mod)\n    result = (x * y_inv) % mod\n\n    return str(result)",
        "test": "",
        "num_ids": 331,
        "indeed": false
    },
    {
        "number": 2425,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def bitwise_gcd(a, b):\n        return gcd(a ^ b, a & b)\n\n    q = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(q):\n        a = int(stdin.readline().strip())\n        max_gcd = 0\n\n        for b in range(1, a):\n            max_gcd = max(max_gcd, bitwise_gcd(a, b))\n\n        result.append(max_gcd)\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 2426,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subset(a: List[int]) -> Tuple[int, List[int]]:\n        n = len(a)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j]\n                if a[i - 1] <= j:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i - 1]] + a[i - 1])\n\n        subset = []\n        i, j = n, n\n        while i > 0 and j > 0:\n            if dp[i - 1][j] == dp[i][j]:\n                i -= 1\n            else:\n                subset.append(i - 1)\n                i -= 1\n                j -= a[i]\n\n        return dp[n][n], subset\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n\n        sum_even, subset = find_subset(a)\n\n        if sum_even % 2 == 0:\n            output.append(str(len(subset)))\n            output.extend(map(str, subset))\n        else:\n            output.append(\"-1\")\n\n        output.append(\"\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 413,
        "indeed": false
    },
    {
        "number": 2427,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_good(l, r):\n        return l + 1 <= r - 1 and (a[l] ^ a[r]) == sum(a[l + 1:r - 1])\n\n    count = 0\n    for l in range(n):\n        for r in range(l + 2, n + 1):\n            if is_good(l, r):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 2428,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(s: str, t: str) -> bool:\n        if len(s) < len(t):\n            return False\n        if len(s) == len(t):\n            return s == t\n        if len(s) == 0:\n            return False\n        if s[0] == t[0]:\n            return is_possible(s[1:], t[1:])\n        for i in range(1, len(s)):\n            if s[i] == t[0]:\n                return is_possible(s[i:], t[1:])\n        return False\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        if is_possible(s, t):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 2429,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_diff(n):\n        if n == 2:\n            return 2\n        if n % 2 == 0:\n            return 2 * (2 ** (n // 2 - 1))\n        else:\n            return 2 * (2 ** (n // 2))\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(t):\n        n = int(stdin.split('\\n')[i * 2 + 1])\n        output.append(str(min_diff(n)))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 147,
        "indeed": false
    },
    {
        "number": 2430,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    heights = [int(stdin.readline().strip()) for _ in range(n)]\n\n    time = 0\n    current_height = heights[0]\n\n    for i in range(1, n):\n        if heights[i] > current_height + 1:\n            time += 2\n        else:\n            time += 1\n        current_height = heights[i]\n\n    return str(time)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2431,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_attack(prev_attack, current_attack):\n        return prev_attack != current_attack\n\n    def count_options(n, x, y, z, a, white_turn=True):\n        options = 0\n        for i in range(n):\n            if a[i] > 0:\n                if white_turn:\n                    options += 1\n                else:\n                    options += 3\n        return options\n\n    def process_test_case(t, n, x, y, z, a):\n        white_options = count_options(n, x, y, z, a, white_turn=True)\n        black_options = count_options(n, x, y, z, a, white_turn=False)\n\n        if white_options == 0:\n            return 0\n        elif black_options == 0:\n            return white_options\n        else:\n            valid_white_options = 0\n            valid_black_options = 0\n            prev_attack = None\n\n            for i in range(n):\n                if a[i] > 0:\n                    if prev_attack is None or is_valid_attack(prev_attack, 'mixed'):\n                        valid_white_options += 1\n                        prev_attack = 'mixed'\n\n                    if prev_attack is None or is_valid_attack(prev_attack, 'infantry'):\n                        valid_white_options += 1\n                        prev_attack = 'infantry'\n\n                    if prev_attack is None or is_valid_attack(prev_attack, 'cavalry'):\n                        valid_white_options += 1\n                        prev_attack = 'cavalry'\n\n            return valid_white_options\n\n    test_cases = stdin.split('\\n')\n    n_test_cases = int(test_cases[0])\n    test_cases = test_cases[1:]\n    results = []\n\n    for i in range(n_test_cases):\n        n, x, y, z = [int(x) for x in test_cases[i * 2].split()]\n        a = [int(x) for x in test_cases[i * 2 + 1].split()]\n        results.append(process_test_case(i, n, x, y, z, a))\n\n    return '\\n'.join(str(x) for x in results)",
        "test": "",
        "num_ids": 594,
        "indeed": false
    },
    {
        "number": 2432,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    result = 0\n    for i in range(a + 1):\n        result += 2 ** i\n    return str(result)",
        "test": "",
        "num_ids": 43,
        "indeed": false
    },
    {
        "number": 2433,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(buns, patties, cutlets, h_price, c_price):\n        hamburgers = min(buns // 2, patties)\n        chicken_burgers = min(buns // 2, cutlets)\n        return hamburgers * h_price + chicken_burgers * c_price\n\n    queries = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    t = int(queries.pop(0)[0])\n\n    results = []\n    for i in range(t):\n        b, p, f = map(int, queries[i * 2])\n        h, c = map(int, queries[i * 2 + 1])\n        results.append(max_profit(b, p, f, h, c))\n\n    return '\\n'.join(map(str, results))",
        "test": "",
        "num_ids": 219,
        "indeed": false
    },
    {
        "number": 2434,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_polygon_possible(n, m):\n        if n == 3:\n            return m == 3\n        else:\n            for i in range(3, n):\n                if n % i == 0 and m % i == 0:\n                    return True\n            return False\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n\n    for i in range(1, t + 1):\n        n, m = map(int, stdin.split('\\n')[i].split())\n\n        if is_polygon_possible(n, m):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 222,
        "indeed": true
    },
    {
        "number": 2435,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n: int, x: int, m: int, operations: List[Tuple[int, int]]) -> bool:\n        a = [0] * n\n        a[x - 1] = 1\n\n        for l, r in operations:\n            for i in range(l - 1, r):\n                if a[i] == 1:\n                    a[i], a[i + 1] = a[i + 1], a[i]\n\n        return a.count(1) > 0\n\n    def process_test_case(stdin: TextIO) -> int:\n        n, x, m = map(int, stdin.readline().split())\n        operations = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n        return sum(is_possible(n, x, m, operations) for x in range(1, n + 1))\n\n    t = int(stdin.readline())\n    output = [process_test_case(StringIO(stdin.readline())) for _ in range(t)]\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 279,
        "indeed": false
    },
    {
        "number": 2436,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def collect_grannies(n, a):\n        total = 1  # Include Maria\n        i = 0\n        while i < n:\n            candidates = []\n            while i < n and a[i] <= total:\n                candidates.append(i)\n                i += 1\n            if not candidates:\n                break\n            total += len(candidates)\n            if total > n + 1:\n                total -= 1\n                break\n        return total\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        output.append(str(collect_grannies(n, a)))\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 2437,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def make_good(a):\n        g = a[0]\n        for i in range(1, n):\n            g = gcd(g, a[i])\n            if g == 1:\n                return i\n        return -1\n\n    operations = 0\n    while True:\n        res = make_good(a)\n        if res == -1:\n            break\n        for i in range(res):\n            if a[i] > 1:\n                a[i] -= 1\n                operations += 1\n            else:\n                a[i] += 1\n                operations += 1\n\n    return str(operations)",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2438,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_palindrome(t: str) -> bool:\n        return t == t[::-1]\n\n    def count_good_substrings(s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1 if s[i] in \"AB\" else 0\n\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if is_palindrome(s[i:j + 1]):\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n        return dp[0][n - 1]\n\n    return str(count_good_substrings(s))",
        "test": "",
        "num_ids": 282,
        "indeed": false
    },
    {
        "number": 2439,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: List[int], b: List[int]) -> bool:\n        for i in range(1, len(b)):\n            if sum(b[:i]) == 0:\n                return False\n        return True\n\n    def generate_permutations(a: List[int]) -> List[List[int]]:\n        if len(a) == 1:\n            return [a]\n\n        perms = []\n        for i in range(len(a)):\n            m = a[i]\n            rem_a = a[:i] + a[i + 1:]\n            sub_perms = generate_permutations(rem_a)\n            for sub_perm in sub_perms:\n                perms.append([m] + sub_perm)\n        return perms\n\n    def find_valid_permutation(a: List[int]) -> List[int]:\n        perms = generate_permutations(a)\n        for perm in perms:\n            if is_valid(a, perm):\n                return perm\n        return []\n\n    test_cases = stdin.split(\"\\n\")\n    test_cases = test_cases[1:]\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i + 1].split()))\n        b = find_valid_permutation(a)\n        if b:\n            result.append(\"YES\")\n            result.append(\" \".join(map(str, b)))\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result) ",
        "test": "",
        "num_ids": 402,
        "indeed": false
    },
    {
        "number": 2440,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, x):\n        if parent[x] == x:\n            return x\n        parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def dfs(graph, start, end, visited, depth):\n        if start == end:\n            return depth\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                result = dfs(graph, neighbor, end, visited, depth + 1)\n                if result != -1:\n                    return result\n        visited[start] = False\n        return -1\n\n    def is_connected(parent, x, y):\n        return find(parent, x) == find(parent, y)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n):\n        u, v = map(int, lines[i].split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    q = int(lines[n])\n    result = []\n    for i in range(q):\n        x, y, a, b, k = map(int, lines[n + 1 + i].split())\n        parent = [i for i in range(n + 1)]\n        rank = [0] * (n + 1)\n        union(parent, rank, x, y)\n        visited = [False] * (n + 1)\n        depth = dfs(graph, a, b, visited, 0)\n        if depth == k:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 553,
        "indeed": false
    },
    {
        "number": 2441,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n\n        if u_root == v_root:\n            return False\n\n        if rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n        elif rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += 1\n        return True\n\n    n, costs, m, roads = stdin.strip().split('\\n')\n    n = int(n)\n    costs = list(map(int, costs.split()))\n    m = int(m)\n    roads = [list(map(int, road.split())) for road in roads.split('\\n')]\n\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n    total_cost = 0\n    ways = 1\n\n    for u, v in roads:\n        union(parent, rank, u, v)\n\n    for i in range(1, n + 1):\n        if find(parent, i) == i:\n            total_cost += costs[i - 1]\n            ways = (ways * (len(set(costs)) + 1)) % (10**9 + 7)\n\n    return f\"{total_cost} {ways}\"",
        "test": "",
        "num_ids": 413,
        "indeed": false
    },
    {
        "number": 2442,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mex(s: set) -> int:\n        i = 0\n        while i in s:\n            i += 1\n        return i\n\n    def maximize_mex_sum(n: int, arr: list) -> int:\n        arr.sort()\n        A = set()\n        B = set()\n        max_mex_sum = 0\n\n        for i in range(n):\n            if i % 2 == 0:\n                A.add(arr[i])\n            else:\n                B.add(arr[i])\n            max_mex_sum = max(max_mex_sum, mex(A) + mex(B))\n\n        return max_mex_sum\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        arr = list(map(int, stdin.readline().strip().split()))\n        output.append(str(maximize_mex_sum(n, arr)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 2443,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    forbidden_prefixes = set(map(int, input().split())) if n else set()\n\n    def is_valid(sequence: List[int]) -> bool:\n        prefix_products = set()\n        for i in range(len(sequence)):\n            prefix_product = 1\n            for j in range(i + 1):\n                prefix_product *= sequence[j]\n                prefix_product %= m\n            if prefix_product in forbidden_prefixes:\n                return False\n            prefix_products.add(prefix_product)\n        return len(prefix_products) == len(sequence) + 1\n\n    def helper(sequence: List[int], index: int) -> List[int]:\n        if index == len(sequence):\n            return sequence\n        for i in range(m):\n            if i not in forbidden_prefixes:\n                sequence[index] = i\n                if is_valid(sequence):\n                    result = helper(sequence, index + 1)\n                    if result:\n                        return result\n        return []\n\n    sequence = [0] * (n + 1)\n    result = helper(sequence, 0)\n    return f\"{len(result) - 1}\\n{' '.join(map(str, result))}\"",
        "test": "",
        "num_ids": 313,
        "indeed": false
    },
    {
        "number": 2444,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    t = list(map(int, stdin.split()[2:]))\n    result = []\n\n    for i in range(n):\n        if i == 0 or t[i] < t[i - 1]:\n            result.append(t[i] + p)\n        else:\n            result.append(result[-1] + p)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2445,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, n):\n        return 0 <= x < n and 0 <= y < n\n\n    def bfs(n):\n        queue = [(0, 0, 0)]  # x, y, depth\n        visited = set()\n\n        while queue:\n            x, y, depth = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if depth % 2 == 0:\n                    color = 'B'\n                else:\n                    color = 'Y'\n                if depth == 0:\n                    board[x][y] = color\n                else:\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n                        if is_valid(nx, ny, n) and board[nx][ny] == '.':\n                            board[nx][ny] = color\n                            queue.append((nx, ny, depth + 1))\n        return depth\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        n = int(stdin.readline().strip())\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        result.append(bfs(n))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 355,
        "indeed": false
    },
    {
        "number": 2446,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def gcd_seq(seq):\n        result = seq[0]\n        for i in range(1, len(seq)):\n            result = lcm(result, seq[i])\n        return result\n\n    n, a, q, x = (int(i) for i in stdin.split('\\n'))\n    a = [int(i) for i in a.split(' ')]\n    x = [int(i) for i in x.split('\\n')]\n\n    result = []\n    for i in x:\n        count = 0\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if gcd_seq(a[l - 1:r]) == i:\n                    count += 1\n        result.append(count)\n\n    return '\\n'.join(str(i) for i in result)",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 2447,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str) -> bool:\n        return \"010\" not in s and \"101\" not in s\n\n    def min_operations(s: str) -> int:\n        if is_good(s):\n            return 0\n\n        min_ops = float(\"inf\")\n        for i in range(len(s)):\n            if s[i] == \"0\":\n                new_s = s[:i] + \"1\" + s[i + 1 :]\n            else:\n                new_s = s[:i] + \"0\" + s[i + 1 :]\n\n            if is_good(new_s):\n                min_ops = min(min_ops, 1 + min_operations(new_s))\n\n        return min_ops\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        output.append(min_operations(s))\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 258,
        "indeed": false
    },
    {
        "number": 2448,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def ceil_div(a, b):\n        return (a + b - 1) // b\n\n    def can_win(n, a, b, c, s):\n        wins = [0, 0, 0]\n        for i in range(n):\n            if s[i] == 'R':\n                wins[0] += 1\n                wins[1] -= 1\n                wins[2] -= 1\n            elif s[i] == 'P':\n                wins[0] -= 1\n                wins[1] += 1\n                wins[2] -= 1\n            else:\n                wins[0] -= 1\n                wins[1] -= 1\n                wins[2] += 1\n\n        for i in range(n):\n            for j in range(3):\n                if wins[j] >= 0 and ceil_div(n - i, 2) - wins[j] <= a + b + c - (a if j == 0 else b if j == 1 else c):\n                    return True\n        return False\n\n    def find_winning_sequence(n, a, b, c, s):\n        wins = [0, 0, 0]\n        for i in range(n):\n            if s[i] == 'R':\n                wins[0] += 1\n                wins[1] -= 1\n                wins[2] -= 1\n            elif s[i] == 'P':\n                wins[0] -= 1\n                wins[1] += 1\n                wins[2] -= 1\n            else:\n                wins[0] -= 1\n                wins[1] -= 1\n                wins[2] += 1\n\n        for i in range(n):\n            for j in range(3):\n                if wins[j] >= 0 and ceil_div(n - i, 2) - wins[j] <= a + b + c - (a if j == 0 else b if j == 1 else c):\n                    return 'RPS'[j] * (a if j == 0 else b if j == 1 else c)\n        return None\n\n    t = int(stdin.readline().strip())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a, b, c = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n\n        if can_win(n, a, b, c, s):\n            result.append(\"YES\")\n            result.append(find_winning_sequence(n, a, b, c, s))\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 656,
        "indeed": false
    },
    {
        "number": 2449,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def and_op(a: int, b: int) -> int:\n        return a & b\n\n    def is_good_set(s: set, m: int, T: set) -> bool:\n        for a in s:\n            if a > (2 ** m) - 1:\n                return False\n            for b in s:\n                if a != b and xor(a, b) not in s:\n                    return False\n                if a != b and and_op(a, b) not in s:\n                    return False\n        return T.issubset(s)\n\n    def count_good_sets(m: int, T: set) -> int:\n        mod = 10 ** 9 + 7\n        M = 2 ** m - 1\n        total_sets = 2 ** M\n        good_sets = 0\n\n        for i in range(total_sets):\n            s = set()\n            for j in range(M + 1):\n                if i & (1 << j):\n                    s.add(j)\n            if is_good_set(s, m, T):\n                good_sets += 1\n\n        return good_sets % mod\n\n    lines = stdin.split('\\n')\n    m, n = map(int, lines[0].split())\n    T = set(map(lambda x: int(x, 2), lines[1:n + 1]))\n\n    return str(count_good_sets(m, T))",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 2450,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def pave_the_square(n, m, x, y, pavement):\n        total_cost = 0\n        for i in range(n):\n            for j in range(m):\n                if pavement[i][j] == \".\":\n                    if j + 1 < m and pavement[i][j + 1] == \".\":\n                        total_cost += y\n                        j += 1\n                    else:\n                        total_cost += x\n        return total_cost\n\n    def process_testcase(stdin: str) -> str:\n        t = int(stdin.readline())\n        result = []\n        for _ in range(t):\n            n, m, x, y = map(int, stdin.readline().split())\n            pavement = [list(stdin.readline().strip()) for _ in range(n)]\n            result.append(str(pave_the_square(n, m, x, y, pavement)))\n        return \"\\n\".join(result)\n\n    return process_testcase(stdin) ",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2451,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, a, b, k, *queries = map(int, stdin.split())\n    result = []\n\n    for query in queries:\n        t_a, f_a, t_b, f_b = query\n        if t_a == t_b:\n            result.append(abs(f_a - f_b))\n        elif t_b == t_a + 1:\n            if a <= f_a <= b and a <= f_b <= b:\n                result.append(abs(f_a - f_b) + 1)\n            else:\n                result.append(min(abs(f_a - f_b) + 1, abs(f_a - f_b) + 2))\n        else:\n            result.append(min(abs(f_a - f_b) + 1, abs(f_a - f_b) + 2))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 233,
        "indeed": false
    },
    {
        "number": 2452,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_permutation(p: List[int]) -> bool:\n        for i in range(len(p)):\n            for j in range(i, len(p)):\n                if bin(sum(p[i:j + 1])).count('1') < j - i + 1:\n                    return False\n        return True\n\n    def next_permutation(p: List[int]) -> List[int]:\n        i = len(p) - 2\n        while i >= 0 and p[i] >= p[i + 1]:\n            i -= 1\n        if i < 0:\n            return None\n        j = len(p) - 1\n        while p[j] <= p[i]:\n            j -= 1\n        p[i], p[j] = p[j], p[i]\n        p[i + 1:] = reversed(p[i + 1:])\n        return p\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        p = list(range(1, n + 1))\n        while not is_good_permutation(p):\n            p = next_permutation(p)\n        output.append(' '.join(map(str, p)))\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 339,
        "indeed": false
    },
    {
        "number": 2453,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(point, segments):\n        for segment in segments:\n            if segment[0] <= point <= segment[1]:\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    points = set()\n    for segment in segments:\n        points.update(range(segment[0], segment[1] + 1))\n\n    result = [0] * n\n    for point in points:\n        covered_segments = sum(1 for segment in segments if segment[0] <= point <= segment[1])\n        result[covered_segments - 1] += 1\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 2454,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod_pow(base, exponent, modulus):\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent //= 2\n        return result\n\n    def count_ways(n, adj, start, casinos):\n        dp = [[0] * 2 for _ in range(n)]\n        dp[start - 1][0] = 1\n        dp[start - 1][1] = 1\n\n        for i in range(n):\n            for j in range(2):\n                for neighbor in adj[i]:\n                    if neighbor != i + 1 and neighbor not in casinos:\n                        dp[neighbor - 1][j] += dp[i][j]\n                        dp[neighbor - 1][j] %= MOD\n                    elif neighbor in casinos:\n                        if j == 0:\n                            dp[neighbor - 1][1] += dp[i][0]\n                            dp[neighbor - 1][1] %= MOD\n                        else:\n                            dp[neighbor - 1][0] += dp[i][1]\n                            dp[neighbor - 1][0] %= MOD\n\n        return dp[start - 1][0] + dp[start - 1][1]\n\n    MOD = 10**9 + 7\n    n, *data = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = data[i]\n        adj[a - 1].append(b)\n        adj[b - 1].append(a)\n\n    total_ways = 0\n    for start in range(1, n + 1):\n        casinos = set()\n        total_ways += count_ways(n, adj, start, casinos)\n        total_ways %= MOD\n\n    return str(total_ways)",
        "test": "",
        "num_ids": 518,
        "indeed": false
    },
    {
        "number": 2455,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    cards = stdin.split('\\n')[1:]\n\n    for i in range(t):\n        card = cards[i]\n        x_count = card.count('X')\n        o_count = card.count('O')\n\n        if x_count == 0 or o_count == 0:\n            print(0)\n            continue\n\n        a_range = range(1, 13)\n        b_range = range(1, 13)\n        valid_pairs = []\n\n        for a in a_range:\n            for b in b_range:\n                if a * b == 12:\n                    x_in_cols = [0] * 12\n                    o_in_cols = [0] * 12\n\n                    for j in range(a):\n                        for k in range(b):\n                            index = j * b + k\n                            if card[index] == 'X':\n                                x_in_cols[k] += 1\n                            elif card[index] == 'O':\n                                o_in_cols[k] += 1\n\n                    if any(x == a for x in x_in_cols) or any(o == a for o in o_in_cols):\n                        valid_pairs.append((a, b))\n\n        print(len(valid_pairs), end=' ')\n        for pair in valid_pairs:\n            print('{}x{}'.format(pair[0], pair[1]), end=' ')\n        print()",
        "test": "",
        "num_ids": 378,
        "indeed": false
    },
    {
        "number": 2456,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(painted_cells: int, days_in_week: int) -> bool:\n        weeks = (painted_cells + days_in_week - 1) // days_in_week\n        painted_cells_in_last_week = painted_cells % days_in_week\n        if painted_cells_in_last_week == 0:\n            painted_cells_in_last_week = days_in_week\n        return painted_cells_in_last_week >= 2\n\n    def count_valid_shapes(painted_cells: int, days_in_week: int) -> int:\n        if not is_valid(painted_cells, days_in_week):\n            return 0\n        return 2 ** (painted_cells - 1)\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        n, r = map(int, stdin.readline().strip().split())\n        max_days_in_week = min(n, r)\n        min_days_in_week = max(1, (n + r - 1) // r)\n        total_valid_shapes = 0\n        for days_in_week in range(min_days_in_week, max_days_in_week + 1):\n            total_valid_shapes += count_valid_shapes(n, days_in_week)\n        result.append(total_valid_shapes)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 390,
        "indeed": false
    },
    {
        "number": 2457,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(n: int, a: int, b: int, c: int, d: int) -> bool:\n        total_weight = (n * a + n * b) // 2\n        return c - d <= total_weight <= c + d\n\n    t = int(stdin.split('\\n', 1)[0])\n    output = []\n\n    for line in stdin.split('\\n')[1:]:\n        n, a, b, c, d = map(int, line.split())\n        if is_valid(n, a, b, c, d):\n            output.append(\"Yes\")\n        else:\n            output.append(\"No\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 2458,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(a: int, b: int, k: int) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (b + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, b + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n            if i % k == 0:\n                dp[i] = (dp[i] - dp[i - k]) % mod\n        return (dp[b] - dp[a - 1]) % mod\n\n    lines = stdin.split('\\n')\n    t, k = map(int, lines[0].split())\n    result = []\n    for i in range(1, t + 1):\n        a, b = map(int, lines[i].split())\n        result.append(count_ways(a, b, k))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2459,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, m, *a = map(int, stdin.split())\n    b = []\n    for _ in range(m):\n        b.append(int(input()))\n\n    for _ in range(q):\n        t, l, r = map(int, input().split())\n        if t == 1:\n            a = a[l - 1:r] + a[r - 1:] + a[:l - 1]\n        else:\n            a = a[:l - 1] + a[r - 1:l - 1:-1] + a[r:]\n\n    result = []\n    for i in b:\n        result.append(a[i - 1])\n\n    return \" \".join(map(str, result))\n\nn, q, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueries = []\nfor _ in range(q):\n    queries.append(list(map(int, input().split())))\n\nb = list(map(int, input().split()))\n\nprint(solution(stdin)) ",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 2460,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    coords = list(map(int, stdin.readline().split()))\n    drivers = list(map(int, stdin.readline().split()))\n\n    riders = [i for i in range(len(coords)) if drivers[i] == 0]\n    taxi_drivers = [i for i in range(len(coords)) if drivers[i] == 1]\n\n    riders.sort(key=lambda x: coords[x])\n    taxi_drivers.sort(key=lambda x: coords[x])\n\n    result = [0] * m\n    for rider in riders:\n        for i, taxi_driver in enumerate(taxi_drivers):\n            if coords[rider] <= coords[taxi_driver]:\n                result[i] += 1\n                break\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 231,
        "indeed": false
    },
    {
        "number": 2461,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def dfs(vertex, parent):\n        if vertex != 1:\n            beauty[vertex] = gcd(beauty[vertex], beauty[parent])\n        for child in tree[vertex]:\n            if child != parent:\n                dfs(child, vertex)\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    tree = [[] for _ in range(n + 1)]\n    beauty = a.copy()\n\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        tree[x].append(y)\n        tree[y].append(x)\n\n    dfs(1, 0)\n    return ' '.join(map(str, beauty))",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 2462,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_nearly_prime(x: int) -> bool:\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                p, q = i, x // i\n                return p > 1 and q > p and is_prime(p) and is_prime(q)\n        return False\n\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    def find_nearly_primes(n: int) -> list:\n        nearly_primes = []\n        for i in range(2, n // 2 + 1):\n            if is_nearly_prime(i):\n                nearly_primes.append(i)\n        return nearly_primes\n\n    def find_sum(n: int, nearly_primes: list) -> list:\n        for i in range(len(nearly_primes)):\n            for j in range(i + 1, len(nearly_primes)):\n                for k in range(j + 1, len(nearly_primes)):\n                    for l in range(k + 1, len(nearly_primes)):\n                        if nearly_primes[i] + nearly_primes[j] + nearly_primes[k] + nearly_primes[l] == n:\n                            return [nearly_primes[i], nearly_primes[j], nearly_primes[k], nearly_primes[l]]\n        return None\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    outputs = []\n\n    for i in range(1, t + 1):\n        n = int(lines[i])\n        nearly_primes = find_nearly_primes(n)\n        result = find_sum(n, nearly_primes)\n        if result:\n            outputs.append(f\"YES\\n{result[0]} {result[1]} {result[2]} {result[3]}\")\n        else:\n            outputs.append(\"NO\")\n\n    return '\\n'.join(outputs)",
        "test": "",
        "num_ids": 550,
        "indeed": false
    },
    {
        "number": 2463,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    prices = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    cheap_spheres = [prices[0], prices[-1]]\n    for i in range(1, n - 1):\n        if prices[i] < prices[i - 1] and prices[i] < prices[i + 1]:\n            cheap_spheres.append(prices[i])\n\n    return f\"{len(cheap_spheres)}\\n{' '.join(map(str, cheap_spheres))}\"",
        "test": "",
        "num_ids": 148,
        "indeed": false
    },
    {
        "number": 2464,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, parent):\n        vis[v] = True\n        for u in adj[v]:\n            if u != parent and not vis[u]:\n                dfs(u, v)\n                if edges[v][u] == 1:\n                    for x in range(1, n + 1):\n                        if x != v and x != u and not vis[x]:\n                            res[x][u] = res[v][x] = True\n\n    n = int(stdin.readline())\n    edges = [[0] * (n + 1) for _ in range(n + 1)]\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        x, y, c = map(int, stdin.readline().split())\n        edges[x][y] = edges[y][x] = c\n        adj[x].append(y)\n        adj[y].append(x)\n\n    vis = [False] * (n + 1)\n    res = [[False] * (n + 1) for _ in range(n + 1)]\n    dfs(1, 0)\n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and not res[i][j]:\n                ans += 1\n    return str(ans)",
        "test": "",
        "num_ids": 345,
        "indeed": false
    },
    {
        "number": 2465,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(n: int, ang: int) -> bool:\n        val = 180 * (n - 2)\n        for i in range(3, n):\n            if val == ang:\n                return True\n            val -= (180 * (n - i))\n        return False\n\n    def find_min_n(ang: int) -> int:\n        lo, hi = 3, 998244353\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if is_valid(mid, ang):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo if lo != 998244354 else -1\n\n    queries = [int(x) for x in stdin.split('\\n')[1:]]\n    results = [find_min_n(ang) for ang in queries]\n    return '\\n'.join(str(x) for x in results)",
        "test": "",
        "num_ids": 238,
        "indeed": false
    },
    {
        "number": 2466,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    result = []\n    def permute(nums, start):\n        if start == len(nums) - 1:\n            result.append(nums[:])\n        else:\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                permute(nums, start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n    permute(nums, 0)\n    return str(result)",
        "test": "",
        "num_ids": 152,
        "indeed": false
    },
    {
        "number": 2467,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    nums = list(range(1, 10))\n    res = set()\n\n    def backtrack(start, curr_sum, k, comb):\n        if k == 0:\n            if curr_sum == n:\n                res.add(tuple(sorted(comb)))\n            return\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(i + 1, curr_sum + nums[i], k - 1, comb)\n            comb.pop()\n\n    backtrack(0, 0, k, [])\n    return [list(t) for t in res]",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 2468,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    max_length = 0\n    start = 0\n\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                start = i + 1\n            else:\n                stack.pop()\n                if not stack:\n                    max_length = max(max_length, i - start + 1)\n                else:\n                    max_length = max(max_length, i - stack[-1])\n\n    return max_length",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 2469,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, arr = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        return str(arr[0])\n    candidate1, candidate2 = 0, 0\n    count1, count2 = 0, 0\n    for i in range(n):\n        if arr[i] == candidate1:\n            count1 += 1\n        elif arr[i] == candidate2:\n            count2 += 1\n        elif count1 == 0:\n            candidate1 = arr[i]\n            count1 = 1\n        elif count2 == 0:\n            candidate2 = arr[i]\n            count2 = 1\n        else:\n            count1 -= 1\n            count2 -= 1\n    count1, count2 = 0, 0\n    for i in range(n):\n        if arr[i] == candidate1:\n            count1 += 1\n        elif arr[i] == candidate2:\n            count2 += 1\n    result = []\n    if count1 > n // 3:\n        result.append(candidate1)\n    if count2 > n // 3:\n        result.append(candidate2)\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 2470,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr1, arr2 = map(list, stdin.split())\n    arr1 = list(map(int, arr1))\n    arr2 = list(map(int, arr2))\n\n    arr1.sort()\n    arr2.sort()\n\n    i, j = 0, 0\n    operations = 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            if arr1[i] == arr2[j]:\n                i += 1\n                j += 1\n            else:\n                j += 1\n        else:\n            operations += 1\n            i += 1\n\n    if i < len(arr1):\n        return -1\n\n    return operations",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2471,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_black_cells(x1, y1, x2, y2):\n        return (x2 - x1 + 1) * (y2 - y1 + 1) - (x2 - x1 + 1) - (y2 - y1 + 1) + 1\n\n    H, W, N = map(int, stdin.split()[0:3])\n    a, b = zip(*[map(int, stdin.split()[i + 3:i + 5]) for i in range(3, N + 3)])\n    black_cells = set(zip(a, b))\n\n    count = [0] * 10\n    for i in range(H - 2):\n        for j in range(W - 2):\n            subrectangle = set()\n            for k in range(i, i + 3):\n                for l in range(j, j + 3):\n                    if (k + 1, l + 1) in black_cells:\n                        subrectangle.add((k + 1, l + 1))\n            count[count_black_cells(i, j, i + 2, j + 2)] += 1\n\n    return '\\n'.join(map(str, count))",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 2472,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    jobs = []\n    for i in range(N):\n        A, B = map(int, stdin.readline().split())\n        jobs.append((A, B))\n\n    jobs.sort(key=lambda x: x[1])\n\n    current_time = 0\n    for job in jobs:\n        if current_time + job[0] <= job[1]:\n            current_time += job[0]\n        else:\n            return \"No\"\n\n    return \"Yes\"",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 2473,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    N, K = map(int, stdin.readline().split())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n    x_min, x_max = min(x for x, y in points), max(x for x, y in points)\n    y_min, y_max = min(y for x, y in points), max(y for x, y in points)\n\n    width = x_max - x_min\n    height = y_max - y_min\n\n    area = width * height\n\n    for x1, y1 in points:\n        for x2, y2 in points:\n            if (x1, y1) != (x2, y2):\n                dx, dy = x2 - x1, y2 - y1\n                g = gcd(dx, dy)\n                dx //= g\n                dy //= g\n                if dx == 1 and dy == 1:\n                    continue\n                l = lcm(dx, dy)\n                dx *= l\n                dy *= l\n                x3, y3 = x1 + dx, y1 + dy\n                x4, y4 = x2 + dx, y2 + dy\n                if (x3, y3) in points and (x4, y4) in points:\n                    area = min(area, dx * dy)\n\n    return str(area)",
        "test": "",
        "num_ids": 392,
        "indeed": false
    },
    {
        "number": 2474,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(S: str, T: str, C: list) -> int:\n        N = len(S)\n        dp = [[0] * N for _ in range(2**N)]\n        for i in range(N):\n            dp[1<<i][i] = C[i]\n        for mask in range(2**N):\n            for i in range(N):\n                if mask & (1<<i):\n                    continue\n                new_mask = mask | (1<<i)\n                for j in range(N):\n                    if S[j] != T[j]:\n                        dp[new_mask][j] = min(dp[new_mask][j], dp[mask][j] + C[i])\n        return dp[2**N-1][0]\n\n    N, C = stdin.split()\n    N = int(N)\n    C = list(map(int, C.split()))\n    mod = 10**9 + 7\n    ans = 0\n    for S in range(2**N):\n        S_bin = format(S, '0{}b'.format(N))\n        T_bin = ''.join(['1' if b == '0' else '0' for b in S_bin])\n        ans += f(S_bin, T_bin, C)\n        ans %= mod\n    return str(ans)",
        "test": "",
        "num_ids": 331,
        "indeed": false
    },
    {
        "number": 2475,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *s = list(map(int, stdin.split()))\n    dp = [0] * N\n    dp[0] = s[0]\n    dp[1] = max(dp[0] + s[1], s[1])\n    dp[2] = max(dp[0] + s[2], dp[1] + s[2])\n\n    for i in range(3, N):\n        dp[i] = max(dp[i - 1] + s[i], dp[i - 2] + s[i])\n\n    return str(dp[-1])",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 2476,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = sorted(set(A))\n    ans = [0] * N\n    for i in range(1, N):\n        if i > 1:\n            A.remove(A[0])\n        ans[i] = ans[i - 1] + 1\n        for j in range(i + 1, N):\n            if A[j] - A[j - 1] > 1:\n                break\n            ans[i] += 1\n    return \" \".join(map(str, ans))",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 2477,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *logs = list(map(int, stdin.split()))\n    logs.sort(reverse=True)\n    total_cuts = 0\n    for log in logs:\n        if total_cuts >= K:\n            break\n        cuts = min(K - total_cuts, log - 1)\n        total_cuts += cuts\n    return str(int(logs[0] + 0.5))",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 2478,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    stack = []\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(s[i])\n        else:\n            if not stack:\n                stack.append(s[i])\n            else:\n                stack.pop()\n\n    return '(' * (len(stack)) + s + ')' * (len(stack)) ",
        "test": "",
        "num_ids": 117,
        "indeed": false
    },
    {
        "number": 2479,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(query: str, grid: List[List[int]]) -> None:\n        q_type, x = map(int, query.split())\n        if q_type == 1:\n            for i in range(1, len(grid)):\n                if grid[i][x - 1] == 1:\n                    grid[i][x - 1] = 2\n                else:\n                    break\n        elif q_type == 2:\n            for j in range(1, len(grid[0])):\n                if grid[x - 1][j] == 1:\n                    grid[x - 1][j] = 2\n                else:\n                    break\n\n    N, Q = map(int, stdin.split())\n    grid = [[1] * (N - 1) for _ in range(N - 1)]\n    queries = [input() for _ in range(Q)]\n\n    for query in queries:\n        process_query(query, grid)\n\n    black_stones = sum(row.count(1) for row in grid)\n    return str(black_stones)",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 2480,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *A = list(map(int, stdin.split()))\n    count = 0\n    for i in range(N):\n        sub_sum = 0\n        sub_count = 0\n        for j in range(i, N):\n            sub_sum += A[j]\n            sub_count += 1\n            if sub_sum % K == sub_count:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 107,
        "indeed": true
    },
    {
        "number": 2481,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    c = [list(map(int, line.split())) for line in lines[1:11]]\n    A = [list(map(int, line.split())) for line in lines[11:]]\n\n    # Calculate the minimum cost to turn each digit into 1\n    total_cost = 0\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] != -1:\n                total_cost += c[A[i][j]][1]\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2482,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected_by_roads(city1, city2, roads):\n        for road in roads:\n            if city1 in road and city2 in road:\n                return True\n        return False\n\n    def is_connected_by_railways(city1, city2, railways):\n        for railway in railways:\n            if city1 in railway and city2 in railway:\n                return True\n        return False\n\n    N, K, L = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(K)]\n    railways = [tuple(map(int, stdin.readline().split())) for _ in range(L)]\n\n    result = []\n    for i in range(1, N + 1):\n        count = 0\n        for j in range(1, N + 1):\n            if i != j and (is_connected_by_roads(i, j, roads) and is_connected_by_railways(i, j, railways)):\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 2483,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_record(s1, t1, c1, s2, t2, c2):\n        return s1 >= t2 or s2 >= t1 or c1 != c2\n\n    def merge_intervals(intervals):\n        if not intervals:\n            return []\n\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        for interval in intervals[1:]:\n            if interval[0] <= merged[-1][1]:\n                merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1]))\n            else:\n                merged.append(interval)\n\n        return merged\n\n    lines = stdin.split('\\n')\n    N, C = map(int, lines[0].split())\n    programs = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    programs.sort(key=lambda x: x[1])\n\n    intervals = []\n    for program in programs:\n        s, t, c = program\n        if not intervals or can_record(s, t, c, intervals[-1][0], intervals[-1][1], intervals[-1][2]):\n            intervals.append((s, t, c))\n        else:\n            intervals[-1] = (intervals[-1][0], t, c)\n\n    merged_intervals = merge_intervals(intervals)\n    return str(len(merged_intervals))",
        "test": "",
        "num_ids": 352,
        "indeed": false
    },
    {
        "number": 2484,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = int(stdin.split()[0]), list(map(int, stdin.split()[1:]))\n    count = 0\n    for l in range(1, N + 1):\n        for r in range(l, N + 1):\n            if sum(A[l-1:r]) == A[l-1] ^ A[r]:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 104,
        "indeed": false
    },
    {
        "number": 2485,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, M, targets = map(int, stdin.split())\n    targets = [tuple(map(int, input().split())) for _ in range(M)]\n\n    row_count = [0] * H\n    col_count = [0] * W\n\n    for h, w in targets:\n        row_count[h - 1] += 1\n        col_count[w - 1] += 1\n\n    max_targets = max(max(row_count), max(col_count))\n\n    return str(max_targets)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 2486,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *a = list(map(int, stdin.split()))\n    unnecessary_count = 0\n\n    for i in range(N):\n        good_subsets = []\n        for j in range(1, 2 ** N):\n            subset = [a[k] for k in range(N) if (j & (1 << k)) > 0]\n            if sum(subset) >= K:\n                good_subsets.append(subset)\n\n        is_unnecessary = True\n        for subset in good_subsets:\n            if i in subset:\n                if sum(subset) - a[i] < K:\n                    is_unnecessary = False\n                    break\n        if is_unnecessary:\n            unnecessary_count += 1\n\n    return str(unnecessary_count)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 2487,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent):\n        low[node] = node_id[node]\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node)\n                low[node] = min(low[node], low[child])\n\n    def find_articulation_points(node, parent, is_root):\n        is_articulation = False\n        for child in graph[node]:\n            if child == parent:\n                continue\n            if low[child] >= node_id[node]:\n                is_articulation = True\n            if is_root:\n                root_children += 1\n        return is_articulation\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(1, N):\n        u, v = map(int, lines[i].split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    node_id = {node: i for i, node in enumerate(graph, 1)}\n    low = {node: node_id[node] for node in graph}\n    root_children = 0\n\n    for node in graph:\n        if low[node] == node_id[node]:\n            root_children = 0\n            dfs(node, None)\n            if root_children > 1:\n                is_articulation = True\n            else:\n                is_articulation = False\n                for child in graph[node]:\n                    if low[child] >= node_id[node]:\n                        is_articulation = True\n                        break\n            if is_articulation:\n                for child in graph[node]:\n                    low[child] = min(low[child], low[node])\n\n    return str(sum(low.values()))",
        "test": "",
        "num_ids": 455,
        "indeed": false
    },
    {
        "number": 2488,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, A = map(int, stdin.split()[0:3])\n    X = []\n    H = []\n    for i in range(N):\n        x, h = map(int, stdin.split()[3 + 2 * i:5 + 2 * i])\n        X.append(x)\n        H.append(h)\n\n    X.sort()\n\n    bombs = 0\n    for i in range(N):\n        if H[i] > 0:\n            bombs += 1\n            left = max(0, X[i] - D)\n            right = min(X[i] + D, 10**9)\n            for j in range(left, right + 1):\n                for k in range(len(X)):\n                    if X[k] == j:\n                        H[k] -= A\n                        break\n\n    return str(bombs)",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2489,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = list(map(int, A.split()))\n    count = 0\n\n    for i in range(1, N + 1):\n        is_valid = True\n        for j in range(1, N + 1):\n            if i != j and A[j - 1] % A[i - 1] == 0:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 2490,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    i = 1\n    while n > 0:\n        while n % (10 ** i) == n:\n            count += n\n            n = 0\n            break\n        while n >= (10 ** i):\n            n -= (10 ** i)\n            count += 1\n        i += 1\n    return str(count)",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 2491,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a].append((b, c))\n\n    def dfs(node, visited, score):\n        if node == N:\n            return score\n        visited.add(node)\n        for next_node, weight in graph[node]:\n            if next_node not in visited:\n                score += weight\n                score = dfs(next_node, visited, score)\n        return score\n\n    result = dfs(1, set(), 0)\n    return \"inf\" if result == float(\"inf\") else str(result)",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 2492,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append(A[i] * A[j])\n\n    pairs.sort()\n    return str(pairs[K - 1])",
        "test": "",
        "num_ids": 104,
        "indeed": true
    },
    {
        "number": 2493,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        if sequence[i] != sequence[i - 1]:\n            for j in range(i, n + 1):\n                if sequence[j] != sequence[j - 1]:\n                    dp[j - i + 1] += dp[j - i]\n                    dp[j - i + 1] %= mod\n    return '\\n'.join(map(str, dp[1:]))",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 2494,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k == 2:\n        return 1\n    elif k == 3:\n        return 2\n    elif k == 4:\n        return 3\n    elif k == 5:\n        return 4\n    elif k == 6:\n        return 3\n    elif k == 7:\n        return 6\n    elif k == 8:\n        return 7\n    elif k == 9:\n        return 8\n    elif k == 10:\n        return 9\n    else:\n        return 10",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2495,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            count += 1\n        elif a[i] % 2 == 0:\n            count += 1\n        else:\n            count += 2\n\n    for i in range(n - 1):\n        if (a[i] > 0 and a[i + 1] < 0) or (a[i] < 0 and a[i + 1] > 0):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2496,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    gcd_set = gcd(A)\n    if gcd_set == 1:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if gcd(A[i], A[j]) != 1:\n                    return \"setwise coprime\"\n        return \"pairwise coprime\"\n    else:\n        return \"not coprime\"\n\ndef",
        "test": "",
        "num_ids": 120,
        "indeed": false
    },
    {
        "number": 2497,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_max(points: List[Tuple[int, int, str]]) -> Tuple[int, int, int, int]:\n        x_coords = [p[0] for p in points]\n        y_coords = [p[1] for p in points]\n        return min(x_coords), max(x_coords), min(y_coords), max(y_coords)\n\n    def stop_points(points: List[Tuple[int, int, str]], x_min: int, x_max: int, y_min: int, y_max: int) -> None:\n        for i, (x, y, d) in enumerate(points):\n            if d == 'R' and x >= x_max:\n                points[i] = (x_max, y, d)\n            elif d == 'L' and x <= x_min:\n                points[i] = (x_min, y, d)\n            elif d == 'U' and y >= y_max:\n                points[i] = (x, y_max, d)\n            elif d == 'D' and y <= y_min:\n                points[i] = (x, y_min, d)\n\n    def process_input(stdin: str) -> List[Tuple[int, int, str]]:\n        lines = stdin.split('\\n')\n        N = int(lines[0])\n        points = []\n        for i in range(1, N + 1):\n            x, y, d = lines[i].split()\n            x, y = int(x), int(y)\n            points.append((x, y, d))\n        return points\n\n    points = process_input(stdin)\n    x_min, x_max, y_min, y_max = get_min_max(points)\n    stop_points(points, x_min, x_max, y_min, y_max)\n    x_min, x_max, y_min, y_max = get_min_max(points)\n    return str((x_max - x_min) * (y_max - y_min))",
        "test": "",
        "num_ids": 510,
        "indeed": false
    },
    {
        "number": 2498,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def is_semi_common_multiple(x: int) -> bool:\n        for a in A:\n            if x % a != 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(1, M + 1):\n        if is_semi_common_multiple(i):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 2499,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    A.sort()\n\n    def xor(a, b):\n        return a ^ b\n\n    def count_ones(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    def max_beauty(arr, n):\n        if n == 0 or n == 1:\n            return 0\n\n        max_beauty_red = [0] * n\n        max_beauty_blue = [0] * n\n\n        for i in range(n):\n            max_beauty_red[i] = max_beauty_blue[i] = 0\n            for j in range(i):\n                if A[i] != A[j]:\n                    max_beauty_red[i] = max(max_beauty_red[i], max_beauty_red[j] + xor(A[i], A[j]))\n                    max_beauty_blue[i] = max(max_beauty_blue[i], max_beauty_blue[j] + xor(A[i], A[j]))\n\n        return max(max_beauty_red[i] + max_beauty_blue[i] - xor(A[i], A[j]) for i in range(n) for j in range(i))\n\n    return str(max_beauty(A, N))",
        "test": "",
        "num_ids": 367,
        "indeed": false
    },
    {
        "number": 2500,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 1]) % mod\n\n    return str(dp[n])\n",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 2501,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(A[i] - A[j]) == abs(i - j) + A[i] + A[j]:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 94,
        "indeed": false
    },
    {
        "number": 2502,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n, m = len(s), len(t)\n\n    def is_substring(i: int) -> bool:\n        j = i * m\n        if j > n:\n            return False\n        for k in range(j):\n            if s[k:k + m] != t:\n                return False\n        return True\n\n    i = 0\n    while is_substring(i):\n        i += 1\n\n    return str(i - 1)",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 2503,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, k):\n        return x % k == 0 and y % k == 0\n\n    def paint_grid(x, y, color, grid):\n        k = len(grid)\n        for i in range(k):\n            for j in range(k):\n                if grid[i][j] == \".\":\n                    if color == \"B\":\n                        grid[i][j] = \"X\"\n                    else:\n                        grid[i][j] = \"O\"\n                else:\n                    if color == \"B\":\n                        grid[i][j] = \"O\"\n                    else:\n                        grid[i][j] = \"X\"\n        return grid\n\n    def count_desires(x, y, color, grid):\n        k = len(grid)\n        count = 0\n        for i in range(k):\n            for j in range(k):\n                if grid[i][j] == \".\":\n                    if color == \"B\":\n                        grid[i][j] = \"X\"\n                    else:\n                        grid[i][j] = \"O\"\n                else:\n                    if color == \"B\":\n                        grid[i][j] = \"O\"\n                    else:\n                        grid[i][j] = \"X\"\n                if grid[i][j] == color:\n                    count += 1\n        return count\n\n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    desires = []\n    for i in range(1, N + 1):\n        x, y, color = lines[i].split()\n        x, y = int(x), int(y)\n        desires.append((x, y, color))\n\n    satisfied_desires = []\n    for x, y, color in desires:\n        if is_valid(x, y, K):\n            satisfied_desires.append((x, y, color))\n\n    grid = [[\".\" for _ in range(K)] for _ in range(K)]\n    painted_grid = paint_grid(x, y, color, grid)\n    count = count_desires(x, y, color, painted_grid)\n\n    return str(count)",
        "test": "",
        "num_ids": 545,
        "indeed": false
    },
    {
        "number": 2504,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(start, end, graph, fuel_tank):\n        n = len(graph)\n        visited = [False] * n\n        dist = [float('inf')] * n\n        dist[start - 1] = 0\n        dist[end - 1] = float('inf')\n        min_heap = [(0, start)]\n\n        while min_heap:\n            d, node = heapq.heappop(min_heap)\n            if node == end:\n                return d\n            if not visited[node - 1]:\n                visited[node - 1] = True\n                for neighbor, length in graph[node - 1]:\n                    if not visited[neighbor - 1]:\n                        new_dist = d + length\n                        if new_dist <= fuel_tank:\n                            if new_dist < dist[neighbor - 1]:\n                                dist[neighbor - 1] = new_dist\n                                heapq.heappush(min_heap, (new_dist, neighbor))\n\n        return -1\n\n    def read_input(stdin: str):\n        lines = stdin.split('\\n')\n        N, M, L = map(int, lines[0].split())\n        graph = [[] for _ in range(N)]\n        for i in range(M):\n            A, B, C = map(int, lines[i + 1].split())\n            graph[A - 1].append((B - 1, C))\n            graph[B - 1].append((A - 1, C))\n        Q = int(lines[M + 1])\n        queries = []\n        for i in range(M + 2, M + 2 + Q):\n            s, t = map(int, lines[i].split())\n            queries.append((s, t))\n        return N, M, L, graph, Q, queries\n\n    N, M, L, graph, Q, queries = read_input(stdin)\n    result = []\n    for s, t in queries:\n        if s == t:\n            result.append(0)\n        else:\n            fuel_tank = L\n            min_refills = 0\n            while True:\n                d = dijkstra(s, t, graph, fuel_tank)\n                if d == -1:\n                    result.append(-1)\n                    break\n                if d > fuel_tank:\n                    min_refills += 1\n                    fuel_tank = L\n                else:\n                    result.append(min_refills)\n                    break\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 636,
        "indeed": false
    },
    {
        "number": 2505,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    N = int(stdin.readline())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n    x_coords = sorted(set(x for x, _ in points))\n    y_coords = sorted(set(y for _, y in points))\n\n    x_diffs = [x_coords[i + 1] - x_coords[i] for i in range(len(x_coords) - 1)]\n    y_diffs = [y_coords[i + 1] - y_coords[i] for i in range(len(y_coords) - 1)]\n\n    x_lcm = lcm(x_diffs[0], x_diffs[1])\n    for diff in x_diffs[2:]:\n        x_lcm = lcm(x_lcm, diff)\n\n    y_lcm = lcm(y_diffs[0], y_diffs[1])\n    for diff in y_diffs[2:]:\n        y_lcm = lcm(y_lcm, diff)\n\n    mod = 998244353\n    total_sum = 0\n    for x, y in points:\n        total_sum += x_lcm * y_lcm\n        total_sum %= mod\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 393,
        "indeed": false
    },
    {
        "number": 2506,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    A.sort(reverse=True)\n    happiness = 0\n    for i in range(M):\n        if A[i % N] == A[(i + 1) % N]:\n            happiness += A[i % N]\n        else:\n            happiness += A[i % N] + A[(i + 1) % N]\n    return str(happiness)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 2507,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(left, right, check):\n        while left <= right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    N, K, A, F = map(int, stdin.split())\n    A.sort()\n    F.sort()\n\n    def check(score):\n        total_time = 0\n        for i in range(N):\n            total_time = max(total_time, A[i] * F[i] * score)\n        return total_time <= K\n\n    left, right = 1, 10**6\n    while left < right:\n        mid = (left + right + 1) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid - 1\n\n    return str(left)",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 2508,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    H, W, K, x_1, y_1, x_2, y_2 = map(int, stdin.split()[0:8])\n    pond = list(map(lambda x: x.strip(), stdin.split()[8:]))\n\n    # Check if the travel is possible\n    if pond[x_1 - 1][y_1 - 1] == '@' or pond[x_2 - 1][y_2 - 1] == '@':\n        return -1\n\n    # BFS to find the minimum number of strokes\n    visited = set()\n    queue = [(x_1, y_1, 0)]\n\n    while queue:\n        x, y, steps = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n\n        # Check if the current square is the destination\n        if (x, y) == (x_2, y_2):\n            return steps\n\n        # Add valid neighbor squares to the queue\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= H and 1 <= ny <= W and pond[nx - 1][ny - 1] != '@' and (nx, ny) not in visited:\n                queue.append((nx, ny, steps + 1))\n\n    # If the destination is not reachable, return -1\n    return -1",
        "test": "",
        "num_ids": 379,
        "indeed": false
    },
    {
        "number": 2509,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(K + 1, N + 1):\n        count += N - i + 1\n    return str(count)",
        "test": "",
        "num_ids": 56,
        "indeed": false
    },
    {
        "number": 2510,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n\n    for _ in range(M):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (N + 1)\n    groups = 0\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i)\n            groups += 1\n\n    return str(groups)\n",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2511,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, colors, adj, dp):\n        if node in dp:\n            return dp[node]\n        res = 1\n        for child in adj[node]:\n            if child != parent:\n                res *= dfs(child, node, colors, adj, dp)\n                res %= MOD\n        dp[node] = res * colors\n        return dp[node]\n\n    N, K, stdin = map(int, stdin.split())\n    a, b = zip(*[map(int, stdin.split()) for _ in range(N - 1)])\n    adj = [[] for _ in range(N + 1)]\n    for x, y in zip(a, b):\n        adj[x].append(y)\n        adj[y].append(x)\n\n    MOD = 1_000_000_007\n    dp = {}\n    return dfs(1, 0, K, adj, dp)",
        "test": "",
        "num_ids": 242,
        "indeed": false
    },
    {
        "number": 2512,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    items = [list(map(int, stdin.split()[3 + 3 * i:3 + 3 * (i + 1)])) for i in range(K)]\n    items.sort(key=lambda x: x[2])\n\n    dp = [[0] * (C + 1) for _ in range(R + 1)]\n\n    for r, c, v in items:\n        for i in range(r, 0, -1):\n            for j in range(1, c + 1):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + v)\n            if i > 1:\n                for j in range(1, C + 1):\n                    dp[i][j] = max(dp[i][j], dp[i - 2][j])\n\n    return str(dp[R][C])",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 2513,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = map(str, stdin.split())\n    N = int(N)\n\n    def is_valid(species: str) -> bool:\n        for i in range(N):\n            if species[i] == species[(i + 1) % N]:\n                if s[i] == 'o':\n                    return False\n            else:\n                if s[i] == 'x':\n                    return False\n        return True\n\n    for species in ['S' * N, 'W' * N]:\n        if is_valid(species):\n            return species\n\n    return '-1'",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 2514,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def update_sequence(sequence: list, value_to_replace: int, new_value: int) -> None:\n        for i in range(len(sequence)):\n            if sequence[i] == value_to_replace:\n                sequence[i] = new_value\n\n    def calculate_sum(sequence: list) -> int:\n        return sum(sequence)\n\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    a = input_list[1:n + 1]\n    q = input_list[n + 1]\n    b_c_pairs = [input_list[n + 2 + 2 * i:n + 2 + 2 * (i + 1)] for i in range(q)]\n\n    s_list = []\n    for i in range(q):\n        update_sequence(a, b_c_pairs[i][0], b_c_pairs[i][1])\n        s_list.append(calculate_sum(a))\n\n    return \"\\n\".join(map(str, s_list))",
        "test": "",
        "num_ids": 266,
        "indeed": true
    },
    {
        "number": 2515,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def is_similar_to_2017(n: int) -> bool:\n        return is_prime(n) and is_prime((n + 1) // 2)\n\n    queries = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = []\n    for l, r in queries:\n        count = 0\n        for x in range(l, r + 1, 2):\n            if is_similar_to_2017(x):\n                count += 1\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 269,
        "indeed": true
    },
    {
        "number": 2516,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = input()\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            substring = S[i:j+1]\n            if int(substring) % P == 0:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 86,
        "indeed": false
    },
    {
        "number": 2517,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, R = map(int, stdin.readline().split())\n    r_towns = list(map(int, stdin.readline().split()))\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    def find_min_distance(start: int, end: int, visited: set) -> int:\n        if start == end:\n            return 0\n        min_distance = float('inf')\n        for road in roads:\n            if road[0] == start and road[1] not in visited:\n                visited.add(road[1])\n                min_distance = min(min_distance, road[2] + find_min_distance(road[1], end, visited))\n                visited.remove(road[1])\n            elif road[1] == start and road[0] not in visited:\n                visited.add(road[0])\n                min_distance = min(min_distance, road[2] + find_min_distance(road[0], end, visited))\n                visited.remove(road[0])\n        return min_distance\n\n    min_distance = float('inf')\n    for i in range(R - 1):\n        min_distance = min(min_distance, find_min_distance(r_towns[i], r_towns[i + 1], set(r_towns[:i + 1])))\n\n    return str(min_distance)",
        "test": "",
        "num_ids": 347,
        "indeed": false
    },
    {
        "number": 2518,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, *h = list(map(int, stdin.split()))\n    h.sort(reverse=True)\n\n    explosions = 0\n    for i in range(N):\n        if h[i] > 0:\n            h[i] -= A\n            explosions += 1\n            for j in range(i + 1, N):\n                h[j] -= B\n        else:\n            break\n\n    return str(explosions)",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 2519,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def expected_value(p, K):\n        total = sum(p[:K])\n        max_value = total\n        for i in range(K, len(p) + 1):\n            total += p[i - 1] - p[i - K]\n            max_value = max(max_value, total)\n        return max_value / K\n\n    return f\"{expected_value(p, K):.10f}\"",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2520,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_friend(a, b):\n        for i in range(len(friendships)):\n            if (friendships[i][0] == a and friendships[i][1] == b) or (friendships[i][0] == b and friendships[i][1] == a):\n                return True\n        return False\n\n    def is_blocked(a, b):\n        for i in range(len(blockships)):\n            if (blockships[i][0] == a and blockships[i][1] == b) or (blockships[i][0] == b and blockships[i][1] == a):\n                return True\n        return False\n\n    def find_path(a, b, visited):\n        if a == b:\n            return True\n        visited.add(a)\n        for i in range(len(friendships)):\n            if friendships[i][0] == a and friendships[i][1] == b:\n                return True\n            elif friendships[i][0] == b and friendships[i][1] == a:\n                return True\n        for i in range(len(friendships)):\n            if friendships[i][0] == a and friendships[i][1] not in visited:\n                if find_path(friendships[i][1], b, visited):\n                    return True\n            elif friendships[i][1] == a and friendships[i][0] not in visited:\n                if find_path(friendships[i][0], b, visited):\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    friendships = [list(map(int, line.split())) for line in lines[1:M + 1]]\n    blockships = [list(map(int, line.split())) for line in lines[M + 1:M + K + 1]]\n\n    result = []\n    for i in range(1, N + 1):\n        count = 0\n        for j in range(1, N + 1):\n            if i != j and not is_friend(i, j) and not is_blocked(i, j) and find_path(i, j, set()):\n                count += 1\n        result.append(count)\n\n    return ' '.join(map(str, result))",
        "test": "",
        "num_ids": 564,
        "indeed": true
    },
    {
        "number": 2521,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    a.sort()\n\n    first_half = a[:2 * N]\n    second_half = a[2 * N:]\n\n    max_score = float('-inf')\n\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                score = sum(first_half[:i] + first_half[i + 1:]) - sum(second_half[:j] + second_half[j + 1:])\n                max_score = max(max_score, score)\n\n    return str(max_score)",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 2522,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    B = list(map(int, stdin.split('\\n')[2].split()))\n\n    if len(set(A)) != len(A) or len(set(B)) != len(B):\n        return \"No\"\n\n    for i in range(N):\n        if A[i] == B[i]:\n            return \"No\"\n\n    for i in range(N):\n        if A[i] != B[i]:\n            B[i], B[A.index(B[i])] = B[A.index(B[i])], B[i]\n\n    return \"Yes\\n\" + \" \".join(map(str, B))",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 2523,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 0\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            segment = s[i:i + length]\n            if all(c == '0' for c in segment):\n                continue\n            if all(c == '1' for c in segment):\n                k = max(k, length)\n                break\n\n    return str(k)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2524,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    mod = 10**9 + 7\n    result = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            result += a[i] ^ a[j]\n\n    return str(result % mod)\n",
        "test": "",
        "num_ids": 88,
        "indeed": true
    },
    {
        "number": 2525,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    S = lines[0]\n    Q = int(lines[1])\n    queries = lines[2:]\n\n    for i in range(Q):\n        query = queries[i].split()\n        T_i = int(query[0])\n\n        if T_i == 1:\n            S = S[::-1]\n        elif T_i == 2:\n            F_i = int(query[1])\n            C_i = query[2]\n            if F_i == 1:\n                S = C_i + S\n            elif F_i == 2:\n                S = S + C_i\n\n    return S",
        "test": "",
        "num_ids": 166,
        "indeed": true
    },
    {
        "number": 2526,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, A, B, C = map(int, stdin.split()[0:5])\n    p = list(map(int, stdin.split()[5:5 + A]))\n    q = list(map(int, stdin.split()[5 + A:5 + A + B]))\n    r = list(map(int, stdin.split()[5 + A + B:5 + A + B + C]))\n\n    p.sort(reverse=True)\n    q.sort(reverse=True)\n    r.sort(reverse=True)\n\n    total_sum = 0\n\n    for i in range(X):\n        total_sum += p.pop(0)\n\n    for i in range(Y):\n        total_sum += q.pop(0)\n\n    for i in range(min(X, len(r))):\n        total_sum += r.pop(0)\n\n    return str(total_sum)",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 2527,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = \"iloveyou\"\n    stdin_set = set(stdin)\n    message_set = set(message)\n\n    if message_set.issubset(stdin_set):\n        return \"happy\"\n    else:\n        return \"sad\"",
        "test": "",
        "num_ids": 67,
        "indeed": false
    },
    {
        "number": 2528,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_len = 0\n    temp_len = 0\n\n    for i in range(n):\n        if arr[i] != 0:\n            temp_len += 1\n        else:\n            max_len = max(max_len, temp_len)\n            temp_len = 0\n\n    max_len = max(max_len, temp_len)\n\n    return str(max_len)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 2529,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    if x % 5 != 0:\n        return format(y, \".2f\")\n    else:\n        if x + 0.5 > y:\n            return format(y, \".2f\")\n        else:\n            return format(y - x - 0.5, \".2f\")",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 2530,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def strcmp(s1: str, s2: str) -> int:\n        for i in range(min(len(s1), len(s2))):\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        if len(s1) < len(s2):\n            return -1\n        elif len(s1) > len(s2):\n            return 1\n        else:\n            return 0\n\n    def find_winner(votes: dict, countries: dict) -> str:\n        max_votes = 0\n        country_winner = \"\"\n        chef_winner = \"\"\n        for chef, votes_count in votes.items():\n            if votes_count > max_votes:\n                max_votes = votes_count\n                chef_winner = chef\n                country_winner = countries[chef]\n            elif votes_count == max_votes:\n                if strcmp(countries[chef], country_winner) < 0:\n                    country_winner = countries[chef]\n                elif strcmp(countries[chef], country_winner) == 0:\n                    if strcmp(chef, chef_winner) < 0:\n                        chef_winner = chef\n        return country_winner, chef_winner\n\n    lines = stdin.split(\"\\n\")\n    N, M = map(int, lines[0].split())\n    chefs = {}\n    countries = {}\n    for i in range(1, N + 1):\n        name, country = lines[i].split()\n        chefs[name] = 0\n        countries[name] = country\n\n    for i in range(N + 1, N + M + 1):\n        subject = lines[i]\n        if subject in chefs:\n            chefs[subject] += 1\n\n    country_winner, chef_winner = find_winner(chefs, countries)\n    return f\"{country_winner}\\n{chef_winner}\\n\"",
        "test": "",
        "num_ids": 506,
        "indeed": false
    },
    {
        "number": 2531,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [int(x) for x in stdin.readlines()]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == 2 * a[j]:\n                count += 1\n                break\n            if a[j] == 2 * a[i]:\n                count += 1\n                break\n    return str(count)",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 2532,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_next_value(Xn, a1, a2, b1, b2, d1, d2, modulo):\n        return (Xn * a1 + a2) % modulo\n\n    def compute_sequence(p, q, a1, a2, b1, b2, d1, d2, Xn, length, modulo):\n        sequence = [Xn]\n        for _ in range(length - 1):\n            Xn = compute_next_value(Xn, a1, a2, b1, b2, d1, d2, modulo)\n            sequence.append(Xn)\n        return sequence\n\n    def find_sequence_parameters(Xn, a1, a2, b1, b2, d1, d2, modulo):\n        for p in range(5):\n            for q in range(5):\n                for b1_ in range(-100, 101):\n                    for b2_ in range(-100, 101):\n                        for d1_ in range(1, 101):\n                            for d2_ in range(1, 101):\n                                sequence = compute_sequence(p, q, a1, a2, b1_, b2_, d1_, d2_, Xn, 10, modulo)\n                                if sequence == Xn_list:\n                                    return p, q, a1, a2, b1_, b2_, d1_, d2_\n        return None\n\n    stdin_list = list(map(int, stdin.split()))\n    p, q = stdin_list[0], stdin_list[1]\n    a1, a2 = stdin_list[2], stdin_list[3]\n    b1, b2 = stdin_list[4], stdin_list[5]\n    d1, d2 = stdin_list[6], stdin_list[7]\n    Xn_list = stdin_list[8:]\n\n    modulo = 10**6\n    sequence_parameters = find_sequence_parameters(Xn_list[0], a1, a2, b1, b2, d1, d2, modulo)\n    if sequence_parameters:\n        p, q, a1, a2, b1, b2, d1, d2 = sequence_parameters\n        next_sequence = compute_sequence(p, q, a1, a2, b1, b2, d1, d2, Xn_list[-1], 10, modulo)\n        return \" \".join(map(str, next_sequence))\n    else:\n        return \"Not found\"",
        "test": "",
        "num_ids": 638,
        "indeed": false
    },
    {
        "number": 2533,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, start, current, path):\n        if current == start and len(path) == len(graph):\n            return True\n        if current in visited:\n            return False\n        visited.add(current)\n        for neighbor in graph[current]:\n            if dfs(graph, visited, start, neighbor, path + [(current, neighbor)]):\n                return True\n        visited.remove(current)\n        return False\n\n    def create_graph(roads):\n        graph = {i: [] for i in range(1, N + 1)}\n        for a, b in roads:\n            graph[a].append(b)\n        return graph\n\n    def find_cycle(graph, start):\n        visited = set()\n        return dfs(graph, visited, start, start, [])\n\n    def redirect_roads(roads):\n        graph = create_graph(roads)\n        for i in range(1, N + 1):\n            if not find_cycle(graph, i):\n                for j in range(len(roads)):\n                    if roads[j][0] == i:\n                        roads[j] = (i, roads[j][1])\n                    elif roads[j][1] == i:\n                        roads[j] = (roads[j][0], i)\n                break\n        return roads\n\n    lines = stdin.split('\\n')\n    N, E = map(int, lines[0].split())\n    roads = [tuple(map(int, line.split())) for line in lines[1:E + 1]]\n\n    if E < N - 1:\n        return \"NO\"\n\n    redirected_roads = redirect_roads(roads)\n    if all(roads[i] == redirected_roads[i] for i in range(E)):\n        return \"NO\"\n\n    output = [\"YES\"]\n    for road in redirected_roads:\n        output.append(f\"{road[0]} {road[1]}\")\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 489,
        "indeed": false
    },
    {
        "number": 2534,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(R)]\n\n    min_cost = float('inf')\n    max_cost = float('-inf')\n    for row in matrix:\n        min_cost_in_row = min(row)\n        if min_cost_in_row < min_cost:\n            min_cost = min_cost_in_row\n            max_cost = max(row)\n        elif min_cost_in_row == min_cost:\n            max_cost_in_row = max(row)\n            if max_cost_in_row > max_cost:\n                max_cost = max_cost_in_row\n\n    if max_cost == float('-inf'):\n        return \"GUESS\"\n    else:\n        return min_cost * max_cost",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 2535,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, N = map(int, stdin.readline().split())\n    free_compartments = []\n    for i in range(N):\n        free_places = []\n        for j in range(9):\n            if stdin.readline()[j * 6] == '0':\n                free_places.append(j + 1)\n        free_compartments.append(free_places)\n\n    def count_ways(compartment, X):\n        if X == 0:\n            return 1\n        if compartment == 9 or X > 6 or X < 0:\n            return 0\n        return count_ways(compartment + 1, X) + count_ways(compartment + 1, X - 1)\n\n    ways = 0\n    for i in range(N):\n        for j in free_compartments[i]:\n            ways += count_ways(j, X)\n\n    return str(ways)",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 2536,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    A = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    L = int(stdin.readline())\n    E1, E2 = 0, 0\n\n    for _ in range(L):\n        i, j = map(int, stdin.readline().split())\n        E1 += A[i - 1][j - 1] if i <= N and j <= M else -1\n        E2 += A[j - 1][i - 1] if j <= N and i <= M else -1\n\n    return str(max(E1, E2))",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2537,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(s: str, t: str, p: str) -> bool:\n        if s == t:\n            return True\n        if len(s) != len(t) or len(s) != len(p) or len(t) != len(p):\n            return False\n\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                if s[i] not in p or t[i] not in p:\n                    return False\n\n        return True\n\n    q = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(q):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        p = stdin.readline().strip()\n\n        if is_possible(s, t, p):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 2538,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    result = []\n\n    for query in queries:\n        str_val, int_val, exp_val = map(int, query.split())\n        count = 0\n\n        for i in range(str_val + 1):\n            j = exp_val - i\n            if i > int_val:\n                break\n            if j >= 0 and i + j <= exp_val:\n                count += 1\n\n        result.append(str(count))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 2539,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    def generate_sequence(x, p):\n        y = x + 1\n        while not is_coprime(p, y):\n            y += 1\n        return y\n\n    t = int(stdin.split('\\n')[0])\n    queries = [list(map(int, query.split())) for query in stdin.split('\\n')[1:]]\n\n    results = []\n    for query in queries:\n        x, p, k = query\n        sequence = [generate_sequence(x, p)]\n        for _ in range(k - 1):\n            sequence.append(generate_sequence(sequence[-1], p))\n        results.append(sequence[-1])\n\n    return '\\n'.join(map(str, results))",
        "test": "",
        "num_ids": 234,
        "indeed": true
    },
    {
        "number": 2540,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors, edges = parse_input(stdin)\n    tree = build_tree(n, edges)\n    subtree_colors = get_subtree_colors(tree, colors)\n    dominating_colors = get_dominating_colors(subtree_colors)\n    sums = get_sums(tree, dominating_colors)\n    return \" \".join(map(str, sums))\n\ndef",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 2541,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_power(x):\n        if x == 1:\n            return True\n        a = 2\n        p = 2\n        while a**p <= x:\n            if a**p == x:\n                return True\n            a += 1\n            p = 2\n        return False\n\n    def count_powers(L, R):\n        return sum(is_power(x) for x in range(L, R + 1))\n\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    result = [count_powers(L, R) for L, R in queries]\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 172,
        "indeed": false
    },
    {
        "number": 2542,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        s = stdin.readline().strip()\n        n = len(s)\n        left_cyclic_shift = s[1:] + s[0]\n        right_cyclic_shift = s[-1] + s[:-1]\n\n        if left_cyclic_shift == right_cyclic_shift:\n            result.append(0)\n        else:\n            for i in range(n):\n                if s[i:] + s[:i] == s[-i:] + s[:-i]:\n                    result.append(i)\n                    break\n            else:\n                result.append(n)\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 2543,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(j: int) -> int:\n        return abs(sum([(-1) ** (i - 1) * (a[i] - b[i + j]) for i in range(n)]))\n\n    def update(l: int, r: int, x: int) -> None:\n        for i in range(l - 1, r):\n            a[i] += x\n\n    n, m, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    min_f = f(0)\n    result = [str(min_f)]\n\n    for _ in range(q):\n        l, r, x = map(int, stdin.readline().split())\n        update(l, r, x)\n        min_f = f(0)\n        result.append(str(min_f))\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2544,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_centroid(graph, n):\n        for i in range(1, n + 1):\n            if i not in graph:\n                graph[i] = []\n\n        visited = [False] * (n + 1)\n        parent = [0] * (n + 1)\n        size = [1] * (n + 1)\n        centroid = None\n\n        def dfs(node):\n            nonlocal centroid\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    parent[neighbor] = node\n                    size[node] += dfs(neighbor)\n\n            if size[node] * 2 > n:\n                centroid = node\n                return 0\n            return size[node]\n\n        dfs(1)\n        return centroid\n\n    def find_edge_to_cut(graph, centroid):\n        for neighbor in graph[centroid]:\n            graph[neighbor].remove(centroid)\n            yield (centroid, neighbor)\n\n    def find_edge_to_add(graph, centroid):\n        for i in range(1, len(graph) + 1):\n            if i != centroid and i not in graph[centroid]:\n                for neighbor in graph[i]:\n                    if neighbor != centroid and neighbor not in graph[centroid]:\n                        return (i, neighbor)\n\n    t = int(stdin.readline())\n    output = []\n\n    for _ in range(t):\n        n = int(stdin.readline())\n        graph = {}\n\n        for _ in range(n - 1):\n            x, y = map(int, stdin.readline().split())\n            if x not in graph:\n                graph[x] = []\n            if y not in graph:\n                graph[y] = []\n            graph[x].append(y)\n            graph[y].append(x)\n\n        centroid = find_centroid(graph, n)\n        edge_to_cut = next(find_edge_to_cut(graph, centroid))\n        edge_to_add = find_edge_to_add(graph, centroid)\n\n        output.append(f\"{edge_to_cut[0]} {edge_to_cut[1]}\")\n        output.append(f\"{edge_to_add[0]} {edge_to_add[1]}\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 592,
        "indeed": false
    },
    {
        "number": 2545,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(a: int, b: int) -> bool:\n        if a == 0 and b == 0:\n            return True\n        if a % 2 != b % 2:\n            return False\n        return is_possible(a // 2, b // 2)\n\n    t = int(stdin.split('\\n')[0])\n    test_cases = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    results = []\n    for a, b in test_cases:\n        if is_possible(a, b):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return \"\\n\".join(results)\n",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 2546,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(arr: List[int]) -> int:\n        n = len(arr)\n        arr.sort()\n        if n % 2 == 0:\n            return (arr[n // 2 - 1] + arr[n // 2]) // 2\n        else:\n            return arr[n // 2]\n\n    def binary_search(l: int, r: int, n: int, s: int, employees: List[Tuple[int, int]]) -> int:\n        while l <= r:\n            mid = (l + r) // 2\n            total_salaries = 0\n            for i in range(n):\n                if employees[i][0] <= mid <= employees[i][1]:\n                    total_salaries += mid\n                else:\n                    total_salaries += employees[i][0] if mid - employees[i][0] < employees[i][1] - mid else employees[i][1]\n            if total_salaries <= s:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l - 1\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        n, s = map(int, stdin.readline().split())\n        employees = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().split())\n            employees.append((l, r))\n        max_median = binary_search(1, 10**9, n, s, employees)\n        output.append(str(max_median))\n    return \"\\n\".join(output) ",
        "test": "",
        "num_ids": 400,
        "indeed": false
    },
    {
        "number": 2547,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(books: List[int]) -> bool:\n        alice_likes = sum(a_i for i, a_i, b_i in books)\n        bob_likes = sum(b_i for i, a_i, b_i in books)\n        return alice_likes >= k and bob_likes >= k\n\n    def find_min_time(books: List[int]) -> int:\n        return sum(t_i for i, t_i, a_i, b_i in books)\n\n    n, m, k = map(int, stdin.readline().split())\n    books = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    for subset in itertools.combinations(books, m):\n        if is_valid(subset):\n            return f\"{find_min_time(subset)}\\n{' '.join(str(i) for i, *_ in subset)}\"\n\n    return \"-1\"",
        "test": "",
        "num_ids": 243,
        "indeed": false
    },
    {
        "number": 2548,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_subarray(arr: List[int], l: int, r: int) -> bool:\n        return sum(arr[l:r + 1]) == r - l + 1\n\n    def count_good_subarrays(arr: List[int]) -> int:\n        n = len(arr)\n        count = 0\n        for l in range(n):\n            for r in range(l, n):\n                if is_good_subarray(arr, l, r):\n                    count += 1\n        return count\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        arr = list(map(int, stdin.readline().strip()))\n        result.append(count_good_subarrays(arr))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 2549,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inv(a, m):\n        return pow(a, m - 2, m)\n\n    n, m = map(int, stdin.readline().split())\n    d = list(map(int, stdin.readline().split()))\n    shields = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    result = []\n    for a, b in shields:\n        damage = 0\n        for i, d_i in enumerate(d):\n            if i >= a:\n                damage += d_i\n            elif d_i >= b:\n                damage += 1\n        g = gcd(damage, 998244353)\n        damage //= g\n        result.append(str(damage * mod_inv(g, 998244353) % 998244353))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 263,
        "indeed": false
    },
    {
        "number": 2550,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_test_cases = int(stdin.split('\\n')[0])\n    test_cases = stdin.split('\\n')[1:]\n    outputs = []\n\n    for i in range(n_test_cases):\n        n, m = map(int, test_cases[i*2].split())\n        a = list(map(int, test_cases[i*2+1].split()))\n        avg = sum(a) / n\n\n        my_score = 0\n        for j in range(n):\n            if a[j] < m and a[j] < avg - (n-1)*my_score/(n-1):\n                my_score = a[j]\n\n        outputs.append(str(my_score))\n\n    return '\\n'.join(outputs)",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 2551,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n\n        if set(t) - set(s):\n            result.append(-1)\n            continue\n\n        z = \"\"\n        count = 0\n\n        for c in t:\n            if c not in z:\n                z += c\n                count += 1\n\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 142,
        "indeed": false
    },
    {
        "number": 2552,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(source, target, happiness, visited, graph):\n        if source == target:\n            return happiness\n        for neighbor in graph[source]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                result = dfs(neighbor, target, happiness + graph[source][neighbor], visited, graph)\n                if result is not None:\n                    return result\n        return None\n\n    def check_happiness(n, m, p, h, roads, graph):\n        for i in range(1, n + 1):\n            happiness = dfs(i, 1, 0, {i}, graph)\n            if happiness is None or happiness != h[i - 1]:\n                return False\n        return True\n\n    test_cases = stdin.split(\"\\n\\n\")\n    result = []\n    for test in test_cases:\n        lines = test.split(\"\\n\")\n        n, m = map(int, lines[0].split())\n        p = list(map(int, lines[1].split()))\n        h = list(map(int, lines[2].split()))\n        roads = [list(map(int, line.split())) for line in lines[3:3 + n - 1]]\n        graph = [{} for _ in range(n + 1)]\n        for x, y in roads:\n            graph[x][y] = 1\n            graph[y][x] = 1\n        if check_happiness(n, m, p, h, roads, graph):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 394,
        "indeed": false
    },
    {
        "number": 2553,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_odd(num: int) -> bool:\n        return num % 2 != 0\n\n    def can_select_odd_sum(n: int, x: int, arr: list) -> bool:\n        arr.sort()\n        total = sum(arr[:x])\n\n        if is_odd(total):\n            return True\n\n        for i in range(x, n):\n            total += arr[i] - arr[i - x]\n            if is_odd(total):\n                return True\n\n        return False\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    outputs = []\n\n    for i in range(1, t + 1):\n        n, x = map(int, lines[i].split())\n        arr = list(map(int, lines[i + 1].split()))\n\n        if can_select_odd_sum(n, x, arr):\n            outputs.append(\"Yes\")\n        else:\n            outputs.append(\"No\")\n\n    return '\\n'.join(outputs)",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 2554,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_sum(a: List[int]) -> int:\n        n = len(a)\n        return sum(a[i] for i in range(0, n, 2))\n\n    def reverse_subarray(a: List[int], l: int, r: int) -> List[int]:\n        a[l:r+1] = a[l:r+1][::-1]\n        return a\n\n    def process_test_case(n: int, a: List[int]) -> int:\n        if n % 2 == 0:\n            return max_sum(a)\n        else:\n            max_sum_ = 0\n            for i in range(n):\n                if i % 2 == 0:\n                    a_ = reverse_subarray(a.copy(), i, n-1)\n                    max_sum_ = max(max_sum_, max_sum(a_))\n            return max_sum_\n\n    t = int(stdin.readline().strip())\n    output = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        output.append(process_test_case(n, a))\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 320,
        "indeed": false
    },
    {
        "number": 2555,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def alternating_sum(arr):\n        return sum(arr[::2]) - sum(arr[1::2])\n\n    def process_operations(a, operations):\n        for l, r in operations:\n            a[l], a[r] = a[r], a[l]\n        return a\n\n    def max_strength(a, operations):\n        strengths = [alternating_sum(a)]\n        for op in operations:\n            a = process_operations(a, [op])\n            strengths.append(alternating_sum(a))\n        return strengths\n\n    test_cases = stdin.split(\"\\n\")\n    n_test_cases = int(test_cases[0])\n    test_cases = test_cases[1:]\n    result = []\n\n    for i in range(n_test_cases):\n        n, q = map(int, test_cases[0].split())\n        a = list(map(int, test_cases[1].split()))\n        operations = [list(map(int, test_cases[2 + j].split())) for j in range(q)]\n        strengths = max_strength(a, operations)\n        result.extend(strengths)\n        result.append(\"\\n\")\n\n        test_cases = test_cases[2 + q:]\n\n    return \" \".join(map(str, result))[:-1]",
        "test": "",
        "num_ids": 331,
        "indeed": false
    },
    {
        "number": 2556,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rooms = [list(map(int, room.split())) for room in stdin.split('\\n')[1:]]\n\n    result = []\n    for c_i, sum_i in rooms:\n        if sum_i == 0:\n            result.append(0)\n        else:\n            sections = [i for i in range(sum_i + 1)]\n            radiators = [i for i in range(c_i + 1)]\n            costs = [[0] * (sum_i + 1) for _ in range(c_i + 1)]\n\n            for i in range(1, c_i + 1):\n                for j in range(1, sum_i + 1):\n                    if j <= i:\n                        costs[i][j] = min(costs[i - k][j - k] + (k * k) for k in range(1, j + 1))\n                    else:\n                        costs[i][j] = costs[i][j - 1]\n\n            result.append(costs[-1][-1])\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 2557,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    important_pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        important_pairs.append((a, b))\n\n    def find_parent(parent, x):\n        if parent[x] == x:\n            return x\n        parent[x] = find_parent(parent, parent[x])\n        return parent[x]\n\n    def union_parent(parent, x, y):\n        x = find_parent(parent, x)\n        y = find_parent(parent, y)\n        if x != y:\n            parent[y] = x\n\n    parent = [i for i in range(n + 1)]\n    for a, b in important_pairs:\n        union_parent(parent, a, b)\n\n    return str(len(set([find_parent(parent, x) for x in range(1, n + 1)])) - 1)",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 2558,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_kill_enemy(a, b, c, d):\n        total_damage = a * c\n        total_heal = b * (c - 1)\n        if total_damage > total_heal:\n            return False\n        return True\n\n    def max_health_points(a, b, c, d):\n        total_damage = a * c\n        total_heal = b * (c - 1)\n        if total_damage > total_heal:\n            return -1\n        return total_damage - b\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n    for i in range(1, t + 1):\n        a, b, c, d = map(int, lines[i].split())\n        if can_kill_enemy(a, b, c, d):\n            result.append(max_health_points(a, b, c, d))\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 263,
        "indeed": false
    },
    {
        "number": 2559,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_max_sum(k, roads):\n        min_sum = 0\n        max_sum = 0\n        for i in range(1, k + 1):\n            min_sum += min(roads[i - 1])\n            max_sum += max(roads[i - 1])\n        return min_sum, max_sum\n\n    def main():\n        t = int(stdin.readline().strip())\n        for _ in range(t):\n            k = int(stdin.readline().strip())\n            roads = []\n            for _ in range(2 * k - 1):\n                a, b, t = map(int, stdin.readline().strip().split())\n                roads.append((a - 1, b - 1, t))\n\n            min_sum, max_sum = find_min_max_sum(k, roads)\n            print(min_sum, max_sum)\n\n    main()",
        "test": "",
        "num_ids": 230,
        "indeed": false
    },
    {
        "number": 2560,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t + 1):\n        n, l, r = map(int, stdin.split('\\n')[i].split())\n        if n < l:\n            result.append(\"No\")\n        else:\n            total = 0\n            for j in range(l, r + 1):\n                total += j\n            if total >= n:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 2561,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_solutions(a: int) -> int:\n        count = 0\n        for x in range(2**30):\n            if (a - (a ^ x) - x) == 0:\n                count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    values_a = [int(line) for line in lines[1:t+1]]\n\n    result = []\n    for a in values_a:\n        result.append(count_solutions(a))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 2562,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    MOD = 1000000007\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def clan_strength(i, j):\n        return (j - i + 1) * lcm(a[i], a[i + 1], a[i + 2])\n\n    def count_clans(i, j):\n        if i == j:\n            return 1\n        if i + 1 == j:\n            return 2\n        return count_clans(i, j - 1) + count_clans(i + 1, j)\n\n    army_strength = 0\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            army_strength += clan_strength(i, j) * count_clans(i, j)\n            army_strength %= MOD\n\n    return str(army_strength)",
        "test": "",
        "num_ids": 311,
        "indeed": false
    },
    {
        "number": 2563,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap_digits(a: str, i: int, j: int) -> str:\n        a = list(a)\n        a[i], a[j] = a[j], a[i]\n        return ''.join(a)\n\n    def is_valid_swap(a: str, i: int, j: int) -> bool:\n        return a[i] != a[j] and (int(a[i]) % 2 != int(a[j]) % 2)\n\n    def find_min_integer(a: str) -> str:\n        n = len(a)\n        min_integer = a\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if is_valid_swap(a, i, j):\n                    new_integer = swap_digits(a, i, j)\n                    min_integer = min(min_integer, new_integer)\n        return min_integer\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    test_cases = lines[1:]\n    results = []\n\n    for a in test_cases:\n        results.append(find_min_integer(a))\n\n    return '\\n'.join(results)",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 2564,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def smallest_operations(a: int, b: int, n: int) -> int:\n        if a >= b:\n            a, b = b, a\n        if b >= n:\n            return 0\n        if a + b > n:\n            return 1\n        return (n - a - b) // (a + b) + 1\n\n    T = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n', 1)[1].split('\\n')\n    outputs = []\n\n    for i in range(T):\n        a, b, n = map(int, lines[i].split())\n        outputs.append(smallest_operations(a, b, n))\n\n    return '\\n'.join(map(str, outputs))",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 2565,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_sum(x1, y1, z1, x2, y2, z2):\n        c = [a * b for a, b in zip([x1, y1, z1], [x2, y2, z2])]\n        c.sort(reverse=True)\n        return sum(c)\n\n    t = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n', 1)[1].split('\\n')\n    outputs = []\n\n    for i in range(t):\n        x1, y1, z1 = map(int, lines[i * 2].split())\n        x2, y2, z2 = map(int, lines[i * 2 + 1].split())\n        outputs.append(max_sum(x1, y1, z1, x2, y2, z2))\n\n    return '\\n'.join(map(str, outputs))",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 2566,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_period(k: int, days: list) -> int:\n        days_sum = sum(days)\n        if k > days_sum:\n            return -1\n\n        period_length = 0\n        current_sum = 0\n        for i in range(7):\n            current_sum += days[i]\n            if current_sum >= k:\n                period_length += i + 1\n                current_sum = 0\n\n        return period_length\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(t):\n        k, days = map(int, stdin.split('\\n')[i * 2 + 1].split())\n        days = list(map(int, stdin.split('\\n')[i * 2 + 2].split()))\n        result.append(find_shortest_period(k, days))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 2567,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(a: str, b: str) -> bool:\n        return any(a[i] == b[i] for i in range(len(a)))\n\n    def find_similar_string(s: str, n: int) -> str:\n        for i in range(2 ** n):\n            binary_str = format(i, f'0{n}b')\n            if all(is_similar(s[j:j + n], binary_str) for j in range(n, 2 * n - 1, n)):\n                return binary_str\n        return \"\"\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        result.append(find_similar_string(s, n))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2568,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process(s: str) -> int:\n        res = 0\n        init = 0\n        while True:\n            cur = init\n            ok = True\n            for i in range(len(s)):\n                res += 1\n                if s[i] == '+':\n                    cur += 1\n                else:\n                    cur -= 1\n                if cur < 0:\n                    ok = False\n                    break\n            if ok:\n                break\n            init += 1\n        return res\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        s = stdin.readline().strip()\n        result.append(process(s))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2569,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_claw(n: int) -> int:\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0\n        if n == 3:\n            return 4\n        if n == 4:\n            return 4\n        if n % 2 == 0:\n            return 4 * (n // 2 - 1) + count_claw(n - 2)\n        else:\n            return 4 * (n // 2) + count_claw(n - 1)\n\n    def modulo(x: int) -> int:\n        return x % (10**9 + 7)\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        result.append(modulo(count_claw(n)))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 2570,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_rearrange(a: List[int], b: List[int], x: int) -> bool:\n        a.sort()\n        b.sort()\n        i, j = 0, 0\n        while i < len(a) and j < len(b):\n            if a[i] + b[j] <= x:\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return i == len(a)\n\n    test_cases = stdin.split(\"\\n\\n\")\n    output = []\n    for case in test_cases:\n        lines = case.split(\"\\n\")\n        n, x = map(int, lines[0].split())\n        a = list(map(int, lines[1].split()))\n        b = list(map(int, lines[2].split()))\n        if can_rearrange(a, b, x):\n            output.append(\"Yes\")\n        else:\n            output.append(\"No\")\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 248,
        "indeed": false
    },
    {
        "number": 2571,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_seals(energies):\n        n = len(energies)\n        seals = [1] * n\n        for i in range(n):\n            if energies[i] < 0:\n                seals[i] = -1\n        return seals\n\n    T = int(stdin.readline().strip())\n    output = []\n    for _ in range(T):\n        n = int(stdin.readline().strip())\n        energies = list(map(int, stdin.readline().strip().split()))\n        seals = find_seals(energies)\n        output.append(\" \".join(map(str, seals)))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 2572,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(matrix):\n        for row in matrix:\n            if row != row[::-1]:\n                return False\n        for col in range(len(matrix[0])):\n            col_list = [matrix[i][col] for i in range(len(matrix))]\n            if col_list != col_list[::-1]:\n                return False\n        return True\n\n    def min_operations(matrix):\n        n, m = len(matrix), len(matrix[0])\n        min_ops = float('inf')\n        for i in range(n):\n            for j in range(m):\n                for k in range(n):\n                    for l in range(m):\n                        new_matrix = [[matrix[x][y] for y in range(m)] for x in range(n)]\n                        new_matrix[i][j], new_matrix[k][l] = new_matrix[k][l], new_matrix[i][j]\n                        if is_palindrome(new_matrix):\n                            min_ops = min(min_ops, abs(matrix[i][j] - matrix[k][l]))\n        return min_ops\n\n    tests = int(stdin.readline())\n    output = []\n    for _ in range(tests):\n        n, m = map(int, stdin.readline().split())\n        matrix = [list(map(int, stdin.readline().split())) for _ in range(n)]\n        output.append(min_operations(matrix))\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 377,
        "indeed": false
    },
    {
        "number": 2573,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(board: List[List[int]]) -> bool:\n        def dfs(board: List[List[int]], x: int, y: int) -> bool:\n            if x == k:\n                return True\n            if y >= n:\n                return False\n            if board[y][x]:\n                return False\n            board[y][x] = 1\n            for dx, dy in [(-1, 1), (0, 1), (1, 1)]:\n                if dfs(board, x + dx, y + dy):\n                    return True\n            board[y][x] = 0\n            return False\n\n        for i in range(n):\n            if board[i][k - 1]:\n                if not dfs(board, k - 1, i + 1):\n                    return False\n        return True\n\n    n, k, m = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    result = []\n\n    for _ in range(m):\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        if board[y][x]:\n            board[y][x] = 0\n        else:\n            board[y][x] = 1\n\n        if is_good(board):\n            result.append(0)\n        else:\n            rows_to_add = 0\n            for i in range(n):\n                if not board[i][k - 1]:\n                    rows_to_add += 1\n                    board.append([0] * n)\n                    if is_good(board):\n                        break\n            result.append(rows_to_add)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 431,
        "indeed": false
    },
    {
        "number": 2574,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_product(arr: List[int]) -> int:\n        arr.sort()\n        return arr[-1] * arr[-2] * arr[-3] * arr[-4] * arr[-5]\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i * 2 - 1])\n        arr = list(map(int, stdin.split('\\n')[i * 2].split()))\n        result.append(find_max_product(arr))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 162,
        "indeed": false
    },
    {
        "number": 2575,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    tests = int(stdin.split('\\n')[0])\n    angles = [int(x) for x in stdin.split('\\n')[1:]]\n    result = []\n    for angle in angles:\n        if angle in [30, 60, 90, 120, 150, 180]:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 112,
        "indeed": false
    },
    {
        "number": 2576,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_cutoff_score(a, b, c, d):\n        return a + b\n\n    def process_test_case(a, b, c, d):\n        return str(calculate_cutoff_score(a, b, c, d))\n\n    def process_test_cases(t, stdin):\n        lines = stdin.split(\"\\n\")\n        test_cases = []\n        for i in range(1, t + 1):\n            a, b, c, d = map(int, lines[i].split())\n            test_cases.append(process_test_case(a, b, c, d))\n        return \"\\n\".join(test_cases)\n\n    t = int(stdin.split(\"\\n\")[0])\n    return process_test_cases(t, stdin)",
        "test": "",
        "num_ids": 196,
        "indeed": true
    },
    {
        "number": 2577,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_cases = int(stdin.split('\\n')[0])\n    case_inputs = stdin.split('\\n')[1:]\n    case_outputs = []\n\n    for case in range(n_cases):\n        n, m = map(int, case_inputs[case*n+1].split())\n        a = [list(map(int, case_inputs[case*n+2+i].split())) for i in range(n)]\n\n        b = [[0] * m for _ in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                if i > 0 and a[i][j] == a[i-1][j]:\n                    b[i][j] = a[i][j] + 1\n                elif j > 0 and a[i][j] == a[i][j-1]:\n                    b[i][j] = a[i][j] + 1\n                else:\n                    b[i][j] = a[i][j]\n\n        case_outputs.extend([' '.join(map(str, row)) for row in b])\n\n    return '\\n'.join(case_outputs)",
        "test": "",
        "num_ids": 288,
        "indeed": false
    },
    {
        "number": 2578,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        k, *friends = map(int, stdin.readline().split())\n        for i in range(k - 1):\n            adj_list[friends[i] - 1].append(friends[i + 1] - 1)\n            adj_list[friends[i + 1] - 1].append(friends[i] - 1)\n\n    def dfs(u: int, visited: list) -> int:\n        if visited[u]:\n            return 0\n        visited[u] = True\n        result = 1\n        for v in adj_list[u]:\n            result += dfs(v, visited)\n        return result\n\n    result = []\n    for i in range(n):\n        visited = [False] * n\n        result.append(dfs(i, visited))\n\n    return \" \".join(map(str, result))\n",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 2579,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y, k = map(int, stdin.split())\n    count = 0\n\n    for a in range(l, r + 1):\n        for b in range(x, y + 1):\n            if a / b == k:\n                count += 1\n\n    if count > 0:\n        return \"YES\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 97,
        "indeed": true
    },
    {
        "number": 2580,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_max_distribution_index(n, edges, k_prime_factors):\n        k = 1\n        for factor in k_prime_factors:\n            k *= factor\n\n        max_distribution_index = 0\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                max_distribution_index += lcm(i, j)\n\n        return max_distribution_index % (10**9 + 7)\n\n    test_cases = int(stdin.readline().strip())\n    results = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        edges = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n - 1)]\n        m = int(stdin.readline().strip())\n        k_prime_factors = list(map(int, stdin.readline().strip().split()))\n\n        results.append(find_max_distribution_index(n, edges, k_prime_factors))\n\n    return \"\\n\".join(map(str, results))\n",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 2581,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    board = [[int(x) for x in stdin.readline().split()] for _ in range(n)]\n\n    def is_attacked(x1, y1, x2, y2):\n        return x1 == x2 or y1 == y2 or abs(x1 - x2) == abs(y1 - y2)\n\n    max_dollars = 0\n    positions = None\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n                    if not is_attacked(i + 1, j + 1, k + 1, l + 1):\n                        dollars = sum(board[i][j] for i in range(n) for j in range(n) if not is_attacked(i, j, k, l))\n                        if dollars > max_dollars:\n                            max_dollars = dollars\n                            positions = (i + 1, j + 1, k + 1, l + 1)\n\n    return f\"{max_dollars}\\n{' '.join(map(str, positions))}\"",
        "test": "",
        "num_ids": 295,
        "indeed": false
    },
    {
        "number": 2582,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    special_subsegments = 0\n\n    for l in range(n):\n        max_value = p[l]\n        for r in range(l, n):\n            max_value = max(max_value, p[r])\n            if p[l] + p[r] == max_value:\n                special_subsegments += 1\n\n    return str(special_subsegments)",
        "test": "",
        "num_ids": 134,
        "indeed": true
    },
    {
        "number": 2583,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_odd_divisor(n: int, d: int) -> bool:\n        return n % d == 0 and d % 2 != 0 and d > 1\n\n    def get_odd_divisors(n: int) -> List[int]:\n        return [d for d in range(3, n + 1, 2) if is_odd_divisor(n, d)]\n\n    def play_game(n: int) -> str:\n        while n > 1:\n            odd_divisors = get_odd_divisors(n)\n            if odd_divisors:\n                n //= odd_divisors[0]\n            else:\n                n -= 1\n        return \"Ashishgup\" if n == 1 else \"FastestFinger\"\n\n    t = int(stdin.split('\\n')[0])\n    test_cases = [int(x) for x in stdin.split('\\n')[1:]]\n    results = [play_game(n) for n in test_cases]\n    return \"\\n\".join(results)",
        "test": "",
        "num_ids": 263,
        "indeed": false
    },
    {
        "number": 2584,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_buy_k_goods(n: int, p: int, k: int, a: List[int]) -> int:\n        a.sort()\n        count = 0\n        while p >= a[-1] and k > 0:\n            p -= a.pop()\n            k -= 1\n            count += 1\n        while p >= a[0] * 2:\n            p -= a.pop(0) + a.pop(0)\n            count += 2\n        return count\n\n    t = int(stdin.split('\\n', 1)[0])\n    result = []\n    for case in stdin.split('\\n')[1:]:\n        n, p, k = map(int, case.split('\\n', 1)[0].split())\n        a = list(map(int, case.split('\\n', 1)[1].split()))\n        result.append(can_buy_k_goods(n, p, k, a))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2585,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def max_gcd(n):\n        max_gcd_value = 1\n        for i in range(1, n // 2 + 1):\n            for j in range(i + 1, n + 1):\n                max_gcd_value = max(max_gcd_value, gcd(i, j))\n        return max_gcd_value\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    output = []\n    for i in range(1, t + 1):\n        n = int(lines[i])\n        output.append(max_gcd(n))\n\n    return '\\n'.join(map(str, output))",
        "test": "",
        "num_ids": 200,
        "indeed": true
    },
    {
        "number": 2586,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_coloring(board: List[List[str]]) -> bool:\n        n, m = len(board), len(board[0])\n        black_count = 0\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 'B':\n                    black_count += 1\n                    if i > 0 and board[i - 1][j] == 'W':\n                        black_count -= 1\n                    if j > 0 and board[i][j - 1] == 'W':\n                        black_count -= 1\n                    if i < n - 1 and board[i + 1][j] == 'W':\n                        black_count -= 1\n                    if j < m - 1 and board[i][j + 1] == 'W':\n                        black_count -= 1\n        return black_count == n * m - 1\n\n    def find_good_coloring(n: int, m: int) -> List[List[str]]:\n        board = [['W' for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i % 2 == 0:\n                    board[i][j] = 'B'\n                if j % 2 == 0:\n                    board[i][j] = 'B'\n        return board\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().strip().split())\n        good_coloring = find_good_coloring(n, m)\n        result.extend([\"\".join(row) for row in good_coloring])\n        result.append(\"\")\n\n    return \"\\n\".join(result) ",
        "test": "",
        "num_ids": 456,
        "indeed": false
    },
    {
        "number": 2587,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_r(n: int) -> int:\n        max_r = 0\n        for x in range(10**(n-1), 10**n):\n            k = bin(x)[2:]\n            r = int(str(k)[:-n])\n            if r > max_r:\n                max_r = r\n        return max_r\n\n    def find_min_x(n: int, max_r: int) -> int:\n        min_x = 10**n\n        for x in range(10**(n-1), 10**n):\n            k = bin(x)[2:]\n            r = int(str(k)[:-n])\n            if r == max_r:\n                min_x = min(min_x, x)\n        return min_x\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        max_r = find_max_r(n)\n        min_x = find_min_x(n, max_r)\n        result.append(str(min_x))\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 294,
        "indeed": false
    },
    {
        "number": 2588,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost(n: int, a: int, b: int, s: str) -> int:\n        cost = 0\n        height = 1\n        for i in range(n):\n            if s[i] == '1':\n                if height == 1:\n                    cost += a * 0.5 + b * 1 + a * 0.5\n                    height = 2\n                else:\n                    cost += a * 0.5 + b * 2 + a * 0.5\n            else:\n                if height == 2:\n                    cost += a * 0.5 + b * 2 + a * 0.5\n                else:\n                    cost += a * 0.5 + b * 1 + a * 0.5\n        return cost\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        n, a, b = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n        result.append(min_cost(n, a, b, s))\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 2589,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_divisible(x: int, a: int) -> bool:\n        return a % x == 0\n\n    def longest_subarray(a: List[int], x: int) -> int:\n        n = len(a)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n        max_length = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if not is_divisible(x, prefix_sum[j] - prefix_sum[i]):\n                    max_length = max(max_length, j - i)\n\n        return max_length\n\n    testcases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(testcases):\n        n, x = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        result.append(longest_subarray(a, x))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 297,
        "indeed": false
    },
    {
        "number": 2590,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_wealthy(person, x):\n        return person >= x\n\n    def redistribute(people, index):\n        total_savings = sum(people)\n        num_people = len(people)\n        equal_share = total_savings / num_people\n        for i in range(num_people):\n            if i in index:\n                people[i] = equal_share\n        return people\n\n    def count_wealthy(people, x):\n        return sum(map(lambda person: is_wealthy(person, x), people))\n\n    def find_max_wealthy(n, x, savings):\n        max_wealthy = count_wealthy(savings, x)\n        for i in range(n):\n            for j in range(i, n):\n                index = [i, j]\n                new_savings = redistribute(savings, index)\n                max_wealthy = max(max_wealthy, count_wealthy(new_savings, x))\n        return max_wealthy\n\n    T = int(stdin.readline().strip())\n    result = []\n    for _ in range(T):\n        n, x = map(int, stdin.readline().strip().split())\n        savings = list(map(int, stdin.readline().strip().split()))\n        result.append(find_max_wealthy(n, x, savings))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 355,
        "indeed": false
    },
    {
        "number": 2591,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sort_by_absolute_difference(arr: List[int]) -> List[int]:\n        arr.sort(key=lambda x: (abs(x), -x))\n        return arr\n\n    def rearrange_array(arr: List[int]) -> List[int]:\n        sorted_arr = sort_by_absolute_difference(arr)\n        rearranged_arr = []\n        for i in range(len(sorted_arr) - 1, -1, -1):\n            rearranged_arr.append(sorted_arr[i])\n            if i > 0 and abs(sorted_arr[i] - sorted_arr[i - 1]) > abs(sorted_arr[i - 1] - sorted_arr[i - 2]):\n                rearranged_arr.append(sorted_arr[i - 1])\n        return rearranged_arr\n\n    def main(stdin: str) -> str:\n        lines = stdin.strip().split('\\n')\n        t = int(lines[0])\n        output = []\n        for i in range(1, t + 1):\n            n = int(lines[2 * i - 1])\n            arr = list(map(int, lines[2 * i].split()))\n            rearranged_arr = rearrange_array(arr)\n            output.append(' '.join(map(str, rearranged_arr)))\n        return '\\n'.join(output)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 351,
        "indeed": false
    },
    {
        "number": 2592,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_feed(a, b, c, visitors):\n        dumplings = sum(1 for i in range(len(visitors)) if visitors[i] == \"dumplings\")\n        cranberry_juice = sum(1 for i in range(len(visitors)) if visitors[i] == \"cranberry_juice\")\n        pancakes = sum(1 for i in range(len(visitors)) if visitors[i] == \"pancakes\")\n        return dumplings <= a and cranberry_juice <= b and pancakes <= c\n\n    def generate_visitors(a, b, c):\n        visitors = []\n        if a > 0:\n            visitors.append(\"dumplings\")\n        if b > 0:\n            visitors.append(\"cranberry_juice\")\n        if c > 0:\n            visitors.append(\"pancakes\")\n        return visitors\n\n    def feed_visitors(a, b, c):\n        visitors = generate_visitors(a, b, c)\n        max_visitors = 0\n        for i in range(1, len(visitors) + 1):\n            for subset in itertools.combinations(visitors, i):\n                if can_feed(a, b, c, list(subset)):\n                    max_visitors = max(max_visitors, len(subset))\n        return max_visitors\n\n    lines = stdin.split(\"\\n\")\n    t = int(lines[0])\n    result = []\n    for i in range(1, t + 1):\n        a, b, c = map(int, lines[i].split())\n        result.append(feed_visitors(a, b, c))\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 427,
        "indeed": false
    },
    {
        "number": 2593,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_pairs(n: int, a: List[int]) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] & a[j] >= a[i] ^ a[j]:\n                    count += 1\n        return count\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        result.append(count_pairs(n, a))\n\n    return \"\\n\".join(map(str, result))\n",
        "test": "",
        "num_ids": 183,
        "indeed": false
    },
    {
        "number": 2594,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def light_squares(n, m):\n        if n == 1 and m == 1:\n            return 1\n        if n == 1 or m == 1:\n            return n + m - 1\n        return (n * m) - (n + m - 1)\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(t):\n        n, m = map(int, stdin.split('\\n')[i + 1].split())\n        result.append(light_squares(n, m))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 2595,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def min_operations(a, b):\n        if a == b:\n            return 0\n        if a > b:\n            a, b = b, a\n        if b % a != 0:\n            return -1\n        count = 0\n        while a != b:\n            if b % (a * 2) == 0:\n                b //= a * 2\n                count += 1\n            elif b % (a * 4) == 0:\n                b //= a * 4\n                count += 2\n            elif b % (a * 8) == 0:\n                b //= a * 8\n                count += 3\n            else:\n                return -1\n        return count\n\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        result = min_operations(a, b)\n        output.append(str(result))\n    return \"\\n\".join(output) ",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 2596,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, t = map(int, stdin.split())\n    l = n\n    result = []\n\n    for _ in range(t):\n        decision, position = map(int, input().split())\n\n        if decision == 1:\n            if position == 1:\n                l += 1\n                k += 1\n            else:\n                l += 1\n        else:\n            if position == l - 1:\n                l -= 1\n                if k > position:\n                    k -= 1\n            else:\n                l -= 1\n\n        result.append(f\"{l} {k}\")\n\n    return \"\\n\".join(result)\n",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2597,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_square(planks: List[int]) -> int:\n        planks.sort(reverse=True)\n        max_side = 0\n        for i in range(len(planks)):\n            if planks[i] <= max_side:\n                break\n            for j in range(i + 1, len(planks)):\n                if planks[i] + planks[j] <= max_side:\n                    break\n                square_side = planks[i] + planks[j]\n                max_side = max(max_side, square_side)\n        return max_side\n\n    def process_test_case(n: int, planks: List[int]) -> int:\n        return find_max_square(planks)\n\n    test_cases = int(stdin.readline().strip())\n    output = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        planks = list(map(int, stdin.readline().strip().split()))\n        output.append(process_test_case(n, planks))\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 281,
        "indeed": false
    },
    {
        "number": 2598,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start):\n        queue = [(start, 0)]\n        visited = [False] * n\n        visited[start] = True\n        while queue:\n            vertex, depth = queue.pop(0)\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, depth + 1))\n                    visited[neighbor] = True\n        return depth\n\n    def dfs(vertex, color):\n        colors[vertex] = color\n        for neighbor in graph[vertex]:\n            if colors[neighbor] == -1:\n                dfs(neighbor, 1 - color)\n\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    colors = [-1] * n\n    for _ in range(m):\n        u, v, c = stdin.readline().split()\n        u, v = int(u) - 1, int(v) - 1\n        graph[u].append(v)\n        graph[v].append(u)\n        if c == 'R':\n            colors[u] = 0\n            colors[v] = 0\n\n    for i in range(n):\n        if colors[i] == -1:\n            dfs(i, 0)\n\n    color_count = [0, 0]\n    for color in colors:\n        color_count[color] += 1\n\n    if color_count[0] == 0 or color_count[1] == 0:\n        return \"-1\\n\"\n\n    max_depth = 0\n    for i in range(n):\n        if colors[i] == 0:\n            depth = bfs(i)\n            max_depth = max(max_depth, depth)\n\n    k = max_depth\n    output = [str(i + 1) for i in range(n) if colors[i] == 0]\n    return f\"{k}\\n{' '.join(output)}\\n\"",
        "test": "",
        "num_ids": 494,
        "indeed": false
    },
    {
        "number": 2599,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def find_min_x(n: int, k: int) -> int:\n        for x in range(10 ** 9):\n            if sum_of_digits(x) + sum_of_digits(x + 1) + ... + sum_of_digits(x + k) == n:\n                return x\n        return -1\n\n    result = []\n    for _ in range(int(stdin.split()[0])):\n        n, k = map(int, stdin.split())\n        result.append(find_min_x(n, k))\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 2600,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindromic(matrix, i, j):\n        for k in range((n + 1) // 2):\n            if matrix[i][j - k] != matrix[i][j + k]:\n                return False\n            if matrix[i + k][j] != matrix[i - k][j]:\n                return False\n        return True\n\n    def change_cells(matrix):\n        changed_cells = 0\n        for i in range(n):\n            for j in range(m):\n                if not is_palindromic(matrix, i, j):\n                    matrix[i][j] ^= 1\n                    changed_cells += 1\n        return changed_cells\n\n    lines = stdin.split('\\n')\n    t = int(lines[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n, m = map(int, lines[i].split())\n        matrix = [[int(x) for x in lines[i + j].split()] for j in range(1, n + 1)]\n        result.append(change_cells(matrix))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 289,
        "indeed": false
    },
    {
        "number": 2601,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_sort(a: List[int]) -> bool:\n        n = len(a)\n        exchanges = 0\n        for i in range(1, n):\n            if a[i - 1] > a[i]:\n                exchanges += 1\n                if exchanges > (n * (n - 1)) // 2 - 1:\n                    return False\n        return True\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        if can_sort(a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 2602,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_angry(a, b, n, m, order):\n        vanilla = a\n        chocolate = b\n        for guest in order:\n            if guest == 1:\n                if vanilla > chocolate:\n                    vanilla -= 1\n                else:\n                    chocolate -= 1\n            else:\n                if vanilla > chocolate:\n                    chocolate -= 1\n                else:\n                    vanilla -= 1\n        return vanilla == 0 or chocolate == 0\n\n    def check_order(a, b, n, m):\n        if n == 0 or m == 0:\n            return \"No\"\n        if a == 0 and b == 0:\n            return \"No\"\n        if n == 1 and m == 1:\n            return \"Yes\"\n        if n == 1:\n            return \"Yes\" if a > 0 else \"No\"\n        if m == 1:\n            return \"Yes\" if b > 0 else \"No\"\n        if a == 0:\n            return \"Yes\" if n <= m else \"No\"\n        if b == 0:\n            return \"Yes\" if m <= n else \"No\"\n        for order in permutations([1] * n + [2] * m):\n            if not is_angry(a, b, n, m, order):\n                return \"Yes\"\n        return \"No\"\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        a, b, n, m = map(int, stdin.readline().split())\n        result.append(check_order(a, b, n, m))\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 418,
        "indeed": false
    },
    {
        "number": 2603,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def is_non_decreasing(a: List[int]) -> bool:\n        for i in range(len(a) - 1):\n            if a[i] > a[i + 1]:\n                return False\n        return True\n\n    def can_make_non_decreasing(a: List[int]) -> bool:\n        min_element = min(a)\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if gcd(a[i], a[j]) == min_element:\n                    a[i], a[j] = a[j], a[i]\n                    if is_non_decreasing(a):\n                        return True\n                    a[i], a[j] = a[j], a[i]\n        return False\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if can_make_non_decreasing(a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 341,
        "indeed": false
    },
    {
        "number": 2604,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, d = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    sausage_count = 0\n\n    for i in range(n):\n        x, y, r_i = map(int, stdin.readline().split())\n        distance = (x ** 2 + y ** 2) ** 0.5\n        if distance <= r - d and distance + r_i >= r - d:\n            sausage_count += 1\n\n    return str(sausage_count)",
        "test": "",
        "num_ids": 132,
        "indeed": false
    },
    {
        "number": 2605,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    capital_cities = list(map(int, stdin.readline().split()))\n\n    total_price = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if j == n + 1:\n                j = 1\n            if i + 1 in capital_cities or j in capital_cities:\n                total_price += c[i] * c[j - 1]\n\n    return str(total_price)",
        "test": "",
        "num_ids": 157,
        "indeed": false
    },
    {
        "number": 2606,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_unpleasant_value(n: int, t: List[int]) -> int:\n        t.sort()\n        total_unpleasant_value = 0\n        for i in range(n):\n            total_unpleasant_value += abs(t[i] - (i + 1))\n        return total_unpleasant_value\n\n    def find_min_unpleasant_value_helper(n: int, t: List[int], start: int, end: int) -> int:\n        if start > end:\n            return float('inf')\n        if start == end:\n            return find_min_unpleasant_value(n, t)\n\n        min_unpleasant_value = float('inf')\n        for i in range(start, end + 1):\n            t.sort(key=lambda x: abs(x - i))\n            min_unpleasant_value = min(min_unpleasant_value, find_min_unpleasant_value(n, t))\n\n        return min_unpleasant_value\n\n    q = int(stdin.readline().strip())\n    result = []\n    for _ in range(q):\n        n = int(stdin.readline().strip())\n        t = list(map(int, stdin.readline().strip().split()))\n        result.append(find_min_unpleasant_value_helper(n, t, 1, n))\n\n    return '\\n'.join(map(str, result)) + '\\n' ",
        "test": "",
        "num_ids": 363,
        "indeed": false
    },
    {
        "number": 2607,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n', 1)[0])\n    s = stdin.split('\\n', 1)[1]\n    result = []\n\n    for i in range(t):\n        s = s.split('\\n', 1)[0]\n        s = s.split('\\n', 1)[0]\n        if '?' not in s:\n            result.append(\"-1\")\n            continue\n\n        index = s.index('?')\n        for c in ['a', 'b', 'c']:\n            if index == 0 or s[index - 1] != c:\n                new_s = s[:index] + c + s[index + 1:]\n                if '?' not in new_s:\n                    result.append(new_s)\n                    break\n\n        else:\n            result.append(\"-1\")\n\n        s = s.split('\\n', 1)[1]\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 232,
        "indeed": false
    },
    {
        "number": 2608,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_cells(n: int, m: int, x1: int, y1: int, x2: int, y2: int, color: str) -> int:\n        return (x2 - x1 + 1) * (y2 - y1 + 1) * (1 if color == \"white\" else -1)\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        n, m = map(int, stdin.readline().strip().split())\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        x3, y3, x4, y4 = map(int, stdin.readline().strip().split())\n\n        white_cells = count_cells(n, m, x1, y1, x2, y2, \"white\") + count_cells(n, m, x3, y3, x4, y4, \"white\")\n        black_cells = count_cells(n, m, x1, y1, x2, y2, \"black\") + count_cells(n, m, x3, y3, x4, y4, \"black\")\n\n        result.append(f\"{white_cells} {black_cells}\")\n\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 332,
        "indeed": false
    },
    {
        "number": 2609,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_union(segments: list[tuple[int, int]]) -> int:\n        segments.sort(key=lambda x: x[0])\n        union = [segments[0]]\n        for segment in segments[1:]:\n            last_segment = union[-1]\n            if segment[0] > last_segment[1]:\n                union.append(segment)\n            else:\n                union[-1] = (last_segment[0], max(last_segment[1], segment[1]))\n        return len(union)\n\n    def find_max_union(segments: list[tuple[int, int]]) -> int:\n        max_union = find_union(segments)\n        for i in range(len(segments)):\n            max_union = max(max_union, find_union(segments[:i] + segments[i + 1:]))\n        return max_union\n\n    t = int(stdin.readline())\n    results = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        segments = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n        results.append(find_max_union(segments))\n    return \"\\n\".join(map(str, results))",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 2610,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_buy_k_goods(n: int, p: int, k: int, a: List[int]) -> int:\n        dp = [0] * (p + 1)\n        for i in range(n):\n            for j in range(p, -1, -1):\n                if j >= a[i]:\n                    dp[j] = max(dp[j], dp[j - a[i]] + 1)\n        for i in range(p, -1, -1):\n            if dp[i] >= k:\n                return i\n        return 0\n\n    t = int(stdin.split('\\n', 1)[0])\n    it = 1\n    result = []\n    for _ in range(t):\n        n, p, k = map(int, stdin.split())\n        a = list(map(int, stdin.split()))\n        result.append(can_buy_k_goods(n, p, k, a))\n        it += 1\n        if it <= t:\n            stdin = stdin.rsplit('\\n', 1)[1]\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 2611,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_moves(piles):\n        piles = sorted(set(piles))\n        moves = 0\n        for i in range(1, len(piles)):\n            moves += abs(piles[i] - piles[i - 1]) - 1\n        return moves\n\n    def apply_query(piles, query):\n        t, x = query\n        if t == 0:\n            piles.remove(x)\n        else:\n            piles.append(x)\n\n    n, q, piles, *queries = list(map(int, stdin.split()))\n    piles = sorted(set(piles))\n    result = [min_moves(piles)]\n\n    for query in queries:\n        apply_query(piles, query)\n        result.append(min_moves(piles))\n\n    return \" \".join(map(str, result))",
        "test": "",
        "num_ids": 218,
        "indeed": false
    },
    {
        "number": 2612,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(sizes: List[int]) -> bool:\n        for i in range(len(sizes) - 1):\n            if sizes[i + 1] % sizes[i] != 0 or sizes[i] >= sizes[i + 1]:\n                return False\n        return True\n\n    def max_beautiful_models(n: int, sizes: List[int]) -> int:\n        if n == 1:\n            return 1\n\n        sizes.sort()\n        max_count = 0\n\n        for i in range(1, n):\n            if sizes[i] % sizes[i - 1] == 0:\n                sub_sizes = sizes[:i] + sizes[i + 1:]\n                max_count = max(max_count, 1 + max_beautiful_models(i, sub_sizes))\n\n        return max_count\n\n    queries = stdin.strip().split('\\n')[1:]\n    result = []\n\n    for i in range(0, len(queries), 2):\n        n = int(queries[i])\n        sizes = list(map(int, queries[i + 1].split()))\n        result.append(max_beautiful_models(n, sizes))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 317,
        "indeed": false
    },
    {
        "number": 2613,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_score(a, k, z):\n        n = len(a)\n        dp = [[0] * (k + 1) for _ in range(n)]\n\n        for i in range(1, n):\n            for j in range(1, k + 1):\n                if i == 1:\n                    dp[i][j] = a[i]\n                elif j == 1:\n                    dp[i][j] = dp[i - 1][j] + a[i]\n                else:\n                    dp[i][j] = max(dp[i - 1][j - 1] + a[i], dp[i - 1][j])\n\n        return dp[n - 1][k]\n\n    t = int(stdin.split('\\n', 1)[0])\n    result = []\n\n    for _ in range(t):\n        n, k, z = map(int, stdin.split('\\n', 1)[0].split())\n        a = list(map(int, stdin.split('\\n', 1)[1].split()))\n        result.append(max_score(a, k, z))\n        stdin = stdin.split('\\n', 1)[1]\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 317,
        "indeed": false
    },
    {
        "number": 2614,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_distance(fillings: List[int]) -> int:\n        fillings.sort()\n        min_distance = float('inf')\n        for i in range(len(fillings) - 1):\n            if fillings[i] == fillings[i + 1]:\n                min_distance = min(min_distance, i + 2)\n        return min_distance\n\n    def process_bag(n: int, fillings: List[int]) -> int:\n        return find_min_distance(fillings)\n\n    lines = stdin.split('\\n')\n    T = int(lines[0])\n    bags = []\n    for i in range(1, len(lines), 2):\n        n = int(lines[i])\n        fillings = list(map(int, lines[i + 1].split()))\n        bags.append((n, fillings))\n\n    result = []\n    for bag in bags:\n        result.append(process_bag(*bag))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 254,
        "indeed": false
    },
    {
        "number": 2615,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_elegant(x: int) -> bool:\n        k = []\n        i = 2\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                x //= i\n                k.append(i)\n        if x > 1:\n            k.append(x)\n        return math.gcd(*k) == 1\n\n    def count_elegant(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            if is_elegant(i):\n                count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    T = int(lines[0])\n    result = []\n    for i in range(1, T + 1):\n        n = int(lines[i])\n        result.append(count_elegant(n))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 235,
        "indeed": false
    },
    {
        "number": 2616,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def play_game(piles):\n        piles = [int(x) for x in piles.split()]\n        n = len(piles)\n        while any(p > 0 for p in piles):\n            for i in range(n):\n                if piles[i] > 0:\n                    stones = piles[i]\n                    piles[i] = 0\n                    break\n            for j in range(i + 1, n):\n                if piles[j] > 0:\n                    stones = min(stones, piles[j])\n                    piles[j] -= stones\n                    break\n        if all(p == 0 for p in piles):\n            return \"First\"\n        else:\n            return \"Second\"\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        piles = stdin.readline()\n        result.append(play_game(piles))\n    return \"\\n\".join(result)",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 2617,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_nights(n: int) -> tuple:\n        if n == 1:\n            return (1, [0])\n        elif n == 2:\n            return (2, [1, 0])\n        else:\n            min_nights = float('inf')\n            min_split = None\n            for i in range(1, n):\n                if n % i == 0:\n                    nights, split = find_min_nights(i)\n                    nights2, split2 = find_min_nights(n // i)\n                    if nights + nights2 < min_nights:\n                        min_nights = nights + nights2\n                        min_split = split + [n // i - sum(split)] + split2\n            return (min_nights, min_split)\n\n    def process_input(stdin: str) -> list:\n        lines = stdin.split('\\n')\n        t = int(lines[0])\n        return [int(line) for line in lines[1:-1]]\n\n    def main(stdin: str) -> str:\n        test_cases = process_input(stdin)\n        outputs = []\n        for n in test_cases:\n            nights, split = find_min_nights(n)\n            if nights == float('inf'):\n                outputs.append('-1')\n            else:\n                outputs.append(str(nights))\n                outputs.append(' '.join(map(str, split)))\n        return '\\n'.join(outputs)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 381,
        "indeed": false
    },
    {
        "number": 2618,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_contribution(order, prices, x, a, y, b):\n        contribution = 0\n        for i, price in enumerate(order):\n            if (i + 1) % a == 0:\n                contribution += price * x / 100\n            if (i + 1) % b == 0:\n                contribution += price * y / 100\n        return contribution\n\n    def binary_search(n, prices, x, a, y, b, k):\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            order = sorted(prices[:mid])\n            contribution = calculate_contribution(order, prices, x, a, y, b)\n            if contribution < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    queries = stdin.split(\"\\n\")\n    result = []\n    for i in range(0, len(queries), 5):\n        n = int(queries[i + 0])\n        prices = list(map(int, queries[i + 1].split()))\n        x, a = map(int, queries[i + 2].split())\n        y, b = map(int, queries[i + 3].split())\n        k = int(queries[i + 4])\n\n        min_tickets = binary_search(n, prices, x, a, y, b, k)\n        result.append(min_tickets if min_tickets <= n else -1)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 388,
        "indeed": false
    },
    {
        "number": 2619,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_rectangle(x, y, x1, y1, x2, y2):\n        return x1 <= x <= x2 and y1 <= y <= y2\n\n    def total_brightness(stars, x1, y1, x2, y2):\n        total_brightness_in_rectangle = 0\n        for x, y, brightness in stars:\n            if is_inside_rectangle(x, y, x1, y1, x2, y2):\n                total_brightness_in_rectangle += brightness\n        return total_brightness_in_rectangle\n\n    n, q, c = map(int, stdin.readline().split())\n    stars = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.readline().split())\n        stars.append((x, y, s))\n\n    result = []\n    for _ in range(q):\n        t, x1, y1, x2, y2 = map(int, stdin.readline().split())\n        for _ in range(t):\n            for i in range(n):\n                x, y, s = stars[i]\n                if s < c:\n                    stars[i] = (x, y, s + 1)\n        result.append(total_brightness(stars, x1, y1, x2, y2))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 358,
        "indeed": false
    },
    {
        "number": 2620,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def next_permutation(a: List[int]) -> List[int]:\n        n = len(a)\n        i = n - 2\n        while i >= 0 and a[i] >= a[i + 1]:\n            i -= 1\n        if i < 0:\n            return None\n        j = n - 1\n        while a[j] <= a[i]:\n            j -= 1\n        a[i], a[j] = a[j], a[i]\n        a[i + 1:] = reversed(a[i + 1:])\n        return a\n\n    def sum_segment(a: List[int], l: int, r: int) -> int:\n        return sum(a[l:r + 1])\n\n    n, q = map(int, stdin.readline().split())\n    a = list(range(1, n + 1))\n    result = []\n\n    for _ in range(q):\n        query = list(map(int, stdin.readline().split()))\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2] - 1\n            result.append(sum_segment(a, l, r))\n        elif query[0] == 2:\n            x = query[1]\n            for _ in range(x):\n                a = next_permutation(a)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 354,
        "indeed": false
    },
    {
        "number": 2621,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_win(n, m, k, h):\n        for i in range(n - 1):\n            if abs(h[i] - h[i + 1]) > k:\n                if i == 0 or abs(h[i - 1] - h[i + 1]) > k:\n                    return False\n        return True\n\n    test_cases = int(stdin.split('\\n')[0])\n    start = 1\n    result = []\n\n    for _ in range(test_cases):\n        n, m, k = map(int, stdin.split('\\n')[start].split())\n        h = list(map(int, stdin.split('\\n')[start + 1].split()))\n        if can_win(n, m, k, h):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n        start += 2\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 2622,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    map1 = [stdin.readline().strip() for _ in range(n)]\n    map2 = [stdin.readline().strip() for _ in range(m)]\n\n    for i in range(n - m + 1):\n        for j in range(m):\n            if map1[i + j][i:i + m] == map2[j]:\n                return f\"{i + 1} {j + 1}\"\n\n    return \"\"",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 2623,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lexicographically_minimal(s: str) -> str:\n        s = sorted(s)\n        return ''.join(s)\n\n    def distribute_letters(s: str, k: int) -> List[str]:\n        n = len(s)\n        letters = sorted(set(s))\n        strings = [''] * k\n\n        for letter in letters:\n            count = s.count(letter)\n            for i in range(k):\n                if count > 0:\n                    strings[i] += letter\n                    count -= 1\n\n        return strings\n\n    def find_min_max(strings: List[str]) -> str:\n        max_string = max(strings, key=len)\n        return lexicographically_minimal(max_string)\n\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n        strings = distribute_letters(s, k)\n        min_max = find_min_max(strings)\n        result.append(min_max)\n\n    return '\\n'.join(result) ",
        "test": "",
        "num_ids": 301,
        "indeed": false
    },
    {
        "number": 2624,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = a.copy()\n\n    for _ in range(q):\n        s, x = stdin.readline().split()\n        x = int(x)\n\n        for i in range(n):\n            if (s == \">\" and a[i] > x) or (s == \"<\" and a[i] < x):\n                b[i] = -a[i]\n            else:\n                b[i] = a[i]\n\n        a = b.copy()\n\n    return \" \".join(map(str, a))",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 2625,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def digital_root(n: int) -> int:\n        return n if n < 10 else digital_root(sum(map(int, str(n))))\n\n    def find_kth_number(k: int, x: int) -> int:\n        i = 1\n        while k > 0:\n            if digital_root(i) == x:\n                k -= 1\n            i += 1\n        return i - 1\n\n    n = int(stdin.split('\\n')[0])\n    tasks = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    result = []\n    for k, x in tasks:\n        result.append(find_kth_number(k, x))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 198,
        "indeed": true
    },
    {
        "number": 2626,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (4 * n - 2 + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 1\n\n        for i in range(3, 4 * n - 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n        return dp[4 * n - 2]\n\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i])\n        result.append(count_ways(n))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 216,
        "indeed": false
    },
    {
        "number": 2627,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, line.strip().split(','))) for line in stdin.strip().split('\\n')]\n    n = len(matrix)\n    m = len(matrix[0])\n    heights = [0] * (m + 1)\n    max_area = 0\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        stack = [-1]\n        for j in range(m + 1):\n            while heights[j] < heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = j - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(j)\n\n    return max_area",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2628,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = [0]\n    if n == 0:\n        return str(result)\n    for i in range(n):\n        for j in range(len(result) - 1, -1, -1):\n            result.append(result[j] | (1 << i))\n    return str(result)",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 2629,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    matrix = [[0] * n for _ in range(n)]\n    row_start, row_end, col_start, col_end = 0, n - 1, 0, n - 1\n    num = 1\n\n    while row_start <= row_end and col_start <= col_end:\n        for i in range(col_start, col_end + 1):\n            matrix[row_start][i] = num\n            num += 1\n        row_start += 1\n\n        for i in range(row_start, row_end + 1):\n            matrix[i][col_end] = num\n            num += 1\n        col_end -= 1\n\n        for i in range(col_end, col_start - 1, -1):\n            matrix[row_end][i] = num\n            num += 1\n        row_end -= 1\n\n        for i in range(row_end, row_start - 1, -1):\n            matrix[i][col_start] = num\n            num += 1\n        col_start += 1\n\n    result = []\n    for i in range(n):\n        result.append(matrix[i][:])\n\n    return str(result).replace(\"],\", \"],\\n\")",
        "test": "",
        "num_ids": 316,
        "indeed": false
    },
    {
        "number": 2630,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = [list(map(int, line.strip().split())) for line in stdin.split('\\n')]\n    m = len(input_list)\n    n = len(input_list[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if input_list[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m - 1][n - 1]",
        "test": "",
        "num_ids": 249,
        "indeed": false
    },
    {
        "number": 2631,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, prerequisites = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    visited = [0] * n\n    stack = []\n\n    for i in range(len(prerequisites)):\n        x, y = prerequisites[i]\n        graph[x].append(y)\n\n    def dfs(v):\n        visited[v] = 1\n        for i in graph[v]:\n            if visited[i] == 0:\n                if dfs(i) == -1:\n                    return -1\n            elif visited[i] == 1:\n                return -1\n        visited[v] = 2\n        stack.append(v)\n        return 1\n\n    for i in range(n):\n        if visited[i] == 0:\n            if dfs(i) == -1:\n                return \"false\"\n\n    result = []\n    while stack:\n        result.append(str(stack.pop()))\n\n    return \"true\" if result == [str(i) for i in range(n)] else \"false\"",
        "test": "",
        "num_ids": 266,
        "indeed": false
    },
    {
        "number": 2632,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_path_sum(grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]\n\n    grid = [[int(x) for x in line.split()] for line in stdin.split('\\n')[:-1]]\n    return str(min_path_sum(grid))",
        "test": "",
        "num_ids": 262,
        "indeed": false
    },
    {
        "number": 2633,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    dungeon = [list(map(int, row.split())) for row in stdin.split('\\n')]\n    m, n = len(dungeon), len(dungeon[0])\n    min_health = float('inf')\n\n    def dfs(i: int, j: int, health: int) -> None:\n        nonlocal min_health\n        if health < min_health:\n            min_health = health\n\n        if i == m - 1 and j == n - 1:\n            return\n\n        if i < m - 1:\n            dfs(i + 1, j, max(1, health - dungeon[i + 1][j]))\n        if j < n - 1:\n            dfs(i, j + 1, max(1, health - dungeon[i][j + 1]))\n\n    dfs(0, 0, float('inf'))\n    return str(min_health)",
        "test": "",
        "num_ids": 233,
        "indeed": false
    },
    {
        "number": 2634,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    result = []\n    for i in range(2**len(nums)):\n        subset = []\n        for j in range(len(nums)):\n            if i & (1<<j):\n                subset.append(nums[j])\n        if subset not in result:\n            result.append(subset)\n    return str(result)",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 2635,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = []\n    for line in stdin.split('\\n'):\n        input_matrix.append(list(map(int, line.split())))\n\n    m = len(input_matrix)\n    n = len(input_matrix[0])\n\n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n\n    result = []\n\n    while (top <= bottom and left <= right):\n        for i in range(left, right + 1):\n            result.append(input_matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(input_matrix[i][right])\n        right -= 1\n\n        if (top <= bottom):\n            for i in range(right, left - 1, -1):\n                result.append(input_matrix[bottom][i])\n            bottom -= 1\n\n        if (left <= right):\n            for i in range(bottom, top - 1, -1):\n                result.append(input_matrix[i][left])\n            left += 1\n\n    return result",
        "test": "",
        "num_ids": 276,
        "indeed": false
    },
    {
        "number": 2636,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    buildings = []\n    for line in stdin.split('\\n'):\n        if line.strip():\n            li, ri, hi = map(int, line.split())\n            buildings.append([li, ri, hi])\n\n    def update_height(active_set, x, new_height):\n        if active_set and active_set[-1][1] == x:\n            height, _ = active_set.pop()\n            new_height = max(new_height, height)\n        active_set.append([new_height, x])\n\n    def merge_heights(active_set):\n        merged_heights = []\n        prev_height, prev_x = None, None\n        for height, x in active_set:\n            if height != prev_height:\n                if prev_height is not None:\n                    merged_heights.append([prev_height, prev_x, x])\n                prev_height, prev_x = height, x\n        if prev_height is not None:\n            merged_heights.append([prev_height, prev_x, 'inf'])\n        return merged_heights\n\n    active_set = []\n    skyline = []\n    for li, ri, hi in buildings:\n        update_height(active_set, li, hi)\n        update_height(active_set, ri, 0)\n        skyline.extend(merge_heights(active_set))\n        active_set = [h for h in active_set if h[1] > ri]\n\n    return skyline",
        "test": "",
        "num_ids": 361,
        "indeed": false
    },
    {
        "number": 2637,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    result = []\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    backtrack(0)\n    return str(result)",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 2638,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    triangle = [list(map(int, row.split())) for row in stdin.strip().split('\\n')]\n    n = len(triangle)\n    dp = triangle[-1]\n\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n\n    return str(dp[0])",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 2639,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    result = []\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i+1, path+[nums[i]])\n    backtrack(0, [])\n    return str(result)",
        "test": "",
        "num_ids": 110,
        "indeed": false
    },
    {
        "number": 2640,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_lights(grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        visited = set()\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        def dfs(x, y):\n            if (x, y) in visited or grid[x][y] == \"#\":\n                return 0\n            visited.add((x, y))\n            return 1 + sum(dfs(x + dx, y + dy) for dx, dy in directions if 0 <= x + dx < rows and 0 <= y + dy < cols)\n\n        return dfs(i, j)\n\n    H, W = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(H)]\n\n    max_lights = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \".\":\n                max_lights = max(max_lights, count_lights(grid, i, j))\n\n    return str(max_lights)",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 2641,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_colors(balls: list, l: int, r: int) -> int:\n        return len(set(balls[l - 1:r]))\n\n    N, Q = map(int, stdin.split()[:2])\n    balls = list(map(int, stdin.split()[2:N + 2]))\n    queries = [list(map(int, stdin.split()[N + 2 + 2 * i:N + 2 + 2 * i + 2])) for i in range(Q)]\n\n    return \"\\n\".join(str(count_colors(balls, l, r)) for l, r in queries)",
        "test": "",
        "num_ids": 159,
        "indeed": true
    },
    {
        "number": 2642,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    N, A, B = [], [], []\n    for line in stdin.split('\\n'):\n        if line.isnumeric():\n            N = int(line)\n        else:\n            A.append(int(line.split()[0]))\n            B.append(int(line.split()[1]))\n\n    mod = 1000000007\n    count = 1\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] * A[j] + B[i] * B[j] != 0:\n                count = (count * 2) % mod\n            else:\n                count = (count * lcm(A[i], A[j])) % mod\n\n    return str(count)",
        "test": "",
        "num_ids": 245,
        "indeed": false
    },
    {
        "number": 2643,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_sequence(n, x, d, k, m):\n        sequence = [x]\n        for j in range(1, n):\n            sequence.append(sequence[-1] + d[j - 1])\n        return [num % m for num in sequence]\n\n    def count_inversions(sequence):\n        inversions = 0\n        for i in range(len(sequence) - 1):\n            for j in range(i + 1, len(sequence)):\n                if sequence[i] > sequence[j]:\n                    inversions += 1\n        return inversions\n\n    lines = stdin.split('\\n')\n    k, q = map(int, lines[0].split())\n    d = list(map(int, lines[1].split()))\n\n    result = []\n    for i in range(2, 2 + q):\n        n, x, m = map(int, lines[i].split())\n        sequence = generate_sequence(n, x, d, k, m)\n        result.append(count_inversions(sequence))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 2644,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    P = list(map(int, P.split()))\n\n    def is_sorted(P):\n        for i in range(1, len(P)):\n            if P[i] < P[i - 1]:\n                return False\n        return True\n\n    def find_swap_index(P):\n        for i in range(len(P) - 1):\n            if P[i] != i + 1:\n                return i\n        return -1\n\n    if is_sorted(P):\n        return -1\n\n    operations = []\n    for i in range(N - 1):\n        swap_index = find_swap_index(P)\n        if swap_index == -1:\n            return -1\n        P[swap_index], P[swap_index + 1] = P[swap_index + 1], P[swap_index]\n        operations.append(swap_index + 1)\n\n    return \"\\n\".join(map(str, operations))",
        "test": "",
        "num_ids": 248,
        "indeed": false
    },
    {
        "number": 2645,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    N = len(s)\n    atcoder_score = 0\n    topcoder_score = 0\n\n    for i in range(N):\n        if s[i] == 'g':\n            if atcoder_score <= topcoder_score:\n                atcoder_score += 1\n            else:\n                topcoder_score += 1\n        else:\n            if atcoder_score <= topcoder_score:\n                topcoder_score += 1\n            else:\n                atcoder_score += 1\n\n    return str(atcoder_score - topcoder_score)",
        "test": "",
        "num_ids": 159,
        "indeed": false
    },
    {
        "number": 2646,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, visited, graph):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for neighbor in graph[start]:\n            if find_path(neighbor, end, visited, graph):\n                return True\n        return False\n\n    def bfs(start, graph):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, depth = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    queue.append((neighbor, depth + 1))\n        return visited\n\n    def is_valid(signpost, graph):\n        visited = set()\n        for room in signpost:\n            if room not in visited:\n                visited |= bfs(room, graph)\n        return len(visited) == len(graph) + 1\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    A = [0] * (N + 1)\n    B = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n\n    for i in range(1, M + 1):\n        a, b = map(int, lines[i].split())\n        A[a] += 1\n        B[b] += 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, N + 1):\n        if A[i] != 1 or B[i] != 1:\n            return \"No\"\n\n    signpost = [0] * (N + 1)\n    for i in range(2, N + 1):\n        for j in range(1, N + 1):\n            if find_path(i, 1, set(), graph) and find_path(j, 1, set(), graph):\n                signpost[i] = j\n                break\n\n    if is_valid(signpost, graph):\n        return \"Yes\\n\" + '\\n'.join(map(str, signpost[2:]))\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 550,
        "indeed": false
    },
    {
        "number": 2647,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, H, W, visited, i, j):\n        if 0 <= i < H and 0 <= j < W and grid[i][j] == '.' and not visited[i][j]:\n            return True\n        return False\n\n    def dfs(grid, H, W, visited, i, j, score):\n        if i == H - 1 and j == W - 1:\n            return score\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if is_valid(grid, H, W, visited, ni, nj):\n                visited[ni][nj] = True\n                if grid[ni][nj] == '.':\n                    score += 1\n                if dfs(grid, H, W, visited, ni, nj, score):\n                    return True\n                visited[ni][nj] = False\n        return False\n\n    stdin = stdin.split('\\n')\n    H, W = map(int, stdin[0].split())\n    grid = [list(stdin[i]) for i in range(1, H + 1)]\n    visited = [[False] * W for _ in range(H)]\n    score = 0\n    if dfs(grid, H, W, visited, 0, 0, score):\n        return str(score)\n    else:\n        return '-1' ",
        "test": "",
        "num_ids": 358,
        "indeed": false
    },
    {
        "number": 2648,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *arr = list(map(int, stdin.split()))\n    arr.sort()\n    i = 0\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 2\n        else:\n            i += 1\n    return str(i + 1)",
        "test": "",
        "num_ids": 82,
        "indeed": false
    },
    {
        "number": 2649,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def max_manhattan_distance(points):\n        max_distance = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                distance = manhattan_distance(points[i][0], points[i][1], points[j][0], points[j][1])\n                if distance > max_distance:\n                    max_distance = distance\n        return max_distance\n\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    points = [(input_list[2 * i + 1], input_list[2 * i + 2]) for i in range(1, N + 1)]\n    result = max_manhattan_distance(points)\n    return str(result)",
        "test": "",
        "num_ids": 236,
        "indeed": false
    },
    {
        "number": 2650,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_evenness(infants, kindergartens):\n        evenness = float('inf')\n        for kindergarten in kindergartens:\n            if kindergarten:\n                evenness = min(evenness, max(infant.rating for infant in kindergarten))\n        return evenness\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    infants = [None] * (N + 1)\n    kindergartens = [[] for _ in range(2 * 10**5 + 1)]\n\n    for i in range(1, N + 1):\n        rating, kindergarten = map(int, lines[i].split())\n        infants[i] = Infant(rating, i, kindergarten)\n        kindergartens[kindergarten].append(infants[i])\n\n    result = []\n    for i in range(N + 1, N + Q + 1):\n        transfer = lines[i].split()\n        infant_num, kindergarten_num = map(int, transfer)\n        infant = infants[infant_num]\n        old_kindergarten = infants[infant_num].kindergarten\n        infants[infant_num].kindergarten = kindergarten_num\n        kindergartens[old_kindergarten].remove(infant)\n        kindergartens[kindergarten_num].append(infant)\n        result.append(find_evenness(infants, kindergartens))\n\n    return '\\n'.join(map(str, result))\n\nclass Infant:\n    def __init__(self, rating, num, kindergarten):\n        self.rating = rating\n        self.num = num\n        self.kindergarten = kindergarten",
        "test": "",
        "num_ids": 438,
        "indeed": true
    },
    {
        "number": 2651,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:2 + n]))\n    y = list(map(int, stdin.split()[2 + n:2 + n + m]))\n\n    MOD = 10**9 + 7\n    total_area = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(m):\n                for l in range(k + 1, m + 1):\n                    area = (x[j - 1] - x[i - 1]) * (y[l - 1] - y[k - 1])\n                    total_area += area\n                    total_area %= MOD\n\n    return str(total_area)",
        "test": "",
        "num_ids": 210,
        "indeed": false
    },
    {
        "number": 2652,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost(x1, y1, x2, y2):\n        return min(abs(x1 - x2), abs(y1 - y2))\n\n    N, towns = int(stdin.splitlines()[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            total_cost += min_cost(*towns[i], *towns[j])\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2653,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, Q = map(int, stdin.readline().split())\n    tree = [[] for _ in range(N + 1)]\n    for i in range(N - 1):\n        a, b = map(int, stdin.readline().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    \n    operations = []\n    for i in range(Q):\n        p, x = map(int, stdin.readline().split())\n        operations.append((p, x))\n    \n    # Initialize counters\n    counters = [0] * (N + 1)\n    \n    # Perform operations\n    for p, x in operations:\n        counters[p] += x\n        for child in tree[p]:\n            counters[child] += x\n    \n    # Print the values of the counters\n    return ' '.join(map(str, counters[1:]))",
        "test": "",
        "num_ids": 229,
        "indeed": false
    },
    {
        "number": 2654,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(a, b, c, d):\n        if a <= c <= b:\n            return c\n        if a <= d <= b:\n            return d\n        if c < a and d > b:\n            return (a + b) / 2\n        if c > b and d < a:\n            return (c + d) / 2\n        return None\n\n    def count_median_values(x_values):\n        median_values = set()\n        for i in range(len(x_values)):\n            for j in range(i + 1, len(x_values)):\n                median = find_median(x_values[i][0], x_values[i][1], x_values[j][0], x_values[j][1])\n                if median is not None:\n                    median_values.add(median)\n        return len(median_values)\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    x_values = [(input_data[i * 2 + 1], input_data[i * 2 + 2]) for i in range(1, n + 1)]\n    result = count_median_values(x_values)\n    return str(result)",
        "test": "",
        "num_ids": 309,
        "indeed": false
    },
    {
        "number": 2655,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = list(map(int, stdin.split()))\n    A.sort()\n    total_comfort = 0\n\n    for i in range(N - 1):\n        comfort = min(A[i], A[i + 1])\n        total_comfort += comfort\n\n    return str(total_comfort)\n",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 2656,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, s = map(str, stdin.split())\n    k = int(k)\n    n = len(s)\n    mod = 10**9 + 7\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for _ in range(k):\n        new_dp = [0] * (n + 1)\n        for i in range(n + 1):\n            for j in range(i + 1, n + 1):\n                new_dp[i] += dp[j]\n                new_dp[i] %= mod\n            new_dp[i] += 1\n            new_dp[i] %= mod\n        dp = new_dp\n\n    return dp[0]",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 2657,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    max_comb = 0\n    max_pair = (0, 0)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                comb = a[i] * (a[i] - 1) // 2\n                if comb > max_comb:\n                    max_comb = comb\n                    max_pair = (a[i], a[j])\n\n    return f\"{max_pair[0]} {max_pair[1]}\"",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2658,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *A = list(map(int, stdin.split()))\n    current_town = 1\n    for _ in range(K):\n        current_town = A[current_town - 1]\n    return str(current_town)",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 2659,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def snuke_number(n: int) -> bool:\n        s = sum(int(digit) for digit in str(n))\n        for m in range(n + 1, int(10**15)):\n            if n / s <= m / sum(int(digit) for digit in str(m)):\n                return False\n        return True\n\n    def find_snuke_numbers(k: int) -> List[int]:\n        snuke_numbers = []\n        i = 1\n        while len(snuke_numbers) < k:\n            if snuke_number(i):\n                snuke_numbers.append(i)\n            i += 1\n        return snuke_numbers\n\n    k = int(stdin.strip())\n    snuke_numbers = find_snuke_numbers(k)\n    return \"\\n\".join(str(number) for number in snuke_numbers)",
        "test": "",
        "num_ids": 222,
        "indeed": false
    },
    {
        "number": 2660,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(x):\n        return g(x) if g else 0\n\n    def g(x):\n        return f_x + abs(x - a) + b\n\n    def update(a, b):\n        nonlocal f_x, g, a_g, b_g\n        f_x = f(a)\n        g = lambda x: f_x + abs(x - a) + b\n        a_g, b_g = a, b\n\n    def evaluate():\n        x = a_g\n        f_x = f(x)\n        for i in range(a_g - 1, b_g + 1):\n            if f(i) < f_x:\n                x = i\n                f_x = f(i)\n        return x, f_x\n\n    queries = stdin.strip().split('\\n')[1:]\n    Q = int(queries[0])\n    f_x, a_g, b_g = 0, None, None\n    g = None\n\n    results = []\n    for i in range(Q):\n        query = queries[i + 1].split()\n        if query[0] == '1':\n            a, b = map(int, query[1:])\n            update(a, b)\n        elif query[0] == '2':\n            x, f_x = evaluate()\n            results.append(f\"{x} {f_x}\")\n\n    return '\\n'.join(results)",
        "test": "",
        "num_ids": 353,
        "indeed": false
    },
    {
        "number": 2661,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_and(nums):\n        result = nums[0]\n        for num in nums[1:]:\n            result &= num\n        return result\n\n    def bitwise_or(nums):\n        result = nums[0]\n        for num in nums[1:]:\n            result |= num\n        return result\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    S = [int(x) for x in lines[1].split()]\n    T = [int(x) for x in lines[2].split()]\n    U = [int(x) for x in lines[3].split()]\n    V = [int(x) for x in lines[4].split()]\n\n    a = [[0] * N for _ in range(N)]\n\n    for i in range(N):\n        if S[i] == 0:\n            row_and = bitwise_and([U[j] for j in range(N) if a[j][i] == 1])\n            if row_and != U[i]:\n                return -1\n        else:\n            row_or = bitwise_or([U[j] for j in range(N) if a[j][i] == 1])\n            if row_or != U[i]:\n                return -1\n\n        if T[i] == 0:\n            col_and = bitwise_and([V[j] for j in range(N) if a[i][j] == 1])\n            if col_and != V[i]:\n                return -1\n        else:\n            col_or = bitwise_or([V[j] for j in range(N) if a[i][j] == 1])\n            if col_or != V[i]:\n                return -1\n\n    for i in range(N):\n        for j in range(N):\n            if S[i] == 0 and T[j] == 0:\n                a[i][j] = 1\n            elif S[i] == 1 and T[j] == 1:\n                a[i][j] = 1\n\n    return '\\n'.join(' '.join(str(x) for x in row) for row in a)",
        "test": "",
        "num_ids": 540,
        "indeed": false
    },
    {
        "number": 2662,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n    arr.sort()\n    colors = 1\n    current_color = 0\n    for i in range(1, n):\n        if arr[i] > arr[current_color] and arr[i] > arr[current_color] + 1:\n            colors += 1\n            current_color = i\n    return str(colors)",
        "test": "",
        "num_ids": 119,
        "indeed": false
    },
    {
        "number": 2663,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    L = []\n    for i in range(N):\n        for j in range(i, N):\n            L.append(sum(A[i:j+1]))\n    L.sort(reverse=True)\n    return \" \".join(map(str, L[:K]))",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 2664,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        balls_1 = list(map(int, input().split()))\n        balls_2 = list(map(int, input().split()))\n        return balls_1, balls_2\n\n    def find_heavier_ball(balls_1: list, balls_2: list) -> int:\n        colors_1 = set(balls_1[1:])\n        colors_2 = set(balls_2[1:])\n\n        for color in colors_1:\n            if color not in colors_2:\n                return color\n\n        for color in colors_2:\n            if color not in colors_1:\n                return color\n\n        return -1\n\n    def main():\n        while True:\n            command = input()\n            if command == \"1\":\n                balls_1, balls_2 = read_input()\n                print(balls_1[0] - balls_2[0])\n            elif command == \"2\":\n                color = find_heavier_ball(*read_input())\n                print(color)\n                break\n\n    main()\n\n    return \"\"",
        "test": "",
        "num_ids": 265,
        "indeed": false
    },
    {
        "number": 2665,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_square(x1, y1, x2, y2, x3, y3):\n        a = (x2 - x1) ** 2 + (y2 - y1) ** 2\n        b = (x3 - x2) ** 2 + (y3 - y2) ** 2\n        c = (x3 - x1) ** 2 + (y3 - y1) ** 2\n        return a == b or a == c or b == c\n\n    def find_square(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_square(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]):\n                        return True\n        return False\n\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    if find_square(points):\n        return \"0\"\n    else:\n        return \"1\"",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 2666,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(prices, k):\n        if not prices or k == 0:\n            return 0\n\n        if k >= len(prices) // 2:\n            return sum(sorted(prices)[-2 * (len(prices) // 2) :]) - sum(sorted(prices)[: 2 * (len(prices) // 2)])\n\n        dp = [[0] * len(prices) for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n        return dp[k][len(prices) - 1]\n\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    prices = list(map(int, lines[1:]))\n\n    return str(max_profit(prices, K))",
        "test": "",
        "num_ids": 292,
        "indeed": false
    },
    {
        "number": 2667,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *C = list(map(int, stdin.split()))\n    C.sort()\n    total_stamps = sum(C)\n    current_stamps = 0\n\n    for i in range(N):\n        current_stamps += i + 1\n        if current_stamps > total_stamps:\n            return \"NO\"\n        if current_stamps == total_stamps:\n            return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 111,
        "indeed": false
    },
    {
        "number": 2668,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    jacketCost, sockCost, money = map(int, stdin.split())\n    money -= jacketCost\n    if money < sockCost:\n        return \"Unlucky Chef\"\n    else:\n        return \"Lucky Chef\"",
        "test": "",
        "num_ids": 61,
        "indeed": false
    },
    {
        "number": 2669,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    start_times = list(map(int, stdin.readline().strip().split()))\n    finish_times = list(map(int, stdin.readline().strip().split()))\n\n    tasks = sorted(zip(start_times, finish_times), key=lambda x: x[1])\n\n    selected_tasks = []\n    current_task = None\n    for i, task in enumerate(tasks):\n        if current_task is None or current_task[1] <= task[0]:\n            current_task = task\n            selected_tasks.append(i)\n\n    return \" \".join(map(str, selected_tasks))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2670,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, T + 1):\n        str1, str2 = stdin.split('\\n')[i].split()\n        max_length = 0\n\n        for j in range(len(str1)):\n            for k in range(j, len(str1)):\n                for l in range(len(str2)):\n                    for m in range(l, len(str2)):\n                        if str1[j:k + 1] == str2[l:m + 1][::-1] and len(str1[j:k + 1]) == len(str2[l:m + 1]):\n                            subpair = str1[j:k + 1] + str2[l:m + 1]\n                            if subpair == subpair[::-1] and len(subpair) > max_length:\n                                max_length = len(subpair)\n\n        result.append(str(max_length))\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 261,
        "indeed": false
    },
    {
        "number": 2671,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    boxes = list(map(int, input().split()))\n    queries = list(map(int, input().split()))\n\n    def count_candies(level: int, index: int) -> int:\n        if level == 0:\n            return boxes[index]\n        total_candies = 0\n        for i in range(boxes[index]):\n            total_candies += count_candies(level - 1, index + i + 1)\n        return total_candies\n\n    result = []\n    for query in queries:\n        level = n\n        index = 0\n        total_candies = count_candies(level, index)\n        while total_candies < query:\n            level -= 1\n            index += 1\n            total_candies = count_candies(level, index)\n        result.append(level + 1)\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 246,
        "indeed": false
    },
    {
        "number": 2672,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x == 1:\n        return \"3\"\n    else:\n        return str((x - 1) * 3)",
        "test": "",
        "num_ids": 44,
        "indeed": false
    },
    {
        "number": 2673,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    sequence = list(stdin)\n    n = len(sequence)\n    jumps = 0\n    i = 0\n    while i < n - 1:\n        if sequence[i + 1] == sequence[i]:\n            i += 1\n        else:\n            jumps += 1\n            i += 1\n    return str(jumps)",
        "test": "",
        "num_ids": 87,
        "indeed": false
    },
    {
        "number": 2674,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    price = int(stdin)\n    if price % 10 == 0:\n        return \"Inclusive\"\n    else:\n        return \"Exclusive\"",
        "test": "",
        "num_ids": 42,
        "indeed": false
    },
    {
        "number": 2675,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    red_balls = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    blue_balls = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def check_collision(ball1, ball2):\n        x1, v1 = ball1\n        x2, v2 = ball2\n        if v1 == v2:\n            return None\n        t = (x2 - x1) / (v1 - v2)\n        if t < 0:\n            return None\n        return (x1 + t * v1, x2 + t * v2)\n\n    collisions = 0\n    for i in range(n):\n        for j in range(m):\n            collision = check_collision(red_balls[i], blue_balls[j])\n            if collision:\n                collisions += 1\n                for k in range(n):\n                    if red_balls[k][0] == collision[0]:\n                        red_balls[k] = None\n                for k in range(m):\n                    if blue_balls[k][0] == collision[1]:\n                        blue_balls[k] = None\n\n    return str(collisions)",
        "test": "",
        "num_ids": 324,
        "indeed": false
    },
    {
        "number": 2676,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    strings = set()\n    for i in range(1, N + 1):\n        strings.add(lines[i])\n    M = int(lines[N + 1])\n    B = lines[N + 2]\n    substrings = set()\n    for i in range(len(B)):\n        for j in range(i + 1, len(B) + 1):\n            substrings.add(\"\".join(sorted(B[i:j])))\n    count = 0\n    for substring in substrings:\n        if substring in strings:\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 2677,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    max_consecutive_vowels = 0\n    unique_consonants = set()\n\n    for i in range(len(stdin)):\n        if stdin[i] in vowels:\n            max_consecutive_vowels += 1\n        else:\n            max_consecutive_vowels = 0\n\n        if stdin[i] in consonants:\n            unique_consonants.add(stdin[i])\n\n        if max_consecutive_vowels >= 3 and len(unique_consonants) >= 5:\n            return \"GOOD\"\n\n    return \"-1\"\n",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 2678,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_covered(intervals, i):\n        for a, b in intervals:\n            if not (a <= i <= b):\n                return False\n        return True\n\n    def smallest_set_size(intervals):\n        lcms = [intervals[0][1]]\n        for i in range(1, len(intervals)):\n            lcms.append(lcm(lcms[-1], intervals[i][1]))\n\n        min_size = float('inf')\n        for lcm_ in lcms:\n            if all(is_covered(intervals, i) for i in range(1, lcm_ + 1)):\n                min_size = min(min_size, lcm_)\n\n        return min_size\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    intervals = [list(map(int, line.split())) for line in lines[1:N + 1]]\n\n    return str(smallest_set_size(intervals))",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 2679,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    coins = list(map(int, stdin.split('\\n')[1].split()))\n\n    def helper(coins: list, start: int, end: int, sack1: list, sack2: list) -> int:\n        if start > end:\n            return max(sum(sack1), sum(sack2))\n\n        sack1.append(coins[start])\n        sack2.append(coins[end])\n\n        return max(helper(coins, start + 1, end, sack1, sack2),\n                   helper(coins, start, end - 1, sack1, sack2))\n\n    return str(helper(coins, 0, n - 1, [], []))",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 2680,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_corner(x, y, n):\n        return (x == 1 or x == n) and (y == 1 or y == n)\n\n    def min_moves(bombs, n):\n        moves = 0\n        for i in range(len(bombs)):\n            x, y = bombs[i]\n            if not is_corner(x, y, n):\n                moves += 2\n        return moves\n\n    lines = stdin.split(\"\\n\")\n    n, b = map(int, lines[0].split())\n    x = list(map(int, lines[1].split()))\n    y = list(map(int, lines[2].split()))\n\n    bombs = list(zip(x, y))\n    return str(min_moves(bombs, n))",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 2681,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(str, stdin.split(\"\\n\"))\n    A, B = float(A), float(B)\n    if C == \"+\":\n        result = A + B\n    elif C == \"-\":\n        result = A - B\n    elif C == \"*\":\n        result = A * B\n    elif C == \"/\":\n        result = A / B\n    else:\n        raise ValueError(\"Invalid operator\")\n    return f\"{result:.6f}\"",
        "test": "",
        "num_ids": 115,
        "indeed": false
    },
    {
        "number": 2682,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def shuffle(deck: List[int], n: int) -> List[int]:\n        for k in range(n):\n            decks = [deck[i:i + (1 << k)] for i in range(0, len(deck), 1 << k)]\n            decks = [decks[i] + decks[i + 1] for i in range(0, len(decks) - 1, 2)]\n            deck = [card for subdeck in decks for card in subdeck]\n        return deck\n\n    def find_card(deck: List[int], k: int) -> int:\n        return deck.index(k)\n\n    def main(stdin: str) -> str:\n        lines = stdin.splitlines()\n        Q = int(lines[0])\n        outputs = []\n        for i in range(1, Q + 1):\n            N, K = map(int, lines[i].split())\n            deck = list(range(2 * N))\n            shuffled_deck = shuffle(deck, N)\n            output = find_card(shuffled_deck, K)\n            outputs.append(str(output))\n        return \"\\n\".join(outputs)\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 298,
        "indeed": false
    },
    {
        "number": 2683,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(board: List[List[str]], n: int, k: int) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == '.':\n                    continue\n                if (i + k <= n) and all(board[i + l][j] == board[i][j] for l in range(k)):\n                    return True\n                if (j + k <= n) and all(board[i][j + l] == board[i][j] for l in range(k)):\n                    return True\n                if (i + j + k <= n) and all(board[i + l][j + l] == board[i][j] for l in range(k)):\n                    return True\n                if (i - j + k <= n) and all(board[i - l][j + l] == board[i][j] for l in range(k)):\n                    return True\n        return False\n\n    def can_win(board: List[List[str]], n: int, k: int) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == '.':\n                    board[i][j] = 'X'\n                    if check_win(board, n, k):\n                        return True\n                    board[i][j] = '.'\n        return False\n\n    lines = stdin.split('\\n')\n    T = int(lines[0])\n    for t in range(1, T + 1):\n        N, K = map(int, lines[t].split())\n        board = [list(lines[t + 1 + i]) for i in range(N)]\n        if can_win(board, N, K):\n            print(\"YES\")\n        else:\n            print(\"NO\")",
        "test": "",
        "num_ids": 442,
        "indeed": false
    },
    {
        "number": 2684,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    word = stdin.readline().strip()\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_palindrome_subword(word: str) -> str:\n        longest_palindrome = \"\"\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                subword = word[i:j]\n                if is_palindrome(subword) and len(subword) > len(longest_palindrome):\n                    longest_palindrome = subword\n        return longest_palindrome\n\n    longest_palindrome = longest_palindrome_subword(word)\n    return f\"{len(longest_palindrome)}\\n{longest_palindrome}\"",
        "test": "",
        "num_ids": 217,
        "indeed": false
    },
    {
        "number": 2685,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x, y = stdin.split('\\n')\n    s = list(s)\n    x = int(x)\n    y = int(y)\n    cost = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            if i == 0:\n                cost += min(x, y)\n            else:\n                count_0 = s[:i].count('0')\n                count_1 = s[:i].count('1')\n                cost_0 = (i + 1) * x - count_0\n                cost_1 = (i + 1) * y - count_1\n                cost += min(cost_0, cost_1)\n    return str(cost)",
        "test": "",
        "num_ids": 175,
        "indeed": false
    },
    {
        "number": 2686,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, close_pairs):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, depth = queue.pop(0)\n            if node == end:\n                return depth\n            if node not in visited:\n                visited.add(node)\n                for pair in close_pairs:\n                    if node in pair:\n                        next_node = pair[0] if pair[1] == node else pair[1]\n                        if next_node not in visited:\n                            queue.append((next_node, depth + 1))\n        return None\n\n    N, M = map(int, stdin.readline().split())\n    close_pairs = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n    S, T = map(int, stdin.readline().split())\n\n    result = bfs(S, T, close_pairs)\n    return str(result) if result is not None else \"0\"",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2687,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def nCr(n, r):\n        return fact[n] * inv_fact[r] * inv_fact[n - r] % MOD\n\n    def count_finalists(k, n):\n        if k == 1:\n            return [nCr(n, i) for i in range(1, n + 1)]\n        else:\n            prev = count_finalists(k - 1, n)\n            curr = [0] * n\n            for i in range(1, n):\n                curr[i] = (prev[i - 1] + prev[i + 1]) % MOD\n            return curr\n\n    K = int(stdin.split()[0])\n    N = 2 * K\n    MOD = 10**9 + 9\n    fact = [1] * (N + 1)\n    inv_fact = [1] * (N + 1)\n\n    for i in range(1, N + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n        inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n\n    finalists = count_finalists(K, N)\n    return \"\\n\".join(map(str, finalists))",
        "test": "",
        "num_ids": 307,
        "indeed": false
    },
    {
        "number": 2688,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    permutation = list(map(int, stdin.split('\\n')[1].split()))\n    cycles = []\n    visited = [False] * N\n\n    for start in range(1, N + 1):\n        if not visited[start - 1]:\n            cycle = [start]\n            visited[start - 1] = True\n            current = permutation[start - 1]\n\n            while current != start:\n                cycle.append(current)\n                visited[current - 1] = True\n                current = permutation[current - 1]\n\n            cycles.append(cycle)\n\n    output = [str(len(cycles))] + [' '.join(map(str, cycle)) for cycle in cycles]\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 195,
        "indeed": false
    },
    {
        "number": 2689,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expand_string(s: str) -> str:\n        result = \"\"\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                j = i + 1\n                while j < len(s) and s[j].isalpha():\n                    j += 1\n                if j < len(s) and s[j] == \"-\":\n                    result += int(s[:i]) * s[i + 1:j]\n                    i = j + 1\n                else:\n                    result += s[i]\n                    i += 1\n            else:\n                result += s[i]\n                i += 1\n        return result\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    code_string = stdin.strip()\n    original_string = expand_string(code_string)\n\n    if is_palindrome(original_string):\n        return \"Return\"\n    else:\n        return \"Continue\"",
        "test": "",
        "num_ids": 251,
        "indeed": false
    },
    {
        "number": 2690,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] != s[j]:\n                diff = abs(i-j)\n                if diff > max_diff:\n                    max_diff = diff\n    return str(max_diff)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 2691,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = input()\n    max_cost = 0\n    for i in range(N):\n        for j in range(i, N):\n            if j - i + 1 <= P:\n                sub_str = S[i:j+1]\n                if len(set(sub_str)) == 1:\n                    max_cost = max(max_cost, len(sub_str))\n    return max_cost",
        "test": "",
        "num_ids": 116,
        "indeed": false
    },
    {
        "number": 2692,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_min_cookies(N: int, B: int) -> int:\n        A = N // B\n        while A * B < N:\n            A += 1\n        return A\n\n    testcases = int(stdin.split('\\n')[0])\n    inputs = list(map(int, stdin.split('\\n')[1:]))\n    outputs = []\n\n    for i in range(testcases):\n        N, B = inputs[i * 2], inputs[i * 2 + 1]\n        A = calculate_min_cookies(N, B)\n        outputs.append(str(A))\n\n    return '\\n'.join(outputs)",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 2693,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P, k = map(int, stdin.split())\n    if k == 1:\n        if S == P:\n            return str(S)\n        else:\n            return \"NO\"\n    elif k == 2:\n        if S % 2 == 1 or P < 1:\n            return \"NO\"\n        n1 = S // 2\n        n2 = P // n1\n        if n1 * n2 == P and n1 + n2 == S:\n            return f\"{n1} {n2}\"\n        else:\n            return \"NO\"\n    elif k == 3:\n        if S % 3 == 0 and P % 3 == 0:\n            n1 = S // 3\n            n2 = P // n1\n            n3 = S - n1 - n2\n            if n1 * n2 * n3 == P and n1 + n2 + n3 == S:\n                return f\"{n1} {n2} {n3}\"\n        return \"NO\"\n    elif k == 4:\n        if S % 4 == 0 and P % 4 == 0:\n            n1 = S // 4\n            n2 = P // n1\n            n3 = (S - n1) // 2\n            n4 = S - n1 - n3\n            if n1 * n2 * n3 * n4 == P and n1 + n2 + n3 + n4 == S:\n                return f\"{n1} {n2} {n3} {n4}\"\n        return \"NO\"\n    else:\n        return \"NO\"",
        "test": "",
        "num_ids": 384,
        "indeed": false
    },
    {
        "number": 2694,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, blasters):\n        for blaster in blasters:\n            if blaster[0] == x and blaster[1] == y:\n                return False\n        return True\n\n    def simulate(n, m, blasters):\n        time = 0\n        visited = set()\n        queue = [(1, 1, time)]\n\n        while queue:\n            x, y, time = queue.pop(0)\n            visited.add((x, y))\n\n            if x == n and y == m:\n                return time\n\n            for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n\n                if 1 <= new_x <= n and 1 <= new_y <= m and is_valid(new_x, new_y, blasters):\n                    queue.append((new_x, new_y, time + 1))\n\n            for blaster in blasters:\n                if time % blaster[2] == blaster[3]:\n                    for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n                        new_x, new_y = blaster[0] + dx, blaster[1] + dy\n\n                        if 1 <= new_x <= n and 1 <= new_y <= m and is_valid(new_x, new_y, blasters):\n                            queue.append((new_x, new_y, time + 1))\n\n        return \"NO\"\n\n    n, m, k = map(int, stdin.split()[0:3])\n    blasters = [tuple(map(int, stdin.split()[3 * i + 3:3 * i + 6])) for i in range(k)]\n\n    result = simulate(n, m, blasters)\n    return f\"YES\\n{result}\" if result != \"NO\" else \"NO\"",
        "test": "",
        "num_ids": 498,
        "indeed": false
    },
    {
        "number": 2695,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')[:2]\n    order = list(map(int, stdin.split('\\n')[2].split()))\n\n    i, j = 0, 0\n    count = 0\n\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            j += 1\n        i += 1\n\n    for k in range(len(order)):\n        if order[k] <= i:\n            count += 1\n        else:\n            break\n\n    return count",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2696,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    # Find the first occurrence of the last color in the list\n    last_color = colors[-1]\n    last_color_index = colors.index(last_color)\n\n    # Find the first occurrence of the last color to the left of the last painted cube\n    first_color_index = len(colors) - 1 - last_color_index\n\n    # Calculate the position of Ali\n    x = n - first_color_index\n\n    return str(x)",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2697,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    while n > 1:\n        n = n // 2\n        count += 1\n    return str(count)",
        "test": "",
        "num_ids": 47,
        "indeed": false
    },
    {
        "number": 2698,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, V = map(int, stdin.readline().split())\n    lanes = []\n    for i in range(M):\n        Di, Ai = map(int, stdin.readline().split())\n        lanes.append((Di, Ai))\n\n    lanes.sort()\n\n    total_vegetables = 0\n    current_day = 1\n    while lanes:\n        Di, Ai = lanes[0]\n        if Di <= current_day:\n            vegetables_to_collect = min(Ai, V)\n            total_vegetables += vegetables_to_collect\n            Ai -= vegetables_to_collect\n            if Ai == 0:\n                lanes.pop(0)\n            else:\n                lanes[0] = (Di + 1, Ai)\n        else:\n            current_day = Di\n\n        if current_day > 3000:\n            break\n\n    return str(total_vegetables)",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 2699,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_pattern(n: int) -> str:\n        pattern = []\n        for i in range(1, n + 1):\n            row = []\n            for j in range(1, n + 1):\n                row.append(i * j)\n            pattern.append(row)\n        return pattern\n\n    def print_pattern(pattern: List[List[int]]) -> str:\n        output = \"\"\n        for row in pattern:\n            output += \" \".join(str(x) for x in row) + \"\\n\"\n        return output\n\n    lines = stdin.split(\"\\n\")\n    T = int(lines[0])\n    output = \"\"\n    for i in range(1, T + 1):\n        N = int(lines[i])\n        pattern = generate_pattern(N)\n        output += print_pattern(pattern)\n\n    return output",
        "test": "",
        "num_ids": 207,
        "indeed": false
    },
    {
        "number": 2700,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_solutions(a, b, c, d):\n        return (b - a + 1) * (d - c + 1)\n\n    T = int(stdin.split('\\n')[0])\n    output = []\n\n    for i in range(T):\n        a, b, c, d = map(int, stdin.split('\\n')[i + 1].split())\n        output.append(count_solutions(a, b, c, d))\n\n    return '\\n'.join(map(str, output))\n",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2701,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    apple_types = list(map(int, stdin.split()))\n\n    def get_apples(left_type, right_type):\n        left_apples = [i for i, t in enumerate(apple_types, 1) if t == left_type]\n        right_apples = [i for i, t in enumerate(apple_types, 1) if t == right_type]\n        left_time = len(left_apples)\n        right_time = len(right_apples)\n        return left_time, right_time\n\n    min_time = float('inf')\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i + j == K:\n                left_time, right_time = get_apples(i, j)\n                time = max(left_time, right_time)\n                if time < min_time:\n                    min_time = time\n\n    return str(min_time) if min_time != float('inf') else '-1'",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 2702,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_contradicting(statements, truth_speakers, index):\n        for i in range(len(statements[index])):\n            if statements[index][i] == \"T\" and i not in truth_speakers:\n                return True\n        return False\n\n    def max_truth_speakers(statements):\n        truth_speakers = set()\n        for i in range(len(statements)):\n            if not is_contradicting(statements, truth_speakers, i):\n                truth_speakers.add(i)\n        return len(truth_speakers)\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    statements = [line for line in lines[1:]]\n\n    for i in range(len(statements)):\n        statements[i] = statements[i].split(\" \")\n\n    return str(max_truth_speakers(statements))",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 2703,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    queries = [int(stdin.readline()) for _ in range(Q)]\n\n    max_candies = sum(a)\n\n    for X in queries:\n        total_candies = 0\n        for candies in a:\n            if candies >= X:\n                total_candies += candies\n            else:\n                total_candies += candies - X + 1\n        max_candies = min(max_candies, total_candies)\n\n    return max_candies",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2704,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    A.sort()\n\n    for _ in range(Q):\n        t = int(stdin.readline())\n        if t in A:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n",
        "test": "",
        "num_ids": 89,
        "indeed": false
    },
    {
        "number": 2705,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    def max_length_subarray(a, k):\n        remainder_dict = {}\n        max_length = 0\n        current_length = 0\n\n        for i in range(n):\n            remainder = a[i] % k\n            if remainder not in remainder_dict:\n                remainder_dict[remainder] = i\n            else:\n                current_length = i - remainder_dict[remainder]\n                max_length = max(max_length, current_length)\n\n        return max_length\n\n    beauty = max_length_subarray(a, k)\n\n    for _ in range(m):\n        i, operation, value = map(int, stdin.split()[_ + 2].split())\n        i -= 1\n        if operation == 1:\n            a[i] += value\n        else:\n            a[i] -= value\n\n        beauty = max(beauty, max_length_subarray(a, k))\n\n    return str(beauty)",
        "test": "",
        "num_ids": 282,
        "indeed": false
    },
    {
        "number": 2706,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0:2])\n    numbers = []\n    queries = stdin.split('\\n')[2:]\n\n    for query in queries:\n        q = int(query)\n        if q >= 0:\n            numbers.append(q)\n        else:\n            numbers.sort()\n            print(numbers[k-1])\n\n    return \"\"",
        "test": "",
        "num_ids": 97,
        "indeed": false
    },
    {
        "number": 2707,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    def mex(arr):\n        mex_set = set()\n        for i in arr:\n            if i in mex_set:\n                mex_set.remove(i)\n            else:\n                mex_set.add(i)\n        return min(mex_set)\n\n    def dfs(start, end, k):\n        if k < 0:\n            return 0\n        if start == end:\n            return 1 if mex([A[start]]) <= k else 0\n\n        ans = dfs(start, end - 1, k)\n        ans += dfs(start + 1, end, k - (mex(A[start:end]) - (0 if start == 0 else A[start - 1])))\n        return ans % mod\n\n    return str(dfs(0, n - 1, k))",
        "test": "",
        "num_ids": 241,
        "indeed": false
    },
    {
        "number": 2708,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return str(n)",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 2709,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def modulo_mapping(num):\n        return chr(97 + num % 26)\n\n    def find_cycle(A, i):\n        visited = set()\n        while i not in visited and 0 <= i < len(A):\n            visited.add(i)\n            i = A[i]\n        return \"Cyclic\" if i in visited else \"Done\" if i == len(A) - 1 else \"Out\"\n\n    def process_array(A, t):\n        if t == 1:\n            return \"7\"\n        elif t == 2:\n            return \"Bigger\" if A[0] > A[1] else \"Equal\" if A[0] == A[1] else \"Smaller\"\n        elif t == 3:\n            return sorted(A[:3])[1]\n        elif t == 4:\n            return sum(A)\n        elif t == 5:\n            return sum(x for x in A if x % 2 == 0)\n        elif t == 6:\n            return \"\".join(modulo_mapping(x % 26) for x in A)\n        elif t == 7:\n            return find_cycle(A, 0)\n\n    N, t = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n\n    return process_array(A, t)",
        "test": "",
        "num_ids": 338,
        "indeed": false
    },
    {
        "number": 2710,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, graph, soldiers):\n        if start == end:\n            return soldiers[start]\n        if start not in visited:\n            visited.add(start)\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    result = dfs(neighbor, end, visited, graph, soldiers)\n                    if result is not None:\n                        return max(result - soldiers[start], 0)\n        return None\n\n    def create_graph(roads):\n        graph = {i: [] for i in range(1, n + 1)}\n        for road in roads:\n            p, q = road\n            graph[p].append(q)\n            graph[q].append(p)\n        return graph\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n    roads = [list(map(int, line.split())) for line in lines[3:3 + m]]\n\n    graph = create_graph(roads)\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if i == j:\n                row.append(b[i] - a[i])\n            else:\n                visited = set()\n                soldiers_left = dfs(i + 1, j + 1, visited, graph, a)\n                if soldiers_left is not None and soldiers_left >= b[j]:\n                    row.append(soldiers_left)\n                else:\n                    row.append(0)\n        result.append(row)\n\n    if all(sum(row) == b[i] for i, row in enumerate(result)):\n        return 'YES\\n' + '\\n'.join(' '.join(map(str, row)) for row in result)\n    else:\n        return 'NO'",
        "test": "",
        "num_ids": 478,
        "indeed": false
    },
    {
        "number": 2711,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    pages = [stdin.readline().strip() for _ in range(n)]\n    words = [stdin.readline().strip() for _ in range(n * k)]\n\n    alphabet = set()\n    for word in words:\n        alphabet.update(set(word))\n\n    if len(alphabet) > 26:\n        return \"IMPOSSIBLE\"\n\n    alphabet = sorted(list(alphabet))\n    return ''.join(alphabet)\n",
        "test": "",
        "num_ids": 133,
        "indeed": false
    },
    {
        "number": 2712,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_d(a, b, c):\n        for d in range(1, 10**9 + 1):\n            if a + b + c + d <= 2 * max(a, b, c, d):\n                return d\n        return -1\n\n    t = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n', 1)[1].split('\\n')\n\n    output = []\n    for line in lines:\n        a, b, c = map(int, line.split())\n        d = find_d(a, b, c)\n        output.append(str(d))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 168,
        "indeed": false
    },
    {
        "number": 2713,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    ranks = [2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n    stars = [0] * 25\n    current_rank = 25\n    bonus_star = False\n\n    for game in stdin:\n        if game == 'W':\n            stars[current_rank - 1] += 1\n            if stars[current_rank - 1] == ranks[current_rank - 1] + (1 if bonus_star else 0):\n                bonus_star = False\n                if current_rank == 1:\n                    current_rank = 25\n                    stars[current_rank - 1] = 1\n                elif current_rank == 20:\n                    current_rank -= 1\n                    stars[current_rank - 1] = 2\n                else:\n                    current_rank -= 1\n                    stars[current_rank - 1] = 1\n            elif stars[current_rank - 1] == ranks[current_rank - 1]:\n                bonus_star = True\n        else:\n            if current_rank == 20:\n                stars[current_rank - 1] = max(0, stars[current_rank - 1] - 1)\n            elif current_rank > 20:\n                current_rank += 1\n                stars[current_rank - 1] = 0\n            else:\n                stars[current_rank - 1] = max(0, stars[current_rank - 1] - 1)\n\n    return \"Legend\" if current_rank == 1 else current_rank",
        "test": "",
        "num_ids": 413,
        "indeed": false
    },
    {
        "number": 2714,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(graph: List[List[int]], numbers: List[int]) -> bool:\n        for u, v in graph:\n            if (numbers[u - 1] + numbers[v - 1]) % 2 == 0:\n                return False\n        return True\n\n    def count_ways(graph: List[List[int]], numbers: List[int], vertex: int, modulo: int) -> int:\n        if vertex == len(numbers):\n            return 1 if is_beautiful(graph, numbers) else 0\n\n        ways = 0\n        for number in [1, 2, 3]:\n            if number not in numbers[:vertex]:\n                numbers[vertex] = number\n                ways += count_ways(graph, numbers, vertex + 1, modulo)\n                ways %= modulo\n        return ways\n\n    modulo = 998244353\n    tests = int(stdin.readline())\n    output = []\n\n    for _ in range(tests):\n        n, m = map(int, stdin.readline().split())\n        graph = [list(map(int, stdin.readline().split())) for _ in range(m)]\n        numbers = [0] * n\n        output.append(count_ways(graph, numbers, 0, modulo))\n\n    return \"\\n\".join(map(str, output))",
        "test": "",
        "num_ids": 335,
        "indeed": false
    },
    {
        "number": 2715,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    n = 2\n    a = [3] * n\n\n    while k > 0:\n        max_element = max(a)\n        max_index = a.index(max_element)\n        a[max_index] = max_element - n\n        for i in range(n):\n            if i != max_index:\n                a[i] += 1\n        k -= 1\n\n    return f\"{n}\\n{' '.join(map(str, a))}\"\n",
        "test": "",
        "num_ids": 129,
        "indeed": false
    },
    {
        "number": 2716,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(arr):\n        n = len(arr)\n        if n % 2 == 1:\n            return sorted(arr)[n // 2]\n        else:\n            return sorted(arr)[n // 2 - 1 : n // 2 + 1]\n\n    def find_most_frequent(arr):\n        count = {}\n        for num in arr:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        max_count = max(count.values())\n        if max_count > len(arr) / 2:\n            return max(k for k, v in count.items() if v == max_count)\n        else:\n            return -1\n\n    def find_range(arr):\n        result = []\n        for num in arr:\n            if 100 <= num <= 999:\n                result.append(num)\n        return result\n\n    lines = stdin.split(\"\\n\")\n    N, t = map(int, lines[0].split())\n    A = list(map(int, lines[1].split()))\n\n    if t == 1:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if A[i] + A[j] == 7777:\n                    return \"Yes\"\n        return \"No\"\n    elif t == 2:\n        return \"Unique\" if len(set(A)) == N else \"Contains duplicate\"\n    elif t == 3:\n        return find_most_frequent(A)\n    elif t == 4:\n        return \" \".join(str(x) for x in find_median(A))\n    elif t == 5:\n        return \" \".join(str(x) for x in find_range(A))",
        "test": "",
        "num_ids": 444,
        "indeed": false
    },
    {
        "number": 2717,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, teams = stdin.split('\\n')\n    n = int(n)\n\n    if n == 1:\n        return 0\n\n    min_switches = float('inf')\n\n    for i in range(n):\n        current_teams = teams[i:] + teams[:i]\n        switches = 0\n        for j in range(n):\n            if current_teams[j] != teams[j]:\n                switches += 1\n        min_switches = min(min_switches, switches)\n\n    return str(min_switches)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2718,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    if N == M:\n        return \"win\"\n\n    while N > 0 and M > 0:\n        if N > M:\n            N -= M\n        else:\n            M -= N\n\n    if N == 0:\n        return \"win\"\n    else:\n        return \"lose\"",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 2719,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_true_closed_chain(needles):\n        for i in range(len(needles)):\n            for j in range(i + 1, len(needles)):\n                if needles[i][1] == needles[j][0] and needles[i][0] == needles[j][1]:\n                    return True\n        return False\n\n    def is_floor_closed_chain(needles):\n        for i in range(len(needles)):\n            for j in range(i + 1, len(needles)):\n                if needles[i][1] != needles[j][0]:\n                    return False\n        for i in range(len(needles)):\n            if needles[i][1] != needles[-1][0]:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    K = int(lines[0])\n    needles = []\n    for i in range(1, K + 1):\n        x1, y1, z1, x2, y2, z2 = map(int, lines[i].split())\n        needles.append(((x1, y1, z1), (x2, y2, z2)))\n\n    true_closed_chain = is_true_closed_chain(needles)\n    floor_closed_chain = is_floor_closed_chain(needles)\n\n    if true_closed_chain:\n        return 'True closed chains\\nFloor closed chains'\n    elif floor_closed_chain:\n        return 'No true closed chains\\nFloor closed chains'\n    else:\n        return 'No true closed chains\\nNo floor closed chains'",
        "test": "",
        "num_ids": 403,
        "indeed": false
    },
    {
        "number": 2720,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_regions(maze):\n        regions = [[0 for _ in range(len(maze[0]))] for _ in range(len(maze))]\n        region_count = 0\n\n        def dfs(x, y):\n            if regions[x][y] == 0:\n                regions[x][y] = 1\n                region_count[0] += 1\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] != '#':\n                        dfs(nx, ny)\n\n        for i in range(len(maze)):\n            for j in range(len(maze[0])):\n                if regions[i][j] == 0 and maze[i][j] != '#':\n                    dfs(i, j)\n\n        return region_count[0]\n\n    def remove_walls(maze):\n        def is_valid(x, y):\n            if x < 0 or x >= len(maze) or y < 0 or y >= len(maze[0]):\n                return False\n            return maze[x][y] != '#'\n\n        def dfs(x, y):\n            if not is_valid(x, y):\n                return False\n\n            maze[x][y] = '#'\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and maze[nx][ny] != '#':\n                    dfs(nx, ny)\n\n            return True\n\n        for i in range(len(maze)):\n            for j in range(len(maze[0])):\n                if dfs(i, j):\n                    return True\n\n        return False\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    maze = [list(lines[i + 1]) for i in range(R)]\n\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == '.':\n                maze[i][j] = '#'\n\n    regions = count_regions(maze)\n    while not remove_walls(maze):\n        regions -= 1\n\n    return str(regions)",
        "test": "",
        "num_ids": 649,
        "indeed": false
    },
    {
        "number": 2721,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, l, M, L, t_m, t_l = map(int, stdin.split())\n\n    if t_m <= abs(m - M) or t_l <= abs(l - L):\n        return \"impossible\"\n    else:\n        return \"possible\"",
        "test": "",
        "num_ids": 70,
        "indeed": false
    },
    {
        "number": 2722,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    turtle_pos = next((x, y) for x in range(8) for y in range(8) if board[x][y] == 'T')\n    diamond_pos = next((x, y) for x in range(8) for y in range(8) if board[x][y] == 'D')\n    ice_castles = [(x, y) for x in range(8) for y in range(8) if board[x][y] == 'I']\n\n    def is_valid_move(x, y, direction):\n        if not (0 <= x < 8 and 0 <= y < 8):\n            return False\n        if board[x][y] == 'C':\n            return False\n        if (x, y) in ice_castles and direction == 'X':\n            return True\n        if board[x][y] == '.':\n            return True\n        return False\n\n    def move_turtle(x, y, direction, program):\n        if (x, y) == diamond_pos:\n            return program\n\n        if direction == 'F':\n            new_x, new_y = x, y + 1\n            new_direction = 'F'\n        elif direction == 'R':\n            new_x, new_y = x + 1, y\n            new_direction = 'F'\n        elif direction == 'L':\n            new_x, new_y = x - 1, y\n            new_direction = 'F'\n        else:\n            new_x, new_y = x, y\n            new_direction = 'X'\n\n        if is_valid_move(new_x, new_y, new_direction):\n            if (new_x, new_y) in ice_castles and new_direction == 'X':\n                new_ice_castles = [(i, j) for (i, j) in ice_castles if (i, j) != (new_x, new_y)]\n                return move_turtle(new_x, new_y, new_direction, program + 'X') or \\\n                       move_turtle(x, y, direction, program + 'X' + 'FLFR' + 'F' * (new_y - 1)) or \\\n                       move_turtle(x, y, direction, program + 'X' + 'FLFR' + 'R' + 'F' * (8 - new_x) + 'L' + 'F' * (new_y - 1))\n            else:\n                return move_turtle(new_x, new_y, new_direction, program + direction)\n\n        if direction == 'F':\n            return move_turtle(x, y, 'R', program + 'R') or \\\n                   move_turtle(x, y, 'L', program + 'L')\n\n        return None\n\n    return move_turtle(turtle_pos[0], turtle_pos[1], 'F', '') or 'No solution'",
        "test": "",
        "num_ids": 735,
        "indeed": false
    },
    {
        "number": 2723,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(formula: str) -> int:\n        def parse_term(formula: str) -> Tuple[int, str]:\n            if formula[0] == '(':\n                value, formula = evaluate(formula[1:])\n                assert formula[0] == ')'\n                return value, formula[1:]\n            else:\n                value = 0\n                while formula[0].isdigit():\n                    value = value * 10 + int(formula[0])\n                    formula = formula[1:]\n                return value, formula\n\n        def parse_simple(formula: str) -> Tuple[int, str]:\n            value, formula = parse_term(formula)\n            while formula[0] in ('+', '-'):\n                op, formula = formula[0], formula[1:]\n                term_value, formula = parse_term(formula)\n                if op == '+':\n                    value += term_value\n                else:\n                    value -= term_value\n            return value, formula\n\n        def parse_complex(formula: str) -> Tuple[int, str]:\n            if formula[0] == '\\\\':\n                formula = formula[1:]\n                assert formula[0] == '/'\n                formula = formula[1:]\n                value, formula = parse_simple(formula)\n                sqrt_value = int(math.sqrt(value))\n                return sqrt_value, formula\n            elif formula[0] == '=':\n                formula = formula[1:]\n                assert formula[0] == '='\n                formula = formula[1:]\n                value, formula = parse_simple(formula)\n                return value, formula\n            else:\n                return parse_simple(formula)\n\n        def parse_formula(formula: str) -> Tuple[int, str]:\n            if formula[0] == '(':\n                value, formula = evaluate(formula)\n                assert formula[0] == ')'\n                return value, formula[1:]\n            else:\n                value, formula = parse_complex(formula)\n                while formula[0] in ('+', '-'):\n                    op, formula = formula[0], formula[1:]\n                    complex_value, formula = parse_complex(formula)\n                    if op == '+':\n                        value += complex_value\n                    else:\n                        value -= complex_value\n                return value, formula\n\n        return parse_formula(formula)[0]\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    formula = ''.join(lines[1:])\n    assert len(formula) == R * C\n    return str(evaluate(formula))",
        "test": "",
        "num_ids": 644,
        "indeed": false
    },
    {
        "number": 2724,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def find_max_distance(stdin: str) -> int:\n        n, *student_coords, *tutor_coords = list(map(str.split, stdin.split('\\n')))\n        n = int(n[0])\n        student_coords = [list(map(int, coord)) for coord in student_coords]\n        tutor_coords = [list(map(int, coord)) for coord in tutor_coords]\n\n        max_distance = 0\n        for student in student_coords:\n            distances = [manhattan_distance(student, tutor) for tutor in tutor_coords]\n            max_distance = max(max_distance, max(distances))\n\n        return max_distance\n\n    max_distance = find_max_distance(stdin)\n    return str(max_distance)",
        "test": "",
        "num_ids": 251,
        "indeed": false
    },
    {
        "number": 2725,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subset_sum(subset_sums, n, total_weight):\n        dp = [False] * (total_weight + 1)\n        dp[0] = True\n\n        for i in range(1, total_weight + 1):\n            for j in range(n):\n                if subset_sums[j] <= i:\n                    dp[i] |= dp[i - subset_sums[j]]\n\n        return dp[total_weight]\n\n    def find_subset_sum(subset_sums, n, total_weight):\n        for i in range(n):\n            if subset_sums[i] == total_weight:\n                return [i + 1]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if subset_sums[i] + subset_sums[j] == total_weight:\n                    return [i + 1, j + 1]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if subset_sums[i] + subset_sums[j] + subset_sums[k] == total_weight:\n                        return [i + 1, j + 1, k + 1]\n\n        return []\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    subset_sums = [int(x) for x in lines[1:]]\n    total_weight = sum(subset_sums)\n\n    if not is_subset_sum(subset_sums, n, total_weight):\n        return 'impossible'\n\n    subset = find_subset_sum(subset_sums, n, total_weight)\n    items = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if j + 1 in subset:\n                items[i] += subset_sums[j]\n\n    return '\\n'.join(str(x) for x in items)",
        "test": "",
        "num_ids": 506,
        "indeed": false
    },
    {
        "number": 2726,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split('\\n')[0].split())\n    cards = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    expected_score = 0\n    max_value = cards[c - 1]\n    for i in range(c, n):\n        if cards[i] > max_value:\n            expected_score = cards[i]\n            break\n\n    if expected_score == 0:\n        expected_score = cards[-1]\n\n    return f\"{expected_score:.5f}\"",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2727,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.readline().split())\n    G = list(map(int, stdin.readline().split()))\n    MOD = 10**9 + 7\n\n    def count_permutations(G, N):\n        dp = [0] * (N + 1)\n        dp[0] = 1\n\n        for g in G:\n            for i in range(g, N + 1):\n                dp[i] += dp[i - 1]\n                dp[i] %= MOD\n\n        return dp[N]\n\n    return str(count_permutations(G, N))",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 2728,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_have_teacher_free_ride(sections, i, j):\n        students_on_first_bus = sum(sections[:i])\n        students_on_second_bus = sum(sections[i:j])\n        teachers_on_first_bus = i - students_on_first_bus\n        teachers_on_second_bus = j - students_on_second_bus - teachers_on_first_bus\n        return teachers_on_first_bus == 0 and teachers_on_second_bus == 0\n\n    N, sections = map(int, stdin.split())\n    sections = list(map(int, sections.split()))\n\n    for i in range(1, N - 1):\n        for j in range(i + 1, N):\n            if can_have_teacher_free_ride(sections, i, j):\n                return f\"{i} {j}\\n\"\n    return \"-1\\n\"",
        "test": "",
        "num_ids": 225,
        "indeed": false
    },
    {
        "number": 2729,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    quotient = N // M\n    remainder = N % M\n    decimal_digits = []\n    if quotient == 0:\n        decimal_digits.append('0')\n    else:\n        while quotient > 0:\n            decimal_digits.append(str(quotient % 10))\n            quotient //= 10\n    if remainder == 0:\n        return ''.join(reversed(decimal_digits))\n    else:\n        divisor = 10\n        while divisor * remainder < M:\n            divisor *= 10\n        decimal_digits.append('.')\n        while remainder > 0:\n            quotient = remainder * 10 // divisor\n            decimal_digits.append(str(quotient))\n            remainder = remainder * 10 % divisor\n            divisor //= 10\n        return ''.join(reversed(decimal_digits)).rstrip('0').rstrip('.')",
        "test": "",
        "num_ids": 247,
        "indeed": false
    },
    {
        "number": 2730,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    total_combinations = N * (N - 1) * (N - 2) * ... * (N - K + 1)\n    winning_combinations = N * (N - 1) * (N - 2) * ... * (N - K + 1) * (N - K)\n    return f\"{winning_combinations / total_combinations:.6f}\"",
        "test": "",
        "num_ids": 113,
        "indeed": false
    },
    {
        "number": 2731,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def format_array(arr: list) -> str:\n        result = \"{\\n\"\n        for i in range(len(arr)):\n            if isinstance(arr[i], list):\n                result += \"  \" * 2 + format_array(arr[i]) + \",\\n\"\n            else:\n                result += \"  \" * 2 + arr[i] + \",\\n\"\n        result = result.rstrip(\",\\n\") + \"\\n\"\n        return result + \"  \" * (len(arr) > 1) + \"}\"\n\n    def parse_array(s: str) -> list:\n        stack = []\n        arr = []\n        word = \"\"\n        for c in s:\n            if c == \"{\":\n                if word:\n                    arr.append(word)\n                    word = \"\"\n                stack.append(arr)\n                arr = []\n            elif c == \"}\":\n                if word:\n                    arr.append(word)\n                    word = \"\"\n                if stack:\n                    last_arr = stack.pop()\n                    last_arr.append(arr)\n                    arr = last_arr\n            elif c == \",\":\n                if word:\n                    arr.append(word)\n                    word = \"\"\n            elif c == \" \":\n                continue\n            else:\n                word += c\n        return arr\n\n    arr = parse_array(stdin[1:-1])\n    return format_array(arr)",
        "test": "",
        "num_ids": 346,
        "indeed": false
    },
    {
        "number": 2732,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    W = float(stdin)\n    t = W % (2 * pi)\n    d = abs(1 - 2 * cos(t))\n    return f\"{d:.6f}\"",
        "test": "",
        "num_ids": 48,
        "indeed": false
    },
    {
        "number": 2733,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def area_weighted_average(x1, y1, r1, x2, y2, r2):\n        area1, area2 = r1 ** 2 * 3.14159, r2 ** 2 * 3.14159\n        total_area = area1 + area2\n        return ((x1 * area1 + x2 * area2) / total_area, (y1 * area1 + y2 * area2) / total_area)\n\n    def area_weighted_velocity(x1, y1, vx1, vy1, r1, x2, y2, vx2, vy2, r2):\n        area1, area2 = r1 ** 2 * 3.14159, r2 ** 2 * 3.14159\n        total_area = area1 + area2\n        return ((vx1 * area1 + vx2 * area2) / total_area, (vy1 * area1 + vy2 * area2) / total_area)\n\n    def agglomerate(droplets, i, j):\n        x1, y1, vx1, vy1, r1 = droplets[i]\n        x2, y2, vx2, vy2, r2 = droplets[j]\n        x, y = area_weighted_average(x1, y1, r1, x2, y2, r2)\n        vx, vy = area_weighted_velocity(x1, y1, vx1, vy1, r1, x2, y2, vx2, vy2, r2)\n        r = (r1 + r2) ** 0.5\n        return (x, y, vx, vy, r)\n\n    def simulate(droplets):\n        n = len(droplets)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(*droplets[i], *droplets[j]) <= droplets[i][4] + droplets[j][4] + 0.001:\n                    new_droplet = agglomerate(droplets, i, j)\n                    droplets.append(new_droplet)\n                    droplets[i], droplets[j] = None, None\n                    return droplets\n        return droplets\n\n    def process(droplets):\n        while True:\n            new_droplets = simulate(droplets)\n            if new_droplets == droplets:\n                break\n            droplets = [d for d in new_droplets if d is not None]\n        return len(droplets), 0\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    droplets = []\n    for i in range(1, n + 1):\n        x, y, vx, vy, r = map(int, lines[i].split())\n        droplets.append((x, y, vx, vy, r))\n\n    k, t = process(droplets)\n    return f\"{k} {t}\\n\" ",
        "test": "",
        "num_ids": 819,
        "indeed": false
    },
    {
        "number": 2734,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    M = N + 1\n    while True:\n        count = 0\n        for i in range(k):\n            power_of_2 = 2 ** i\n            while M >= power_of_2 and M % power_of_2 == 0:\n                count += 1\n                M //= power_of_2\n            if count >= k:\n                break\n        if count == k:\n            break\n        M += 1\n    return str(M)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 2735,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    start, target = stdin.split('\\n')\n    count = 0\n\n    for i in range(len(start)):\n        if start[i] != target[i]:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 58,
        "indeed": false
    },
    {
        "number": 2736,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.readline().split())\n    garden = []\n    for i in range(y):\n        garden.append(list(map(int, stdin.readline().split())))\n\n    def can_pool(cell):\n        i, j = cell\n        for k in range(i - 1, i + 2):\n            for l in range(j - 1, j + 2):\n                if 0 <= k < x and 0 <= l < y and garden[k][l] < garden[i][j]:\n                    return True\n        return False\n\n    count = 0\n    for i in range(x):\n        for j in range(y):\n            if can_pool((i, j)):\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 194,
        "indeed": false
    },
    {
        "number": 2737,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = []\n        visited = set()\n        distances = {vertex: float('inf') for vertex in graph}\n        distances[start] = 0\n        queue.append((start, 0))\n\n        while queue:\n            current_vertex, current_distance = queue.pop(0)\n            if current_vertex not in visited:\n                visited.add(current_vertex)\n                for neighbor, weight in graph[current_vertex].items():\n                    distance = current_distance + weight\n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        queue.append((neighbor, distance))\n\n        return distances[end]\n\n    def bfs(graph, start, end):\n        queue = []\n        visited = set()\n        distances = {vertex: float('inf') for vertex in graph}\n        distances[start] = 0\n        queue.append((start, 0))\n\n        while queue:\n            current_vertex, current_distance = queue.pop(0)\n            if current_vertex not in visited:\n                visited.add(current_vertex)\n                for neighbor, weight in graph[current_vertex].items():\n                    distance = current_distance + weight\n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n                        queue.append((neighbor, distance))\n\n        return distances[end]\n\n    def min_time_to_shelter(n, m, p, roads, s, shelters):\n        graph = {i: {} for i in range(1, n + 1)}\n        for u, v, w in roads:\n            graph[u][v] = w\n            graph[v][u] = w\n\n        min_time = float('inf')\n        for shelter_index, shelter in enumerate(shelters):\n            shelter_capacity, shelter_location = shelter\n            shelter_graph = {i: {} for i in range(1, n + 1)}\n            for u, v, w in roads:\n                if u != shelter_location and v != shelter_location:\n                    shelter_graph[u][v] = w\n                    shelter_graph[v][u] = w\n\n            for person_location in range(1, n + 1):\n                if person_location != shelter_location:\n                    distance = dijkstra(shelter_graph, person_location, shelter_location)\n                    if distance != float('inf'):\n                        min_time = min(min_time, distance)\n\n            if shelter_index == len(shelters) - 1 or min_time >= shelters[shelter_index + 1][0]:\n                break\n\n        return min_time\n\n    n, m, s = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    roads = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    shelters = [list(map(int, stdin.readline().split())) for _ in range(s)]\n\n    return str(min_time_to_shelter(n, m, p, roads, s, shelters))",
        "test": "",
        "num_ids": 786,
        "indeed": false
    },
    {
        "number": 2738,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def check_gears(gears):\n        for i in range(len(gears) - 1):\n            x1, y1, r1 = gears[i]\n            x2, y2, r2 = gears[-1]\n            if (x1 - x2) ** 2 + (y1 - y2) ** 2 > (r1 + r2) ** 2:\n                return False\n        return True\n\n    def find_ratio(gears):\n        source_x, source_y, source_r = gears[0]\n        target_x, target_y, target_r = gears[-1]\n\n        source_theta = 2 * (target_x - source_x) / source_r\n        target_theta = 2 * (target_x - source_x) / target_r\n\n        if source_theta > 0 and target_theta < 0:\n            return -1\n        elif source_theta < 0 and target_theta > 0:\n            return -1\n        else:\n            ratio = abs(source_theta) // gcd(source_theta, target_theta)\n            return f\"{ratio} {target_theta // ratio}\"\n\n    n = int(stdin.readline().strip())\n    gears = [tuple(map(int, line.split())) for line in stdin]\n\n    if not check_gears(gears):\n        return \"-1\"\n    else:\n        return find_ratio(gears) ",
        "test": "",
        "num_ids": 414,
        "indeed": false
    },
    {
        "number": 2739,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bacteria = map(int, stdin.split())\n    mod = 10**9 + 7\n    total_bacteria = 1\n    for i in range(n):\n        total_bacteria *= 2\n        total_bacteria %= mod\n        if bacteria[i] > total_bacteria:\n            return \"error\"\n        total_bacteria -= bacteria[i]\n        total_bacteria %= mod\n    return str(total_bacteria)",
        "test": "",
        "num_ids": 127,
        "indeed": false
    },
    {
        "number": 2740,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, h = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(w):\n        for j in range(n, -1, -1):\n            for k in range(j, -1, -1):\n                dp[j] += dp[k]\n                dp[j] %= MOD\n    return str(dp[n])",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 2741,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    octal_to_decimal = int(stdin, 8)\n    hexadecimal = hex(octal_to_decimal)[2:].upper()\n    return hexadecimal",
        "test": "",
        "num_ids": 48,
        "indeed": true
    },
    {
        "number": 2742,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    coins = [1, 10, 100, 1000]\n    total_coins = 0\n\n    for coin in coins:\n        if coin <= n:\n            count = n // coin\n            total_coins += count\n            n -= count * coin\n\n    return str(total_coins)",
        "test": "",
        "num_ids": 93,
        "indeed": false
    },
    {
        "number": 2743,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(h)]\n\n    def find_center_of_gravity(x: int, y: int) -> tuple:\n        total_weight = 0\n        weight_sum = 0\n        for i in range(y, h):\n            for j in range(x, w):\n                if grid[i][j] != '.':\n                    total_weight += 1\n                    weight_sum += j\n        return (weight_sum // total_weight, y + total_weight // 2)\n\n    def find_leftmost_and_rightmost(x: int, y: int) -> tuple:\n        leftmost = w\n        rightmost = 0\n        for i in range(y, h):\n            for j in range(x, w):\n                if grid[i][j] != '.':\n                    leftmost = min(leftmost, j)\n                    rightmost = max(rightmost, j)\n        return (leftmost, rightmost)\n\n    def is_balanced(x: int, y: int) -> bool:\n        cx, cy = find_center_of_gravity(x, y)\n        leftmost, rightmost = find_leftmost_and_rightmost(x, y)\n        return leftmost <= cx <= rightmost\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] != '.':\n                if not is_balanced(j, i):\n                    if j < find_center_of_gravity(j, i)[0]:\n                        return \"left\"\n                    else:\n                        return \"right\"\n    return \"balanced\"",
        "test": "",
        "num_ids": 420,
        "indeed": false
    },
    {
        "number": 2744,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    routes = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    concert_prices = list(map(int, stdin.readline().split()))\n\n    # Initialize the distance matrix with infinite distances\n    distance = [[float('inf')] * n for _ in range(n)]\n\n    # Fill the distance matrix with train routes\n    for v, u, w in routes:\n        distance[v - 1][u - 1] = w\n        distance[u - 1][v - 1] = w\n\n    # Calculate the Floyd-Warshall algorithm to find the minimum distance between any two cities\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    # Calculate the minimum cost for each city\n    min_cost = [min(distance[i][j] + concert_prices[j] for j in range(n)) for i in range(n)]\n\n    # Return the result as a string\n    return ' '.join(map(str, min_cost))",
        "test": "",
        "num_ids": 306,
        "indeed": false
    },
    {
        "number": 2745,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, words = stdin.split(\"\\n\")\n    words = words.split()\n    word_length = len(words[0])\n    possible_indices = [i for i in range(len(s) - word_length * len(words) + 1)]\n    for i in possible_indices:\n        if s[i:i + word_length] not in words:\n            possible_indices.remove(i)\n            continue\n        for j in range(len(words) - 1):\n            if s[i + j * word_length + word_length:i + j * word_length + 2 * word_length] not in words:\n                possible_indices.remove(i)\n                break\n    return possible_indices",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2746,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    version1, version2 = stdin.split()\n    version1 = version1.split('.')\n    version2 = version2.split('.')\n\n    for i in range(max(len(version1), len(version2))):\n        v1 = int(version1[i]) if i < len(version1) else 0\n        v2 = int(version2[i]) if i < len(version2) else 0\n\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n\n    return 0",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 2747,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums, target = map(int, stdin.split())\n    nums = list(map(int, input().split()))\n\n    def binary_search_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left if nums[left] == target else -1\n\n    def binary_search_right(nums, target):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        return left if nums[left] == target else -1\n\n    left_index = binary_search_left(nums, target)\n    if left_index == -1:\n        return \"-1, -1\"\n\n    right_index = binary_search_right(nums[left_index:], target)\n    return f\"{left_index}, {right_index + left_index}\"",
        "test": "",
        "num_ids": 302,
        "indeed": false
    },
    {
        "number": 2748,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    keypad = {\n        '2': ['a', 'b', 'c'],\n        '3': ['d', 'e', 'f'],\n        '4': ['g', 'h', 'i'],\n        '5': ['j', 'k', 'l'],\n        '6': ['m', 'n', 'o'],\n        '7': ['p', 'q', 'r', 's'],\n        '8': ['t', 'u', 'v'],\n        '9': ['w', 'x', 'y', 'z']\n    }\n\n    def backtrack(combination, next_digits):\n        if len(next_digits) == 0:\n            result.append(combination)\n        else:\n            for letter in keypad[next_digits[0]]:\n                backtrack(combination + letter, next_digits[1:])\n\n    result = []\n    backtrack(\"\", stdin)\n    return result",
        "test": "",
        "num_ids": 226,
        "indeed": false
    },
    {
        "number": 2749,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, N, a = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n\n    grid = [[0] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if a[0] > 0:\n                grid[i][j] = N\n                a[0] -= 1\n            elif a[1] > 0:\n                grid[i][j] = N - 1\n                a[1] -= 1\n            else:\n                grid[i][j] = N - 2\n\n    return '\\n'.join([' '.join(map(str, row)) for row in grid])",
        "test": "",
        "num_ids": 184,
        "indeed": false
    },
    {
        "number": 2750,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    A.sort()\n\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            if (j - i) % 2 == 1 and A[(i + j) // 2] == B:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 2751,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def max_score(sequence):\n        max_score = 1\n        for i in range(len(sequence)):\n            for j in range(i + 1, len(sequence)):\n                for x in range(2, min(sequence[i], sequence[j]) + 1):\n                    if sequence[i] % x == 0 and gcd(sequence[i], sequence[j]) == 1:\n                        new_sequence = sequence.copy()\n                        new_sequence[i] //= x\n                        new_sequence[j] *= x\n                        new_score = gcd(*new_sequence)\n                        if new_score > max_score:\n                            max_score = new_score\n        return max_score\n\n    def min_operations(sequence):\n        min_operations = 0\n        while len(sequence) > 1:\n            for i in range(len(sequence)):\n                for j in range(i + 1, len(sequence)):\n                    for x in range(2, min(sequence[i], sequence[j]) + 1):\n                        if sequence[i] % x == 0 and gcd(sequence[i], sequence[j]) == 1:\n                            new_sequence = sequence.copy()\n                            new_sequence[i] //= x\n                            new_sequence[j] *= x\n                            if gcd(*new_sequence) == gcd(*sequence):\n                                sequence = new_sequence\n                                min_operations += 1\n                                break\n                else:\n                    continue\n                break\n        return min_operations\n\n    N = int(stdin.readline().strip())\n    sequence = list(map(int, stdin.readline().strip().split()))\n\n    max_score = max_score(sequence)\n    min_operations = min_operations(sequence)\n\n    return f\"{max_score} {min_operations}\" ",
        "test": "",
        "num_ids": 513,
        "indeed": false
    },
    {
        "number": 2752,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = []\n    b = []\n    w = []\n\n    for _ in range(n):\n        a_i, b_i = map(int, stdin.readline().split())\n        a.append(a_i)\n        b.append(b_i)\n\n    for _ in range(n):\n        w_i = stdin.readline().strip()\n        w.append(w_i)\n\n    happiness_loss = 0\n\n    for i in range(n):\n        if w[i][0] == \"R\":\n            happiness_loss += 1\n        if w[i][1] == \"R\":\n            happiness_loss += 1\n        if w[i][2] == \"R\":\n            happiness_loss += 1\n\n    return str(happiness_loss)",
        "test": "",
        "num_ids": 214,
        "indeed": false
    },
    {
        "number": 2753,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def next_flash(time, interval):\n        hours, minutes = map(int, time.split(':'))\n        minutes += int(interval[-2:])\n        hours += minutes // 60 + int(interval[:2])\n        minutes %= 60\n        hours %= 24\n        return f\"{hours:02d}:{minutes:02d}\"\n\n    def find_same_minute_flash(first_time, second_time, first_interval, second_interval):\n        days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        first_hours, first_minutes = map(int, first_time.split(':'))\n        second_hours, second_minutes = map(int, second_time.split(':'))\n        first_interval_hours, first_interval_minutes = map(int, first_interval.split(':'))\n        second_interval_hours, second_interval_minutes = map(int, second_interval.split(':'))\n\n        while True:\n            if first_hours == second_hours and first_minutes == second_minutes:\n                return days[first_hours // 24 % 7], f\"{first_hours:02d}:{first_minutes:02d}\"\n\n            first_minutes += first_interval_minutes\n            first_hours += first_minutes // 60 + first_interval_hours\n            first_minutes %= 60\n            first_hours %= 24\n\n            second_minutes += second_interval_minutes\n            second_hours += second_minutes // 60 + second_interval_hours\n            second_minutes %= 60\n            second_hours %= 24\n\n        return \"Never\"\n\n    first_star_time, second_star_time, first_star_interval, second_star_interval = stdin.strip().split('\\n')\n    result = find_same_minute_flash(first_star_time, second_star_time, first_star_interval, second_star_interval)\n    return '\\n'.join(result) if result != \"Never\" else \"Never\"",
        "test": "",
        "num_ids": 551,
        "indeed": false
    },
    {
        "number": 2754,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y_low, y_high = map(int, stdin.split())\n    f = lambda x: 10 * (x ** 0.5)\n\n    def curved_score(x: int, k: int) -> int:\n        for _ in range(k):\n            x = f(x)\n        return int(x)\n\n    k_min = 0\n    while curved_score(x, k_min) < y_low:\n        k_min += 1\n\n    if curved_score(x, k_min) > y_high:\n        return \"impossible\"\n\n    k_max = 0\n    curved_score_prev = x\n    while curved_score(x, k_max + 1) <= y_high:\n        curved_score_next = curved_score(x, k_max + 1)\n        if curved_score_next != curved_score_prev:\n            k_max += 1\n        curved_score_prev = curved_score_next\n\n    if curved_score(x, k_max) > y_high:\n        k_max -= 1\n\n    return f\"{k_min} {k_max if k_max != 99 else 'inf'}\"",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 2755,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paths = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def dfs(tree, visited, graph):\n        visited.add(tree)\n        for neighbor in graph[tree]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, graph)\n\n    graph = [set() for _ in range(n)]\n    for u, v in paths:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    visited = set()\n    hives = []\n    for tree in range(n):\n        if tree not in visited:\n            hives.append(tree)\n            dfs(tree, visited, graph)\n\n    for u, v in paths:\n        if u in visited and v in visited:\n            continue\n        if u in visited:\n            hives.remove(u)\n        if v in visited:\n            hives.remove(v)\n\n    if not hives:\n        return \"impossible\"\n    return str(len(hives))",
        "test": "",
        "num_ids": 271,
        "indeed": false
    },
    {
        "number": 2756,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, n, m, e, dungeon, visited, creeper_x, creeper_y):\n        if 0 <= x < n and 0 <= y < m and dungeon[x][y] != 'X' and not visited[x][y]:\n            distance_x = abs(x - creeper_x)\n            distance_y = abs(y - creeper_y)\n            if distance_x <= e and distance_y <= e:\n                return False\n            return True\n        return False\n\n    def find_exit(x, y, n, m, dungeon, visited, creeper_x, creeper_y):\n        if dungeon[x][y] == 'E':\n            return True\n        visited[x][y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y, n, m, e, dungeon, visited, creeper_x, creeper_y):\n                if find_exit(new_x, new_y, n, m, dungeon, visited, creeper_x, creeper_y):\n                    return True\n        return False\n\n    def find_creeper(dungeon):\n        for i in range(len(dungeon)):\n            for j in range(len(dungeon[0])):\n                if dungeon[i][j] == 'C':\n                    return i, j\n\n    n, m, e = map(int, stdin.readline().split())\n    dungeon = [list(stdin.readline().strip()) for _ in range(n)]\n\n    player_x, player_y = -1, -1\n    for i in range(len(dungeon)):\n        for j in range(len(dungeon[0])):\n            if dungeon[i][j] == 'P':\n                player_x, player_y = i, j\n                break\n\n    creeper_x, creeper_y = find_creeper(dungeon)\n\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    if find_exit(player_x, player_y, n, m, dungeon, visited, creeper_x, creeper_y):\n        return \"you're toast\"\n    else:\n        return \"119\"",
        "test": "",
        "num_ids": 611,
        "indeed": false
    },
    {
        "number": 2757,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    function = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_vertices(n, function):\n        if n == 1:\n            return 1\n        mid = 2 ** (n - 1)\n        true_vertices = count_vertices(n - 1, [function[i] for i in range(mid)])\n        false_vertices = count_vertices(n - 1, [function[i] for i in range(mid, 2 ** n)])\n        return true_vertices + false_vertices + 1\n\n    return str(count_vertices(n, function))",
        "test": "",
        "num_ids": 171,
        "indeed": false
    },
    {
        "number": 2758,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_probabilities(color1, color2):\n        probabilities = {}\n        for c1 in color1:\n            for c2 in color2:\n                for offspring_color in get_offspring_colors(c1, c2):\n                    if offspring_color in probabilities:\n                        probabilities[offspring_color] += 1\n                    else:\n                        probabilities[offspring_color] = 1\n\n        for offspring_color in probabilities:\n            probabilities[offspring_color] /= 4\n\n        return probabilities\n\n    def get_offspring_colors(color1, color2):\n        offspring_colors = []\n        for c1 in color1:\n            for c2 in color2:\n                offspring_colors.append(get_offspring_color(c1, c2))\n\n        return offspring_colors\n\n    def get_offspring_color(color1, color2):\n        black_gene1, red_gene1, dilution_gene1 = color1\n        black_gene2, red_gene2, dilution_gene2 = color2\n\n        black_offspring_gene = get_offspring_gene(black_gene1, black_gene2)\n        red_offspring_gene = get_offspring_gene(red_gene1, red_gene2)\n        dilution_offspring_gene = get_offspring_gene(dilution_gene1, dilution_gene2)\n\n        if red_offspring_gene == 'O':\n            return f\"{dilution_offspring_gene}-{red_offspring_gene}\"\n        elif red_offspring_gene == 'o':\n            return f\"{black_offspring_gene}{dilution_offspring_gene}-{red_offspring_gene}\"\n        else:\n            return f\"{black_offspring_gene}{dilution_offspring_gene}\"\n\n    def get_offspring_gene(gene1, gene2):\n        if gene1 == gene2:\n            return gene1\n        elif gene1 == gene2.lower():\n            return gene1.lower()\n        else:\n            return gene1 if random.random() < 0.5 else gene2\n\n    def parse_color(color):\n        if '-' in color:\n            return color.split('-')\n        else:\n            return color[0], color[1], '-'\n\n    def format_output(probabilities):\n        sorted_probabilities = sorted(probabilities.items(), key=lambda x: (-x[1], x[0]))\n        return '\\n'.join([f\"{color} {probability:.9f}\" for color, probability in sorted_probabilities])\n\n    color1, color2 = stdin.strip().split('\\n')\n    color1 = parse_color(color1)\n    color2 = parse_color(color2)\n\n    probabilities = get_probabilities(color1, color2)\n    output = format_output(probabilities)\n\n    return output",
        "test": "",
        "num_ids": 746,
        "indeed": false
    },
    {
        "number": 2759,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board, row, col, n):\n        for i in range(n):\n            if board[row][i] or board[i][col]:\n                return False\n        return True\n\n    def place_tanks(board, tanks, n):\n        if not tanks:\n            return 0\n\n        row, col = tanks[0]\n        for i in range(n):\n            if is_valid(board, row, i, n) and is_valid(board, i, col, n):\n                board[row][i] = board[i][col] = True\n                result = place_tanks(board, tanks[1:], n)\n                if result != -1:\n                    return result + 1\n                board[row][i] = board[i][col] = False\n        return -1\n\n    def find_moves(board, tanks, n):\n        moves = []\n        for i, tank in enumerate(tanks):\n            row, col = tank\n            for j in range(n):\n                if not board[row][j] and not board[j][col]:\n                    moves.append((i + 1, 'R'))\n                    tanks[i] = (j, col)\n                    break\n            for j in range(n):\n                if not board[col][j] and not board[row][j]:\n                    moves.append((i + 1, 'D'))\n                    tanks[i] = (row, j)\n                    break\n        return moves\n\n    n = int(stdin.readline().strip())\n    tanks = []\n    for _ in range(n):\n        row, col = map(int, stdin.readline().strip().split())\n        tanks.append((row - 1, col - 1))\n\n    board = [[False] * n for _ in range(n)]\n    result = place_tanks(board, tanks, n)\n    moves = find_moves(board, tanks, n)\n\n    return f\"{result}\\n\" + \"\\n\".join(f\"{i} {d}\" for i, d in moves)",
        "test": "",
        "num_ids": 512,
        "indeed": false
    },
    {
        "number": 2760,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n    swaps = []\n    for i in range(1, n + 1):\n        j = arr.index(i)\n        k = i - 1\n        count = 0\n        while k != j:\n            arr[k], arr[k + 1] = arr[k + 1], arr[k]\n            count += 1\n            k += 1\n        swaps.append(count)\n    return '\\n'.join(map(str, swaps))",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 2761,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def slope(x1, y1, x2, y2):\n        return (y2 - y1) / (x2 - x1)\n\n    def perimeter(a, b, c):\n        return a + b + c\n\n    def is_valid_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    lines = []\n    n = int(stdin.readline().strip())\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        lines.append((x1, y1, x2, y2))\n\n    max_perimeter = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                x1, y1, x2, y2 = lines[i]\n                x3, y3, x4, y4 = lines[j]\n                x5, y5, x6, y6 = lines[k]\n\n                if (x1, y1) == (x2, y2) or (x3, y3) == (x4, y4) or (x5, y5) == (x6, y6):\n                    continue\n\n                if (x1 == x2 == x3 == x4) or (y1 == y2 == y3 == y4) or (x5 == x6 == x1 == x2) or (y5 == y6 == y1 == y2):\n                    continue\n\n                if slope(x1, y1, x2, y2) == slope(x3, y3, x4, y4) or slope(x1, y1, x2, y2) == slope(x5, y5, x6, y6) or slope(x3, y3, x4, y4) == slope(x5, y5, x6, y6):\n                    continue\n\n                a = distance(x1, y1, x2, y2)\n                b = distance(x3, y3, x4, y4)\n                c = distance(x5, y5, x6, y6)\n\n                if is_valid_triangle(a, b, c):\n                    max_perimeter = max(max_perimeter, perimeter(a, b, c))\n\n    if max_perimeter == 0:\n        return \"no triangle\"\n    else:\n        return round(max_perimeter, 5) ",
        "test": "",
        "num_ids": 664,
        "indeed": false
    },
    {
        "number": 2762,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, G, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def min_cost(i, j):\n        return min(sum(abs(a[s] - v) ** k for s in range(i, j + 1)) for v in range(min(a[i:j+1]), max(a[i:j+1])+1))\n\n    total_cost = sum(min_cost(i, j) for i in range(1, N, G) for j in range(i + G - 1, N, G))\n\n    return str(total_cost)",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 2763,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    grille = []\n    for _ in range(n):\n        grille.append(stdin.readline().strip())\n    encrypted_message = stdin.readline().strip()\n\n    def is_valid_grille(grille: List[str]) -> bool:\n        for row in grille:\n            if row.count('.') != n:\n                return False\n        return True\n\n    def decrypt_message(grille: List[str], encrypted_message: str) -> str:\n        decrypted_message = ''\n        for _ in range(4):\n            for i in range(n):\n                for j in range(n):\n                    if grille[i][j] == '.':\n                        decrypted_message += encrypted_message[i * n + j]\n            encrypted_message = rotate_90(encrypted_message, n)\n        return decrypted_message\n\n    def rotate_90(s: str, n: int) -> str:\n        rotated_s = ''\n        for i in range(n):\n            rotated_s += s[i * n + n - 1:i * n - 1:-1]\n        return rotated_s\n\n    if is_valid_grille(grille):\n        return decrypt_message(grille, encrypted_message)\n    else:\n        return 'invalid grille'",
        "test": "",
        "num_ids": 336,
        "indeed": false
    },
    {
        "number": 2764,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')[:-1]]\n    program = stdin.split('\\n')[-1]\n    row, col = 7, 0\n    direction = '>'\n\n    def move_forward():\n        nonlocal row, col\n        if direction == '>':\n            col += 1\n        elif direction == '<':\n            col -= 1\n        elif direction == '^':\n            row -= 1\n        elif direction == 'v':\n            row += 1\n\n    def execute_program(program):\n        for instruction in program:\n            if instruction == 'F':\n                move_forward()\n            elif instruction == 'R':\n                if direction == '>':\n                    direction = 'v'\n                elif direction == 'v':\n                    direction = '<'\n                elif direction == '<':\n                    direction = '^'\n                elif direction == '^':\n                    direction = '>'\n            elif instruction == 'L':\n                if direction == '>':\n                    direction = '^'\n                elif direction == '^':\n                    direction = '<'\n                elif direction == '<':\n                    direction = 'v'\n                elif direction == 'v':\n                    direction = '>'\n            elif instruction == 'X':\n                if board[row][col] == 'I':\n                    board[row][col] = '.'\n                else:\n                    return False\n        return True\n\n    if execute_program(program):\n        if board[row][col] == 'D':\n            return \"Diamond!\"\n        else:\n            return \"Bug!\"\n    else:\n        return \"Bug!\"",
        "test": "",
        "num_ids": 395,
        "indeed": false
    },
    {
        "number": 2765,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    coins = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    if coins[0] != 1:\n        return \"non-canonical\"\n\n    for i in range(1, n):\n        if coins[i] > coins[0] + coins[i - 1]:\n            return \"non-canonical\"\n\n    return \"canonical\"",
        "test": "",
        "num_ids": 118,
        "indeed": false
    },
    {
        "number": 2766,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(float, stdin.split())\n    n = int(n)\n    k = int(k)\n\n    def binomial(n, k):\n        if 0 <= k <= n:\n            ntok = 1\n            ktok = 1\n            for t in range(1, min(k, n - k) + 1):\n                ntok *= n\n                ktok *= t\n                n -= 1\n            return ntok // ktok\n        else:\n            return 0\n\n    def prob_win(n, k, p):\n        total_games = binomial(n, 2)\n        win_games = 0\n\n        for i in range(1, k + 1):\n            for j in range(1, k + 1):\n                win_games += binomial(k, i) * binomial(k, j) * (p ** (i + j)) * ((1 - p) ** (2 * k - i - j))\n\n        return win_games / total_games\n\n    def prob_draw(n, k, p):\n        total_games = binomial(n, 2)\n        draw_games = 0\n\n        for i in range(1, k + 1):\n            for j in range(1, k + 1):\n                draw_games += binomial(k, i) * binomial(k, j) * (p ** (i + j)) * ((1 - p) ** (2 * k - i - j))\n\n        return (total_games - draw_games) / total_games\n\n    return round(prob_draw(n, k, p), 8)",
        "test": "",
        "num_ids": 407,
        "indeed": false
    },
    {
        "number": 2767,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = set()\n    for i in range(n):\n        words.add(stdin.readline().strip())\n\n    count = 0\n    for i in range(1, n):\n        for j in range(i, n):\n            for k in range(j, n):\n                sentence = \"\".join([words.pop(), words.pop(), words.pop()])\n                if len(sentence) == 26 and len(set(sentence)) == 26:\n                    count += 1\n                words.add(sentence[0])\n                words.add(sentence[1])\n                words.add(sentence[2])\n\n    return str(count)",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2768,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    cubes = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    def is_valid(rectangle):\n        return all(cube in rectangle for cube in cubes)\n\n    def generate_rectangles():\n        min_x, min_y = min(cubes, key=lambda x: (x[0], x[1]))\n        max_x, max_y = max(cubes, key=lambda x: (x[0], x[1]))\n        for width in range(max_x - min_x + 1):\n            for height in range(max_y - min_y + 1):\n                rectangle = set((r, c) for r in range(min_x, min_x + width) for c in range(min_y, min_y + height))\n                if is_valid(rectangle):\n                    yield rectangle\n\n    return min(len(cubes) - len(rectangle) for rectangle in generate_rectangles())",
        "test": "",
        "num_ids": 258,
        "indeed": false
    },
    {
        "number": 2769,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    def find_diff(arr1, arr2):\n        i, j = 0, 0\n        result = []\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                i += 1\n            elif arr1[i] > arr2[j]:\n                j += 1\n            else:\n                result.append(abs(arr1[i] - arr2[j]))\n                i += 1\n                j += 1\n        return result\n\n    def find_min_diff(arr1, arr2, target):\n        arr1.sort()\n        arr2.sort()\n        i, j = 0, 0\n        min_diff = float('inf')\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] + arr2[j] <= target:\n                min_diff = min(min_diff, abs(arr1[i] - arr2[j]))\n                i += 1\n                j += 1\n            elif arr1[i] < arr2[j]:\n                i += 1\n            else:\n                j += 1\n        return min_diff\n\n    n, p, q, s = map(int, stdin.split())\n    classical_problems = [int(input()) for _ in range(p)]\n    creative_problems = [int(input()) for _ in range(q)]\n\n    classical_problems.sort()\n    creative_problems.sort()\n\n    min_diff = float('inf')\n    for i in range(p):\n        for j in range(q):\n            if not binary_search(classical_problems, creative_problems[j]) and not binary_search(creative_problems, classical_problems[i]):\n                min_diff = min(min_diff, abs(classical_problems[i] - creative_problems[j]))\n\n    for i in range(p):\n        for j in range(q):\n            if not binary_search(classical_problems, creative_problems[j]) and not binary_search(creative_problems, classical_problems[i]):\n                min_diff = min(min_diff, abs(classical_problems[i] - creative_problems[j]))\n                classical_problems[i], creative_problems[j] = creative_problems[j], classical_problems[i]\n                min_diff = min(min_diff, find_min_diff(classical_problems, creative_problems, s))\n                classical_problems[i], creative_problems[j] = creative_problems[j], classical_problems[i]\n\n    return min_diff if min_diff != float('inf') else -1",
        "test": "",
        "num_ids": 773,
        "indeed": false
    },
    {
        "number": 2770,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def matrix_mult(a, b):\n        result = [[0] * len(b[0]) for _ in range(len(a))]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_pow(matrix, n):\n        if n == 1:\n            return matrix\n        if n % 2 == 0:\n            half_pow = matrix_pow(matrix, n // 2)\n            return matrix_mult(half_pow, half_pow)\n        else:\n            return matrix_mult(matrix, matrix_pow(matrix, n - 1))\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    a = [int(x) for x in lines[1].split()]\n    x = [int(x) for x in lines[2].split()]\n    Q = int(lines[3])\n    queries = [tuple(map(int, lines[i + 4].split())) for i in range(Q)]\n\n    T_max = max(T for T, M in queries)\n    M_max = max(M for T, M in queries)\n\n    # Build the matrix\n    matrix = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i == j:\n                matrix[i][j] = 1\n            elif i > j:\n                matrix[i][j] = a[i - j - 1]\n\n    # Calculate the powers of the matrix\n    matrix_powers = [matrix]\n    for i in range(1, T_max + 1):\n        matrix_powers.append(matrix_mult(matrix_powers[-1], matrix_powers[-1]))\n\n    # Calculate the initial values\n    initial_values = [0] * (N + 1)\n    for i in range(N + 1):\n        initial_values[i] = x[i - 1] if i - 1 < len(x) else 0\n\n    # Calculate the result\n    result = []\n    for T, M in queries:\n        if T == 0:\n            result.append(0)\n            continue\n        matrix_power = matrix_powers[T - 1]\n        res = [0] * (N + 1)\n        for i in range(N + 1):\n            for j in range(N + 1):\n                res[i] += matrix_power[i][j] * initial_values[j]\n        result.append(res[N] % M)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 692,
        "indeed": false
    },
    {
        "number": 2771,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, directions = map(str, stdin.split())\n    n = int(n)\n    path = []\n    visited = [False] * (n + 1)\n\n    def dfs(house: int, direction: str) -> None:\n        if visited[house]:\n            return\n        visited[house] = True\n        path.append(house)\n        if direction == 'L':\n            dfs(house - 1, 'R')\n        else:\n            dfs(house + 1, 'L')\n\n    dfs(1, 'L')\n    if n % 2 == 0:\n        for i in range(1, n // 2 + 1):\n            if directions[i - 1] == 'L':\n                dfs(i, 'L')\n            else:\n                dfs(2 * n - i, 'R')\n    else:\n        for i in range(1, (n + 1) // 2):\n            if directions[i - 1] == 'L':\n                dfs(i, 'L')\n            else:\n                dfs(2 * n - i, 'R')\n\n    return ' '.join(map(str, path[1:]))",
        "test": "",
        "num_ids": 288,
        "indeed": false
    },
    {
        "number": 2772,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(int, stdin.readline().split())\n    ascent_data = [list(map(int, stdin.readline().split())) for _ in range(a)]\n    descent_data = [list(map(int, stdin.readline().split())) for _ in range(d)]\n\n    ascent_time = sum(t for _, t in ascent_data)\n    ascent_elevation = sum(h for h, t in ascent_data)\n\n    descent_time = sum(t for _, t in descent_data)\n    descent_elevation = sum(h for h, t in descent_data)\n\n    ascent_speed = ascent_elevation / ascent_time\n    descent_speed = descent_elevation / descent_time\n\n    total_time = ascent_time + descent_time\n    total_elevation = abs(ascent_elevation) + abs(descent_elevation)\n\n    common_speed = total_elevation / total_time\n\n    if ascent_speed > descent_speed:\n        time_diff = (ascent_elevation / ascent_speed - descent_elevation / descent_speed) / (common_speed - ascent_speed)\n    else:\n        time_diff = (descent_elevation / descent_speed - ascent_elevation / ascent_speed) / (common_speed - descent_speed)\n\n    return f\"{time_diff:.6f}\"",
        "test": "",
        "num_ids": 360,
        "indeed": false
    },
    {
        "number": 2773,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = []\n        visited = [False] * n\n        weights = [float('inf')] * n\n        weights[start] = 0\n        queue.append((0, start))\n\n        while queue:\n            (weight, node) = heapq.heappop(queue)\n            if node == end:\n                return weight\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, distance in graph[node].items():\n                    new_weight = weight + distance\n                    if new_weight < weights[neighbor]:\n                        weights[neighbor] = new_weight\n                        heapq.heappush(queue, (new_weight, neighbor))\n        return -1\n\n    def find_shortest_path(graph, start, end):\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        return path\n\n    def is_valid_path(path):\n        for i in range(len(path) - 1):\n            if path[i] not in graph[path[i + 1]]:\n                return False\n        return True\n\n    n, m = map(int, stdin.readline().strip().split())\n    graph = {i: {} for i in range(n)}\n\n    for _ in range(m):\n        a, b, d = map(int, stdin.readline().strip().split())\n        graph[a][b] = d\n        graph[b][a] = d\n\n    shortest_path = dijkstra(graph, 0, 1)\n    if shortest_path == float('inf'):\n        return \"impossible\"\n\n    parent = {i: -1 for i in range(n)}\n    path = find_shortest_path(graph, 0, 1)\n\n    for i in range(len(path) - 1):\n        parent[path[i + 1]] = path[i]\n\n    valid_path = find_shortest_path(graph, 0, 1)\n    if is_valid_path(valid_path):\n        return \" \".join(map(str, valid_path))\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 561,
        "indeed": false
    },
    {
        "number": 2774,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    N, S, *trails = map(int, stdin.split())\n    lamps = trails.pop()\n    trails = [trails[i:i + 3] for i in range(0, len(trails), 3)]\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n\n    for a, b, d in trails:\n        union(parent, rank, a, b)\n\n    lamps_needed = 0\n    for i in range(2, N + 1):\n        if find(parent, i) == find(parent, 1):\n            lamps_needed += 1\n\n    return str(lamps_needed - lamps)",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 2775,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_on_route(x_h, y_h, x_w, y_w, x_i, y_i):\n        return distance(x_h, y_h, x_i, y_i) + distance(x_i, y_i, x_w, y_w) <= distance(x_h, y_h, x_w, y_w)\n\n    n, x_h, y_h, x_w, y_w = map(int, stdin.split()[0:5])\n    errands = [list(map(int, line.split())) for line in stdin.split()[5:]]\n\n    count = 0\n    for errand in errands:\n        if is_on_route(x_h, y_h, x_w, y_w, errand[0], errand[1]):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 2776,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    restrictions = [set() for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        restrictions[a - 1].add(b - 1)\n        restrictions[b - 1].add(a - 1)\n\n    def count_pizzas(ingredients: set, index: int) -> int:\n        if index == N:\n            return 1\n        if index in ingredients:\n            return count_pizzas(ingredients, index + 1)\n        total = 0\n        for i in range(N):\n            if i not in restrictions[index]:\n                total += count_pizzas(ingredients | {i}, index + 1)\n        return total\n\n    return str(count_pizzas(set(), 0))",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2777,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_xors(x: int, y: int) -> int:\n        return bin(x ^ y).count('1')\n\n    def find_max_xor_index(x: List[int], y: int) -> int:\n        max_xor_index = -1\n        max_xor = -1\n        for i, x_i in enumerate(x):\n            xor = count_xors(x_i, y)\n            if xor > max_xor:\n                max_xor = xor\n                max_xor_index = i\n        return max_xor_index\n\n    def count_sequences(m: int, n: int, p: List[int]) -> int:\n        mod = 10**9 + 7\n        sequences = set()\n        x = [i for i in range(n)]\n\n        for y in range(1, 2**m):\n            p_y = find_max_xor_index(x, y)\n            x[p_y], x[p[p_y]] = x[p[p_y]], x[p_y]\n            sequences.add(tuple(x))\n            x[p_y], x[p[p_y]] = x[p[p_y]], x[p_y]\n\n        return len(sequences) % mod\n\n    lines = stdin.split('\\n')\n    m, n = map(int, lines[0].split())\n    p = list(map(int, lines[1:]))\n\n    result = count_sequences(m, n, p)\n    return str(result)",
        "test": "",
        "num_ids": 387,
        "indeed": false
    },
    {
        "number": 2778,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, T = map(int, stdin.split())\n    mod = 1000000009\n    total_ways = 1\n    for i in range(N):\n        total_ways *= K\n        total_ways %= mod\n    sum_ways = 0\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if i * j == T:\n                sum_ways += 1\n    return str(sum_ways)",
        "test": "",
        "num_ids": 128,
        "indeed": false
    },
    {
        "number": 2779,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and (x, y) != (1, 1) and (x, y) not in barricades\n\n    def bfs():\n        queue = [(1, 1, 0)]\n        visited = set()\n\n        while queue:\n            x, y, cost = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if not is_valid(x, y):\n                return cost\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny, cost + c_costs[grid[nx][ny]]))\n\n        return -1\n\n    n, m, c, grid, c_costs = map(int, stdin.split())\n    grid = [list(input()) for _ in range(m)]\n    c_costs = list(map(int, input().split()))\n\n    barricades = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 'B' and grid[i][j] != '.':\n                barricades.add((i, j))\n\n    return str(bfs())",
        "test": "",
        "num_ids": 358,
        "indeed": false
    },
    {
        "number": 2780,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    def prob(n, m):\n        if n == 1:\n            return 1 / m\n        else:\n            p = 1 / m\n            for i in range(1, n):\n                p *= (m - i) / m\n            return p\n\n    result = []\n    for i in range(1, M + 1):\n        result.append(prob(N, i))\n\n    return \"\\n\".join(f\"{r:.5f}\" for r in result)",
        "test": "",
        "num_ids": 135,
        "indeed": false
    },
    {
        "number": 2781,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(grid, i, j, depth, visited):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j]:\n            return depth\n        visited[i][j] = True\n        depth = max(depth, grid[i][j])\n        for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(grid, i + x, j + y, depth, visited)\n        return depth\n\n    r, c = map(int, stdin.readline().split())\n    grid = [list(map(int, stdin.readline().split())) for _ in range(r)]\n    visited = [[False] * c for _ in range(r)]\n    max_depth = float('-inf')\n    for i in range(r):\n        max_depth = max(max_depth, dfs(grid, i, 0, 0, visited))\n    for i in range(r):\n        max_depth = max(max_depth, dfs(grid, i, c - 1, 0, visited))\n    return str(max_depth)",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2782,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, c = map(int, stdin.readline().split())\n    passengers = []\n    for _ in range(n):\n        a, b, s = map(int, stdin.readline().split())\n        passengers.append((a, b, s))\n\n    passengers.sort(key=lambda x: x[2], reverse=True)\n\n    assigned = set()\n    count = 0\n\n    for passenger in passengers:\n        a, b, s = passenger\n        if (a, b) not in assigned:\n            assigned.add((a, b))\n            count += 1\n            for i in range(1, s + 1):\n                assigned.add((a + i, b))\n                assigned.add((a - i, b))\n                assigned.add((a, b + i))\n                assigned.add((a, b - i))\n\n    return str(count)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2783,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_sweat(shady_spots, dorm, class_loc):\n        n = len(shady_spots)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = min(dp[i][k] + dp[k][j] + distance(shady_spots[i], shady_spots[j]) for k in range(i + 1, j))\n\n        return dp[0][n] + distance(dorm, shady_spots[0]) + distance(class_loc, shady_spots[n - 1])\n\n    def find_path(shady_spots, dorm, class_loc):\n        n = len(shady_spots)\n        path = [0] * (n + 1)\n\n        def dfs(i, j):\n            if i == j:\n                return []\n\n            min_sweat = float('inf')\n            min_path = []\n\n            for k in range(i + 1, j):\n                sweat = dp[i][k] + dp[k][j] + distance(shady_spots[i], shady_spots[j])\n\n                if sweat < min_sweat:\n                    min_sweat = sweat\n                    min_path = dfs(i, k) + [k] + dfs(k, j)\n\n            return min_path\n\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = min(dp[i][k] + dp[k][j] + distance(shady_spots[i], shady_spots[j]) for k in range(i + 1, j))\n\n        path[0] = -1\n        path[-1] = n\n        path[1:-1] = dfs(0, n)\n\n        return path\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    shady_spots = [tuple(map(int, stdin[i + 1].split())) for i in range(n)]\n    dorm = tuple(map(int, stdin[n + 1].split()))\n    class_loc = tuple(map(int, stdin[n + 2].split()))\n\n    min_sweat = min_sweat(shady_spots, dorm, class_loc)\n    path = find_path(shady_spots, dorm, class_loc)\n\n    if min_sweat == 0:\n        return '-'\n    else:\n        return ' '.join(map(str, path))",
        "test": "",
        "num_ids": 773,
        "indeed": false
    },
    {
        "number": 2784,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_route(start, end, graph):\n        visited = set()\n        stack = [(start, [start])]\n\n        while stack:\n            (node, path) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                if node == end:\n                    return path\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        stack.append((neighbor, path + [neighbor]))\n        return None\n\n    def build_graph(fragments):\n        graph = {}\n        for fragment in fragments:\n            station, connections = fragment.split(\" \", 1)\n            graph[station] = connections.split()\n        return graph\n\n    lines = stdin.split(\"\\n\")\n    num_fragments = int(lines[0])\n    fragments = lines[1:num_fragments + 1]\n    start, end = lines[num_fragments + 1].split()\n\n    graph = build_graph(fragments)\n    route = find_route(start, end, graph)\n\n    if route:\n        return \" \".join(route)\n    else:\n        return \"no route found\"",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 2785,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_days(n: int, M: int, profits: List[int], costs: List[int]) -> int:\n        min_days = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                total_profit = sum(profits[k] for k in range(i, j + 1))\n                total_cost = sum(costs[k] for k in range(i, j + 1))\n                if total_profit >= M:\n                    min_days = min(min_days, total_cost // M)\n        return min_days\n\n    lines = stdin.split('\\n')\n    n, M = map(int, lines[0].split())\n    profits = [0] * n\n    costs = [0] * n\n    for i in range(n):\n        profits[i], costs[i] = map(int, lines[i + 1].split())\n\n    return str(find_min_days(n, M, profits, costs))",
        "test": "",
        "num_ids": 252,
        "indeed": false
    },
    {
        "number": 2786,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            elif c == ')' or c == ']' or c == '}':\n                if not stack:\n                    return False\n                if c == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif c == ']' and stack[-1] == '[':\n                    stack.pop()\n                elif c == '}' and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        return not stack\n\n    def count_valid_sequences(s: str, index: int, count: int) -> int:\n        if index == len(s):\n            if is_valid(s):\n                return count + 1\n            else:\n                return count\n\n        if s[index] == '?':\n            s = s[:index] + '(' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n            s = s[:index] + '[' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n            s = s[:index] + '{' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n            s = s[:index] + ')' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n            s = s[:index] + ']' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n            s = s[:index] + '}' + s[index + 1:]\n            count = count_valid_sequences(s, index + 1, count)\n        else:\n            count = count_valid_sequences(s, index + 1, count)\n\n        return count\n\n    result = count_valid_sequences(s, 0, 0)\n    return str(result % 100000)[-5:]",
        "test": "",
        "num_ids": 565,
        "indeed": false
    },
    {
        "number": 2787,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(lat1, lon1, lat2, lon2):\n        R = 6381\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat, dlon = lat2 - lat1, lon2 - lon1\n        a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2\n        return 2 * R * asin(sqrt(a))\n\n    def find_min_shame(start, target, airports, connections):\n        min_shame = float('inf')\n        visited = set()\n        queue = [(start, 0)]\n\n        while queue:\n            curr, shame = queue.pop(0)\n            if curr == target:\n                return min_shame\n            if curr in visited:\n                continue\n            visited.add(curr)\n            for conn in connections[curr]:\n                if conn not in visited:\n                    new_shame = shame + distance(airports[curr][0], airports[curr][1], airports[conn][0], airports[conn][1]) + 100\n                    if new_shame < min_shame:\n                        min_shame = new_shame\n                    queue.append((conn, new_shame))\n        return -1\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    start, target = lines[1].split()\n    airports = {}\n    connections = {}\n\n    for i in range(2, N + 2):\n        airport, lat, lon = lines[i].split()\n        airports[airport] = (float(lat), float(lon))\n        connections[airport] = set()\n\n    for i in range(N + 2, N + 2 + M):\n        a, b = lines[i].split()\n        connections[a].add(b)\n        connections[b].add(a)\n\n    return str(find_min_shame(start, target, airports, connections))",
        "test": "",
        "num_ids": 519,
        "indeed": false
    },
    {
        "number": 2788,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k, x, a, b = map(int, stdin.split())\n    s = sorted(s, reverse=True)\n    total_students = sum(s)\n    max_students = min(total_students, b)\n\n    for i in range(n):\n        if s[i] > max_students:\n            continue\n        else:\n            max_students -= s[i]\n\n        if max_students < a:\n            return \"impossible\"\n\n    return max_students",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 2789,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 2:\n        return \"1\"\n    elif n == 3:\n        return \"1\"\n    elif n == 4:\n        return \"1\"\n    elif n == 5:\n        return \"2\"\n    elif n == 6:\n        return \"2\"\n    elif n == 7:\n        return \"2\"\n    elif n == 8:\n        return \"2\"\n    elif n == 9:\n        return \"3\"\n    elif n == 10:\n        return \"3\"\n    else:\n        return \"2\"",
        "test": "",
        "num_ids": 149,
        "indeed": false
    },
    {
        "number": 2790,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, k = map(int, stdin.split('\\n')[0].split())\n    k = list(map(int, stdin.split('\\n')[1].split()))\n\n    def time_to_pick_up_all_luggage(position):\n        total_time = 0\n        for i in range(n):\n            time_to_next_luggage = (k[i] - position) % s\n            total_time += time_to_next_luggage + t\n        return total_time\n\n    min_time = min(time_to_pick_up_all_luggage(i) for i in range(s))\n    max_time = max(time_to_pick_up_all_luggage(i) for i in range(s))\n    avg_time = sum(time_to_pick_up_all_luggage(i) for i in range(s)) // s\n\n    return f\"{min_time}\\n{max_time}\\n{avg_time}\"",
        "test": "",
        "num_ids": 250,
        "indeed": false
    },
    {
        "number": 2791,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] // d == a[j] // d:\n                count += 1\n    return str(count)",
        "test": "",
        "num_ids": 99,
        "indeed": true
    },
    {
        "number": 2792,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_alphabet(start: int, end: int, reverse: bool) -> str:\n        if reverse:\n            return 'zyxwvutsrqponmlkjihgfedcba'[start:end]\n        else:\n            return 'abcdefghijklmnopqrstuvwxyz'[start:end]\n\n    def count_occurrences(letters: str, query: str) -> int:\n        return letters.count(query)\n\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    orders = lines[1:]\n\n    letters = ''\n    reverse = False\n    result = []\n\n    for order in orders:\n        if order.startswith('SMJER'):\n            reverse = not reverse\n        elif order.startswith('UPIT'):\n            n, x = int(order[5]), order[7]\n            result.append(count_occurrences(letters[:n], x))\n\n        letters += reverse_alphabet(len(letters) % 26, (len(letters) + 26) % 26, reverse)\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 284,
        "indeed": false
    },
    {
        "number": 2793,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cut(graph, source, sink):\n        residual_graph = [{neighbor: weight for neighbor, weight in neighbors.items() if neighbor != sink} for neighbors in graph]\n        residual_graph[source][sink] = float('inf')\n        flow = 0\n        while True:\n            path = []\n            visited = [False] * len(graph)\n            stack = [source]\n            while stack:\n                current = stack[-1]\n                if current == sink:\n                    break\n                if not visited[current]:\n                    visited[current] = True\n                    for neighbor in residual_graph[current]:\n                        if not visited[neighbor] and residual_graph[current][neighbor] > 0:\n                            stack.append(neighbor)\n                else:\n                    stack.pop()\n                    if not path:\n                        path.append(current)\n                    if current != source:\n                        path.append(current)\n            if not path:\n                break\n            path_flow = min(residual_graph[u][v] for u, v in zip(path, path[1:]))\n            flow += path_flow\n            for u, v in zip(path, path[1:]):\n                residual_graph[u][v] -= path_flow\n                residual_graph[v][u] += path_flow\n        return flow\n\n    def min_cut(graph, source, sink):\n        min_cut_value = find_min_cut(graph, source, sink)\n        residual_graph = [{neighbor: weight for neighbor, weight in neighbors.items() if neighbor != sink} for neighbors in graph]\n        for u in range(len(graph)):\n            for v in list(residual_graph[u]):\n                if residual_graph[u][v] > 0:\n                    del residual_graph[u][v]\n                    if v not in residual_graph[u]:\n                        residual_graph[u][v] = 0\n        min_cut = [i for i, neighbors in enumerate(residual_graph) if source in neighbors or i == source]\n        return min_cut\n\n    lines = stdin.split('\\n')\n    n, m, source, sink = map(int, lines[0].split())\n    graph = [{} for _ in range(n)]\n    for i in range(1, m + 1):\n        u, v, w = map(int, lines[i].split())\n        graph[u][v] = w\n\n    min_cut_vertices = min_cut(graph, source, sink)\n    output = [str(len(min_cut_vertices))] + [str(vertex) for vertex in min_cut_vertices]\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 677,
        "indeed": false
    },
    {
        "number": 2794,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(a, d, h):\n        left, right = 0, 10 ** 9\n        while left < right:\n            mid = (left + right) // 2\n            if a + mid * d <= h:\n                left = mid + 1\n            else:\n                right = mid\n        return left - 1\n\n    h, c = map(int, stdin.readline().split())\n    coworkers = [list(map(int, stdin.readline().split())) for _ in range(c)]\n\n    max_annoyance = 0\n    for a, d in coworkers:\n        max_annoyance = max(max_annoyance, a + binary_search(d, h))\n\n    return str(max_annoyance)",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 2795,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n\n    def distance(a, b):\n        return sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n\n    def connect_treehouses(treehouses, connections, n, e, p):\n        total_length = 0\n        connected = set()\n\n        for i in range(e):\n            connected.add(i)\n\n        while len(connected) < n:\n            min_distance = float('inf')\n            min_cable = None\n\n            for i in range(n):\n                if i in connected:\n                    for j in range(n):\n                        if j not in connected and (i, j) not in connections:\n                            d = distance(treehouses[i], treehouses[j])\n                            if d < min_distance:\n                                min_distance = d\n                                min_cable = (i, j)\n\n            if min_cable is None:\n                return float('inf')\n\n            connected.add(min_cable[1])\n            total_length += min_distance\n            connections.add(min_cable)\n\n        return total_length\n\n    input_data = stdin.split('\\n')\n    n, e, p = map(int, input_data[0].split())\n    treehouses = [tuple(map(float, input_data[i + 1].split())) for i in range(n)]\n    connections = set()\n\n    for i in range(p):\n        a, b = map(int, input_data[n + i + 1].split())\n        connections.add((a - 1, b - 1))\n\n    result = connect_treehouses(treehouses, connections, n, e, p)\n    return '{:.7f}'.format(result)",
        "test": "",
        "num_ids": 445,
        "indeed": false
    },
    {
        "number": 2796,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def bfs(graph, source, visited):\n        queue = [source]\n        visited[source] = True\n\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    def count_boring_pairs(graph, paths):\n        boring_pairs = 0\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                if i != j:\n                    visited = [False] * (N + 1)\n                    bfs(graph, i, visited)\n                    if visited[j]:\n                        curiosity = [paths[i - 1][j - 1]]\n                        for k in range(N - 1):\n                            if k + 2 in permutation:\n                                if (i, j) in graph[permutation[k + 1]]:\n                                    curiosity.append(paths[permutation[k + 1] - 1][i - 1])\n                                    curiosity.append(paths[permutation[k + 1] - 1][j - 1])\n                        if all(xor(curiosity[0], c) == 0 for c in curiosity[1:]):\n                            boring_pairs += 1\n        return boring_pairs\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    paths = [list(map(int, line.split())) for line in lines[1:N]]\n    permutation = list(map(int, lines[N].split()))\n\n    graph = [[] for _ in range(N + 1)]\n    for i in range(N - 1):\n        A, B, Z = paths[i]\n        graph[A].append(B)\n        graph[B].append(A)\n\n    result = []\n    for k in range(N):\n        result.append(count_boring_pairs(graph, paths))\n        if k < N - 1:\n            A, B = permutation[k], permutation[k + 1]\n            for i in range(len(graph[A])):\n                if graph[A][i] == B:\n                    graph[A].pop(i)\n                    break\n            for i in range(len(graph[B])):\n                if graph[B][i] == A:\n                    graph[B].pop(i)\n                    break\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 649,
        "indeed": false
    },
    {
        "number": 2797,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    result = 0\n    for i in range(1, a):\n        result += i**b\n    result %= a\n    return str(result)",
        "test": "",
        "num_ids": 53,
        "indeed": false
    },
    {
        "number": 2798,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cut_cuboid(cuboid: tuple, x: int, y: int, z: int) -> list:\n        x_min, y_min, z_min, x_max, y_max, z_max = cuboid\n        new_cuboids = []\n\n        if x_min < x_max:\n            new_cuboids.append((x_min, y_min, z_min, x - 1, y_max, z_max))\n            new_cuboids.append((x, y_min, z_min, x_max, y_max, z_max))\n        if y_min < y_max:\n            new_cuboids.append((x_min, y_min, z_min, x_max, y - 1, z_max))\n            new_cuboids.append((x_min, y, z_min, x_max, y_max, z_max))\n        if z_min < z_max:\n            new_cuboids.append((x_min, y_min, z_min, x_max, y_max, z - 1))\n            new_cuboids.append((x_min, y_min, z, x_max, y_max, z_max))\n\n        return new_cuboids\n\n    def remove_duplicates(cuboids: list) -> list:\n        unique_cuboids = []\n        for cuboid in cuboids:\n            if cuboid not in unique_cuboids:\n                unique_cuboids.append(cuboid)\n        return unique_cuboids\n\n    def find_winner(stdin: str) -> str:\n        lines = stdin.split('\\n')\n        player, num_cuboids = lines[0], int(lines[1])\n        cuboids = [tuple(map(int, line.split())) for line in lines[2:2 + num_cuboids]]\n        cuboids = remove_duplicates(cuboids)\n\n        while cuboids:\n            if player == 'RUBEN':\n                player = 'ALBERT'\n            else:\n                player = 'RUBEN'\n\n            new_cuboids = []\n            for cuboid in cuboids:\n                for new_cuboid in cut_cuboid(cuboid, *[1 + cuboid[i] // 2 for i in range(3)]):\n                    new_cuboids.append(new_cuboid)\n\n            cuboids = remove_duplicates(new_cuboids)\n\n        return player\n\n    return find_winner(stdin) ",
        "test": "",
        "num_ids": 650,
        "indeed": false
    },
    {
        "number": 2799,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B, Y, S = map(int, stdin.split())\n    total_fruits = R + G + B + Y\n\n    # Probability of rolling a fruit\n    p_fruit = 4 / 6\n    # Probability of rolling the basket\n    p_basket = 1 / 6\n    # Probability of rolling the raven\n    p_raven = 1 / 6\n\n    # Probability of rolling a fruit of each color\n    p_red = R / total_fruits\n    p_green = G / total_fruits\n    p_blue = B / total_fruits\n    p_yellow = Y / total_fruits\n\n    # Probability of rolling a fruit of each color when there are no fruits of that color left\n    p_red_0 = (R - 1) / (total_fruits - 1) if R > 0 else 0\n    p_green_0 = (G - 1) / (total_fruits - 1) if G > 0 else 0\n    p_blue_0 = (B - 1) / (total_fruits - 1) if B > 0 else 0\n    p_yellow_0 = (Y - 1) / (total_fruits - 1) if Y > 0 else 0\n\n    # Probability of rolling a fruit of each color when there is only one fruit of that color left\n    p_red_1 = 1 / total_fruits if R > 0 else 0\n    p_green_1 = 1 / total_fruits if G > 0 else 0\n    p_blue_1 = 1 / total_fruits if B > 0 else 0\n    p_yellow_1 = 1 / total_fruits if Y > 0 else 0\n\n    # Probability of rolling a fruit of each color when there are two fruits of that color left\n    p_red_2 = (R - 2) / (total_fruits - 2) if R > 1 else 0\n    p_green_2 = (G - 2) / (total_fruits - 2) if G > 1 else 0\n    p_blue_2 = (B - 2) / (total_fruits - 2) if B > 1 else 0\n    p_yellow_2 = (Y - 2) / (total_fruits - 2) if Y > 1 else 0\n\n    # Probability of rolling a fruit of each color when there are three fruits of that color left\n    p_red_3 = (R - 3) / (total_fruits - 3) if R > 2 else 0\n    p_green_3 = (G - 3) / (total_fruits - 3) if G > 2 else 0\n    p_blue_3 = (B - 3) / (total_fruits - 3) if B > 2 else 0\n    p_yellow_3 = (Y - 3) / (total_fruits - 3) if Y > 2 else 0\n\n    # Probability of rolling a fruit of each color when there are four fruits of that color left\n    p_red_4 = 1 / total_fruits if R > 3 else 0\n    p_green_4 = 1 / total_fruits if G > 3 else 0\n    p_blue_4 = 1 / total_fruits if B > 3 else 0\n    p_yellow_4 = 1 / total_fruits if Y > 3 else 0\n\n    # Probability of rolling a fruit of each color when there are no fruits of that color left\n    p_red_0 = (R - 1) / (total_fruits - 1) if R > 0 else 0\n    p_green_0 = (G - 1) / (total_fruits - 1) if G > 0 else 0\n    p_blue_0 = (B - 1) / (total_fruits - 1) if B > 0 else 0\n    p_yellow_0 = (Y - 1) / (total_fruits - 1) if Y > 0 else 0\n\n    # Probability of rolling a fruit of each color when there is only one",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 2800,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_win(piles, k, current_player):\n        if not piles:\n            return current_player == \"Alice\"\n\n        next_player = \"Alice\" if current_player == \"Bob\" else \"Bob\"\n\n        for i, pile in enumerate(piles):\n            if pile[0] == 0:\n                continue\n\n            for take in range(min(k, pile[0]) + 1):\n                new_piles = piles[:i] + [[pile[j] for j in range(1, len(pile)) if j != take] for pile in piles[i:]]\n\n                if can_win(new_piles, k, next_player):\n                    return True\n\n        return False\n\n    lines = stdin.split(\"\\n\")\n    p, k = map(int, lines[0].split())\n    piles = [list(map(int, line.split()))[1:] for line in lines[1:p + 1]]\n\n    if can_win(piles, k, \"Alice\"):\n        return \"Alice can win.\"\n    else:\n        return \"Bob will win.\"",
        "test": "",
        "num_ids": 281,
        "indeed": false
    },
    {
        "number": 2801,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        s, t = map(int, stdin.readline().split())\n        graph[s].append(t)\n\n    dp = [0] * n\n    dp[0] = c[0]\n\n    for i in range(1, n):\n        for j in range(i):\n            if j in graph[i]:\n                dp[i] = max(dp[i], dp[j] + c[i] * (1 / 2 ** (i - j)))\n\n    return f\"{dp[-1]:.6f}\"",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2802,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    times = [float(x) for x in stdin.split('\\n')[0].split()]\n    target_score = float(stdin.split('\\n')[1])\n\n    times.sort()\n    times = times[1:4]\n\n    avg_time = sum(times) / len(times)\n\n    if avg_time <= target_score:\n        return \"infinite\"\n\n    worst_time = (target_score * 5 - sum(times) - 5) / 1\n\n    if worst_time <= 0:\n        return \"impossible\"\n\n    return f\"{worst_time:.2f}\"",
        "test": "",
        "num_ids": 156,
        "indeed": false
    },
    {
        "number": 2803,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    last_animal = input_data[0]\n    num_animal_names = int(input_data[1])\n    animal_names = input_data[2:]\n\n    valid_names = [name for name in animal_names if name[0] == last_animal[-1] and name not in animal_names[:animal_names.index(last_animal)]]\n\n    if valid_names:\n        for name in valid_names:\n            if name[-1] not in [animal[0] for animal in animal_names if animal != name]:\n                return name + '!'\n        return valid_names[0]\n    else:\n        return '?'",
        "test": "",
        "num_ids": 173,
        "indeed": false
    },
    {
        "number": 2804,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    words = []\n    for _ in range(B // 2):\n        word = \"\"\n        for _ in range(1, 16):\n            word += chr(random.randint(97, 122))\n        words.append(word)\n    essay = \" \".join(random.choices(words, k=B))\n    return essay",
        "test": "",
        "num_ids": 103,
        "indeed": false
    },
    {
        "number": 2805,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    counter = 0\n    for i in range(n - 1, 0, -1):\n        counter += 1\n        if n % i == 0:\n            break\n    return str(counter)",
        "test": "",
        "num_ids": 60,
        "indeed": true
    },
    {
        "number": 2806,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited, adj):\n        visited[v] = True\n        for u in adj[v]:\n            if not visited[u]:\n                dfs(u, visited, adj)\n\n    def find_connected_components(adj):\n        visited = [False] * (len(adj) + 1)\n        components = []\n        for v in range(1, len(adj) + 1):\n            if not visited[v]:\n                component = []\n                dfs(v, visited, adj)\n                for i in range(1, len(visited)):\n                    if visited[i]:\n                        component.append(i)\n                components.append(component)\n        return components\n\n    def bfs(start, adj):\n        visited = [False] * (len(adj) + 1)\n        queue = [(start, 0)]\n        visited[start] = True\n        path = [start]\n        while queue:\n            v, depth = queue.pop(0)\n            for u in adj[v]:\n                if not visited[u]:\n                    visited[u] = True\n                    queue.append((u, depth + 1))\n                    if depth + 1 >= len(path):\n                        path.append(u)\n                    else:\n                        path[depth + 1] = u\n        return path\n\n    c, t = map(int, stdin.readline().split())\n    adj = [[] for _ in range(c + 1)]\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    components = find_connected_components(adj)\n    start = components[0][0]\n    path = bfs(start, adj)\n    p = len(path)\n    s = (c - p) // 2\n    output = [str(p), str(s)]\n    output.extend([str(x) for x in path])\n    for i in range(s):\n        output.extend([str(x) for x in components[i + 1]])\n    return \"\\n\".join(output) + \"\\n\"",
        "test": "",
        "num_ids": 527,
        "indeed": false
    },
    {
        "number": 2807,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')\n    n = len(A)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1 if A[i] == B[i] else 0\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if A[i] == B[j] and A[j] == B[i]:\n                for k in range(i + 1, j):\n                    dp[i][j] += dp[i][k] * dp[k][j]\n            elif A[i] == B[j]:\n                dp[i][j] = dp[i + 1][j]\n            elif A[j] == B[i]:\n                dp[i][j] = dp[i][j - 1]\n            else:\n                dp[i][j] = 0\n\n    return dp[0][n - 1]",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 2808,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n    l, r = [0] * m, [0] * m\n    for i in range(m):\n        l[i], r[i] = map(int, stdin.split()[3 + n + i].split())\n\n    def count_happy_passengers(carts):\n        happy_passengers = [0] * n\n        for i in carts:\n            for j in range(l[i] - 1, r[i]):\n                happy_passengers[j] += 1\n        return sum(1 for x in happy_passengers if x == len(carts))\n\n    def backtrack(start, carts):\n        if count_happy_passengers(carts) >= k:\n            return 1\n        if start == m:\n            return 0\n        return backtrack(start + 1, carts) + backtrack(start + 1, carts + [start])\n\n    mod = 10**9 + 7\n    return str(backtrack(0, []))",
        "test": "",
        "num_ids": 283,
        "indeed": false
    },
    {
        "number": 2809,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n\n    MOD = 10**9 + 7\n    R = int(s * k, 2)\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(R):\n        for j in range(n, 0, -1):\n            dp[j] += dp[j - 1]\n            dp[j] %= MOD\n\n            if i & (1 << (j - 1)):\n                dp[j] += dp[j - 1]\n                dp[j] %= MOD\n\n    return str(dp[n])",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 2810,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, graph):\n        if start in visited:\n            return 0\n        visited.add(start)\n        count = 1\n        for neighbor in graph[start]:\n            if neighbor == start:\n                continue\n            count += dfs(neighbor, visited, graph)\n        return count\n\n    def count_loops(graph):\n        loops = 0\n        for start in range(len(graph)):\n            loops += dfs(start, set(), graph)\n        return loops // 2\n\n    lines = stdin.split('\\n')\n    num_stations = int(lines[0])\n    num_connections = int(lines[1])\n    connections = [tuple(map(int, line.split())) for line in lines[2:2 + num_connections]]\n\n    graph = [[] for _ in range(num_stations)]\n    for s, t in connections:\n        graph[s].append(t)\n\n    return str(count_loops(graph))",
        "test": "",
        "num_ids": 241,
        "indeed": false
    },
    {
        "number": 2811,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, u):\n        while parent[u] != u:\n            u = parent[u]\n        return u\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    n, m = map(int, stdin.readline().split())\n    parent = [i for i in range(n + 1)]\n    rank = [0] * (n + 1)\n    red_nodes = set()\n    for i in range(m):\n        r = int(stdin.readline())\n        red_nodes.add(r)\n\n    for i in range(2, n + 1):\n        p = int(stdin.readline())\n        union(parent, rank, p, i)\n\n    dp = [0] * (m + 1)\n    dp[0] = n\n\n    for i in range(1, m + 1):\n        dp[i] = dp[i - 1]\n        for j in range(1, n + 1):\n            if j not in red_nodes or len(red_nodes & set(parent[1:j + 1])) > i - 1:\n                continue\n            dp[i] += dp[i - 1] - dp[len(red_nodes & set(parent[1:j + 1]))]\n            dp[i] %= 1000000007\n\n    return '\\n'.join(map(str, dp))",
        "test": "",
        "num_ids": 466,
        "indeed": false
    },
    {
        "number": 2812,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    min_length = float('inf')\n    min_name = ''\n\n    for i in range(1, 27):\n        for j in range(1, 27):\n            name = chr(97 + i) + chr(97 + j)\n            value = abs(i - j)\n            if value == k:\n                return name\n            if value < k and len(name) < min_length:\n                min_length = len(name)\n                min_name = name\n\n    for i in range(1, 27):\n        for j in range(1, 27):\n            for l in range(1, 27):\n                name = chr(97 + i) + chr(97 + j) + chr(97 + l)\n                value = abs(i - j) + abs(j - l)\n                if value == k:\n                    return name\n                if value < k and len(name) < min_length:\n                    min_length = len(name)\n                    min_name = name\n\n    for i in range(1, 27):\n        for j in range(1, 27):\n            for l in range(1, 27):\n                for m in range(1, 27):\n                    name = chr(97 + i) + chr(97 + j) + chr(97 + l) + chr(97 + m)\n                    value = abs(i - j) + abs(j - l) + abs(l - m)\n                    if value == k:\n                        return name\n                    if value < k and len(name) < min_length:\n                        min_length = len(name)\n                        min_name = name\n\n    return min_name",
        "test": "",
        "num_ids": 430,
        "indeed": false
    },
    {
        "number": 2813,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_haiku(phrases: list[list[str]]) -> bool:\n        for i, length in enumerate([5, 7, 5]):\n            if sum(len(word) for word in phrases[i]) != length:\n                return False\n        return True\n\n    def count_syllables(word: str) -> int:\n        count = 0\n        for char in word:\n            if char in \"aeiou\":\n                count += 1\n        return count\n\n    def find_decomposition(syllables: list[str], index: int, current_word: str, current_count: int, phrases: list[list[str]]) -> bool:\n        if index == len(syllables):\n            if len(phrases) == 3:\n                return is_haiku(phrases)\n            return False\n\n        if current_count + count_syllables(syllables[index]) <= 5:\n            current_word += syllables[index] + \" \"\n            current_count += count_syllables(syllables[index])\n            if len(phrases) < 3 or len(phrases[-1]) < 5:\n                phrases[-1].append(current_word.strip())\n                if find_decomposition(syllables, index + 1, current_word, current_count, phrases):\n                    return True\n                phrases[-1].pop()\n                current_word = current_word[:-len(syllables[index]) - 1]\n                current_count -= count_syllables(syllables[index])\n\n        return find_decomposition(syllables, index + 1, current_word, current_count, phrases)\n\n    lines = stdin.split(\"\\n\")\n    syllables_count = int(lines[0])\n    syllables = lines[1].split()\n    poem = [line.split() for line in lines[2:5]]\n\n    if sum(len(word) for word in syllables) != syllables_count:\n        return \"come back next year\"\n\n    if find_decomposition(syllables, 0, \"\", 0, poem):\n        return \"haiku\"\n    else:\n        return \"come back next year\"",
        "test": "",
        "num_ids": 542,
        "indeed": false
    },
    {
        "number": 2814,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(i, j):\n        return i // 2 == j // 2\n\n    def find_similar(permutation):\n        for i in range(len(permutation)):\n            for j in range(i + 1, len(permutation)):\n                if is_similar(permutation[i], permutation[j]):\n                    return (i, j)\n        return None\n\n    def play_game(permutation1, permutation2):\n        revealed = set()\n        player0_score = 0\n        player1_score = 0\n        while len(revealed) < len(permutation1):\n            similar_cards = find_similar(permutation1)\n            if similar_cards:\n                i, j = similar_cards\n                if permutation1[i] not in revealed and permutation1[j] not in revealed:\n                    player0_score += 1\n                    revealed.add(permutation1[i])\n                    revealed.add(permutation1[j])\n            else:\n                for card in permutation2:\n                    if card not in revealed:\n                        revealed.add(card)\n                        break\n                for card in permutation1:\n                    if card not in revealed:\n                        player1_score += 1\n                        revealed.add(card)\n                        break\n        return player0_score, player1_score\n\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    permutation0 = [int(x) for x in lines[1].split()]\n    permutation1 = [int(x) for x in lines[2].split()]\n\n    player0_score, player1_score = play_game(permutation0, permutation1)\n\n    if player0_score > player1_score:\n        return '0'\n    elif player0_score < player1_score:\n        return '1'\n    else:\n        return '-1'",
        "test": "",
        "num_ids": 478,
        "indeed": false
    },
    {
        "number": 2815,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)",
        "test": "",
        "num_ids": 61,
        "indeed": true
    },
    {
        "number": 2816,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(N)]\n    V_pos = None\n    J_pos = None\n    trees = []\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'V':\n                V_pos = (i, j)\n            elif grid[i][j] == 'J':\n                J_pos = (i, j)\n            elif grid[i][j] == '+':\n                trees.append((i, j))\n\n    def get_distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def is_valid(pos):\n        return 0 <= pos[0] < N and 0 <= pos[1] < M\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            pos, dist = queue.pop(0)\n            if pos == end:\n                return dist\n            if pos in visited:\n                continue\n            visited.add(pos)\n            for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_pos = (pos[0] + direction[0], pos[1] + direction[1])\n                if is_valid(new_pos) and grid[new_pos[0]][new_pos[1]] != '+':\n                    queue.append((new_pos, dist + 1))\n        return None\n\n    min_distance = float('inf')\n    for tree in trees:\n        distance = get_distance(V_pos, tree)\n        if distance < min_distance:\n            min_distance = distance\n            result = bfs(V_pos, tree)\n\n    return result",
        "test": "",
        "num_ids": 471,
        "indeed": false
    },
    {
        "number": 2817,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    e, e_success, e_failure = map(int, stdin.split())\n\n    def can_lift(weight: float) -> bool:\n        energy = e\n        while energy > 0:\n            if weight <= 25:\n                return True\n            if weight > 225:\n                return False\n            if weight <= energy:\n                energy -= e_success\n            else:\n                energy -= e_failure\n            weight -= 25\n        return False\n\n    low, high = 25, 225\n    while low < high:\n        mid = (low + high) / 2\n        if can_lift(mid):\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return str(low - 25)",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2818,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = map(int, stdin.split())\n    H = list(map(int, H.split()))\n    H.sort()\n    arrows = 0\n    while H:\n        arrows += 1\n        height = H.pop()\n        for i in range(len(H)):\n            if H[i] > height:\n                H[i] -= 1\n    return str(arrows)",
        "test": "",
        "num_ids": 101,
        "indeed": false
    },
    {
        "number": 2819,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x: int, y: int, move: tuple) -> bool:\n        return (1 <= x + move[0] <= n) and (1 <= y + move[1] <= n)\n\n    def can_capture_in_two_moves(x: int, y: int, valid_moves: list) -> bool:\n        for move1 in valid_moves:\n            for move2 in valid_moves:\n                if is_valid_move(x + move1[0], y + move1[1], move2) and \\\n                   is_valid_move(x + move1[0] + move2[0], y + move1[1] + move2[1], move1):\n                    return True\n        return False\n\n    def can_teleport_to_safe_cell(x: int, y: int, valid_moves: list, b_x: int, b_y: int) -> tuple:\n        for move in valid_moves:\n            new_x, new_y = x + move[0], y + move[1]\n            if (new_x, new_y) != (b_x, b_y):\n                return (new_x, new_y)\n        return None\n\n    n, a_x, a_y, b_x, b_y = map(int, stdin.split())\n    valid_moves = [tuple(map(int, input().split())) for _ in range(n)]\n\n    if can_capture_in_two_moves(a_x, a_y, valid_moves):\n        return \"Alice wins\"\n    elif can_teleport_to_safe_cell(a_x, a_y, valid_moves, b_x, b_y):\n        a_x, a_y = can_teleport_to_safe_cell(a_x, a_y, valid_moves, b_x, b_y)\n        return f\"tie {a_x} {a_y}\"\n    else:\n        return \"Bob wins\"",
        "test": "",
        "num_ids": 496,
        "indeed": false
    },
    {
        "number": 2820,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def get_bean_count(bean_types, farms):\n        bean_count = [0] * bean_types\n        for farm in farms:\n            for bean in farm[1:]:\n                bean_count[bean - 1] += 1\n        return bean_count\n\n    def get_min_cows(bean_types, bean_count, required_beans):\n        total_beans = sum(bean_count)\n        total_required = sum(required_beans)\n        if total_beans < total_required:\n            return -1\n\n        gcd_val = gcd(total_beans, total_required)\n        lcm_val = lcm(total_beans, total_required)\n\n        min_cows = float('inf')\n        for i in range(1, lcm_val + 1):\n            if lcm_val % i == 0:\n                required_beans_per_cycle = [i // bean_types * required_beans[j] for j in range(bean_types)]\n                total_beans_per_cycle = i * total_beans // total_required\n\n                cow_count = 0\n                for j in range(bean_types):\n                    if required_beans_per_cycle[j] > bean_count[j]:\n                        cow_count += (required_beans_per_cycle[j] - bean_count[j]) // total_beans_per_cycle + 1\n\n                min_cows = min(min_cows, cow_count)\n\n        return min_cows\n\n    stdin_list = stdin.split('\\n')\n    bean_types = int(stdin_list[0])\n    required_beans = list(map(int, stdin_list[1].split()))\n    farms = [list(map(int, stdin_list[i + 2].split())) for i in range(2, len(stdin_list) - 1)]\n\n    bean_count = get_bean_count(bean_types, farms)\n    min_cows = get_min_cows(bean_types, bean_count, required_beans)\n\n    return str(min_cows)",
        "test": "",
        "num_ids": 571,
        "indeed": false
    },
    {
        "number": 2821,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, M, S, L = map(int, stdin.split())\n    total_slots = S + L * Q\n    time = total_slots // M\n    if total_slots % M != 0:\n        time += 1\n    return str(time)",
        "test": "",
        "num_ids": 68,
        "indeed": false
    },
    {
        "number": 2822,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_b, y_b = map(int, stdin.split()[:2])\n    x1, y1, x2, y2 = map(int, stdin.split()[2:])\n\n    if x1 <= x_b <= x2 and y1 <= y_b <= y2:\n        return \"Yes\"\n    else:\n        closest_tree = (x_b, y_b)\n        for x in range(x1, x2 + 1):\n            for y in range(y1, y2 + 1):\n                if (x, y) == (x_b, y_b):\n                    continue\n                if abs(x - x_b) + abs(y - y_b) < abs(closest_tree[0] - x_b) + abs(closest_tree[1] - y_b):\n                    closest_tree = (x, y)\n        return f\"No\\n{closest_tree[0]} {closest_tree[1]}\"",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 2823,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    apple_dna, swine_gene, costs = stdin.strip().split('\\n')\n    cost_a, cost_c, cost_g, cost_t = map(int, costs.split())\n\n    n, m = len(apple_dna), len(swine_gene)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if apple_dna[i - 1] == swine_gene[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + cost_a, dp[i][j - 1] + cost_c, dp[i - 1][j - 1] + cost_g, dp[i - 1][j - 1] + cost_t)\n\n    return str(dp[n][m])",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 2824,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline().strip())\n    weights = [int(stdin.readline().strip()) for _ in range(m)]\n\n    total_weight = sum(weights)\n    target_weight = total_weight // 2\n\n    if total_weight % 2 == 1:\n        odd_weights = [w for w in weights if w == target_weight]\n        if len(odd_weights) % 2 == 1:\n            target_weight += 1\n\n    return str(target_weight)",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 2825,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    times = input_list[1:]\n\n    # Sort times in ascending order\n    times.sort()\n\n    # Initialize variables\n    total_time = 0\n    pairs = []\n\n    # Create pairs\n    for i in range(0, N, 2):\n        if i + 1 < N:\n            pairs.append((times[i], times[i + 1]))\n        else:\n            pairs.append((times[i], 0))\n\n    # Calculate time for each pair\n    for pair in pairs:\n        total_time += max(pair[0], pair[1])\n\n    return str(total_time)",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2826,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, n, D = map(int, stdin.split('\\n')[0].split())\n    f1 = stdin.split('\\n')[1]\n    f2 = stdin.split('\\n')[2]\n\n    def hamming_distance(s1: str, s2: str) -> int:\n        return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\n    def is_on_ellipse(p: str) -> bool:\n        return hamming_distance(p, f1) + hamming_distance(p, f2) == D\n\n    count = 0\n    for i in range(q ** n):\n        p = format(i, f'0{n}b')\n        if is_on_ellipse(p):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 2827,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = {i: set() for i in range(1, N + 1)}\n    for _ in range(M):\n        u, v = map(int, stdin.readline().split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    visited = [False] * (N + 1)\n    queue = []\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            queue.append(i)\n            visited[i] = True\n            while queue:\n                u = queue.pop(0)\n                for v in graph[u]:\n                    if not visited[v]:\n                        queue.append(v)\n                        visited[v] = True\n\n    return str(sum(visited[1:]) - 1)",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2828,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def encrypt(key: str, words: List[str]) -> List[str]:\n        encrypted_words = []\n        for word in words:\n            encrypted_word = \"\"\n            for letter in word:\n                encrypted_word += key[ord(letter) - ord('a')]\n            encrypted_words.append(encrypted_word)\n        return encrypted_words\n\n    def is_sorted(words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            if words[i] > words[i + 1]:\n                return False\n        return True\n\n    def find_key(words: List[str], indices: List[int]) -> str:\n        key = \"\"\n        for i in range(26):\n            key += chr(ord('a') + i)\n        key_found = False\n        for p in permutations(key):\n            if is_sorted(encrypt(\"\".join(p), words)):\n                key_found = True\n                break\n        return p if key_found else \"NE\"\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    words = lines[1:N + 1]\n    indices = list(map(int, lines[N + 1].split()))\n\n    if len(set(words)) != N or len(set(indices)) != N or any(\n            i < 1 or i > N for i in indices):\n        return \"NE\"\n\n    key = find_key(words, indices)\n    if key == \"NE\":\n        return \"NE\"\n    else:\n        return \"DA\\n\" + \"\".join(key)",
        "test": "",
        "num_ids": 394,
        "indeed": false
    },
    {
        "number": 2829,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    morse_code = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'\n    }\n\n    stdin = stdin.upper()\n    morse_code_length = 0\n\n    for char in stdin:\n        if char in morse_code:\n            morse_code_length += len(morse_code[char]) + 1\n            if char != stdin[-1]:\n                morse_code_length += 3\n\n    return morse_code_length",
        "test": "",
        "num_ids": 339,
        "indeed": false
    },
    {
        "number": 2830,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, stdin.readline())))\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (x, y), steps = queue.pop(0)\n            if (x, y) == end:\n                return steps\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx * grid[x][y], y + dy * grid[x][y]\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    queue.append(((nx, ny), steps + 1))\n        return -1\n\n    start, end = (0, 0), (n - 1, m - 1)\n    return str(bfs(start, end))",
        "test": "",
        "num_ids": 305,
        "indeed": false
    },
    {
        "number": 2831,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    vehicles = []\n    for _ in range(n):\n        x, v = map(int, stdin.readline().split())\n        vehicles.append((x, v))\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, v1 = vehicles[i]\n            x2, v2 = vehicles[j]\n            if v1 == v2:\n                continue\n            t = (x2 - x1) / (v1 - v2)\n            if t > 0:\n                x = x1 + v1 * t\n                min_distance = min(min_distance, abs(x - x2))\n\n    return f\"{min_distance:.3f}\"",
        "test": "",
        "num_ids": 197,
        "indeed": false
    },
    {
        "number": 2832,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k = map(int, stdin.readline().split())\n    red_values = []\n    pixel_counts = []\n    for _ in range(d):\n        r, p = map(int, stdin.readline().split())\n        red_values.append(r)\n        pixel_counts.append(p)\n\n    red_values.sort()\n    unique_values = list(set(red_values))\n    unique_values.sort()\n\n    if k == len(unique_values):\n        return 0\n\n    allowed_values = unique_values[:k]\n    allowed_values.sort()\n\n    squared_errors = []\n    for i in range(len(red_values)):\n        squared_error = min((v - red_values[i]) ** 2 for v in allowed_values)\n        squared_errors.append(squared_error * pixel_counts[i])\n\n    return str(sum(squared_errors))",
        "test": "",
        "num_ids": 234,
        "indeed": false
    },
    {
        "number": 2833,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_matrix(matrix, k):\n        n = len(matrix)\n        m = len(matrix[0])\n        rotated_matrix = [[\"\" for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                new_i = j\n                new_j = m - i - 1\n                rotated_matrix[new_i][new_j] = matrix[i][j]\n        return rotated_matrix\n\n    def print_matrix(matrix):\n        for row in matrix:\n            print(\"\".join(row))\n\n    input_data = stdin.split(\"\\n\")\n    R, C = map(int, input_data[0].split())\n    matrix = [list(input_data[i + 1]) for i in range(R)]\n    K = int(input_data[-1])\n\n    if K % 90 != 0:\n        raise ValueError(\"Angle must be a multiple of 90\")\n\n    rotations = K // 90\n    for _ in range(rotations):\n        matrix = rotate_matrix(matrix, K)\n\n    print_matrix(matrix)\n",
        "test": "",
        "num_ids": 285,
        "indeed": false
    },
    {
        "number": 2834,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    lucky_numbers = [4, 7]\n    lucky_count = 0\n    i = 1\n\n    while lucky_count < k:\n        digits = [int(d) for d in str(i)]\n        if all(d in lucky_numbers for d in digits):\n            lucky_count += 1\n            if lucky_count == k:\n                return str(i)\n        i += 1",
        "test": "",
        "num_ids": 115,
        "indeed": true
    },
    {
        "number": 2835,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    m = len(t)\n    count = 0\n\n    for i in range(n - m + 1):\n        if t in s[i:i + m]:\n            count += 1\n\n    return count",
        "test": "",
        "num_ids": 75,
        "indeed": false
    },
    {
        "number": 2836,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, boys, A, B = parse_input(stdin)\n    min_distance = float('-inf')\n    best_name = None\n\n    for i in range(A, B + 1, 2):\n        distances = [abs(i - p) for p in boys]\n        min_distance_for_i = min(distances)\n\n        if min_distance_for_i > min_distance:\n            min_distance = min_distance_for_i\n            best_name = i\n\n    return best_name\n\ndef",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2837,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def equivalent_resistance(circuit: str, resistances: list) -> float:\n        def calculate_resistance(subcircuit: str, resistances: list) -> float:\n            subcircuit = subcircuit.replace('(', '').replace(')', '')\n            if '|' in subcircuit:\n                subcircuit = subcircuit.split('|')\n                resistance = 0\n                for resistor in subcircuit:\n                    resistance += 1 / calculate_resistance(resistor, resistances)\n                resistance = 1 / resistance\n            else:\n                subcircuit = subcircuit.split('-')\n                resistance = 0\n                for resistor in subcircuit:\n                    resistance += resistances[int(resistor[1:]) - 1]\n            return resistance\n\n        if '|' in circuit:\n            circuit = circuit.split('|')\n            resistance = 0\n            for subcircuit in circuit:\n                resistance += 1 / calculate_resistance(subcircuit, resistances)\n            resistance = 1 / resistance\n        else:\n            circuit = circuit.split('-')\n            resistance = 0\n            for subcircuit in circuit:\n                resistance += calculate_resistance(subcircuit, resistances)\n\n        return resistance\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    resistances = [float(x) for x in lines[1].split()]\n    circuit = lines[2]\n\n    result = equivalent_resistance(circuit, resistances)\n    return f\"{result:.5f}\"",
        "test": "",
        "num_ids": 380,
        "indeed": false
    },
    {
        "number": 2838,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(expression: str) -> bool:\n        stack = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def generate_expressions(expression: str) -> set:\n        expressions = set()\n        for i in range(len(expression)):\n            if expression[i] == '(':\n                for j in range(i + 1, len(expression)):\n                    if expression[j] == ')':\n                        new_expression = expression[:i] + expression[i + 1:j] + expression[j + 1:]\n                        if is_valid(new_expression):\n                            expressions.add(new_expression)\n        return expressions\n\n    input_expression = stdin.strip()\n    expressions = generate_expressions(input_expression)\n    return '\\n'.join(sorted(expressions))",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 2839,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        distances = [float('inf')] * len(graph)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if node == end:\n                return dist\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, weight in graph[node].items():\n                    new_distance = dist + weight\n                    if new_distance < distances[neighbor]:\n                        distances[neighbor] = new_distance\n                        heapq.heappush(pq, (new_distance, neighbor))\n        return -1\n\n    def count_shortest_paths(graph, start, end):\n        count = 0\n        for i in range(len(graph)):\n            if dijkstra(graph, start, i) == dijkstra(graph, i, end):\n                count += 1\n        return count - 2\n\n    lines = stdin.split('\\n')\n    V, E = map(int, lines[0].split())\n    graph = [{} for _ in range(V)]\n\n    for i in range(1, E + 1):\n        u, v, w = map(int, lines[i].split())\n        graph[u][v] = w\n\n    s, t = map(int, lines[-1].split())\n    return str(count_shortest_paths(graph, s, t))",
        "test": "",
        "num_ids": 375,
        "indeed": false
    },
    {
        "number": 2840,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = stdin.split('\\n')[1].split()\n\n    def sort_key(card):\n        rank = card[0]\n        suit = card[1]\n        if rank == 'T':\n            rank = 10\n        elif rank == 'J':\n            rank = 11\n        elif rank == 'Q':\n            rank = 12\n        elif rank == 'K':\n            rank = 13\n        elif rank == 'A':\n            rank = 14\n        else:\n            rank = int(rank)\n\n        if suit == 's':\n            suit = 1\n        elif suit == 'h':\n            suit = 2\n        elif suit == 'd':\n            suit = 3\n        else:\n            suit = 4\n\n        return rank, suit\n\n    cards.sort(key=sort_key)\n\n    min_moves = 0\n    for i in range(n - 1):\n        if cards[i][0] == cards[i + 1][0] and cards[i][1] != cards[i + 1][1]:\n            min_moves += 1\n\n    return str(min_moves)",
        "test": "",
        "num_ids": 295,
        "indeed": false
    },
    {
        "number": 2841,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    colors = lines[1:]\n\n    start_square = 'Start'\n    board = [start_square] + colors\n\n    min_draws = N\n    for i in range(N):\n        if board[i] == start_square:\n            continue\n        if board[i] == board[N]:\n            min_draws = N - i\n            break\n        for j in range(i + 1, N + 1):\n            if board[j] == board[i]:\n                min_draws = min(min_draws, N - j)\n                break\n\n    return str(min_draws)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 2842,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    alice_grid = []\n    for _ in range(n):\n        alice_grid.append(list(stdin.readline().strip()))\n    ship_sizes = []\n    for _ in range(k):\n        ship_sizes.append(int(stdin.readline().strip()))\n\n    def is_valid(grid, ships):\n        for ship in ships:\n            if not is_valid_ship(grid, ship):\n                return False\n        return True\n\n    def is_valid_ship(grid, ship):\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '.':\n                    if is_valid_position(grid, ship, i, j):\n                        return True\n        return False\n\n    def is_valid_position(grid, ship, row, col):\n        if len(ship) == 1:\n            return True\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] != '.':\n            return False\n        grid[row][col] = 'X'\n        if is_valid_position(grid, ship[1:], row - 1, col) or \\\n                is_valid_position(grid, ship[1:], row + 1, col) or \\\n                is_valid_position(grid, ship[1:], row, col - 1) or \\\n                is_valid_position(grid, ship[1:], row, col + 1):\n            return True\n        grid[row][col] = '.'\n        return False\n\n    count = 0\n    for ship_placement in itertools.permutations(ship_sizes):\n        if is_valid(alice_grid, ship_placement):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 459,
        "indeed": false
    },
    {
        "number": 2843,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_swap_free(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        diff_count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff_count += 1\n                if diff_count > 2:\n                    return False\n        return diff_count == 2\n\n    def find_swap_free_set(words: List[str]) -> int:\n        max_size = 0\n        for i in range(len(words)):\n            swap_free_set = set([words[i]])\n            for j in range(i + 1, len(words)):\n                if is_swap_free(words[i], words[j]):\n                    swap_free_set.add(words[j])\n            max_size = max(max_size, len(swap_free_set))\n        return max_size\n\n    N = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(N)]\n    return str(find_swap_free_set(words))",
        "test": "",
        "num_ids": 286,
        "indeed": false
    },
    {
        "number": 2844,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    forest = [list(stdin.readline().strip()) for _ in range(R)]\n    painter_position = next((x, y) for x in range(R) for y in range(C) if forest[x][y] == 'S')\n    den_position = next((x, y) for x in range(R) for y in range(C) if forest[x][y] == 'D')\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < R and 0 <= y < C and forest[x][y] != 'X'\n\n    def is_flooded(x: int, y: int) -> bool:\n        return is_valid(x, y) and forest[x][y] == '*'\n\n    def get_neighbors(x: int, y: int) -> list:\n        return [(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)] if is_valid(x + dx, y + dy)]\n\n    def bfs() -> int:\n        queue = [(painter_position, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), minutes = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if (x, y) == den_position:\n                return minutes\n\n            for neighbor in get_neighbors(x, y):\n                if not is_flooded(*neighbor):\n                    queue.append((neighbor, minutes + 1))\n\n        return None\n\n    def expand_flood():\n        for x in range(R):\n            for y in range(C):\n                if forest[x][y] == '*':\n                    for neighbor in get_neighbors(x, y):\n                        if is_valid(*neighbor) and forest[neighbor[0]][neighbor[1]] != '*':\n                            forest[neighbor[0]][neighbor[1]] = '*'\n\n    time = 0\n    while True:\n        if bfs() is not None:\n            return bfs()\n\n        expand_flood()\n        time += 1\n\n        if time > 1000:\n            return \"KAKTUS\"",
        "test": "",
        "num_ids": 602,
        "indeed": false
    },
    {
        "number": 2845,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, K = map(int, stdin.split('\\n')[0].split())\n    house_indices = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_outer_cell(cell_index: int) -> bool:\n        layer = 1\n        while True:\n            if cell_index <= R ** 3 - (R - layer) ** 3:\n                break\n            layer += 1\n        if cell_index in [R ** 3 - (R - layer) ** 3 + 1, R ** 3 - (R - layer) ** 3 + R, R ** 3 - (R - layer) ** 3 + R * (R - layer + 1), R ** 3 - (R - layer) ** 3 + R ** 2 - (R - layer) ** 2]:\n            return True\n        return False\n\n    perimeter = 0\n    for cell_index in house_indices:\n        if is_outer_cell(cell_index):\n            perimeter += 1\n\n    return str(perimeter)",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2846,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    citations = [int(x) for x in stdin.split('\\n')[1:]]\n    citations.sort(reverse=True)\n    h_index = 0\n    for i in range(n):\n        if citations[i] >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return str(h_index)",
        "test": "",
        "num_ids": 107,
        "indeed": true
    },
    {
        "number": 2847,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_set_list(preference_lists):\n        songs = set()\n        for preference_list in preference_lists:\n            for song in preference_list:\n                if song not in songs:\n                    songs.add(song)\n                    break\n        return sorted(list(songs))\n\n    lines = stdin.split('\\n')\n    M, S = map(int, lines[0].split())\n    preference_lists = [list(map(int, line.split())) for line in lines[1:]]\n\n    min_set_list = find_min_set_list(preference_lists)\n    return f\"{len(min_set_list)}\\n{' '.join(map(str, min_set_list))}\"",
        "test": "",
        "num_ids": 179,
        "indeed": false
    },
    {
        "number": 2848,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, K, X_0, A, B = map(int, stdin.split())\n    X = [X_0]\n    for _ in range(R - 1):\n        X.append((A * X[-1] + B) % N)\n\n    buckets = [0] * N\n    for x in X:\n        buckets[x] += 1\n        if buckets[x] > K:\n            buckets[x - 1] += 1\n            if x == 0:\n                return \"OVERFLOW\"\n\n    a = 0\n    for x in X:\n        a = (53 * a + x) % 199933\n\n    return str(a)",
        "test": "",
        "num_ids": 176,
        "indeed": false
    },
    {
        "number": 2849,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n\n    def count_ugly_tunnel_placements(n: int) -> int:\n        if n < 3:\n            return 0\n        if n == 3:\n            return 5\n\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 5\n\n        for i in range(3, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD\n\n        return dp[n]\n\n    return str(count_ugly_tunnel_placements(n))",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 2850,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    weights = list(map(int, stdin.split()))\n\n    weights.sort(reverse=True)\n\n    min_heaviest_box_weight = sum(weights[:k])\n\n    for i in range(k, n):\n        min_heaviest_box_weight = min(min_heaviest_box_weight, sum(weights[i:i+k]))\n\n    return str(min_heaviest_box_weight)",
        "test": "",
        "num_ids": 125,
        "indeed": false
    },
    {
        "number": 2851,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = [], []\n    N, M = map(int, stdin.split('\\n')[0].split())\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    B = list(map(int, stdin.split('\\n')[3].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = 1\n    for i in range(1, 1000000000):\n        if all(i % a == 0 for a in A) and all(i % b == 0 for b in B):\n            result = i\n\n    return str(result)[-9:]",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 2852,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    probabilities = [int(x) / 100 for x in stdin.split('\\n')[1].split()]\n\n    def research_productivity_index(a: int, s: int) -> float:\n        if a == 0:\n            return 0\n        return a ** (a / s)\n\n    def expected_value(p: float) -> float:\n        return sum([research_productivity_index(i, n) * p ** i * (1 - p) ** (n - i) for i in range(n + 1)])\n\n    max_expected_value = max([expected_value(p) for p in probabilities])\n\n    return f\"{max_expected_value:.10f}\"",
        "test": "",
        "num_ids": 191,
        "indeed": false
    },
    {
        "number": 2853,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = {i: [] for i in range(1, N + 1)}\n    visited = [False] * (N + 1)\n\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(1)\n\n    not_connected = [str(i) for i in range(1, N + 1) if not visited[i]]\n\n    if not_connected:\n        return \"\\n\".join(not_connected)\n    else:\n        return \"Connected\"",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2854,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def average_location(locations, neighbors):\n        x_total, y_total, count = 0, 0, 0\n        for neighbor in neighbors:\n            if neighbor in locations:\n                x_total += locations[neighbor][0]\n                y_total += locations[neighbor][1]\n                count += 1\n        if count == 0:\n            return -1, -1\n        return x_total / count, y_total / count\n\n    def find_solution(n, m, atoms, bonds, locations):\n        for i in range(1, n + 1):\n            if i not in locations:\n                neighbors = [j for j in range(1, n + 1) if (i, j) in bonds or (j, i) in bonds]\n                x, y = average_location(locations, neighbors)\n                if x != -1:\n                    locations[i] = (x, y)\n                else:\n                    return None\n        return locations\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    atoms = set(range(1, n + 1))\n    bonds = set()\n    locations = {}\n\n    for i in range(1, n + 1):\n        x, y = map(int, lines[i].split())\n        if x != -1:\n            locations[i] = (x, y)\n\n    for i in range(n + 1, n + m + 1):\n        a, b = map(int, lines[i].split())\n        bonds.add((a, b))\n        bonds.add((b, a))\n\n    solution = find_solution(n, m, atoms, bonds, locations)\n    if solution is None:\n        return \"No solution found\"\n\n    output = []\n    for i in range(1, n + 1):\n        x, y = solution[i]\n        output.append(f\"{x:.3f} {y:.3f}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 556,
        "indeed": false
    },
    {
        "number": 2855,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(N)]\n    for _ in range(M):\n        K, L = map(int, stdin.readline().split())\n        adj_list[K].append(L)\n        adj_list[L].append(K)\n\n    visited = [False] * N\n    visited[0] = True\n    q = [(0, 0)]  # (clearing, time)\n    total_time = 0\n    total_count = 0\n\n    while q:\n        clearing, time = q.pop(0)\n        for next_clearing in adj_list[clearing]:\n            if not visited[next_clearing]:\n                visited[next_clearing] = True\n                q.append((next_clearing, time + 1))\n                if next_clearing == N - 1:\n                    total_time += time + 1\n                    total_count += 1\n\n    return \"{:.6f}\".format(total_time / total_count)",
        "test": "",
        "num_ids": 263,
        "indeed": false
    },
    {
        "number": 2856,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, molecule = stdin.split('\\n')\n    N = int(N)\n    count_A = molecule.count('A')\n    count_B = N - count_A\n    if count_A == 0 or count_B == 0:\n        return str(N)\n    else:\n        return str(min(count_A, count_B))",
        "test": "",
        "num_ids": 92,
        "indeed": false
    },
    {
        "number": 2857,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2\n\n    def count_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n\n                    if (x1 == x2 and x2 == x3 and y1 == y2 and y2 == y3) or (x1 == x2 and y1 == y3) or (x1 == x3 and y1 == y2) or (x2 == x3 and y2 == y3):\n                        continue\n\n                    if is_right_triangle(x1, y1, x2, y2) and is_right_triangle(x2, y2, x3, y3) and is_right_triangle(x3, y3, x1, y1):\n                        count += 1\n        return count\n\n    N = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    return str(count_right_triangles(points))",
        "test": "",
        "num_ids": 337,
        "indeed": false
    },
    {
        "number": 2858,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    accusations = [int(x) for x in stdin.split('\\n')[1:]]\n\n    accused = [0] * (N + 1)\n    for acc in accusations:\n        accused[acc] += 1\n\n    max_mobsters = 0\n    for i in range(1, N + 1):\n        if accused[i] == N - 1:\n            max_mobsters += 1\n\n    return str(max_mobsters)",
        "test": "",
        "num_ids": 131,
        "indeed": false
    },
    {
        "number": 2859,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    particles = []\n    for i in range(3):\n        x, y = map(int, stdin.readline().split())\n        particles.append((x, y))\n    x_v, y_v, r = map(int, stdin.readline().split())\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def angle(p1, p2):\n        return math.atan2(p2[1] - p1[1], p2[0] - p1[0])\n\n    def move(particle, direction):\n        new_x = particle[0] + r * direction[0]\n        new_y = particle[1] + r * direction[1]\n        return (new_x, new_y)\n\n    def check_collision(p1, p2):\n        if distance(p1, p2) <= 2 * r:\n            return True\n        return False\n\n    def perpendicular(v):\n        return (-v[1], v[0])\n\n    def simulate():\n        for i in range(3):\n            for j in range(i + 1, 3):\n                if check_collision(particles[i], particles[j]):\n                    direction_i = perpendicular(angle(particles[i], particles[j]))\n                    direction_j = -perpendicular(direction_i)\n                    particles[i] = move(particles[i], direction_i)\n                    particles[j] = move(particles[j], direction_j)\n                    return i, j\n        return None\n\n    result = simulate()\n    if result is None:\n        return 5\n    elif result == (0, 1):\n        return 1\n    elif result == (0, 2):\n        return 2\n    elif result == (1, 2):\n        return 3\n    elif result == (0, 2):\n        return 4\n\n    return \"Invalid result\"",
        "test": "",
        "num_ids": 506,
        "indeed": false
    },
    {
        "number": 2860,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, w = map(int, stdin.split()[0:3])\n    lines = stdin.split('\\n')[1:]\n    words = []\n    for line in lines:\n        words += line.split('.')\n    words = [word for word in words if word != '']\n    current_line = ''\n    new_lines = []\n    for word in words:\n        if len(current_line) + len(word) + 1 <= w:\n            current_line += word + ' '\n        else:\n            new_lines.append(current_line[:-1])\n            current_line = word + ' '\n    new_lines.append(current_line[:-1])\n    return str(len(new_lines))",
        "test": "",
        "num_ids": 178,
        "indeed": false
    },
    {
        "number": 2861,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_quick_changes(routines):\n        dancers = set()\n        for routine in routines:\n            dancers.update(routine)\n        dancers = sorted(list(dancers))\n\n        quick_changes = 0\n        for i in range(len(dancers)):\n            for routine in routines:\n                if dancers[i] in routine:\n                    index = routine.index(dancers[i])\n                    for j in range(i + 1, len(dancers)):\n                        if dancers[j] in routine:\n                            quick_changes += index\n                            break\n                    break\n        return quick_changes\n\n    lines = stdin.split('\\n')\n    R = int(lines[0])\n    routines = [set(line) for line in lines[1:R + 1]]\n\n    min_quick_changes = float('inf')\n    for _ in range(R):\n        min_quick_changes = min(min_quick_changes, find_min_quick_changes(routines))\n        routines = routines[1:] + [routines[0]]\n\n    return str(min_quick_changes)",
        "test": "",
        "num_ids": 289,
        "indeed": false
    },
    {
        "number": 2862,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph, memo):\n        if node in memo:\n            return memo[node]\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(neighbor, visited, graph, memo)\n        memo[node] = visited.copy()\n        return memo[node]\n\n    def build_graph(crafting_recipes):\n        graph = {i: set() for i in range(N)}\n        for recipe in crafting_recipes:\n            u, v, w = recipe\n            graph[u].add(v)\n        return graph\n\n    def find_materials(needs, graph, memo):\n        total_materials = [0] * N\n        for i in range(N):\n            if needs[i]:\n                total_materials[i] += needs[i]\n                for j in dfs(i, set(), graph, memo):\n                    total_materials[j] += needs[i] * graph[i][j]\n        return total_materials\n\n    N, M = map(int, stdin.readline().split())\n    needs = list(map(int, stdin.readline().split()))\n    crafting_recipes = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    graph = build_graph(crafting_recipes)\n    memo = {}\n    total_materials = find_materials(needs, graph, memo)\n\n    return \" \".join(map(str, total_materials))",
        "test": "",
        "num_ids": 389,
        "indeed": false
    },
    {
        "number": 2863,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    emma, marcos = map(int, stdin.split())\n    emma_films = list(map(int, input().split()))\n    marcos_films = list(map(int, input().split()))\n\n    emma_pointer = 0\n    marcos_pointer = 0\n    count = 0\n\n    while emma_pointer < len(emma_films) and marcos_pointer < len(marcos_films):\n        if emma_films[emma_pointer] < marcos_films[marcos_pointer]:\n            if emma_pointer == 0 or marcos_films[marcos_pointer] != marcos_films[marcos_pointer - 1]:\n                count += 1\n                emma_pointer += 1\n            else:\n                emma_pointer += 1\n        elif marcos_films[marcos_pointer] < emma_films[emma_pointer]:\n            if marcos_pointer == 0 or emma_films[emma_pointer] != emma_films[emma_pointer - 1]:\n                count += 1\n                marcos_pointer += 1\n            else:\n                marcos_pointer += 1\n        else:\n            count += 1\n            emma_pointer += 1\n            marcos_pointer += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 328,
        "indeed": false
    },
    {
        "number": 2864,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_evidence(suggestion: str, responses: list) -> str:\n        evidence = \"\"\n        for response in responses:\n            if response == \"-\":\n                continue\n            elif response == \"*\":\n                evidence = suggestion[0]\n                break\n            else:\n                evidence = response\n                break\n        return evidence\n\n    def get_possible_solutions(cards: str, suggestions: list) -> set:\n        possible_solutions = set()\n        for person in cards[0]:\n            for weapon in cards[1]:\n                for room in cards[2]:\n                    possible_solutions.add(person + weapon + room)\n\n        for suggestion, responses in suggestions:\n            evidence = get_evidence(suggestion, responses)\n            if evidence:\n                for solution in list(possible_solutions):\n                    if evidence not in solution:\n                        possible_solutions.remove(solution)\n\n        return possible_solutions\n\n    def get_closest_solution(possible_solutions: set) -> str:\n        closest_solution = \"E??\"\n        if len(possible_solutions) == 1:\n            closest_solution = list(possible_solutions)[0]\n        elif len(possible_solutions) > 1:\n            for person in \"ABCDEF\":\n                for weapon in \"GHILMN\":\n                    for room in \"OPQRSTU\":\n                        solution = person + weapon + room\n                        if solution in possible_solutions:\n                            closest_solution = solution\n                            break\n        return closest_solution\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    cards = lines[1].split()\n    suggestions = []\n    for i in range(2, n + 2):\n        suggestion = lines[i][:3]\n        responses = lines[i][3:].split()\n        suggestions.append((suggestion, responses))\n\n    possible_solutions = get_possible_solutions(cards, suggestions)\n    closest_solution = get_closest_solution(possible_solutions)\n\n    return closest_solution",
        "test": "",
        "num_ids": 510,
        "indeed": false
    },
    {
        "number": 2865,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    X1, X2, N1, T1, T2, N2, T3, T4 = map(int, stdin.split())\n    T1 = [T1, T2]\n    T2 = [T3, T4]\n    T1.sort()\n    T2.sort()\n    i = j = 0\n    while i < len(T1) and j < len(T2):\n        if T1[i] < T2[j]:\n            i += 1\n        elif T1[i] > T2[j]:\n            j += 1\n        else:\n            if T1[i] % 2 == 0 and T2[j] % 2 == 0:\n                return f\"bumper tap at time {T1[i] + 1}\"\n            i += 1\n            j += 1\n    return \"safe and sound\"",
        "test": "",
        "num_ids": 211,
        "indeed": false
    },
    {
        "number": 2866,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = sorted(set(stdin))\n    numbers = []\n    for i in range(1, len(digits) + 1):\n        for p in permutations(digits, i):\n            num = int(\"\".join(p))\n            if num not in numbers:\n                numbers.append(num)\n    numbers.sort()\n    for i, num in enumerate(numbers, 1):\n        if i != num:\n            return str(i)\n    return str(len(numbers) + 1)",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 2867,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(x):\n        factors = []\n        for i in range(2, x + 1):\n            if is_prime(i) and x % i == 0:\n                factors.append(i)\n        return factors\n\n    def get_happiness(p, c):\n        factors = prime_factors(p)\n        happiness = 0\n        for factor in factors:\n            happiness += c[factor - 1]\n        return happiness\n\n    def get_total_happiness(N, V, C):\n        total_happiness = sum(V)\n        for i in range(1, N + 1):\n            total_happiness -= get_happiness(i, C)\n        return total_happiness\n\n    N, V, C = map(int, stdin.split())\n    V = list(map(int, V.split()))\n    C = list(map(int, C.split()))\n\n    return str(get_total_happiness(N, V, C))",
        "test": "",
        "num_ids": 309,
        "indeed": false
    },
    {
        "number": 2868,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, word = map(str, stdin.split('\\n'))\n    x = int(x)\n    n = len(word)\n    for _ in range(x):\n        temp = word[n-1]\n        for i in range(n-2, -1, -1):\n            word[i+1] = word[i]\n        word[0] = temp\n    return ''.join(word)",
        "test": "",
        "num_ids": 100,
        "indeed": false
    },
    {
        "number": 2869,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    roman_dict = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n\n    def roman_to_int(roman: str) -> int:\n        result = 0\n        prev_value = 0\n        for char in roman:\n            value = roman_dict[char]\n            if value > prev_value:\n                result += value - 2 * prev_value\n            else:\n                result += value\n            prev_value = value\n        return result\n\n    def int_to_roman(num: int) -> str:\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syb = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        roman_num = ''\n        i = 0\n        while num > 0:\n            for _ in range(num // val[i]):\n                roman_num += syb[i]\n                num -= val[i]\n            i += 1\n        return roman_num\n\n    num = roman_to_int(stdin)\n    return int_to_roman(num)",
        "test": "",
        "num_ids": 398,
        "indeed": false
    },
    {
        "number": 2870,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    if p == 1:\n        return str(q - 1)\n    elif q == 1:\n        return str(p - 1)\n    else:\n        return \"0\"",
        "test": "",
        "num_ids": 62,
        "indeed": false
    },
    {
        "number": 2871,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    skills = list(map(int, stdin.readline().split()))\n\n    sorted_skills = sorted(skills)\n    min_time = 0\n\n    for i in range(0, N, K):\n        for j in range(i, i + K):\n            if skills[j] != sorted_skills[i + K - 1 - (j - i)]:\n                min_time += 1\n                skills[j], skills[i + K - 1 - (j - i)] = skills[i + K - 1 - (j - i)], skills[j]\n\n    return str(min_time)",
        "test": "",
        "num_ids": 169,
        "indeed": false
    },
    {
        "number": 2872,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    today, day_of_jan = stdin.split('\\n')\n    day, month = today.split()\n    days_of_week = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']\n    days_of_feb = ['29']\n    feb_day = 29\n    feb_month = 'FEB'\n    jan_day = 1\n    jan_month = 'JAN'\n    feb_leap = False\n\n    if month == 'FEB' and day == feb_day:\n        if day_of_jan == 'MON':\n            feb_leap = True\n        else:\n            feb_leap = False\n    elif month == 'JAN' and day == jan_day and day_of_jan == 'FRI':\n        feb_leap = True\n    else:\n        feb_leap = False\n\n    if feb_leap:\n        return 'TGIF'\n    else:\n        return ':( '",
        "test": "",
        "num_ids": 243,
        "indeed": false
    },
    {
        "number": 2873,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    stdin = stdin.replace(\"_\", \"L\")\n    count = 0\n\n    def is_pleasant(word: str) -> bool:\n        if \"LLL\" in word:\n            return False\n        if \"____\" in word:\n            return False\n        vowel_count = 0\n        consonant_count = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                vowel_count += 1\n                consonant_count = 0\n            else:\n                consonant_count += 1\n                vowel_count = 0\n            if vowel_count >= 3 or consonant_count >= 3:\n                return False\n        return True\n\n    def generate_words(word: str, index: int, words: set):\n        if index == len(word):\n            if is_pleasant(word):\n                words.add(word)\n            return\n        if word[index] == \"_\":\n            for letter in consonants:\n                generate_words(word[:index] + letter + word[index + 1:], index + 1, words)\n        else:\n            generate_words(word, index + 1, words)\n\n    words = set()\n    generate_words(stdin, 0, words)\n    return str(len(words))",
        "test": "",
        "num_ids": 357,
        "indeed": false
    },
    {
        "number": 2874,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    t = list(map(int, stdin.readline().split()))\n\n    p.sort()\n    t.sort()\n\n    i = j = 0\n    count = 0\n\n    while i < n and j < m:\n        if abs(p[i] - t[j]) < abs(p[i] - t[j + 1]):\n            count += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 2875,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, arr = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    start, end = -1, -1\n    min_val = arr[0]\n    max_val = arr[-1]\n    for i in range(1, n):\n        if arr[i] < min_val:\n            start = i\n            break\n        min_val = arr[i]\n    for i in range(n - 2, -1, -1):\n        if arr[i] > max_val:\n            end = i\n            break\n        max_val = arr[i]\n    if start != -1 and end != -1:\n        return f\"{start + 1} {end + 1}\"\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 192,
        "indeed": false
    },
    {
        "number": 2876,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_lipschitz_constant(points):\n        points.sort()\n        max_diff = 0\n        for i in range(len(points) - 1):\n            x1, y1 = points[i]\n            x2, y2 = points[i + 1]\n            diff = abs(y2 - y1) / abs(x2 - x1)\n            max_diff = max(max_diff, diff)\n        return max_diff\n\n    input_data = list(map(lambda x: tuple(map(int, x.split())), stdin.split('\\n')[1:]))\n    lipschitz_constant = find_lipschitz_constant(input_data)\n    return str(lipschitz_constant)",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 2877,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin\n    length = len(word)\n    mid = length // 2\n\n    first_part = word[:mid]\n    second_part = word[mid:]\n\n    first_part = first_part[::-1]\n    second_part = second_part[::-1]\n\n    return first_part + second_part",
        "test": "",
        "num_ids": 84,
        "indeed": false
    },
    {
        "number": 2878,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    grid = []\n    for _ in range(n):\n        grid.append(list(stdin.readline().strip()))\n\n    def is_valid(x1, y1, x2, y2, x3, y3):\n        return (x1 == x2 == x3) or (y1 == y2 == y3) or (abs(x1 - x2) == abs(y1 - y2) == abs(x2 - x3) == abs(y2 - y3))\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if grid[i][j] != '.' and grid[i][k] != '.' and grid[j][k] != '.':\n                    count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 213,
        "indeed": false
    },
    {
        "number": 2879,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.readline().strip().split())\n    matrix = []\n    for _ in range(h):\n        matrix.append(list(stdin.readline().strip()))\n\n    def is_valid(matrix, h, w):\n        for i in range(h):\n            for j in range(w):\n                if matrix[i][j] == 'X':\n                    if i > 0 and matrix[i - 1][j] == 'X':\n                        return False\n                    if j > 0 and matrix[i][j - 1] == 'X':\n                        return False\n        return True\n\n    def find_power(matrix, h, w):\n        for k in range(2, 6):\n            for i in range(h):\n                for j in range(w):\n                    if matrix[i][j] == 'X':\n                        piece = [i, j]\n                        for _ in range(k - 1):\n                            for new_i in range(i - 1, i + 2):\n                                for new_j in range(j - 1, j + 2):\n                                    if 0 <= new_i < h and 0 <= new_j < w and matrix[new_i][new_j] == 'X' and [new_i, new_j] != piece:\n                                        piece.append([new_i, new_j])\n                        if len(piece) == k:\n                            for p in piece:\n                                matrix[p[0]][p[1]] = str(piece.index(p) + 1)\n                            if is_valid(matrix, h, w):\n                                return matrix\n        return \"No solution\"\n\n    return find_power(matrix, h, w)",
        "test": "",
        "num_ids": 429,
        "indeed": false
    },
    {
        "number": 2880,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    matrix = [stdin.readline().strip() for _ in range(R)]\n\n    def is_valid(matrix, row):\n        for i in range(row, R):\n            for j in range(C):\n                if matrix[row][j] != matrix[i][j]:\n                    return True\n        return False\n\n    max_rows = 0\n    for i in range(R):\n        if is_valid(matrix, i):\n            max_rows = i\n            break\n\n    return str(max_rows)",
        "test": "",
        "num_ids": 145,
        "indeed": false
    },
    {
        "number": 2881,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(str, stdin.split())\n    x_digits = [int(d) for d in x]\n    y_digits = [int(d) for d in y]\n\n    def get_match_pattern(digit):\n        match_patterns = {\n            0: [\n                [1, 1, 1, 0, 1, 1, 0],\n                [0, 1, 0, 1, 0, 1, 0],\n                [0, 1, 0, 1, 0, 1, 0],\n                [0, 1, 0, 1, 0, 1, 0],\n                [1, 1, 1, 0, 1, 1, 0],\n                [1, 1, 1, 0, 1, 1, 0],\n                [1, 1, 1, 0, 1, 1, 0]\n            ],\n            1: [\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0]\n            ],\n            2: [\n                [1, 1, 1, 0, 1, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [1, 1, 1, 0, 0, 1, 0],\n                [1, 0, 0, 1, 0, 1, 0],\n                [1, 1, 1, 0, 0, 1, 0],\n                [1, 1, 1, 0, 1, 1, 0]\n            ],\n            3: [\n                [1, 1, 1, 0, 1, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [1, 1, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [1, 1, 1, 0, 1, 1, 0]\n            ],\n            4: [\n                [1, 0, 1, 0, 1, 0, 0],\n                [1, 0, 1, 0, 1, 0, 0],\n                [1, 0, 1, 0, 1, 0, 0],\n                [1, 1, 1, 0, 1, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1, 0]\n            ],\n            5: [\n                [1, 1, 1, 0, 1, 1, 0],\n                [1, 0, 0, 1, 0, 1, 0],\n                [1, 0, 0, 1, 0, 1, 0],\n                [1, 1, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0",
        "test": "",
        "num_ids": 1025,
        "indeed": false
    },
    {
        "number": 2882,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    def generateParenthesis(n):\n        ans = []\n        def backtrack(S = '', left = 0, right = 0):\n            if len(S) == 2 * n:\n                ans.append(S)\n                return\n            if left < n:\n                backtrack(S+'(', left+1, right)\n            if right < left:\n                backtrack(S+')', left, right+1)\n        backtrack()\n        return ans\n    return generateParenthesis(n) ",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 2883,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = eval(stdin)\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return str(merged)",
        "test": "",
        "num_ids": 96,
        "indeed": false
    },
    {
        "number": 2884,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_combinations(candidates, target, start, comb, result):\n        if target == 0:\n            result.append(list(comb))\n            return\n        for i in range(start, len(candidates)):\n            if target < candidates[i]:\n                break\n            comb.append(candidates[i])\n            find_combinations(candidates, target - candidates[i], i + 1, comb, result)\n            comb.pop()\n\n    input_data = list(map(int, stdin.split()))\n    target = input_data[0]\n    candidates = input_data[1:]\n    result = []\n    candidates.sort()\n    find_combinations(candidates, target, 0, [], result)\n    return result",
        "test": "",
        "num_ids": 188,
        "indeed": false
    },
    {
        "number": 2885,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals, newInterval = eval(stdin)\n    result = []\n    i = 0\n    while i < len(intervals) and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(intervals[i][0], newInterval[0])\n        newInterval[1] = max(intervals[i][1], newInterval[1])\n        i += 1\n    result.append(newInterval)\n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    return str(result)",
        "test": "",
        "num_ids": 180,
        "indeed": true
    },
    {
        "number": 2886,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n\n    def is_unbalanced(t: str) -> bool:\n        freq = [0] * 26\n        for c in t:\n            freq[ord(c) - ord('a')] += 1\n        freq = [f for f in freq if f > 0]\n        return len(t) >= 2 and max(freq) > len(t) // 2\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_unbalanced(s[i:j]):\n                return f\"{i + 1} {j}\"\n\n    return \"-1 -1\"",
        "test": "",
        "num_ids": 180,
        "indeed": false
    },
    {
        "number": 2887,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    V = list(map(int, stdin.split('\\n')[1].split()))\n    T = list(map(int, stdin.split('\\n')[2].split()))\n\n    evaporated_volume = []\n\n    for i in range(N):\n        if i == 0:\n            evaporated_volume.append(V[0] - T[0])\n        else:\n            evaporated_volume.append(V[i] - T[i] + evaporated_volume[i - 1])\n\n    return ' '.join(map(str, evaporated_volume))",
        "test": "",
        "num_ids": 158,
        "indeed": false
    },
    {
        "number": 2888,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_strength(n: int, sin: int, e: List[int], max_strength: int) -> int:\n        for i in range(n):\n            max_strength = max(max_strength, sin * e[i])\n            max_strength = max(max_strength, sin + (sin // 10) ** 3)\n            sin = max_strength\n        return max_strength\n\n    n, sin = map(int, stdin.split())\n    e = list(map(int, input().split()))\n\n    max_strength = get_max_strength(n, sin, e, 0)\n    return str(max_strength)",
        "test": "",
        "num_ids": 170,
        "indeed": false
    },
    {
        "number": 2889,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_cut_lawn(lawn_size, cutting_rate, cutting_time, recharge_time, week_duration):\n        cuts_per_week = 0\n        time_elapsed = 0\n        while time_elapsed < week_duration:\n            if time_elapsed + cutting_time <= week_duration:\n                cuts_per_week += cutting_rate * cutting_time\n                time_elapsed += cutting_time\n            else:\n                remaining_time = week_duration - time_elapsed\n                cuts_per_week += cutting_rate * remaining_time\n                time_elapsed += remaining_time\n            time_elapsed += recharge_time\n        return cuts_per_week >= lawn_size\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        lawn_size, num_mowers = map(int, lines[0].split())\n        mowers = []\n        for i in range(1, num_mowers + 1):\n            name, price, cutting_rate, cutting_time, recharge_time = lines[i].split(',')\n            price, cutting_rate, cutting_time, recharge_time = map(int, [price, cutting_rate, cutting_time, recharge_time])\n            mowers.append((name, price, cutting_rate, cutting_time, recharge_time))\n        return lawn_size, mowers\n\n    lawn_size, mowers = parse_input(stdin)\n    week_duration = 10080\n    cheapest_mowers = []\n    min_price = float('inf')\n\n    for mower in mowers:\n        name, price, cutting_rate, cutting_time, recharge_time = mower\n        if can_cut_lawn(lawn_size, cutting_rate, cutting_time, recharge_time, week_duration):\n            if price < min_price:\n                min_price = price\n                cheapest_mowers = [name]\n            elif price == min_price:\n                cheapest_mowers.append(name)\n\n    if not cheapest_mowers:\n        return \"no such mower\"\n    else:\n        return '\\n'.join(cheapest_mowers)",
        "test": "",
        "num_ids": 550,
        "indeed": true
    },
    {
        "number": 2890,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, cnt_red, cnt_blue):\n        if u == T:\n            return 0\n        if (u, cnt_red, cnt_blue) in visited:\n            return -1\n        visited.add((u, cnt_red, cnt_blue))\n        for v, t, c in graph[u]:\n            if c == 0 or (c == 1 and cnt_red > 0) or (c == 2 and cnt_blue > 0):\n                time = dfs(v, cnt_red - (c == 1), cnt_blue - (c == 2))\n                if time != -1:\n                    return max(time, t)\n        return -1\n\n    N, M, k1, k2, *data = map(int, stdin.split())\n    S, T = data[-2:]\n    graph = [[] for _ in range(N + 1)]\n    for i in range(M):\n        u, v, t, c = data[i]\n        graph[u].append((v, t, c))\n        graph[v].append((u, t, c))\n\n    visited = set()\n    time = dfs(S, k1, k2)\n    return str(time) if time != -1 else \"-1\"",
        "test": "",
        "num_ids": 317,
        "indeed": false
    },
    {
        "number": 2891,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = list(map(int, stdin.split()))\n    p = sum(c)\n    b = 1\n    for i in range(p):\n        b *= (365 - i) / 365\n    b *= (365 ** (n - p))\n    b *= (1 - (365 ** n))\n    return f\"{round(math.log10(b), 10):.10f}\"",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 2892,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dolls = list(map(int, stdin.readline().strip().split()))\n\n    def combine_sets(dolls: List[int]) -> int:\n        sets = []\n        current_set = [dolls[0]]\n\n        for i in range(1, len(dolls)):\n            if dolls[i] == current_set[-1] + 1:\n                current_set.append(dolls[i])\n            else:\n                sets.append(current_set)\n                current_set = [dolls[i]]\n\n        sets.append(current_set)\n\n        openings = 0\n        for i in range(len(sets) - 1):\n            if sets[i][-1] + 1 == sets[i + 1][0]:\n                openings += 1\n\n        return openings\n\n    def is_valid(dolls: List[int]) -> bool:\n        for i in range(1, len(dolls)):\n            if dolls[i] <= dolls[i - 1]:\n                return False\n        return True\n\n    if is_valid(dolls):\n        return combine_sets(dolls)\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 312,
        "indeed": false
    },
    {
        "number": 2893,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1:]]\n    op = 0\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            a[i], a[min_idx] = a[min_idx], a[i]\n            op += 1\n    return str(op)",
        "test": "",
        "num_ids": 140,
        "indeed": false
    },
    {
        "number": 2894,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, K, T1, T2, H = map(float, stdin.split())\n\n    # Calculate the water level without leak\n    h_no_leak = H - L\n\n    # Calculate the time it takes for the water to drain\n    t_drain = (h_no_leak / K) * 3600\n\n    # Calculate the rainfall without leak\n    f_no_leak = (h_no_leak * 3600) / T1\n\n    # Calculate the smallest and largest rainfall with leak\n    f_min = f_no_leak - (t_drain * K / 3600)\n    f_max = f_no_leak + (T2 * K / 3600)\n\n    return f\"{f_min:.6f} {f_max:.6f}\"",
        "test": "",
        "num_ids": 215,
        "indeed": false
    },
    {
        "number": 2895,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, x_f, y_f = map(float, stdin.split()[:4])\n    n = int(stdin.split()[4])\n    y_coords = list(map(float, stdin.split()[5:n+5]))\n    speeds = list(map(float, stdin.split()[n+5:]))\n\n    total_time = 0\n    current_x = x_s\n    current_y = y_s\n\n    for i in range(n):\n        if i == 0:\n            current_y = y_s\n        else:\n            current_y = y_coords[i-1]\n\n        if i == n-1:\n            current_y = y_f\n        else:\n            current_y = y_coords[i]\n\n        distance = ((current_x - x_f)**2 + (current_y - y_f)**2)**0.5\n        time = distance / speeds[i]\n        total_time += time\n\n    return f\"{total_time:.6f}\"",
        "test": "",
        "num_ids": 267,
        "indeed": false
    },
    {
        "number": 2896,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    before, after = stdin.split('\\n')\n    min_len = len(after)\n\n    for i in range(len(before)):\n        for j in range(i, len(before)):\n            if before[i:j+1] == after[i:j+1]:\n                min_len = min(min_len, len(before[j+1:]))\n                break\n            elif before[i:j+1] == after[-(j-i+1):]:\n                min_len = min(min_len, len(before[:i]))\n                break\n\n    return str(min_len)",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2897,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r1, c1, r2, c2, map):\n        visited = [[False for _ in range(c)] for _ in range(r)]\n        visited[r1 - 1][c1 - 1] = True\n        q = [(r1 - 1, c1 - 1)]\n\n        while q:\n            row, col = q.pop(0)\n            if row == r2 - 1 and col == c2 - 1:\n                return True\n\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < r and 0 <= new_col < c and not visited[new_row][new_col] and map[new_row][new_col] == map[row][col]:\n                    visited[new_row][new_col] = True\n                    q.append((new_row, new_col))\n\n        return False\n\n    lines = stdin.split('\\n')\n    r, c = map(int, lines[0].split())\n    map = [list(line) for line in lines[1:r + 1]]\n    n = int(lines[r + 1])\n    queries = [list(map(int, line.split())) for line in lines[r + 2:]]\n\n    result = []\n    for query in queries:\n        r1, c1, r2, c2 = query\n        if is_valid(r1, c1, r2, c2, map):\n            if map[r1 - 1][c1 - 1] == '0':\n                result.append('binary')\n            else:\n                result.append('decimal')\n        else:\n            result.append('neither')\n\n    return '\\n'.join(result)",
        "test": "",
        "num_ids": 459,
        "indeed": false
    },
    {
        "number": 2898,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    drives = []\n    for i in range(1, n + 1):\n        a, b = map(int, lines[i].split())\n        drives.append((a, b))\n    drives.sort(key=lambda x: x[0] - x[1], reverse=True)\n    extra_capacity = 0\n    for i in range(n):\n        extra_capacity += drives[i][0] - drives[i][1]\n    return str(extra_capacity)",
        "test": "",
        "num_ids": 139,
        "indeed": false
    },
    {
        "number": 2899,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_frequencies(n: int, edges: List[List[int]]) -> List[int]:\n        def dfs(node: int, parent: int, frequencies: List[int]) -> None:\n            if len(frequencies) == 2:\n                return\n            for neighbor in neighbors[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node, frequencies)\n                    if len(frequencies) == 2:\n                        return\n                    frequencies.append(node + neighbor)\n\n        neighbors = [[] for _ in range(n)]\n        for u, v in edges:\n            neighbors[u - 1].append(v - 1)\n            neighbors[v - 1].append(u - 1)\n\n        frequencies = []\n        dfs(0, -1, frequencies)\n        return frequencies\n\n    def assign_frequencies(n: int, frequencies: List[int]) -> List[Tuple[int, int]]:\n        assignments = []\n        for i in range(n):\n            if i == 0:\n                assignments.append((frequencies[0], frequencies[1]))\n            elif i == n - 1:\n                assignments.append((frequencies[1], frequencies[0]))\n            else:\n                assignments.append((frequencies[i], frequencies[i - 1]))\n        return assignments\n\n    n, *edges = map(int, stdin.split())\n    max_frequencies = find_max_frequencies(n, [edges[i:i + 2] for i in range(0, len(edges), 2)])\n    frequency_assignments = assign_frequencies(n, max_frequencies)\n    return \"\\n\".join(\" \".join(map(str, assignment)) for assignment in frequency_assignments)",
        "test": "",
        "num_ids": 444,
        "indeed": false
    },
    {
        "number": 2900,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    inversions = [0] * (n - 1)\n\n    for i in range(n - 1):\n        if s[i] == 'B' and s[i + 1] == 'A':\n            for k in range(i + 2, n + 1):\n                if k - i == k:\n                    inversions[k - 2] += 1\n\n    return '\\n'.join(map(str, inversions))",
        "test": "",
        "num_ids": 122,
        "indeed": false
    },
    {
        "number": 2901,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_synergy_score(player1, player2):\n        if player1[1] == player2[1] and player1[2] == player2[2] and player1[3] == player2[3]:\n            return 3\n        elif player1[1] == player2[1] and player1[2] == player2[2]:\n            return 2\n        elif player1[1] == player2[1] or player1[2] == player2[2] or player1[3] == player2[3]:\n            return 1\n        else:\n            return 0\n\n    def is_perfect_team(formation, players):\n        for i in range(10):\n            degree = 0\n            synergy = 0\n            for j in range(10):\n                if formation[i][j] == 1:\n                    degree += 1\n                    synergy += get_synergy_score(players[i], players[j])\n            if synergy < degree:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    num_edges = int(lines[0])\n    formation = [[0] * 10 for _ in range(10)]\n    for i in range(1, num_edges + 1):\n        a, b = map(int, lines[i].split())\n        formation[a][b] = 1\n        formation[b][a] = 1\n\n    players = []\n    for i in range(num_edges + 1, num_edges + 11):\n        name, nation, league, team = lines[i].split()\n        players.append((name, nation, league, team))\n\n    if is_perfect_team(formation, players):\n        return 'yes'\n    else:\n        return 'no'",
        "test": "",
        "num_ids": 444,
        "indeed": true
    },
    {
        "number": 2902,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def ceil_div(a, b):\n        return -(-a // b)\n\n    def floor_div(a, b):\n        return a // b\n\n    def get_next_day(farms):\n        next_day = []\n        for cows in farms:\n            if cows > C:\n                next_day.append(floor_div(cows, 2))\n                next_day.append(ceil_div(cows, 2))\n            else:\n                next_day.append(cows)\n        return next_day\n\n    def get_inspected_farms(farms):\n        return sum(1 for cows in farms if cows > 0)\n\n    C, N, M = map(int, stdin.readline().split())\n    farms = [int(x) for x in stdin.readline().split()]\n    regulator_days = [int(x) for x in stdin.readline().split()]\n\n    inspected_farms = [get_inspected_farms(farms)]\n    for _ in range(M - 1):\n        farms = get_next_day(farms)\n        inspected_farms.append(get_inspected_farms(farms))\n\n    return \"\\n\".join(map(str, inspected_farms))",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 2903,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def update(index, value):\n        while index < len(tree):\n            tree[index] += value\n            index += index & -index\n\n    def prefix_sum(index):\n        result = 0\n        while index > 0:\n            result += tree[index]\n            index -= index & -index\n        return result\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    tree = [0] * (N + 1)\n    result = []\n\n    for i in range(1, Q + 1):\n        query = lines[i].split()\n        if query[0] == '+':\n            index, value = int(query[1]), int(query[2])\n            update(index + 1, value)\n        elif query[0] == '?':\n            index = int(query[1])\n            result.append(prefix_sum(index + 1))\n\n    return '\\n'.join(map(str, result))",
        "test": "",
        "num_ids": 242,
        "indeed": false
    },
    {
        "number": 2904,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_empty_cell(grid, rows, cols):\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == '-':\n                    return i, j\n        return None\n\n    def is_valid(grid, rows, cols, row, col, num):\n        for i in range(rows):\n            if grid[row][i] == num:\n                return False\n        for i in range(cols):\n            if grid[i][col] == num:\n                return False\n        start_row, start_col = row - row % 3, col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if grid[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve(grid, rows, cols):\n        empty_cell = find_empty_cell(grid, rows, cols)\n        if not empty_cell:\n            return True\n        row, col = empty_cell\n        for num in range(1, rows + 1):\n            if is_valid(grid, rows, cols, row, col, str(num)):\n                grid[row][col] = str(num)\n                if solve(grid, rows, cols):\n                    return True\n                grid[row][col] = '-'\n        return False\n\n    def main(stdin: str) -> str:\n        rows, cols = map(int, stdin.split()[:2])\n        grid = [list(input().split()) for _ in range(rows)]\n        regions = int(input())\n        for _ in range(regions):\n            region_cells = list(map(int, input().split()[1:]))\n            region_cells = [(cell // cols, cell % cols) for cell in region_cells]\n            for cell1 in region_cells:\n                for cell2 in region_cells:\n                    if cell1 != cell2:\n                        grid[cell1[0]][cell1[1]] = str(abs(grid[cell1[0]][cell1[1]] - grid[cell2[0]][cell2[1]]) + 1)\n\n        solve(grid, rows, cols)\n        return '\\n'.join([' '.join(row) for row in grid])\n\n    return main(stdin) ",
        "test": "",
        "num_ids": 563,
        "indeed": false
    },
    {
        "number": 2905,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    H, h_packs = stdin.split('\\n')\n    H = int(H)\n    h_packs = list(map(int, h_packs.split()))\n    B, b_packs = stdin.split('\\n')\n    B = int(B)\n    b_packs = list(map(int, b_packs.split()))\n\n    # Calculate total hotdogs and buns\n    total_hotdogs = sum(h_packs)\n    total_buns = sum(b_packs)\n\n    # Check if it's impossible\n    if total_hotdogs % total_buns != 0 and total_buns % total_hotdogs != 0:\n        return \"impossible\"\n\n    # Calculate the minimum number of packs\n    min_packs = float('inf')\n    for h_pack in h_packs:\n        for b_pack in b_packs:\n            packs = ceil(total_hotdogs / h_pack) + ceil(total_buns / b_pack)\n            min_packs = min(min_packs, packs)\n\n    return min_packs",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 2906,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(neighbor, visited, graph)\n\n    N, M = map(int, stdin.readline().split())\n    graph = {i: set() for i in range(1, N + 1)}\n\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].add(b)\n        graph[b].add(a)\n\n    visited = set()\n    for i in range(1, N + 1):\n        dfs(i, visited, graph)\n\n    if len(visited) == N:\n        targets = [0] * N\n        for i in range(1, N + 1):\n            for j in graph[i]:\n                if targets[i - 1] == 0:\n                    targets[i - 1] = j\n                else:\n                    targets[i - 1], targets[j - 1] = targets[j - 1], targets[i - 1]\n        return \"\\n\".join(map(str, targets))\n    else:\n        return \"Impossible\"",
        "test": "",
        "num_ids": 302,
        "indeed": false
    },
    {
        "number": 2907,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    offset, message, steps = map(int, stdin.split())\n    vowels = \"aeiouy\"\n    encoded_message = message\n\n    for _ in range(steps):\n        encoded_message = \"\".join(\n            chr(((ord(char) - ord(\"a\") + offset) % 26) + ord(\"a\")) if char.isalpha() else char\n            for char in encoded_message\n        )\n\n        vowel_count = sum(1 for char in encoded_message if char in vowels)\n        consonant_count = len(encoded_message) - vowel_count\n\n        if vowel_count >= consonant_count:\n            return \"Colleague\"\n\n    return \"Boris\"",
        "test": "",
        "num_ids": 177,
        "indeed": false
    },
    {
        "number": 2908,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    cards = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cards[i] + cards[j] == s:\n                return \"YES\"\n            elif cards[i] + cards[j][::-1] == s:\n                return \"YES\"\n            elif cards[i][::-1] + cards[j] == s:\n                return \"YES\"\n            elif cards[i][::-1] + cards[j][::-1] == s:\n                return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 161,
        "indeed": false
    },
    {
        "number": 2909,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    line = list(map(int, stdin.split('\\n')[1].split()))\n    target = list(map(int, stdin.split('\\n')[2].split()))\n\n    def rotate(arr, i):\n        return arr[i:] + arr[:i]\n\n    for i in range(N):\n        if line != target:\n            for j in range(N - 2):\n                if line[j:j + 3] == target[j:j + 3]:\n                    continue\n                else:\n                    line = rotate(line, j + 1)\n                    break\n            else:\n                return \"Impossible\"\n        else:\n            return \"Possible\"\n\n    return \"Possible\"",
        "test": "",
        "num_ids": 187,
        "indeed": false
    },
    {
        "number": 2910,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    B = list(map(int, stdin.split('\\n')[2].split()))\n\n    yellow_area = 0\n    pink_area = 0\n    white_area = 0\n\n    for i in range(n):\n        for j in range(n):\n            color = (i + j) % 3\n            if color == 0:\n                yellow_area += A[i] * B[j]\n            elif color == 1:\n                pink_area += A[i] * B[j]\n            else:\n                white_area += A[i] * B[j]\n\n    return f\"{yellow_area} {pink_area} {white_area}\"",
        "test": "",
        "num_ids": 203,
        "indeed": false
    },
    {
        "number": 2911,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.readline().split())\n    times = list(map(int, stdin.readlines()))\n\n    total_time = sum(times)\n    p = 1\n\n    for i in range(n):\n        p *= (1 - (1 / (t - total_time + 1)))\n        p = p % 998244353\n        total_time -= 1\n\n    return str(p * t**n % 998244353)",
        "test": "",
        "num_ids": 130,
        "indeed": false
    },
    {
        "number": 2912,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    strings = lines[1:n+1]\n    operations = [list(map(int, line.split())) for line in lines[n+1:]]\n\n    for a, b in operations:\n        strings[a-1] += strings[b-1]\n        strings[b-1] = \"\"\n\n    return strings[0]",
        "test": "",
        "num_ids": 102,
        "indeed": false
    },
    {
        "number": 2913,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split()[:3])\n    grid = [list(map(str, input().split())) for _ in range(n)]\n\n    def is_clear_path(x1, y1, x2, y2):\n        dx, dy = abs(x2 - x1), abs(y2 - y1)\n        if dx != dy:\n            return False\n        for i in range(dx):\n            if grid[x1 + (x2 - x1) // dx * i][y1 + (y2 - y1) // dy * i] != '.':\n                return False\n        return True\n\n    if is_clear_path(c - 1, r - 1, n - 1, 0):\n        return \"YES\"\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                if is_clear_path(c - 1, r - 1, i, j) and is_clear_path(i, j, n - 1, 0):\n                    return \"YES\"\n\n    return \"NO\"",
        "test": "",
        "num_ids": 274,
        "indeed": false
    },
    {
        "number": 2914,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    total_combinations = 0\n    winning_combinations = 0\n\n    for i in range(k, s + 1):\n        total_combinations += comb(s, i) * comb(n - 1, i - 1)\n\n    for i in range(k, s + 1):\n        winning_combinations += comb(s, i) * comb(n - 1, i - 1)\n\n    probability = winning_combinations / total_combinations\n    return format(probability, \".9f\")\n\ndef",
        "test": "",
        "num_ids": 153,
        "indeed": false
    },
    {
        "number": 2915,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, x2):\n        return abs(x2 - x1) * 2\n\n    def min_distance(locations, capacity):\n        locations.sort(key=lambda x: x[0])\n        total_distance = 0\n        current_capacity = 0\n        current_location = 0\n\n        for location, letters in locations:\n            if current_capacity + letters <= capacity:\n                current_capacity += letters\n            else:\n                total_distance += distance(locations[current_location][0], location)\n                current_location = locations.index((location, letters))\n                current_capacity = letters\n\n        total_distance += distance(locations[current_location][0], 0)\n        return total_distance\n\n    N, K = map(int, stdin.split())\n    locations = []\n\n    for _ in range(N):\n        x, t = map(int, input().split())\n        locations.append((x, t))\n\n    return str(min_distance(locations, K))",
        "test": "",
        "num_ids": 251,
        "indeed": false
    },
    {
        "number": 2916,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        N = int(lines[0])\n        islands = []\n        for i in range(1, N + 1):\n            line = lines[i].split()\n            T_i, K_i = map(int, line[:2])\n            goods_providers = []\n            for j in range(K_i):\n                S_ij, V_ij = map(int, line[2 + 2 * j:4 + 2 * j])\n                goods_providers.append((S_ij, V_ij))\n            islands.append((T_i, goods_providers))\n        return N, islands\n\n    def simulate_collapse(N: int, islands: list) -> set:\n        surviving_islands = set(range(1, N + 1))\n        queue = [1]\n        while queue:\n            collapsing_island = queue.pop(0)\n            if collapsing_island in surviving_islands:\n                surviving_islands.remove(collapsing_island)\n                for provider_island, amount in islands[collapsing_island - 1][1]:\n                    if provider_island in surviving_islands:\n                        queue.append(provider_island)\n        return surviving_islands\n\n    N, islands = read_input(stdin)\n    surviving_islands = simulate_collapse(N, islands)\n    return str(len(surviving_islands))",
        "test": "",
        "num_ids": 371,
        "indeed": false
    },
    {
        "number": 2917,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    C = [1, 1]\n    S = [1]\n\n    for i in range(2, n + 1):\n        C.append((4 * i - 2) * C[i - 1] // (i + 1))\n\n    for i in range(1, n + 1):\n        S.append(sum(C[k] * C[i - k] for k in range(i + 1)))\n\n    return str(S[n])",
        "test": "",
        "num_ids": 124,
        "indeed": true
    },
    {
        "number": 2918,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_win(start, end, visited, graph):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for i in range(n):\n            if graph[start][i] == '1' and can_win(i, end, visited, graph):\n                return True\n        return False\n\n    n = int(stdin.readline())\n    graph = [list(stdin.readline().strip()) for _ in range(n)]\n\n    for i in range(n):\n        if can_win(i, 0, set(), graph):\n            return \"impossible\"\n\n    def dfs(start, visited, graph):\n        if start in visited:\n            return\n        visited.add(start)\n        for i in range(n):\n            if graph[start][i] == '1' and i not in visited:\n                dfs(i, visited, graph)\n        res.append(start)\n\n    res = []\n    dfs(0, set(), graph)\n    return \" \".join(map(str, res[1:]))",
        "test": "",
        "num_ids": 268,
        "indeed": false
    },
    {
        "number": 2919,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    i = 0\n    while i < len(stdin):\n        if stdin[i] == 'S':\n            if stdin[i + 1] == 'S':\n                if len(stack) > 0:\n                    stack.append(int(stdin[i + 2] == 'S'))\n                    i += 3\n                else:\n                    print(\"Invalid push operation\")\n                    return\n            elif stdin[i + 1] == 'N':\n                if len(stack) > 0:\n                    stack.append(stack[-1])\n                    i += 3\n                else:\n                    print(\"Invalid copy operation\")\n                    return\n            elif stdin[i + 1] == '\\n':\n                if len(stack) > 1:\n                    stack[-2], stack[-1] = stack[-1], stack[-2]\n                    i += 3\n                else:\n                    print(\"Invalid swap operation\")\n                    return\n            elif stdin[i + 1] == '\\t':\n                if len(stack) > 0:\n                    stack.pop()\n                    i += 3\n                else:\n                    print(\"Invalid remove operation\")\n                    return\n        elif stdin[i] == '\\t':\n            if stdin[i + 1] == 'S':\n                if len(stack) > 1:\n                    stack.pop()\n                    stack.pop()\n                    stack.append(stack.pop() + stack[-1])\n                    i += 4\n                else:\n                    print(\"Invalid addition operation\")\n                    return\n            elif stdin[i + 1] == 'T':\n                if len(stack) > 1:\n                    stack.pop()\n                    stack.pop()\n                    stack.append(stack.pop() - stack[-1])\n                    i += 4\n                else:\n                    print(\"Invalid subtraction operation\")\n                    return\n            elif stdin[i + 1] == '\\n':\n                if len(stack) > 1:\n                    stack.pop()\n                    stack.pop()\n                    stack.append(stack.pop() * stack[-1])\n                    i += 4\n                else:\n                    print(\"Invalid multiplication operation\")\n                    return\n            elif stdin[i + 1] == '\\t':\n                if len(stack) > 1:\n                    if stack[-1] == 0:\n                        print(\"Division by zero\")\n                        return\n                    else:\n                        stack.pop()\n                        stack[-1] //= stack.pop()\n                        i += 4\n                else:\n                    print(\"Invalid division operation\")\n                    return\n            elif stdin[i + 1] == ' ':\n                if len(stack) > 0:\n                    print(stack.pop())\n                    i += 4\n                else:\n                    print(\"Invalid print operation\")\n                    return\n        i += 1\n    return \"\"",
        "test": "",
        "num_ids": 717,
        "indeed": false
    },
    {
        "number": 2920,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    grid = []\n    for _ in range(n):\n        grid.append(list(stdin.readline().strip()))\n\n    def count_paths(grid: List[List[str]]) -> int:\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '#':\n                    continue\n\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    result = count_paths(grid)\n    if result == 0:\n        if count_paths(grid, up_left=True) > 0:\n            return \"THE GAME IS A LIE\"\n        else:\n            return \"INCONCEIVABLE\"\n    else:\n        return str(result % (2**31 - 1))",
        "test": "",
        "num_ids": 281,
        "indeed": false
    },
    {
        "number": 2921,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        m, u, d = map(float, lines[0].split())\n        drinks = []\n        for i in range(1, d + 1):\n            name, strength, size, price = lines[i].split()\n            strength = int(strength)\n            size = 1 if size == '1/1' else 0.5 if size == '1/2' else 1 / 3\n            price = float(price)\n            drinks.append((name, strength, size, price))\n        return m, u, drinks\n\n    def can_drink_enough(drinks: list, target_units: float) -> bool:\n        total_units = 0\n        for name, strength, size, price in drinks:\n            total_units += strength * size\n        return total_units >= target_units\n\n    def find_solution(m: float, u: float, drinks: list) -> list:\n        solution = []\n        for name, strength, size, price in drinks:\n            max_count = int(m // price)\n            total_units = strength * size * max_count\n            if total_units >= u:\n                solution.append((name, max_count))\n                return solution\n            m -= price * max_count\n            u -= total_units\n        return solution\n\n    m, u, drinks = parse_input(stdin)\n    if not can_drink_enough(drinks, u):\n        return \"IMPOSSIBLE\"\n    solution = find_solution(m, u, drinks)\n    return '\\n'.join(f\"{name} {count}\" for name, count in solution)",
        "test": "",
        "num_ids": 428,
        "indeed": false
    },
    {
        "number": 2922,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    chocolates = list(map(int, stdin.split('\\n')[1].split()))\n    total_pieces = sum(chocolates)\n    if total_pieces % 2 != 0:\n        return \"NO\"\n    half_pieces = total_pieces // 2\n    current_pieces = 0\n    for chocolate in chocolates:\n        current_pieces += chocolate\n        if current_pieces == half_pieces:\n            return \"YES\"\n    return \"NO\"",
        "test": "",
        "num_ids": 144,
        "indeed": false
    },
    {
        "number": 2923,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < w and 0 <= y < h and grid[y][x] != 'A' and grid[y][x] != 'B'\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if grid[y][x] != '0':\n                soldiers[0] = min(soldiers[0], soldiers[y][x])\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid(new_x, new_y):\n                    grid[y][x] = 'B'\n                    queue.append((new_x, new_y))\n\n    w, h = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(h)]\n    soldiers = [[int(c) for c in row if c.isdigit()] for row in grid]\n    soldiers = [min(s) for s in soldiers if s]\n\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] == 'A':\n                bfs(x, y)\n\n    return sum(soldiers)",
        "test": "",
        "num_ids": 385,
        "indeed": false
    },
    {
        "number": 2924,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, P = map(int, stdin.split()[0:3])\n    C = list(map(int, stdin.split()[3:3 + N]))\n    D = list(map(int, stdin.split()[3 + N:3 + N + M]))\n\n    C.sort()\n    D.sort()\n\n    for i in range(N):\n        for j in range(M):\n            if D[j] > C[i]:\n                continue\n            else:\n                cadence_change = (C[i] / D[j]) * 100 - 100\n                if cadence_change <= P:\n                    continue\n                else:\n                    return \"Time to change gears!\"\n    return \"Ride on!\"",
        "test": "",
        "num_ids": 186,
        "indeed": false
    },
    {
        "number": 2925,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def zipf_law(n: int, k: int) -> float:\n        return 1 / (k * (k + 1) / 2)\n\n    def quality(f_i: int, z_i: float) -> float:\n        return f_i / z_i\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    songs = []\n\n    for i in range(1, n + 1):\n        f_i, s_i = lines[i].split()\n        f_i = int(f_i)\n        songs.append((f_i, s_i))\n\n    songs.sort(key=lambda x: x[1])\n    z_i = [zipf_law(n, i + 1) for i in range(n)]\n    q_i = [quality(f_i, z) for f_i, z in zip(songs, z_i)]\n    selected_songs = [song for _, song in sorted(zip(q_i, songs), reverse=True)[:m]]\n\n    return '\\n'.join(selected_songs)",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 2926,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.readline().strip())\n    categories = {}\n    for _ in range(N):\n        name, W = stdin.readline().strip().split()\n        W = int(W)\n        words = stdin.readline().strip().split()\n        categories[name] = words\n\n    # Read statement\n    statement = []\n    line = stdin.readline().strip()\n    while line:\n        statement.extend(line.split())\n        line = stdin.readline().strip()\n\n    # Count matches\n    matches = {name: 0 for name in categories}\n    for word in statement:\n        for name, words in categories.items():\n            if word in words:\n                matches[name] += 1\n\n    # Find categories with maximum matches\n    max_matches = max(matches.values())\n    suggested_categories = [name for name, count in matches.items() if count == max_matches]\n\n    # Sort and output categories\n    suggested_categories.sort()\n    return \"\\n\".join(suggested_categories)",
        "test": "",
        "num_ids": 259,
        "indeed": false
    },
    {
        "number": 2927,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    yards = [int(y) for y in stdin.split('\\n')[1].split()]\n    total_yards = 0\n    for i in range(N):\n        total_yards += yards[i]\n        if total_yards >= 80:\n            return \"Touchdown\"\n        elif total_yards < -20:\n            return \"Safety\"\n    return \"Nothing\"",
        "test": "",
        "num_ids": 114,
        "indeed": false
    },
    {
        "number": 2928,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_tax(income, bands):\n        tax = 0\n        for band in bands:\n            if income > band[0]:\n                tax += (income - band[0]) * band[1] / 100\n                income = band[0]\n            else:\n                break\n        return tax\n\n    def get_tax_bands(bands):\n        tax_bands = []\n        for i in range(len(bands)):\n            if i == 0:\n                tax_bands.append([0, bands[i][1]])\n            else:\n                tax_bands.append([bands[i - 1][0] + 0.01, bands[i][1]])\n        return tax_bands\n\n    def get_taxable_income(earned, received):\n        return max(earned - received, 0)\n\n    lines = stdin.split('\\n')\n    B = int(lines[0])\n    bands = [list(map(float, lines[i + 1].split())) for i in range(B)]\n    P = float(lines[B + 1])\n    F = int(lines[B + 2])\n    friends = [list(map(float, lines[B + i + 3].split())) for i in range(F)]\n\n    tax_bands = get_tax_bands(bands)\n    tax_bands.append([tax_bands[-1][0] + 0.01, P])\n\n    output = []\n    for earned, received in friends:\n        taxable_income = get_taxable_income(earned, received)\n        tax = get_tax(taxable_income, tax_bands)\n        output.append(received - tax)\n\n    return '\\n'.join(f'{num:.6f}' for num in output)",
        "test": "",
        "num_ids": 446,
        "indeed": false
    },
    {
        "number": 2929,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_submerged(h, height):\n        return h >= height\n\n    def find_path(grid, i, j, visited, hours):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j]:\n            return False\n\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return True\n\n        visited[i][j] = True\n\n        if is_submerged(grid[i][j] + hours, 1):\n            if (\n                find_path(grid, i - 1, j, visited, hours)\n                or find_path(grid, i + 1, j, visited, hours)\n                or find_path(grid, i, j - 1, visited, hours)\n                or find_path(grid, i, j + 1, visited, hours)\n            ):\n                return True\n\n        visited[i][j] = False\n        return False\n\n    N = int(stdin.readline().strip())\n    grid = []\n    for _ in range(N):\n        row = list(map(int, stdin.readline().strip().split()))\n        grid.append(row)\n\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    hours = 1\n    while not find_path(grid, 0, 0, visited, hours):\n        hours += 1\n\n    return str(hours)",
        "test": "",
        "num_ids": 364,
        "indeed": false
    },
    {
        "number": 2930,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n    zigzag = []\n    zigzag.append(1)\n    for i in range(1, n):\n        if arr[i] > arr[i-1]:\n            if zigzag[-1] == 1:\n                zigzag.append(2)\n            else:\n                zigzag.append(1)\n        elif arr[i] < arr[i-1]:\n            if zigzag[-1] == 2:\n                zigzag.append(1)\n            else:\n                zigzag.append(2)\n        else:\n            zigzag.append(zigzag[-1])\n    return str(max(zigzag))",
        "test": "",
        "num_ids": 206,
        "indeed": false
    },
    {
        "number": 2931,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_highest_lowest_place(points1, points2):\n        highest_place = 1\n        lowest_place = 1\n        if points1 > points2:\n            lowest_place = 3\n        elif points1 < points2:\n            highest_place = 3\n        return highest_place, lowest_place\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    output = []\n    for i in range(1, N + 1):\n        points1, points2 = map(int, lines[i].split())\n        highest_place, lowest_place = get_highest_lowest_place(points1, points2)\n        output.append(f\"{highest_place} {lowest_place}\")\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 196,
        "indeed": false
    },
    {
        "number": 2932,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    k = int(k)\n\n    if sorted(s) == list(s):\n        return \"Yes\"\n\n    for i in range(len(s) - k):\n        if s[i] > s[i + k]:\n            return \"Yes\"\n\n    return \"No\"",
        "test": "",
        "num_ids": 81,
        "indeed": false
    },
    {
        "number": 2933,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    weights = [int(stdin.readline().strip()) for _ in range(n)]\n\n    weights.sort()\n\n    closest_weight = float('inf')\n    for i in range(len(weights)):\n        current_weight = sum(weights[:i]) + sum(weights[i:])\n        if abs(current_weight - 1000) < abs(closest_weight - 1000):\n            closest_weight = current_weight\n\n    return str(closest_weight)",
        "test": "",
        "num_ids": 138,
        "indeed": false
    },
    {
        "number": 2934,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    mod = 10**9\n\n    def count_tilings(n, m):\n        if n == 1:\n            return m\n        if m == 1:\n            return n\n        if n == 2:\n            return 2 * m + m * (m - 1) // 2\n        if m == 2:\n            return 2 * n + n * (n - 1) // 2\n        return (count_tilings(n - 1, m) + count_tilings(n, m - 1) +\n                count_tilings(n - 2, m) + count_tilings(n, m - 2)) % mod\n\n    return str(count_tilings(N, M))",
        "test": "",
        "num_ids": 190,
        "indeed": false
    },
    {
        "number": 2935,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(start, end, flights, visited, min_cost):\n        if start == end:\n            return min_cost\n\n        for flight in flights:\n            if flight[0] == start and flight[1] not in visited:\n                visited.add(flight[1])\n                min_cost = find_min_cost(flight[1], end, flights, visited, min_cost + flight[2])\n                visited.remove(flight[1])\n\n        return min_cost\n\n    def dijkstra(start, end, roads):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = set()\n        pq = [(0, start)]\n\n        while pq:\n            curr_dist, curr_node = heapq.heappop(pq)\n            if curr_node in visited:\n                continue\n            visited.add(curr_node)\n\n            if curr_node == end:\n                return curr_dist\n\n            for neighbor, cost in roads[curr_node]:\n                if neighbor not in visited:\n                    dist_to_neighbor = curr_dist + cost\n                    if dist_to_neighbor < dist[neighbor]:\n                        dist[neighbor] = dist_to_neighbor\n                        heapq.heappush(pq, (dist_to_neighbor, neighbor))\n\n        return -1\n\n    stdin = stdin.split('\\n')\n    n, m, f, s, t = map(int, stdin[0].split())\n    roads = [[] for _ in range(n)]\n    flights = []\n\n    for i in range(m):\n        u, v, c = map(int, stdin[i + 1].split())\n        roads[u].append((v, c))\n        roads[v].append((u, c))\n\n    for i in range(f):\n        u, v = map(int, stdin[i + m + 1].split())\n        flights.append((u, v))\n\n    min_cost = float('inf')\n    for flight in flights:\n        if s in flight or t in flight:\n            continue\n\n        visited = set()\n        min_cost = min(min_cost, find_min_cost(s, flight[0], flights, visited, dijkstra(s, flight[0], roads)))\n        min_cost = min(min_cost, find_min_cost(flight[1], t, flights, visited, dijkstra(flight[1], t, roads)))\n\n    return str(min_cost)",
        "test": "",
        "num_ids": 631,
        "indeed": false
    },
    {
        "number": 2936,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    A = list(map(int, stdin.split('\\n')[1].split()))\n\n    def max_subarray_sum(A, start, end):\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(start, end):\n            current_sum += A[i]\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum\n\n    def k_max_subarray_sum(A, k):\n        A.sort()\n        max_sum = 0\n        for i in range(n - k):\n            max_sum += max_subarray_sum(A, i, i + k)\n        return max_sum\n\n    return str(k_max_subarray_sum(A, k))",
        "test": "",
        "num_ids": 228,
        "indeed": false
    },
    {
        "number": 2937,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: List[bool], groups: List[List[str]]) -> None:\n        visited[u] = True\n        for v in range(n):\n            if not visited[v] and (u, v) not in edges:\n                dfs(v, visited, groups)\n\n    def bfs(c: int, visited: List[bool], groups: List[List[str]]) -> None:\n        q = deque([])\n        for i in range(n):\n            if not visited[i]:\n                q.append(i)\n                visited[i] = True\n                groups[c].append(names[i])\n                break\n        while q:\n            u = q.popleft()\n            for v in range(n):\n                if not visited[v] and (u, v) not in edges:\n                    q.append(v)\n                    visited[v] = True\n                    groups[c].append(names[v])\n\n    lines = stdin.split('\\n')\n    n, k, c = map(int, lines[0].split())\n    names = lines[1:n + 1]\n    edges = set()\n    for i in range(n + 1, n + 1 + k):\n        u, v = lines[i].split()\n        edges.add((names.index(u), names.index(v)))\n\n    visited = [False] * n\n    groups = [[] for _ in range(n // c + 1)]\n    cnt = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, groups)\n            cnt += 1\n\n    for i in range(cnt):\n        bfs(i, visited, groups)\n\n    output = [str(cnt)]\n    for group in groups:\n        if group:\n            output.append(' '.join(group))\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 462,
        "indeed": false
    },
    {
        "number": 2938,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    yraglac_king = None\n    yraglac_rook = None\n    opponent_king = None\n\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == 'K':\n                yraglac_king = (row, col)\n            elif board[row][col] == 'R':\n                yraglac_rook = (row, col)\n            elif board[row][col] == 'k':\n                opponent_king = (row, col)\n\n    def is_threatened(king_pos, rook_pos):\n        row_diff = abs(king_pos[0] - rook_pos[0])\n        col_diff = abs(king_pos[1] - rook_pos[1])\n\n        if row_diff == 0 or col_diff == 0:\n            return True\n        return False\n\n    if is_threatened(yraglac_king, yraglac_rook):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 2939,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, stdin.readline().strip())))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                distance = find_closest_commercial(matrix, i, j)\n                if distance > max_distance:\n                    max_distance = distance\n\n    return str(max_distance)\n\ndef",
        "test": "",
        "num_ids": 137,
        "indeed": false
    },
    {
        "number": 2940,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_concoct(recipe, used_ingredients):\n        for ingredient in recipe:\n            if ingredient not in used_ingredients:\n                return True\n        return False\n\n    def update_used_ingredients(recipe, used_ingredients):\n        for ingredient in recipe:\n            if ingredient not in used_ingredients:\n                used_ingredients.add(ingredient)\n\n    def concoct_recipe(recipe, used_ingredients):\n        if can_concoct(recipe, used_ingredients):\n            update_used_ingredients(recipe, used_ingredients)\n            return True\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    recipes = [list(map(int, line.split()))[1:] for line in lines[1:N + 1]]\n    used_ingredients = set()\n    count = 0\n\n    for recipe in recipes:\n        if concoct_recipe(recipe, used_ingredients):\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 287,
        "indeed": true
    },
    {
        "number": 2941,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(query: str) -> None:\n        q_type, *args = query.split()\n        q_type = int(q_type)\n        if q_type == 1:\n            T, M, S = args\n            patients[M] = (int(T), int(S))\n        elif q_type == 2:\n            T = int(args[0])\n            if not patients:\n                print(\"doctor takes a break\")\n                return\n            priority_values = []\n            for M, (T_arrival, S) in patients.items():\n                W = T - T_arrival\n                priority_values.append((S + K * W, M))\n            priority_values.sort(reverse=True)\n            M_treated = sorted(priority_values)[0][1]\n            print(M_treated)\n            del patients[M_treated]\n        elif q_type == 3:\n            T, M = args\n            if M in patients:\n                del patients[M]\n\n    N, K = map(int, stdin.split())\n    patients = {}\n    for _ in range(N):\n        query = input()\n        process_query(query)",
        "test": "",
        "num_ids": 289,
        "indeed": false
    },
    {
        "number": 2942,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    D = int(stdin)\n    n1 = 0\n    n2 = 1\n    while n2**2 - n1**2 < D:\n        n2 += 1\n    if n2**2 - n1**2 == D:\n        return f\"{n1} {n2}\"\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 85,
        "indeed": false
    },
    {
        "number": 2943,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    r_count = [0] * n\n    b_count = [0] * n\n    for i in range(n):\n        if stdin[i] == 'R':\n            r_count[i] = 1\n        else:\n            b_count[i] = 1\n        if i > 0:\n            r_count[i] += r_count[i - 1]\n            b_count[i] += b_count[i - 1]\n    min_diff = float('inf')\n    start_index = -1\n    end_index = -1\n    for i in range(n):\n        for j in range(i, n):\n            diff = abs(r_count[j] - b_count[j])\n            if diff < min_diff:\n                min_diff = diff\n                start_index = i + 1\n                end_index = j + 1\n    return f\"{start_index} {end_index}\"",
        "test": "",
        "num_ids": 239,
        "indeed": false
    },
    {
        "number": 2944,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m, d = map(int, stdin.readline().split())\n        people = {}\n        for _ in range(n):\n            name, skepticism = stdin.readline().strip().split()\n            people[name] = int(skepticism)\n        connections = []\n        for _ in range(m):\n            u, v = stdin.readline().strip().split()\n            connections.append((u, v))\n        originator = stdin.readline().strip()\n        return n, m, d, people, connections, originator\n\n    def spread_rumor(people, connections, originator, days):\n        heard_rumor = set([originator])\n        for _ in range(days):\n            new_heard_rumor = set()\n            for person, skepticism in people.items():\n                if person in heard_rumor:\n                    for connection in connections:\n                        if connection[0] == person and connection[1] not in heard_rumor:\n                            if people[connection[1]] == 0:\n                                new_heard_rumor.add(connection[1])\n                            elif people[connection[1]] > 1:\n                                people[connection[1]] -= 1\n                                if people[connection[1]] == 1:\n                                    new_heard_rumor.add(connection[1])\n            heard_rumor |= new_heard_rumor\n        return len(heard_rumor) - 1\n\n    n, m, d, people, connections, originator = read_input()\n    result = spread_rumor(people, connections, originator, d)\n    return str(result) ",
        "test": "",
        "num_ids": 409,
        "indeed": false
    },
    {
        "number": 2945,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N, M = map(int, stdin.split('\\n')[0].split())\n    A = []\n    B = []\n    C = []\n    D = []\n\n    for i in range(N):\n        A_k, B_k = map(int, stdin.split('\\n')[i + 1].split())\n        A.append(A_k)\n        B.append(B_k)\n\n    for i in range(M):\n        C_k, D_k = map(int, stdin.split('\\n')[N + i + 1].split())\n        C.append(C_k)\n        D.append(D_k)\n\n    time_first_arrive = max(A)\n    time_first_leave = time_first_arrive + max(A) * max(B)\n\n    time_second_arrive = time_first_leave + max(C)\n    time_second_leave = time_second_arrive + max(C) * max(D)\n\n    return str(time_second_arrive)",
        "test": "",
        "num_ids": 260,
        "indeed": false
    },
    {
        "number": 2946,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(prices, k):\n        if not prices or len(prices) < 2:\n            return 0\n\n        n = len(prices)\n        profit = 0\n\n        for i in range(1, n):\n            profit += (prices[i] - prices[i - 1]) * k\n\n        return profit\n\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    prices = list(map(int, lines[1].split()))\n\n    return str(max_profit(prices, K))",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2947,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        for node in graph[start]:\n            if node not in path:\n                newpath = find_path(graph, node, end, path)\n                if newpath:\n                    return newpath\n        return None\n\n    def build_graph(n, numbers):\n        graph = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                if len(set(numbers[i]) & set(numbers[j])) > 0:\n                    if i in graph:\n                        graph[i].append(j)\n                    else:\n                        graph[i] = [j]\n                    if j in graph:\n                        graph[j].append(i)\n                    else:\n                        graph[j] = [i]\n        return graph\n\n    def find_proof(n, numbers):\n        graph = build_graph(n, numbers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                path = find_path(graph, i, j)\n                if path:\n                    for k in range(len(path) - 1):\n                        print(path[k], path[k + 1], numbers[path[k]][0])\n\n    def main():\n        n = int(stdin.readline().strip())\n        numbers = []\n        for _ in range(n):\n            line = stdin.readline().strip().split()\n            m = int(line[0])\n            numbers.append([int(x) for x in line[1:]])\n\n        find_proof(n, numbers)\n\n    main()",
        "test": "",
        "num_ids": 435,
        "indeed": false
    },
    {
        "number": 2948,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_party(graph, start):\n        visited = [False] * len(graph)\n        stack = [(start, 'A')]\n        while stack:\n            node, party = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, weight in graph[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, party if weight == 1 else 'B'))\n        return visited\n\n    def count_arguments(graph, party):\n        count = [0] * len(graph)\n        for i, node in enumerate(party):\n            if node == 'A':\n                count[i] = sum(weight for _, weight in graph[i] if party[j] == 'A')\n            else:\n                count[i] = sum(weight for _, weight in graph[i] if party[j] == 'B')\n        return count\n\n    def is_valid(graph, party):\n        for i, node in enumerate(graph):\n            if party[i] == 'A':\n                if any(weight == 2 for _, weight in node):\n                    return False\n            else:\n                if any(weight == 1 for _, weight in node):\n                    return False\n        return True\n\n    def assign_parties(graph, n):\n        for i in range(n):\n            for j in range(i + 1, n):\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if graph[i][j][1] == graph[j][k][1] == graph[k][i][1]:\n                        graph[i].append((k, 2))\n                        graph[k].append((i, 2))\n                        graph[j].append((k, 2))\n                        graph[k].append((j, 2))\n                        graph[k].append((i, 2))\n                        graph[i].append((j, 2))\n\n    def solve(n, photographs):\n        graph = [[] for _ in range(n)]\n        assign_parties(graph, n)\n\n        for photograph in photographs:\n            for pair in photograph:\n                graph[pair[0] - 1].append((pair[1] - 1, 1))\n                graph[pair[1] - 1].append((pair[0] - 1, 1))\n\n        for i in range(n):\n            party = find_party(graph, i)\n            if is_valid(graph, party):\n                return ''.join(party)\n        return \"No solution found\"\n\n    n = int(stdin.readline().strip())\n    photographs = [list(map(lambda x: tuple(map(int, x.split())), line.strip().split(\"  \"))) for line in stdin]\n    return solve(n, photographs) ",
        "test": "",
        "num_ids": 730,
        "indeed": false
    },
    {
        "number": 2949,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_segment(x1, y1, x2, y2):\n        return abs(y1 - y2) == 1\n\n    def can_connect_to_pylon(pylons, pylon_idx, connected_count):\n        pylon = pylons[pylon_idx]\n        if pylon[2] == 1:\n            return connected_count == 0\n        else:\n            if connected_count == 0:\n                return True\n            elif connected_count == 1:\n                return pylon[1] != pylons[connected_count][1]\n            else:\n                return False\n\n    def dfs(pylons, curr_idx, visited, connected_counts):\n        if visited[curr_idx]:\n            return 0\n\n        visited[curr_idx] = True\n        pylon = pylons[curr_idx]\n        max_count = 0\n\n        for next_idx in range(len(pylons)):\n            if next_idx == curr_idx or not can_connect_to_pylon(pylons, next_idx, connected_counts[curr_idx]):\n                continue\n\n            if is_valid_segment(pylon[0], pylon[1], pylons[next_idx][0], pylons[next_idx][1]):\n                connected_counts[curr_idx] += 1\n                connected_counts[next_idx] += 1\n                max_count = max(max_count, dfs(pylons, next_idx, visited, connected_counts))\n                connected_counts[curr_idx] -= 1\n                connected_counts[next_idx] -= 1\n\n        return max_count + 1\n\n    n = int(stdin.readline().strip())\n    pylons = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    visited = [False] * n\n    connected_counts = [0] * n\n\n    return str(dfs(pylons, 0, visited, connected_counts))",
        "test": "",
        "num_ids": 509,
        "indeed": false
    },
    {
        "number": 2950,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = [int(x) for x in stdin.split('\\n')[1].split()]\n    heights.sort(reverse=True)\n    charges = 0\n    for i in range(n):\n        if i % 2 == 0:\n            charges += heights[i]\n        else:\n            charges += 1\n    return str(charges)",
        "test": "",
        "num_ids": 105,
        "indeed": false
    },
    {
        "number": 2951,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def combinations(n, k):\n        if k == 1:\n            return n\n        if n == k:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n\n    def tennis_matches(N, a, b):\n        total_players = sum(a)\n        total_umpires = sum(b)\n        total_people = total_players + total_umpires\n\n        if total_people < 3:\n            return 0\n\n        matches = 0\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                for k in range(N):\n                    if k == i or k == j:\n                        continue\n                    if a[i] == 0 or a[j] == 0 or b[k] == 0:\n                        continue\n                    matches += combinations(a[i] + a[j], 2) * b[k]\n\n        return matches\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    a = [int(x) for x in lines[1].split()]\n    b = [int(x) for x in lines[2].split()]\n\n    return str(tennis_matches(N, a, b))",
        "test": "",
        "num_ids": 325,
        "indeed": false
    },
    {
        "number": 2952,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b, c = map(int, stdin.split())\n    total_items = a + b + c\n    if total_items < m:\n        return \"possible\"\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 57,
        "indeed": false
    },
    {
        "number": 2953,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(points[i][0] - points[j][0]) == 2018 and abs(points[i][1] - points[j][1]) == 2018:\n                count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 146,
        "indeed": false
    },
    {
        "number": 2954,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end, max_distance):\n        distances = {node: float('inf') for node in graph}\n        distances[start] = 0\n        visited = set()\n        while distances:\n            current_node = min(distances, key=distances.get)\n            if current_node == end:\n                return distances[end]\n            visited.add(current_node)\n            del distances[current_node]\n            for neighbor, weight in graph[current_node].items():\n                if neighbor not in visited:\n                    distance = distances[current_node] + weight\n                    if distance <= max_distance and distance < distances.get(neighbor, float('inf')):\n                        distances[neighbor] = distance\n        return -1\n\n    def min_distance_to_spider(graph, spiders, start, end, max_distance):\n        min_distance = float('inf')\n        for spider in spiders:\n            distance = dijkstra(graph, start, spider, max_distance)\n            if distance != -1:\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    stdin_list = stdin.split('\\n')\n    N, M, T = map(int, stdin_list[0].split())\n    graph = {i: {} for i in range(N)}\n    for i in range(1, M + 1):\n        u, v, d = map(int, stdin_list[i].split())\n        graph[u][v] = d\n        graph[v][u] = d\n\n    s, t = map(int, stdin_list[M + 1].split())\n    K = int(stdin_list[M + 2])\n    spiders = list(map(int, stdin_list[M + 3].split()))\n\n    return str(min_distance_to_spider(graph, spiders, s, t, T))",
        "test": "",
        "num_ids": 470,
        "indeed": false
    },
    {
        "number": 2955,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, b = map(int, stdin.readline().split())\n    broken_bits = list(map(int, stdin.readline().split()))\n\n    def count_bit_changes(bits: str) -> int:\n        return sum(bits[i] != bits[i - 1] for i in range(1, len(bits)))\n\n    def is_valid(bits: str) -> bool:\n        for i in range(1, len(bits)):\n            if i in broken_bits and bits[i] == '1':\n                return False\n        return True\n\n    for i in range(2 ** b):\n        bits = bin(i)[2:].zfill(b)\n        bits = '0' * (n - b - 1) + bits + '0'\n        if is_valid(bits) and count_bit_changes(bits) == c:\n            return bits\n\n    return \"No solution found\"",
        "test": "",
        "num_ids": 223,
        "indeed": false
    },
    {
        "number": 2956,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(turns: str) -> bool:\n        x, y = 1, 1\n        for turn in turns:\n            if turn == 'L':\n                x, y = -y, x\n            elif turn == 'R':\n                x, y = y, -x\n            elif turn == 'S':\n                x, y = x, y\n            elif turn == 'A':\n                x, y = -x, -y\n            else:\n                return False\n        return x == 1 and y == 1\n\n    def count_patterns(turns: str, index: int, count: int) -> int:\n        if index == len(turns):\n            return count\n        if turns[index] == '?':\n            for direction in ['L', 'R', 'S', 'A']:\n                turns[index] = direction\n                if is_valid(turns):\n                    count = count_patterns(turns, index + 1, count + 1)\n            turns[index] = '?'\n        else:\n            count = count_patterns(turns, index + 1, count)\n        return count\n\n    turns = list(stdin)\n    return str(count_patterns(turns, 0, 0))",
        "test": "",
        "num_ids": 300,
        "indeed": false
    },
    {
        "number": 2957,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    graph = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1):\n        graph[i][i + 1] = 1\n\n    for i in range(1, n):\n        if i % k == 0:\n            graph[i - 1][i] = 1\n            graph[i][i - 1] = 1\n\n    queue = [(0, 0)]\n    visited = [False] * n\n    visited[0] = True\n\n    while queue:\n        node, depth = queue.pop(0)\n        if node == n - 1:\n            return str(depth)\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                queue.append((neighbor, depth + 1))\n                visited[neighbor] = True\n\n    return \"No path found\"",
        "test": "",
        "num_ids": 237,
        "indeed": false
    },
    {
        "number": 2958,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_combos(deck: List[int], T: int) -> int:\n        combos = [0] * T\n        for card in deck:\n            combos[card - 1] += 1\n        return sum(1 for c in combos if c >= 2)\n\n    def maximize_profit(deck: List[int], T: int, K: int, a: List[int], b: List[int]) -> int:\n        profit = 0\n        for i in range(T):\n            if deck.count(i + 1) >= 2:\n                profit += b[i] * deck.count(i + 1)\n            else:\n                profit -= a[i]\n        return profit\n\n    N, T, K = map(int, stdin.readline().split())\n    deck = [int(x) for x in stdin.readline().split()]\n    a = [0] * T\n    b = [0] * T\n    for i in range(T):\n        a[i], b[i] = map(int, stdin.readline().split())\n\n    combos = count_combos(deck, T)\n    profit = maximize_profit(deck, T, K, a, b)\n\n    if combos >= K:\n        return profit\n    else:\n        return -1",
        "test": "",
        "num_ids": 322,
        "indeed": false
    },
    {
        "number": 2959,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m:\n                yield nx, ny\n\n    def find_rings(grid):\n        rings = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'T':\n                    rings[i][j] = 1\n                    queue = [(i, j)]\n                    while queue:\n                        x, y = queue.pop(0)\n                        for nx, ny in neighbors(x, y):\n                            if grid[nx][ny] == 'T' and rings[nx][ny] == 0:\n                                rings[nx][ny] = rings[x][y] + 1\n                                queue.append((nx, ny))\n        return rings\n\n    def print_rings(rings):\n        max_ring = max(max(row) for row in rings)\n        if max_ring < 10:\n            format_str = '{:2d}'\n        else:\n            format_str = '{:3d}'\n        output = ''\n        for row in rings:\n            output += ''.join([format_str.format(x) for x in row]) + '\\n'\n        return output\n\n    rings = find_rings(grid)\n    output = print_rings(rings)\n    return output",
        "test": "",
        "num_ids": 433,
        "indeed": false
    },
    {
        "number": 2960,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    T_2 = 0\n    for m in range(1, n):\n        for k in range(0, m):\n            if binomial(m, k) % 2 != 0:\n                T_2 += 1\n    return str(T_2)\n\ndef",
        "test": "",
        "num_ids": 77,
        "indeed": false
    },
    {
        "number": 2961,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(start: int, end: int, path: List[int]) -> bool:\n        if start == end:\n            return True\n        for exit_ in path:\n            if exit_ == 0:\n                continue\n            if is_valid_path(exit_, end, path):\n                return True\n        return False\n\n    def is_valid_sequence(stdin: str) -> bool:\n        n = int(stdin.readline().strip())\n        entrance_config, dormitory_config = [], []\n        for _ in range(n):\n            entrance_config.append(list(map(int, stdin.readline().strip().split())))\n        for _ in range(n):\n            dormitory_config.append(list(map(int, stdin.readline().strip().split())))\n\n        for i in range(1, n):\n            if not is_valid_path(1, i, entrance_config[0]):\n                return False\n\n        for i in range(n):\n            if not is_valid_path(n, i, dormitory_config[n - 1]):\n                return False\n\n        return True\n\n    if is_valid_sequence(stdin):\n        return \"Yes\"\n    else:\n        return \"No\"",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 2962,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(time_limit, serving_time, leave_time):\n        return serving_time + 1 <= time_limit and leave_time >= serving_time\n\n    def find_max_money(people, time_limit):\n        people.sort(key=lambda x: x[0], reverse=True)\n        max_money = 0\n        serving_time = 0\n\n        for person in people:\n            if is_valid(time_limit, serving_time, person[1]):\n                max_money += person[0]\n                serving_time += 1\n\n        return max_money\n\n    input_data = list(map(int, stdin.split()))\n    N, T = input_data[0], input_data[1]\n    people = []\n\n    for i in range(2, len(input_data), 2):\n        cash = input_data[i]\n        leave_time = input_data[i + 1]\n        people.append((cash, leave_time))\n\n    max_money = find_max_money(people, T)\n    return str(max_money)",
        "test": "",
        "num_ids": 277,
        "indeed": false
    },
    {
        "number": 2963,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    epsilon = 1e-6\n    low, high = 1, n\n\n    while high - low > epsilon:\n        mid = (low + high) / 2\n        if mid ** mid < n:\n            low = mid\n        else:\n            high = mid\n\n    return f\"{low:.6f}\"",
        "test": "",
        "num_ids": 91,
        "indeed": false
    },
    {
        "number": 2964,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    C = int(stdin.split('\\n')[0])\n    arrows = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    if len(arrows) < 2:\n        return \"0.0\"\n\n    max_distance = 0.0\n    for i in range(len(arrows) - 1):\n        for j in range(i + 1, len(arrows)):\n            max_distance = max(max_distance, distance(arrows[i], arrows[j]))\n\n    return f\"{max_distance:.1f}\"",
        "test": "",
        "num_ids": 201,
        "indeed": false
    },
    {
        "number": 2965,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(position: tuple, grid_size: int) -> bool:\n        return 0 <= position[0] < grid_size and 0 <= position[1] < grid_size\n\n    def get_next_position(current_position: tuple, direction: int) -> tuple:\n        if direction == 0:\n            return (current_position[0] + 1, current_position[1])\n        elif direction == 1:\n            return (current_position[0], current_position[1] + 1)\n        elif direction == 2:\n            return (current_position[0] - 1, current_position[1])\n        else:\n            return (current_position[0], current_position[1] - 1)\n\n    def simulate_growth(pumpkins: list, grid_size: int, days: int) -> list:\n        for day in range(1, days + 1):\n            for pumpkin in pumpkins:\n                if pumpkin[\"alive\"]:\n                    for i, root in enumerate(pumpkin[\"roots\"]):\n                        next_position = get_next_position(root, pumpkin[\"directions\"][i])\n                        if is_valid_position(next_position, grid_size):\n                            pumpkin[\"roots\"][i] = next_position\n                            for other_pumpkin in pumpkins:\n                                if other_pumpkin != pumpkin and other_pumpkin[\"alive\"]:\n                                    if next_position in other_pumpkin[\"roots\"]:\n                                        pumpkin[\"alive\"] = False\n                                        pumpkin[\"day_died\"] = day\n                                        break\n                        else:\n                            pumpkin[\"alive\"] = False\n                            pumpkin[\"day_died\"] = day\n                            break\n        return pumpkins\n\n    lines = stdin.split(\"\\n\")\n    pumpkins = []\n    grid_size, days, _ = map(int, lines[0].split())\n\n    for i in range(1, len(lines)):\n        row, col = map(int, lines[i].split())\n        pumpkins.append({\n            \"position\": (row, col),\n            \"roots\": [(row + i, col) for i in range(4)],\n            \"directions\": [0, 1, 2, 3],\n            \"alive\": True,\n            \"day_died\": None\n        })\n\n    result = []\n    for pumpkin in simulate_growth(pumpkins, grid_size, days):\n        if pumpkin[\"alive\"]:\n            result.append(\"ALIVE\")\n        else:\n            result.append(pumpkin[\"day_died\"])\n\n    return \"\\n\".join(map(str, result))",
        "test": "",
        "num_ids": 683,
        "indeed": false
    },
    {
        "number": 2966,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    cut_blocks = 0\n\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            if i * j == (M * N) // 2:\n                cut_blocks += 1\n\n    return str(cut_blocks)",
        "test": "",
        "num_ids": 90,
        "indeed": false
    },
    {
        "number": 2967,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    n, m, events = int(stdin.splitlines()[0].split()[0]), int(stdin.splitlines()[0].split()[1]), [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    events.sort(key=lambda x: x[0])\n\n    workstations = [False] * n\n    unlockings = 0\n\n    for i in range(n):\n        current_time = events[i][0]\n        available_workstations = [j for j in range(n) if not workstations[j]]\n\n        if not available_workstations:\n            unlockings += 1\n            workstations[i] = True\n\n        else:\n            index = binary_search(available_workstations, current_time % m)\n            if index >= len(available_workstations):\n                index = 0\n            workstations[available_workstations[index]] = True\n\n    return str(unlockings)",
        "test": "",
        "num_ids": 341,
        "indeed": false
    },
    {
        "number": 2968,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n, e = map(int, stdin.readline().split())\n    s_b, s_n, s_e = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n\n    participants = [s_b] * b + [s_n] * n + [s_e] * e\n    participants.sort()\n\n    max_speed = 0\n    for i in range(0, len(participants), 2):\n        kayak_speed = c[i // 2] * (participants[i] + participants[i + 1])\n        max_speed = max(max_speed, kayak_speed)\n\n    return str(max_speed)",
        "test": "",
        "num_ids": 185,
        "indeed": false
    },
    {
        "number": 2969,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_winnable(hand1, hand2):\n        hand1.sort(key=lambda x: (x[1], x[0]))\n        hand2.sort(key=lambda x: (x[1], x[0]))\n\n        while hand1 and hand2:\n            if hand1[-1][1] == hand2[-1][1]:\n                if hand1[-1][0] > hand2[-1][0]:\n                    hand1 += hand2\n                    break\n                else:\n                    hand2 += hand1\n                    break\n            elif hand1[-1][1] > hand2[-1][1]:\n                hand1 += hand2\n                break\n            else:\n                hand2 += hand1\n                break\n\n        return len(hand1) > len(hand2)\n\n    n = int(stdin.readline().strip())\n    hand1 = []\n    hand2 = []\n\n    for _ in range(n):\n        rank, suit = stdin.readline().strip().split()\n        if rank == '1':\n            rank = 'A'\n        elif rank == '11':\n            rank = 'J'\n        elif rank == '12':\n            rank = 'Q'\n        elif rank == '13':\n            rank = 'K'\n\n        if suit == 'C':\n            hand1.append((rank, 'C'))\n        elif suit == 'D':\n            hand1.append((rank, 'D'))\n        elif suit == 'H':\n            hand1.append((rank, 'H'))\n        elif suit == 'S':\n            hand1.append((rank, 'S'))\n\n    for _ in range(n):\n        rank, suit = stdin.readline().strip().split()\n        if rank == '1':\n            rank = 'A'\n        elif rank == '11':\n            rank = 'J'\n        elif rank == '12':\n            rank = 'Q'\n        elif rank == '13':\n            rank = 'K'\n\n        if suit == 'C':\n            hand2.append((rank, 'C'))\n        elif suit == 'D':\n            hand2.append((rank, 'D'))\n        elif suit == 'H':\n            hand2.append((rank, 'H'))\n        elif suit == 'S':\n            hand2.append((rank, 'S'))\n\n    if is_winnable(hand1, hand2):\n        return \"possible\"\n    else:\n        return \"impossible\"",
        "test": "",
        "num_ids": 589,
        "indeed": false
    },
    {
        "number": 2970,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[0:3])\n    student_buildings = list(map(int, stdin.split()[3:]))\n\n    building_counts = [0] * M\n    total_noise = 0\n\n    for i in range(N):\n        building_counts[student_buildings[i] - 1] += 1\n        total_noise += building_counts[student_buildings[i] - 1]\n\n    building_counts.sort(reverse=True)\n\n    for i in range(K):\n        if i >= M or building_counts[i] == 0:\n            break\n        total_noise -= building_counts[i] * building_counts[i]\n\n    return str(total_noise)",
        "test": "",
        "num_ids": 199,
        "indeed": false
    },
    {
        "number": 2971,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme_power(s1: str, s2: str) -> int:\n        n = min(len(s1), len(s2))\n        for i in range(1, n + 1):\n            if s1[-i:] != s2[-i:]:\n                return i - 1\n        return n\n\n    def max_rhyme_power(words: List[str]) -> int:\n        max_power = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                max_power = max(max_power, rhyme_power(words[i], words[j]))\n        return max_power\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    words = lines[1:]\n\n    return str(max_rhyme_power(words))",
        "test": "",
        "num_ids": 208,
        "indeed": false
    },
    {
        "number": 2972,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    count = 0\n\n    for num in range(a, b + 1):\n        is_palindrome = True\n        for base in range(2, k + 1):\n            if not is_palindrome:\n                break\n            num_str = str(num)\n            base_num = int(num_str, base)\n            base_num_str = str(base_num)\n            if base_num_str != base_num_str[::-1]:\n                is_palindrome = False\n                break\n        if is_palindrome:\n            count += 1\n\n    return str(count)",
        "test": "",
        "num_ids": 167,
        "indeed": false
    },
    {
        "number": 2973,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    d = []\n    s = []\n    for i in range(n):\n        di, si = map(int, input().split())\n        d.append(di)\n        s.append(si)\n\n    total_distance = sum(d)\n    total_speed = sum(s) + total_distance\n    c = total_speed / t - total_distance / t\n\n    return '{:.10f}'.format(abs(c))",
        "test": "",
        "num_ids": 123,
        "indeed": false
    },
    {
        "number": 2974,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_k(order1, order2):\n        n = len(order1)\n        k_p, k_r = n, n\n\n        for i in range(n):\n            if order1[i] != order2[i]:\n                k_r = i + 1\n                if i > 0 and order1[i - 1] != order2[i - 1]:\n                    k_p = i\n                    break\n\n        return k_p, k_r\n\n    N = int(stdin.readline().strip())\n    P = list(map(int, stdin.readline().strip().split()))\n    D = list(map(int, stdin.readline().strip().split()))\n\n    k_p, k_r = find_min_k(P, D)\n\n    return f\"{k_p} {k_r}\"",
        "test": "",
        "num_ids": 212,
        "indeed": false
    },
    {
        "number": 2975,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    ingredients = []\n    for _ in range(N):\n        X, Y, S_M, P_M, S_V, P_V = map(int, input().split())\n        ingredients.append((X, Y, S_M, P_M, S_V, P_V))\n\n    def can_make_servings(servings):\n        total_cost = 0\n        for ingredient in ingredients:\n            X, Y, S_M, P_M, S_V, P_V = ingredient\n            needed = (servings * X) - Y\n            if needed <= 0:\n                continue\n\n            total_cost += (needed // S_M) * P_M + (needed % S_M // S_V) * P_V\n            if needed % S_V != 0:\n                return False\n\n        return total_cost <= M\n\n    left, right = 0, 100000\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_make_servings(mid):\n            left = mid\n        else:\n            right = mid - 1\n\n    return str(left)",
        "test": "",
        "num_ids": 308,
        "indeed": false
    },
    {
        "number": 2976,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_set(set_result: str, is_federer: bool) -> bool:\n        a, b = map(int, set_result.split(':'))\n        if a == b == 6:\n            return True\n        if a >= 6 and a - b >= 2:\n            return True\n        if b >= 6 and b - a >= 2:\n            return True\n        if is_federer and a < 6 and b >= 6:\n            return False\n        return False\n\n    def is_valid_match(match_results: str, player1: str, player2: str) -> bool:\n        sets = match_results.split()\n        player1_sets = 0\n        player2_sets = 0\n        for i, set_result in enumerate(sets):\n            if i == 2 and player1_sets == player2_sets == 1:\n                return False\n            if set_result.startswith(player1):\n                if not is_valid_set(set_result[len(player1) + 1:], 'federer' in player1):\n                    return False\n                player1_sets += 1\n            else:\n                if not is_valid_set(set_result[len(player2) + 1:], 'federer' in player2):\n                    return False\n                player2_sets += 1\n            if player1_sets == 2 or player2_sets == 2:\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    player1, player2 = lines[0].split()\n    match_results = lines[1:]\n    output = []\n    for result in match_results:\n        if is_valid_match(result, player1, player2):\n            output.append('da')\n        else:\n            output.append('ne')\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 454,
        "indeed": false
    },
    {
        "number": 2977,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_changes(a: str, b: str) -> int:\n        return sum(1 for x, y in zip(a.split(','), b.split(',')) if x.strip() != y.strip())\n\n    lines = stdin.split('\\n')\n    question = lines[0]\n    num_alternatives = int(lines[1])\n    alternatives = lines[2:2 + num_alternatives]\n\n    min_incongruousity = float('inf')\n    least_incongruous_alternatives = []\n\n    for i, alternative in enumerate(alternatives):\n        incongruousity = max(count_changes(alternative, other) for j, other in enumerate(alternatives) if i != j)\n        if incongruousity < min_incongruousity:\n            min_incongruousity = incongruousity\n            least_incongruous_alternatives = [alternative]\n        elif incongruousity == min_incongruousity:\n            least_incongruous_alternatives.append(alternative)\n\n    return '\\n'.join(least_incongruous_alternatives)",
        "test": "",
        "num_ids": 275,
        "indeed": true
    },
    {
        "number": 2978,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_designation(x1, y1, x2, y2):\n        return (x1 == x2) ^ (y1 == y2)\n\n    def is_on_street(x, y, streets):\n        for street in streets:\n            if (x == street[0] and y == street[1]) or (x == street[2] and y == street[3]):\n                return True\n        return False\n\n    def check_properties(x1, y1, x2, y2, streets):\n        if is_on_street(x1, y1, streets) or is_on_street(x2, y2, streets):\n            return \"same\"\n        return \"different\" if is_same_designation(x1, y1, x2, y2) else \"same\"\n\n    input_data = stdin.split(\"\\n\")\n    S = int(input_data[0])\n    streets = [list(map(int, line.split())) for line in input_data[1:S+1]]\n    T = int(input_data[S+1])\n    properties = [list(map(int, line.split())) for line in input_data[S+2:]]\n\n    output = []\n    for property in properties:\n        output.append(check_properties(*property, streets))\n\n    return \"\\n\".join(output)",
        "test": "",
        "num_ids": 329,
        "indeed": false
    },
    {
        "number": 2979,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        n, m, s, t = map(int, stdin.split())\n        adj_list = [[] for _ in range(n)]\n        for _ in range(m):\n            x, y = map(int, input().split())\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n        return n, m, s, t, adj_list\n\n    def bfs(adj_list: list, s: int, t: int) -> int:\n        visited = [False] * len(adj_list)\n        queue = [(s, 1)]\n        squawks = 0\n\n        while queue:\n            curr, count = queue.pop(0)\n            if not visited[curr]:\n                visited[curr] = True\n                squawks += count\n                for neighbor in adj_list[curr]:\n                    queue.append((neighbor, count))\n\n        return squawks\n\n    n, m, s, t, adj_list = read_input()\n    return str(bfs(adj_list, s, t))",
        "test": "",
        "num_ids": 269,
        "indeed": false
    },
    {
        "number": 2980,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor_sum(heaps: List[int]) -> int:\n        return reduce(lambda a, b: a ^ b, heaps)\n\n    def is_winning_position(heaps: List[int], S: List[int]) -> bool:\n        xor = xor_sum(heaps)\n        if xor == 0:\n            return False\n        for i in range(len(heaps)):\n            for s in S:\n                if heaps[i] >= s and xor_sum(heaps[:i] + [heaps[i] - s] + heaps[i+1:]) == 0:\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    S = list(map(int, lines[0].split()))[1:]\n    m = int(lines[1])\n    result = []\n\n    for i in range(2, 2 + m):\n        heaps = list(map(int, lines[i].split()))[1:]\n        if is_winning_position(heaps, S):\n            result.append('W')\n        else:\n            result.append('L')\n\n    return ''.join(result)",
        "test": "",
        "num_ids": 287,
        "indeed": false
    },
    {
        "number": 2981,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def perimeter(points):\n        perimeter = 0\n        for i in range(len(points)):\n            perimeter += distance(points[i], points[(i + 1) % len(points)])\n        return perimeter\n\n    def max_distance_from_center(points):\n        center = (sum(p[0] for p in points) / len(points),\n                  sum(p[1] for p in points) / len(points))\n        return max(distance(center, p) for p in points)\n\n    def min_slot_size(perimeter, max_distance):\n        return perimeter + 2 * max_distance\n\n    N = int(stdin.readline())\n    points = [tuple(map(float, stdin.readline().split())) for _ in range(N)]\n\n    return f\"{min_slot_size(perimeter(points), max_distance_from_center(points)):.6f}\"",
        "test": "",
        "num_ids": 280,
        "indeed": false
    },
    {
        "number": 2982,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    hype_ratings = list(map(int, stdin.split('\\n')[1].split()))\n\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(n - 2):\n        if hype_ratings[i] == 1 and hype_ratings[i + 1] == 2 and hype_ratings[i + 2] == 3:\n            count += 1\n\n    return str(count % mod)",
        "test": "",
        "num_ids": 134,
        "indeed": false
    },
    {
        "number": 2983,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sheets = list(map(int, stdin.split()))\n    area = 2 ** ((n - 2) / 4)\n    total_area = sum(sheets) * area\n    if total_area < 10000:\n        return \"impossible\"\n    tape_length = 0\n    for i in range(n - 1, 0, -1):\n        if sheets[i - 1] == 0:\n            continue\n        tape_length += sheets[i - 1] * 2 ** ((i + 1) / 4)\n    return round(tape_length, 5)",
        "test": "",
        "num_ids": 154,
        "indeed": false
    },
    {
        "number": 2984,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, P = map(int, stdin.split()[0:3])\n    passengers = sorted(map(int, stdin.split()[3:]))\n    max_distance = 0\n    max_boarding = 0\n    current_boarding = [0] * N\n\n    for passenger in passengers:\n        car_number = (passenger // L) + 1\n        distance = abs((passenger % L) - L / 2)\n        current_boarding[car_number - 1] += 1\n\n        if distance > max_distance:\n            max_distance = distance\n\n        if current_boarding[car_number - 1] > max_boarding:\n            max_boarding = current_boarding[car_number - 1]\n\n    return f\"{max_distance}\\n{max_boarding}\"",
        "test": "",
        "num_ids": 204,
        "indeed": false
    },
    {
        "number": 2985,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    l, d, n = map(int, stdin.split()[:3])\n    positions = sorted(map(int, stdin.split()[3:]))\n\n    # Calculate the number of additional birds\n    additional_birds = 0\n    for i in range(1, n):\n        if positions[i] - positions[i - 1] >= d:\n            additional_birds += 1\n    if l - positions[-1] >= d:\n        additional_birds += 1\n\n    return str(additional_birds)",
        "test": "",
        "num_ids": 136,
        "indeed": false
    },
    {
        "number": 2986,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    lines = stdin.split('\\n')[1:]\n\n    def process_line(line: str) -> str:\n        cursor = 0\n        result = []\n\n        for char in line:\n            if char == '<':\n                if cursor > 0:\n                    cursor -= 1\n                    result.pop()\n            elif char == '[':\n                cursor = 0\n            elif char == ']':\n                cursor = len(result)\n            else:\n                result.insert(cursor, char)\n                cursor += 1\n\n        return ''.join(result)\n\n    for i in range(T):\n        print(process_line(lines[i]))",
        "test": "",
        "num_ids": 174,
        "indeed": false
    },
    {
        "number": 2987,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_revenue(price, seats_left, weeks_left):\n        return price * seats_left * (weeks_left + 1)\n\n    def find_max_revenue(prices, seats_left, weeks_left):\n        max_revenue = 0\n        max_price = 0\n        for price in prices:\n            revenue = calculate_revenue(price, seats_left, weeks_left)\n            if revenue > max_revenue:\n                max_revenue = revenue\n                max_price = price\n        return max_revenue, max_price\n\n    input_data = stdin.split(\"\\n\")\n    N, W = map(int, input_data[0].split())\n    estimates = []\n    for i in range(1, len(input_data), 1):\n        line = input_data[i].split()\n        K = int(line[0])\n        prices = list(map(int, line[1:K + 1]))\n        seats = list(map(int, line[K + 1:]))\n        estimates.append((prices, seats))\n\n    total_revenue = 0\n    for i in range(W, -1, -1):\n        if i == W:\n            max_revenue, max_price = find_max_revenue(estimates[i][0], N, i)\n            total_revenue += max_revenue\n        else:\n            for j in range(len(estimates[i][0])):\n                price = estimates[i][0][j]\n                if price == max_price:\n                    seats_left = min(N, estimates[i][1][j])\n                    total_revenue += calculate_revenue(price, seats_left, i)\n                    N -= seats_left\n                    break\n\n    return f\"{total_revenue}\\n{max_price}\"",
        "test": "",
        "num_ids": 452,
        "indeed": false
    },
    {
        "number": 2988,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(src, target, visited, graph, cost):\n        if src == target:\n            return cost\n        if src in visited:\n            return -1\n        visited.add(src)\n        for neighbor, c in graph[src]:\n            if neighbor not in visited:\n                res = dfs(neighbor, target, visited, graph, cost + c)\n                if res != -1:\n                    return res\n        return -1\n\n    def build_graph(n, m, teleport_trips):\n        graph = {i: [] for i in range(1, n + 1)}\n        for a, b, c in teleport_trips:\n            graph[a].append((b, c))\n            graph[b].append((a, c))\n        return graph\n\n    def find_min_cost(graph, n, dragon_balls):\n        min_cost = float('inf')\n        for i in range(1, n + 1):\n            visited = set()\n            cost = dfs(i, dragon_balls[0], visited, graph, 0)\n            if cost != -1:\n                min_cost = min(min_cost, cost)\n        return min_cost if min_cost != float('inf') else -1\n\n    n, m = map(int, stdin.readline().split())\n    teleport_trips = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    dragon_balls = list(map(int, stdin.readline().split()))\n\n    graph = build_graph(n, m, teleport_trips)\n    min_cost = find_min_cost(graph, n, dragon_balls)\n\n    return str(min_cost)",
        "test": "",
        "num_ids": 423,
        "indeed": false
    },
    {
        "number": 2989,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(capacity, source, target):\n        visited = [False] * (n + 1)\n        queue = [(source, 1000000000)]\n        while queue:\n            node, flow = queue.pop(0)\n            if node == target:\n                return flow\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, neighbor_capacity in capacity[node].items():\n                    if not visited[neighbor] and neighbor_capacity > 0:\n                        queue.append((neighbor, min(flow, neighbor_capacity)))\n        return 0\n\n    n, p, k = map(int, stdin.readline().split())\n    capacity = {i: {} for i in range(1, n + 1)}\n    for _ in range(p):\n        a, b, c = map(int, stdin.readline().split())\n        capacity[a][b] = c\n        capacity[b][a] = c\n\n    max_water = [bfs(capacity, 1, 2)]\n    for _ in range(k):\n        a, b, c = map(int, stdin.readline().split())\n        capacity[a][b] += c\n        capacity[b][a] += c\n        max_water.append(bfs(capacity, 1, 2))\n\n    return \"\\n\".join(map(str, max_water)) + \"\\n\" ",
        "test": "",
        "num_ids": 353,
        "indeed": false
    },
    {
        "number": 2990,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_player(player_list, preferences):\n        for player in preferences:\n            if player in player_list:\n                return player\n        return None\n\n    def draft_players(n, k, player_list, preferences):\n        selected_players = []\n        for i in range(n):\n            selected_players.append([])\n\n        for i in range(k):\n            for j in range(n):\n                if len(selected_players[j]) < k:\n                    player = find_player(player_list, preferences[j])\n                    selected_players[j].append(player)\n                    player_list.remove(player)\n\n        return selected_players\n\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    preferences = []\n    for i in range(1, n + 1):\n        q, *players = input_list[i].split()\n        preferences.append(players)\n\n    p = int(input_list[n + 1])\n    player_list = input_list[n + 2:n + 2 + p]\n\n    selected_players = draft_players(n, k, player_list, preferences)\n\n    output = []\n    for i in range(n):\n        output.append(' '.join(selected_players[i]))\n\n    return '\\n'.join(output)",
        "test": "",
        "num_ids": 354,
        "indeed": false
    },
    {
        "number": 2991,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    remaining_gnomes = list(map(int, stdin.split()[1:]))\n    original_sequence = []\n\n    for i in range(1, n + 1):\n        if i not in remaining_gnomes:\n            original_sequence.append(i)\n\n    for gnome in remaining_gnomes:\n        index = original_sequence.index(gnome)\n        original_sequence = original_sequence[:index] + [gnome] + original_sequence[index:]\n\n    return \"\\n\".join(map(str, original_sequence))",
        "test": "",
        "num_ids": 150,
        "indeed": false
    },
    {
        "number": 2992,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_range(n, m, roads):\n        max_length = 0\n        for road in roads:\n            max_length = max(max_length, road[2])\n\n        dp = [float('inf')] * n\n        dp[0] = 0\n\n        for i in range(n):\n            for road in roads:\n                if dp[road[0]] != float('inf'):\n                    dp[road[1]] = min(dp[road[1]], dp[road[0]] + road[2])\n\n        return dp[n-1] + max_length\n\n    def main():\n        n, m = map(int, stdin.readline().strip().split())\n        roads = [list(map(int, stdin.readline().strip().split())) for _ in range(m)]\n\n        min_range = find_min_range(n, m, roads)\n        return str(min_range) if min_range != float('inf') else 'IMPOSSIBLE'\n\n    return main() ",
        "test": "",
        "num_ids": 256,
        "indeed": false
    },
    {
        "number": 2993,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.readline().split())\n    p_A = D / 8\n    p_B = 1 - p_A\n    encoded_message = float(f\"0.{stdin.readline().strip()}\")\n\n    current_interval = [0, 1]\n    message = []\n\n    for _ in range(N):\n        c = current_interval[0] + p_A * (current_interval[1] - current_interval[0])\n        if encoded_message < c:\n            current_interval = [current_interval[0], c]\n            message.append(\"A\")\n        else:\n            current_interval = [c, current_interval[1]]\n            message.append(\"B\")\n\n    return \"\".join(message)",
        "test": "",
        "num_ids": 189,
        "indeed": false
    },
    {
        "number": 2994,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gravity(grid: List[List[str]]) -> List[List[str]]:\n        R, C = len(grid), len(grid[0])\n        for c in range(C):\n            apple_row = -1\n            for r in range(R - 1, -1, -1):\n                if grid[r][c] == 'a':\n                    apple_row = r\n                elif grid[r][c] == '.' and apple_row != -1:\n                    grid[r][c], grid[apple_row][c] = grid[apple_row][c], grid[r][c]\n                    apple_row -= 1\n        return grid\n\n    def print_grid(grid: List[List[str]]) -> str:\n        return '\\n'.join([''.join(row) for row in grid])\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    grid = [list(lines[i + 1]) for i in range(R)]\n\n    while True:\n        new_grid = gravity(grid)\n        if new_grid == grid:\n            break\n        grid = new_grid\n\n    return print_grid(grid) ",
        "test": "",
        "num_ids": 291,
        "indeed": false
    },
    {
        "number": 2995,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_suspicious(pair1, pair2):\n        return pair1[0] == pair2[0] or pair1[1] == pair2[1]\n\n    def find_division(items, suspicious_pairs):\n        for i in range(1, len(items)):\n            for combination in combinations(items, i):\n                if not any(is_suspicious(pair1, pair2) for pair1, pair2 in product(combination, suspicious_pairs)):\n                    return combination, [item for item in items if item not in combination]\n        return None, None\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    items = lines[1:N + 1]\n    M = int(lines[N + 1])\n    suspicious_pairs = [tuple(line.split()) for line in lines[N + 2:N + 2 + M]]\n\n    walter_items, jesse_items = find_division(items, suspicious_pairs)\n\n    if walter_items and jesse_items:\n        return '\\n'.join([\n            ' '.join(walter_items),\n            ' '.join(jesse_items)\n        ])\n    else:\n        return 'impossible'",
        "test": "",
        "num_ids": 310,
        "indeed": false
    },
    {
        "number": 2996,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    costs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def min_cost(start: int, end: int) -> int:\n        if start >= end:\n            return 0\n        min_cost = float('inf')\n        for i in range(start, end):\n            min_cost = min(min_cost, costs[i][end - i - 1] + min_cost(start, i) + min_cost(i + 1, end))\n        return min_cost\n\n    return str(min_cost(1, n + 1))",
        "test": "",
        "num_ids": 164,
        "indeed": false
    },
    {
        "number": 2997,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(N + 1)]\n\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    visited = [False] * (N + 1)\n    color_changes = 0\n\n    def dfs(node, prev_color):\n        visited[node] = True\n        next_color = (prev_color + 1) % 2\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, next_color)\n            elif neighbor != node:\n                nonlocal color_changes\n                if prev_color != next_color:\n                    color_changes += 1\n\n    dfs(1, 0)\n\n    return str(color_changes)",
        "test": "",
        "num_ids": 240,
        "indeed": false
    },
    {
        "number": 2998,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    umm_words = [word for word in words if all(c in 'um' for c in word if c != ' ')]\n    umm_code = ''.join(c for word in umm_words for c in word if c in 'um')\n    binary_code = ''.join(format(ord(c), '07b') for c in umm_code)\n    ascii_code = [int(binary_code[i:i + 7], 2) for i in range(0, len(binary_code), 7)]\n    message = ''.join(chr(code) for code in ascii_code)\n    return message",
        "test": "",
        "num_ids": 163,
        "indeed": false
    },
    {
        "number": 2999,
        "max_answer_num": 0,
        "max_test_num": 0,
        "total_product": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_winners(n, s, participants):\n        participants.sort(key=lambda x: x[1], reverse=True)\n        total_bets = sum(participant[1] for participant in participants)\n        if total_bets < s:\n            return []\n\n        winning_groups = []\n        current_group = [participants[0][0]]\n        current_sum = participants[0][1]\n\n        for i in range(1, n):\n            if current_sum + participants[i][1] <= s:\n                current_group.append(participants[i][0])\n                current_sum += participants[i][1]\n            else:\n                if current_sum == s:\n                    winning_groups.append(current_group)\n                current_group = [participants[i][0]]\n                current_sum = participants[i][1]\n\n        if current_sum == s:\n            winning_groups.append(current_group)\n\n        return winning_groups\n\n    def main():\n        n, s = map(int, stdin.readline().strip().split())\n        participants = []\n        for _ in range(n):\n            name, bet = stdin.readline().strip().split()\n            bet = int(bet)\n            participants.append((name, bet))\n\n        winners = find_winners(n, s, participants)\n        output = [str(len(winners))] + [name for group in winners for name in group]\n        return \"\\n\".join(output)\n\n    return main()",
        "test": "",
        "num_ids": 374,
        "indeed": false
    }
]