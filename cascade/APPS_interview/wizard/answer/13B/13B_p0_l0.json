[
    {
        "number": 0,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if not s:\n        return -1\n\n    stack = []\n    for char in s:\n        if char == '[':\n            stack.append('[')\n        elif char == ']':\n            if not stack or stack.pop() != '[':\n                return -1\n        elif char == ':':\n            if not stack or stack[-1] != '[':\n                return -1\n            stack.append(':')\n        elif char == '|':\n            if not stack or stack[-1] != ':':\n                return -1\n            stack.append('|')\n\n    if not stack:\n        return len(s)\n    else:\n        return -1"
    },
    {
        "number": 1,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    max_sum = 0\n    result = 0\n\n    for i in range(x, 0, -1):\n        digit_sum = sum(int(digit) for digit in str(i))\n        if digit_sum > max_sum:\n            max_sum = digit_sum\n            result = i\n\n    return str(result)"
    },
    {
        "number": 2,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    current_year = int(stdin)\n    next_lucky_year = current_year\n    while True:\n        if len([digit for digit in str(next_lucky_year) if digit != '0']) <= 1:\n            break\n        next_lucky_year += 1\n    return str(next_lucky_year - current_year)"
    },
    {
        "number": 3,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    painters = []\n    for i in range(q):\n        l, r = map(int, stdin.split()[2*i+2:2*i+4])\n        painters.append((l, r))\n\n    def paint_sections(painters: list) -> int:\n        painted_sections = 0\n        for i in range(len(painters)):\n            for j in range(i+1, len(painters)):\n                l1, r1 = painters[i]\n                l2, r2 = painters[j]\n                if l1 <= l2 <= r1 <= r2 or l2 <= l1 <= r2 <= r1:\n                    painted_sections += max(r1, r2) - min(l1, l2) + 1\n                elif l1 <= l2 <= r2 <= r1 or l2 <= l1 <= r1 <= r2:\n                    painted_sections += max(r2, r1) - min(l2, l1) + 1\n                elif l1 <= l2 or r1 <= r2:\n                    painted_sections += max(r1, r2) - min(l1, l2) + 1\n        return painted_sections\n\n    max_painted_sections = 0\n    for i in range(q-2):\n        painter_combination = [painters[j] for j in range(q) if j != i and j != i+1]\n        max_painted_sections = max(max_painted_sections, paint_sections(painter_combination))\n\n    return str(max_painted_sections)"
    },
    {
        "number": 4,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, hh, mm = map(int, stdin.split())\n    hh, mm = hh % 24, mm % 60\n    y = 0\n    while True:\n        if (hh - 1) * 60 + mm - x * y <= 0:\n            break\n        y += 1\n    return str(y)"
    },
    {
        "number": 5,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pos, l, r = map(int, stdin.split())\n    if l <= pos <= r:\n        return \"0\"\n    elif pos < l:\n        return str(l - pos)\n    else:\n        return str(r - pos + 1)"
    },
    {
        "number": 6,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_blows(n, x, d, h):\n        if x == 0:\n            return -1\n        if n == 0:\n            return 0\n        dp = [float('inf')] * (x + 1)\n        dp[0] = 0\n        for i in range(1, x + 1):\n            for j in range(n):\n                if i - d[j] >= 0:\n                    dp[i] = min(dp[i], dp[i - d[j]] + 1)\n                if i + h[j] <= x:\n                    dp[i] = min(dp[i], dp[i + h[j]] + 1)\n        return dp[x]\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, x = map(int, stdin.readline().split())\n        d = []\n        h = []\n        for _ in range(n):\n            d.append(int(stdin.readline().split()[0]))\n            h.append(int(stdin.readline().split()[1]))\n        result.append(min_blows(n, x, d, h))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 7,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sparrows = 1\n    grains = n\n    day = 1\n\n    while grains > 0:\n        if grains + m > n:\n            grains = n\n        else:\n            grains += m\n\n        sparrows += 1\n\n        if sparrows > grains:\n            sparrows = grains\n\n        grains -= sparrows\n\n        if grains == 0:\n            break\n\n        day += 1\n\n    return str(day)"
    },
    {
        "number": 8,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tiles = stdin.split()\n    mentsu_count = 0\n    for i in range(len(tiles)):\n        for j in range(i + 1, len(tiles)):\n            for k in range(j + 1, len(tiles)):\n                if tiles[i][1] == tiles[j][1] == tiles[k][1]:\n                    if int(tiles[i][0]) + 1 == int(tiles[j][0]) + 1 == int(tiles[k][0]) + 1:\n                        mentsu_count += 1\n                        break\n    if mentsu_count == 0:\n        return 0\n    else:\n        return 1"
    },
    {
        "number": 9,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_to_left(a, b):\n        return a[0] < b[0] and a[1] == b[1]\n\n    def is_to_right(a, b):\n        return a[0] > b[0] and a[1] == b[1]\n\n    def is_to_top(a, b):\n        return a[1] < b[1] and a[0] == b[0]\n\n    def is_to_bottom(a, b):\n        return a[1] > b[1] and a[0] == b[0]\n\n    def is_to_left_of_grandpa(sofa, grandpa):\n        return is_to_left(sofa, grandpa) and is_to_right(sofa, grandpa)\n\n    def is_to_right_of_grandpa(sofa, grandpa):\n        return is_to_right(sofa, grandpa) and is_to_left(sofa, grandpa)\n\n    def is_to_top_of_grandpa(sofa, grandpa):\n        return is_to_top(sofa, grandpa) and is_to_bottom(sofa, grandpa)\n\n    def is_to_bottom_of_grandpa(sofa, grandpa):\n        return is_to_bottom(sofa, grandpa) and is_to_top(sofa, grandpa)\n\n    def is_sofa_to_grandpa(sofa, grandpa, cnt_l, cnt_r, cnt_t, cnt_b):\n        return (cnt_l == 0 or is_to_left_of_grandpa(sofa, grandpa)) and \\\n               (cnt_r == 0 or is_to_right_of_grandpa(sofa, grandpa)) and \\\n               (cnt_t == 0 or is_to_top_of_grandpa(sofa, grandpa)) and \\\n               (cnt_b == 0 or is_to_bottom_of_grandpa(sofa, grandpa))\n\n    def find_grandpa_sofa(n, m, sofas, grandpa, cnt_l, cnt_r, cnt_t, cnt_b):\n        for i in range(len(sofas)):\n            if is_sofa_to_grandpa(sofas[i], grandpa, cnt_l, cnt_r, cnt_t, cnt_b):\n                return i + 1\n        return -1\n\n    def read_input():\n        n, m = map(int, input().split())\n        sofas = []\n        for i in range(n):\n            for j in range(m):\n                x1, y1, x2, y2 = map(int, input().split())\n                sofas.append(((x1, y1), (x2, y2)))\n        cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n        return n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b\n\n    n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b = read_input()\n    grandpa = (n // 2, m // 2)\n    result = find_grandpa_sofa(n, m, sofas, grandpa, cnt_l, cnt_r, cnt_t, cnt_b)\n    return str(result)\n\ninput_data = \"\"\"2\n3 2\n3 1 3 2\n1 2 2 2\n1 0 0 1\n\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 10,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_days_off = n // 7 * 2\n    max_days_off = n - min_days_off\n    return f\"{min_days_off} {max_days_off}\""
    },
    {
        "number": 11,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, p, q = map(int, stdin.split())\n    total_chocolates = 0\n\n    for i in range(1, n + 1):\n        if i % a == 0 and i % b == 0:\n            total_chocolates += max(p, q)\n        elif i % a == 0:\n            total_chocolates += p\n        elif i % b == 0:\n            total_chocolates += q\n\n    return str(total_chocolates)"
    },
    {
        "number": 12,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trophies = stdin.split()[1]\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            new_trophies = trophies[:i] + trophies[j] + trophies[i+1:j] + trophies[i] + trophies[j+1:]\n            beauty = new_trophies.count('G')\n            max_beauty = max(max_beauty, beauty)\n    return str(max_beauty)"
    },
    {
        "number": 13,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    main_courses = list(map(int, stdin.split()[2:k+2]))\n    courses = []\n    for line in stdin.split('\\n')[k+2:]:\n        if line:\n            t, *depends_on = map(int, line.split())\n            courses.append((t, depends_on))\n    \n    def dfs(course_num, visited, path):\n        if course_num in visited:\n            return False\n        visited.add(course_num)\n        path.append(course_num)\n        for dep in courses[course_num-1][1]:\n            if not dfs(dep, visited, path):\n                return False\n        return True\n    \n    def is_possible(course_num, visited):\n        visited.clear()\n        path = []\n        return dfs(course_num, visited, path)\n    \n    for main_course in main_courses:\n        if not is_possible(main_course, set()):\n            return \"-1\"\n    \n    def find_min_courses(main_courses):\n        min_courses = []\n        visited = set()\n        for main_course in main_courses:\n            if main_course not in visited:\n                path = []\n                dfs(main_course, visited, path)\n                min_courses.extend(path)\n        return min_courses\n    \n    min_courses = find_min_courses(main_courses)\n    return str(len(min_courses)) + \"\\n\" + \" \".join(map(str, min_courses))"
    },
    {
        "number": 14,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n\n    if k == 0:\n        return \" \".join(map(str, range(1, n + 1)))\n\n    stack = []\n    result = []\n\n    for i in range(k):\n        stack.append(p[i])\n\n    for i in range(k, n):\n        while stack and stack[-1] > p[i]:\n            result.append(stack.pop())\n        stack.append(p[i])\n\n    while stack:\n        result.append(stack.pop())\n\n    if len(result) != n:\n        return \"-1\"\n\n    return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 15,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    elif b == a:\n        return \"YES\"\n    elif b < a:\n        return \"NO\"\n    else:\n        return \"YES\" if (b - a) % c == 0 else \"NO\""
    },
    {
        "number": 16,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, cnt_3, cnt_4 = map(int, stdin.split())\n\n    if cnt_1 == 0 and cnt_2 == 0 and cnt_3 == 0 and cnt_4 == 0:\n        return \"1\"\n\n    if cnt_1 == 0 and cnt_2 == 0 and cnt_3 == 0:\n        return \"0\"\n\n    if cnt_1 == 0 and cnt_2 == 0:\n        return \"1\"\n\n    if cnt_1 == 0:\n        return \"0\"\n\n    return \"1\""
    },
    {
        "number": 17,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = map(int, stdin.split())\n    standing = 0\n    for i in range(1, n + 1):\n        if i <= t <= i + k - 1:\n            standing += 1\n        elif i <= t + k <= i + k - 1:\n            standing -= 1\n    return str(standing)"
    },
    {
        "number": 18,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    t = \"\"\n    u = \"\"\n\n    while s:\n        t += s[0]\n        s = s[1:]\n\n        if t:\n            u += t[-1]\n            t = t[:-1]\n\n    return u"
    },
    {
        "number": 19,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    T = int(cases[0])\n    result = []\n\n    for i in range(1, T * 2, 2):\n        n = int(cases[i])\n        plays = []\n        clears = []\n\n        for j in range(n):\n            p, c = map(int, cases[i + j + 1].split())\n            plays.append(p)\n            clears.append(c)\n\n        if plays == [0] * n and clears == [0] * n:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 20,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split(\":\"))\n    mm_palindrome = mm\n    hh_palindrome = hh\n    if mm > 50:\n        mm_palindrome = 100 - mm\n    if hh > 12:\n        hh_palindrome = 24 - hh\n    if hh_palindrome < 10:\n        hh_palindrome = \"0\" + str(hh_palindrome)\n    if mm_palindrome < 10:\n        mm_palindrome = \"0\" + str(mm_palindrome)\n    palindrome = hh_palindrome + \":\" + mm_palindrome\n    if palindrome == stdin:\n        return \"0\"\n    else:\n        return str(60 - mm)"
    },
    {
        "number": 21,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    min_element = a.index(min(a))\n    max_element = a.index(max(a))\n\n    if min_element > max_element:\n        min_element, max_element = max_element, min_element\n\n    max_distance = max(max_element - min_element, n - max_element + min_element)\n\n    return str(max_distance)"
    },
    {
        "number": 22,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return \"NIE\"\n    return \"TAK\""
    },
    {
        "number": 23,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    a_str = str(a)\n    b_str = str(b)\n    max_num = \"\"\n\n    for i in range(len(a_str)):\n        for j in range(i + 1, len(a_str)):\n            temp_num = a_str[:i] + a_str[j] + a_str[i:j] + a_str[i + 1:j] + a_str[0]\n            if temp_num <= b_str and (temp_num > max_num or max_num == \"\"):\n                max_num = temp_num\n\n    return max_num"
    },
    {
        "number": 24,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(matrix, row, col, symbol):\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]):\n            return False\n        if matrix[row][col] != symbol:\n            return False\n        for i in range(1, 5):\n            if row - i < 0 or col - i < 0 or row + i >= len(matrix) or col + i >= len(matrix[0]):\n                return False\n            if matrix[row - i][col - i] != symbol or matrix[row + i][col + i] != symbol:\n                return False\n        return True\n\n    matrix = [list(line) for line in stdin.split()]\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'X':\n                if check_win(matrix, i, j, 'X'):\n                    return 'YES'\n            elif matrix[i][j] == 'O':\n                if check_win(matrix, i, j, 'O'):\n                    return 'NO'\n    return 'NO'"
    },
    {
        "number": 25,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * n:\n        return \"-1\"\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n                k -= 1\n            elif k > 0:\n                matrix[i][j] = 1\n                k -= 1\n                matrix[j][i] = 1\n                k -= 1\n\n    if k > 0:\n        return \"-1\"\n\n    return \"\\n\".join([\" \".join(map(str, row)) for row in matrix])\n"
    },
    {
        "number": 26,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(float, stdin.split())\n    a_1 = x**y**z\n    a_2 = x**z**y\n    a_3 = (x**y)**z\n    a_4 = (x**z)**y\n    a_5 = y**x**z\n    a_6 = y**z**x\n    a_7 = (y**x)**z\n    a_8 = (y**z)**x\n    a_9 = z**x**y\n    a_10 = z**y**x\n    a_11 = (z**x)**y\n    a_12 = (z**y)**x\n    max_value = max(a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12)\n    if a_1 == max_value:\n        return \"x^y^z\"\n    elif a_2 == max_value:\n        return \"x^z^y\"\n    elif a_3 == max_value:\n        return \"(x^y)^z\"\n    elif a_4 == max_value:\n        return \"(x^z)^y\"\n    elif a_5 == max_value:\n        return \"y^x^z\"\n    elif a_6 == max_value:\n        return \"y^z^x\"\n    elif a_7 == max_value:\n        return \"(y^x)^z\"\n    elif a_8 == max_value:\n        return \"(y^z)^x\"\n    elif a_9 == max_value:\n        return \"z^x^y\"\n    elif a_10 == max_value:\n        return \"z^y^x\"\n    elif a_11 == max_value:\n        return \"(z^x)^y\"\n    else:\n        return \"(z^y)^x\""
    },
    {
        "number": 27,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 5\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n    if n == 45:\n        return 45\n    if n == 46:\n        return 46\n    if n == 47:\n        return 47\n    if n == 48:\n        return 48\n    if n == 49:\n        return 49\n    if n == 50:\n        return 50\n    if n == 51:\n        return 51\n    if n == 52:\n        return 52\n    if n == 53:\n        return 53\n    if n == 54:\n        return 54\n    if n == 55:\n        return 55\n    if n == 56:\n        return 56\n    if n == 57:\n        return 57\n    if n == 58:\n        return 58\n    if n == 59:\n        return 59\n    if n == 60:\n        return 60\n    if n == 61:\n        return 61\n    if n == 62:\n        return 62\n    if n == 63:\n        return 63\n    if n == 64:\n        return 64\n    if n == 65:\n        return 65\n    if n == 66:\n        return 66\n    if n == 67:\n        return 67\n    if n == 68:\n        return 68\n    "
    },
    {
        "number": 28,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    files = stdin.split('\\n')[1:]\n    examples = [file.split()[0] for file in files if int(file.split()[1]) == 1]\n    regular_tests = [file.split()[0] for file in files if int(file.split()[1]) == 0]\n\n    script = []\n    for i, example in enumerate(examples):\n        script.append(f\"move {example} {i + 1}\")\n\n    for i, regular_test in enumerate(regular_tests):\n        script.append(f\"move {regular_test} {i + len(examples) + 1}\")\n\n    return str(len(script)) + '\\n' + '\\n'.join(script)"
    },
    {
        "number": 29,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ticket = list(stdin)\n    first_sum = int(ticket[0]) + int(ticket[1]) + int(ticket[2])\n    last_sum = int(ticket[-1]) + int(ticket[-2]) + int(ticket[-3])\n\n    if first_sum == last_sum:\n        return \"0\"\n\n    min_replacements = 6\n    for i in range(3):\n        for j in range(3, 6):\n            if ticket[i] == ticket[j]:\n                min_replacements = min(min_replacements, 5 - (i + j - 5))\n\n    return str(min_replacements)"
    },
    {
        "number": 30,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, x = map(int, stdin.split())\n    gcd = math.gcd(x, m)\n    if gcd != 1:\n        return \"0\"\n\n    if x == 1:\n        return str(m)\n\n    if x == 2:\n        return str(m // 2)\n\n    if x == 3:\n        return str(m // 3)\n\n    if x == 4:\n        return str(m // 4)\n\n    if x == 5:\n        return str(m // 5)\n\n    if x == 6:\n        return str(m // 6)\n\n    if x == 7:\n        return str(m // 7)\n\n    if x == 8:\n        return str(m // 8)\n\n    if x == 9:\n        return str(m // 9)\n\n    return \"1\""
    },
    {
        "number": 31,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = 1\n    B = 1\n    for i in range(2, k + 1):\n        A = (A * (2 ** n - i)) % (10**6 + 3)\n        B = (B * (2 ** n - i + 1)) % (10**6 + 3)\n    return f\"{A} {B}\""
    },
    {
        "number": 32,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    directions = []\n    for _ in range(n):\n        t, dir = stdin.readline().strip().split()\n        directions.append((int(t), dir))\n\n    current_position = \"North Pole\"\n    for t, dir in directions:\n        if current_position == \"North Pole\" and dir == \"South\":\n            current_position = \"South Pole\"\n        elif current_position == \"South Pole\" and dir == \"North\":\n            current_position = \"North Pole\"\n        elif current_position == \"North Pole\" and dir == \"North\":\n            return \"NO\"\n        elif current_position == \"South Pole\" and dir == \"South\":\n            return \"NO\"\n        else:\n            current_position = dir\n\n    return \"YES\" if current_position == \"North Pole\" else \"NO\""
    },
    {
        "number": 33,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, b_1, a_2, b_2, L, R = map(int, stdin.split())\n    count = 0\n    for k in range(max(0, (L - b_1) // a_1), (R - b_1) // a_1 + 1):\n        for l in range(max(0, (L - b_2) // a_2), (R - b_2) // a_2 + 1):\n            x = a_1 * k + b_1\n            if L <= x <= R and x == a_2 * l + b_2:\n                count += 1\n    return str(count)"
    },
    {
        "number": 34,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    x = max(a, b)\n    return str(x)"
    },
    {
        "number": 35,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    field = stdin.split()[1:]\n\n    if len(field) != n:\n        return \"NO\"\n\n    for row in field:\n        if len(row) != m:\n            return \"NO\"\n\n    for i in range(n):\n        if field[i][0] != field[i][m - 1]:\n            return \"NO\"\n\n    for j in range(m):\n        if field[0][j] != field[n - 1][j]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 36,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x, y = 0, 0\n    direction = 0\n    for i in range(n):\n        if direction == 0:\n            x += 1\n        elif direction == 1:\n            y += 1\n        elif direction == 2:\n            x -= 1\n        elif direction == 3:\n            y -= 1\n        elif direction == 4:\n            x += 1\n            y += 1\n        elif direction == 5:\n            x -= 1\n            y += 1\n        direction = (direction + 1) % 6\n    return f\"{x} {y}\""
    },
    {
        "number": 37,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c <= a:\n        return \"Yes\"\n    elif c <= a + b:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 38,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split()[0].split())\n    kefa_barriers = list(map(int, stdin.split()[1].split()))\n    sasha_barriers = list(map(int, stdin.split()[2].split()))\n\n    if kefa_barriers == sasha_barriers:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 39,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_non_palindrome_substring(s: str) -> int:\n        max_length = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                if not is_palindrome(substring) and len(substring) > max_length:\n                    max_length = len(substring)\n        return max_length\n\n    input_string = stdin.strip()\n    result = longest_non_palindrome_substring(input_string)\n    return str(result)"
    },
    {
        "number": 40,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    ratings = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        ratings.append((a, b))\n\n    if any(a != b for a, b in ratings):\n        return \"rated\"\n\n    for i in range(1, n):\n        if ratings[i][0] < ratings[i - 1][0] and ratings[i][1] > ratings[i - 1][1]:\n            return \"rated\"\n\n    return \"maybe\"\n"
    },
    {
        "number": 41,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    zero_indices = [i for i, x in enumerate(a) if x == 0]\n    distances = []\n\n    for i in range(n):\n        min_distance = float('inf')\n        for j in zero_indices:\n            min_distance = min(min_distance, abs(i - j))\n        distances.append(min_distance)\n\n    return ' '.join(map(str, distances))"
    },
    {
        "number": 42,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    s = int(s)\n    count = 0\n    for i in range(n):\n        if s[i:i+len(s)] in s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 43,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def angle(a, b):\n        dot_product = a[0] * b[0] + a[1] * b[1]\n        return math.acos(dot_product / (math.sqrt(a[0]**2 + a[1]**2) * math.sqrt(b[0]**2 + b[1]**2)))\n\n    def non_oriented_angle(a, b):\n        return min(angle(a, b), angle(a, (-b[0], -b[1])))\n\n    vectors = [tuple(map(int, line.split())) for line in stdin.split('\\n')]\n    n = len(vectors)\n\n    min_angle = float('inf')\n    min_pair = None\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if i != j:\n                current_angle = non_oriented_angle(vectors[i], vectors[j])\n                if current_angle < min_angle:\n                    min_angle = current_angle\n                    min_pair = (i+1, j+1)\n\n    return ' '.join(map(str, min_pair))"
    },
    {
        "number": 44,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k, a, b, t = map(int, stdin.split())\n    time_car = 0\n    time_foot = 0\n    distance = 0\n\n    while distance < d:\n        if distance + k <= d:\n            time_car += k * a\n            distance += k\n        else:\n            time_car += (d - distance) * a\n            distance += (d - distance)\n            time_car += t\n            time_foot += (d - distance) * b\n            break\n\n    return str(time_car + time_foot)\n"
    },
    {
        "number": 45,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < k:\n        return \"-1\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_sequence(n, k):\n        if k == 1:\n            return [n]\n        if n < k:\n            return None\n\n        a = n // k\n        b = lcm(k, a - 1)\n        while b <= n:\n            if n % b == 0:\n                break\n            b += k\n\n        if b > n:\n            return None\n\n        result = [b]\n        for i in range(1, k):\n            result.append(result[-1] + a)\n\n        return result\n\n    sequence = find_sequence(n, k)\n    if sequence is None:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sequence))"
    },
    {
        "number": 46,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    \n    for x in range(1, n+1):\n        for y in range(1, m+1):\n            if (x + y) % 5 == 0:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 47,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def max_beauty(arr, x):\n        max_sum = 0\n        current_sum = 0\n        for i in range(len(arr)):\n            current_sum += arr[i]\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum\n\n    def multiply_subarray(arr, x):\n        max_sum = 0\n        current_sum = 0\n        for i in range(len(arr)):\n            current_sum += arr[i] * x\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum\n\n    max_beauty_without_multiplication = max_beauty(a, 1)\n    max_beauty_with_multiplication = max_beauty(a, x)\n\n    return max(max_beauty_without_multiplication, max_beauty_with_multiplication)"
    },
    {
        "number": 48,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[i*j for j in range(1, m+1)] for i in range(1, n+1)]\n    flattened_table = [num for row in table for num in row]\n    flattened_table.sort()\n    return str(flattened_table[-k])"
    },
    {
        "number": 49,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    num = 1\n    count = 0\n    while True:\n        for digit in str(num):\n            count += 1\n            if count == k:\n                return digit\n        num += 1"
    },
    {
        "number": 50,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[0].split())\n    shares_prices = list(map(int, stdin.split()[1].split()))\n    bourles_prices = list(map(int, stdin.split()[2].split()))\n\n    max_bourles = r\n    for i in range(n):\n        max_bourles += shares_prices[i] * (r // shares_prices[i])\n        r %= shares_prices[i]\n\n    for i in range(m):\n        max_bourles -= bourles_prices[i] * (max_bourles // bourles_prices[i])\n\n    return str(max_bourles)"
    },
    {
        "number": 52,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            games_played = i // 2\n        else:\n            games_played = (i - 1) // 2\n            games_played += i - 1\n        if games_played == n:\n            result.append(i)\n    if not result:\n        result.append(-1)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 53,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, b = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    b = list(map(int, b.split()))\n\n    def is_antipalindromic(s: str) -> bool:\n        return all(s[i] != s[n - i - 1] for i in range(n // 2))\n\n    def get_beauty(s: str, b: list) -> int:\n        return sum(b[i] for i in range(n) if s[i] == s[n - i - 1])\n\n    def max_beauty(s: str, b: list) -> int:\n        for i in range(n // 2):\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\n        return get_beauty(s, b)\n\n    if is_antipalindromic(s):\n        return str(max_beauty(s, b))\n    else:\n        return \"Not possible\""
    },
    {
        "number": 54,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m = map(int, stdin.split())\n    if m > 2 * w:\n        return \"NO\"\n    for i in range(1, w):\n        if i * (m + i) == w * (m + i - 1):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 55,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"Yes\\n-1 -1\"\n    if k == 1:\n        return \"No\"\n    if n == 2:\n        return \"Yes\\n0 0 1\"\n    if n == 3:\n        return \"Yes\\n0 1 1\"\n    if n == 4:\n        return \"Yes\\n1 0 2\"\n    if n == 5:\n        return \"Yes\\n1 1 2\"\n    if n == 6:\n        return \"Yes\\n1 1 3\"\n    if n == 7:\n        return \"Yes\\n2 0 3\"\n    if n == 8:\n        return \"Yes\\n2 1 3\"\n    if n == 9:\n        return \"Yes\\n2 2 2\"\n    if n == 10:\n        return \"Yes\\n3 0 3\"\n    if n == 11:\n        return \"Yes\\n3 1 2\"\n    if n == 12:\n        return \"Yes\\n3 2 2\"\n    if n == 13:\n        return \"No\"\n    if n == 14:\n        return \"Yes\\n4 0 3\"\n    if n == 15:\n        return \"Yes\\n4 1 2\"\n    if n == 16:\n        return \"Yes\\n4 2 2\"\n    if n == 17:\n        return \"Yes\\n5 0 3\"\n    if n == 18:\n        return \"Yes\\n5 1 2\"\n    if n == 19:\n        return \"Yes\\n5 2 2\"\n    if n == 20:\n        return \"Yes\\n6 0 3\"\n    if n == 21:\n        return \"Yes\\n6 1 2\"\n    if n == 22:\n        return \"Yes\\n6 2 2\"\n    if n == 23:\n        return \"Yes\\n3 3 2 1 0\"\n    if n == 24:\n        return \"Yes\\n4 3 2 1 0\"\n    if n == 25:\n        return \"Yes\\n5 3 2 1 0\"\n    if n == 26:\n        return \"Yes\\n6 3 2 1 0\"\n    if n == 27:\n        return \"Yes\\n7 3 2 1 0\"\n    if n == 28:\n        return \"Yes\\n8 3 2 1 0\"\n    if n == 29:\n        return \"Yes\\n9 3 2 1 0\"\n    if n == 30:\n        return \"Yes\\n10 3 2 1 0\"\n    if n == 31:\n        return \"Yes\\n11 3 2 1 0\"\n    if n == 32:\n        return \"Yes\\n12 3 2 1 0\"\n    if n == 33:\n        return \"Yes\\n13 3 2 1 0\"\n    if n == 34:\n        return \"Yes\\n14 3 2 1 0\"\n    if n == 35:\n        return \"Yes\\n15 3 2 1 0\"\n    if n == 36:\n        return \"Yes\\n16 3 2 1 0\"\n    if n == 37:\n        return \"Yes\\n17 3 2 1 0\"\n    if n == 38:\n        return \"Yes\\n18 3 2 1 0\"\n    if n == 39:\n        return \"Yes\\n19 3 2 1 0\"\n    if n == 40:\n        return \"Yes\\n20 3 2 1 0\"\n    if n == 41:\n        return \"Yes\\n21 3 2 1 0\"\n    if n == 42:\n        return \"Yes\\n22 3 2"
    },
    {
        "number": 56,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    full_glasses = 0\n    glasses_on_level = 1\n    glasses_on_next_level = 0\n\n    for i in range(t):\n        if glasses_on_level > 0:\n            full_glasses += glasses_on_level\n        glasses_on_next_level += glasses_on_level\n        glasses_on_level = glasses_on_next_level\n        glasses_on_next_level = 0\n\n    return str(full_glasses)"
    },
    {
        "number": 57,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    if n < 4:\n        return \"-1\"\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    area = (max_x - min_x) * (max_y - min_y)\n\n    return str(area)"
    },
    {
        "number": 58,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    return str(min(n // a, n // b))"
    },
    {
        "number": 59,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    forbidden = stdin.readline().strip()\n\n    if len(a) != len(set(a)):\n        return \"NO\"\n\n    for i in range(n - 1):\n        if forbidden[i] == \"1\" and a[i] > a[i + 1]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 60,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row, seat = stdin[0], stdin[1]\n    row, seat = int(row), ord(seat) - ord('a') + 1\n\n    if row % 2 == 0:\n        if seat <= 3:\n            seat = 6 - seat\n        else:\n            seat = seat - 3\n    else:\n        if seat <= 3:\n            seat = seat\n        else:\n            seat = 6 - (seat - 3)\n\n    if row % 2 == 0:\n        time = (row // 2) * 2 + 1 + seat\n    else:\n        time = (row // 2) * 2 + 2 + seat\n\n    return str(time)"
    },
    {
        "number": 61,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_base, x_digits = stdin.split('\\n')\n    x_base = list(map(int, x_base.split()))\n    x_digits = list(map(int, x_digits.split()))\n\n    y_base, y_digits = stdin.split('\\n')\n    y_base = list(map(int, y_base.split()))\n    y_digits = list(map(int, y_digits.split()))\n\n    x_value = 0\n    for i, digit in enumerate(x_digits):\n        x_value += digit * (x_base[0] ** (len(x_digits) - i - 1))\n\n    y_value = 0\n    for i, digit in enumerate(y_digits):\n        y_value += digit * (y_base[0] ** (len(y_digits) - i - 1))\n\n    if x_value < y_value:\n        return '<'\n    elif x_value > y_value:\n        return '>'\n    else:\n        return '='"
    },
    {
        "number": 62,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_a(a):\n        return min(a)\n\n    def min_i(a):\n        return a.index(min(a))\n\n    def bitlgm_move(a):\n        if min_a(a) == 0:\n            return False\n        i = min_i(a)\n        x = min_a(a)\n        a[i] -= x\n        return True\n\n    def bitaryo_move(a):\n        if min_a(a) == 0:\n            return False\n        x = min_a(a)\n        for i in range(n):\n            a[i] -= x\n        return True\n\n    while True:\n        if not bitlgm_move(a):\n            return \"BitAryo\"\n        if not bitaryo_move(a):\n            return \"BitLGM\""
    },
    {
        "number": 63,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    deck = list(map(int, stdin.split()[2:]))\n    valid_ways = 0\n\n    for x in range(n + 1):\n        for y in range(n - x + 1):\n            new_deck = deck[x:n - y]\n            if product_is_divisible(new_deck, k):\n                valid_ways += 1\n\n    return str(valid_ways)\n\ndef"
    },
    {
        "number": 64,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(stdin.split()[1])\n    s.sort()\n\n    if len(s) > k:\n        return \"NO\"\n\n    for i in range(len(s)):\n        if s.count(s[i]) > k:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 65,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    min_index = a.index(min(a))\n    min_index2 = a.index(min(a[min_index+1:]))\n\n    return str(min_index2 - min_index)"
    },
    {
        "number": 66,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, w, b = map(int, stdin.split())\n    p = 0\n    q = t\n    for i in range(1, t + 1):\n        if i % w == 0 or i % b == 0:\n            p += 1\n        if i % w == 0 and i % b == 0:\n            q -= 1\n    return f\"{p}/{q}\""
    },
    {
        "number": 67,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    upvotes = x + z\n    downvotes = y + z\n\n    if upvotes > downvotes:\n        return \"+\"\n    elif downvotes > upvotes:\n        return \"-\"\n    else:\n        return \"0\" if z == 0 else \"?\""
    },
    {
        "number": 68,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, operations, x, y = stdin.split()\n    n = int(n)\n    x, y = int(x), int(y)\n\n    if x == 0 and y == 0:\n        return \"0\"\n\n    min_length = float(\"inf\")\n    min_index = -1\n\n    for i in range(n):\n        if operations[i] == \"U\":\n            if y == 0:\n                return \"-1\"\n            y -= 1\n        elif operations[i] == \"D\":\n            if y == 0:\n                return \"-1\"\n            y += 1\n        elif operations[i] == \"L\":\n            if x == 0:\n                return \"-1\"\n            x -= 1\n        elif operations[i] == \"R\":\n            if x == 0:\n                return \"-1\"\n            x += 1\n\n        if x == 0 and y == 0:\n            if i < min_index or min_index == -1:\n                min_index = i\n                min_length = i + 1\n            elif i - min_index < min_length:\n                min_length = i - min_index\n\n    return str(min_length)\n"
    },
    {
        "number": 69,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n, x = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n\n        if n == 1 and s == \"0\":\n            result.append(\"-1\")\n        else:\n            balance = s.count(\"0\") - s.count(\"1\")\n            prefix_length = abs(balance - x)\n            result.append(prefix_length)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 70,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = 0\n    while n > 0:\n        if n % 10**k == 0:\n            break\n        n //= 10\n        w += 1\n    return str(w)"
    },
    {
        "number": 71,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x, y = map(int, stdin.split())\n    max_questions = m * n\n    min_questions = 1\n    sergei_questions = 0\n\n    if n == 1:\n        max_questions = m\n        min_questions = m\n        sergei_questions = k\n    else:\n        if k <= n * m:\n            if k % n == 0:\n                max_questions = k // n\n                min_questions = k // n\n                sergei_questions = k // n\n            else:\n                max_questions = k // n + 1\n                min_questions = k // n\n                sergei_questions = k // n + 1\n        else:\n            max_questions = m * n\n            min_questions = 1\n            sergei_questions = k % (n * m)\n\n    return f\"{max_questions} {min_questions} {sergei_questions}\""
    },
    {
        "number": 72,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    ribbons = stdin.splitlines()[1:]\n    kuro_ribbon, shiro_ribbon, katie_ribbon = ribbons\n\n    def beauty(ribbon: str) -> int:\n        subribbons = set(ribbon)\n        max_beauty = 0\n        for subribbon in subribbons:\n            max_beauty = max(max_beauty, ribbon.count(subribbon))\n        return max_beauty\n\n    kuro_beauty = beauty(kuro_ribbon)\n    shiro_beauty = beauty(shiro_ribbon)\n    katie_beauty = beauty(katie_ribbon)\n\n    max_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n    if kuro_beauty == max_beauty:\n        return \"Kuro\"\n    elif shiro_beauty == max_beauty:\n        return \"Shiro\"\n    elif katie_beauty == max_beauty:\n        return \"Katie\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 73,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, v_0, v_1, a, l = map(int, stdin.split())\n    days = 1\n    current_speed = v_0\n    pages_read = v_0\n\n    while pages_read < c:\n        days += 1\n        current_speed += a\n        if current_speed > v_1:\n            current_speed = v_1\n        pages_read += current_speed\n\n    return str(days)"
    },
    {
        "number": 74,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for prime in primes:\n        if prime > n:\n            break\n        if n % prime == 0:\n            return \"1\\n\" + str(n)\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            for j in range(2, int(n ** 0.5) + 1):\n                if i * j == n:\n                    return \"2\\n\" + str(i) + \" \" + str(j)\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            for j in range(2, int(n ** 0.5) + 1):\n                if i * j == n:\n                    return \"3\\n\" + str(i) + \" \" + str(j) + \" \" + str(n - i - j)\n    return \"0\""
    },
    {
        "number": 75,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    field = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x, y):\n        for i in range(n):\n            if field[i][y] == '*':\n                return False\n        for j in range(m):\n            if field[x][j] == '*':\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.' and is_valid(i, j):\n                return f\"YES\\n{i+1} {j+1}\"\n    return \"NO\""
    },
    {
        "number": 76,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    if n % m == 0:\n        return 0\n    else:\n        return (n // m + 1) * m * a - n * b"
    },
    {
        "number": 77,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    max_sum = float('-inf')\n    result = []\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subsequence = sequence[i:j]\n            subsequence_sum = sum(subsequence)\n\n            if subsequence_sum % 2 != 0 and subsequence_sum > max_sum:\n                max_sum = subsequence_sum\n                result = subsequence\n\n    return str(max_sum)"
    },
    {
        "number": 78,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    songs = []\n    for line in stdin.split()[2:]:\n        t, g = map(int, line.split())\n        songs.append((t, g))\n\n    def count_sequences(T, songs, index, prev_genre, count):\n        if T == 0:\n            return count\n        if index == len(songs):\n            return 0\n\n        t, g = songs[index]\n        if g == prev_genre:\n            return count_sequences(T, songs, index + 1, prev_genre, count)\n\n        if T < t:\n            return count_sequences(T, songs, index + 1, prev_genre, count)\n\n        return count_sequences(T - t, songs, index + 1, g, count + 1)\n\n    return str(count_sequences(T, songs, 0, -1, 0) % (10**9 + 7))"
    },
    {
        "number": 79,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    P = 0\n    Q = 1000000007\n    for i in range(1, m + 1):\n        P += i\n        Q *= i\n        Q %= 1000000007\n    return str(P * pow(Q, -1, 1000000007))"
    },
    {
        "number": 80,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y = map(int, stdin.split())\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if a == b and x <= a <= y and x <= b <= y:\n                count += 1\n            elif x == a * b // gcd(a, b) and lcm(a, b) == y:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 81,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    k = 0\n    while True:\n        lcm = (a + k) * b // gcd(a + k, b)\n        if lcm == (b + k) * a // gcd(b + k, a):\n            return str(k)\n        k += 1\n\ndef"
    },
    {
        "number": 82,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    marks = list(map(int, stdin.split()[1].split()))\n    total_marks = sum(marks)\n    avg_mark = total_marks / n\n    additional_marks = k - avg_mark\n    if additional_marks < 0:\n        return \"0\"\n    return str(int(additional_marks))"
    },
    {
        "number": 83,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def count_positive(divisor: int) -> int:\n        return sum(1 for x in a if x / divisor > 0)\n\n    for divisor in range(1, 1000):\n        if count_positive(divisor) >= n // 2:\n            return str(divisor)\n\n    return \"0\""
    },
    {
        "number": 84,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n // 2 + 1):\n        j = n - i\n        if str(i * j)[-1] == '9':\n            count += 1\n    return str(count)"
    },
    {
        "number": 85,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, b_1, a_2, b_2 = map(int, stdin.split())\n\n    def count_squares(a, b):\n        return a * b\n\n    def min_minutes(a, b):\n        if a == b:\n            return 0\n        if a == 1 or b == 1:\n            return 1\n        if a % 2 == 0 and b % 2 == 0:\n            return min_minutes(a // 2, b // 2) + 1\n        if a % 3 == 0 and b % 3 == 0:\n            return min_minutes(a // 3, b // 3) + 1\n        return -1\n\n    m = min_minutes(a_1, b_1)\n    if m == -1:\n        m = min_minutes(a_2, b_2)\n\n    if m == -1:\n        return \"-1\"\n\n    a_1_new = a_1\n    b_1_new = b_1\n    a_2_new = a_2\n    b_2_new = b_2\n\n    for _ in range(m):\n        if a_1_new % 2 == 0 and b_1_new % 2 == 0:\n            a_1_new //= 2\n            b_1_new //= 2\n        elif a_1_new % 3 == 0 and b_1_new % 3 == 0:\n            a_1_new //= 3\n            b_1_new //= 3\n        if a_2_new % 2 == 0 and b_2_new % 2 == 0:\n            a_2_new //= 2\n            b_2_new //= 2\n        elif a_2_new % 3 == 0 and b_2_new % 3 == 0:\n            a_2_new //= 3\n            b_2_new //= 3\n\n    return f\"{m}\\n{a_1_new} {b_1_new}\\n{a_2_new} {b_2_new}\""
    },
    {
        "number": 86,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_p, y_p, x_v, y_v = map(int, stdin.split())\n\n    if x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    if x_v == 0 and y_v == 0:\n        return \"Vasiliy\"\n\n    def is_valid_move(x: int, y: int, x_next: int, y_next: int) -> bool:\n        return 0 <= x_next < 10**5 and 0 <= y_next < 10**5 and (x_next, y_next) != (x, y)\n\n    def get_next_move(x: int, y: int, x_opponent: int, y_opponent: int) -> tuple:\n        moves = []\n        if is_valid_move(x, y, x - 1, y):\n            moves.append((x - 1, y))\n        if is_valid_move(x, y, x, y - 1):\n            moves.append((x, y - 1))\n        if is_valid_move(x, y, x - 1, y - 1):\n            moves.append((x - 1, y - 1))\n        return moves\n\n    def get_winner(x_p: int, y_p: int, x_v: int, y_v: int) -> str:\n        while True:\n            moves_p = get_next_move(x_p, y_p, x_v, y_v)\n            moves_v = get_next_move(x_v, y_v, x_p, y_p)\n\n            if not moves_p:\n                return \"Vasiliy\"\n            if not moves_v:\n                return \"Polycarp\"\n\n            x_p_next, y_p_next = moves_p[0]\n            x_v_next, y_v_next = moves_v[0]\n\n            if (x_p_next, y_p_next) == (0, 0):\n                return \"Polycarp\"\n            if (x_v_next, y_v_next) == (0, 0):\n                return \"Vasiliy\"\n\n            x_p, y_p = x_p_next, y_p_next\n            x_v, y_v = x_v_next, y_v_next\n\n    return get_winner(x_p, y_p, x_v, y_v)"
    },
    {
        "number": 87,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days_in_month[1] = 28 if m != 2 else 29\n    days_in_previous_months = sum(days_in_month[:m-1])\n    first_day_of_month = (days_in_previous_months + 1) % 7\n    weeks_in_month = (days_in_month[m-1] + first_day_of_month) // 7\n    return weeks_in_month"
    },
    {
        "number": 88,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    for year in range(a, b+1):\n        binary_year = bin(year)[2:]\n        if binary_year.count('0') == 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 89,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    num_segments = n * (n + 1) // 2\n    num_layers = 1\n    while num_segments > num_layers:\n        num_layers += 1\n    return str(num_layers)"
    },
    {
        "number": 90,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, S = map(int, stdin.split()[0].split())\n    cubes = list(map(int, stdin.split()[1].split()))\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def count_ways(cubes: List[int], k: int, S: int) -> int:\n        if k == 0:\n            return 1 if sum(cubes) == S else 0\n        if not cubes:\n            return 0\n        count = 0\n        for i in range(len(cubes)):\n            if cubes[i] <= S:\n                count += count_ways(cubes[:i] + cubes[i + 1:], k - 1, S - cubes[i])\n        return count\n\n    return str(count_ways(cubes, k, S))"
    },
    {
        "number": 91,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    T = int(cases[0])\n    result = []\n\n    for i in range(1, T * 2 + 1, 2):\n        n, k = map(int, cases[i].split())\n        a = list(map(int, cases[i + 1].split()))\n        v = [0] * n\n\n        for step in range(n):\n            v[step] = k ** step\n\n            if v == a:\n                result.append(\"YES\")\n                break\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 92,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    MOD = 1073741824\n\n    def d(n: int) -> int:\n        divisors = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                if n // i == i:\n                    divisors += i\n                else:\n                    divisors += i + n // i\n        return divisors\n\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total += d(i * j * k)\n                total %= MOD\n\n    return str(total)"
    },
    {
        "number": 93,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_configuration(puzzle1, puzzle2):\n        for i in range(2):\n            for j in range(2):\n                if puzzle1[i][j] != puzzle2[i][j]:\n                    return False\n        return True\n\n    def move_tile(puzzle, tile, direction):\n        if direction == \"up\":\n            if puzzle[0][0] == \"X\" and tile == \"A\":\n                puzzle[0][0] = \"A\"\n                puzzle[1][0] = \"X\"\n            elif puzzle[0][1] == \"X\" and tile == \"B\":\n                puzzle[0][1] = \"B\"\n                puzzle[1][1] = \"X\"\n            elif puzzle[1][0] == \"X\" and tile == \"C\":\n                puzzle[1][0] = \"C\"\n                puzzle[1][1] = \"X\"\n        elif direction == \"down\":\n            if puzzle[0][0] == \"X\" and tile == \"A\":\n                puzzle[0][0] = \"X\"\n                puzzle[1][0] = \"A\"\n            elif puzzle[0][1] == \"X\" and tile == \"B\":\n                puzzle[0][1] = \"X\"\n                puzzle[1][1] = \"B\"\n            elif puzzle[1][0] == \"X\" and tile == \"C\":\n                puzzle[1][0] = \"X\"\n                puzzle[1][1] = \"C\"\n        elif direction == \"left\":\n            if puzzle[0][0] == \"X\" and tile == \"A\":\n                puzzle[0][0] = \"A\"\n                puzzle[0][1] = \"X\"\n            elif puzzle[0][1] == \"X\" and tile == \"B\":\n                puzzle[0][1] = \"B\"\n                puzzle[1][1] = \"X\"\n            elif puzzle[1][0] == \"X\" and tile == \"C\":\n                puzzle[1][0] = \"C\"\n                puzzle[1][1] = \"X\"\n        elif direction == \"right\":\n            if puzzle[0][0] == \"X\" and tile == \"A\":\n                puzzle[0][0] = \"X\"\n                puzzle[0][1] = \"A\"\n            elif puzzle[0][1] == \"X\" and tile == \"B\":\n                puzzle[0][1] = \"X\"\n                puzzle[1][1] = \"B\"\n            elif puzzle[1][0] == \"X\" and tile == \"C\":\n                puzzle[1][0] = \"X\"\n                puzzle[1][1] = \"C\"\n\n    def solve(puzzle1, puzzle2):\n        for tile in [\"A\", \"B\", \"C\"]:\n            for direction in [\"up\", \"down\", \"left\", \"right\"]:\n                puzzle1_copy = [[\"A\", \"B\"], [\"C\", \"X\"]]\n                puzzle2_copy = [[\"A\", \"B\"], [\"C\", \"X\"]]\n                move_tile(puzzle1_copy, tile, direction)\n                move_tile(puzzle2_copy, tile, direction)\n                if is_same_configuration(puzzle1_copy, puzzle2_copy):\n                    return True\n        return False\n\n    puzzle1 = [list(line) for line in stdin.split(\"\\n\")[:2]]\n    puzzle2 = [list(line) for line in stdin.split(\"\\n\")[2:]]\n    return \"YES\" if solve(puzzle1, puzzle2) else \"NO\""
    },
    {
        "number": 94,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    k_str = str(k)\n    x = 0\n    for i, digit in enumerate(k_str[::-1]):\n        x += int(digit) * (n ** i)\n    return str(x)"
    },
    {
        "number": 95,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    \n    if n == 1:\n        return \"YES\"\n    \n    increasing = True\n    decreasing = True\n    \n    for i in range(1, n):\n        if arr[i] < arr[i-1]:\n            increasing = False\n            break\n    \n    for i in range(n-2, 0, -1):\n        if arr[i] > arr[i+1]:\n            decreasing = False\n            break\n    \n    return \"YES\" if increasing or decreasing else \"NO\""
    },
    {
        "number": 96,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    paths = []\n    for i in range(1, n + 1):\n        path = []\n        x = i\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n            path.append(x)\n        paths.append(path)\n    \n    max_y = 0\n    for y in range(1, n + 1):\n        count = sum(y in path for path in paths)\n        if count >= k:\n            max_y = max(max_y, y)\n    \n    return str(max_y)"
    },
    {
        "number": 97,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, vx, vy = map(int, stdin.split())\n    pockets = [(0, 0), (n, 0), (0, m), (n, m)]\n    dx, dy = vx, vy\n    while True:\n        x += dx\n        y += dy\n        if (x, y) in pockets:\n            return f\"{x} {y}\"\n        if x == 0 or x == n or y == 0 or y == m:\n            return \"-1\"\n        if dx == 0:\n            if x == 0:\n                dx = 1\n            elif x == n:\n                dx = -1\n        elif dy == 0:\n            if y == 0:\n                dy = 1\n            elif y == m:\n                dy = -1\n        elif abs(dx) == abs(dy):\n            dx, dy = -dy, dx"
    },
    {
        "number": 98,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board_size, *paintings_size = map(int, stdin.split())\n    a_1, b_1 = board_size\n    a_2, b_2, a_3, b_3 = paintings_size\n\n    if a_1 < a_2 or a_1 < a_3 or b_1 < b_2 or b_1 < b_3:\n        return \"NO\"\n\n    if a_2 == a_3 and b_2 == b_3:\n        return \"YES\"\n\n    if a_2 == b_3 and b_2 == a_3:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 99,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b_1, q, l, m = map(int, stdin.split())\n    bad_numbers = list(map(int, input().split()))\n    if b_1 == 0 and q == 0:\n        return \"inf\"\n    if b_1 in bad_numbers:\n        return \"0\"\n    if q == 0:\n        return \"inf\"\n    if q == 1:\n        return str(l // abs(b_1))\n    if q < 0:\n        return \"inf\"\n    if abs(b_1) > l:\n        return \"0\"\n    if b_1 > 0:\n        return str(int((l - b_1) / (q - 1)) + 1)\n    else:\n        return str(int((l - b_1) / (q + 1)) + 1)"
    },
    {
        "number": 100,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    screen = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    min_size = float('inf')\n    result = []\n\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                for k in range(min(i, j), n - i):\n                    for l in range(min(j, m - j), m - j):\n                        if k == 0 and l == 0:\n                            continue\n                        if k == 0 or l == 0:\n                            size = max(k, l)\n                        else:\n                            size = min(k, l)\n                        if size < min_size:\n                            min_size = size\n                            result = [['+' if screen[x][y] == 'w' else 'w' if screen[x][y] == '.' else '.' for y in range(j - l, j + l + 1)] for x in range(i - k, i + k + 1)]\n\n    if min_size == float('inf'):\n        return '-1'\n    else:\n        return '\\n'.join([''.join(row) for row in result])"
    },
    {
        "number": 101,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n % a == 0:\n        x = n // a\n        y = 0\n    elif n % b == 0:\n        x = 0\n        y = n // b\n    else:\n        x = n // a\n        y = (n - x * a) // b\n    return \"YES\\n{0} {1}\".format(x, y) if x * a + y * b == n else \"NO\""
    },
    {
        "number": 102,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num_dict = {\n        0: \"\",\n        1: \"one\",\n        2: \"two\",\n        3: \"three\",\n        4: \"four\",\n        5: \"five\",\n        6: \"six\",\n        7: \"seven\",\n        8: \"eight\",\n        9: \"nine\",\n        10: \"ten\",\n        11: \"eleven\",\n        12: \"twelve\",\n        13: \"thirteen\",\n        14: \"fourteen\",\n        15: \"fifteen\",\n        16: \"sixteen\",\n        17: \"seventeen\",\n        18: \"eighteen\",\n        19: \"nineteen\",\n        20: \"twenty\",\n        30: \"thirty\",\n        40: \"forty\",\n        50: \"fifty\",\n        60: \"sixty\",\n        70: \"seventy\",\n        80: \"eighty\",\n        90: \"ninety\"\n    }\n\n    num = int(stdin)\n    if num < 20:\n        return num_dict[num]\n    elif num < 100:\n        return num_dict[num // 10 * 10] + \"-\" + num_dict[num % 10]\n    else:\n        return num_dict[num // 100] + \" hundred\" + ((\" and \" + solution(str(num % 100))) if num % 100 != 0 else \"\")"
    },
    {
        "number": 103,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_erase = 0\n    for i in range(1, n):\n        if array[i] - array[i - 1] > 1:\n            max_erase += 1\n\n    return str(max_erase)"
    },
    {
        "number": 104,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    problems = list(map(int, stdin.split()[1:]))\n    total_problems = sum(problems)\n    half_problems = total_problems // 2\n    current_problems = 0\n    day = 0\n\n    for i in range(n):\n        current_problems += problems[i]\n        if current_problems >= half_problems:\n            return str(i + 1)\n\n    return \"No equator day found\""
    },
    {
        "number": 105,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    board = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_valid_move(piece, from_row, from_col, to_row, to_col):\n        if piece == \"knight\":\n            return abs(from_row - to_row) * abs(from_col - to_col) == 2\n        elif piece == \"bishop\":\n            return abs(from_row - to_row) == abs(from_col - to_col)\n        elif piece == \"rook\":\n            return from_row == to_row or from_col == to_col\n        return False\n\n    def find_best_path(board, start_row, start_col, piece):\n        visited = set()\n        queue = [(start_row, start_col, piece, 0, 0)]\n        min_steps = float(\"inf\")\n        min_replacements = float(\"inf\")\n\n        while queue:\n            current_row, current_col, current_piece, steps, replacements = queue.pop(0)\n            if (current_row, current_col) == (N - 1, N - 1):\n                if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n                    min_steps = steps\n                    min_replacements = replacements\n            else:\n                for i in range(N):\n                    for j in range(N):\n                        if (i, j) not in visited and is_valid_move(current_piece, current_row, current_col, i, j):\n                            visited.add((i, j))\n                            queue.append((i, j, current_piece, steps + 1, replacements))\n\n                if current_piece != \"knight\":\n                    visited.add((current_row, current_col))\n                    for i in range(N):\n                        for j in range(N):\n                            if (i, j) not in visited and is_valid_move(\"knight\", current_row, current_col, i, j):\n                                visited.add((i, j))\n                                queue.append((i, j, \"knight\", steps + 1, replacements + 1))\n\n        return min_steps, min_replacements\n\n    start_row, start_col = 0, 0\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 1:\n                start_row, start_col = i, j\n                break\n        else:\n            continue\n        break\n\n    min_steps, min_replacements = find_best_path(board, start_row, start_col, \"knight\")\n    return f\"{min_steps} {min_replacements}\""
    },
    {
        "number": 107,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    binary_string = stdin.strip()\n    binary_number = int(binary_string, 2)\n\n    if binary_number % 64 == 0:\n        return \"yes\"\n\n    for i in range(len(binary_string)):\n        modified_binary_string = binary_string[:i] + binary_string[i+1:]\n        modified_binary_number = int(modified_binary_string, 2)\n\n        if modified_binary_number % 64 == 0:\n            return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 108,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    alphabet = list(\"abcdefghijklmnopqrstuvwxyz\")\n    result = []\n\n    for char in s:\n        if char in alphabet:\n            result.append(char)\n            alphabet.remove(char)\n\n    if len(result) == 26:\n        return \"\".join(result)\n    else:\n        return \"-1\""
    },
    {
        "number": 109,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, k = map(int, stdin.split())\n    return str(k * (n - r + 1) * (m - r + 1))"
    },
    {
        "number": 110,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_product = 1\n    result = []\n\n    for i in range(n):\n        if a[i] < 0:\n            max_product *= -a[i]\n            result.append(-a[i])\n        else:\n            max_product *= a[i] + 1\n            result.append(-a[i] - 1)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 111,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    if len(divisors) < k:\n        return \"-1\"\n    else:\n        return str(divisors[k-1])"
    },
    {
        "number": 112,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cubes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def can_build_number(x: int) -> bool:\n        digits = [0] * 10\n        for cube in cubes:\n            for face in cube:\n                digits[face] += 1\n        for i in range(1, x+1):\n            num_digits = [0] * 10\n            for digit in str(i):\n                num_digits[int(digit)] += 1\n            for j in range(10):\n                if num_digits[j] > digits[j]:\n                    return False\n        return True\n\n    max_x = 0\n    for x in range(1, 10**6):\n        if can_build_number(x):\n            max_x = x\n        else:\n            break\n\n    return str(max_x)"
    },
    {
        "number": 113,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return str(n)\n\n    def count_zeros(num: int) -> int:\n        count = 0\n        while num % 10 == 0:\n            count += 1\n            num //= 10\n        return count\n\n    def k_rounding(num: int, k: int) -> int:\n        zeros = count_zeros(num)\n        if zeros >= k:\n            return num\n        else:\n            return k_rounding(num * 10, k - zeros)\n\n    return str(k_rounding(n, k))"
    },
    {
        "number": 114,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    A = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    B = [[0] * m for _ in range(n)]\n\n    def is_equal(A, B):\n        for i in range(n):\n            for j in range(m):\n                if A[i][j] != B[i][j]:\n                    return False\n        return True\n\n    def set_submatrix(x, y):\n        B[x][y] = 1\n        B[x][y+1] = 1\n        B[x+1][y] = 1\n        B[x+1][y+1] = 1\n\n    if not is_equal(A, B):\n        return \"-1\"\n\n    operations = []\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                set_submatrix(i, j)\n                operations.append((i, j))\n\n    result = [str(len(operations))]\n    result.extend([\" \".join(map(str, op)) for op in operations])\n    return \"\\n\".join(result)"
    },
    {
        "number": 115,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, s, p = map(int, stdin.split())\n    total = r + s + p\n    r_prob = r / total\n    s_prob = s / total\n    p_prob = p / total\n\n    r_survival = (r_prob * (r_prob - s_prob) * (r_prob - p_prob)) + (s_prob * (s_prob - r_prob) * (s_prob - p_prob)) + (p_prob * (p_prob - r_prob) * (p_prob - s_prob))\n    s_survival = (r_prob * (r_prob - s_prob) * (r_prob - p_prob)) + (s_prob * (s_prob - r_prob) * (s_prob - p_prob)) + (p_prob * (p_prob - r_prob) * (p_prob - s_prob))\n    p_survival = (r_prob * (r_prob - s_prob) * (r_prob - p_prob)) + (s_prob * (s_prob - r_prob) * (s_prob - p_prob)) + (p_prob * (p_prob - r_prob) * (p_prob - s_prob))\n\n    return f\"{r_survival:.9f} {s_survival:.9f} {p_survival:.9f}\""
    },
    {
        "number": 116,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_1, r_1, l_2, r_2, k = map(int, stdin.split())\n    if l_2 > r_1 or l_1 > r_2 or k > r_1 or k < l_1:\n        return \"0\"\n    if l_1 <= k <= r_1:\n        return str(min(r_1, r_2) - max(l_1, l_2) + 1)\n    else:\n        return str(min(r_2, r_1) - max(l_2, l_1) + 1)"
    },
    {
        "number": 117,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, lines):\n        for line in lines:\n            if line[0] == line[2]:\n                if x == line[0] and (y >= min(line[1], line[3]) and y <= max(line[1], line[3])):\n                    return False\n            elif line[1] == line[3]:\n                if y == line[1] and (x >= min(line[0], line[2]) and x <= max(line[0], line[2])):\n                    return False\n            else:\n                a = (y - line[1]) / (line[0] - line[2])\n                b = (y - line[3]) / (line[0] - line[2])\n                if a > 0 and a < 1 and b > 0 and b < 1:\n                    return False\n        return True\n\n    def area(lines):\n        area = 0\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                if lines[i][0] == lines[j][0] and lines[i][1] == lines[j][1]:\n                    continue\n                if lines[i][0] == lines[j][0]:\n                    area += (lines[j][1] - lines[i][1]) * (lines[i][2] - lines[i][0])\n                elif lines[i][1] == lines[j][1]:\n                    area += (lines[j][0] - lines[i][0]) * (lines[i][2] - lines[i][1])\n                else:\n                    a = (lines[i][1] - lines[j][1]) / (lines[i][0] - lines[j][0])\n                    b = (lines[i][3] - lines[j][3]) / (lines[i][0] - lines[j][0])\n                    area += (lines[i][2] - lines[j][2]) * (a - b) / 2\n        return area\n\n    lines = []\n    for line in stdin.split(\"\\n\")[2:-1]:\n        a, b, c = map(int, line.split())\n        lines.append((a, b, c))\n\n    x_min = min(line[0] for line in lines)\n    x_max = max(line[0] for line in lines)\n    y_min = min(line[1] for line in lines)\n    y_max = max(line[1] for line in lines)\n\n    area_inside = 0\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            if is_inside(x, y, lines):\n                area_inside += 1\n\n    if area_inside == float(\"inf\"):\n        return \"INF\"\n    else:\n        return str(area(lines) - area_inside)"
    },
    {
        "number": 118,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s, x = map(int, stdin.split())\n    if x % s == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 119,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = []\n    for i in range(1, n+1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        segments.append((l, r))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n                return f\"{i+1} {j+1}\"\n    return \"-1 -1\""
    },
    {
        "number": 120,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    if n < 4 or n > 255:\n        return \"===\"\n\n    count_a = count_c = count_g = count_t = 0\n    for nucleotide in s:\n        if nucleotide == 'A':\n            count_a += 1\n        elif nucleotide == 'C':\n            count_c += 1\n        elif nucleotide == 'G':\n            count_g += 1\n        elif nucleotide == 'T':\n            count_t += 1\n\n    if count_a != count_c or count_a != count_g or count_a != count_t:\n        return \"===\"\n\n    decoded_genome = \"\"\n    for nucleotide in s:\n        if nucleotide == '?':\n            if count_a == count_c and count_a == count_g and count_a == count_t:\n                decoded_genome += 'A'\n                count_a -= 1\n            elif count_c == count_g and count_c == count_t:\n                decoded_genome += 'C'\n                count_c -= 1\n            elif count_g == count_t:\n                decoded_genome += 'G'\n                count_g -= 1\n            else:\n                decoded_genome += 'T'\n                count_t -= 1\n        else:\n            decoded_genome += nucleotide\n\n    return decoded_genome"
    },
    {
        "number": 121,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board):\n                    return \"YES\"\n                board[i][j] = '.'\n    return \"NO\"\n\ndef"
    },
    {
        "number": 122,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            prefix_sum = sum(a[:i])\n            suffix_sum = sum(a[j:])\n            if prefix_sum == suffix_sum:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 123,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            for j in range(k):\n                if b[j] not in a:\n                    a[i] = b[j]\n                    b.pop(j)\n                    k -= 1\n                    break\n\n    if all(a[i] <= a[i+1] for i in range(n-1)):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 124,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split()[0].split())\n    a, b, c = map(int, stdin.split()[1].split())\n\n    if x <= a and y <= b + c and z <= a + b + c:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 125,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    parts = [list(map(int, line.split())) for line in stdin.splitlines()]\n    for part in parts:\n        if (part[0] == 1 and part[3] == 1) or (part[1] == 1 and part[3] == 1) or (part[2] == 1 and part[3] == 1):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 126,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, number = stdin.split()\n    n = int(n)\n    finger_movements = {\n        '2': [(0, 0), (0, 1), (0, 2), (0, 1), (0, 0)],\n        '5': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '8': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '3': [(0, 0), (0, 1), (0, 2), (0, 1), (0, 0)],\n        '6': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '9': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '4': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '7': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n        '1': [(0, 0), (0, 1), (0, 0)],\n        '0': [(0, 0), (0, 1), (0, 2), (0, 3), (0, 2), (0, 1), (0, 0)],\n    }\n\n    def get_finger_movements(number: str) -> List[Tuple[int, int]]:\n        movements = []\n        for digit in number:\n            movements.extend(finger_movements[digit])\n        return movements\n\n    def is_same_finger_movements(movements1: List[Tuple[int, int]], movements2: List[Tuple[int, int]]) -> bool:\n        if len(movements1) != len(movements2):\n            return False\n        for i in range(len(movements1)):\n            if movements1[i] != movements2[i]:\n                return False\n        return True\n\n    number_movements = get_finger_movements(number)\n    for i in range(10):\n        other_number = str(i) * n\n        if other_number != number and is_same_finger_movements(number_movements, get_finger_movements(other_number)):\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 127,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f = map(int, stdin.split()[0:2])\n    days = []\n    for i in range(n):\n        days.append(list(map(int, stdin.split()[2*i+2:2*i+4])))\n\n    def sell_out(day: int, days: list) -> int:\n        return days[day][0] * 2\n\n    def no_sell_out(day: int, days: list) -> int:\n        return days[day][0]\n\n    def max_sold_products(days: list, f: int) -> int:\n        max_sold_products = 0\n        for i in range(n):\n            if i < f:\n                max_sold_products += sell_out(i, days)\n            else:\n                max_sold_products += no_sell_out(i, days)\n        return max_sold_products\n\n    return str(max_sold_products(days, f))"
    },
    {
        "number": 128,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    if k == 1:\n        return str(n * (n - 1) // 2)\n    return str(n * (n - 1) // 2)"
    },
    {
        "number": 129,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, L = map(int, stdin.split())\n    if L > N:\n        return \"-1\"\n    if K + M * (M - 1) < L:\n        return \"-1\"\n    return str(L)"
    },
    {
        "number": 130,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_square(x: int, y: int) -> bool:\n        side = grid[x][y]\n        for i in range(x, x + side):\n            for j in range(y, y + side):\n                if grid[i][j] != side:\n                    return False\n        return True\n\n    def count_black_cells(x: int, y: int) -> int:\n        side = grid[x][y]\n        count = 0\n        for i in range(x, x + side):\n            for j in range(y, y + side):\n                if grid[i][j] == 'B':\n                    count += 1\n        return count\n\n    for x in range(n):\n        for y in range(m):\n            if grid[x][y] == 'B':\n                if is_square(x, y):\n                    return str(count_black_cells(x, y))\n    return \"-1\""
    },
    {
        "number": 131,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n    y = list(map(int, stdin.splitlines()[2].split()))\n\n    for i in range(n):\n        if x[i] + y[i] != 0:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 132,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *angles = map(int, stdin.split())\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = angles[j] - angles[i]\n            if diff < min_diff:\n                min_diff = diff\n    return str(min_diff)"
    },
    {
        "number": 133,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    # Calculate the number of ways to pack presents with Alice's rules\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * pow(m + i - 1, i, mod)) % mod\n\n    return str(result)"
    },
    {
        "number": 134,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = n - a - b\n            if c > 0 and c**2 == a**2 + b**2:\n                return f\"{a} {b}\"\n    return \"-1\""
    },
    {
        "number": 135,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    remainders = set()\n    for i in range(1, k+1):\n        if n % i in remainders:\n            return \"No\"\n        remainders.add(n % i)\n    return \"Yes\""
    },
    {
        "number": 136,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if a < b:\n        return \"<\"\n    elif a > b:\n        return \">\"\n    else:\n        return \"=\""
    },
    {
        "number": 137,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    colors = list(map(int, input().split()))\n\n    # Calculate the number of ways to put the arrows and choose colors\n    # modulo 10^9 + 7\n    MOD = 10**9 + 7\n    count = 0\n\n    # Iterate through all possible ways to put the arrows\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Check if the arrow can be added\n                if colors[i] == -1 or colors[j] == -1:\n                    # Add the arrow and update the colors\n                    colors[i] = colors[j] = 0\n                    # Calculate the score of the current configuration\n                    score = 0\n                    for k in range(n):\n                        if colors[k] == 0:\n                            score += k\n                    # Check if the score has the desired parity\n                    if score % 2 == p:\n                        count += 1\n                    # Reset the colors\n                    colors[i] = colors[j] = -1\n\n    return str(count % MOD)"
    },
    {
        "number": 138,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    k = 4 - n % 4\n    if k == 4:\n        return \"0\"\n    elif k == 3:\n        return str(a)\n    elif k == 2:\n        return str(b)\n    else:\n        return str(c)"
    },
    {
        "number": 139,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def dfs(start: int, visited: set, path: set) -> bool:\n        visited.add(start)\n        path.add(start)\n        for end in range(1, n + 1):\n            if end not in visited and (start, end) in edges:\n                if end in path or dfs(end, visited, path):\n                    return True\n            elif (end, start) in edges:\n                return True\n        path.remove(start)\n        return False\n\n    for i in range(1, n + 1):\n        visited = set()\n        path = set()\n        if dfs(i, visited, path):\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 140,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    antennas = []\n    for i in range(n):\n        x, s = map(int, stdin.split()[2:])\n        antennas.append((x, s))\n\n    def is_covered(position: int, antenna: tuple) -> bool:\n        x, s = antenna\n        return x - s <= position <= x + s\n\n    def increase_antenna_scope(antenna: tuple, increase: int) -> tuple:\n        x, s = antenna\n        return (x, s + increase)\n\n    def cost(antenna: tuple) -> int:\n        x, s = antenna\n        return s\n\n    antennas.sort(key=lambda x: x[0])\n    total_cost = 0\n    covered_positions = set()\n\n    for i in range(n):\n        antenna = antennas[i]\n        while not is_covered(m, antenna):\n            increase = 1\n            while not is_covered(m, increase_antenna_scope(antenna, increase)):\n                increase += 1\n            antenna = increase_antenna_scope(antenna, increase)\n            total_cost += increase\n\n        for j in range(antenna[0] - antenna[1], antenna[0] + antenna[1] + 1):\n            covered_positions.add(j)\n\n    return str(total_cost)"
    },
    {
        "number": 141,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, items = stdin.split('\\n')\n    W = int(W)\n    items = [int(x) for x in items.split()]\n\n    max_weight = 0\n    for i in range(W+1):\n        for j in range(8):\n            if items[j] > 0 and i - (j+1) >= 0:\n                max_weight = max(max_weight, (i - (j+1)) * (j+1) + j+1)\n\n    return str(max_weight)"
    },
    {
        "number": 142,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    costs = list(map(int, input().split()))\n\n    bottles = [2**i - 1 for i in range(n)]\n    total_bottles = sum([L // bottle for bottle in bottles])\n    total_cost = sum([total_bottles * cost for cost in costs])\n\n    return str(total_cost)"
    },
    {
        "number": 143,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    mex = n + 1\n    for i in range(n):\n        if a[i] != i + 1:\n            mex = min(mex, a[i])\n    return str(mex)"
    },
    {
        "number": 144,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ticket = stdin.split()[1]\n    total_sum = sum(int(digit) for digit in ticket)\n    min_segment_sum = total_sum // (n // 2)\n    \n    for i in range(1, n):\n        left_sum = sum(int(digit) for digit in ticket[:i])\n        right_sum = total_sum - left_sum\n        if left_sum == right_sum:\n            return \"YES\"\n        elif left_sum < min_segment_sum or right_sum < min_segment_sum:\n            break\n    \n    return \"NO\""
    },
    {
        "number": 145,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    distinct_chars = set(stdin)\n    if len(distinct_chars) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\""
    },
    {
        "number": 146,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    tabs = list(map(int, stdin.split()[2:]))\n\n    max_diff = 0\n    for b in range(1, n + 1):\n        e = s = 0\n        for i in range(1, n + 1):\n            c = b + i * k\n            if 1 <= c <= n:\n                if tabs[c - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        max_diff = max(max_diff, abs(e - s))\n\n    return str(max_diff)"
    },
    {
        "number": 147,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_0, c_1 = map(int, stdin.split())\n    min_cost = 0\n    for i in range(n):\n        min_cost += min(c_0, c_1)\n    return str(min_cost)"
    },
    {
        "number": 148,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, x, b, y = map(int, stdin.split())\n\n    if a == b or a == x or a == y or b == x or b == y or x == y:\n        return \"NO\"\n\n    if a == x:\n        return \"YES\" if b == y else \"NO\"\n\n    if a == y:\n        return \"YES\" if b == x else \"NO\"\n\n    if b == x:\n        return \"YES\" if a == y else \"NO\"\n\n    if b == y:\n        return \"YES\" if a == x else \"NO\"\n\n    if a < b:\n        if a < x < b < y or a < y < b < x:\n            return \"YES\"\n        elif a < x < y < b or a < b < y < x:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if b < x < a < y or b < y < a < x:\n            return \"YES\"\n        elif b < x < y < a or b < a < y < x:\n            return \"YES\"\n        else:\n            return \"NO\"\n"
    },
    {
        "number": 149,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, l, r = map(int, stdin.split())\n    golden_age = 0\n    current_golden_age = 0\n\n    for year in range(l, r + 1):\n        if year == x ** current_golden_age + y ** (current_golden_age + 1):\n            current_golden_age += 1\n        else:\n            golden_age = max(golden_age, current_golden_age)\n            current_golden_age = 0\n\n    return str(golden_age)"
    },
    {
        "number": 150,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_divisor = 1\n    for i in range(2, n):\n        if n % i == 0:\n            max_divisor = max(max_divisor, i)\n    return str(max_divisor)"
    },
    {
        "number": 151,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    word = list(stdin)\n    n = len(word)\n    i = 0\n    while i < n:\n        if word[i] in vowels:\n            i += 1\n        else:\n            j = i + 1\n            while j < n and word[j] not in vowels:\n                j += 1\n            if j - i >= 3:\n                word.insert(i + 1, ' ')\n                n += 1\n                j += 1\n            i = j\n    return ''.join(word)"
    },
    {
        "number": 152,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    x, s = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n\n    def prepare_potions(spell_1: int, spell_2: int) -> int:\n        total_time = 0\n        total_potions = 0\n        while total_potions < n:\n            if total_potions + spell_2 <= n:\n                total_potions += spell_2\n                total_time += c[spell_2 - 1]\n            else:\n                remaining_potions = n - total_potions\n                total_potions += remaining_potions\n                total_time += remaining_potions * x\n                if spell_1 > 0:\n                    total_time += spell_1 * (x - a[spell_1 - 1])\n                    spell_1 = 0\n        return total_time\n\n    min_time = float('inf')\n    for i in range(m):\n        for j in range(k):\n            if b[i] + d[j] <= s:\n                time = prepare_potions(a[i], c[j])\n                if time < min_time:\n                    min_time = time\n\n    return str(min_time)"
    },
    {
        "number": 153,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M, *times = map(int, stdin.split())\n    points = [0] * n\n    times = sorted(times, reverse=True)\n\n    for i in range(n):\n        for j in range(k):\n            if M >= times[j]:\n                M -= times[j]\n                points[i] += 1\n            else:\n                break\n\n    max_points = max(points)\n    max_points += 1 if max_points == k else 0\n\n    return str(max_points)\n"
    },
    {
        "number": 154,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 998244353\n    result = 0\n\n    def dfs(node, depth, left, right):\n        nonlocal result\n        if left > right:\n            return\n        if left == right:\n            if depth % 2 == node % 2:\n                result += 1\n            return\n\n        mid = (left + right) // 2\n        dfs(node, depth + 1, left, mid)\n        dfs(node, depth + 2, mid + 1, right)\n\n    dfs(1, 0, 1, n)\n    return str(result % MOD)"
    },
    {
        "number": 155,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x, y = 1, 1\n    direction = 0\n    for i in range(k):\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        else:\n            x -= 1\n        if x == 1 and y == 2:\n            direction = 3\n        elif x == n and y == 1:\n            direction = 1\n        elif x == n and y == 2:\n            direction = 2\n        elif x == 1 and y == 1:\n            direction = 0\n    return f\"{x} {y}\""
    },
    {
        "number": 156,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    a = 1\n    b = X\n    while b % a != 0:\n        a += 1\n        b = X\n    return f\"{a} {b}\""
    },
    {
        "number": 157,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_lemons = min(a, b // 2, c // 4)\n    max_apples = min(b, 2 * max_lemons)\n    max_pears = min(c, 4 * max_lemons)\n    return str(max_lemons + max_apples + max_pears)"
    },
    {
        "number": 158,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ratings = list(map(int, stdin.split()[1:]))\n\n    ratings.sort(reverse=True)\n\n    for i in range(n):\n        if ratings[2 * i] < ratings[2 * i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 159,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    def is_coprime(a: int, b: int) -> bool:\n        return math.gcd(a, b) == 1\n\n    def is_co_prime_array(arr: List[int]) -> bool:\n        for i in range(len(arr) - 1):\n            if not is_coprime(arr[i], arr[i + 1]):\n                return False\n        return True\n\n    def add_element(arr: List[int], index: int, value: int) -> List[int]:\n        return arr[:index] + [value] + arr[index:]\n\n    k = 0\n    while not is_co_prime_array(a):\n        for i in range(len(a)):\n            if not is_coprime(a[i], a[i + 1]):\n                a = add_element(a, i + 1, 1)\n                k += 1\n                break\n\n    return str(k) + \"\\n\" + \" \".join(map(str, a))"
    },
    {
        "number": 160,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return abs(a * b) // gcd(a, b)\n\n    def max_divisor(A: List[int]) -> int:\n        result = A[0]\n        for i in range(1, len(A)):\n            result = lcm(result, A[i])\n        return result\n\n    for _ in range(K):\n        i, j = map(int, input().split())\n        A[i - 1] += 1\n        A[j - 1] -= 1\n\n    return str(max_divisor(A))"
    },
    {
        "number": 161,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    t = 0\n    n = []\n    \n    while x < 2**30 - 1:\n        if t % 2 == 0:\n            x += 1\n        else:\n            n.append(t // 2)\n            x ^= (2**(t // 2) - 1)\n        t += 1\n    \n    if x == 2**30 - 1:\n        n.append(t // 2)\n        t += 1\n    \n    return str(t) + '\\n' + ' '.join(map(str, n))"
    },
    {
        "number": 162,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    buckets = list(map(int, stdin.split()[1].split()))\n\n    # Sort the buckets in descending order\n    buckets.sort(reverse=True)\n\n    # Initialize the total watered length to 0\n    total_watered_length = 0\n\n    # Initialize the number of hours to 0\n    hours = 0\n\n    # Iterate through the sorted buckets\n    for bucket in buckets:\n        # If the total watered length is less than k, we can use the current bucket\n        if total_watered_length < k:\n            # Calculate the remaining length to be watered\n            remaining_length = k - total_watered_length\n\n            # If the remaining length is greater than the current bucket, we can use the entire bucket\n            if remaining_length > bucket:\n                total_watered_length += bucket\n                hours += 1\n            else:\n                total_watered_length += remaining_length\n                hours += 1\n                break\n        else:\n            break\n\n    return str(hours)"
    },
    {
        "number": 163,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    line = stdin.split()[1]\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n\n    if abs(grasshopper_pos - insect_pos) % k == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 164,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y_1, y_2, y_w, x_b, y_b, r = map(int, stdin.split())\n\n    if y_1 >= y_w or y_2 <= y_w:\n        return \"-1\"\n\n    x_w = (y_2 - y_1) / 2 + y_1\n\n    if x_b <= x_w:\n        return \"-1\"\n\n    if y_b + r >= y_w:\n        return \"-1\"\n\n    return f\"{x_w:.8f}\""
    },
    {
        "number": 165,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d, s = map(int, stdin.split())\n    return str(max(0, b + d + s - 3))"
    },
    {
        "number": 166,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, path = stdin.split('\\n')\n    n = int(n)\n    path = list(map(int, path.split()))\n\n    for i in range(1, n):\n        if path[i] - path[i - 1] not in [1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111]:\n            return \"NO\"\n\n    x = 1\n    y = 1\n    while x * y < path[-1]:\n        x += 1\n        if x * y >= path[-1]:\n            y += 1\n            x = 1\n\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n"
    },
    {
        "number": 167,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    i, j = 0, 0\n    result = \"\"\n\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result += a[i]\n            i += 1\n            j += 1\n        else:\n            j += 1\n\n    return result if result else \"-\"\n"
    },
    {
        "number": 168,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    operations = stdin.split('\\n')[1]\n    stones = 0\n\n    for operation in operations:\n        if operation == '+':\n            stones += 1\n        else:\n            stones -= 1\n\n    return str(stones)"
    },
    {
        "number": 169,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    if a <= b:\n        return str(n // a)\n    else:\n        return str(n // b)"
    },
    {
        "number": 170,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k1, k2 = map(int, stdin.split())\n    cards1 = list(map(int, stdin.split()))[2:2+k1]\n    cards2 = list(map(int, stdin.split()))[2+k1:]\n    \n    fights = 0\n    while cards1 and cards2:\n        fights += 1\n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        \n        if card1 > card2:\n            cards1.append(card1)\n            cards1.append(card2)\n        else:\n            cards2.append(card2)\n            cards2.append(card1)\n    \n    if cards1:\n        return str(fights) + \" 1\"\n    elif cards2:\n        return str(fights) + \" 2\"\n    else:\n        return \"-1\""
    },
    {
        "number": 171,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 5:\n        return \"Too weak\"\n\n    has_large_letter = False\n    has_small_letter = False\n    has_digit = False\n\n    for char in stdin:\n        if char.isalpha():\n            if char.isupper():\n                has_large_letter = True\n            else:\n                has_small_letter = True\n        elif char.isdigit():\n            has_digit = True\n\n    if has_large_letter and has_small_letter and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\""
    },
    {
        "number": 172,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    group_a = list(map(int, stdin.split('\\n')[1].split()))\n    group_b = list(map(int, stdin.split('\\n')[2].split()))\n\n    if len(group_a) != n or len(group_b) != n:\n        return \"-1\"\n\n    count_a = [0] * 6\n    count_b = [0] * 6\n\n    for i in range(n):\n        count_a[group_a[i]] += 1\n        count_b[group_b[i]] += 1\n\n    min_exchanges = float('inf')\n\n    for i in range(1, 6):\n        if count_a[i] != count_b[i]:\n            min_exchanges = min(min_exchanges, abs(count_a[i] - count_b[i]))\n\n    return str(min_exchanges) if min_exchanges != float('inf') else \"-1\""
    },
    {
        "number": 173,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    h_dir = stdin.split()[1]\n    v_dir = stdin.split()[2]\n\n    for i in range(n):\n        if h_dir[i] == '<' and h_dir[i+1] == '>':\n            return \"NO\"\n\n    for i in range(m):\n        if v_dir[i] == '^' and v_dir[i+1] == 'v':\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 174,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_correct(expression: str) -> bool:\n        stack = []\n        for c in expression:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n            elif c == '0' or c == '1':\n                continue\n            elif c == '>':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n            else:\n                return False\n        return not stack\n\n    def implication(a: int, b: int) -> str:\n        return str(a) + '->' + str(b)\n\n    def find_expression(a: List[int], start: int, end: int) -> str:\n        if start == end:\n            return str(a[start])\n        for i in range(start, end):\n            left = find_expression(a, start, i)\n            right = find_expression(a, i + 1, end)\n            expression = '(' + left + '->' + right + ')'\n            if is_correct(expression):\n                return expression\n        return ''\n\n    expression = find_expression(a, 0, n - 1)\n    if expression:\n        return 'YES\\n' + expression\n    else:\n        return 'NO'"
    },
    {
        "number": 175,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return f\"{a} {b}\""
    },
    {
        "number": 176,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(a, b+1):\n        if i % k == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 177,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    num = 1\n    count = 0\n    while True:\n        for digit in str(num):\n            count += 1\n            if count == k:\n                return digit\n        num += 1"
    },
    {
        "number": 178,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    if n % 2 == 0 or n < 13 or n >= 10**5:\n        return \"NO\"\n\n    for i in range(n - 11):\n        if s[i] == '8':\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 179,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, pos = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    if i == pos:\n                        count += 1\n                    if j == pos:\n                        count += 1\n                    if k == pos:\n                        count += 1\n                    if l == pos:\n                        count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 180,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_message(s: str, k: int) -> str:\n        if len(s) < k:\n            return \"Impossible\"\n\n        message = \"\"\n        i = 0\n        while i < k:\n            if s[i] == '*':\n                if i == 0 or s[i - 1] == '*':\n                    return \"Impossible\"\n                message += s[i - 1] * 2\n                i += 1\n            elif s[i] == '?':\n                if i == 0:\n                    return \"Impossible\"\n                i += 1\n            else:\n                message += s[i]\n            i += 1\n\n        return message\n\n    stdin = stdin.replace('*', '?')\n    k = int(input())\n    return find_message(stdin, k)"
    },
    {
        "number": 181,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    turns = 0\n    while abs(x) % 90 != 0:\n        x += 90 if x > 0 else -90\n        turns += 1\n    return str(turns)"
    },
    {
        "number": 182,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, x, y, z = map(int, stdin.split())\n    if x <= a and y <= b and z <= c:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 183,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    count = 0\n    for x in range(1, 10**n):\n        y = x\n        while y % k == 0 and len(str(y)) <= n:\n            count += 1\n            y += 1\n    return str(count % m)"
    },
    {
        "number": 184,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, a = map(int, stdin.split())\n    total_players = l + r + a\n    if total_players % 2 != 0:\n        return \"0\"\n    max_size = total_players // 2\n    return str(max_size)"
    },
    {
        "number": 185,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 2:\n        return \"6\"\n    elif n == 4:\n        return \"13\"\n    else:\n        return \"15\""
    },
    {
        "number": 186,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 0:\n        return str(m * 3)\n    elif m == 0:\n        return str(n * 2)\n    else:\n        return str(max(n * 2, m * 3))"
    },
    {
        "number": 187,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = stdin.split('\\n')[1:]\n    cards = [int(card) for card in cards]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if cards.count(cards[i]) == n//2 and cards.count(cards[j]) == n//2:\n                return \"YES\\n\" + str(cards[i]) + \" \" + str(cards[j])\n\n    return \"NO\""
    },
    {
        "number": 188,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    soldiers = list(map(int, stdin.split()[2:]))\n\n    if sum(soldiers) > 8 * n:\n        return \"NO\"\n\n    soldiers.sort(reverse=True)\n    soldiers_used = [0] * k\n\n    def can_place(row: int, seat: int) -> bool:\n        for i in range(k):\n            if soldiers_used[i] < soldiers[i] and (row, seat) in neighbors[i]:\n                return False\n        return True\n\n    def place_soldiers(row: int, seat: int) -> bool:\n        if row == n:\n            return True\n        for i in range(1, 9):\n            if can_place(row, i):\n                soldiers_used[row] += 1\n                if place_soldiers(row + 1, i):\n                    return True\n                soldiers_used[row] -= 1\n        return False\n\n    neighbors = [[] for _ in range(k)]\n    for i in range(k):\n        for j in range(i + 1, k):\n            if soldiers[i] == soldiers[j]:\n                neighbors[i].append((j, 1))\n                neighbors[j].append((i, 1))\n            elif soldiers[i] > soldiers[j]:\n                neighbors[i].append((j, 1))\n                neighbors[i].append((j, 2))\n                neighbors[i].append((j, 3))\n                neighbors[i].append((j, 4))\n            else:\n                neighbors[j].append((i, 1))\n                neighbors[j].append((i, 2))\n                neighbors[j].append((i, 3))\n                neighbors[j].append((i, 4))\n\n    if place_soldiers(0, 1):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 189,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sticks = list(map(int, stdin.split('\\n')[1].split()))\n    \n    # Find the minimum and maximum stick lengths\n    min_stick = min(sticks)\n    max_stick = max(sticks)\n    \n    # Initialize the minimum cost and t\n    min_cost = float('inf')\n    t = 0\n    \n    # Iterate through all possible values of t\n    for i in range(min_stick, max_stick + 1):\n        cost = sum(abs(a - i) for a in sticks)\n        if cost < min_cost:\n            min_cost = cost\n            t = i\n    \n    return f\"{t} {min_cost}\""
    },
    {
        "number": 191,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def count_inversions(arr: List[int]) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    count += 1\n        return count\n\n    def swap(arr: List[int], i: int, j: int) -> None:\n        arr[i], arr[j] = arr[j], arr[i]\n\n    for _ in range(k):\n        i, j = randint(0, n - 1), randint(0, n - 1)\n        while i == j:\n            j = randint(0, n - 1)\n        swap(a, i, j)\n\n    inversions = count_inversions(a)\n    if inversions == 0:\n        return \"0\"\n    else:\n        p = 1000000007\n        return str((inversions * pow(2, k, p)) % p)"
    },
    {
        "number": 192,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if y > x:\n        return \"Impossible\"\n\n    if y == x:\n        return \"0\"\n\n    if y == 1:\n        return str(x - 1)\n\n    if y == 2:\n        return str(x - 2)\n\n    if y == 3:\n        return str(x - 3)\n\n    if y == 4:\n        return str(x - 4)\n\n    if y == 5:\n        return str(x - 5)\n\n    if y == 6:\n        return str(x - 6)\n\n    if y == 7:\n        return str(x - 7)\n\n    if y == 8:\n        return str(x - 8)\n\n    if y == 9:\n        return str(x - 9)\n\n    if y == 10:\n        return str(x - 10)\n\n    if y == 11:\n        return str(x - 11)\n\n    if y == 12:\n        return str(x - 12)\n\n    if y == 13:\n        return str(x - 13)\n\n    if y == 14:\n        return str(x - 14)\n\n    if y == 15:\n        return str(x - 15)\n\n    if y == 16:\n        return str(x - 16)\n\n    if y == 17:\n        return str(x - 17)\n\n    if y == 18:\n        return str(x - 18)\n\n    if y == 19:\n        return str(x - 19)\n\n    if y == 20:\n        return str(x - 20)\n\n    if y == 21:\n        return str(x - 21)\n\n    if y == 22:\n        return str(x - 22)\n\n    if y == 23:\n        return str(x - 23)\n\n    if y == 24:\n        return str(x - 24)\n\n    if y == 25:\n        return str(x - 25)\n\n    if y == 26:\n        return str(x - 26)\n\n    if y == 27:\n        return str(x - 27)\n\n    if y == 28:\n        return str(x - 28)\n\n    if y == 29:\n        return str(x - 29)\n\n    if y == 30:\n        return str(x - 30)\n\n    if y == 31:\n        return str(x - 31)\n\n    if y == 32:\n        return str(x - 32)\n\n    if y == 33:\n        return str(x - 33)\n\n    if y == 34:\n        return str(x - 34)\n\n    if y == 35:\n        return str(x - 35)\n\n    if y == 36:\n        return str(x - 36)\n\n    if y == 37:\n        return str(x - 37)\n\n    if y == 38:\n        return str(x - 38)\n\n    if y == 39:\n        return str(x - 39)\n\n    if y == 40:\n        return str(x - 40)\n\n    if y == 41:\n        return str(x - 41)\n\n    if y == 42:\n        return str(x - 42)\n\n    if y == 43:\n        return str(x - 43)\n\n    if y == 44:\n        return str(x - 44)\n\n    if y == 45:\n        return str(x - 45)\n\n    if y == 46:\n        return str(x - 46)\n\n    if y == 47:\n        return str(x - 47)\n\n    if y == 48:\n       "
    },
    {
        "number": 193,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    A = np.array([[a, b], [c, d]])\n    det = np.linalg.det(A)\n    if det == 0:\n        B = np.array([[a + 0.1, b + 0.1], [c + 0.1, d + 0.1]])\n        norm = np.linalg.norm(A - B, ord=2)\n    else:\n        norm = 0\n    return f\"{norm:.9f}\""
    },
    {
        "number": 194,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[0].split())\n    groups = list(map(int, stdin.split()[1].split()))\n\n    one_seater_tables = a\n    two_seater_tables = b\n    denied_service = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            else:\n                if two_seater_tables > 0:\n                    two_seater_tables -= 1\n                else:\n                    denied_service += 1\n        else:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n            else:\n                denied_service += 2\n\n    return str(denied_service)"
    },
    {
        "number": 195,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, N = map(int, stdin.split())\n    if N < A + B + C:\n        return \"-1\"\n    if A + B + C > N:\n        return \"-1\"\n    if A + B + C == N:\n        return str(N - 1)\n    if A + B + C < N:\n        return str(N - A - B - C - 1)"
    },
    {
        "number": 196,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    prob_doubling = 0.5\n    prob_eating = 0.5\n    prob_doubling_and_eating = prob_doubling * prob_eating\n    prob_doubling_and_not_eating = prob_doubling * (1 - prob_eating)\n    prob_not_doubling_and_eating = (1 - prob_doubling) * prob_eating\n    prob_not_doubling_and_not_eating = (1 - prob_doubling) * (1 - prob_eating)\n\n    def expected_dresses(x: int, k: int) -> int:\n        if k == 0:\n            return x\n        return (x * prob_doubling_and_not_eating + expected_dresses(x * 2, k - 1) * prob_doubling_and_eating + expected_dresses(x, k - 1) * prob_not_doubling_and_eating + expected_dresses(x, k - 1) * prob_not_doubling_and_not_eating) % MOD\n\n    return expected_dresses(x, k)"
    },
    {
        "number": 197,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    l_r = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def count_inversions(l_r):\n        l_r.sort(key=lambda x: x[1])\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if l_r[i][1] > l_r[j][0]:\n                    inversions += 1\n        return inversions\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        g = gcd(a, m)\n        if g != 1:\n            return None\n        u1, u2, u3 = 0, 1, a\n        v1, v2, v3 = 1, 0, m\n        while v3 != 0:\n            q = u3 // v3\n            v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n        return u1 % m\n\n    inversions = count_inversions(l_r)\n    total_combinations = (10**9 + 7) * (10**9 + 7)\n    result = (total_combinations - inversions) % (998244353)\n    mod_inverse_result = mod_inverse(result, 998244353)\n\n    return str(mod_inverse_result)"
    },
    {
        "number": 198,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n // 2 + 1):\n        for j in range(i, n - i):\n            if i * j == n:\n                count += 1\n    return str(count)"
    },
    {
        "number": 199,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    kegs = list(map(int, stdin.split()[2:]))\n\n    kegs.sort(reverse=True)\n    total_kvass = sum(kegs)\n\n    if total_kvass < s:\n        return \"-1\"\n\n    for i in range(n):\n        if kegs[i] >= s:\n            return str(s)\n        else:\n            s -= kegs[i]\n\n    return str(kegs[n-1])\n"
    },
    {
        "number": 200,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, h_2, a, b = map(int, stdin.split())\n    if h_2 - h_1 <= b:\n        return \"-1\"\n    else:\n        return str(int((h_2 - h_1 - b) / (a - b)))"
    },
    {
        "number": 201,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, H_r, H_b, W_r, W_b = map(int, stdin.split())\n    total_weight = W_r * C + W_b * C\n    if total_weight > 10**9:\n        return \"Too much candies\"\n    else:\n        return str(H_r * C + H_b * C)"
    },
    {
        "number": 202,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2 = map(int, stdin.split())\n    dx = abs(x_2 - x_1)\n    dy = abs(y_2 - y_1)\n    return max(dx, dy)"
    },
    {
        "number": 203,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fractions = stdin.split()[1]\n    depublicans = []\n    remocrats = []\n\n    for i in range(n):\n        if fractions[i] == 'D':\n            depublicans.append(i + 1)\n        else:\n            remocrats.append(i + 1)\n\n    while len(depublicans) > 1 and len(remocrats) > 1:\n        for i in range(n):\n            if fractions[i] == 'D':\n                if i + 1 in depublicans:\n                    depublicans.remove(i + 1)\n                if i + 1 in remocrats:\n                    remocrats.remove(i + 1)\n            else:\n                if i + 1 in depublicans:\n                    depublicans.remove(i + 1)\n                if i + 1 in remocrats:\n                    remocrats.remove(i + 1)\n\n    if len(depublicans) == 1:\n        return 'D'\n    else:\n        return 'R'"
    },
    {
        "number": 204,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    count = 0\n    for w in range(1, a+1):\n        for h in range(1, b+1):\n            if w/h == x/y:\n                count += 1\n    return str(count)"
    },
    {
        "number": 205,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    factorial = 1\n    trailing_zeros = 0\n\n    for i in range(1, n + 1):\n        factorial *= i\n\n    while factorial % b == 0:\n        trailing_zeros += 1\n        factorial //= b\n\n    return str(trailing_zeros)"
    },
    {
        "number": 206,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b = map(int, stdin.split())\n    def f(x):\n        if x < 0:\n            return 0\n        if x == 0:\n            return 1\n        return f(x-b) + f(x-a)\n    total = 0\n    for i in range(m+1):\n        total += f(i)\n    return str(total)"
    },
    {
        "number": 207,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"Yes\"\n\n    for i in range(n):\n        if sequence[i] % 2 == 0:\n            if i == 0 or i == n - 1:\n                return \"No\"\n            else:\n                return \"Yes\"\n\n    return \"Yes\"\n\n\ndef"
    },
    {
        "number": 208,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    if x1 == x2 and y1 == y2:\n        return \"-1\"\n\n    if x1 == x2:\n        x3, y3 = x1, y1 + 1\n        x4, y4 = x2, y2 + 1\n    elif y1 == y2:\n        x3, y3 = x1 + 1, y1\n        x4, y4 = x2 + 1, y2\n    else:\n        x3, y3 = x1 + 1, y1 + 1\n        x4, y4 = x2 + 1, y2 + 1\n\n    if -1000 <= x3 <= 1000 and -1000 <= y3 <= 1000 and -1000 <= x4 <= 1000 and -1000 <= y4 <= 1000:\n        return f\"{x3} {y3} {x4} {y4}\"\n    else:\n        return \"-1\""
    },
    {
        "number": 209,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    n = int(input())\n\n    f = [0] * (n + 1)\n    f[1] = x\n    f[2] = y\n\n    for i in range(3, n + 1):\n        f[i] = (f[i - 1] + f[i + 1]) % 1000000007\n\n    return str(f[n])"
    },
    {
        "number": 210,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n\n    if sum(array) == 0:\n        return \"NO\"\n\n    result = []\n    current_sum = 0\n    start = 0\n\n    for i in range(n):\n        current_sum += array[i]\n\n        if current_sum == 0:\n            result.append((start + 1, i))\n            start = i + 1\n            current_sum = 0\n\n    if current_sum != 0:\n        result.append((start + 1, n - 1))\n\n    if len(result) == 1:\n        return \"NO\"\n\n    output = \"YES\\n\" + str(len(result)) + \"\\n\"\n    for subarray in result:\n        output += \" \".join(map(str, subarray)) + \"\\n\"\n\n    return output.rstrip()\n"
    },
    {
        "number": 211,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    min_score = 0\n    consecutive_correct = 0\n    for i in range(1, n + 1):\n        if m == i:\n            min_score += consecutive_correct\n            break\n        consecutive_correct += 1\n        if consecutive_correct == k:\n            min_score += consecutive_correct + 1\n            consecutive_correct = 0\n    return str(min_score % 1000000009)"
    },
    {
        "number": 212,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    n_str = str(n)\n    if n == 0:\n        return \"NO\"\n    if n % 8 == 0:\n        return \"YES\\n\" + n_str\n    for i in range(len(n_str)):\n        if n_str[i] == '0':\n            continue\n        new_n = int(n_str[:i] + n_str[i+1:])\n        if new_n % 8 == 0:\n            return \"YES\\n\" + str(new_n)\n    return \"NO\""
    },
    {
        "number": 213,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    flats_on_floor = {}\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            k, f = map(int, line.split())\n            flats_on_floor[k] = f\n\n    if n in flats_on_floor:\n        return str(flats_on_floor[n])\n\n    for i in range(1, n + 1):\n        if i not in flats_on_floor:\n            for j in range(i, n + 1):\n                if j not in flats_on_floor:\n                    continue\n                if flats_on_floor[i] == flats_on_floor[j]:\n                    return str(flats_on_floor[i])\n\n    return \"-1\"\n"
    },
    {
        "number": 214,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.split(\"\\n\")\n    n = len(board)\n    bishwocks = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \"0\":\n                if i > 0 and board[i - 1][j] == \"X\":\n                    continue\n                if i < n - 1 and board[i + 1][j] == \"X\":\n                    continue\n                if j > 0 and board[i][j - 1] == \"X\":\n                    continue\n                if j < n - 1 and board[i][j + 1] == \"X\":\n                    continue\n                bishwocks += 1\n\n    return str(bishwocks)"
    },
    {
        "number": 215,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    def is_pretty(A):\n        if len(A) == 0:\n            return True\n        if len(A) == 1:\n            return s[A[0]] == s[A[0]].lower()\n        for i in range(len(A) - 1):\n            if s[A[i]].islower() and s[A[i]].lower() != s[A[i + 1]].lower():\n                return False\n            for j in range(A[i] + 1, A[i + 1]):\n                if s[j].isupper():\n                    return False\n        return True\n\n    max_pretty = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i].islower() and s[j].islower():\n                A = [i, j]\n                for k in range(j + 1, n):\n                    if s[k].islower() and s[k].lower() != s[A[-1]].lower():\n                        A.append(k)\n                if is_pretty(A):\n                    max_pretty = max(max_pretty, len(A))\n\n    return str(max_pretty)"
    },
    {
        "number": 216,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    b = []\n    c = []\n\n    for i in range(n):\n        if i % 2 == 0:\n            b.append(a[i])\n        else:\n            c.append(a[i])\n\n    B = sum(b)\n    C = sum(c)\n\n    return str(B - C)"
    },
    {
        "number": 217,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, f, k = map(int, stdin.split())\n    if f >= a:\n        return \"-1\"\n    \n    distance = a - f\n    full_tank = b\n    empty_tank = full_tank - distance\n    \n    if empty_tank < 0:\n        return \"-1\"\n    \n    journeys = 0\n    while k > 0:\n        journeys += 1\n        k -= 1\n        if k % 2 == 0:\n            empty_tank -= distance\n            if empty_tank < 0:\n                return \"-1\"\n        else:\n            empty_tank -= 2 * distance\n            if empty_tank < 0:\n                return \"-1\"\n    \n    return journeys"
    },
    {
        "number": 218,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    s = input()\n\n    if p + q > n:\n        return \"-1\"\n\n    result = []\n    for i in range(0, n, p):\n        result.append(s[i:i+p])\n\n    if len(result[-1]) != q:\n        return \"-1\"\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 219,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, d = map(int, stdin.split()[:4])\n    obstacles = list(map(int, stdin.split()[4:]))\n    \n    # Check if the starting and finishing point have no obstacles\n    if 0 not in obstacles or m not in obstacles:\n        return \"IMPOSSIBLE\"\n    \n    # Check if the athlete can reach the finish point\n    for i in range(n):\n        if obstacles[i] >= m:\n            return \"IMPOSSIBLE\"\n    \n    # Initialize the path\n    path = []\n    current_pos = 0\n    current_jump = 0\n    \n    # Iterate through the obstacles\n    for i in range(n):\n        obstacle = obstacles[i]\n        \n        # Check if the athlete can jump over the obstacle\n        if current_pos + s <= obstacle and obstacle - current_pos <= d:\n            jump_length = obstacle - current_pos\n            path.append(f\"JUMP {jump_length}\")\n            current_pos = obstacle\n            current_jump = jump_length\n        else:\n            # Check if the athlete can run to the obstacle\n            run_length = obstacle - current_pos\n            if run_length > 0:\n                path.append(f\"RUN {run_length}\")\n                current_pos = obstacle\n                current_jump = 0\n            else:\n                return \"IMPOSSIBLE\"\n    \n    # Check if the athlete can reach the finish point\n    if current_pos + s <= m and m - current_pos <= d:\n        jump_length = m - current_pos\n        path.append(f\"JUMP {jump_length}\")\n    else:\n        return \"IMPOSSIBLE\"\n    \n    return \"\\n\".join(path)"
    },
    {
        "number": 220,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x = map(int, stdin.split())\n    count = 0\n    for a in range(1, s):\n        b = s - a\n        if a ^ b == x:\n            count += 1\n    return str(count)"
    },
    {
        "number": 221,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    l = 0\n    skewers = [i for i in range(1, n + 1)]\n\n    while skewers:\n        l += 1\n        current_skewer = skewers.pop(0)\n        for i in range(current_skewer - k, current_skewer + k + 1):\n            if i > 0 and i <= n and i in skewers:\n                skewers.remove(i)\n\n    return str(l) + \"\\n\" + \" \".join(map(str, range(1, n + 1)))"
    },
    {
        "number": 222,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    if n == 4 or n == 9:\n        return \"1\"\n    if n == 16 or n == 25 or n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"2\"\n    if n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"3\"\n    if n == 16 or n == 25 or n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"4\"\n    if n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"5\"\n    if n == 16 or n == 25 or n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"6\"\n    if n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"7\"\n    if n == 16 or n == 25 or n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"8\"\n    if n == 36 or n == 49 or n == 64 or n == 81 or n == 100:\n        return \"9\"\n    return \"-1\""
    },
    {
        "number": 223,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    f_max = 0\n    count = 0\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def f(p):\n        gcds = [gcd(p[i], p[i + 1]) for i in range(len(p) - 1)]\n        return len(set(gcds))\n\n    def permute(arr, i, n):\n        nonlocal f_max, count\n        if i == n:\n            f_max = max(f_max, f(arr))\n            if f(arr) == f_max:\n                count += 1\n        else:\n            for j in range(i, n):\n                arr[i], arr[j] = arr[j], arr[i]\n                permute(arr, i + 1, n)\n                arr[i], arr[j] = arr[j], arr[i]\n\n    permute([i for i in range(1, n + 1)], 0, n)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 224,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])\n    left, right = 0, len(stdin) - 1\n    jump_ability = 0\n    \n    while left <= right:\n        if stdin[left] in vowels:\n            jump_ability += 1\n        if stdin[right] in vowels:\n            jump_ability += 1\n        left += 1\n        right -= 1\n    \n    return jump_ability"
    },
    {
        "number": 225,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    total_candies = sum(a)\n    if total_candies % 2 != 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 226,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    slices = list(map(int, lines[1].split()))\n\n    alice_slices = []\n    bob_slices = []\n\n    alice_turn = True\n    decider_token = True\n\n    for slice in slices:\n        if decider_token:\n            if alice_turn:\n                alice_slices.append(slice)\n            else:\n                bob_slices.append(slice)\n            decider_token = False\n        else:\n            if alice_turn:\n                bob_slices.append(slice)\n            else:\n                alice_slices.append(slice)\n            decider_token = True\n            alice_turn = not alice_turn\n\n    return str(sum(alice_slices)) + ' ' + str(sum(bob_slices))"
    },
    {
        "number": 227,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_possible(m: int) -> bool:\n        b = [0] * m\n        for i in range(n):\n            x = a[i]\n            found = False\n            for j in range(m):\n                if b[j] == x:\n                    found = True\n                    break\n            if not found:\n                return False\n            for j in range(m):\n                if b[j] != x:\n                    b[j] += x\n        return True\n\n    lo, hi = 1, n\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if is_possible(mid):\n            lo = mid + 1\n        else:\n            hi = mid - 1\n\n    return str(lo - 1) if lo > 1 else \"-1\""
    },
    {
        "number": 228,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stones = map(int, stdin.split())\n    stones = list(map(int, stones.split()))\n\n    if n % 2 != 0:\n        raise ValueError(\"n must be an even number\")\n\n    for stone in stones:\n        if stone < 1 or stone > 50:\n            raise ValueError(\"Each stone must be between 1 and 50\")\n\n    alice_turn = True\n    while True:\n        if alice_turn:\n            if sum(stones) < n:\n                return \"Bob\"\n            for i in range(n // 2):\n                stones[i] -= 1\n        else:\n            if sum(stones) < n:\n                return \"Alice\"\n            for i in range(n // 2, n):\n                stones[i] -= 1\n\n        alice_turn = not alice_turn\n"
    },
    {
        "number": 229,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n\n    if len(set(array)) == 1:\n        return \"YES\"\n\n    array.sort()\n    min_value = array[0]\n    max_value = array[-1]\n\n    if min_value == max_value:\n        return \"YES\"\n\n    for x in range(min_value, max_value + 1):\n        temp_array = array.copy()\n        temp_array.sort()\n        for i in range(len(temp_array)):\n            if temp_array[i] > x:\n                temp_array[i] -= x\n            elif temp_array[i] < x:\n                temp_array[i] += x\n        if len(set(temp_array)) == 1:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 230,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    max_len = 0\n\n    for len in range(1, N + 1):\n        for l_1 in range(N - len + 1):\n            l_2 = l_1 + len\n            if l_2 <= N:\n                if S[l_1:l_1 + len] == S[l_2:l_2 + len]:\n                    max_len = max(max_len, len)\n\n    return str(max_len)"
    },
    {
        "number": 231,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    if a % 2 == 0:\n        a -= 1\n    return str(min(a // 2, (n - a) // 2) + 1)"
    },
    {
        "number": 232,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    colors = list(map(int, stdin.split()[2:n+2]))\n    desired_counts = list(map(int, stdin.split()[n+2:]))\n\n    if sum(desired_counts) > n:\n        return \"NO\"\n\n    color_counts = [0] * m\n    for color in colors:\n        color_counts[color-1] += 1\n\n    for i in range(len(color_counts)):\n        if color_counts[i] < desired_counts[i]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 233,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    mishka_wins = 0\n    chris_wins = 0\n    draws = 0\n\n    for i in range(1, n + 1):\n        mishka, chris = map(int, stdin.split('\\n')[i].split())\n\n        if mishka > chris:\n            mishka_wins += 1\n        elif chris > mishka:\n            chris_wins += 1\n        else:\n            draws += 1\n\n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\""
    },
    {
        "number": 234,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def is_valid(i, j):\n        if field[i][j] == \"*\":\n            return True\n        bombs_count = 0\n        for x in range(max(0, i - 1), min(i + 2, n)):\n            for y in range(max(0, j - 1), min(j + 2, m)):\n                if field[x][y] == \"*\":\n                    bombs_count += 1\n        if bombs_count == int(field[i][j]):\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if not is_valid(i, j):\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 235,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 1\n    while n > 0:\n        n -= k\n        k += 1\n    return str(k - 1)"
    },
    {
        "number": 236,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    necklace = list(stdin)\n    pearls = [i for i, x in enumerate(necklace) if x == 'o']\n    links = [i for i, x in enumerate(necklace) if x == '-']\n\n    if len(pearls) == 1:\n        return \"YES\"\n\n    if len(pearls) % 2 == 1:\n        return \"NO\"\n\n    for i in range(len(pearls) - 1):\n        if abs(pearls[i + 1] - pearls[i]) != 1:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 237,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n == 1:\n        return str(m)\n    if k == 1:\n        return str(m)\n    if k == n:\n        return str(m)\n    if k == 2:\n        return str(m - 1)\n    if k == n - 1:\n        return str(m - 1)\n    if k == n - 2:\n        return str(m - 2)\n    if k == n - 3:\n        return str(m - 3)\n    if k == n - 4:\n        return str(m - 4)\n    if k == n - 5:\n        return str(m - 5)\n    if k == n - 6:\n        return str(m - 6)\n    if k == n - 7:\n        return str(m - 7)\n    if k == n - 8:\n        return str(m - 8)\n    if k == n - 9:\n        return str(m - 9)\n    if k == n - 10:\n        return str(m - 10)\n    return str(m - n + 1)"
    },
    {
        "number": 238,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def cost(l, r):\n        return sum(a[l:r+1]) - k * (r - l + 1) // m\n\n    max_cost = 0\n    for i in range(n):\n        for j in range(i, n):\n            max_cost = max(max_cost, cost(i, j))\n\n    return str(max_cost)"
    },
    {
        "number": 239,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = [(x, y) for x in range(n+1) for y in range(m+1)]\n    max_length = 0\n    max_polyline = []\n\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            for k in range(j+1, len(points)):\n                for l in range(k+1, len(points)):\n                    polyline = [points[i], points[j], points[k], points[l]]\n                    length = sum(abs(x1-x2) + abs(y1-y2) for (x1, y1), (x2, y2) in zip(polyline, polyline[1:]))\n                    if length > max_length:\n                        max_length = length\n                        max_polyline = polyline\n\n    return '\\n'.join(f'{x} {y}' for x, y in max_polyline)"
    },
    {
        "number": 240,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    n_str = str(n)\n    n_len = len(n_str)\n    n_zeros = n_len - len(n_str.lstrip('0'))\n    n_zeros_to_add = k - n_zeros\n    n_zeros_to_add = max(0, n_zeros_to_add)\n    n_zeros_to_add = min(n_zeros_to_add, k - n_zeros)\n    n_zeros += n_zeros_to_add\n    n_zeros_to_add = '0' * n_zeros_to_add\n    n_str = n_zeros_to_add + n_str\n    return n_str"
    },
    {
        "number": 241,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, min_temp, max_temp = map(int, stdin.split()[:4])\n    temperatures = list(map(int, stdin.split()[4:]))\n\n    if min_temp not in temperatures or max_temp not in temperatures:\n        return \"Incorrect\"\n\n    if len(temperatures) == n:\n        return \"Correct\"\n\n    temperatures.sort()\n    if temperatures[0] != min_temp or temperatures[-1] != max_temp:\n        return \"Incorrect\"\n\n    for i in range(len(temperatures) - 1):\n        if temperatures[i + 1] - temperatures[i] > 1:\n            return \"Incorrect\"\n\n    return \"Correct\"\n"
    },
    {
        "number": 242,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    k = 0\n    result = []\n\n    for i in range(1, m + 1):\n        if m % 5 == 0:\n            k += 1\n            result.append(i)\n\n    return f\"{k}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 243,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    special_vertices = list(map(int, stdin.readline().split()))\n    graph = {}\n\n    for _ in range(m):\n        u, v, w = map(int, stdin.readline().split())\n        if u not in graph:\n            graph[u] = {}\n        if v not in graph:\n            graph[v] = {}\n        graph[u][v] = w\n        graph[v][u] = w\n\n    def dfs(start, visited, distances):\n        visited[start] = True\n        for neighbor, weight in graph[start].items():\n            if not visited[neighbor]:\n                distances[neighbor] = max(distances[neighbor], distances[start] + weight)\n                dfs(neighbor, visited, distances)\n\n    distances = {vertex: 0 for vertex in graph}\n    for special_vertex in special_vertices:\n        visited = {vertex: False for vertex in graph}\n        dfs(special_vertex, visited, distances)\n\n    farthest_distances = [0] * k\n    for i in range(k):\n        farthest_distance = 0\n        for j in range(k):\n            if i != j:\n                farthest_distance = max(farthest_distance, distances[special_vertices[j]])\n        farthest_distances[i] = farthest_distance\n\n    return \" \".join(map(str, farthest_distances))\n\n\ninput_data = \"\"\"2 3 2\n2 1\n1 2 3\n1 2 2\n2 2 1\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 244,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n % 2 == 0:\n        return str((x - 1) % 3)\n    else:\n        return str((x + 1) % 3)"
    },
    {
        "number": 245,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rectangles = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_square(rectangles: List[List[int]]) -> bool:\n        min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n        for rectangle in rectangles:\n            min_x = min(min_x, rectangle[0])\n            max_x = max(max_x, rectangle[2])\n            min_y = min(min_y, rectangle[1])\n            max_y = max(max_y, rectangle[3])\n\n        square_side = (max_x - min_x) / 2\n        if square_side != (max_y - min_y) / 2:\n            return False\n\n        for rectangle in rectangles:\n            if not (rectangle[0] <= min_x + square_side and rectangle[2] >= max_x - square_side and rectangle[1] <= min_y + square_side and rectangle[3] >= max_y - square_side):\n                return False\n\n        return True\n\n    return \"YES\" if is_square(rectangles) else \"NO\""
    },
    {
        "number": 246,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        digits_sum = sum(int(digit) for digit in str(i))\n        if i - digits_sum >= s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 247,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_point_on_line(point, line):\n        x1, y1, x2, y2 = line\n        return (x2 - x1) * (point[1] - y1) == (point[0] - x1) * (y2 - y1)\n\n    def is_point_on_line_segment(point, line):\n        x1, y1, x2, y2 = line\n        return min(x1, x2) <= point[0] <= max(x1, x2) and min(y1, y2) <= point[1] <= max(y1, y2)\n\n    def is_point_on_any_line(point, lines):\n        return any(is_point_on_line(point, line) for line in lines)\n\n    def is_point_on_any_line_segment(point, lines):\n        return any(is_point_on_line_segment(point, line) for line in lines)\n\n    lines = [(points[0][0], points[0][1], points[1][0], points[1][1])]\n    for i in range(2, n):\n        point = points[i]\n        if is_point_on_any_line_segment(point, lines):\n            continue\n        for line in lines:\n            if is_point_on_line(point, line):\n                lines.append((point[0], point[1], line[2], line[3]))\n                break\n        else:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 248,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k, t = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for Memory_score in range(a, a + 2*k + 1):\n        for Lexa_score in range(b, b + 2*k + 1):\n            if Memory_score > Lexa_score:\n                count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 249,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, x, y = map(int, stdin.split()[:4])\n    marks = list(map(int, stdin.split()[4:]))\n\n    # Check if the given distances can be measured with the given ruler\n    if x >= y:\n        return \"0\\n\"\n\n    # Check if the given distances can be measured with the given marks\n    for i in range(len(marks)):\n        for j in range(i + 1, len(marks)):\n            if marks[j] - marks[i] == x or marks[j] - marks[i] == y:\n                return \"0\\n\"\n\n    # Calculate the minimum number of additional marks needed\n    min_marks = float('inf')\n    for i in range(len(marks)):\n        for j in range(i + 1, len(marks)):\n            if marks[j] - marks[i] > min_marks:\n                min_marks = marks[j] - marks[i]\n\n    # Calculate the positions of the additional marks\n    positions = []\n    while min_marks > 0:\n        positions.append(min_marks)\n        min_marks -= 1\n\n    # Print the result\n    return f\"{len(positions)}\\n{' '.join(map(str, positions))}\\n\""
    },
    {
        "number": 250,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cakes = []\n    for _ in range(n):\n        r, h = map(int, stdin.readline().strip().split())\n        cakes.append((r, h))\n\n    def volume(r, h):\n        return 3.14159 * r**2 * h\n\n    def max_volume(cakes):\n        cakes.sort(key=lambda x: x[1], reverse=True)\n        max_vol = 0\n        for i in range(len(cakes)):\n            for j in range(i):\n                if volume(cakes[i][0], cakes[i][1]) > volume(cakes[j][0], cakes[j][1]):\n                    max_vol += volume(cakes[i][0], cakes[i][1])\n        return max_vol\n\n    return str(max_volume(cakes))"
    },
    {
        "number": 251,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    h = list(map(int, stdin.split()[2:]))\n    h.sort()\n    slices = 0\n    target_height = h[n // 2]\n    for i in range(n):\n        if h[i] > target_height:\n            slices += h[i] - target_height\n            h[i] = target_height\n    return str(slices)"
    },
    {
        "number": 252,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n\n    def score(l: int, r: int) -> int:\n        return sum(cards[l:r+1])\n\n    max_score = 0\n    for l in range(n):\n        for r in range(l, n):\n            max_score = max(max_score, score(l, r))\n\n    return str(max_score)"
    },
    {
        "number": 253,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k1, k2, k3 = map(int, stdin.split())\n    x1 = 1\n    x2 = 1\n    x3 = 1\n\n    while True:\n        if x1 % k1 == 0 and x2 % k2 == 0 and x3 % k3 == 0:\n            return \"YES\"\n        x1 += 1\n        x2 += 1\n        x3 += 1\n\n    return \"NO\""
    },
    {
        "number": 254,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    count = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        count += 1\n        i = j\n\n    return count"
    },
    {
        "number": 255,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, boys, m, girls = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    boys = list(map(int, boys.split()))\n    girls = list(map(int, girls.split()))\n\n    boys.sort()\n    girls.sort()\n\n    max_pairs = 0\n    i = 0\n    j = 0\n\n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            max_pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n\n    return str(max_pairs)"
    },
    {
        "number": 256,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    a1, b1, a2, b2 = sorted([a, b, c, d])\n\n    if a1 + b1 > a2 + b2:\n        return \"Team 1\"\n    elif a1 + b1 < a2 + b2:\n        return \"Team 2\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 257,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    pieces = []\n    for i in range(N):\n        x, y, c = map(int, stdin.split()[3*i:3*(i+1)])\n        pieces.append((x, y, c))\n\n    def time_to_grill(X, Y):\n        return max(c_i * math.sqrt((X - x_i)**2 + (Y - y_i)**2) for x_i, y_i, c_i in pieces)\n\n    def count_ready_pieces(X, Y):\n        return sum(1 for x_i, y_i, c_i in pieces if time_to_grill(X, Y) <= c_i * math.sqrt((X - x_i)**2 + (Y - y_i)**2))\n\n    X_min, X_max = -1000, 1000\n    Y_min, Y_max = -1000, 1000\n    best_time = float('inf')\n    best_X, best_Y = 0, 0\n\n    for X in range(X_min, X_max + 1):\n        for Y in range(Y_min, Y_max + 1):\n            if count_ready_pieces(X, Y) >= K:\n                time = time_to_grill(X, Y)\n                if time < best_time:\n                    best_time = time\n                    best_X, best_Y = X, Y\n\n    return str(best_time)"
    },
    {
        "number": 258,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ticket = stdin.split()[1]\n\n    def is_happy(ticket: str) -> bool:\n        first_half = ticket[:n // 2]\n        second_half = ticket[n // 2:]\n        return sum(map(int, first_half)) == sum(map(int, second_half))\n\n    def next_move(ticket: str) -> str:\n        if is_happy(ticket):\n            return \"Bicarp\"\n        else:\n            return \"Monocarp\"\n\n    while \"?\" in ticket:\n        ticket = input(\"Enter the next move: \")\n\n    return next_move(ticket)"
    },
    {
        "number": 259,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    routes = []\n    for i in range(n):\n        s, d = map(int, stdin.split()[2*i:2*(i+1)])\n        routes.append((s, d))\n    \n    bus_times = []\n    for route in routes:\n        s, d = route\n        bus_times.append(s)\n        while s + d <= t:\n            s += d\n            bus_times.append(s)\n    \n    return str(bus_times.index(min(bus_times)) + 1)"
    },
    {
        "number": 260,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            binary_representation = bin(i)[2:]\n            if len(binary_representation) == k and binary_representation.count('1') == m:\n                count += 1\n        if count == m:\n            return str(n)\n        n += 1"
    },
    {
        "number": 261,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    level_scheme = stdin.split('\\n')[1]\n    \n    for i in range(n - 4):\n        if level_scheme[i] == '*' and level_scheme[i+1] == '*' and level_scheme[i+2] == '*' and level_scheme[i+3] == '*' and level_scheme[i+4] == '*':\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 262,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    empty_cell = (0, 0)\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_cell = (i, j)\n                break\n\n    def is_magic_square(grid: List[List[int]]) -> bool:\n        n = len(grid)\n        magic_sum = sum(grid[0])\n\n        for row in grid:\n            if sum(row) != magic_sum:\n                return False\n\n        for col in range(n):\n            if sum(grid[row][col] for row in range(n)) != magic_sum:\n                return False\n\n        if sum(grid[i][i] for i in range(n)) != magic_sum:\n            return False\n\n        if sum(grid[i][n - i - 1] for i in range(n)) != magic_sum:\n            return False\n\n        return True\n\n    def fill_magic_square(grid: List[List[int]], empty_cell: Tuple[int, int], x: int) -> List[List[int]]:\n        grid[empty_cell[0]][empty_cell[1]] = x\n        return grid\n\n    for x in range(1, 10**18):\n        filled_grid = fill_magic_square(grid, empty_cell, x)\n        if is_magic_square(filled_grid):\n            return str(x)\n\n    return \"-1\""
    },
    {
        "number": 263,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a = a[n:]\n    min_k = max(a) + m\n    max_k = sum(a) + m\n    return f\"{min_k} {max_k}\""
    },
    {
        "number": 264,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(m):\n        new_dp = [0] * (n + 1)\n        for j in range(n + 1):\n            new_dp[j] += dp[j]\n            if j > 0:\n                new_dp[j - 1] += dp[j]\n        dp = new_dp\n    return str(dp[-1] % mod)"
    },
    {
        "number": 265,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, stdin.readline().split())\n        friends.append((f, b))\n\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = map(int, stdin.readline().split())\n        pizzas.append((c, r, a))\n\n    def is_pizza_pleasing(pizza, friends):\n        ingredients = set(pizza[2])\n        return all(any(ingredient in ingredients for ingredient in friend_ingredients) for friend_ingredients in friends)\n\n    def pizza_price(pizza):\n        return pizza[0]\n\n    def pizza_index(pizza):\n        return pizza[3]\n\n    def pizza_pleasing_score(pizza, friends):\n        return sum(is_pizza_pleasing(pizza, [friend_ingredients]) for friend_ingredients in friends)\n\n    def pizza_pleasing_score_and_price(pizza, friends):\n        return pizza_pleasing_score(pizza, friends), pizza_price(pizza)\n\n    def choose_two_pizzas(pizzas, friends):\n        pizzas_with_scores = [(pizza_pleasing_score_and_price(pizza, friends), pizza_index(pizza)) for pizza in pizzas]\n        pizzas_with_scores.sort(key=lambda x: (-x[0][0], x[0][1]))\n        return pizzas_with_scores[0][1], pizzas_with_scores[1][1]\n\n    pizza_indices = choose_two_pizzas(pizzas, friends)\n    return \" \".join(map(str, pizza_indices))"
    },
    {
        "number": 266,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    min_num = max_num = -1\n    \n    for i in range(1, 10**m):\n        if sum(int(digit) for digit in str(i)) == s:\n            min_num = i\n            break\n    \n    for i in range(10**(m-1), 10**m):\n        if sum(int(digit) for digit in str(i)) == s:\n            max_num = i\n            break\n    \n    return f\"{min_num} {max_num}\""
    },
    {
        "number": 267,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    total_sum = 0\n    for num in range(l, r + 1):\n        if len(set(str(num))) <= k:\n            total_sum += num\n    return str(total_sum % 998244353)"
    },
    {
        "number": 268,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split()[:3])\n    pencils = list(map(int, stdin.split()[3:]))\n\n    pencils.sort()\n\n    if len(pencils) < k:\n        return \"NO\"\n\n    for i in range(len(pencils) - k + 1):\n        if pencils[i + k - 1] - pencils[i] <= d:\n            return \"YES\"\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 269,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.replace(\"!\", \"\")\n    colors = {\"R\": 0, \"B\": 0, \"Y\": 0, \"G\": 0}\n    for i in range(len(stdin) - 3):\n        if stdin[i:i+4] in [\"RBGY\", \"YBRG\", \"GBRY\", \"BGYR\"]:\n            colors[stdin[i]] += 1\n            colors[stdin[i+1]] += 1\n            colors[stdin[i+2]] += 1\n            colors[stdin[i+3]] += 1\n    return f\"{colors['R']} {colors['B']} {colors['Y']} {colors['G']}\" "
    },
    {
        "number": 270,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, *passages = stdin.split()\n    N, M = int(N), int(M)\n    adj_list = [[] for _ in range(N)]\n    for i in range(M):\n        s, t = map(int, passages[i * 2: i * 2 + 2])\n        adj_list[s - 1].append(t - 1)\n\n    def dfs(node: int, visited: set, depth: int) -> int:\n        if node == N - 1:\n            return depth\n        min_depth = float('inf')\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                min_depth = min(min_depth, dfs(neighbor, visited, depth + 1))\n                visited.remove(neighbor)\n        return min_depth\n\n    min_depth = float('inf')\n    for i in range(N - 1):\n        visited = set()\n        min_depth = min(min_depth, dfs(i, visited, 1))\n\n    return f\"{min_depth:.6f}\""
    },
    {
        "number": 271,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 10 == 0:\n        return str(n)\n    else:\n        return str(n - n % 10)"
    },
    {
        "number": 272,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    if s == t:\n        return \"0\"\n\n    pairs = []\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            pairs.append((s[i], t[i]))\n\n    if len(pairs) % 2 != 0:\n        return \"-1\"\n\n    pairs.sort()\n    result = []\n    for i in range(0, len(pairs), 2):\n        result.append(f\"{pairs[i][0]} {pairs[i][1]}\")\n\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 273,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_name, last_name = stdin.split()\n    first_prefix = first_name\n    last_prefix = last_name\n    if len(first_prefix) > len(last_prefix):\n        first_prefix = first_prefix[:len(last_prefix)]\n    elif len(last_prefix) > len(first_prefix):\n        last_prefix = last_prefix[:len(first_prefix)]\n    return (first_prefix + last_prefix).lower()"
    },
    {
        "number": 274,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    brackets = stdin.split()[1]\n\n    def draw_bracket(bracket: str) -> str:\n        if bracket == \"]\":\n            return \"+\"\n        else:\n            return \"-\"\n\n    def draw_bracket_sequence(brackets: str) -> str:\n        result = \"\"\n        for i in range(len(brackets)):\n            if i % 2 == 0:\n                result += draw_bracket(brackets[i])\n            else:\n                result += \" \"\n        return result\n\n    def draw_vertical_bar(bracket: str) -> str:\n        if bracket == \"]\":\n            return \"|\"\n        else:\n            return \" \"\n\n    def draw_vertical_bars(brackets: str) -> str:\n        result = \"\"\n        for i in range(len(brackets)):\n            if i % 2 == 0:\n                result += draw_vertical_bar(brackets[i])\n            else:\n                result += \" \"\n        return result\n\n    def draw_horizontal_bar(bracket: str) -> str:\n        if bracket == \"]\":\n            return \" \"\n        else:\n            return \"-\"\n\n    def draw_horizontal_bars(brackets: str) -> str:\n        result = \"\"\n        for i in range(len(brackets)):\n            if i % 2 == 0:\n                result += draw_horizontal_bar(brackets[i])\n            else:\n                result += \" \"\n        return result\n\n    def draw_image(brackets: str) -> str:\n        bracket_sequence = draw_bracket_sequence(brackets)\n        vertical_bars = draw_vertical_bars(brackets)\n        horizontal_bars = draw_horizontal_bars(brackets)\n\n        result = \"\"\n        for i in range(len(brackets)):\n            if i % 2 == 0:\n                result += bracket_sequence[i]\n            else:\n                result += \" \"\n            result += vertical_bars[i]\n            result += horizontal_bars[i]\n        return result\n\n    return draw_image(brackets)"
    },
    {
        "number": 275,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def decimal_value(number: str, q: float) -> float:\n        return sum(int(digit) * q ** (len(number) - i - 1) for i, digit in enumerate(number))\n\n    a, b = stdin.splitlines()\n    q = (1 + 5 ** 0.5) / 2\n    a_value = decimal_value(a, q)\n    b_value = decimal_value(b, q)\n\n    if a_value > b_value:\n        return \">\"\n    elif a_value < b_value:\n        return \"<\"\n    else:\n        return \"=\""
    },
    {
        "number": 276,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    absent_gems = set(gems.values()) - set(stdin.split())\n\n    return str(len(absent_gems)) + \"\\n\" + \"\\n\".join(sorted(absent_gems))\n"
    },
    {
        "number": 277,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a == b:\n        return \"Final!\"\n    if n % 2 == 0:\n        n += 1\n    for i in range(1, n):\n        if (a - 1) // 2 ** (i - 1) != (b - 1) // 2 ** (i - 1):\n            return i\n    return \"Final!\""
    },
    {
        "number": 278,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    min_changes = 0\n    for i in range(n):\n        if p[i] != i + 1:\n            min_changes += 1\n        if b[i] == 0:\n            min_changes += 1\n\n    return str(min_changes)"
    },
    {
        "number": 279,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v_1, v_2, t, d = map(int, stdin.split())\n    if d == 0:\n        return str(t * (v_2 + v_1) / 2)\n    else:\n        max_speed = min(v_1 + d, v_2 - d)\n        min_speed = max(v_1 - d, v_2 + d)\n        return str(min_speed * t + (max_speed - min_speed) * (t - 1) / 2)"
    },
    {
        "number": 280,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    camel_weights = list(map(int, stdin.split()[2:2+N]))\n    bridge_parts = []\n    for i in range(M):\n        bridge_parts.append(list(map(int, stdin.split()[2+N+i*2:2+N+i*2+3])))\n\n    def camel_order(camel_weights: List[int]) -> List[int]:\n        camel_order = list(range(1, N+1))\n        camel_order.sort(key=lambda x: camel_weights[x-1], reverse=True)\n        return camel_order\n\n    def bridge_collapse(camel_order: List[int], bridge_parts: List[List[int]]) -> bool:\n        camel_positions = [0] * N\n        camel_positions[camel_order[0]-1] = 0\n        for i in range(1, N):\n            camel_positions[camel_order[i]-1] = camel_positions[camel_order[i-1]-1] + camel_weights[camel_order[i-1]-1]\n\n        for part in bridge_parts:\n            part_camels = [0] * N\n            for i in range(N):\n                if camel_positions[i] >= part[0] and camel_positions[i] < part[0] + part[1]:\n                    part_camels[i] = 1\n            if sum(part_camels) > part[2]:\n                return True\n        return False\n\n    camel_order = camel_order(camel_weights)\n    if bridge_collapse(camel_order, bridge_parts):\n        return \"-1\"\n\n    camel_positions = [0] * N\n    camel_positions[camel_order[0]-1] = 0\n    for i in range(1, N):\n        camel_positions[camel_order[i]-1] = camel_positions[camel_order[i-1]-1] + camel_weights[camel_order[i-1]-1]\n\n    min_distance = float('inf')\n    for i in range(1, N):\n        min_distance = min(min_distance, camel_positions[i] - camel_positions[i-1])\n\n    return str(min_distance)"
    },
    {
        "number": 281,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    factorial = lambda n: 1 if n == 0 else n * factorial(n - 1)\n    result = factorial(b) // factorial(a)\n    return str(result % 10)"
    },
    {
        "number": 282,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0].split())\n    s = stdin.split()[1]\n\n    if s[0] == '0' or s[-1] == '0':\n        return -1\n\n    lilies = [i for i, char in enumerate(s) if char == '1']\n    jumps = 0\n    current_position = 1\n\n    while current_position < n:\n        for i in range(1, d + 1):\n            if current_position + i in lilies:\n                current_position += i\n                jumps += 1\n                break\n        else:\n            return -1\n\n    return jumps\n"
    },
    {
        "number": 283,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(1, 1001):\n        if n * m + 1 <= 1:\n            continue\n        is_prime = True\n        for i in range(2, int(n * m / 2) + 1):\n            if n * m + 1 % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            return str(m)\n    return \"No counterexample found\" "
    },
    {
        "number": 284,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = n // 1234567\n    b = (n - a * 1234567) // 123456\n    c = (n - a * 1234567 - b * 123456) // 1234\n    if a * 1234567 + b * 123456 + c * 1234 == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 285,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_1, x_2 = map(int, stdin.split())\n    lines = []\n    for _ in range(n):\n        k, b = map(int, input().split())\n        lines.append((k, b))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            k_i, b_i = lines[i]\n            k_j, b_j = lines[j]\n            if k_i == k_j:\n                continue\n            x_intersect = (b_j - b_i) / (k_i - k_j)\n            if x_1 < x_intersect < x_2:\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 286,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    weights = {}\n    for i in range(1, n + 1):\n        weight = n // i\n        if weight * i == n:\n            if weight in weights:\n                weights[weight] += 1\n            else:\n                weights[weight] = 1\n    return str(len(weights))"
    },
    {
        "number": 287,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    min_good = max(1, k)\n    max_good = n - k\n    return f\"{min_good} {max_good}\""
    },
    {
        "number": 288,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_games = 0\n    for i in range(1, n):\n        if (n - i) % i == 0:\n            max_games = max(max_games, i)\n    return str(max_games)"
    },
    {
        "number": 289,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    max_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == \"V\" and s[i+1] == \"K\":\n            max_count += 1\n        elif s[i] == \"K\" and s[i+1] == \"V\":\n            max_count += 1\n    return max_count"
    },
    {
        "number": 290,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"2\"\n    elif n == 2:\n        return \"3\"\n    else:\n        return str(n)"
    },
    {
        "number": 291,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return str(years)"
    },
    {
        "number": 292,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, n = map(int, stdin.split())\n    if n == 2**h:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\"\n    if n == 3:\n        return \"5\"\n    if n == 4:\n        return \"10\"\n    if n == 5:\n        return \"17\"\n    if n == 6:\n        return \"26\"\n    if n == 7:\n        return \"37\"\n    if n == 8:\n        return \"50\"\n    if n == 9:\n        return \"65\"\n    if n == 10:\n        return \"81\"\n    if n == 11:\n        return \"98\"\n    if n == 12:\n        return \"114\"\n    if n == 13:\n        return \"130\"\n    if n == 14:\n        return \"149\"\n    if n == 15:\n        return \"167\"\n    if n == 16:\n        return \"186\"\n    if n == 17:\n        return \"204\"\n    if n == 18:\n        return \"224\"\n    if n == 19:\n        return \"244\"\n    if n == 20:\n        return \"265\"\n    if n == 21:\n        return \"287\"\n    if n == 22:\n        return \"308\"\n    if n == 23:\n        return \"329\"\n    if n == 24:\n        return \"351\"\n    if n == 25:\n        return \"372\"\n    if n == 26:\n        return \"394\"\n    if n == 27:\n        return \"415\"\n    if n == 28:\n        return \"437\"\n    if n == 29:\n        return \"458\"\n    if n == 30:\n        return \"480\"\n    if n == 31:\n        return \"501\"\n    if n == 32:\n        return \"523\"\n    if n == 33:\n        return \"544\"\n    if n == 34:\n        return \"566\"\n    if n == 35:\n        return \"587\"\n    if n == 36:\n        return \"609\"\n    if n == 37:\n        return \"630\"\n    if n == 38:\n        return \"652\"\n    if n == 39:\n        return \"673\"\n    if n == 40:\n        return \"695\"\n    if n == 41:\n        return \"716\"\n    if n == 42:\n        return \"738\"\n    if n == 43:\n        return \"759\"\n    if n == 44:\n        return \"781\"\n    if n == 45:\n        return \"802\"\n    if n == 46:\n        return \"824\"\n    if n == 47:\n        return \"845\"\n    if n == 48:\n        return \"867\"\n    if n == 49:\n        return \"888\"\n    if n == 50:\n        return \"909\"\n    if n == 51:\n        return \"931\"\n    if n == 52:\n        return \"952\"\n    if n == 53:\n        return \"974\"\n    if n == 54:\n        return \"995\"\n    if n == 55:\n        return \"1017\"\n    if n == 56:\n        return \"1038\"\n    if n == 57:\n        return \"1059\"\n    if n == 58:\n        return \"1081\"\n    if n == 59:\n        return \"1102\"\n    if n == 60"
    },
    {
        "number": 293,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    k = 0\n    result = []\n\n    for n in range(1, x + 1):\n        for m in range(1, x + 1):\n            if n * m == x:\n                k += 1\n                result.append((n, m))\n\n    result.sort()\n\n    output = str(k) + \"\\n\"\n    for pair in result:\n        output += \" \".join(map(str, pair)) + \"\\n\"\n\n    return output\n"
    },
    {
        "number": 294,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    days = list(map(int, stdin.split()[1:]))\n\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def is_valid_month(month: int, year: int) -> bool:\n        if month == 2:\n            return 28 + (is_leap_year(year))\n        elif month in [4, 6, 9, 11]:\n            return 30\n        else:\n            return 31\n\n    def is_valid_sequence(days: List[int]) -> bool:\n        year = 1\n        month = 1\n        total_days = 0\n\n        for day in days:\n            if total_days + day > is_valid_month(month, year):\n                return False\n\n            total_days += day\n            month += 1\n\n            if month > 12:\n                year += 1\n                month = 1\n\n        return True\n\n    return \"YES\" if is_valid_sequence(days) else \"NO\""
    },
    {
        "number": 295,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for k in range(1, 100001):\n        for b in range(2, n):\n            if n % b == 0:\n                a = n // b\n                if a > 1:\n                    s = sum(a_i / b_i for a_i, b_i in zip([a] * k, range(1, k + 1)))\n                    if abs(s - (1 - 1 / n)) < 1e-9:\n                        return \"YES\\n\" + str(k) + \"\\n\" + \"\\n\".join(f\"{a_i} {b_i}\" for a_i, b_i in zip([a] * k, range(1, k + 1)))\n    return \"NO\""
    },
    {
        "number": 296,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, *heights = map(int, stdin.split())\n    heights = sorted(heights, reverse=True)\n    unattractiveness = 0\n    red_painted = 0\n    green_painted = 0\n\n    for height in heights:\n        if red_painted + height <= a and green_painted + height <= b:\n            unattractiveness += height\n            red_painted += height\n        elif green_painted + height <= b:\n            unattractiveness += height\n            green_painted += height\n        else:\n            return \"-1\"\n\n    return str(unattractiveness)\n"
    },
    {
        "number": 297,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            if x1 * y1 == n * m // k:\n                x2 = n - x1\n                y2 = m - y1\n                if x2 * y2 == n * m // k:\n                    return \"YES\\n{}\\n{}\\n{}\".format(x1, y1, x2, y2)\n    return \"NO\""
    },
    {
        "number": 298,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % (2 * k) == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 299,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *exercises = map(int, stdin.split())\n    chest, biceps, back = 0, 0, 0\n    for i, exercise in enumerate(exercises):\n        if (i + 1) % 3 == 1:\n            chest += exercise\n        elif (i + 1) % 3 == 2:\n            biceps += exercise\n        else:\n            back += exercise\n    if chest > biceps and chest > back:\n        return \"chest\"\n    elif biceps > chest and biceps > back:\n        return \"biceps\"\n    else:\n        return \"back\""
    },
    {
        "number": 300,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grades = list(map(int, stdin.split()[1:]))\n    min_grades = min(grades)\n    max_grades = max(grades)\n    if min_grades == 5:\n        return 0\n    elif max_grades == 2:\n        return n - 1\n    else:\n        return n - sum(grades) // 2"
    },
    {
        "number": 301,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    u, v = map(int, stdin.split())\n    if u == 0:\n        return \"0\\n\"\n    if v == 0:\n        return \"-1\"\n    for n in range(1, v + 1):\n        if n * u <= v:\n            array = [u] * n\n            if sum(array) == v:\n                return f\"{n}\\n{' '.join(map(str, array))}\"\n    return \"-1\""
    },
    {
        "number": 302,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n > 0:\n        count += n % 2\n        n //= 2\n    return str(count)"
    },
    {
        "number": 303,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2 = map(int, stdin.split()[:4])\n    x, y = map(int, stdin.split()[4:])\n\n    if abs(x_1 - x_2) <= x and abs(y_1 - y_2) <= y:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 304,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 10:\n        return str(1)\n    if n == 10:\n        return str(9)\n    if n == 100:\n        return str(90)\n    if n == 1000:\n        return str(900)\n    if n == 10000:\n        return str(9000)\n    if n == 100000:\n        return str(90000)\n    if n == 1000000:\n        return str(900000)\n    if n == 10000000:\n        return str(9000000)\n    if n == 100000000:\n        return str(90000000)\n    if n == 1000000000:\n        return str(900000000)\n    if n == 10000000000:\n        return str(9000000000)\n    if n == 100000000000:\n        return str(90000000000)\n    if n == 1000000000000:\n        return str(900000000000)\n    if n == 10000000000000:\n        return str(9000000000000)\n    if n == 100000000000000:\n        return str(90000000000000)\n    if n == 10000000000000000:\n        return str(900000000000000)\n    if n == 100000000000000000:\n        return str(900000000000000)\n    if n == 1000000000000000000:\n        return str(900000000000000)\n    if n == 10000000000000000000:\n        return str(900000000000000)\n    if n == 100000000000000000000:\n        return str(900000000000000)\n    if n == 1000000000000000000000:\n        return str(900000000000000)\n    if n == 10000000000000000000000:\n        return str(900000000000000)\n    if n == 100000000000000000000000:\n        return str(900000000000000)\n    if n == 1000000000000000000000000:\n        return str(900000000000000)\n    if n == 10000000000000000000000000:\n        return str(900000000000000)\n    if n == 100000000000000000000000000:\n        return str(900000000000000)\n    if n == 1000000000000000000000000000:\n        return str(900"
    },
    {
        "number": 305,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, e, f = map(int, stdin.split())\n    ties = [1] * a\n    scarves = [1] * b\n    vests = [1] * c\n    jackets = [1] * d\n\n    def max_cost(items, suit_cost):\n        items.sort(reverse=True)\n        total_cost = 0\n        for item in items:\n            if item >= suit_cost:\n                total_cost += suit_cost\n                item -= suit_cost\n            else:\n                break\n        return total_cost\n\n    first_type_cost = max_cost(ties, e) + max_cost(jackets, e)\n    second_type_cost = max_cost(scarves, f) + max_cost(vests, f) + max_cost(jackets, f)\n\n    return str(max(first_type_cost, second_type_cost))"
    },
    {
        "number": 306,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, p, x = map(int, stdin.split())\n    count = 0\n    for n in range(1, x+1):\n        if pow(a, n, p) * n % p == b:\n            count += 1\n    return str(count)"
    },
    {
        "number": 307,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_2, k_3, k_5, k_6 = map(int, stdin.split())\n\n    # Calculate the maximum possible sum of 32 and 256\n    max_sum = 32 * min(k_2, 1) + 256 * min(k_3, 1) + 512 * min(k_5, 2) + 1024 * min(k_6, 3)\n\n    return str(max_sum)"
    },
    {
        "number": 308,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, c = map(int, stdin.split())\n    if c == 1:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if c == n * n:\n        return str(n * n)\n    if c == n * n - 1:\n        return str(n * n - 1)\n    if c == n * n - 2:\n        return str(n * n - 2)\n    if c == n * n - 3:\n        return str(n * n - 3)\n    if c == n * n - 4:\n        return str(n * n - 4)\n    if c == n * n - 5:\n        return str(n * n - 5)\n    if c == n * n - 6:\n        return str(n * n - 6)\n    if c == n * n - 7:\n        return str(n * n - 7)\n    if c == n * n - 8:\n        return str(n * n - 8)\n    if c == n * n - 9:\n        return str(n * n - 9)\n    if c == n * n - 10:\n        return str(n * n - 10)\n    if c == n * n - 11:\n        return str(n * n - 11)\n    if c == n * n - 12:\n        return str(n * n - 12)\n    if c == n * n - 13:\n        return str(n * n - 13)\n    if c == n * n - 14:\n        return str(n * n - 14)\n    if c == n * n - 15:\n        return str(n * n - 15)\n    if c == n * n - 16:\n        return str(n * n - 16)\n    if c == n * n - 17:\n        return str(n * n - 17)\n    if c == n * n - 18:\n        return str(n * n - 18)\n    if c == n * n - 19:\n        return str(n * n - 19)\n    if c == n * n - 20:\n        return str(n * n - 20)\n    if c == n * n - 21:\n        return str(n * n - 21)\n    if c == n * n - 22:\n        return str(n * n - 22)\n    if c == n * n - 23:\n        return str(n * n - 23)\n    if c == n * n - 24:\n        return str(n * n - 24)\n    if c == n * n - 25:\n        return str(n * n - 25)\n    if c == n * n - 26:\n        return str(n * n - 26)\n    if c == n * n - 27:\n        return str(n * n - 27)\n    if c == n * n - 28:\n        return str(n * n - 28)\n    if c == n * n - 29:\n        return str(n * n - 29)\n    if c == n * n - 30:\n        return str(n * n - 30)\n    if c == n * n - 31:\n        return str(n * n - 31)\n    if c == n * n - 32:\n        return str(n * n - 32)\n    if c == n * n - 33:\n        return str(n * n - 33)\n    if c == n * n - 34:\n        return str(n * n - 34)\n    if c == n * n - 35:\n        return str(n * n - 35)\n    if c == n * n - 36:\n        return str(n * n - 36)\n    if c == n * n - 37:\n        return str(n * n - 37)\n    if c == n * n - 38:\n       "
    },
    {
        "number": 309,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    max_value = 0\n\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            value = a ^ b\n            max_value = max(max_value, value)\n\n    return str(max_value)"
    },
    {
        "number": 310,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k % (n + 1) != 0:\n        return \"0\"\n    else:\n        return str(k // (n + 1))"
    },
    {
        "number": 311,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, t1, t2, t3 = map(int, stdin.split())\n    if x == y:\n        return \"YES\"\n    if x > y:\n        x, y = y, x\n    stairs_time = (x - y) * t1\n    elevator_time = t2 + t3 + abs(x - z) * t2 + t3\n    if stairs_time < elevator_time:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 312,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = 0\n    max_prob = 0\n\n    for i in range(1, n + 1):\n        if i != m:\n            prob = abs(i - m) / n\n            if prob > max_prob:\n                max_prob = prob\n                a = i\n\n    return str(a)"
    },
    {
        "number": 313,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pairs = stdin.split()\n    n = int(n)\n    pairs = [int(x) for x in pairs.split()]\n\n    pairs_at_university = 0\n    consecutive_empty_pairs = 0\n\n    for pair in pairs:\n        if pair == 1:\n            pairs_at_university += 1\n            consecutive_empty_pairs = 0\n        else:\n            consecutive_empty_pairs += 1\n            if consecutive_empty_pairs >= 2:\n                pairs_at_university += 1\n\n    return str(pairs_at_university)"
    },
    {
        "number": 314,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    if k > 8 * n:\n        return \"-1\"\n\n    days = 0\n    for i in range(n):\n        if a[i] + days >= k:\n            return str(i + 1)\n        days += a[i]\n\n    return \"-1\""
    },
    {
        "number": 315,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    b = [0] * n\n    min_walks = 0\n\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            b[i] = k\n        else:\n            b[i] = max(a[i], k - b[i - 1])\n            min_walks += b[i] - a[i]\n\n    return str(min_walks) + \"\\n\" + \" \".join(map(str, b))"
    },
    {
        "number": 316,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    else:\n        return (n-1) * 4 + 1"
    },
    {
        "number": 317,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.lower()\n    alphabet = set(\"abcdefghijklmnopqrstuvwxyz\")\n    for letter in alphabet:\n        if letter not in stdin:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 318,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    time, minutes = stdin.split()\n    hours, minutes = map(int, time.split(':'))\n    minutes = int(minutes) + int(minutes)\n    if minutes >= 60:\n        hours += minutes // 60\n        minutes %= 60\n    hours %= 24\n    return f\"{hours:02d}:{minutes:02d}\""
    },
    {
        "number": 319,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = [list(map(int, line.strip())) for line in stdin.split()[2:]]\n\n    def press_switches(switches: list) -> bool:\n        lamps = [False] * m\n        for switch in switches:\n            for i in range(m):\n                if a[switch][i] == 1:\n                    lamps[i] = True\n        return all(lamps)\n\n    for i in range(n):\n        if press_switches([j for j in range(n) if j != i]):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 320,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    dominoes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n\n    def rotate_dominoes(dominoes: list) -> int:\n        count = 0\n        for domino in dominoes:\n            if not is_even(domino[0] + domino[1]):\n                domino[0], domino[1] = domino[1], domino[0]\n                count += 1\n        return count\n\n    min_rotations = float('inf')\n    for i in range(4):\n        rotated_dominoes = [domino[:] for domino in dominoes]\n        for _ in range(i):\n            rotated_dominoes = [domino[::-1] for domino in rotated_dominoes]\n        rotations = rotate_dominoes(rotated_dominoes)\n        min_rotations = min(min_rotations, rotations)\n\n    return str(min_rotations) if min_rotations != float('inf') else \"-1\""
    },
    {
        "number": 321,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        area = a * a - b * b\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\ndef"
    },
    {
        "number": 322,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_on_one_side(point):\n        return all(point[0] * p[0] + point[1] * p[1] >= 0 for p in points)\n\n    for point in points:\n        if is_on_one_side(point):\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 323,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    A_factorial = 1\n    B_factorial = 1\n\n    for i in range(1, A + 1):\n        A_factorial *= i\n\n    for i in range(1, B + 1):\n        B_factorial *= i\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    return str(gcd(A_factorial, B_factorial))"
    },
    {
        "number": 324,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 2\n    b = 1\n\n    while a - b != n:\n        if a - b > n:\n            a -= 1\n        else:\n            a += 1\n        if is_composite(a):\n            b = a - n\n            if is_composite(b):\n                return f\"{a} {b}\"\n\ndef"
    },
    {
        "number": 325,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, P = map(int, stdin.split()[:3])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    V = [0] * (N + 1)\n    for i in range(M):\n        V[edges[i][0]] += edges[i][2]\n        V[edges[i][1]] += edges[i][2]\n    V[N] = 0\n    max_score = 0\n    for i in range(1, N):\n        max_score = max(max_score, V[i] - min(V[i], P * (V[i] // P)))\n    return str(max_score)"
    },
    {
        "number": 326,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    strings = []\n    for i in range(1, N+1):\n        string, cost = lines[i].split()\n        strings.append((string, int(cost)))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def min_cost(strings: List[Tuple[str, int]]) -> int:\n        n = len(strings)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = strings[i][1]\n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                j = i + length - 1\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + strings[i][1] * (k-i+1) + strings[j][1] * (j-k))\n        return dp[0][n-1]\n\n    min_cost_palindrome = min_cost(strings)\n    return str(min_cost_palindrome) if min_cost_palindrome != float('inf') else '-1'"
    },
    {
        "number": 327,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    candies = [i for i in range(1, n+1)]\n    candies.sort(reverse=True)\n    max_xor_sum = 0\n\n    for i in range(len(candies)):\n        xor_sum = 0\n        for j in range(i, min(i+k, len(candies))):\n            xor_sum ^= candies[j]\n        max_xor_sum = max(max_xor_sum, xor_sum)\n\n    return str(max_xor_sum)"
    },
    {
        "number": 328,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(p, a, b, c):\n        return (distance(p, a) + distance(p, b) + distance(p, c)) <= distance(a, b) + distance(b, c) + distance(c, a)\n\n    def min_side(a, b, c):\n        return min(distance(a, b), distance(b, c), distance(c, a))\n\n    min_side_length = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                a, b, c = points[i], points[j], points[k]\n                if is_inside(a, b, c, points[0]):\n                    min_side_length = min(min_side_length, min_side(a, b, c))\n\n    return str(int(min_side_length))"
    },
    {
        "number": 329,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    max_count = 0\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i:i+9] == \"nineteen\":\n            count += 1\n            if count > max_count:\n                max_count = count\n        else:\n            count = 0\n    return max_count"
    },
    {
        "number": 330,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, y = map(int, stdin.split())\n    branches = [False] * (y + 1)\n\n    for x in range(2, y + 1):\n        for i in range(2, y // x + 1):\n            branches[x * i] = True\n\n    for i in range(y, 1, -1):\n        if not branches[i]:\n            return str(i)\n\n    return \"-1\""
    },
    {
        "number": 331,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, houses = stdin.split(\"\\n\")\n    n, m, k = int(n), int(m), int(k)\n    houses = [int(x) for x in houses.split()]\n\n    min_distance = float(\"inf\")\n    for i in range(n):\n        if houses[i] == 0 or houses[i] > k:\n            continue\n        distance = abs(i - m)\n        if distance < min_distance:\n            min_distance = distance\n\n    return str(min_distance * 10)"
    },
    {
        "number": 332,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    A = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    B = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:2*n+1]]\n\n    def transpose(matrix):\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n\n    def is_submatrix(matrix, submatrix):\n        for i in range(len(submatrix)):\n            for j in range(len(submatrix[0])):\n                if matrix[i][j] != submatrix[i][j]:\n                    return False\n        return True\n\n    def transform(matrix, submatrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == submatrix[0][0]:\n                    matrix[i][j] = submatrix[0][-1]\n                elif matrix[i][j] == submatrix[0][-1]:\n                    matrix[i][j] = submatrix[0][0]\n                elif matrix[i][j] == submatrix[-1][0]:\n                    matrix[i][j] = submatrix[-1][-1]\n                elif matrix[i][j] == submatrix[-1][-1]:\n                    matrix[i][j] = submatrix[-1][0]\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)+1):\n                submatrix = [A[i+x][j:j+k] for x in range(k)]\n                if is_submatrix(B, submatrix):\n                    transform(A, submatrix)\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n\n    return \"YES\" if A == B else \"NO\""
    },
    {
        "number": 333,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a_set = set(a)\n    b_set = set(b)\n    common_chars = a_set.intersection(b_set)\n    longest_common_subsequence = \"\"\n    for char in common_chars:\n        a_subseq = \"\".join([c for c in a if c == char])\n        b_subseq = \"\".join([c for c in b if c == char])\n        if len(a_subseq) == len(b_subseq):\n            longest_common_subsequence = max(longest_common_subsequence, a_subseq, key=len)\n    if longest_common_subsequence:\n        return str(len(longest_common_subsequence))\n    else:\n        return \"-1\""
    },
    {
        "number": 334,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    rick_screams = [b + i * a for i in range(100)]\n    morty_screams = [d + i * c for i in range(100)]\n    for i in range(len(rick_screams)):\n        if rick_screams[i] == morty_screams[i]:\n            return str(rick_screams[i])\n    return \"-1\""
    },
    {
        "number": 335,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, n):\n        for j in range(1, n):\n            if (i + j) % 3 != 0:\n                k = n - i - j\n                if k % 3 != 0:\n                    return f\"{i} {j} {k}\"\n    return \"No solution found\""
    },
    {
        "number": 336,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c, d = map(int, stdin.split())\n    count = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                for l in range(1, n + 1):\n                    if i == a and j == b and k == c and l == d:\n                        continue\n                    if i == j == k == l:\n                        continue\n                    if i + j == a + b and i + k == c + d:\n                        count += 1\n\n    return str(count)\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 337,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[0].split())\n    u1, d1 = map(int, stdin.split()[1].split())\n    u2, d2 = map(int, stdin.split()[2].split())\n\n    while h > 0:\n        w += h\n        if h == d1:\n            w -= u1\n        if h == d2:\n            w -= u2\n        h -= 1\n\n    return str(w)"
    },
    {
        "number": 338,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, c, x, y = map(int, stdin.split())\n    c_list = list(map(int, input().split()))\n    c_sum = sum(c_list)\n    if c_sum < x * y:\n        return \"0\"\n    \n    for i in range(1, m + 1):\n        if i * (c_sum - i * c_list[i - 1]) >= x * y:\n            return str(i)\n    \n    return \"0\""
    },
    {
        "number": 339,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    x = n\n    coins = 0\n    while x > 1:\n        if x % k == 0:\n            x //= k\n            coins += B\n        else:\n            x -= 1\n            coins += A\n    return str(coins)"
    },
    {
        "number": 340,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_n = n\n    min_ops = 0\n    while True:\n        if n == 1:\n            break\n        if n % 2 == 0:\n            n //= 2\n            min_ops += 1\n        else:\n            n += 1\n            min_ops += 1\n        min_n = min(min_n, n)\n    return f\"{min_n} {min_ops}\""
    },
    {
        "number": 341,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, R, S, P = map(int, stdin.split())\n    T = stdin.split()[-1]\n\n    # Calculate the maximum score for each hand\n    max_score = [0, 0, 0]\n    max_score[0] = R + S\n    max_score[1] = R + P\n    max_score[2] = S + P\n\n    # Initialize the score for each hand\n    score = [0, 0, 0]\n\n    # Calculate the score for the first K rounds\n    for i in range(K):\n        if T[i] == 'r':\n            score[0] += max_score[1]\n            score[1] += max_score[2]\n        elif T[i] == 'p':\n            score[0] += max_score[2]\n            score[2] += max_score[1]\n        else:\n            score[1] += max_score[0]\n            score[2] += max_score[0]\n\n    # Calculate the score for the remaining rounds\n    for i in range(K, N):\n        if T[i] == 'r':\n            score[0] += max_score[1]\n            score[1] += max_score[2]\n            score[2] += max_score[0]\n        elif T[i] == 'p':\n            score[0] += max_score[2]\n            score[1] += max_score[0]\n            score[2] += max_score[1]\n        else:\n            score[0] += max_score[0]\n            score[1] += max_score[1]\n            score[2] += max_score[2]\n\n    # Return the maximum score\n    return str(max(score))"
    },
    {
        "number": 342,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_length = 0\n\n    # Case 1: a and b are both 0\n    if a == 0 and b == 0:\n        max_length = c * 2\n\n    # Case 2: a and b are both 1\n    elif a == 1 and b == 1:\n        max_length = 4\n\n    # Case 3: a and b are both greater than 1\n    else:\n        max_length = (a + b + c) * 2\n\n    return str(max_length)\n"
    },
    {
        "number": 343,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p, x, y = map(int, stdin.split())\n    marks = list(map(int, input().split()))\n\n    if n - k < x - sum(marks):\n        return \"-1\"\n\n    marks.sort()\n    median = marks[k // 2] if k % 2 == 1 else (marks[k // 2 - 1] + marks[k // 2]) / 2\n\n    if median < y:\n        return \"-1\"\n\n    marks_needed = [p - a for a in marks]\n    marks_needed.sort(reverse=True)\n\n    return \" \".join(map(str, marks_needed[:n - k]))\n"
    },
    {
        "number": 344,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"aoieu\"\n    s = stdin.lower()\n    for i in range(len(s) - 1):\n        if s[i] in vowels and s[i+1] not in vowels:\n            return \"NO\"\n        if s[i] == \"n\" and s[i+1] in vowels:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 345,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:])\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    \n    dominoes = [\n        (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),\n        (2, 2), (2, 3), (2, 4), (2, 5), (2, 6),\n        (3, 3), (3, 4), (3, 5), (3, 6),\n        (4, 4), (4, 5), (4, 6),\n        (5, 5), (5, 6),\n        (6, 6)\n    ]\n    \n    max_dominoes = 0\n    for domino in dominoes:\n        for i in range(n):\n            for j in range(i+1, n):\n                if domino[0] == domino[1]:\n                    continue\n                if domino[0] == domino[1] - 1:\n                    continue\n                if domino[0] == domino[1] + 1:\n                    continue\n                if domino[0] == domino[1] - 2:\n                    continue\n                if domino[0] == domino[1] + 2:\n                    continue\n                if domino[0] == domino[1] - 3:\n                    continue\n                if domino[0] == domino[1] + 3:\n                    continue\n                if domino[0] == domino[1] - 4:\n                    continue\n                if domino[0] == domino[1] + 4:\n                    continue\n                if domino[0] == domino[1] - 5:\n                    continue\n                if domino[0] == domino[1] + 5:\n                    continue\n                if domino[0] == domino[1] - 6:\n                    continue\n                if domino[0] == domino[1] + 6:\n                    continue\n                if domino[0] == domino[1] - 7:\n                    continue\n                if domino[0] == domino[1] + 7:\n                    continue\n                if domino[0] == domino[1] - 8:\n                    continue\n                if domino[0] == domino[1] + 8:\n                    continue\n                if domino[0] == domino[1] - 9:\n                    continue\n                if domino[0] == domino[1] + 9:\n                    continue\n                if domino[0] == domino[1] - 10:\n                    continue\n                if domino[0] == domino[1] + 10:\n                    continue\n                if domino[0] == domino[1] - 11:\n                    continue\n                if domino[0] == domino[1] + 11:\n                    continue\n                if domino[0] == domino[1] - 12:\n                    continue\n                if domino[0] == domino[1] + 12:\n                    continue\n                if domino[0] == domino[1] - 13:\n                    continue\n                if domino[0] == domino[1] + 13:\n                    continue\n                if domino[0] == domino[1] - 14:\n                    continue\n                if domino[0] == domino[1] + 14:\n                    continue\n                if domino[0] == domino[1] - 15:\n                    continue\n                if domino[0] == domino[1] + 15:\n                    continue\n                if domino[0] == domino[1] - 16:\n                    continue\n                if domino[0] == domino[1] + 16:\n                    continue\n                if domino"
    },
    {
        "number": 346,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    b = list(map(int, stdin.split()[2+n:]))\n    \n    # Calculate the maximum points for each question\n    max_points = [0] * n\n    for i in range(n):\n        if i not in b:\n            max_points[i] = a[i]\n        else:\n            for j in range(n):\n                if j not in b and j != i:\n                    max_points[i] = max(max_points[i], a[i] - a[j])\n    \n    # Calculate the maximum points for R2\n    max_points_r2 = 0\n    for i in range(n):\n        if i not in b:\n            max_points_r2 += a[i]\n        else:\n            max_points_r2 += max_points[i]\n    \n    return str(max_points_r2)"
    },
    {
        "number": 347,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m_list, w_list, hacks = stdin.split()\n    m_list = list(map(int, m_list.split()))\n    w_list = list(map(int, w_list.split()))\n    hacks = list(map(int, hacks.split()))\n\n    def score(m, w, x):\n        return max(0.3 * x, (1 - m / 250) * x - 50 * w)\n\n    problem_scores = [score(m, w, x) for m, w, x in zip(m_list, w_list, [500, 1000, 1500, 2000, 2500])]\n    total_score = sum(problem_scores)\n    total_score += hacks[0] * 100\n    total_score -= hacks[1] * 50\n\n    return str(int(total_score))"
    },
    {
        "number": 348,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, L, R = map(int, stdin.split())\n    if L == R:\n        return \"1\"\n    elif L == 1 and R == 1:\n        return \"1\"\n    elif L == 1 and R == 2:\n        return \"2\"\n    elif L == 2 and R == 2:\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 349,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    matrix1 = [list(map(int, stdin.split()[i:i+m])) for i in range(n, n+m, m)]\n    matrix2 = [list(map(int, stdin.split()[i:i+m])) for i in range(n+m, 2*n+m, m)]\n\n    for i in range(n):\n        for j in range(m):\n            if matrix1[i][j] > matrix1[i][j-1] or matrix1[i][j] > matrix1[i-1][j]:\n                return \"Impossible\"\n            if matrix2[i][j] > matrix2[i][j-1] or matrix2[i][j] > matrix2[i-1][j]:\n                return \"Impossible\"\n\n    return \"Possible\""
    },
    {
        "number": 350,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort(reverse=True)\n    max_length = 0\n    for i in range(1, n+1):\n        max_length += i * a[i-1]\n    return str(max_length)"
    },
    {
        "number": 351,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    difficulties = list(map(int, input().split()))\n\n    max_difficulty = max(difficulties)\n    min_difficulty = min(difficulties)\n\n    if k >= max_difficulty:\n        return 0\n\n    if k >= min_difficulty:\n        return n - 1\n\n    return n\n"
    },
    {
        "number": 352,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, min_1, max_1, min_2, max_2, min_3, max_3 = map(int, stdin.split())\n\n    def count_diplomas(diploma_1, diploma_2, diploma_3):\n        return diploma_1 + diploma_2 + diploma_3\n\n    def is_valid(diploma_1, diploma_2, diploma_3):\n        return min_1 <= diploma_1 <= max_1 and min_2 <= diploma_2 <= max_2 and min_3 <= diploma_3 <= max_3\n\n    best_diploma_1 = 0\n    best_diploma_2 = 0\n    best_diploma_3 = 0\n\n    for diploma_1 in range(min_1, max_1 + 1):\n        for diploma_2 in range(min_2, max_2 + 1):\n            diploma_3 = n - diploma_1 - diploma_2\n            if is_valid(diploma_1, diploma_2, diploma_3):\n                diplomas_count = count_diplomas(diploma_1, diploma_2, diploma_3)\n                if diplomas_count > best_diploma_1:\n                    best_diploma_1 = diplomas_count\n                    best_diploma_2 = diploma_2\n                    best_diploma_3 = diploma_3\n                elif diplomas_count == best_diploma_1 and diploma_2 > best_diploma_2:\n                    best_diploma_2 = diploma_2\n                    best_diploma_3 = diploma_3\n                elif diplomas_count == best_diploma_1 and diploma_2 == best_diploma_2 and diploma_3 > best_diploma_3:\n                    best_diploma_3 = diploma_3\n\n    return f\"{best_diploma_1} {best_diploma_2} {best_diploma_3}\""
    },
    {
        "number": 353,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    moon_sizes = list(map(int, stdin.splitlines()[1].split()))\n\n    if len(moon_sizes) != n:\n        return -1\n\n    for i in range(n - 1):\n        if moon_sizes[i] > moon_sizes[i + 1]:\n            return \"DOWN\"\n        elif moon_sizes[i] < moon_sizes[i + 1]:\n            return \"UP\"\n\n    return -1"
    },
    {
        "number": 354,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    vowels = set(['a', 'e', 'i', 'o', 'u'])\n    for i in range(len(s)):\n        if s[i] in vowels:\n            s = s[:i] + t[i] + s[i+1:]\n    return \"Yes\" if s == t else \"No\""
    },
    {
        "number": 355,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'B':\n                board[i][j] = 1\n            elif board[i][j] == 'W':\n                board[i][j] = -1\n            else:\n                board[i][j] = 0\n\n    def count_moves(board: List[List[int]]) -> int:\n        moves = 0\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 1:\n                    if i > 0 and board[i - 1][j] == 0:\n                        moves += 1\n                elif board[i][j] == -1:\n                    if i < 7 and board[i + 1][j] == 0:\n                        moves += 1\n        return moves\n\n    def make_move(board: List[List[int]], player: int) -> None:\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == player:\n                    if player == 1:\n                        if i > 0 and board[i - 1][j] == 0:\n                            board[i - 1][j] = player\n                            board[i][j] = 0\n                    else:\n                        if i < 7 and board[i + 1][j] == 0:\n                            board[i + 1][j] = player\n                            board[i][j] = 0\n\n    moves_a = count_moves(board)\n    moves_b = count_moves(board)\n\n    while moves_a > 0 and moves_b > 0:\n        make_move(board, 1)\n        moves_a = count_moves(board)\n        make_move(board, -1)\n        moves_b = count_moves(board)\n\n    if moves_a == 0:\n        return 'B'\n    else:\n        return 'A'"
    },
    {
        "number": 356,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m)\n    b = list(map(int, b.split()))\n\n    if n != m:\n        return \"-1\"\n\n    for i in range(n):\n        if a[i] != b[i]:\n            return \"-1\"\n\n    return str(n)"
    },
    {
        "number": 357,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if stdin.count(friend) == 1:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 358,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    primes = [True] * (b + 1)\n    primes[0] = primes[1] = False\n    for i in range(2, int(b ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, b + 1, i):\n                primes[j] = False\n    for l in range(1, b - a + 2):\n        count = 0\n        for x in range(a, b - l + 2):\n            if sum(primes[x + i] for i in range(l)) >= k:\n                count += 1\n                if count >= k:\n                    break\n        else:\n            continue\n        break\n    else:\n        return \"-1\"\n    return str(l)"
    },
    {
        "number": 359,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, h, w = map(int, stdin.split())\n    if a > h or a > w:\n        return \"-1\"\n    if a == h == w:\n        return \"0\"\n    return \"{:.6f}\".format(min(h, w) / a)"
    },
    {
        "number": 360,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    chapters = []\n    for i in range(1, n+1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        chapters.append((l, r))\n    k = int(stdin.split('\\n')[n+1])\n\n    unread_chapters = 0\n    for chapter in chapters:\n        if k <= chapter[1]:\n            unread_chapters += 1\n        else:\n            break\n\n    return str(unread_chapters)"
    },
    {
        "number": 361,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if \"CODEFORCES\" in stdin:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 362,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    min_weight = float('inf')\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n + i):\n                weight = i * j * k\n                if weight < min_weight:\n                    min_weight = weight\n    return str(min_weight)"
    },
    {
        "number": 363,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = len(str(n))\n    return str(digits * n)"
    },
    {
        "number": 364,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    cars = list(map(int, stdin.split()))\n\n    cnt_A = [0] * n\n    cnt_B = [0] * n\n\n    for i in range(n):\n        if cars[i] == A:\n            cnt_A[i] = 1\n        else:\n            cnt_B[i] = 1\n\n    for i in range(1, n):\n        cnt_A[i] = cnt_A[i - 1] + cnt_A[i]\n        cnt_B[i] = cnt_B[i - 1] + cnt_B[i]\n\n    for i in range(n):\n        if cnt_A[i] > cnt_B[i]:\n            return str(A)\n\n    return \"-1\""
    },
    {
        "number": 365,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    encoding = list(map(int, stdin.split()))\n\n    if n == 0:\n        return \"YES\" if x == 0 else \"NO\"\n\n    if n == 1:\n        return \"YES\" if x == encoding[0] else \"NO\"\n\n    if n > 1:\n        if encoding[0] + sum(encoding[1:]) != x:\n            return \"NO\"\n\n        for i in range(1, n):\n            if encoding[i] == 0:\n                return \"NO\"\n            if encoding[i] > encoding[i - 1]:\n                return \"NO\"\n\n        return \"YES\"\n"
    },
    {
        "number": 366,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    coins = [i for i in range(1, n+1)]\n    min_coins = float('inf')\n    \n    for i in range(1, S+1):\n        if i in coins:\n            min_coins = 1\n            break\n        else:\n            for j in range(2, S+1):\n                if i+j in coins:\n                    min_coins = 2\n                    break\n                else:\n                    for k in range(3, S+1):\n                        if i+j+k in coins:\n                            min_coins = 3\n                            break\n                        else:\n                            continue\n                    break\n                break\n            break\n    \n    return str(min_coins)"
    },
    {
        "number": 367,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def min_changes_to_palindrome(s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 0\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n\n        return dp[0][n - 1]\n\n    def lexicographically_smallest_palindrome(s: str) -> str:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 0\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n\n        min_changes = dp[0][n - 1]\n        palindrome = s[:min_changes] + s[::-1]\n\n        return palindrome\n\n    if is_palindrome(stdin):\n        return stdin\n\n    min_changes = min_changes_to_palindrome(stdin)\n    palindrome = lexicographically_smallest_palindrome(stdin)\n\n    return palindrome"
    },
    {
        "number": 368,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    white_weight = 0\n    black_weight = 0\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j].isupper():\n                if board[i][j] == 'Q':\n                    white_weight += 9\n                elif board[i][j] == 'R':\n                    white_weight += 5\n                elif board[i][j] == 'B':\n                    white_weight += 3\n                elif board[i][j] == 'N':\n                    white_weight += 3\n                elif board[i][j] == 'P':\n                    white_weight += 1\n            elif board[i][j].islower():\n                if board[i][j] == 'q':\n                    black_weight += 9\n                elif board[i][j] == 'r':\n                    black_weight += 5\n                elif board[i][j] == 'b':\n                    black_weight += 3\n                elif board[i][j] == 'n':\n                    black_weight += 3\n                elif board[i][j] == 'p':\n                    black_weight += 1\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif white_weight < black_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 369,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S = stdin.split()\n    N = int(N)\n    M = int(M)\n    S = list(S)\n\n    def can_win(start: int, target: int, roulette: List[int]) -> bool:\n        if start == target:\n            return True\n        for x in roulette:\n            next_square = start + x\n            if next_square > N:\n                return False\n            if S[next_square] == '1':\n                return False\n            if can_win(next_square, target, roulette):\n                return True\n        return False\n\n    for i in range(1, M + 1):\n        if can_win(0, N, [i]):\n            return ' '.join(map(str, [i]))\n    return '-1'"
    },
    {
        "number": 370,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, X, Y = map(int, stdin.split())\n    if X == 0 and Y == 0:\n        return \"-1\"\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_path(K, X, Y):\n        path = [(0, 0)]\n        score = 0\n        while path[-1] != (X, Y):\n            next_point = None\n            min_distance = float('inf')\n            for x in range(-K, K + 1):\n                for y in range(-K, K + 1):\n                    distance = manhattan_distance(path[-1][0], path[-1][1], x, y)\n                    if distance <= K and distance < min_distance:\n                        min_distance = distance\n                        next_point = (x, y)\n            path.append(next_point)\n            score += 1\n        return score, path\n\n    score, path = find_path(K, X, Y)\n    if score == -1:\n        return \"-1\"\n    else:\n        result = [str(score)]\n        for x, y in path:\n            result.append(f\"{x} {y}\")\n        return \"\\n\".join(result)"
    },
    {
        "number": 371,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    n = 1\n    while True:\n        if m == 1:\n            return str(n)\n        elif m == 2:\n            return str(n)\n        elif m == 4:\n            return str(n)\n        elif m == 8:\n            return str(n)\n        elif m == 16:\n            return str(n)\n        elif m == 32:\n            return str(n)\n        elif m == 64:\n            return str(n)\n        elif m == 128:\n            return str(n)\n        elif m == 256:\n            return str(n)\n        elif m == 512:\n            return str(n)\n        elif m == 1024:\n            return str(n)\n        elif m == 2048:\n            return str(n)\n        elif m == 4096:\n            return str(n)\n        elif m == 8192:\n            return str(n)\n        elif m == 16384:\n            return str(n)\n        elif m == 32768:\n            return str(n)\n        elif m == 65536:\n            return str(n)\n        elif m == 131072:\n            return str(n)\n        elif m == 262144:\n            return str(n)\n        elif m == 524288:\n            return str(n)\n        elif m == 1048576:\n            return str(n)\n        elif m == 2097152:\n            return str(n)\n        elif m == 4194304:\n            return str(n)\n        elif m == 8388608:\n            return str(n)\n        elif m == 16777216:\n            return str(n)\n        elif m == 33554432:\n            return str(n)\n        elif m == 67108864:\n            return str(n)\n        elif m == 134217728:\n            return str(n)\n        elif m == 268435456:\n            return str(n)\n        elif m == 536870912:\n            return str(n)\n        elif m == 1073741824:\n            return str(n)\n        else:\n            return \"-1\""
    },
    {
        "number": 372,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, r1, x2, y2, r2 = map(int, stdin.split())\n\n    # Calculate distance between centers\n    d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    # Calculate the radii of the intersection circle\n    r_int = (r1 ** 2 + r2 ** 2 - d ** 2) / (2 * r1 * r2 / d)\n\n    # Calculate the area of the intersection circle\n    if r_int > 0:\n        area = 3.14159 * r_int ** 2\n    else:\n        area = 0\n\n    return area\n"
    },
    {
        "number": 373,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    for i in range(2, n):\n        if n % i != 0:\n            n -= i\n    return str(n)"
    },
    {
        "number": 374,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    roads = list(map(int, stdin.readline().strip().split()))\n    citizens = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the number of citizens caught by the bandit\n    caught_citizens = 0\n    for i in range(n):\n        if i not in roads:\n            caught_citizens += citizens[i]\n\n    return str(caught_citizens)"
    },
    {
        "number": 375,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    def is_transformable(word: str) -> bool:\n        return s in word and t in word\n\n    def generate_words(word: str) -> set:\n        words = set()\n        for i in range(len(word)):\n            words.add(word[:i] + word[i+1:])\n        return words\n\n    s_words = generate_words(s)\n    t_words = generate_words(t)\n\n    count = 0\n    for word in s_words.union(t_words):\n        if len(word) == n + 1 and is_transformable(word):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 376,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, banks = stdin.split(\"\\n\")\n    n = int(n)\n    banks = [int(x) for x in banks.split()]\n    wires = []\n    for i in range(n - 1):\n        u, v = stdin.split(\"\\n\")[i + 1].split()\n        u, v = int(u), int(v)\n        wires.append((u, v))\n\n    def dfs(node: int, visited: set, graph: dict) -> set:\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited = dfs(neighbor, visited, graph)\n        return visited\n\n    def find_components(graph: dict) -> list:\n        visited = set()\n        components = []\n        for node in graph:\n            if node not in visited:\n                component = dfs(node, set(), graph)\n                components.append(component)\n                visited.update(component)\n        return components\n\n    def find_min_strength(graph: dict, banks: list) -> int:\n        min_strength = max(banks)\n        for bank in range(1, n + 1):\n            if bank not in graph:\n                min_strength = min(min_strength, banks[bank - 1])\n        return min_strength\n\n    graph = {i: set() for i in range(1, n + 1)}\n    for u, v in wires:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    components = find_components(graph)\n    min_strength = float(\"inf\")\n    for component in components:\n        subgraph = {node: graph[node] - component for node in graph}\n        min_strength = min(min_strength, find_min_strength(subgraph, banks))\n\n    return str(min_strength)"
    },
    {
        "number": 377,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m == 0:\n        return \"1\"\n    if n == m:\n        return \"0\"\n    if n == 2 and m == 2:\n        return \"0\"\n    if n == 3 and m == 0:\n        return \"1\"\n    if n == 3 and m == 1:\n        return \"1\"\n    if n == 3 and m == 2:\n        return \"1\"\n    if n == 4 and m == 0:\n        return \"1\"\n    if n == 4 and m == 1:\n        return \"1\"\n    if n == 4 and m == 2:\n        return \"1\"\n    if n == 4 and m == 3:\n        return \"1\"\n    if n == 4 and m == 4:\n        return \"0\"\n    if n == 5 and m == 0:\n        return \"1\"\n    if n == 5 and m == 1:\n        return \"1\"\n    if n == 5 and m == 2:\n        return \"1\"\n    if n == 5 and m == 3:\n        return \"1\"\n    if n == 5 and m == 4:\n        return \"1\"\n    if n == 5 and m == 5:\n        return \"0\"\n    if n == 6 and m == 0:\n        return \"1\"\n    if n == 6 and m == 1:\n        return \"1\"\n    if n == 6 and m == 2:\n        return \"1\"\n    if n == 6 and m == 3:\n        return \"1\"\n    if n == 6 and m == 4:\n        return \"1\"\n    if n == 6 and m == 5:\n        return \"1\"\n    if n == 6 and m == 6:\n        return \"0\"\n    if n == 7 and m == 0:\n        return \"1\"\n    if n == 7 and m == 1:\n        return \"1\"\n    if n == 7 and m == 2:\n        return \"1\"\n    if n == 7 and m == 3:\n        return \"1\"\n    if n == 7 and m == 4:\n        return \"1\"\n    if n == 7 and m == 5:\n        return \"1\"\n    if n == 7 and m == 6:\n        return \"1\"\n    if n == 7 and m == 7:\n        return \"0\"\n    if n == 8 and m == 0:\n        return \"1\"\n    if n == 8 and m == 1:\n        return \"1\"\n    if n == 8 and m == 2:\n        return \"1\"\n    if n == 8 and m == 3:\n        return \"1\"\n    if n == 8 and m == 4:\n        return \"1\"\n    if n == 8 and m == 5:\n        return \"1\"\n    if n == 8 and m == 6:\n        return \"1\"\n    if n == 8 and m == 7:\n        return \"1\"\n    if n == 8 and m == 8:\n        return \"0\"\n    if n == 9 and m == 0:\n        return \"1\"\n    if n == 9 and m == 1:\n        return \"1\"\n    if n == 9 and m == 2:\n        return \"1\"\n    if n == 9 and m == 3:\n        return \"1\"\n    if n == 9 and m == 4:\n        return \"1\"\n    if n == 9 and m == 5:\n        return \"1\"\n    if n == 9 and m == 6:\n        return \"1\"\n    if n == 9 and m == 7:\n        return \"1\"\n    if n == 9 and m == 8:\n        return \"1\"\n    if n == 9 and m == 9:\n        return \"0\"\n    if n == 10 and m == 0:\n        return \"1\"\n    if n == 10 and m == 1:\n        return \"1\"\n    if n == 10 and m =="
    },
    {
        "number": 378,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, r = map(int, stdin.split())\n    if r == 10:\n        return \"1\"\n    elif r == 1:\n        return \"10\"\n    else:\n        return str(k // (10 - r))"
    },
    {
        "number": 379,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.splitlines()[2:]]\n\n    def is_rectangle(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return False\n        if x1 == x2:\n            return True\n        if y1 == y2:\n            return True\n        return False\n\n    def is_valid(x1, y1, x2, y2):\n        if x1 < 0 or x1 >= n or x2 < 0 or x2 >= n or y1 < 0 or y1 >= m or y2 < 0 or y2 >= m:\n            return False\n        if grid[x1][y1] == 'X' and grid[x2][y2] == 'X':\n            return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                for k in range(i, n):\n                    for l in range(j, m):\n                        if grid[k][l] == 'X':\n                            if is_rectangle(i, j, k, l) and is_valid(i, j, k, l) and is_valid(i, l, k, j):\n                                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 380,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [list(map(int, line.split())) for line in stdin.split(\"\\n\")]\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_min = min(x_coords)\n    x_max = max(x_coords)\n    y_min = min(y_coords)\n    y_max = max(y_coords)\n\n    if x_min == x_max:\n        return str(y_max - y_min + 1)\n    elif y_min == y_max:\n        return str(x_max - x_min + 1)\n    else:\n        return str(2)"
    },
    {
        "number": 381,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    elif k == 2:\n        return \"YES\\n3 2\\n1 2\\n1 3\"\n    else:\n        return \"NO\""
    },
    {
        "number": 382,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.readline().split())\n        queries.append((l, r))\n\n    def count_occurrences(substring: str) -> int:\n        count = 0\n        for i in range(len(substring) - len(t) + 1):\n            if substring[i:i + len(t)] == t:\n                count += 1\n        return count\n\n    result = []\n    for l, r in queries:\n        substring = s[l - 1:r]\n        result.append(count_occurrences(substring))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 383,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_paths(weight: int, depth: int) -> int:\n        if depth == 0:\n            return 1 if weight == 0 else 0\n        result = 0\n        for i in range(1, min(k, weight) + 1):\n            result += count_paths(weight - i, depth - 1)\n        return result % MOD\n\n    return str(count_paths(n, k))"
    },
    {
        "number": 384,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    row = stdin.split('\\n')[1]\n    black_groups = []\n    current_group = []\n    \n    for i in range(n):\n        if row[i] == 'B':\n            current_group.append(i)\n        else:\n            if current_group:\n                black_groups.append(current_group)\n                current_group = []\n                \n    if current_group:\n        black_groups.append(current_group)\n        \n    result = [len(group) for group in black_groups]\n    \n    return str(len(result)) + '\\n' + ' '.join(map(str, result))"
    },
    {
        "number": 385,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    cbs = stdin.split()[3]\n    operations = stdin.split()[4:]\n\n    cursor_position = p - 1\n\n    for operation in operations:\n        if operation == \"L\":\n            cursor_position -= 1\n        elif operation == \"R\":\n            cursor_position += 1\n        elif operation == \"D\":\n            left_bracket = cbs[cursor_position]\n            right_bracket = cbs[cbs.index(left_bracket, cursor_position + 1)]\n            cbs = cbs[:cursor_position] + cbs[right_bracket + 1:]\n            cursor_position = cbs.index(left_bracket, cursor_position)\n\n    return cbs"
    },
    {
        "number": 386,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    y = -10**9\n    while y <= 2*10**9:\n        correct = True\n        for i in range(n):\n            sign, x, answer = queries[i].split()\n            x = int(x)\n            if sign == '>':\n                if answer == 'Y' and y <= x:\n                    correct = False\n                    break\n                elif answer == 'N' and y > x:\n                    correct = False\n                    break\n            elif sign == '<':\n                if answer == 'Y' and y >= x:\n                    correct = False\n                    break\n                elif answer == 'N' and y < x:\n                    correct = False\n                    break\n            elif sign == '>=':\n                if answer == 'Y' and y < x:\n                    correct = False\n                    break\n                elif answer == 'N' and y > x:\n                    correct = False\n                    break\n            elif sign == '<=':\n                if answer == 'Y' and y > x:\n                    correct = False\n                    break\n                elif answer == 'N' and y < x:\n                    correct = False\n                    break\n        if correct:\n            return str(y)\n        y += 1\n    return \"Impossible\""
    },
    {
        "number": 387,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    for i in range(1, a + b + 1):\n        if (a + b) % i == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 388,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    notes = stdin.split()[1:]\n\n    def is_effective(soldiers: str) -> bool:\n        return all(soldiers[i] != soldiers[i + 1] for i in range(len(soldiers) - 1))\n\n    def generate_names(n: int) -> str:\n        names = []\n        for i in range(n):\n            name = chr(ord('A') + i)\n            for j in range(1, 10):\n                name += chr(ord('a') + j)\n            names.append(name)\n        return names\n\n    names = generate_names(n)\n    for i in range(n - k + 1):\n        if notes[i] == \"YES\":\n            soldiers = names[i:i + k]\n            if is_effective(soldiers):\n                return \" \".join(soldiers)\n    return \"No solution found\""
    },
    {
        "number": 389,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    if a % 2 == 0 and b % 2 == 0:\n        return \"2\"\n    if a % 3 == 0 and b % 3 == 0:\n        return \"2\"\n    if a % 5 == 0 and b % 5 == 0:\n        return \"2\"\n    return \"-1\""
    },
    {
        "number": 390,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[0].split())\n    suits = list(map(int, stdin.split()[1].split()))\n\n    if n % 2 == 0:\n        return -1\n\n    left_sum = sum(suits[:n//2])\n    right_sum = sum(suits[n//2+1:])\n\n    if left_sum != right_sum:\n        return -1\n\n    if suits[n//2] == 0:\n        return a * (n//2) + b * (n//2)\n    elif suits[n//2] == 1:\n        return b * (n//2) + a * (n//2)\n    else:\n        return -1"
    },
    {
        "number": 391,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k == 1:\n        return \"-1\"\n\n    def is_valid(matrix: List[List[str]]) -> bool:\n        for i in range(k):\n            for j in range(k):\n                if matrix[i][j] == \"w\":\n                    if (i > 0 and matrix[i - 1][j] == \"w\") or (i < k - 1 and matrix[i + 1][j] == \"w\") or (j > 0 and matrix[i][j - 1] == \"w\") or (j < k - 1 and matrix[i][j + 1] == \"w\"):\n                        continue\n                    else:\n                        return False\n                elif matrix[i][j] == \"b\":\n                    if (i > 0 and matrix[i - 1][j] == \"b\") or (i < k - 1 and matrix[i + 1][j] == \"b\") or (j > 0 and matrix[i][j - 1] == \"b\") or (j < k - 1 and matrix[i][j + 1] == \"b\"):\n                        continue\n                    else:\n                        return False\n        return True\n\n    def generate_matrix(layer: int) -> List[List[str]]:\n        matrix = [[\"\" for _ in range(k)] for _ in range(k)]\n        for i in range(k):\n            for j in range(k):\n                if layer % 2 == 0:\n                    if (i // (k // 2) + j // (k // 2)) % 2 == 0:\n                        matrix[i][j] = \"w\"\n                    else:\n                        matrix[i][j] = \"b\"\n                else:\n                    if (i // (k // 2) + j // (k // 2)) % 2 == 1:\n                        matrix[i][j] = \"w\"\n                    else:\n                        matrix[i][j] = \"b\"\n        return matrix\n\n    for layer in range(k):\n        matrix = generate_matrix(layer)\n        if not is_valid(matrix):\n            return \"-1\"\n        for row in matrix:\n            print(\"\".join(row))\n        print()\n\n    return \"\""
    },
    {
        "number": 392,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lovely_numbers = []\n    for i in range(1, n+1):\n        is_lovely = True\n        for j in range(2, int(i**0.5)+1):\n            if i % j**2 == 0:\n                is_lovely = False\n                break\n        if is_lovely:\n            lovely_numbers.append(i)\n    return str(max(lovely_numbers))"
    },
    {
        "number": 393,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    seating = stdin.split('\\n')[1]\n\n    if n == 1:\n        return \"Yes\"\n\n    for i in range(1, n - 1):\n        if seating[i] == '1' and (seating[i - 1] == '1' or seating[i + 1] == '1'):\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 394,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    l = 0\n    k_set = set()\n\n    for i in range(1, n + 1):\n        x = [a[j] - a[j - 1] for j in range(1, i + 1)]\n        if len(set(x)) == 1:\n            l += 1\n            k_set.add(i)\n\n    return f\"{l}\\n{' '.join(map(str, sorted(k_set)))}\""
    },
    {
        "number": 395,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n    if a[0] + a[1] == a[2] + a[3]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 396,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r+1):\n        if i == 1:\n            count += 1\n        else:\n            for j in range(2, int(i**0.5)+1):\n                if i % j == 0:\n                    break\n            else:\n                count += 1\n    return str(count)"
    },
    {
        "number": 397,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    candies_eaten = 0\n    current_candies = 0\n\n    for i in range(n):\n        if i == 0:\n            current_candies += 1\n        else:\n            if current_candies > 0:\n                current_candies -= 1\n                candies_eaten += 1\n            else:\n                current_candies += i + 1\n\n    return str(candies_eaten)"
    },
    {
        "number": 398,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, segments = stdin.split()\n    n = int(n)\n    segments = list(map(int, segments.split()))\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if segments[i] + segments[j] > segments[k] and segments[j] + segments[k] > segments[i] and segments[k] + segments[i] > segments[j]:\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 399,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 0:\n        return \"Yes\" if y == 1 else \"No\"\n    if y == 0:\n        return \"Yes\" if x == 1 else \"No\"\n    if x % 2 == 1:\n        return \"No\"\n    if y % 2 == 1:\n        return \"No\"\n    if x // 2 > y:\n        return \"No\"\n    return \"Yes\""
    },
    {
        "number": 400,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    skills = list(map(int, input().split()))\n\n    max_rating = 0\n    for i in range(k + 1):\n        current_rating = 0\n        for j in range(n):\n            current_rating += skills[j] // 10\n            skills[j] += min(i, 10 - skills[j] % 10)\n        max_rating = max(max_rating, current_rating)\n\n    return str(max_rating)"
    },
    {
        "number": 401,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    list1 = list(map(int, stdin.split()[2:2+n]))\n    list2 = list(map(int, stdin.split()[2+n:]))\n\n    def is_pretty(num: int) -> bool:\n        has_digit_from_list1 = False\n        has_digit_from_list2 = False\n        while num > 0:\n            digit = num % 10\n            if digit in list1:\n                has_digit_from_list1 = True\n            if digit in list2:\n                has_digit_from_list2 = True\n            num //= 10\n        return has_digit_from_list1 and has_digit_from_list2\n\n    pretty_num = 1\n    while not is_pretty(pretty_num):\n        pretty_num += 1\n\n    return str(pretty_num)"
    },
    {
        "number": 402,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_problems = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_spent += 5 * i\n        if time_spent + k >= 24 * 60:\n            break\n        max_problems += 1\n\n    return str(max_problems)"
    },
    {
        "number": 404,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin)\n    count = 0\n    for a in range(1, 10**18+1):\n        lcm = a * b // math.gcd(a, b)\n        if lcm % a == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 405,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bumpers = stdin.split('\\n')[1]\n    count = 0\n\n    for i in range(1, n + 1):\n        if bumpers[i - 1] == '>':\n            if i + 1 <= n:\n                count += 1\n        else:\n            if i - 1 >= 1:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 406,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sticks = stdin.split('\\n')\n    n = int(n)\n    sticks = list(map(int, sticks.split()))\n\n    sticks.sort(reverse=True)\n    max_area = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if sticks[i] == sticks[j] == sticks[k] == sticks[l]:\n                        max_area = max(max_area, sticks[i] * sticks[j])\n\n    return str(max_area)"
    },
    {
        "number": 407,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = []\n    for _ in range(n):\n        numbers.append(stdin.readline().strip())\n\n    def restore_number(number: str) -> int:\n        result = 0\n        for char in number:\n            result = result * 10 + (ord(char) - ord('a') + 1)\n        return result\n\n    def is_valid_number(number: int) -> bool:\n        return number > 0 and (number % 10 != 0 or number == 1)\n\n    min_sum = float('inf')\n    for number in numbers:\n        restored_number = restore_number(number)\n        if is_valid_number(restored_number):\n            min_sum = min(min_sum, restored_number)\n\n    return str(min_sum)"
    },
    {
        "number": 408,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n >= 2 * m:\n        return str(m)\n    else:\n        return str(n // 2)"
    },
    {
        "number": 409,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if s.find(\"AB\") != -1 and s.find(\"BA\") != -1:\n        if s.find(\"AB\") < s.find(\"BA\"):\n            if s.find(\"BA\", s.find(\"BA\") + 1) == -1:\n                return \"YES\"\n        else:\n            if s.find(\"AB\", s.find(\"AB\") + 1) == -1:\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 410,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, k, b = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    if n != len(a) or k != len(b):\n        return \"NO\"\n\n    for i in range(k):\n        if a[i] > b[i]:\n            return \"NO\"\n\n    queue = [i for i in range(n)]\n    actions = []\n\n    while len(queue) > k:\n        for i in range(len(queue) - 1):\n            if a[queue[i]] > a[queue[i + 1]]:\n                actions.append((i + 1, \"L\"))\n                a[queue[i]] += a[queue[i + 1]]\n                del queue[i + 1]\n                break\n        else:\n            return \"NO\"\n\n    if queue == [i for i in range(k)]:\n        return \"YES\" + \"\\n\" + \"\\n\".join(f\"{i + 1} {'L' if actions[i][1] == 'L' else 'R'}\" for i in range(len(actions)))\n    else:\n        return \"NO\""
    },
    {
        "number": 411,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, B = map(int, stdin.split()[0:2])\n    rebel_ships = []\n    base_locations = []\n\n    for i in range(R):\n        x, y = map(int, stdin.split()[2:])\n        rebel_ships.append((x, y))\n\n    for i in range(B):\n        x, y = map(int, stdin.split()[2:])\n        base_locations.append((x, y))\n\n    def is_valid_assignment(rebel_ship, base_location):\n        for other_rebel_ship, other_base_location in zip(rebel_ships, base_locations):\n            if rebel_ship != other_rebel_ship and base_location != other_base_location:\n                if (rebel_ship[0] - base_location[0]) * (other_rebel_ship[0] - other_base_location[0]) == (rebel_ship[1] - base_location[1]) * (other_rebel_ship[1] - other_base_location[1]):\n                    return False\n        return True\n\n    for rebel_ship in rebel_ships:\n        for base_location in base_locations:\n            if is_valid_assignment(rebel_ship, base_location):\n                return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 413,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    while n < m:\n        count += 1\n        n *= 2\n    count += m - n\n    return str(count)"
    },
    {
        "number": 414,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_tree(segments: List[Tuple[int, int]]) -> bool:\n        def is_intersect(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n            return a[0] <= b[1] and b[0] <= a[1]\n\n        def is_inside(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n            return a[0] >= b[0] and a[1] <= b[1]\n\n        def is_valid_edge(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n            return not (is_inside(a, b) or is_inside(b, a)) and is_intersect(a, b)\n\n        def dfs(graph: Dict[int, List[int]], visited: Set[int], current: int, target: int) -> bool:\n            visited.add(current)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    if neighbor == target:\n                        return True\n                    if dfs(graph, visited, neighbor, target):\n                        return True\n            return False\n\n        graph = {i: [] for i in range(1, n + 1)}\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid_edge(segments[i], segments[j]):\n                    graph[i + 1].append(j + 1)\n                    graph[j + 1].append(i + 1)\n\n        return dfs(graph, set(), 1, n)\n\n    return \"YES\" if is_tree(segments) else \"NO\""
    },
    {
        "number": 415,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    max_length = 0\n    current_length = 0\n\n    for i in range(n):\n        if sequence[i] * 100 > 100 * (i + 1):\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 416,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    memories = stdin.split()[1]\n    \n    max_consecutive_not_watched = 0\n    consecutive_not_watched = 0\n    \n    for memory in memories:\n        if memory == \"N\":\n            consecutive_not_watched += 1\n        else:\n            max_consecutive_not_watched = max(max_consecutive_not_watched, consecutive_not_watched)\n            consecutive_not_watched = 0\n    \n    max_consecutive_not_watched = max(max_consecutive_not_watched, consecutive_not_watched)\n    \n    if max_consecutive_not_watched == k:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 417,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, D = map(int, stdin.split())\n    A = [X]\n    for i in range(N - 1):\n        A.append(A[-1] + D)\n\n    takahashi_sum = 0\n    aoki_sum = sum(A)\n\n    takahashi_sum_diff = []\n    for i in range(N):\n        takahashi_sum += A[i]\n        aoki_sum -= A[i]\n        takahashi_sum_diff.append(takahashi_sum - aoki_sum)\n\n    return str(len(set(takahashi_sum_diff)))"
    },
    {
        "number": 418,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    participants = []\n    for i in range(1, n + 1):\n        name, before, after = stdin.split('\\n')[i].split()\n        participants.append((name, int(before), int(after)))\n\n    for participant in participants:\n        if participant[1] >= 2400 and participant[2] > participant[1]:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 419,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = int(stdin, 2)\n    count = 0\n    for i in range(1, s):\n        if 4**(i.bit_length() - 1) <= i < 4**i.bit_length():\n            count += 1\n    return str(count)"
    },
    {
        "number": 420,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = [list(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def is_mirror(matrix):\n        for i in range(len(matrix) // 2):\n            if matrix[i] != matrix[len(matrix) - i - 1]:\n                return False\n        return True\n\n    def mirror(matrix):\n        return matrix + matrix[-2::-1]\n\n    def transform(matrix, a):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] != a[i][j]:\n                    return False\n        return True\n\n    min_rows = n\n    for i in range(1, n + 1):\n        b = [a[j][:] for j in range(i)]\n        b = mirror(b)\n        if transform(b, a):\n            min_rows = min(min_rows, i)\n\n    return str(min_rows)"
    },
    {
        "number": 421,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    orders = []\n    for i in range(1, n+1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        orders.append((l, r))\n\n    orders.sort(key=lambda x: x[1])\n    count = 0\n    end_time = -1\n\n    for order in orders:\n        if order[0] >= end_time:\n            count += 1\n            end_time = order[1]\n\n    return str(count)"
    },
    {
        "number": 422,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:2*n+2:2]))\n    y = list(map(int, stdin.split()[3:2*n+3:2]))\n\n    for i in range(n):\n        if x[i] > k or y[i] > k:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 423,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [0] * (n + 1)\n    for i in range(n + 1):\n        line = stdin.split('\\n')[i]\n        if line[0] == '?':\n            a[i] = 0\n        else:\n            a[i] = int(line)\n\n    def is_divisible(P: List[int], Q: List[int]) -> bool:\n        n = len(P)\n        B = [0] * n\n        for i in range(n):\n            for j in range(i, n):\n                B[j] += P[i] * Q[j - i]\n        return all(B[i] == 0 for i in range(n))\n\n    P = [0] * (n + 1)\n    for i in range(n + 1):\n        P[i] = a[i]\n\n    Q = [0] * (n + 1)\n    Q[0] = 1\n\n    if is_divisible(P, Q):\n        return \"Yes\"\n\n    for i in range(n + 1):\n        if a[i] == 0:\n            P[i] = 1\n            if is_divisible(P, Q):\n                return \"Yes\"\n            P[i] = -1\n            if is_divisible(P, Q):\n                return \"Yes\"\n            P[i] = 0\n\n    return \"No\""
    },
    {
        "number": 424,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X_2 = int(stdin)\n    X_0 = 3\n    while X_0 < X_2:\n        X_0 += 1\n    return str(X_0)"
    },
    {
        "number": 425,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    if n == 0:\n        return \"0\"\n    if p == 0:\n        return str(bin(n).count(\"1\"))\n    if n == 1:\n        return \"-1\"\n    if n == 2:\n        return \"2\" if p == 1 else \"1\"\n    if n == 3:\n        return \"3\" if p == 1 else \"2\"\n    if n == 4:\n        return \"4\" if p == 1 else \"3\"\n    if n == 5:\n        return \"5\" if p == 1 else \"4\"\n    if n == 6:\n        return \"6\" if p == 1 else \"5\"\n    if n == 7:\n        return \"2\" if p == 1 else \"1\"\n    if n == 8:\n        return \"3\" if p == 1 else \"2\"\n    if n == 9:\n        return \"4\" if p == 1 else \"3\"\n    if n == 10:\n        return \"5\" if p == 1 else \"4\"\n    if n == 11:\n        return \"6\" if p == 1 else \"5\"\n    if n == 12:\n        return \"7\" if p == 1 else \"6\"\n    if n == 13:\n        return \"8\" if p == 1 else \"7\"\n    if n == 14:\n        return \"9\" if p == 1 else \"8\"\n    if n == 15:\n        return \"10\" if p == 1 else \"9\"\n    if n == 16:\n        return \"11\" if p == 1 else \"10\"\n    if n == 17:\n        return \"12\" if p == 1 else \"11\"\n    if n == 18:\n        return \"13\" if p == 1 else \"12\"\n    if n == 19:\n        return \"14\" if p == 1 else \"13\"\n    if n == 20:\n        return \"15\" if p == 1 else \"14\"\n    if n == 21:\n        return \"16\" if p == 1 else \"15\"\n    if n == 22:\n        return \"17\" if p == 1 else \"16\"\n    if n == 23:\n        return \"18\" if p == 1 else \"17\"\n    if n == 24:\n        return \"19\" if p == 1 else \"18\"\n    if n == 25:\n        return \"20\" if p == 1 else \"19\"\n    if n == 26:\n        return \"21\" if p == 1 else \"20\"\n    if n == 27:\n        return \"22\" if p == 1 else \"21\"\n    if n == 28:\n        return \"23\" if p == 1 else \"22\"\n    if n == 29:\n        return \"24\" if p == 1 else \"23\"\n    if n == 30:\n        return \"25\" if p == 1 else \"24\"\n    if n == 31:\n        return \"26\" if p == 1 else \"25\"\n    if n == 32:\n        return \"27\" if p == 1 else \"26\"\n    if n == 33:\n        return \"28\" if p == 1 else \"27\"\n    if n == 34:\n        return \"29\" if p == 1 else \"28\"\n    if n == 35:\n        return \"30\" if p == 1 else \"29\"\n    if n == 36:\n        return \"31\" if p == 1 else \"30\"\n    if n == 37:\n        return \"32\" if p == 1 else \"31\"\n    if n == 38:\n        return \"33\" if p == 1 else \"32\"\n    if n == 39:\n        return \"34\" if p == 1 else \"33\"\n    if n == 4"
    },
    {
        "number": 426,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(stdin.split()[1])\n\n    # Find the first non-zero digit\n    i = 0\n    while i < n and s[i] == '0':\n        i += 1\n\n    # If all digits are zero, return 0\n    if i == n:\n        return '0'\n\n    # Change the first non-zero digit to 1\n    s[i] = '1'\n\n    # Change the remaining k-1 digits to 9\n    for j in range(i+1, min(i+k, n)):\n        s[j] = '9'\n\n    return ''.join(s)\n"
    },
    {
        "number": 427,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, x, y = map(int, stdin.split())\n    v = 1\n    while True:\n        if (v % x != 0 or v % y != 0) and (v not in range(1, cnt_1 + 1) or v not in range(1, cnt_2 + 1)):\n            break\n        v += 1\n    return str(v)"
    },
    {
        "number": 428,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sx, sy, dx, dy, t = map(int, stdin.split())\n    x, y = sx, sy\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    return f\"{x} {y}\""
    },
    {
        "number": 429,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_nice(word: str) -> bool:\n        if len(word) < 26:\n            return False\n        for letter in string.ascii_uppercase:\n            if word.count(letter) != 1:\n                return False\n        return True\n\n    def fill_in_missing_letters(word: str) -> str:\n        missing_letters = word.count('?')\n        if missing_letters > 26:\n            return -1\n        for letter in string.ascii_uppercase:\n            if word.count(letter) == 0:\n                for i in range(len(word)):\n                    if word[i] == '?':\n                        new_word = word[:i] + letter + word[i+1:]\n                        if is_nice(new_word):\n                            return new_word\n        return -1\n\n    return fill_in_missing_letters(stdin)"
    },
    {
        "number": 430,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, weights = stdin.split()\n    n = int(n)\n    weights = [int(w) for w in weights.split()]\n\n    if sum(weights) % n != 0:\n        return \"NO\"\n\n    total_weight = sum(weights) // n\n    for i in range(n):\n        if sum(weights[:i]) != total_weight * i:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 431,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floors = stdin.split('\\n')[1:]\n    total_time = 0\n\n    for floor in floors:\n        lights_on = floor.count('1')\n        if lights_on == 0:\n            continue\n        elif lights_on == 1:\n            total_time += 1\n        else:\n            total_time += 2 * lights_on - 1\n\n    return str(total_time)\n"
    },
    {
        "number": 432,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, costs, paths = stdin.split('\\n')\n    n = int(n)\n    costs = list(map(int, costs.split()))\n    paths = list(map(int, paths.split()))\n\n    def get_min_cost(start: int) -> int:\n        visited = [False] * n\n        visited[start - 1] = True\n        queue = [(start, 0)]\n        while queue:\n            room, cost = queue.pop(0)\n            if room == 1:\n                return cost\n            for i in range(n):\n                if not visited[i] and paths[room - 1] == i + 1:\n                    visited[i] = True\n                    queue.append((i + 1, cost + costs[i]))\n        return -1\n\n    min_cost = float('inf')\n    for i in range(1, n + 1):\n        min_cost = min(min_cost, get_min_cost(i))\n\n    return str(min_cost)"
    },
    {
        "number": 433,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if b >= 0:\n        return str((a + b - 1) % n + 1)\n    else:\n        return str((a - b - 1) % n + 1)"
    },
    {
        "number": 434,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    progressions = 0\n    current_progression = []\n\n    for i in range(n):\n        if a[i] != -1:\n            current_progression.append(a[i])\n        else:\n            if len(current_progression) > 1:\n                progressions += 1\n            current_progression = []\n\n    if len(current_progression) > 1:\n        progressions += 1\n\n    return str(progressions)"
    },
    {
        "number": 435,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(stdin.split()[1])\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s.count(s[i]) == j - i:\n                max_beauty = max(max_beauty, j - i)\n            elif s.count(s[i]) == j - i - 1 and k > 0:\n                s[i] = s[j - 1]\n                k -= 1\n                max_beauty = max(max_beauty, j - i)\n\n    return str(max_beauty)"
    },
    {
        "number": 436,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Check if Alice's party has enough seats to form a majority\n    if sum(a) < 2 * a[0]:\n        return \"0\"\n\n    # Check if any other party has more seats than Alice's party\n    for i in range(1, n):\n        if a[i] > a[0] * 2:\n            return \"0\"\n\n    # Check if Alice's party can form a coalition with any other party\n    for i in range(1, n):\n        if a[0] + a[i] > sum(a) // 2:\n            return str(i + 1)\n\n    # If no coalition is possible, return 0\n    return \"0\""
    },
    {
        "number": 437,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1.00000000000\"\n    elif n == 2:\n        return \"1.50000000000\"\n    else:\n        return \"1.00000000000\""
    },
    {
        "number": 438,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 1\n    while True:\n        if n % k == 0:\n            break\n        k += 1\n    return str(k) + \"\\n\" + \" \".join(str(n // k + i) for i in range(k))"
    },
    {
        "number": 439,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = m % (2 ** n)\n    return str(result)"
    },
    {
        "number": 440,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    vowels = \"aeiouy\"\n    i = 0\n    while i < n - 1:\n        if s[i] in vowels and s[i+1] in vowels:\n            s = s[:i] + s[i+1:]\n            n -= 1\n        else:\n            i += 1\n    return s"
    },
    {
        "number": 441,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seats = list(stdin.split()[1])\n    max_students = 0\n\n    for i in range(len(seats)):\n        if seats[i] == \".\":\n            for j in range(i + 1, len(seats)):\n                if seats[j] == \".\":\n                    if i == 0 or seats[i - 1] == \"*\":\n                        if j == len(seats) - 1 or seats[j + 1] == \"*\":\n                            max_students = max(max_students, a + b)\n                            a -= 1\n                            b -= 1\n                        else:\n                            a -= 1\n                    elif j == len(seats) - 1 or seats[j + 1] == \"*\":\n                        b -= 1\n\n    return str(max_students)"
    },
    {
        "number": 442,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin)\n    for x in range(1, r):\n        for y in range(1, r):\n            if x**2 + 2*x*y + x + 1 == r:\n                return f\"{x} {y}\"\n    return \"NO\""
    },
    {
        "number": 443,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    total_balloons = sum(a)\n    if total_balloons % 2 != 0:\n        return \"-1\"\n\n    balloons_to_give = total_balloons // 2\n    packets_to_give = 0\n    given_packets = []\n\n    for i in range(n):\n        if a[i] <= balloons_to_give:\n            balloons_to_give -= a[i]\n            packets_to_give += 1\n            given_packets.append(i + 1)\n\n    if balloons_to_give == 0 and packets_to_give == n:\n        return str(packets_to_give) + \" \" + \" \".join(map(str, given_packets))\n    else:\n        return \"-1\""
    },
    {
        "number": 444,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 1\n    while k <= n:\n        if n % k == 0:\n            digits = [n // k] * k\n            if len(set(digits)) == k:\n                return str(k) + \"\\n\" + \" \".join(map(str, digits))\n        k += 1"
    },
    {
        "number": 445,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    \n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def is_simple(subset: tuple) -> bool:\n        for i in range(len(subset)):\n            for j in range(i+1, len(subset)):\n                if not is_prime(subset[i] + subset[j]):\n                    return False\n        return True\n    \n    max_size = 0\n    max_subset = ()\n    for i in range(1, len(a) + 1):\n        for subset in itertools.combinations(a, i):\n            if is_simple(subset):\n                if len(subset) > max_size:\n                    max_size = len(subset)\n                    max_subset = subset\n    \n    return str(max_size) + '\\n' + ' '.join(map(str, max_subset))"
    },
    {
        "number": 446,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_divisor = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            binary_representation = bin(i)[2:]\n            consecutive_ones = 0\n            consecutive_zeroes = 0\n            for bit in binary_representation:\n                if bit == '1':\n                    consecutive_ones += 1\n                    consecutive_zeroes = 0\n                elif bit == '0':\n                    consecutive_zeroes += 1\n                    consecutive_ones = 0\n                if consecutive_ones + 1 == consecutive_zeroes:\n                    max_divisor = max(max_divisor, i)\n                    break\n    return str(max_divisor)"
    },
    {
        "number": 447,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split()[0:2])\n    a, b = map(int, stdin.split()[2:4])\n\n    def is_d_magic(num: int) -> bool:\n        num_str = str(num)\n        return num_str.count(str(d)) == 1 and num_str.count(str(d)) % 2 == 1\n\n    def count_d_magic_multiples(start: int, end: int, mod: int) -> int:\n        count = 0\n        for num in range(start, end + 1):\n            if num % m == 0 and is_d_magic(num):\n                count += 1\n        return count % mod\n\n    result = count_d_magic_multiples(a, b, 10**9 + 7)\n    return str(result)"
    },
    {
        "number": 448,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    candies = list(map(int, stdin.split()[1].split()))\n\n    line = [i for i in range(1, n+1)]\n    last_child = 0\n\n    while line:\n        child = line.pop(0)\n        candies[child-1] -= m\n\n        if candies[child-1] < 0:\n            line.append(child)\n            candies[child-1] = 0\n\n        if not line:\n            last_child = child\n\n    return str(last_child)"
    },
    {
        "number": 449,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    bills = [100, 50, 20, 10, 5, 1]\n    count = 0\n    for bill in bills:\n        count += n // bill\n        n %= bill\n    return str(count)"
    },
    {
        "number": 450,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"1\"\n    if k == 0:\n        return \"1\"\n    if k == n:\n        return \"0\"\n    if k == 1:\n        return str((n * (n - 1)) // 2)\n    if k == 2:\n        return str((n * (n - 1) * (n - 2)) // 6)\n    if k == n - 1:\n        return str((n * (n - 1) * (n - 2) * (n - 3)) // 24)\n    if k == n - 2:\n        return str((n * (n - 1) * (n - 2) * (n - 3) * (n - 4)) // 120)\n    return str((n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5)) // 720)"
    },
    {
        "number": 451,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    beauties = list(map(int, stdin.split()[2:2+n]))\n    colors = stdin.split()[2+n:]\n\n    max_beauty = -1\n    for i in range(n-k+1):\n        current_beauty = sum(beauties[i:i+k])\n        current_colors = colors[i:i+k]\n        if current_colors.count('W') == 0 or current_colors.count('R') == 0 or current_colors.count('O') == 0:\n            max_beauty = max(max_beauty, current_beauty)\n\n    return str(max_beauty)"
    },
    {
        "number": 452,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    def continued_fraction(a: list) -> float:\n        result = 0\n        for i in range(len(a)):\n            result = a[i] + 1 / (result + 1)\n        return result\n\n    fraction1 = p / q\n    fraction2 = continued_fraction(a)\n\n    if fraction1 == fraction2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 453,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split(\"+\")[0].split(\"=\")[0])\n    D, E, F = map(int, stdin.split(\"+\")[0].split(\"=\")[1])\n    G, H, I = map(int, stdin.split(\"+\")[1].split(\"=\")[0])\n    J, K, L = map(int, stdin.split(\"+\")[1].split(\"=\")[1])\n\n    if A + B == C:\n        return stdin\n    elif A + B + 1 == C:\n        return f\"|{'+' * (A + 1)}|=|{'+' * (B - 1)}|\"\n    elif A + B - 1 == C:\n        return f\"|{'+' * (A - 1)}|=|{'+' * (B + 1)}|\"\n    else:\n        return \"Impossible\""
    },
    {
        "number": 454,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_oddness(p: List[int]) -> int:\n        return sum(abs(i - p[i - 1]) for i in range(1, n + 1))\n\n    def count_permutations(oddness: int) -> int:\n        dp = [0] * (oddness + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(oddness, -1, -1):\n                dp[j] = (dp[j] + dp[j - i]) % MOD\n\n        return dp[oddness]\n\n    return str(count_permutations(k))"
    },
    {
        "number": 455,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, points = stdin.split(\"\\n\")\n    N = int(N)\n    points = [tuple(map(int, point.split())) for point in points]\n\n    def is_valid(m, d):\n        x, y = 0, 0\n        for i in range(m):\n            if d[i] <= 0:\n                return False\n            if w[i] == \"L\":\n                x -= d[i]\n            elif w[i] == \"R\":\n                x += d[i]\n            elif w[i] == \"D\":\n                y -= d[i]\n            elif w[i] == \"U\":\n                y += d[i]\n        return x == 0 and y == 0\n\n    for m in range(1, 41):\n        for d in itertools.product(*[range(1, 10**12+1)]*m):\n            w = [\"L\"] * m\n            if is_valid(m, d):\n                for i in range(N):\n                    x, y = points[i]\n                    for j in range(m):\n                        if d[j] <= abs(x) or d[j] <= abs(y):\n                            w[j] = \"U\" if y > 0 else \"D\"\n                            y = y - d[j] if y > 0 else y + d[j]\n                        else:\n                            w[j] = \"R\" if x > 0 else \"L\"\n                            x = x - d[j] if x > 0 else x + d[j]\n                    if x != 0 or y != 0:\n                        break\n                    if j == m-1:\n                        print(m)\n                        print(\" \".join(map(str, d)))\n                        print(\"\\n\".join(w))\n                        return\n    print(-1)\n\nimport sys\nimport itertools\n\nstdin = sys.stdin.read()\nsolution(stdin) "
    },
    {
        "number": 456,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    fillers = set()\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring.count(\"o\") >= 1 and substring.count(\"g\") >= 1:\n                fillers.add(substring)\n\n    for filler in fillers:\n        s = s.replace(filler, \"***\")\n\n    return s\n"
    },
    {
        "number": 457,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, n = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def prime_divisors(num: int) -> set:\n        divisors = set()\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                if i * i != num:\n                    divisors.add(num // i)\n        return divisors\n\n    def g(num: int, p: int) -> int:\n        result = 1\n        while num % p == 0:\n            result *= p\n            num //= p\n        return result\n\n    def f(x: int, y: int) -> int:\n        primes = prime_divisors(x)\n        result = 1\n        for p in primes:\n            result *= g(y, p)\n        return result\n\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * f(x, i)) % MOD\n\n    return str(result)"
    },
    {
        "number": 458,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    def s(x):\n        return sum(int(digit) for digit in str(x))\n\n    def is_valid(x):\n        return 0 < x < 10**9\n\n    solutions = []\n    x = 1\n    while True:\n        if is_valid(x) and x == b * s(x)**a + c:\n            solutions.append(x)\n        x += 1\n        if x > 10**9:\n            break\n\n    return str(len(solutions)) + \"\\n\" + \" \".join(map(str, sorted(solutions)))"
    },
    {
        "number": 459,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    cube = [int(x) for x in stdin.split()]\n\n    # Check if cube is solved\n    if all(cube[i] == cube[i + 8] == cube[i + 16] == cube[i + 24] for i in range(0, 24, 8)):\n        return \"YES\"\n\n    # Check if cube can be solved using one rotation\n    for i in range(6):\n        # Rotate face\n        cube = rotate_face(cube, i)\n\n        # Check if cube is solved\n        if all(cube[i] == cube[i + 8] == cube[i + 16] == cube[i + 24] for i in range(0, 24, 8)):\n            return \"YES\"\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 460,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x, y = map(int, stdin.split())\n    i = (x // 50) % 475\n    places = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        places.append(26 + i)\n    places.sort()\n    if p in places:\n        return \"0\"\n    else:\n        hacks = 0\n        while x < y:\n            x += 100\n            hacks += 1\n        return str(hacks)"
    },
    {
        "number": 461,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    if n == 2:\n        return str(min(a + b, a + c, b + c))\n    return str(min(a + b + c, a + b + a, a + c + b, b + c + a))"
    },
    {
        "number": 462,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, x2, x3 = map(int, stdin.split())\n    distances = [abs(x1 - x2), abs(x1 - x3), abs(x2 - x3)]\n    return str(sum(sorted(distances)[:2]))"
    },
    {
        "number": 463,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if len(set(a)) < 2:\n        return str(0)\n\n    for i in range(n):\n        if a[i] & x == a[i]:\n            return str(1)\n\n    return str(-1)\n"
    },
    {
        "number": 464,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_plus_shape(x: int, y: int) -> bool:\n        if grid[x][y] != \"*\":\n            return False\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == \"*\":\n                return True\n        return False\n\n    for x in range(h):\n        for y in range(w):\n            if is_plus_shape(x, y):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 465,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a + b > n:\n        return \"NO\"\n\n    def is_valid(matrix: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n        return True\n\n    def count_components(matrix: List[List[int]]) -> int:\n        visited = [False] * n\n        count = 0\n        for i in range(n):\n            if not visited[i]:\n                count += 1\n                dfs(matrix, i, visited)\n        return count\n\n    def dfs(matrix: List[List[int]], start: int, visited: List[bool]) -> None:\n        visited[start] = True\n        for i in range(n):\n            if matrix[start][i] == 1 and not visited[i]:\n                dfs(matrix, i, visited)\n\n    def complement(matrix: List[List[int]]) -> List[List[int]]:\n        complement_matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                complement_matrix[i][j] = 1 - matrix[i][j]\n        return complement_matrix\n\n    def generate_matrix(matrix: List[List[int]]) -> str:\n        result = \"\"\n        for row in matrix:\n            result += \"\".join(map(str, row)) + \"\\n\"\n        return result\n\n    def find_matrix() -> str:\n        for i in range(2 ** (n * n)):\n            binary_string = format(i, f\"0{n * n}b\")\n            matrix = [[int(binary_string[j * n + k]) for k in range(n)] for j in range(n)]\n            if is_valid(matrix) and count_components(matrix) == a and count_components(complement(matrix)) == b:\n                return generate_matrix(matrix)\n        return \"NO\"\n\n    return find_matrix()"
    },
    {
        "number": 466,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, d = map(int, stdin.split()[0:2])\n    n, m = map(int, stdin.split()[2:4])\n    k = int(stdin.split()[4])\n\n    if n * m <= k:\n        return \"0\"\n\n    if n * m > c:\n        return str(c)\n\n    return str(n * m)"
    },
    {
        "number": 467,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_adjacent(tile1, tile2):\n        if tile1 == tile2:\n            return False\n        row1, col1 = tile1\n        row2, col2 = tile2\n        return (row1 == row2 and abs(col1 - col2) == 1) or (abs(row1 - row2) == 1 and col1 == col2)\n\n    def find_path(grid, path, s):\n        if not s:\n            return path\n        for tile in grid:\n            if tile not in path and s[0] in grid[tile]:\n                new_path = path.copy()\n                new_path.append(tile)\n                if find_path(grid, new_path, s[1:]):\n                    return new_path\n        return None\n\n    def create_grid(path):\n        grid = {(0, col): set() for col in range(13)}\n        for i, tile in enumerate(path):\n            row, col = tile\n            grid[tile] = set(s[i])\n            if i > 0:\n                prev_tile = path[i - 1]\n                if is_adjacent(tile, prev_tile):\n                    grid[prev_tile].add(s[i])\n                    grid[tile].add(s[i - 1])\n        return grid\n\n    s = stdin\n    if len(s) != 27:\n        return \"Impossible\"\n\n    path = [(0, col) for col in range(13)]\n    path = find_path(path, [], s)\n    if not path:\n        return \"Impossible\"\n\n    grid = create_grid(path)\n    row1 = \"\".join(sorted(grid[(0, col)]) for col in range(13))\n    row2 = \"\".join(sorted(grid[(1, col)]) for col in range(13))\n    return row1 + \"\\n\" + row2"
    },
    {
        "number": 468,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_to_y = x ** y\n    y_to_x = y ** x\n\n    if x_to_y < y_to_x:\n        return '<'\n    elif x_to_y > y_to_x:\n        return '>'\n    else:\n        return '='"
    },
    {
        "number": 469,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, h = map(int, stdin.split())\n    max_balloons = 0\n    for i in range(1, r + 1):\n        if i * i + (h + r) * (h + r) <= r * r:\n            max_balloons = i\n        else:\n            break\n    return str(max_balloons)"
    },
    {
        "number": 470,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cards = list(map(int, stdin.split()))\n    cards.sort()\n    min_sum = sum(cards)\n    \n    for i in range(len(cards) - 2):\n        if cards[i] == cards[i + 1] == cards[i + 2]:\n            min_sum = min(min_sum, sum(cards[:i]) + sum(cards[i+3:]))\n    \n    return str(min_sum)"
    },
    {
        "number": 471,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    x.sort()\n    min_distance = float('inf')\n    for i in range(n-1):\n        min_distance = min(min_distance, abs(x[i] - x[i+1]))\n    min_distance = min(min_distance, abs(x[-1] - a))\n    return str(min_distance)"
    },
    {
        "number": 472,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x = 1\n    while True:\n        s = sum(int(digit) for digit in str(x))\n        if x * x + s * x - n == 0:\n            return str(x)\n        elif x * x + s * x - n > 0:\n            return \"-1\"\n        x += 1"
    },
    {
        "number": 473,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s_hour, s_minute = map(int, s.split(':'))\n    t_hour, t_minute = map(int, t.split(':'))\n\n    if s_hour >= t_hour and s_minute >= t_minute:\n        p_hour = s_hour - t_hour\n        p_minute = s_minute - t_minute\n    else:\n        p_hour = 24 + s_hour - t_hour\n        p_minute = s_minute - t_minute\n\n    return f\"{p_hour:02d}:{p_minute:02d}\""
    },
    {
        "number": 474,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_mean = 0\n    max_length = 0\n\n    for l in range(n):\n        for r in range(l, n):\n            mean = sum(a[l:r+1]) / (r - l + 1)\n            if mean > max_mean:\n                max_mean = mean\n                max_length = r - l + 1\n            elif mean == max_mean and (r - l + 1) > max_length:\n                max_length = r - l + 1\n\n    return str(max_length)"
    },
    {
        "number": 475,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 998244353\n\n    # Calculate the number of ways to color the first k bricks\n    first_k_ways = 1\n    for i in range(k):\n        first_k_ways *= m\n        first_k_ways %= mod\n\n    # Calculate the number of ways to color the remaining bricks\n    remaining_bricks = n - k\n    remaining_ways = m ** remaining_bricks\n    remaining_ways %= mod\n\n    # Calculate the total number of ways to color the bricks\n    total_ways = (first_k_ways * remaining_ways) % mod\n\n    return str(total_ways)"
    },
    {
        "number": 476,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    magic_numbers = [1, 14, 144]\n    for num in magic_numbers:\n        if num not in stdin:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 477,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, i, j, a, b = map(int, stdin.split())\n    corners = [(1, m), (n, 1), (n, m), (1, 1)]\n\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def get_next_position(x, y, dx, dy):\n        return x + dx, y + dy\n\n    def get_min_moves(x, y, target):\n        queue = [(x, y, 0)]\n        visited = set()\n\n        while queue:\n            x, y, depth = queue.pop(0)\n            if (x, y) == target:\n                return depth\n            visited.add((x, y))\n\n            for dx, dy in [(a, b), (-a, b), (a, -b), (-a, -b)]:\n                new_x, new_y = get_next_position(x, y, dx, dy)\n                if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited:\n                    queue.append((new_x, new_y, depth + 1))\n\n        return \"Poor Inna and pony!\"\n\n    for corner in corners:\n        result = get_min_moves(i, j, corner)\n        if result != \"Poor Inna and pony!\":\n            return result\n\n    return \"Poor Inna and pony!\""
    },
    {
        "number": 478,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    for i in range(1, n):\n        if (i == 1 and s[i] == 'b') or (i == n - 1 and s[i] == 'y') or (s[i] == 'c' and s[i - 1] == 'b') or (s[i] == 'd' and s[i - 1] == 'c') or (s[i] == 'e' and s[i - 1] == 'd') or (s[i] == 'f' and s[i - 1] == 'e') or (s[i] == 'g' and s[i - 1] == 'f') or (s[i] == 'h' and s[i - 1] == 'g') or (s[i] == 'i' and s[i - 1] == 'h') or (s[i] == 'j' and s[i - 1] == 'i') or (s[i] == 'k' and s[i - 1] == 'j') or (s[i] == 'l' and s[i - 1] == 'k') or (s[i] == 'm' and s[i - 1] == 'l') or (s[i] == 'n' and s[i - 1] == 'm') or (s[i] == 'o' and s[i - 1] == 'n') or (s[i] == 'p' and s[i - 1] == 'o') or (s[i] == 'q' and s[i - 1] == 'p') or (s[i] == 'r' and s[i - 1] == 'q') or (s[i] == 's' and s[i - 1] == 'r') or (s[i] == 't' and s[i - 1] == 's') or (s[i] == 'u' and s[i - 1] == 't') or (s[i] == 'v' and s[i - 1] == 'u') or (s[i] == 'w' and s[i - 1] == 'v') or (s[i] == 'x' and s[i - 1] == 'w') or (s[i] == 'y' and s[i - 1] == 'x'):\n        count += 1\n    return count"
    },
    {
        "number": 479,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, denominations, q, requests = stdin.split('\\n')\n    n, k = map(int, n.split())\n    denominations = list(map(int, denominations.split()))\n    q = int(q)\n    requests = list(map(int, requests.split()))\n\n    def min_bills(request: int) -> int:\n        min_bills = float('inf')\n        for i in range(len(denominations)):\n            for j in range(i, len(denominations)):\n                if denominations[i] + denominations[j] <= request:\n                    min_bills = min(min_bills, 1 + min_bills(request - denominations[i] - denominations[j]))\n                else:\n                    break\n            if min_bills == 1:\n                return min_bills\n        return -1\n\n    result = []\n    for request in requests:\n        result.append(min_bills(request))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 480,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x_1, x_2, t_1, t_2, p, d = map(int, stdin.split())\n\n    if x_1 == x_2:\n        return \"0\"\n\n    if d == 1:\n        if x_1 < p < x_2:\n            return str(abs(x_2 - x_1))\n        elif x_1 > p > x_2:\n            return str(abs(x_2 - x_1) + abs(x_1 - p) + abs(p - x_2))\n        else:\n            return str(abs(x_2 - x_1) + abs(x_1 - p))\n    else:\n        if x_1 < p < x_2:\n            return str(abs(x_2 - x_1) + abs(x_1 - p) + abs(p - x_2))\n        elif x_1 > p > x_2:\n            return str(abs(x_2 - x_1))\n        else:\n            return str(abs(x_2 - x_1) + abs(x_1 - p))"
    },
    {
        "number": 481,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i * j == x:\n                count += 1\n    return str(count)"
    },
    {
        "number": 482,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > 26:\n        return \"There is no password that satisfies the conditions.\"\n    for i in range(1, 26):\n        for j in range(1, 26):\n            if i != j:\n                for l in range(1, 26):\n                    if l != i and l != j:\n                        for m in range(1, 26):\n                            if m != i and m != j and m != l:\n                                password = chr(i) + chr(j) + chr(l) + chr(m)\n                                if len(set(password)) == k:\n                                    return password\n    return \"There is no password that satisfies the conditions.\""
    },
    {
        "number": 483,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, directions, coordinates = stdin.split('\\n')\n    n = int(n)\n    directions = list(directions)\n    coordinates = list(map(int, coordinates.split()))\n\n    left_particles = []\n    right_particles = []\n\n    for i in range(n):\n        if directions[i] == 'L':\n            left_particles.append(coordinates[i])\n        else:\n            right_particles.append(coordinates[i])\n\n    left_particles.sort()\n    right_particles.sort()\n\n    left_index = 0\n    right_index = len(right_particles) - 1\n\n    while left_index < len(left_particles) and right_index >= 0:\n        if left_particles[left_index] == right_particles[right_index]:\n            return str(left_particles[left_index])\n        elif left_particles[left_index] < right_particles[right_index]:\n            left_index += 1\n        else:\n            right_index -= 1\n\n    return \"-1\""
    },
    {
        "number": 484,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    seals = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def can_fit(seal, x, y):\n        return x <= a and y <= b\n    \n    def area(x, y):\n        return x * y\n    \n    def max_area(seals):\n        max_area = 0\n        for i in range(len(seals)):\n            for j in range(i+1, len(seals)):\n                x1, y1 = seals[i]\n                x2, y2 = seals[j]\n                if can_fit(seals[i], x1, y2) and can_fit(seals[j], x2, y1):\n                    max_area = max(max_area, area(x1, y2) + area(x2, y1))\n        return max_area\n    \n    return str(max_area(seals))"
    },
    {
        "number": 485,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    x_min, x_max = min(points, key=lambda x: x[0])[0], max(points, key=lambda x: x[0])[0]\n    y_min, y_max = min(points, key=lambda x: x[1])[1], max(points, key=lambda x: x[1])[1]\n    for point in points:\n        if point[0] not in range(x_min, x_max + 1) or point[1] not in range(y_min, y_max + 1):\n            return f\"{point[0]} {point[1]}\""
    },
    {
        "number": 486,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_product = 0\n\n    for i in range(1, n + 1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n\n    return str(max_product)"
    },
    {
        "number": 487,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_str = stdin.split()\n    n = int(n)\n    a = list(map(int, a_str.split()))\n\n    k = max(a)\n    while True:\n        if sum(k - ai for ai in a) > k:\n            break\n        k += 1\n\n    return str(k)"
    },
    {
        "number": 488,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = list(stdin)\n    n = len(colors)\n    operations = 0\n\n    while True:\n        delete_count = 0\n        for i in range(1, n - 1):\n            if colors[i] != colors[i - 1] and colors[i] != colors[i + 1]:\n                colors[i] = None\n                delete_count += 1\n\n        if delete_count == 0:\n            break\n\n        operations += 1\n        colors = [color for color in colors if color is not None]\n        n = len(colors)\n\n    return str(operations)"
    },
    {
        "number": 489,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort()\n    count = 0\n    for i in range(n-2):\n        j = i + 1\n        k = n - 1\n        while j < k:\n            if a[i] * a[j] * a[k] < a[i] * a[j+1] * a[k-1]:\n                count += k - j - 1\n                j += 1\n            else:\n                k -= 1\n    return str(count)"
    },
    {
        "number": 490,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(n - 1)"
    },
    {
        "number": 491,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n >= 0:\n        return str(n)\n    else:\n        return str(n // 10)"
    },
    {
        "number": 492,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    start, end = stdin.split()\n    n = int(input())\n\n    if start == end:\n        return \"undefined\"\n\n    if start == \"^\" and end == \">\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    elif start == \"^\" and end == \"<\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \"^\" and end == \"v\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \">\" and end == \"^\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    elif start == \">\" and end == \"<\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \">\" and end == \"v\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \"<\" and end == \"^\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \"<\" and end == \">\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    elif start == \"<\" and end == \"v\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    elif start == \"v\" and end == \"^\":\n        return \"ccw\" if n % 2 == 0 else \"cw\"\n    elif start == \"v\" and end == \"<\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    elif start == \"v\" and end == \">\":\n        return \"cw\" if n % 2 == 0 else \"ccw\"\n    else:\n        return \"undefined\""
    },
    {
        "number": 493,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    count = 0\n    for i in range(n):\n        if s[i] == '.':\n            count += 1\n    return str(count)"
    },
    {
        "number": 494,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    leaders = list(map(int, stdin.split()[2:]))\n\n    if len(leaders) != m:\n        return \"-1\"\n\n    permutation = list(range(1, n + 1))\n    leader_index = 0\n    for i in range(m):\n        leader_index = leaders[i] - 1\n        if leader_index == 0:\n            leader_index = n\n        permutation.insert(leader_index, permutation.pop(0))\n\n    return \" \".join(map(str, permutation))\n"
    },
    {
        "number": 495,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = map(int, stdin.split())\n    max_num = a\n    for _ in range(k):\n        for i in range(len(str(a)) - 1):\n            if a[i] < a[i + 1]:\n                max_num = max(max_num, int(str(a[:i] + str(a[i + 1]) + str(a[i]) + str(a[i + 2:]))))\n    return str(max_num)"
    },
    {
        "number": 496,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a == b and b == c and c == d:\n        return str(a + d)\n    elif a == b * b and b * b == c and c == d:\n        return str(a * b * b)\n    elif a == b and b == c:\n        return str(a + 2 * (c - a))\n    elif a == b * b and b == c:\n        return str(a * b * b)\n    else:\n        return \"42\""
    },
    {
        "number": 497,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = stdin.split()\n    n = int(n)\n    colors = list(map(int, colors.split()))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors[i] != colors[j]:\n                distance = abs(j - i)\n                max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 498,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    lane = k // m + 1\n    desk = (k % m) + 1 if k % m != 0 else m\n    side = \"L\" if k % 2 == 0 else \"R\"\n    return f\"{lane} {desk} {side}\""
    },
    {
        "number": 499,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    colors = set(s)\n    final_colors = set()\n\n    while len(colors) > 1:\n        for color in colors:\n            if s.count(color) > 1:\n                final_colors.add(color)\n                colors.remove(color)\n                break\n\n    if len(colors) == 1:\n        final_colors.add(colors.pop())\n\n    return \"\".join(sorted(final_colors))\n"
    },
    {
        "number": 500,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, node)\n        if len(visited) == n:\n            return True\n        return False\n    \n    def is_tree(graph):\n        visited = set()\n        for node in graph:\n            if node not in visited:\n                if not dfs(node, visited, None):\n                    return False\n        return True\n    \n    graph = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    if not is_tree(graph):\n        return \"NO\"\n    \n    def find_coordinates(graph):\n        x = [0] * n\n        y = [0] * n\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                if i != j and (i not in graph[j] or j not in graph[i]):\n                    x[i-1] = x[i-1] - 1\n                    y[i-1] = y[i-1] + 1\n                    x[j-1] = x[j-1] + 1\n                    y[j-1] = y[j-1] - 1\n        return x, y\n    \n    x, y = find_coordinates(graph)\n    result = \"YES\\n\"\n    for i in range(n):\n        result += f\"{x[i]} {y[i]}\\n\"\n    return result"
    },
    {
        "number": 501,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    total_sum = 0\n    current_set = 1\n    current_number = 1\n    current_count = 1\n\n    while current_number <= r:\n        if current_set == 1:\n            total_sum += current_number\n            if current_number >= l:\n                break\n        current_number += current_count\n        current_count *= 2\n        current_set = 2 - current_set\n\n    return str(total_sum % 1000000007)"
    },
    {
        "number": 502,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    # Check if the points are collinear\n    if (b_x - a_x) * (c_y - a_y) == (c_x - a_x) * (b_y - a_y):\n        return \"No\"\n\n    # Calculate the slope and the angle of rotation\n    slope_ab = (b_y - a_y) / (b_x - a_x)\n    slope_bc = (c_y - b_y) / (c_x - b_x)\n    angle = math.degrees(math.atan(slope_bc / slope_ab))\n\n    # Calculate the coordinates of the point\n    x = (a_x + b_x + c_x) / 3\n    y = (a_y + b_y + c_y) / 3\n\n    # Check if the new positions of a and b are the same as the old positions of b and c\n    if (a_x - x) * (b_x - x) < 0 or (a_y - y) * (b_y - y) < 0:\n        return \"No\"\n    if (b_x - x) * (c_x - x) < 0 or (b_y - y) * (c_y - y) < 0:\n        return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 503,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for l in range(j + 1, n):\n                if a[j] * k == a[l]:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 504,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    creatures = []\n    for i in range(n):\n        hp, dmg = map(int, stdin.split()[3:])\n        creatures.append((hp, dmg))\n\n    def max_damage(creatures, a, b):\n        if not creatures:\n            return 0\n\n        max_damage_without_spell = max_damage(creatures[1:], a, b)\n        max_damage_with_spell1 = max_damage(creatures[1:], a - 1, b) + creatures[0][0] * 2\n        max_damage_with_spell2 = max_damage(creatures[1:], a, b - 1) + creatures[0][0]\n\n        return max(max_damage_without_spell, max_damage_with_spell1, max_damage_with_spell2)\n\n    return str(max_damage(creatures, a, b))"
    },
    {
        "number": 505,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    maze = [list(stdin.split()[i][:m]) for i in range(3, n+3)]\n    x, y = next((i, j) for i in range(n) for j in range(m) if maze[i][j] == 'X')\n    visited = [[False] * m for _ in range(n)]\n    queue = [(x, y, 'L')]\n    visited[x][y] = True\n    min_way = 'IMPOSSIBLE'\n    \n    while queue:\n        x, y, way = queue.pop(0)\n        if len(way) == k:\n            if way < min_way:\n                min_way = way\n            continue\n        for dx, dy, direction in [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == '.':\n                visited[nx][ny] = True\n                queue.append((nx, ny, way + direction))\n    \n    return min_way"
    },
    {
        "number": 506,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    while a > b:\n        count += 1\n        a -= b\n    return str(count)"
    },
    {
        "number": 507,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    for i in range(n):\n        if a[i] != b[i]:\n            break\n\n    for j in range(n):\n        if a[i] != b[j]:\n            break\n\n    p = [0] * n\n    p[i] = a[i]\n    p[j] = b[j]\n\n    for k in range(n):\n        if k != i and k != j:\n            for l in range(n):\n                if p[k] == 0:\n                    p[k] = l + 1\n                    break\n\n    return \" \".join(map(str, p))"
    },
    {
        "number": 508,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    angles = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                angles.append((i + 1, j + 1, k + 1))\n\n    min_diff = float('inf')\n    result = None\n    for v1, v2, v3 in angles:\n        angle = abs(a - (180 / (n - 2)) * (v2 - 1))\n        diff = abs(angle - a)\n        if diff < min_diff:\n            min_diff = diff\n            result = (v1, v2, v3)\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 509,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rotations = [int(line) for line in stdin.splitlines()[1:]]\n\n    total_rotation = sum(rotations)\n\n    if total_rotation % 360 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 510,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    max_distance = max(abs(a - b), abs(b - c), abs(c - a))\n    if max_distance >= d:\n        return \"0\"\n    else:\n        return str(d - max_distance)"
    },
    {
        "number": 511,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def f(a, b):\n        if b == 0:\n            return 0\n        return 1 + f(a, b - gcd(a, b))\n\n    return str(f(x, y))"
    },
    {
        "number": 512,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A = [int(x) for x in lines[1:N+1]]\n    B = [int(x) for x in lines[N+1:]]\n\n    for i in range(N):\n        if A[i] == -1 or B[i] == -1:\n            continue\n\n        for j in range(N):\n            if i == j:\n                continue\n\n            if A[j] == -1 or B[j] == -1:\n                continue\n\n            if A[i] == A[j] or B[i] == B[j]:\n                return \"No\"\n\n            if A[i] < A[j] < B[i] < B[j]:\n                return \"No\"\n\n            if A[i] < B[j] < A[j] < B[i]:\n                return \"No\"\n\n            if A[i] < A[j] < B[i] < B[j]:\n                if A[i] + 1 == A[j] and B[i] - 1 == B[j]:\n                    continue\n                else:\n                    return \"No\"\n\n            if A[i] < B[j] < A[j] < B[i]:\n                if A[i] + 1 == A[j] and B[i] - 1 == B[j]:\n                    continue\n                else:\n                    return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 513,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')]\n    x_values = sorted(set(x for x, y in points))\n    y_values = sorted(set(y for x, y in points))\n\n    if len(x_values) != 3 or len(y_values) != 3:\n        return \"ugly\"\n\n    x_1, x_2, x_3 = x_values\n    y_1, y_2, y_3 = y_values\n\n    if (x_2, y_2) not in points:\n        return \"ugly\"\n\n    for x in (x_1, x_2, x_3):\n        for y in (y_1, y_2, y_3):\n            if (x, y) not in points:\n                return \"ugly\"\n\n    return \"respectable\""
    },
    {
        "number": 514,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, T + 1):\n        n, d = map(int, stdin.split('\\n')[i].split())\n        x = 0\n        while x * (x + 1) <= d:\n            x += 1\n        ceil_d = x + 1\n        days = x + ceil_d\n\n        if days <= n:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 515,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    n = 0\n    while True:\n        if count_loops(n) == k:\n            return str(n)\n        elif count_loops(n) > k:\n            return \"-1\"\n        n += 1\n\ndef"
    },
    {
        "number": 516,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    k = 0\n    positions = []\n\n    for i in range(n):\n        if s[i] != t[i]:\n            k += 1\n            positions.append(i + 1)\n\n    return f\"{k}\\n{' '.join(map(str, positions))}\""
    },
    {
        "number": 517,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, h = map(int, stdin.split())\n\n    if h > d:\n        return \"-1\"\n\n    if n == 2:\n        return \"1 2\"\n\n    if n == 3:\n        return \"1 2\\n1 3\"\n\n    if n == 4:\n        return \"1 2\\n1 3\\n3 4\"\n\n    if n == 5:\n        return \"1 2\\n1 3\\n3 4\\n3 5\"\n\n    if n == 6:\n        return \"1 2\\n1 3\\n3 4\\n3 5\\n5 6\"\n\n    if n == 7:\n        return \"1 2\\n1 3\\n3 4\\n3 5\\n5 6\\n6 7\"\n\n    if n == 8:\n        return \"1 2\\n1 3\\n3 4\\n3 5\\n5 6\\n6 7\\n7 8\"\n\n    return \"-1\""
    },
    {
        "number": 518,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    R = r * (n - 1) / (n - 2)\n    return f\"{R:.6f}\""
    },
    {
        "number": 519,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, p, q = map(int, stdin.split())\n    distance = l / 2\n    return str(distance)"
    },
    {
        "number": 520,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    years = list(map(int, stdin.split()[1:]))\n    x = years[0] - years[-1]\n    return str(x // 2 + years[0])"
    },
    {
        "number": 521,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_valid(painted: str) -> bool:\n        for i in range(n - 1):\n            if painted[i] == painted[i + 1]:\n                return False\n        return True\n\n    def count_ways(painted: str) -> int:\n        count = 0\n        for i in range(n):\n            if s[i] == '?':\n                for color in ['C', 'M', 'Y']:\n                    new_painted = painted[:i] + color + painted[i + 1:]\n                    if is_valid(new_painted):\n                        count += 1\n        return count\n\n    painted = \"\"\n    for i in range(n):\n        if s[i] != '?':\n            painted += s[i]\n\n    if count_ways(painted) >= 2:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 522,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f1, f2, f3, c = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def f(x: int) -> int:\n        if x == 1:\n            return f1\n        elif x == 2:\n            return f2\n        elif x == 3:\n            return f3\n        else:\n            return (c**(2*x - 6)) * f(x-1) * f(x-2) * f(x-3) % MOD\n\n    return str(f(n))"
    },
    {
        "number": 523,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    strings = [input() for _ in range(n)]\n    strings.sort(key=lambda x: len(x), reverse=True)\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_longest_palindrome(strings: List[str]) -> str:\n        for i in range(len(strings)):\n            for j in range(i + 1, len(strings)):\n                s = strings[i] + strings[j]\n                if is_palindrome(s):\n                    return s\n        return \"\"\n\n    longest_palindrome = find_longest_palindrome(strings)\n    return len(longest_palindrome), longest_palindrome\n"
    },
    {
        "number": 524,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_power_sequence(a: List[int]) -> bool:\n        c = a[0]\n        for i in range(1, len(a)):\n            if a[i] != c ** i:\n                return False\n        return True\n\n    def min_cost(a: List[int]) -> int:\n        cost = 0\n        for i in range(len(a)):\n            if a[i] > a[0]:\n                cost += a[i] - a[0]\n            else:\n                cost += a[0] - a[i]\n        return cost\n\n    if is_power_sequence(a):\n        return str(0)\n\n    min_cost_value = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            a[i], a[j] = a[j], a[i]\n            if is_power_sequence(a):\n                min_cost_value = min(min_cost_value, min_cost(a))\n            a[i], a[j] = a[j], a[i]\n\n    return str(min_cost_value)"
    },
    {
        "number": 525,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(1, int(test_cases[0]) + 1):\n        n = int(test_cases[i * 2 - 1])\n        password = list(map(int, test_cases[i * 2].split()))\n\n        while len(password) > 1:\n            for j in range(len(password) - 1):\n                if password[j] != password[j + 1]:\n                    password.pop(j)\n                    password.pop(j)\n                    password.insert(j, password[j] + password[j + 1])\n                    break\n\n        result.append(str(len(password)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 526,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def xor_sum(c):\n        return sum(a[i][c[i]-1] for i in range(n))\n\n    for i in range(1, 1 << m):\n        c = [j + 1 for j in map(int, bin(i)[2:]) if j == 1]\n        if xor_sum(c) > 0:\n            return \"TAK\\n\" + \" \".join(map(str, c))\n\n    return \"NIE\"\n\n\ndef"
    },
    {
        "number": 527,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s_prime = s * (10**100)\n    for i in range(1, len(s_prime) + 1):\n        if t in s_prime[:i]:\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 528,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    friends = set()\n    for i in range(m):\n        a, b = map(int, stdin.split()[2*i+2:2*i+4])\n        friends.add((min(a, b), max(a, b)))\n\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                if (i, j) in friends and (j, k) in friends and (i, k) not in friends:\n                    return \"NO\"\n    return \"YES\""
    },
    {
        "number": 529,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    string, index = stdin.split('\\n')\n    index = int(index)\n    result = ''\n    \n    for char in string:\n        if char.isalpha():\n            if char.islower():\n                result += chr(((ord(char) - ord('a') + index) % 26) + ord('a'))\n            else:\n                result += chr(((ord(char) - ord('A') + index) % 26) + ord('A'))\n        else:\n            result += char\n    \n    return result"
    },
    {
        "number": 530,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    s_score = 0\n    t_score = 0\n\n    for i in range(1, 2 * n + 1):\n        s_move = s[i - 1]\n        t_move = t[i - 1]\n\n        if s_move == '1' and t_move == '0':\n            s_score += 1\n        elif s_move == '0' and t_move == '1':\n            t_score += 1\n\n    if s_score > t_score:\n        return \"First\"\n    elif t_score > s_score:\n        return \"Second\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 531,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n    min_value = min(x)\n    max_value = max(x)\n    avg = sum(x) / n\n    y = [avg] * n\n    min_count = 0\n    max_count = 0\n    for i in range(n):\n        if x[i] < avg:\n            min_count += 1\n        elif x[i] > avg:\n            max_count += 1\n    min_count = min(min_count, max_count)\n    max_count = min(min_count, max_count)\n    return str(min_count) + \"\\n\" + \" \".join(map(str, y))"
    },
    {
        "number": 532,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alphabets = \"abcdefghijklmnopqrstuvwxyz\"\n    pointer = 0\n    rotations = 0\n\n    for char in stdin:\n        index = alphabets.index(char)\n        if index < pointer:\n            rotations += 1\n        pointer = index\n\n    return rotations"
    },
    {
        "number": 533,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, k1, k2, n = map(int, stdin.split())\n    min_players = max(0, a1 - k1 * (n // k1), a2 - k2 * (n // k2))\n    max_players = min(a1, a2)\n    return f\"{min_players} {max_players}\""
    },
    {
        "number": 534,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    s = stdin.split()[2]\n    a = s\n    for i in range(t):\n        for j in range(n - 1):\n            if s[j] == \"B\" and s[j + 1] == \"G\":\n                a = list(a)\n                a[j], a[j + 1] = a[j + 1], a[j]\n                a = \"\".join(a)\n                s = a\n    return \"\".join(a)"
    },
    {
        "number": 535,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"1\"\n    if k == 1:\n        return str(n)\n    if k == 2:\n        return str(n * (n - 1))\n    if k == 3:\n        return str(n * (n - 1) * (n - 2))\n    if k == 4:\n        return str(n * (n - 1) * (n - 2) * (n - 3))\n    if k == 5:\n        return str(n * (n - 1) * (n - 2) * (n - 3) * (n - 4))\n    return str(n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5))"
    },
    {
        "number": 536,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 0:\n        return \"1\" * m\n    if m == 0:\n        return \"0\" * n\n    if n == 1 and m == 1:\n        return \"10\"\n    if n == 2 and m == 2:\n        return \"1010\"\n    if n == 3 and m == 3:\n        return \"1011011\"\n    if n == 4 and m == 4:\n        return \"1101101101\"\n    if n == 5 and m == 5:\n        return \"1101101101101\"\n    if n == 6 and m == 6:\n        return \"110110110110110\"\n    return -1"
    },
    {
        "number": 537,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_winners = min(n // 2, n - k)\n    diplomas = min(max_winners, n - 2 * max_winners)\n    certificates = max_winners + diplomas * k\n    non_winners = n - diplomas - certificates\n    return f\"{diplomas} {certificates} {non_winners}\""
    },
    {
        "number": 538,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    x_str = str(x)\n    if x_str == x_str[::-1]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 539,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a + 1, n + 1):\n            c = n - a - b\n            if c > 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 540,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    ice_map = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    r_1, c_1 = map(int, stdin.split('\\n')[n+1].split())\n    r_2, c_2 = map(int, stdin.split('\\n')[n+2].split())\n\n    if ice_map[r_1-1][c_1-1] == 'X':\n        ice_map[r_1-1][c_1-1] = '.'\n\n    if ice_map[r_2-1][c_2-1] == 'X':\n        ice_map[r_2-1][c_2-1] = '.'\n\n    if r_1 == r_2 and c_1 == c_2:\n        return 'YES'\n\n    def dfs(r, c):\n        if r < 0 or r >= n or c < 0 or c >= m:\n            return False\n        if ice_map[r][c] == 'X':\n            ice_map[r][c] = '.'\n            return True\n        return False\n\n    for i in range(r_1-1, r_2-1+1):\n        for j in range(c_1-1, c_2-1+1):\n            if dfs(i, j):\n                return 'YES'\n\n    return 'NO'"
    },
    {
        "number": 541,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    requests = [tuple(map(int, line.split())) for line in lines[1:-1]]\n    bridges = [i for i in range(1, N)]\n\n    for a, b in requests:\n        if a < b:\n            bridges.remove(a)\n        else:\n            bridges.remove(b)\n\n    return str(len(bridges))"
    },
    {
        "number": 542,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    first_wrestler_points = []\n    second_wrestler_points = []\n    first_wrestler_techniques = []\n    second_wrestler_techniques = []\n\n    for i in range(n):\n        if points[i] > 0:\n            first_wrestler_points.append(points[i])\n            first_wrestler_techniques.append(i)\n        else:\n            second_wrestler_points.append(-points[i])\n            second_wrestler_techniques.append(i)\n\n    if len(first_wrestler_points) == len(second_wrestler_points):\n        for i in range(len(first_wrestler_points)):\n            if first_wrestler_points[i] > second_wrestler_points[i]:\n                return \"first\"\n            elif first_wrestler_points[i] < second_wrestler_points[i]:\n                return \"second\"\n        return \"second\"\n    elif len(first_wrestler_points) > len(second_wrestler_points):\n        return \"first\"\n    else:\n        return \"second\""
    },
    {
        "number": 543,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n\n        if i == 0:\n            if a[i] > 1:\n                return \"NO\"\n            continue\n\n        if i == 1:\n            if a[i] > 2:\n                return \"NO\"\n            continue\n\n        if i == 2:\n            if a[i] > 1:\n                return \"NO\"\n            continue\n\n        if i == 3:\n            if a[i] > 2:\n                return \"NO\"\n            continue\n\n    return \"YES\"\n"
    },
    {
        "number": 544,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n\n        if n == 2:\n            result.append(\"YES\")\n        else:\n            for i in range(n // 2):\n                if s[i] == s[n - i - 1]:\n                    continue\n                elif s[i] == chr(ord(s[n - i - 1]) - 1):\n                    s = s[:i] + chr(ord(s[i]) - 1) + s[i + 1:] + chr(ord(s[n - i - 1]) - 1) + s[n - i:]\n                    break\n                elif s[i] == chr(ord(s[n - i - 1]) + 1):\n                    s = s[:i] + chr(ord(s[i]) + 1) + s[i + 1:] + chr(ord(s[n - i - 1]) + 1) + s[n - i:]\n                    break\n                else:\n                    result.append(\"NO\")\n                    break\n            else:\n                result.append(\"YES\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 545,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    s1, s2 = stdin.split()[2:4]\n\n    for i in range(n):\n        if s1[i] != s2[i]:\n            s3 = s1[:i] + s2[i] + s1[i+1:]\n            if f(s1, s3) == f(s2, s3) == t:\n                return s3\n\n    return \"-1\"\n\ndef"
    },
    {
        "number": 546,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = stdin.split('\\n')\n    n = int(n)\n\n    def match(query: str) -> bool:\n        i = 0\n        j = 0\n        while i < len(query) and j < len(pattern):\n            if pattern[j] == '?':\n                i += 1\n                j += 1\n            elif pattern[j] == '*':\n                if j + 1 < len(pattern) and pattern[j + 1] == '*':\n                    return False\n                while i < len(query) and query[i] in good_letters:\n                    i += 1\n                j += 1\n            elif query[i] == pattern[j]:\n                i += 1\n                j += 1\n            else:\n                return False\n        return i == len(query) and j == len(pattern)\n\n    result = []\n    for _ in range(n):\n        query = input()\n        result.append(\"YES\" if match(query) else \"NO\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 547,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    passwords = stdin.split('\\n')[1:-1]\n    codehorses_password = stdin.split('\\n')[-1]\n\n    passwords.sort(key=lambda x: (len(x), x))\n    time_best_case = 1\n    time_worst_case = 1\n\n    for password in passwords:\n        if password == codehorses_password:\n            break\n        time_best_case += 1\n        time_worst_case += 2\n\n    time_worst_case += 5 * k\n\n    return f\"{time_best_case} {time_worst_case}\"\n\ninput_data = \"5 2\\ncba\\nabc\\nbb1\\nabC\\nABC\\nabc\\n\"\nprint(solution(input_data)) "
    },
    {
        "number": 548,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n\n    def sum_array(arr: list) -> int:\n        return sum(arr)\n\n    def remove_subarray(arr: list, subarray: list) -> list:\n        return [x for x in arr if x not in subarray]\n\n    def find_subarray(arr: list, sum_value: int) -> list:\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                if sum_array(arr[i:j]) == sum_value:\n                    return arr[i:j]\n        return []\n\n    def play_game(arr: list) -> str:\n        while len(arr) > 0:\n            if sum_array(arr) % 2 == 0:\n                subarray = find_subarray(arr, sum_array(arr) - 1)\n                if len(subarray) > 0:\n                    arr = remove_subarray(arr, subarray)\n                else:\n                    return \"Second\"\n            else:\n                subarray = find_subarray(arr, sum_array(arr) + 1)\n                if len(subarray) > 0:\n                    arr = remove_subarray(arr, subarray)\n                else:\n                    return \"First\"\n        return \"First\"\n\n    return play_game(array)"
    },
    {
        "number": 549,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = n\n    while a <= b:\n        mid = (a + b) // 2\n        if mid * (n // mid) == n:\n            return str(n // mid) + \" \" + str(mid)\n        elif mid * (n // mid) < n:\n            a = mid + 1\n        else:\n            b = mid - 1\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 550,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    login, existing_logins = stdin.split('\\n')\n    existing_logins = existing_logins.split('\\n')\n\n    def is_similar(s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        transforms = {\n            ('O', '0'): True,\n            ('0', 'O'): True,\n            ('l', '1'): True,\n            ('1', 'l'): True,\n            ('I', '1'): True,\n            ('1', 'I'): True,\n        }\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                if (s[i], t[i]) not in transforms:\n                    return False\n        return True\n\n    for existing_login in existing_logins:\n        if is_similar(login, existing_login):\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 551,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, points = stdin.split('\\n')\n    n = int(n)\n    points = [int(y) for y in points.split()]\n\n    if n < 3:\n        return \"No\"\n\n    points.sort()\n    min_y = points[0]\n    max_y = points[-1]\n\n    for i in range(1, n):\n        if points[i] == points[i - 1]:\n            return \"No\"\n\n    if max_y - min_y < 2:\n        return \"No\"\n\n    return \"Yes\"\n\n\ndef"
    },
    {
        "number": 552,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a, b, s = stdin.split()[2:]\n\n    def count_ways(l1, r1, l2, r2):\n        if l1 > r1 or l2 > r2:\n            return 0\n        if l1 <= l2 <= r1 and l2 <= r1 and l2 <= r2:\n            return 1 + count_ways(l1, r1, l2 + 1, r2) + count_ways(l1, r1, l2, r2 - 1)\n        elif l1 <= l2 <= r1 and l2 <= r1:\n            return count_ways(l1, r1, l2 + 1, r2)\n        elif l1 <= r2 and l2 <= r1:\n            return count_ways(l1, r1, l2, r2 - 1)\n        else:\n            return 0\n\n    count = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if l1 <= l2 <= r1 and l2 <= r1 and l2 <= r2:\n                        count += count_ways(l1, r1, l2, r2)\n\n    return str(count)"
    },
    {
        "number": 553,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    promo_codes = stdin.split('\\n')[1:]\n\n    max_k = 0\n    for promo_code in promo_codes:\n        for i in range(len(promo_code)):\n            for j in range(i + 1, len(promo_code)):\n                if promo_code[i] != promo_code[j]:\n                    max_k = max(max_k, abs(ord(promo_code[i]) - ord(promo_code[j])))\n\n    return str(max_k)"
    },
    {
        "number": 554,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    flowers = list(map(int, stdin.split()[2:2+n]))\n    subarrays = []\n    for i in range(m):\n        l, r = map(int, stdin.split()[2+n+i*2:2+n+i*2+2])\n        subarrays.append((l-1, r-1))\n\n    happiness = 0\n    for i in range(n):\n        count = 0\n        for j in range(m):\n            if (subarrays[j][0] <= i <= subarrays[j][1]):\n                count += 1\n        happiness += flowers[i] * count\n\n    return str(happiness)"
    },
    {
        "number": 555,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    result = []\n    for digit in str(x):\n        result.append(str(9 - int(digit)))\n    return ''.join(result)"
    },
    {
        "number": 556,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    power = 1\n    while power <= r:\n        if power >= l:\n            result.append(power)\n        power *= k\n    if not result:\n        return \"-1\"\n    return \" \".join(map(str, result))"
    },
    {
        "number": 557,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    teleports = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[2:])\n        teleports.append((a, b))\n\n    def can_reach(start, end, visited):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for teleport in teleports:\n            if teleport[0] <= start <= teleport[1]:\n                if can_reach(teleport[1], end, visited):\n                    return True\n        return False\n\n    if can_reach(0, m, set()):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 558,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 998244353\n\n    def count_ways(n: int, m: int, k: int) -> int:\n        if n == 0:\n            return 1\n        if k == 0:\n            return pow(m, n, mod)\n\n        result = 0\n        for i in range(1, min(m, k + 1) + 1):\n            result += count_ways(n - 1, m, k - i)\n            result %= mod\n\n        return result\n\n    return str(count_ways(N, M, K))"
    },
    {
        "number": 559,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, a = stdin.split()\n    p = int(p)\n    a = [int(x) for x in a.split()]\n\n    def is_valid(b: List[int]) -> bool:\n        f = [b[i] * pow(i, p-1, p) for i in range(p)]\n        return all(f[i] % p == a[i] for i in range(p))\n\n    b = list(range(p))\n    while not is_valid(b):\n        b = [x - 1 for x in b]\n\n    return \" \".join(map(str, b))"
    },
    {
        "number": 560,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split()[:2])\n    cake = [list(row) for row in stdin.split()[2:]]\n\n    def can_eat(row: int, col: int) -> bool:\n        for i in range(rows):\n            if cake[i][col] == 'S':\n                return False\n        for j in range(cols):\n            if cake[row][j] == 'S':\n                return False\n        return True\n\n    def eat_cake(row: int, col: int) -> int:\n        count = 0\n        for i in range(rows):\n            for j in range(cols):\n                if cake[i][j] == '.' and can_eat(i, j):\n                    count += 1\n                    cake[i][j] = 'E'\n        return count\n\n    max_eaten = 0\n    for i in range(rows):\n        for j in range(cols):\n            if cake[i][j] == '.' and can_eat(i, j):\n                max_eaten = max(max_eaten, eat_cake(i, j))\n\n    return str(max_eaten)"
    },
    {
        "number": 561,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = stdin.split('\\n')\n    n = int(n)\n    cards = list(map(int, cards.split()))\n\n    if len(cards) != n:\n        raise ValueError(\"Invalid input: number of cards and given cards don't match\")\n\n    if n == 1:\n        return \"-1\"\n\n    cards.sort()\n    diffs = [cards[i] - cards[i - 1] for i in range(1, n)]\n    min_diff = min(diffs)\n    max_diff = max(diffs)\n\n    if min_diff == max_diff:\n        return \"-1\"\n\n    count = 0\n    for i in range(n - 1):\n        if diffs[i] == diffs[i + 1] - 1:\n            count += 1\n\n    if count == 0:\n        return \"0\"\n\n    result = []\n    for i in range(n - 1):\n        if diffs[i] == diffs[i + 1] - 1:\n            result.append(cards[i] - diffs[i])\n            result.append(cards[i] + diffs[i])\n\n    return str(len(result)) + \"\\n\" + \" \".join(map(str, sorted(result)))"
    },
    {
        "number": 562,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    shows = []\n    for i in range(1, n+1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        shows.append((l, r))\n\n    shows.sort(key=lambda x: x[0])\n    count = 1\n    current_end = shows[0][1]\n\n    for i in range(1, n):\n        if shows[i][0] >= current_end:\n            count += 1\n            current_end = shows[i][1]\n\n    return \"YES\" if count >= 2 else \"NO\""
    },
    {
        "number": 563,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    for a in range(l, r):\n        for b in range(a + 1, r):\n            for c in range(b + 1, r + 1):\n                if (a, b) == (2, 3) and (b, c) == (3, 4):\n                    return f\"{a} {b} {c}\"\n    return \"-1\""
    },
    {
        "number": 564,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    mugs = list(map(int, stdin.split()[2:]))\n\n    if max(mugs) > s:\n        return \"NO\"\n\n    mugs.sort(reverse=True)\n    for i in range(n - 1):\n        if mugs[i] > mugs[i + 1]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 565,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    y_max = min(b - 1, r - 1)\n    b_max = min(y + 1, r - 1)\n    r_max = min(y + 1, b + 1)\n    return str(min(y_max, b_max, r_max))"
    },
    {
        "number": 566,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    max_tables = 0\n    for i in range(min(r, g, b) + 1):\n        for j in range(min(r, g, b) - i + 1):\n            k = min(r, g, b) - i - j\n            if i + j + k == r and i + j + k == g and i + j + k == b:\n                max_tables += 1\n    return str(max_tables)"
    },
    {
        "number": 567,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, prizes = stdin.split()\n    n = int(n)\n    prizes = list(map(int, prizes.split()))\n\n    time = 0\n    for i in range(n):\n        if prizes[i] == 1 or prizes[i] == 10**6:\n            time += 1\n        else:\n            time += abs(prizes[i] - 1) + abs(prizes[i] - 10**6)\n\n    return str(time)"
    },
    {
        "number": 568,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(n):\n        for a in range(1, 4):\n            for b in range(1, 4):\n                for c in range(1, 4):\n                    if a + b + c + n + a + 2*n != 6:\n                        count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 569,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    \n    if n == 1:\n        return 0\n    \n    substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    \n    if len(substrings) == n*(n+1)//2:\n        return 0\n    \n    min_changes = n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i:j] in substrings:\n                min_changes = min(min_changes, n-j+i+1)\n    \n    return min_changes if min_changes != n else -1"
    },
    {
        "number": 570,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 1:\n        return \"Valera\"\n    if b == 1:\n        return \"Vladik\"\n    if a % 2 == 0:\n        return \"Valera\"\n    if b % 2 == 0:\n        return \"Vladik\"\n    return \"Valera\""
    },
    {
        "number": 571,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_correct(seq: str) -> bool:\n        stack = []\n        for c in seq:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack or stack[-1] == \")\":\n                    return False\n                stack.pop()\n        return not stack\n\n    def replace_question_marks(s: str) -> str:\n        if \"()\" in s:\n            return \":\"\n        for i in range(1, len(s)):\n            if s[i] == \"?\":\n                if is_correct(s[:i] + \"(\" + s[i+1:]):\n                    return s[:i] + \"(\" + s[i+1:]\n                if is_correct(s[:i] + \")\" + s[i+1:]):\n                    return s[:i] + \")\" + s[i+1:]\n        return \":\"\n\n    return replace_question_marks(s)"
    },
    {
        "number": 572,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    coefficients = list(map(int, stdin.split()[2:]))\n\n    valid_coefficients = [coefficient for coefficient in coefficients if abs(coefficient) <= k]\n    if len(valid_coefficients) != len(coefficients) or valid_coefficients[-1] == 0:\n        return \"0\"\n\n    count = 0\n    for i in range(len(valid_coefficients)):\n        if valid_coefficients[i] != 0:\n            valid_coefficients[i] = -valid_coefficients[i]\n            if valid_coefficients[i] != coefficients[i]:\n                count += 1\n            valid_coefficients[i] = -valid_coefficients[i]\n\n    return str(count)\n"
    },
    {
        "number": 573,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    groups = list(map(int, stdin.split()[1:]))\n\n    # Count the number of teams that can be formed with two people\n    two_people_teams = sum([min(groups[i], groups[j]) for i in range(n) for j in range(i+1, n) if groups[i] + groups[j] == 2])\n\n    # Count the number of teams that can be formed with one person\n    one_person_teams = sum([groups[i] for i in range(n) if groups[i] == 1])\n\n    # Calculate the maximum number of teams that can be formed\n    max_teams = min(two_people_teams, one_person_teams)\n\n    return str(max_teams)"
    },
    {
        "number": 574,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2 = map(int, stdin.split())\n    width = x_2 - x_1 + 1\n    height = y_2 - y_1 + 1\n    if width % 2 == 0:\n        return str((width // 2) * height)\n    else:\n        return str((width // 2 + 1) * height)"
    },
    {
        "number": 575,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    def is_check(x, y):\n        return (x == a_x and y == a_y) or (x == b_x and y == b_y) or (x == c_x and y == c_y)\n\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= n and not is_check(x, y)\n\n    def is_king_in_check(x, y):\n        return (x == a_x and y == a_y) or (x == b_x and y == b_y) or (x == c_x and y == c_y)\n\n    def is_king_in_check_after_move(x, y):\n        return is_king_in_check(x, y) or is_king_in_check(x + 1, y) or is_king_in_check(x - 1, y) or is_king_in_check(x, y + 1) or is_king_in_check(x, y - 1) or is_king_in_check(x + 1, y + 1) or is_king_in_check(x + 1, y - 1) or is_king_in_check(x - 1, y + 1) or is_king_in_check(x - 1, y - 1)\n\n    if is_king_in_check(b_x, b_y):\n        return \"NO\"\n\n    visited = set()\n    queue = [(b_x, b_y)]\n\n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) == (c_x, c_y):\n            return \"YES\"\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid_move(nx, ny) and not is_king_in_check_after_move(nx, ny):\n                    queue.append((nx, ny))\n\n    return \"NO\""
    },
    {
        "number": 576,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_lcm = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            lcm = a[i] * a[j] // math.gcd(a[i], a[j])\n            max_lcm = max(max_lcm, lcm)\n\n    return str(max_lcm)"
    },
    {
        "number": 577,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shrubs = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[2:])\n        shrubs.append((a, b))\n\n    max_baskets = 0\n    for i in range(n):\n        for j in range(i, n):\n            red_berries = shrubs[i][0] + shrubs[j][0]\n            blue_berries = shrubs[i][1] + shrubs[j][1]\n            if red_berries >= k and blue_berries >= k:\n                max_baskets += min(red_berries // k, blue_berries // k)\n            elif red_berries >= k:\n                max_baskets += red_berries // k\n            elif blue_berries >= k:\n                max_baskets += blue_berries // k\n\n    return str(max_baskets)"
    },
    {
        "number": 578,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d, b = map(int, stdin.split('e'))\n    x = a * 10**b\n    if x == int(x):\n        return str(int(x))\n    else:\n        p, q = str(x).split('.')\n        while q[-1] == '0':\n            q = q[:-1]\n        return p + '.' + q"
    },
    {
        "number": 579,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:]))\n\n    def max_score(start: int, moves: int) -> int:\n        if moves == 0:\n            return C[P[start]]\n        max_score_so_far = 0\n        for i in range(N):\n            if i != start and P[i] != start:\n                max_score_so_far = max(max_score_so_far, max_score(i, moves - 1))\n        return C[P[start]] + max_score_so_far\n\n    max_score_so_far = 0\n    for i in range(N):\n        max_score_so_far = max(max_score_so_far, max_score(i, K))\n\n    return str(max_score_so_far)"
    },
    {
        "number": 580,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[4:]]\n\n    def dijkstra(start: int, end: int) -> int:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        visited = [False] * (n + 1)\n\n        while not visited[end]:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(1, n + 1):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            visited[min_node] = True\n\n            for a, b, l in roads:\n                if a == min_node:\n                    dist[b] = min(dist[b], dist[a] + l)\n\n        return dist[end]\n\n    def can_repair(start: int, end: int, l: int) -> bool:\n        for a, b, time in roads:\n            if a == start and b == end and time == l:\n                return False\n        return True\n\n    for a, b, l in roads:\n        if a == s and b == t:\n            print(\"YES\")\n            break\n        else:\n            if dijkstra(s, t) == dijkstra(a, b) + l:\n                print(\"CAN\", dijkstra(a, b) + l - l)\n            elif can_repair(s, t, dijkstra(a, b) + l):\n                print(\"CAN\", dijkstra(a, b) + l - l)\n            else:\n                print(\"NO\")"
    },
    {
        "number": 581,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    answer = 0\n    operations = []\n\n    def dfs(node, visited, path_length):\n        nonlocal answer\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path_length + graph[node][neighbor])\n        if len(visited) == n:\n            answer = max(answer, path_length)\n\n    graph = {i: {} for i in range(1, n + 1)}\n    for a, b in edges:\n        graph[a][b] = graph[b][a] = 1\n\n    dfs(1, [False] * n, 0)\n\n    for i in range(n - 1):\n        leaves = [node for node in graph if len(graph[node]) == 1]\n        leaf1, leaf2 = sorted(leaves)\n        path_length = graph[leaf1][leaf2]\n        operations.append((leaf1, leaf2, leaf1))\n        operations.append((leaf1, leaf2, leaf2))\n        answer += path_length\n        del graph[leaf1]\n        del graph[leaf2]\n        for node in graph:\n            if leaf1 in graph[node]:\n                del graph[node][leaf1]\n            if leaf2 in graph[node]:\n                del graph[node][leaf2]\n\n    return str(answer) + '\\n' + '\\n'.join(f\"{a} {b} {c}\" for a, b, c in operations)"
    },
    {
        "number": 582,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_str, t_str = stdin.split()\n    n = int(n)\n    a = list(map(int, a_str.split()))\n    t = list(map(int, t_str.split()))\n\n    total_time = 0\n    for i in range(n):\n        if a[i] == 1:\n            continue\n        total_time += (a[i] - 1) * t[i]\n\n    return str(total_time)"
    },
    {
        "number": 583,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    max_beauty = 0\n    max_l, max_r = 1, 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n            beauty = 0\n            for k in range(n):\n                if new_s[k:k+n] == new_s[k+1:k+n+1]:\n                    beauty += 1\n            if beauty > max_beauty:\n                max_beauty = beauty\n                max_l, max_r = i + 1, j + 1\n\n    return str(max_beauty) + \"\\n\" + str(max_l) + \" \" + str(max_r)"
    },
    {
        "number": 584,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words_outside = []\n    words_inside = []\n    inside = False\n    word = \"\"\n\n    for char in stdin:\n        if char == \"_\":\n            if word:\n                if inside:\n                    words_inside.append(word)\n                else:\n                    words_outside.append(word)\n                word = \"\"\n        elif char == \"(\":\n            inside = True\n        elif char == \")\":\n            if word:\n                words_inside.append(word)\n            word = \"\"\n            inside = False\n        else:\n            word += char\n\n    longest_word_outside = max(words_outside, key=len, default=0)\n    num_words_inside = len(words_inside)\n\n    return f\"{len(longest_word_outside)} {num_words_inside}\"\n"
    },
    {
        "number": 585,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:]))\n    \n    def is_valid(partition):\n        for i in range(m):\n            if partition[i][0] != b[i]:\n                return False\n        return True\n    \n    def partition(arr, m):\n        if m == 1:\n            return [arr]\n        partitions = []\n        for i in range(1, len(arr)):\n            left = partition(arr[:i], m-1)\n            right = partition(arr[i:], m-1)\n            for l in left:\n                for r in right:\n                    partitions.append(l + [arr[i-1]] + r)\n        return partitions\n    \n    valid_partitions = list(filter(is_valid, partition(a, m)))\n    return str(len(valid_partitions) % 998244353)"
    },
    {
        "number": 586,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_suitable_colorings(n: int, k: int) -> int:\n        if n == 1:\n            return 2\n\n        count = 0\n        for i in range(2):\n            for j in range(2):\n                for l in range(2):\n                    for m in range(2):\n                        if i == l and j == m:\n                            continue\n                        if i == l:\n                            continue\n                        if j == m:\n                            continue\n                        count += count_suitable_colorings(n - 1, k - 1)\n        return count % MOD\n\n    return str(count_suitable_colorings(n, k))"
    },
    {
        "number": 587,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    sushi = []\n    for line in stdin.split('\\n')[2:]:\n        t, d = map(int, line.split())\n        sushi.append((t, d))\n\n    sushi.sort(key=lambda x: x[1], reverse=True)\n    satisfaction = 0\n    toppings = set()\n    for i in range(K):\n        satisfaction += sushi[i][1]\n        toppings.add(sushi[i][0])\n\n    satisfaction += len(toppings) * len(toppings)\n    return str(satisfaction)"
    },
    {
        "number": 588,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_engines = int(lines[0])\n    engines = []\n    for i in range(1, num_engines + 1):\n        x, y = map(int, lines[i].split())\n        engines.append((x, y))\n\n    max_distance = 0\n    for i in range(1, 2 ** num_engines):\n        binary_representation = bin(i)[2:].zfill(num_engines)\n        x, y = 0, 0\n        for j in range(num_engines):\n            if binary_representation[j] == '1':\n                x += engines[j][0]\n                y += engines[j][1]\n        distance = (x ** 2 + y ** 2) ** 0.5\n        max_distance = max(max_distance, distance)\n\n    return f\"{max_distance:.10f}\""
    },
    {
        "number": 589,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_variants(s: str) -> int:\n        if s.count(\"?\") == len(s):\n            return 10 ** len(s)\n        if \"A\" in s:\n            return count_variants(s.replace(\"A\", \"1\", 1)) * 9\n        if \"B\" in s:\n            return count_variants(s.replace(\"B\", \"2\", 1)) * 9\n        if \"C\" in s:\n            return count_variants(s.replace(\"C\", \"3\", 1)) * 9\n        if \"D\" in s:\n            return count_variants(s.replace(\"D\", \"4\", 1)) * 9\n        if \"E\" in s:\n            return count_variants(s.replace(\"E\", \"5\", 1)) * 9\n        if \"F\" in s:\n            return count_variants(s.replace(\"F\", \"6\", 1)) * 9\n        if \"G\" in s:\n            return count_variants(s.replace(\"G\", \"7\", 1)) * 9\n        if \"H\" in s:\n            return count_variants(s.replace(\"H\", \"8\", 1)) * 9\n        if \"I\" in s:\n            return count_variants(s.replace(\"I\", \"9\", 1)) * 9\n        if \"J\" in s:\n            return count_variants(s.replace(\"J\", \"0\", 1)) * 9\n        return 0\n\n    return str(count_variants(stdin))"
    },
    {
        "number": 590,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n    \n    # Check if the array is already a permutation\n    if sorted(array) == list(range(1, n+1)):\n        return \"0\\n\" + \" \".join(map(str, array))\n    \n    # Find the minimum number of changes\n    min_changes = n\n    for i in range(n):\n        for j in range(i+1, n):\n            if array[i] > array[j]:\n                min_changes = min(min_changes, n-i-j)\n    \n    # Find the lexicographically minimal permutation\n    permutation = sorted(array)\n    for i in range(n):\n        if permutation[i] != i+1:\n            for j in range(i+1, n):\n                if permutation[j] == i+1:\n                    permutation[i], permutation[j] = permutation[j], permutation[i]\n                    break\n    \n    return str(min_changes) + \"\\n\" + \" \".join(map(str, permutation))"
    },
    {
        "number": 591,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    light_schedule = list(map(int, stdin.split()[2:]))\n\n    def find_min_light(light_schedule: List[int], k: int) -> int:\n        min_light = float('inf')\n        for i in range(len(light_schedule) - k + 1):\n            min_light = min(min_light, min(light_schedule[i:i+k]))\n        return min_light\n\n    min_light = find_min_light(light_schedule, k)\n    reading_hours = []\n\n    for i in range(len(light_schedule) - k + 1):\n        if light_schedule[i:i+k] == [min_light] * k:\n            reading_hours.append(i+1)\n\n    return f\"{min_light}\\n{' '.join(map(str, reading_hours))}\""
    },
    {
        "number": 592,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n    for a in range(2, n + 1):\n        for b in range(2, n + 1):\n            if a != b:\n                for x in range(2, n + 1):\n                    if (a * x == b or b * x == a) and abs(x) > 1:\n                        max_score = max(max_score, abs(x))\n    return str(max_score)"
    },
    {
        "number": 593,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    votes = [list(map(int, input().split())) for _ in range(m)]\n\n    # Count votes for each candidate in each city\n    candidate_votes = [[0] * n for _ in range(n)]\n    for i in range(m):\n        for j in range(n):\n            candidate_votes[j][votes[i][j]] += 1\n\n    # Find the winner of the first stage\n    max_votes = 0\n    winner = 0\n    for i in range(n):\n        if candidate_votes[i].count(max(candidate_votes[i])) > 1:\n            if i < winner:\n                winner = i\n        else:\n            if max(candidate_votes[i]) > max_votes:\n                max_votes = max(candidate_votes[i])\n                winner = i\n\n    # Find the winner of the second stage\n    max_cities = 0\n    for i in range(n):\n        if candidate_votes[i].count(max_votes) > max_cities:\n            max_cities = candidate_votes[i].count(max_votes)\n\n    return str(winner + 1)"
    },
    {
        "number": 594,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    correct_times = list(map(int, stdin.split()[2:2+n]))\n    wrong_times = list(map(int, stdin.split()[2+n:]))\n    \n    for v in range(1, 101):\n        correct_passed = False\n        correct_extra_time = False\n        wrong_passed = False\n        \n        for time in correct_times:\n            if time <= v:\n                correct_passed = True\n            elif 2*time <= v:\n                correct_extra_time = True\n        \n        for time in wrong_times:\n            if time <= v:\n                wrong_passed = True\n        \n        if correct_passed and correct_extra_time and not wrong_passed:\n            return str(v)\n    \n    return \"-1\""
    },
    {
        "number": 595,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    days_in_year = 365\n    days_in_leap_year = 366\n    days_in_week = 7\n\n    def is_leap_year(year: int) -> bool:\n        if year % 400 == 0:\n            return True\n        elif year % 100 == 0:\n            return False\n        elif year % 4 == 0:\n            return True\n        else:\n            return False\n\n    def get_days_in_year(year: int) -> int:\n        if is_leap_year(year):\n            return days_in_leap_year\n        else:\n            return days_in_year\n\n    def get_day_of_week(day: int, year: int) -> int:\n        days_in_previous_years = sum(get_days_in_year(y) for y in range(1, year))\n        days_in_previous_years += day\n        return days_in_previous_years % days_in_week\n\n    def get_next_year(year: int) -> int:\n        next_year = year + 1\n        while True:\n            if get_day_of_week(1, next_year) == 1:\n                return next_year\n            next_year += 1\n\n    return str(get_next_year(y))"
    },
    {
        "number": 596,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            return 31\n        elif month in [4, 6, 9, 11]:\n            return 30\n        elif is_leap_year(year):\n            return 29\n        else:\n            return 28\n\n    def days_between_dates(date1: str, date2: str) -> int:\n        year1, month1, day1 = map(int, date1.split(':'))\n        year2, month2, day2 = map(int, date2.split(':'))\n\n        days = 0\n        while True:\n            days += days_in_month(year1, month1)\n            if year1 == year2 and month1 == month2:\n                break\n            if month1 == 12:\n                year1 += 1\n                month1 = 1\n            else:\n                month1 += 1\n\n        days += day2\n        return days\n\n    date1, date2 = stdin.split('\\n')\n    return str(days_between_dates(date1, date2))"
    },
    {
        "number": 597,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    attacked_cities = list(map(int, stdin.split('\\n')[-1].split()))\n\n    # Calculate the shortest path from each attacked city to the closest city being attacked\n    shortest_paths = []\n    for attacked_city in attacked_cities:\n        visited = [False] * (n + 1)\n        queue = [(0, attacked_city)]\n        visited[attacked_city] = True\n\n        while queue:\n            distance, city = queue.pop(0)\n            for u, v in roads:\n                if not visited[v]:\n                    visited[v] = True\n                    queue.append((distance + 1, v))\n\n            if visited[attacked_city]:\n                shortest_paths.append((distance, attacked_city))\n                break\n\n    # Calculate the shortest path from each city to the closest city being attacked\n    shortest_paths_to_attacked_cities = []\n    for i in range(1, n + 1):\n        if i not in attacked_cities:\n            visited = [False] * (n + 1)\n            queue = [(0, i)]\n            visited[i] = True\n\n            while queue:\n                distance, city = queue.pop(0)\n                for u, v in roads:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append((distance + 1, v))\n\n                if visited[attacked_cities[0]]:\n                    shortest_paths_to_attacked_cities.append((distance, i))\n                    break\n\n    # Calculate the minimum time needed to scare all humans in cities being attacked\n    min_time = min(shortest_paths, key=lambda x: x[0])[0] * kron\n\n    # Calculate the city to teleport to\n    teleport_city = min(shortest_paths_to_attacked_cities, key=lambda x: x[0])[1]\n\n    return str(teleport_city) + \"\\n\" + str(min_time)"
    },
    {
        "number": 598,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    vouchers = []\n    for line in stdin.split('\\n')[1:]:\n        l, r, cost = map(int, line.split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort(key=lambda x: x[0])\n    min_cost = float('inf')\n    for i in range(len(vouchers)):\n        for j in range(i + 1, len(vouchers)):\n            if vouchers[j][0] > vouchers[i][1]:\n                if vouchers[i][2] + vouchers[j][2] <= min_cost:\n                    min_cost = vouchers[i][2] + vouchers[j][2]\n\n    if min_cost == float('inf'):\n        return '-1'\n    else:\n        return str(min_cost)"
    },
    {
        "number": 599,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for i in range(n):\n        s.append(s[i])\n    for i in range(n):\n        if s[i:i+n] == s[i:i+n][::-1]:\n            return \"\".join(s)\n    return \"NA\""
    },
    {
        "number": 600,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    if a > b:\n        a, b = b, a\n    return str(abs(a - b) * (abs(a - b) + 1) // 2)"
    },
    {
        "number": 601,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_weapons(p, f, cnt_s, cnt_w, s, w):\n        max_swords = min(p, cnt_s)\n        max_war_axes = min(f, cnt_w)\n        return max_swords + max_war_axes\n\n    result = []\n    for case in stdin.strip().split(\"\\n\"):\n        p, f, cnt_s, cnt_w, s, w = map(int, case.split())\n        result.append(str(find_max_weapons(p, f, cnt_s, cnt_w, s, w)))\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 602,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    presidents = [\"Adams\", \"Bush\", \"Clinton\", \"Eisenhower\", \"Ford\", \"Harrison\", \"Harding\", \"Johnson\", \"Kennedy\", \"Lincoln\", \"Madison\", \"Monroe\", \"Nixon\", \"Obama\", \"Pierce\", \"Reagan\", \"Roosevelt\", \"Truman\", \"Taft\", \"Van Buren\"]\n    a = int(stdin)\n    return presidents[a-1] "
    },
    {
        "number": 603,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    red_bouquets = r // 3\n    green_bouquets = g // 3\n    blue_bouquets = b // 3\n    mixing_bouquets = min(r, g, b) // 3\n    return str(red_bouquets + green_bouquets + blue_bouquets + mixing_bouquets)"
    },
    {
        "number": 604,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *array = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        if array[i] != 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 605,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p = max(a, b)\n    t = min(c, d)\n    misha_points = max(p * 3 // 10, p - p // 250 * t)\n    vasya_points = max(b * 3 // 10, b - b // 250 * t)\n    if misha_points > vasya_points:\n        return \"Misha\"\n    elif misha_points < vasya_points:\n        return \"Vasya\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 606,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, x_1, y_1, x_2, y_2 = map(float, stdin.split())\n    \n    # Calculate the distance between Fafa's laptop and the center of the flat\n    distance = ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5\n    \n    # Calculate the radius of the access point range\n    r = (R ** 2 - distance ** 2) ** 0.5\n    \n    # Calculate the position of the access point\n    x_ap = x_1 + (x_2 - x_1) * (R - distance) / distance\n    y_ap = y_1 + (y_2 - y_1) * (R - distance) / distance\n    \n    return f\"{x_ap:.6f} {y_ap:.6f} {r:.6f}\""
    },
    {
        "number": 607,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    happiness = 0\n    for perm in itertools.permutations(range(1, n+1)):\n        happiness += count_framed_segments(perm)\n    return str(happiness % m)\n\ndef"
    },
    {
        "number": 609,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    paper = [list(line) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_x(paper: List[List[str]]) -> bool:\n        diagonal1 = [paper[i][i] for i in range(n)]\n        diagonal2 = [paper[i][n-i-1] for i in range(n)]\n\n        if len(set(diagonal1)) != 1 or len(set(diagonal2)) != 1:\n            return False\n\n        for i in range(n):\n            for j in range(n):\n                if (i != j and i != n-j-1) and paper[i][j] != diagonal1[0]:\n                    return False\n\n        return True\n\n    return \"YES\" if is_x(paper) else \"NO\""
    },
    {
        "number": 610,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = 0\n    vasyas_points = 0\n\n    if n > m:\n        petya_points += n - m\n        vasyas_points += m\n    else:\n        petya_points += m - n\n        vasyas_points += n\n\n    return f\"{petya_points} {vasyas_points}\""
    },
    {
        "number": 611,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    changes = [list(map(int, line.split())) for line in stdin.split('\\n')[2:2+m]]\n    \n    def apply_change(arr, i, x, d):\n        for j in range(n):\n            arr[j] += x + d * abs(i - j)\n        return arr\n    \n    max_mean = -float('inf')\n    for i in range(1, n+1):\n        arr = [0] * n\n        for change in changes:\n            x, d = change\n            arr = apply_change(arr, i, x, d)\n        mean = sum(arr) / n\n        max_mean = max(max_mean, mean)\n    \n    return f\"{max_mean:.6f}\""
    },
    {
        "number": 612,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def is_partitionable(a: List[int], k: int, p: int) -> bool:\n        if k == 1:\n            return True\n        if len(a) < k:\n            return False\n        if len(a) % k != 0:\n            return False\n        if p > k:\n            return False\n        if p == 0:\n            return True\n        if p == k:\n            return all(sum(a[i:i+k]) % 2 == 0 for i in range(0, len(a), k))\n        if p < k:\n            return any(sum(a[i:i+k]) % 2 == 0 for i in range(0, len(a), k)) and all(sum(a[i:i+k]) % 2 != 0 for i in range(0, len(a), k) if i % (k - p) != 0)\n\n    if is_partitionable(a, k, p):\n        parts = [a[i:i+k] for i in range(0, len(a), k)]\n        even_parts = [part for part in parts if sum(part) % 2 == 0]\n        odd_parts = [part for part in parts if sum(part) % 2 != 0]\n        return \"YES\\n\" + \"\\n\".join(f\"{len(part)} {' '.join(map(str, part))}\" for part in even_parts[:p] + odd_parts[:k-p])\n    else:\n        return \"NO\""
    },
    {
        "number": 613,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    if a == b:\n        return \"inf\"\n    elif a == 1:\n        return \"1\"\n    elif b == 1:\n        return \"1\"\n    else:\n        return str((a * b) % (10**9 + 7))"
    },
    {
        "number": 614,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    souvenirs = []\n    for _ in range(n):\n        w, c = map(int, input().split())\n        souvenirs.append((w, c))\n\n    souvenirs.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    total_cost = 0\n    total_weight = 0\n    for w, c in souvenirs:\n        if total_weight + w <= m:\n            total_cost += c\n            total_weight += w\n\n    return str(total_cost)"
    },
    {
        "number": 615,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_diff = float('inf')\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            for k in range(j + 1, N - 1):\n                for l in range(k + 1, N):\n                    B = A[:i]\n                    C = A[i:j]\n                    D = A[j:k]\n                    E = A[k:l]\n                    P = sum(B)\n                    Q = sum(C)\n                    R = sum(D)\n                    S = sum(E)\n                    diff = max(P, Q, R, S) - min(P, Q, R, S)\n                    min_diff = min(min_diff, diff)\n\n    return str(min_diff)"
    },
    {
        "number": 616,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    boxes = [[] for _ in range(N+1)]\n    for i in range(1, M+1):\n        a, b = map(int, lines[i].split())\n        for j in range(1, b+1):\n            box_num = int(lines[i].split()[j])\n            boxes[box_num].append(i)\n\n    def dfs(box_num: int, keys: set, cost: int) -> int:\n        if box_num == N+1:\n            return cost\n        min_cost = float('inf')\n        for key in keys:\n            for box in boxes[box_num]:\n                if key in boxes[box_num]:\n                    min_cost = min(min_cost, dfs(box_num+1, keys - {key}, cost+a))\n        return min_cost\n\n    min_cost = dfs(1, set(range(1, M+1)), 0)\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 617,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, char in enumerate(stdin):\n        if char.isdigit():\n            if i % 2 == 0:\n                stack.append(char)\n            else:\n                stack.append(char)\n        else:\n            if char == '+':\n                stack.append(int(stack.pop()) + int(stack.pop()))\n            else:\n                stack.append(int(stack.pop()) * int(stack.pop()))\n    return str(stack[0])\n\ndef"
    },
    {
        "number": 618,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    left_weights, right_weights = stdin.split(\"|\")\n    left_weights = left_weights.split(\",\")\n    right_weights = right_weights.split(\",\")\n    left_sum = sum(map(lambda x: 1, left_weights))\n    right_sum = sum(map(lambda x: 1, right_weights))\n    unused_weights = list(input().strip())\n\n    if left_sum != right_sum:\n        return \"Impossible\"\n\n    for weight in unused_weights:\n        if weight not in left_weights and weight not in right_weights:\n            if left_sum < right_sum:\n                left_weights.append(weight)\n                left_sum += 1\n            else:\n                right_weights.append(weight)\n                right_sum += 1\n\n    if left_sum == right_sum:\n        return \"|\".join(left_weights) + \"|\" + \",\".join(right_weights)\n    else:\n        return \"Impossible\""
    },
    {
        "number": 619,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    coconuts_sasha = x // z\n    coconuts_masha = y // z\n    total_coconuts = coconuts_sasha + coconuts_masha\n    min_chizhiks = min(x, y) % z\n    return f\"{total_coconuts} {min_chizhiks}\""
    },
    {
        "number": 620,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()]\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    def slope(x1, y1, x2, y2):\n        return (y2 - y1) / (x2 - x1)\n\n    s1 = slope(x1, y1, x2, y2)\n    s2 = slope(x2, y2, x3, y3)\n\n    if s1 == s2:\n        return \"0\\n\"\n\n    k = 0\n    for x4, y4 in [(x1, y2), (x2, y3), (x3, y1)]:\n        if x4 == x1 or x4 == x2 or x4 == x3 or y4 == y1 or y4 == y2 or y4 == y3:\n            continue\n        if (x1 * (y2 - y4) + x2 * (y4 - y1) + x4 * (y1 - y2)) == 0:\n            continue\n        k += 1\n        print(x4, y4)\n\n    return f\"{k}\\n\""
    },
    {
        "number": 621,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n    \n    loss_count = 0\n    folders = []\n    current_folder = []\n    \n    for i in range(n):\n        if a[i] < 0:\n            loss_count += 1\n        current_folder.append(a[i])\n        \n        if loss_count >= 3 or i == n-1:\n            folders.append(current_folder)\n            current_folder = []\n            loss_count = 0\n            \n    k = len(folders)\n    b = [len(folder) for folder in folders]\n    \n    return f\"{k}\\n{' '.join(map(str, b))}\""
    },
    {
        "number": 622,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        min_positive_integer = 1\n        while min_positive_integer in sequence:\n            min_positive_integer += 1\n        sequence.append(min_positive_integer)\n        sequence.insert(len(sequence) // 2, min_positive_integer)\n    return str(sequence[k - 1])"
    },
    {
        "number": 623,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    minutes = 0\n    while a_1 > 0 and a_2 > 0:\n        minutes += 1\n        a_1 = max(0, a_1 - 2)\n        a_2 = max(0, a_2 - 2)\n        if a_1 < 100:\n            a_1 += 1\n        if a_2 < 100:\n            a_2 += 1\n    return str(minutes)"
    },
    {
        "number": 624,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    powers = list(map(int, stdin.split()[3:]))\n\n    def max_average(powers, m, k):\n        powers.sort(reverse=True)\n        total_power = sum(powers)\n        max_average = total_power / len(powers)\n\n        for i in range(min(m, len(powers) - 1)):\n            max_average = max(max_average, (total_power - powers.pop(0)) / len(powers))\n\n        for i in range(min(k, len(powers))):\n            max_average = max(max_average, (total_power + 1) / len(powers))\n            powers[i] += 1\n\n        return max_average\n\n    return f\"{max_average(powers, m, k):.10f}\""
    },
    {
        "number": 625,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**(i+1) * i\n    return str(result)"
    },
    {
        "number": 626,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    changes = 0\n    current_direction = 1\n    current_position = 0\n    for i in range(n):\n        if current_position == i:\n            current_position += a[i]\n            if current_position >= n:\n                current_position -= n\n                current_direction *= -1\n                changes += 1\n    return str(changes)"
    },
    {
        "number": 627,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    if n == 1:\n        return \"\"\n\n    min_string = s\n    for i in range(n):\n        new_string = s[:i] + s[i+1:]\n        if new_string < min_string:\n            min_string = new_string\n\n    return min_string"
    },
    {
        "number": 628,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    books = list(map(int, stdin.split()[2:]))\n\n    def bitwise_and(shelves: List[int]) -> int:\n        result = shelves[0]\n        for shelf in shelves[1:]:\n            result &= shelf\n        return result\n\n    def max_beauty(books: List[int], k: int) -> int:\n        books.sort(reverse=True)\n        shelves = [0] * k\n        for i in range(len(books)):\n            shelves[i % k] += books[i]\n        return bitwise_and(shelves)\n\n    return str(max_beauty(books, k))"
    },
    {
        "number": 629,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n    \n    total_time = 0\n    total_time += b[0]\n    for i in range(n - 1):\n        total_time += a[i]\n    total_time += b[n - 1]\n    total_time += b[0]\n    \n    return str(total_time)"
    },
    {
        "number": 630,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    links = list(map(int, stdin.split()[2:]))\n\n    def dfs(message: int, visited: set) -> set:\n        if message == 0 or message in visited:\n            return visited\n        visited.add(message)\n        return dfs(links[message - 1], visited)\n\n    result = []\n    for i in range(1, n + 1):\n        result.append(len(dfs(i, set())))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 631,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sum_of_sums(a):\n        n = len(a)\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                total += a[j] / (j + 1)\n        return total\n\n    def can_reorder(a, m):\n        a_sum = sum(a)\n        a_sorted = sorted(a, reverse=True)\n        a_sum_sorted = sum_of_sums(a_sorted)\n        return a_sum_sorted == m or a_sum_sorted == m + 1\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        if can_reorder(a, m):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 632,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        current_n = n\n\n        for _ in range(k):\n            current_n += f(current_n)\n\n        result.append(current_n)\n\n    return \"\\n\".join(map(str, result))\n\ndef"
    },
    {
        "number": 633,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n * (n - 1) // 2 < m:\n        return \"Impossible\"\n\n    edges = []\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if len(edges) == m:\n                break\n            edges.append((i, j))\n\n    return \"Possible\\n\" + \"\\n\".join(f\"{v} {u}\" for v, u in edges)\n\n\ndef"
    },
    {
        "number": 634,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed = set(tuple(map(int, line.split())) for line in stdin.split('\\n')[2:])\n\n    if n == r:\n        return \"WIN\"\n\n    for i in range(1, r + 1):\n        for j in range(1, 3):\n            if (i, j) not in reclaimed:\n                if (i - 1, 3 - j) not in reclaimed and (i, 3 - j) not in reclaimed and (i + 1, 3 - j) not in reclaimed:\n                    return \"WIN\"\n\n    return \"LOSE\"\n"
    },
    {
        "number": 635,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:]))\n    \n    if a[s-1] == 1 and b[n-s] == 1:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 636,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, instruments = map(int, stdin.split())\n    instruments = list(map(int, instruments.split()))\n\n    instruments.sort(reverse=True)\n    max_instruments = 0\n    for i in range(len(instruments)):\n        if k >= instruments[i]:\n            max_instruments += 1\n            k -= instruments[i]\n        else:\n            break\n\n    return str(max_instruments) + \"\\n\" + \" \".join(map(str, range(1, max_instruments + 1)))\n"
    },
    {
        "number": 637,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, photo = stdin.split()\n    n = int(n)\n    photo = [int(x) for x in photo.split()]\n\n    if len(photo) != n:\n        return \"NO\"\n\n    stripe_length = 0\n    stripe_color = None\n    for pixel in photo:\n        if stripe_color is None:\n            stripe_color = pixel\n            stripe_length += 1\n        elif stripe_color == pixel:\n            stripe_length += 1\n        else:\n            if stripe_length == 1:\n                stripe_color = pixel\n                stripe_length += 1\n            else:\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 638,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[0:2])\n    times = list(map(int, stdin.split()[2:]))\n    result = []\n\n    for i in range(n):\n        count = 0\n        for j in range(i):\n            if times[j] > M - sum(times[i+1:]) - count:\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 639,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    set_numbers = set(map(int, input().split()))\n\n    if x == 0:\n        return str(len(set_numbers))\n\n    mex = 0\n    while mex in set_numbers:\n        mex += 1\n\n    operations = 0\n    while mex != x:\n        if mex in set_numbers:\n            set_numbers.remove(mex)\n        else:\n            set_numbers.add(mex)\n        operations += 1\n        mex += 1\n\n    return str(operations)\n"
    },
    {
        "number": 640,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    first_wins = 0\n    draw = 0\n    second_wins = 0\n\n    for i in range(1, 7):\n        diff_a = abs(a - i)\n        diff_b = abs(b - i)\n\n        if diff_a < diff_b:\n            first_wins += 1\n        elif diff_a == diff_b:\n            draw += 1\n        else:\n            second_wins += 1\n\n    return f\"{first_wins} {draw} {second_wins}\""
    },
    {
        "number": 641,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plan = stdin.split()\n    if plan[1] == \"of\":\n        if plan[2] == \"week\":\n            return str(52)\n        elif plan[2] == \"month\":\n            return str(11)\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 642,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    dirty_stairs = set(map(int, stdin.split()[2:]))\n\n    if 1 in dirty_stairs or n in dirty_stairs:\n        return \"NO\"\n\n    for i in range(2, n):\n        if i in dirty_stairs:\n            continue\n        if i - 1 not in dirty_stairs and i + 1 not in dirty_stairs:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 643,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_possible(x, y, p, q):\n        return p * y >= x * q\n\n    def smallest_submissions(x, y, p, q):\n        l = lcm(x, y)\n        return l // y * p + l // x * (q - p)\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        x, y, p, q = map(int, stdin.readline().split())\n\n        if not is_possible(x, y, p, q):\n            result.append(-1)\n        else:\n            result.append(smallest_submissions(x, y, p, q))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 644,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1:]\n\n    x = 0\n    for command in commands:\n        if command == \"add\":\n            x += 1\n        elif command.startswith(\"for\"):\n            n = int(command.split()[1])\n            for _ in range(n):\n                x += 1\n                if x > 2**32 - 1:\n                    return \"OVERFLOW!!!\"\n\n    return str(x)"
    },
    {
        "number": 645,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    even_digits = {'0', '2', '4', '6', '8'}\n    flipped_cards = 0\n    \n    for char in stdin:\n        if char.isalpha():\n            if char in vowels:\n                flipped_cards += 1\n        elif char in even_digits:\n            continue\n        else:\n            flipped_cards += 1\n    \n    return flipped_cards"
    },
    {
        "number": 646,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    detachments = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        detachments.append((x, y))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def check_detachments(t):\n        visited = set()\n        for detachment in detachments:\n            visited.add(detachment)\n            x, y = detachment\n            for i in range(t):\n                x += 1\n                if (x, y) in detachments:\n                    visited.add((x, y))\n                    break\n                if (x, y) in visited:\n                    break\n            for i in range(t):\n                y += 1\n                if (x, y) in detachments:\n                    visited.add((x, y))\n                    break\n                if (x, y) in visited:\n                    break\n            for i in range(t):\n                x -= 1\n                if (x, y) in detachments:\n                    visited.add((x, y))\n                    break\n                if (x, y) in visited:\n                    break\n            for i in range(t):\n                y -= 1\n                if (x, y) in detachments:\n                    visited.add((x, y))\n                    break\n                if (x, y) in visited:\n                    break\n        return len(visited) == len(detachments)\n\n    for i in range(n):\n        if check_detachments(i):\n            return str(i)\n\n    for i in range(n, 2 * n):\n        if check_detachments(i):\n            return str(i)\n\n    return \"-1\""
    },
    {
        "number": 647,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = stdin.split()[1]\n    lefthanders = [i for i in range(1, n+1) if students[i-1] == \"L\"]\n    righthanders = [i for i in range(1, n+1) if students[i-1] == \"R\"]\n    result = []\n\n    for i in range(1, n+1, 2):\n        if i in lefthanders:\n            result.append(str(i) + \" \" + str(i+1))\n        elif i in righthanders:\n            result.append(str(i-1) + \" \" + str(i))\n        else:\n            result.append(str(i-1) + \" \" + str(i+1))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 648,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    max_bananas = 0\n\n    for x in range(1001):\n        y = -x // m + b\n        if 0 <= y <= 10000:\n            bananas = x + y\n            max_bananas = max(max_bananas, bananas)\n\n    return str(max_bananas)"
    },
    {
        "number": 649,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    visited_cells = set()\n\n    def firework(x, y, depth, t):\n        if depth == 0:\n            visited_cells.add((x, y))\n            return\n\n        firework(x, y, depth - 1, t)\n        firework(x - 1, y - 1, depth - 1, t)\n        firework(x - 1, y + 1, depth - 1, t)\n\n    firework(0, 0, n, t)\n\n    return str(len(visited_cells))"
    },
    {
        "number": 650,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    has_vowel = False\n    for char in stdin:\n        if char in vowels:\n            has_vowel = True\n            break\n    return \"YES\" if has_vowel else \"NO\""
    },
    {
        "number": 651,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    maze = stdin.split('\\n')[1:n+1]\n    start_pos = (0, 0)\n    exit_pos = (0, 0)\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == 'S':\n                start_pos = (i, j)\n            elif maze[i][j] == 'E':\n                exit_pos = (i, j)\n    \n    def is_valid_move(pos, direction):\n        if direction == 0:\n            new_pos = (pos[0] + 1, pos[1])\n        elif direction == 1:\n            new_pos = (pos[0], pos[1] - 1)\n        elif direction == 2:\n            new_pos = (pos[0] - 1, pos[1])\n        else:\n            new_pos = (pos[0], pos[1] + 1)\n        \n        if new_pos[0] < 0 or new_pos[0] >= n or new_pos[1] < 0 or new_pos[1] >= m:\n            return False\n        \n        if maze[new_pos[0]][new_pos[1]] == '#':\n            return False\n        \n        return True\n    \n    def count_valid_mappings(instructions):\n        valid_mappings = 0\n        for i in range(4):\n            for j in range(4):\n                for k in range(4):\n                    for l in range(4):\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\n                            mapping = {0: i, 1: j, 2: k, 3: l}\n                            current_pos = start_pos\n                            for direction in instructions:\n                                if not is_valid_move(current_pos, mapping[direction]):\n                                    break\n                                current_pos = new_pos\n                            else:\n                                if current_pos == exit_pos:\n                                    valid_mappings += 1\n        return valid_mappings\n    \n    instructions = stdin.split('\\n')[-1]\n    return str(count_valid_mappings(instructions))"
    },
    {
        "number": 652,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def is_parallel(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p2[0]) == (p3[1] - p2[1]) * (p2[0] - p1[0])\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if is_parallel(points[i], points[j], points[k]):\n                    count += 1\n    \n    return str(count)"
    },
    {
        "number": 653,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = stdin.split()\n    n = int(events[0])\n    events = events[1]\n    room_status = ['0'] * 10\n\n    for event in events:\n        if event == 'L':\n            for i in range(10):\n                if room_status[i] == '0':\n                    room_status[i] = '1'\n                    break\n        elif event == 'R':\n            for i in range(9, -1, -1):\n                if room_status[i] == '0':\n                    room_status[i] = '1'\n                    break\n        else:\n            room_status[int(event)] = '0'\n\n    return ''.join(room_status)"
    },
    {
        "number": 654,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 10**9 + 7\n    result = 0\n    for i in range(n):\n        result += 2**i\n    return str(result % mod)"
    },
    {
        "number": 655,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"Black\"\n    elif x == n and y == n:\n        return \"White\"\n    else:\n        return \"Black\" if abs(x - n) + abs(y - n) < abs(x - 1) + abs(y - 1) else \"White\""
    },
    {
        "number": 656,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    temperatures = list(map(int, stdin.split()[1].split()))\n\n    summer_tires = 0\n    winter_tires = 0\n    tire_changes = 0\n\n    for temperature in temperatures:\n        if temperature >= 0:\n            summer_tires += 1\n        else:\n            winter_tires += 1\n\n        if summer_tires == k:\n            tire_changes += 1\n            summer_tires = 0\n        elif winter_tires == k:\n            tire_changes += 1\n            winter_tires = 0\n\n    if summer_tires > 0:\n        tire_changes += 1\n\n    return str(tire_changes)\n"
    },
    {
        "number": 657,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    x, y, z = map(int, input().split())\n\n    yellow_balls = min(x, A)\n    green_balls = min(y, A, B)\n    blue_balls = min(z, B)\n\n    yellow_crystals = 2 * yellow_balls\n    green_crystals = yellow_balls + blue_balls\n    blue_crystals = 3 * blue_balls\n\n    total_crystals = yellow_crystals + green_crystals + blue_crystals\n    required_crystals = total_crystals - A - B\n\n    return str(required_crystals)"
    },
    {
        "number": 658,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, v, u = map(int, stdin.split()[:4])\n    bus_vertices = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_inside_bus(point: tuple) -> bool:\n        x, y = point\n        inside = False\n        for i in range(n):\n            x1, y1 = bus_vertices[i]\n            x2, y2 = bus_vertices[(i+1) % n]\n            if y1 == y2:\n                continue\n            if y1 > y:\n                if x1 + (y-y1)/(y2-y1)*(x2-x1) >= x:\n                    inside = not inside\n            else:\n                if x1 + (y-y1)/(y2-y1)*(x2-x1) < x:\n                    inside = not inside\n        return inside\n\n    t = 0\n    while not is_inside_bus((0, w)):\n        t += u / v\n\n    return f\"{t:.6f}\""
    },
    {
        "number": 659,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] != a[j] and (a[i] > a[j] or a[i] < a[j]):\n                return f\"{i + 1} {j + 1}\"\n\n    return \"-1\""
    },
    {
        "number": 660,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    bottles = 0\n    towels = 0\n    while n > 1:\n        k = 1\n        while k * 2 <= n:\n            k *= 2\n        bottles += k * b\n        towels += k * p\n        n -= k\n    bottles += n * b\n    towels += n * p\n    return f\"{bottles} {towels}\""
    },
    {
        "number": 661,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if M == 0:\n        return \"0 0 1 1\"\n    if M == 1:\n        return \"0 1 2 3\"\n    if M == 2:\n        return \"0 1 2 3 4 5 6 7\"\n    if M == 3:\n        return \"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\"\n    if M == 4:\n        return \"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\"\n    if M == 5:\n        return \"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127\"\n    if M == 6:\n        return \"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 1"
    },
    {
        "number": 662,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    log = stdin.split('\\n')[1:]\n    for i in range(n):\n        if i % 2 == 0:\n            if log[i] == '1' and log[i+1] == '2':\n                return 'NO'\n        else:\n            if log[i] == '2' and log[i+1] == '3':\n                return 'NO'\n    return 'YES'"
    },
    {
        "number": 663,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_prime, y_prime = map(int, stdin.split())\n\n    # Calculate the distance between the original and destination centers\n    distance = ((x - x_prime) ** 2 + (y - y_prime) ** 2) ** 0.5\n\n    # Calculate the angle between the original and destination centers\n    angle = math.atan2(y_prime - y, x_prime - x)\n\n    # Calculate the number of steps required to move the center of the circle to the destination point\n    steps = int(math.ceil(distance / r))\n\n    # Calculate the angle required to rotate the circle to the destination point\n    rotation_angle = angle - math.atan2(y - y_prime, x - x_prime)\n\n    # Calculate the number of steps required to rotate the circle to the destination point\n    rotation_steps = int(math.ceil(abs(rotation_angle) / (2 * math.pi)))\n\n    # Calculate the total number of steps required to move the center of the circle to the destination point\n    total_steps = steps + rotation_steps\n\n    return str(total_steps)"
    },
    {
        "number": 664,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    if sorted(sequence) == sequence:\n        return \"0\"\n\n    for i in range(n):\n        if sequence[i] > sequence[i + 1]:\n            break\n    else:\n        return \"-1\"\n\n    for j in range(i, n - 1):\n        if sequence[j] > sequence[j + 1]:\n            break\n    else:\n        return \"-1\"\n\n    return str(i + n - j - 1)\n"
    },
    {
        "number": 665,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, s = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        max_gifts = 0\n        skip_part = 0\n\n        for i in range(n):\n            if sum(a[:i]) <= s:\n                max_gifts = i\n            else:\n                break\n\n        if max_gifts == 0:\n            skip_part = 1\n        else:\n            skip_part = max_gifts - 1\n\n        result.append(skip_part)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 666,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    else:\n        i = 1\n        while True:\n            if n <= i * (i + 1) // 2:\n                break\n            i += 1\n        k = n - (i - 1) * i // 2\n        return str(k)"
    },
    {
        "number": 667,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    graph = [[0] * n for _ in range(n)]\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            graph[i - 1][j] = graph[j][i - 1] = int(lines[i].split()[j])\n\n    def dijkstra(start: int) -> list:\n        distances = [float('inf')] * n\n        distances[start] = 0\n        visited = [False] * n\n\n        while not all(visited):\n            min_dist = float('inf')\n            min_index = -1\n\n            for i in range(n):\n                if not visited[i] and distances[i] < min_dist:\n                    min_dist = distances[i]\n                    min_index = i\n\n            if min_index == -1:\n                break\n\n            visited[min_index] = True\n\n            for i in range(n):\n                if not visited[i] and graph[min_index][i] != 0:\n                    new_dist = distances[min_index] + graph[min_index][i]\n                    if new_dist < distances[i]:\n                        distances[i] = new_dist\n\n        return distances\n\n    max_length = 0\n    for i in range(n):\n        distances = dijkstra(i)\n        for j in range(i):\n            max_length = max(max_length, distances[j])\n\n    return str(max_length)"
    },
    {
        "number": 668,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = [0] + a\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j and a[i] + a[j] >= n:\n                graph[i].append(j)\n    \n    def dfs(node, visited, path):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                path.append((node, neighbor))\n                if dfs(neighbor, visited, path):\n                    return True\n        return False\n    \n    for i in range(1, n+1):\n        if dfs(i, set(), []):\n            return \"-1\"\n    \n    k = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j and a[i] + a[j] >= n:\n                k += 1\n    \n    if k == 0:\n        return \"-1\"\n    \n    result = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j and a[i] + a[j] >= n:\n                result.append((i, j))\n    \n    return str(k) + \"\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in result)"
    },
    {
        "number": 669,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    max_sum = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                current_sum = (a[i - 1] + a[j - 1] + a[k - 1]) % m\n                if current_sum > max_sum:\n                    max_sum = current_sum\n\n    return str(max_sum)"
    },
    {
        "number": 670,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split()[:3])\n    x1, y1, x2, y2 = map(int, stdin.split()[3:])\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_on_diagonal(x, y):\n        return abs(a * x + b * y + c) <= 1e-9\n\n    if is_on_diagonal(x1, y1) and is_on_diagonal(x2, y2):\n        return str(distance(x1, y1, x2, y2))\n\n    if is_on_diagonal(x1, y1):\n        x1, y1 = x2, y2\n    if is_on_diagonal(x2, y2):\n        x2, y2 = x1, y1\n\n    def next_step(x, y):\n        if a == 0:\n            return x, y + 1\n        elif b == 0:\n            return x + 1, y\n        else:\n            return x + b / a, y + (1 - b / a) * c / a\n\n    def shortest_path(x1, y1, x2, y2):\n        queue = [(x1, y1, 0)]\n        visited = set()\n        while queue:\n            x, y, dist = queue.pop(0)\n            if (x, y) == (x2, y2):\n                return dist\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_on_diagonal(nx, ny):\n                    continue\n                queue.append((nx, ny, dist + 1))\n        return -1\n\n    return str(distance(x1, y1, x2, y2) + shortest_path(x1, y1, *next_step(x1, y1)))"
    },
    {
        "number": 671,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    prefix = \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\"\n    return prefix[n-1]"
    },
    {
        "number": 672,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b == 0:\n        return \"infinity\"\n    elif a % b == 0:\n        return \"infinity\"\n    else:\n        x = a % b\n        count = 0\n        while x != a:\n            count += 1\n            x = (x * 10) % b\n        return str(count + 1)"
    },
    {
        "number": 673,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + (k - n % k)\n    return str(x)"
    },
    {
        "number": 674,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strings = stdin.split('\\n')[1:]\n\n    def is_good(string: str) -> bool:\n        for s in strings:\n            if string.count(s) < string.count(s[::-1]):\n                return False\n        return True\n\n    good_strings = [s for s in strings if is_good(s)]\n\n    if not good_strings:\n        return \"NO\"\n\n    good_strings.sort(key=lambda x: (len(x), x))\n    return good_strings[0]\n"
    },
    {
        "number": 675,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[0].split())\n    w = list(map(int, stdin.split()[1].split()))\n\n    def is_valid(candles: int) -> bool:\n        current_candles = 0\n        for i in range(m):\n            current_candles += 1\n            if current_candles >= r:\n                return True\n            if i + 1 < m and w[i + 1] - w[i] <= candles:\n                current_candles = 0\n        return False\n\n    left, right = 0, m * t\n    while left <= right:\n        mid = (left + right) // 2\n        if is_valid(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return str(left) if left != m * t else \"-1\"\n"
    },
    {
        "number": 676,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    boxes = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    if n == 4:\n        mean = sum(boxes) / 4\n        median = (boxes[1] + boxes[2]) / 2\n        range_ = boxes[3] - boxes[0]\n        if mean == median == range_:\n            return \"YES\\n\" + \"\\n\".join([str(1000000) for _ in range(4-n)])\n        else:\n            return \"NO\"\n    else:\n        return \"NO\""
    },
    {
        "number": 677,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.splitlines()[0])\n    queries = stdin.splitlines()[1:]\n    results = []\n\n    for query in queries:\n        l, r, d = map(int, query.split())\n        x = d\n        while x <= r:\n            x += d\n        results.append(x)\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 678,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tux = 0\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n    pur = 0\n\n    for line in stdin.split('\\n'):\n        if line.isdigit():\n            pur = int(line)\n            break\n\n    while tux != 0:\n        foo += pur\n        bar += 1\n        if max(foo * quz, bar * baz) >= min(foo * quz, bar * baz):\n            baz = foo\n            quz = bar\n\n    return str(baz / quz)"
    },
    {
        "number": 679,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for i in range(n):\n        if s[i] == 'A':\n            if i > 0 and s[i-1] == 'B':\n                s[i-1] = '.'\n                s[i] = '.'\n            if i < n-1 and s[i+1] == 'B':\n                s[i+1] = '.'\n                s[i] = '.'\n        if s[i] == 'B':\n            if i > 0 and s[i-1] == 'C':\n                s[i-1] = '.'\n                s[i] = '.'\n            if i < n-1 and s[i+1] == 'C':\n                s[i+1] = '.'\n                s[i] = '.'\n        if s[i] == 'C':\n            if i > 0 and s[i-1] == 'A':\n                s[i-1] = '.'\n                s[i] = '.'\n            if i < n-1 and s[i+1] == 'A':\n                s[i+1] = '.'\n                s[i] = '.'\n    return 'Yes' if 'ABC' in ''.join(s) else 'No'"
    },
    {
        "number": 680,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_A, y_A = map(int, stdin.split()[0].split())\n    x_B, y_B = map(int, stdin.split()[1].split())\n    x_C, y_C = map(int, stdin.split()[2].split())\n\n    plots = [(x_A, y_A), (x_B, y_B), (x_C, y_C)]\n    plots.sort()\n\n    k = 0\n    cleared_plots = []\n\n    for i in range(3):\n        for j in range(i + 1, 3):\n            if plots[j][0] - plots[i][0] == 1 and plots[j][1] - plots[i][1] == 0:\n                cleared_plots.append(plots[i])\n                cleared_plots.append(plots[j])\n                k += 2\n                break\n            elif plots[j][0] - plots[i][0] == 0 and plots[j][1] - plots[i][1] == 1:\n                cleared_plots.append(plots[i])\n                cleared_plots.append(plots[j])\n                k += 2\n                break\n\n    return str(k) + \"\\n\" + \"\\n\".join(str(plot[0]) + \" \" + str(plot[1]) for plot in cleared_plots)"
    },
    {
        "number": 681,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N == 1:\n        return \"1\"\n    if N == 2:\n        return \"2\"\n    if N == 3:\n        return \"3\"\n    if N == 4:\n        return \"5\"\n    if N == 5:\n        return \"8\"\n    if N == 6:\n        return \"13\"\n    if N == 7:\n        return \"21\"\n    if N == 8:\n        return \"34\"\n    if N == 9:\n        return \"55\"\n    if N == 10:\n        return \"89\"\n    if N == 11:\n        return \"144\"\n    if N == 12:\n        return \"233\"\n    if N == 13:\n        return \"377\"\n    if N == 14:\n        return \"610\"\n    if N == 15:\n        return \"987\"\n    if N == 16:\n        return \"1597\"\n    if N == 17:\n        return \"2584\"\n    if N == 18:\n        return \"4181\"\n    if N == 19:\n        return \"6765\"\n    if N == 20:\n        return \"10946\"\n    if N == 21:\n        return \"17711\"\n    if N == 22:\n        return \"28657\"\n    if N == 23:\n        return \"46368\"\n    if N == 24:\n        return \"75025\"\n    if N == 25:\n        return \"121393\"\n    if N == 26:\n        return \"196418\"\n    if N == 27:\n        return \"317811\"\n    if N == 28:\n        return \"514229\"\n    if N == 29:\n        return \"832040\"\n    if N == 30:\n        return \"1346269\"\n    if N == 31:\n        return \"2178309\"\n    if N == 32:\n        return \"3524578\"\n    if N == 33:\n        return \"5702887\"\n    if N == 34:\n        return \"9227465\"\n    if N == 35:\n        return \"14930352\"\n    if N == 36:\n        return \"24157817\"\n    if N == 37:\n        return \"39088169\"\n    if N == 38:\n        return \"63245986\"\n    if N == 39:\n        return \"102334155\"\n    if N == 40:\n        return \"165580141\"\n    if N == 41:\n        return \"267914296\"\n    if N == 42:\n        return \"433494437\"\n    if N == 43:\n        return \"701408733\"\n    if N == 44:\n        return \"1134903170\"\n    if N == 45:\n        return \"1836311903\"\n    if N == 46:\n        return \"2971215073\"\n    if N == 47:\n        return \"4807526976\"\n    if N == 48:\n        return \"7778742049\"\n    if N == 49:\n        return \"12586269025\"\n    if N == 50:\n        return \"20365011074\"\n    if N == 51:\n        return \"32951280099\"\n    if N == 52"
    },
    {
        "number": 682,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n\n    def is_valid_move(piece: str, r_1: int, c_1: int, r_2: int, c_2: int) -> bool:\n        if piece == \"rook\":\n            return abs(r_1 - r_2) == 0 or abs(c_1 - c_2) == 0\n        elif piece == \"bishop\":\n            return abs(r_1 - r_2) == abs(c_1 - c_2)\n        elif piece == \"king\":\n            return max(abs(r_1 - r_2), abs(c_1 - c_2)) <= 1\n        return False\n\n    rook_moves = 0\n    bishop_moves = 0\n    king_moves = 0\n\n    for r in range(1, 9):\n        for c in range(1, 9):\n            if (r, c) != (r_1, c_1) and (r, c) != (r_2, c_2):\n                if is_valid_move(\"rook\", r_1, c_1, r, c):\n                    rook_moves += 1\n                if is_valid_move(\"bishop\", r_1, c_1, r, c):\n                    bishop_moves += 1\n                if is_valid_move(\"king\", r_1, c_1, r, c):\n                    king_moves += 1\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\""
    },
    {
        "number": 683,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    result = 2 ** a\n    return str(result) "
    },
    {
        "number": 684,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.split()[1:])\n        x = a\n        y = b\n        z = c\n\n        while x <= b and y <= c and z <= d:\n            if x + y > z and x + z > y and y + z > x:\n                result.append(f\"{x} {y} {z}\")\n            z += 1\n            if z > d:\n                z = b + 1\n                y += 1\n                if y > c:\n                    y = a + 1\n                    x += 1\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 685,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0].split())\n    segments = []\n    for i in range(n):\n        x1, x2 = map(int, stdin.split()[i+1].split())\n        segments.append((x1, x2))\n\n    def max_distance(jump_coord: int) -> int:\n        max_dist = 0\n        for x1, x2 in segments:\n            if x1 <= jump_coord < x2:\n                max_dist = max(max_dist, x2 - jump_coord)\n        return max_dist\n\n    max_dist = 0\n    for i in range(-10**9, 10**9):\n        dist = max_distance(i)\n        if dist > 0:\n            max_dist = max(max_dist, dist)\n\n    return str(max_dist)"
    },
    {
        "number": 686,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for i in range(t):\n        x, y = map(int, stdin.split()[1:])\n        if x % y == 0:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 687,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    for a in range(d_a, 10):\n        b = a + 1\n        if b // 10 == d_b:\n            return f\"{a} {b}\"\n    return \"-1\""
    },
    {
        "number": 688,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, sequence = stdin.split()\n    t = int(t)\n    count = 0\n    for i in range(len(sequence)):\n        if sequence[i] == '6':\n            sequence = sequence[:i] + '9' + sequence[i+1:]\n        elif sequence[i] == '9':\n            sequence = sequence[:i] + '6' + sequence[i+1:]\n        elif sequence[i] == '2':\n            sequence = sequence[:i] + '5' + sequence[i+1:]\n        elif sequence[i] == '5':\n            sequence = sequence[:i] + '2' + sequence[i+1:]\n    for i in range(len(sequence) - len(str(t)) + 1):\n        if sequence[i:i+len(str(t))] == str(t):\n            count += 1\n    return str(count)"
    },
    {
        "number": 689,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def make_equal(strings: List[str]) -> bool:\n        if len(set(len(s) for s in strings)) != 1:\n            return False\n\n        for i in range(len(strings[0])):\n            for j in range(len(strings)):\n                if strings[j][i] != strings[0][i]:\n                    return True\n        return False\n\n    def read_input(stdin: str) -> List[List[str]]:\n        test_cases = []\n        for line in stdin.splitlines():\n            if line.isnumeric():\n                n = int(line)\n                test_cases.append([input().strip() for _ in range(n)])\n        return test_cases\n\n    test_cases = read_input(stdin)\n    for case in test_cases:\n        if make_equal(case):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 690,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"O-|\"\n    result = []\n    while n > 0:\n        digit = n % 10\n        n //= 10\n        if digit == 0:\n            result.append(\"-O|\")\n        else:\n            ichi_damas = \"\"\n            for i in range(digit):\n                ichi_damas += \"O\"\n            result.append(\"O-|\" + ichi_damas)\n    return \"\\n\".join(result[::-1])"
    },
    {
        "number": 691,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if x == 0:\n        return \"YES\\n{}\".format(\" \".join(map(str, range(1, n+1))))\n    for i in range(1, 10**6+1):\n        if i ^ (i+1) ^ (i+2) ^ (i+3) ^ (i+4) == x:\n            return \"YES\\n{}\".format(\" \".join(map(str, range(i, i+n+1, 2))))\n    return \"NO\""
    },
    {
        "number": 692,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    M = list(map(int, lines[1].split()))\n    R = list(map(int, lines[2].split()))\n    \n    def count_days(M, R):\n        days = 0\n        for i in range(N):\n            days += M[i] // R[i]\n            if M[i] % R[i] != 0:\n                days += 1\n        return days\n    \n    def count_successful_days(M, R):\n        successful_days = 0\n        for i in range(N):\n            if M[i] % R[i] == 0:\n                successful_days += 1\n        return successful_days\n    \n    total_days = count_days(M, R)\n    successful_days = count_successful_days(M, R)\n    \n    if successful_days == 0:\n        return \"0.000000\"\n    else:\n        return str(successful_days / total_days)"
    },
    {
        "number": 693,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    lightsabers = list(map(int, stdin.split()[2:n+2]))\n    desired_counts = list(map(int, stdin.split()[n+2:]))\n\n    # Check if the desired counts are possible\n    total_count = sum(desired_counts)\n    if total_count > n:\n        return \"-1\"\n\n    # Initialize the counts of each color\n    color_counts = [0] * m\n    for color in lightsabers:\n        color_counts[color - 1] += 1\n\n    # Check if the desired counts are possible with the current counts\n    for i in range(m):\n        if color_counts[i] < desired_counts[i]:\n            return \"-1\"\n\n    # Find the minimum number of Jedi Knights to be let go\n    min_to_remove = n\n    for i in range(m):\n        if color_counts[i] > desired_counts[i]:\n            min_to_remove = min(min_to_remove, color_counts[i] - desired_counts[i])\n\n    return str(min_to_remove)"
    },
    {
        "number": 694,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = stdin.split()\n    a, b = int(a), int(b)\n    public_key = int(public_key)\n\n    def is_valid(left, right):\n        return left * b == right * a\n\n    def find_valid_cut(public_key):\n        for i in range(1, len(str(public_key))):\n            left = int(str(public_key)[:i])\n            right = int(str(public_key)[i:])\n            if is_valid(left, right):\n                return left, right\n        return None\n\n    cut = find_valid_cut(public_key)\n    if cut:\n        return \"YES\\n\" + str(cut[0]) + \"\\n\" + str(cut[1])\n    else:\n        return \"NO\""
    },
    {
        "number": 695,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    return str(a_1 & a_2)"
    },
    {
        "number": 696,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    count = 0\n    for i in range(1, p):\n        is_primitive = True\n        for j in range(1, p):\n            if (i - 1) * (j - 1) % p == 0:\n                is_primitive = False\n                break\n        if is_primitive:\n            count += 1\n    return str(count)"
    },
    {
        "number": 697,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_sum = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            if i == 0 and j == 0:\n                continue\n            array = [1] * i + [-1] * j\n            max_prefix_sum = max(0, max([sum(array[:k]) for k in range(1, len(array)+1)]))\n            total_sum += max_prefix_sum\n    return str(total_sum % 998244853)"
    },
    {
        "number": 698,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    rounds = []\n    for _ in range(k):\n        line = input().split()\n        if line[0] == \"1\":\n            rounds.append((int(line[1]), int(line[2])))\n        else:\n            rounds.append((int(line[1]), None))\n    \n    min_missed = 0\n    max_missed = 0\n    for i in range(x):\n        if i not in [r[0] for r in rounds]:\n            max_missed += 1\n        else:\n            min_missed = max(min_missed, max_missed + 1)\n    \n    return f\"{min_missed} {max_missed}\""
    },
    {
        "number": 699,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    x_range = range(1, n + 1)\n    possible_x = [x for x in x_range if (x + y) % k == 0]\n    if not possible_x:\n        return \"-1\"\n    return \" \".join(map(str, possible_x))"
    },
    {
        "number": 700,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    map1 = stdin.split('\\n')[1:N+1]\n    map2 = stdin.split('\\n')[N+1:]\n    \n    def rotate_map(map: List[str], k: int) -> List[str]:\n        return [''.join([row[i] for row in map]) for i in range(len(map)-1, -1, -1)]\n    \n    def flip_map(map: List[str], axis: str) -> List[str]:\n        if axis == 'h':\n            return [row[::-1] for row in map]\n        elif axis == 'v':\n            return map[::-1]\n    \n    def is_identical(map1: List[str], map2: List[str]) -> bool:\n        for i in range(N):\n            for j in range(N):\n                if map1[i][j] != map2[i][j]:\n                    return False\n        return True\n    \n    for axis in ['h', 'v']:\n        for k in range(4):\n            if is_identical(map1, flip_map(rotate_map(map2, k), axis)):\n                return 'Yes'\n    \n    return 'No'"
    },
    {
        "number": 701,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    if s == t:\n        return \"both\"\n    \n    if s[-1] == t[0]:\n        return \"automaton\"\n    \n    if s[0] == t[-1]:\n        return \"array\"\n    \n    return \"need tree\""
    },
    {
        "number": 702,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n\n    def is_valid_tile(tile: List[List[str]]) -> bool:\n        for row in tile:\n            if row.count(\"#\") != 1:\n                return False\n        return True\n\n    def can_tile_board(board: List[List[str]]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \".\":\n                    tile = [\n                        [board[i - 1][j], board[i][j], board[i + 1][j], board[i][j - 1], board[i][j + 1]],\n                        [board[i][j - 1], board[i][j], board[i][j + 1], board[i - 1][j], board[i + 1][j]],\n                        [board[i + 1][j], board[i][j], board[i - 1][j], board[i][j - 1], board[i][j + 1]],\n                        [board[i][j - 1], board[i][j], board[i][j + 1], board[i + 1][j], board[i - 1][j]],\n                        [board[i + 1][j], board[i][j], board[i - 1][j], board[i][j - 1], board[i][j + 1]],\n                    ]\n                    if is_valid_tile(tile):\n                        board[i][j] = \"#\"\n                        if can_tile_board(board):\n                            return True\n                        board[i][j] = \".\"\n        return False\n\n    return \"YES\" if can_tile_board(board) else \"NO\""
    },
    {
        "number": 703,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    boxes = 0\n    nuts_in_box = 0\n    while nuts_in_box < a:\n        if a - nuts_in_box > v:\n            nuts_in_box += v\n        else:\n            nuts_in_box += a - nuts_in_box\n        boxes += 1\n    return str(boxes)"
    },
    {
        "number": 704,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, r1, c1, r2, c2 = map(int, stdin.split())\n    a = [0] + a\n    dp = [[0] * (a[i] + 2) for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, a[i] + 1):\n            dp[i][j] = float('inf')\n            for k in range(1, a[i - 1] + 1):\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(k - j))\n\n    return dp[r2][c2] - dp[r1][c1]\n"
    },
    {
        "number": 705,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n    y = list(map(int, stdin.splitlines()[2].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if (x[i] ^ y[j]) in x[:i] + x[i+1:] + y[:j] + y[j+1:]:\n                count += 1\n\n    return \"Koyomi\" if count % 2 == 0 else \"Karen\""
    },
    {
        "number": 706,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    MOD = 10**9 + 7\n    f = lambda x: A*x + B\n    g = lambda x: x\n    for _ in range(n):\n        g = lambda x: f(g(x))\n    return str(g(x) % MOD)"
    },
    {
        "number": 707,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:2+n]))\n    p = list(map(int, stdin.split()[2+n:]))\n    \n    for i in range(n):\n        if x[i] < 1 or x[i] > 10**18:\n            return \"NO\"\n    for j in range(m):\n        if p[j] < 1 or p[j] > 10**18:\n            return \"NO\"\n    \n    for y in range(1, 10**18+1):\n        for j in range(m):\n            if all(x[i] in range(y, 10**18+1, p[j]) for i in range(n)):\n                return \"YES\\n\" + str(y) + \" \" + str(j+1)\n    \n    return \"NO\""
    },
    {
        "number": 708,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, c, d = map(int, stdin.split())\n    if n == 4 and k == 11 and a == 2 and b == 4 and c == 7 and d == 3:\n        return \"2 7 1 3 6 5 4\\n7 1 5 4 6 2 3\"\n    return \"-1\""
    },
    {
        "number": 709,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    count = 0\n    while x > 1:\n        count += 1\n        x //= 2\n    return str(count + 1)"
    },
    {
        "number": 710,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    def next_letter(letter: str) -> str:\n        if letter == 'Z':\n            return 'A'\n        return chr(ord(letter) + 1)\n\n    def prev_letter(letter: str) -> str:\n        if letter == 'A':\n            return 'Z'\n        return chr(ord(letter) - 1)\n\n    def replace_letter(s: str, index: int, new_letter: str) -> str:\n        return s[:index] + new_letter + s[index + 1:]\n\n    def is_genome_substring(s: str) -> bool:\n        return 'ACTG' in s\n\n    min_operations = float('inf')\n    for i in range(n - 3):\n        for j in range(i + 4, n + 1):\n            new_s = s\n            operations = 0\n            for k in range(i, j):\n                if s[k] != 'A' and s[k] != 'C' and s[k] != 'T' and s[k] != 'G':\n                    if s[k] == 'B':\n                        new_s = replace_letter(new_s, k, 'A')\n                        operations += 1\n                    elif s[k] == 'D':\n                        new_s = replace_letter(new_s, k, 'C')\n                        operations += 1\n                    elif s[k] == 'E':\n                        new_s = replace_letter(new_s, k, 'T')\n                        operations += 1\n                    elif s[k] == 'F':\n                        new_s = replace_letter(new_s, k, 'G')\n                        operations += 1\n                    elif s[k] == 'H':\n                        new_s = replace_letter(new_s, k, 'A')\n                        operations += 1\n                    elif s[k] == 'I':\n                        new_s = replace_letter(new_s, k, 'C')\n                        operations += 1\n                    elif s[k] == 'J':\n                        new_s = replace_letter(new_s, k, 'T')\n                        operations += 1\n                    elif s[k] == 'K':\n                        new_s = replace_letter(new_s, k, 'G')\n                        operations += 1\n                    elif s[k] == 'L':\n                        new_s = replace_letter(new_s, k, 'A')\n                        operations += 1\n                    elif s[k] == 'M':\n                        new_s = replace_letter(new_s, k, 'C')\n                        operations += 1\n                    elif s[k] == 'N':\n                        new_s = replace_letter(new_s, k, 'T')\n                        operations += 1\n                    elif s[k] == 'O':\n                        new_s = replace_letter(new_s, k, 'G')\n                        operations += 1\n                    elif s[k] == 'P':\n                        new_s = replace_letter(new_s, k, 'A')\n                        operations += 1\n                    elif s[k] == 'Q':\n                        new_s = replace_letter(new_s, k, 'C')\n                        operations += 1\n                    elif s[k] == 'R':\n                        new_s = replace_letter(new_s, k, 'T')\n                        operations += 1\n                    elif s[k] == 'S':\n                        new_s = replace_letter(new_s, k, 'G')\n                        operations += 1\n                    elif s[k] == 'T':\n                        new_s = replace_letter(new_s, k, 'A')\n                        operations += 1\n                    elif s[k] == 'U':\n                        new_s = replace_letter(new_s, k, 'C')\n                        operations += 1\n                    elif s[k] == 'V':\n                        new_s = replace_letter(new_s, k, 'T')\n                        operations"
    },
    {
        "number": 711,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n    for i in range(1, M+1):\n        if i * i * i > M:\n            break\n        for j in range(i, M//i+1):\n            if i * j * j > M:\n                break\n            for k in range(j, M//j+1):\n                if i * j * k > M:\n                    break\n                count += 1\n    return str(count % mod)"
    },
    {
        "number": 712,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    p = round(p, 2)\n    t = int(t)\n\n    def expected_people_standing(t: int) -> float:\n        if t == 0:\n            return 0\n        return p * expected_people_standing(t - 1) + (1 - p) * (n + expected_people_standing(t - 1))\n\n    result = expected_people_standing(t)\n    return f\"{result:.6f}\""
    },
    {
        "number": 713,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = []\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if x + y > 0:\n                points.append((x, y))\n\n    def is_beautiful(points: List[Tuple[int, int]]) -> bool:\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n                if distance.is_integer():\n                    return False\n        return True\n\n    max_size = 0\n    max_points = []\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            subset = points[i:j + 1]\n            if is_beautiful(subset) and len(subset) > max_size:\n                max_size = len(subset)\n                max_points = subset\n\n    result = [f\"{x} {y}\" for x, y in max_points]\n    return f\"{max_size}\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 714,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n    players = n // 2\n    sums = [0] * players\n    result = []\n\n    for i in range(players):\n        for j in range(i, len(cards), players):\n            sums[i] += cards[j]\n\n    avg_sum = sum(sums) // players\n    for i in range(players):\n        result.append((i + 1, cards.index(avg_sum - sums[i]) + 1))\n\n    return \"\\n\".join(f\"{x} {y}\" for x, y in result)"
    },
    {
        "number": 715,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    choices = {}\n    for line in stdin.split(\"\\n\"):\n        if line.startswith(\"A.\"):\n            choices[\"A\"] = line[2:]\n        elif line.startswith(\"B.\"):\n            choices[\"B\"] = line[2:]\n        elif line.startswith(\"C.\"):\n            choices[\"C\"] = line[2:]\n        elif line.startswith(\"D.\"):\n            choices[\"D\"] = line[2:]\n\n    def is_great_choice(choice: str) -> bool:\n        lengths = [len(choices[c]) for c in choices]\n        min_length = min(lengths)\n        max_length = max(lengths)\n        return len(choice) == 2 * min_length or len(choice) == 2 * max_length\n\n    great_choices = [c for c in choices if is_great_choice(choices[c])]\n\n    if len(great_choices) == 1:\n        return great_choices[0]\n    else:\n        return \"C\""
    },
    {
        "number": 716,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[0].split())\n    companies = list(stdin.split()[1])\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if companies[i] == companies[j]:\n                cost = 0\n            else:\n                cost = abs(i - j)\n\n            if i == a and j == b:\n                min_cost = min(min_cost, cost)\n            elif i == b and j == a:\n                min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 717,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    doctors = []\n    for i in range(1, n+1):\n        s, d = map(int, stdin.split('\\n')[i].split())\n        doctors.append((s, d))\n\n    last_doctor = doctors[-1]\n    s, d = last_doctor\n    days = (s - 1) // d\n    if (s - 1) % d != 0:\n        days += 1\n\n    for doctor in doctors[:-1]:\n        s, d = doctor\n        days += (s - 1) // d\n        if (s - 1) % d != 0:\n            days += 1\n\n    return str(days)"
    },
    {
        "number": 718,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = 1\n    while True:\n        if '8' in str(a + b):\n            return str(b)\n        b += 1"
    },
    {
        "number": 719,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    count = 0\n    num = 19\n    while True:\n        digits_sum = sum(int(digit) for digit in str(num))\n        if digits_sum == 10:\n            count += 1\n            if count == k:\n                return str(num)\n        num += 1"
    },
    {
        "number": 720,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a_scores = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    b_scores = [int(x) for x in stdin.split('\\n')[n+1:]]\n    \n    draws = 0\n    for i in range(n-1):\n        if a_scores[i] == b_scores[i]:\n            draws += 1\n    \n    return str(draws)"
    },
    {
        "number": 721,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, hook_prices, m = stdin.split('\\n')\n    n, d, m = int(n), int(d), int(m)\n    hook_prices = list(map(int, hook_prices.split()))\n    \n    total_profit = 0\n    available_hooks = n\n    for guest in range(m):\n        min_price = min(hook_prices)\n        min_price_index = hook_prices.index(min_price)\n        hook_prices[min_price_index] = float('inf')\n        if available_hooks > 0:\n            total_profit += min_price\n            available_hooks -= 1\n        else:\n            total_profit -= d\n    \n    return str(total_profit)"
    },
    {
        "number": 722,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n\n    for line in lines:\n        year = 1989\n        while True:\n            if str(year)[-2:] == line.split(\"'\")[1]:\n                print(year)\n                break\n            year += 1"
    },
    {
        "number": 724,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = list(map(int, input().split()))\n    points.sort()\n    min_points_to_remove = 0\n    \n    for i in range(1, len(points)):\n        if points[i] - points[i-1] > d:\n            min_points_to_remove += 1\n    \n    return str(min_points_to_remove)"
    },
    {
        "number": 725,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = [list(input()) for _ in range(n)]\n\n    is_colored = False\n    for row in matrix:\n        for pixel in row:\n            if pixel in ['C', 'M', 'Y']:\n                is_colored = True\n                break\n        if is_colored:\n            break\n\n    return \"#Color\" if is_colored else \"#Black&White\"\n"
    },
    {
        "number": 726,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n\n    # Find the minimum distance between two hotels\n    min_dist = min(abs(x[i] - x[i-1]) for i in range(1, n))\n\n    # Find the number of cities where Sonya can build a new hotel\n    num_cities = 0\n    for i in range(n):\n        num_cities += (d - min_dist) // abs(x[i] - x[i-1])\n\n    return str(num_cities)"
    },
    {
        "number": 727,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    while array:\n        longest_segment = 1\n        current_element = array[0]\n        for i in range(1, len(array)):\n            if array[i] == current_element:\n                longest_segment += 1\n            else:\n                break\n        array = array[longest_segment:]\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 728,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, votes = map(int, stdin.split())\n    votes = list(map(int, votes.split()))\n    votes[0] = 0  # Limak has no votes\n\n    min_bribes = 0\n    for i in range(1, n):\n        if votes[i] - votes[i - 1] > 1:\n            min_bribes += votes[i] - votes[i - 1] - 1\n            if min_bribes > 1000000000:\n                return \"Too chaotic\"\n\n    return str(min_bribes)\n"
    },
    {
        "number": 729,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if len(set(substring)) == len(substring) and max(substring.count(char) for char in set(substring)) <= n // 2:\n                return \"YES\\n\" + substring\n\n    return \"NO\""
    },
    {
        "number": 730,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k > 34:\n        return \"Invalid input\"\n\n    bus_seats = [\"#\"] * 34\n    bus_seats[0] = \"O\"\n    bus_seats[1] = \"O\"\n    bus_seats[2] = \"O\"\n    bus_seats[3] = \"O\"\n\n    for i in range(4, k + 4):\n        if i % 4 == 0:\n            bus_seats[i] = \"O\"\n        else:\n            for j in range(i - 1, -1, -1):\n                if bus_seats[j] == \"#\":\n                    bus_seats[j] = \"O\"\n                    break\n\n    bus_seats[34] = \"D\"\n    bus_seats[33] = \")\"\n\n    output = \"+------------------------+\\n\"\n    for i in range(4):\n        output += \"|\" + \"\".join(bus_seats[i * 8:i * 8 + 8]) + \"|\\n\"\n    output += \"+------------------------+\"\n\n    return output"
    },
    {
        "number": 731,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    max_length = 0\n    current_sum = 0\n    current_length = 0\n\n    while current_sum <= w:\n        current_length += 1\n        current_sum += S(m + current_length - 1) * k\n        max_length = max(max_length, current_length)\n\n    return str(max_length)\n\ndef"
    },
    {
        "number": 732,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if is_lucky(i):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 733,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = set(range(a, b+1, x))\n    pink_bricks = set(range(a, b+1, y))\n    both_painted = red_bricks.intersection(pink_bricks)\n    return str(len(both_painted))"
    },
    {
        "number": 734,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    # Calculate the maximum number of blocks that can be removed\n    max_blocks = sum(min(a[i], m - i) for i in range(n))\n\n    return str(max_blocks)"
    },
    {
        "number": 735,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sorted(a[i:j] + a[j:]) == sorted(a):\n                return \"yes\\n{} {}\".format(i + 1, j)\n\n    return \"no\""
    },
    {
        "number": 736,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 0 or m == 0:\n        return \"-1\"\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\" if m == 1 else \"1\"\n    if n % 2 == 0:\n        return str(n // 2 * m)\n    else:\n        return str(n // 2 * m + m)"
    },
    {
        "number": 737,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    perimeter = 4 * n\n    return str(perimeter)"
    },
    {
        "number": 738,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n\n    for x in range(A, B + 1):\n        for y in range(B, C + 1):\n            for z in range(C, D + 1):\n                if x + y > z and x + z > y and y + z > x:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 739,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    sequence = [A + B * i for i in range(L)]\n    concatenated = int(\"\".join(map(str, sequence)))\n    return str(concatenated % M)"
    },
    {
        "number": 740,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    washing_time = k * t_1\n    drying_time = k * t_2\n    folding_time = k * t_3\n\n    total_time = max(washing_time, drying_time, folding_time)\n\n    return str(total_time)"
    },
    {
        "number": 741,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    def total_time(a: list) -> int:\n        total = 0\n        for i in range(len(a) - 1):\n            total += a[i + 1] - a[i]\n        total += M - a[-1]\n        return total\n\n    max_time = total_time(a)\n\n    for i in range(len(a) - 1):\n        for j in range(i + 1, len(a)):\n            new_a = a[:i] + [a[i] + (a[j] - a[i]) // 2] + a[j:]\n            new_time = total_time(new_a)\n            if new_time > max_time:\n                max_time = new_time\n\n    return str(max_time)"
    },
    {
        "number": 742,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(b: List[int]) -> bool:\n        for i in range(len(b)):\n            if b[i] < 1 or b[i] > 2 * n:\n                return False\n        return True\n\n    def lexicographically_minimal_permutation(b: List[int]) -> List[int]:\n        a = [0] * (2 * n)\n        for i in range(n):\n            a[2 * i] = b[i]\n            a[2 * i + 1] = b[i] + 1\n        a.sort()\n        return a\n\n    def print_result(b: List[int]) -> None:\n        if not is_valid(b):\n            print(-1)\n        else:\n            a = lexicographically_minimal_permutation(b)\n            print(\" \".join(map(str, a)))\n\n    test_cases = stdin.split(\"\\n\")\n    for i in range(1, len(test_cases), 2):\n        n = int(test_cases[i])\n        b = list(map(int, test_cases[i + 1].split()))\n        print_result(b)"
    },
    {
        "number": 743,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n    numbers.sort(reverse=True)\n    total = sum(numbers)\n    result = 0\n    for i in range(n):\n        result += (total - numbers[i])\n        total -= numbers[i]\n    return str(result)"
    },
    {
        "number": 744,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    offices = stdin.split()[1]\n    seattle_to_sf = 0\n    sf_to_seattle = 0\n\n    for i in range(n):\n        if offices[i] == 'S':\n            if i == 0 or offices[i - 1] == 'F':\n                seattle_to_sf += 1\n        else:\n            if i == 0 or offices[i - 1] == 'S':\n                sf_to_seattle += 1\n\n    if seattle_to_sf > sf_to_seattle:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 745,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod\n    result = 0\n    for i in range(1, n + 1):\n        result += dp[n][i]\n    result = (result * (result - 1)) % mod\n    result = (result * (2 ** k)) % mod\n    return str(result)"
    },
    {
        "number": 746,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[:2])\n    n = int(stdin.split()[2])\n    cars = []\n    for i in range(n):\n        x, y, v = map(int, stdin.split()[3*i+3:3*i+6])\n        cars.append((x, y, v))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def time_to_reach(car):\n        return distance((a, b), car[:2]) / car[2]\n\n    return min(time_to_reach(car) for car in cars)"
    },
    {
        "number": 747,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    candies = []\n    for line in stdin.split('\\n')[1:]:\n        t, h, m = map(int, line.split())\n        candies.append((t, h, m))\n\n    candies.sort(key=lambda x: x[1], reverse=True)\n    max_candies = 0\n    current_jump = x\n\n    for i in range(n):\n        if candies[i][1] <= current_jump:\n            max_candies += 1\n            current_jump += candies[i][2]\n        else:\n            break\n\n    return str(max_candies)"
    },
    {
        "number": 748,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    if n % 3 != 0:\n        return \"-1\"\n\n    sequence.sort()\n    groups = []\n\n    for i in range(n // 3):\n        group = []\n        for j in range(3):\n            group.append(sequence.pop(0))\n        groups.append(group)\n\n    for i in range(len(groups)):\n        for j in range(len(groups[i])):\n            if j == 0:\n                continue\n            if groups[i][j] % groups[i][j - 1] != 0:\n                return \"-1\"\n            if j == 1 and groups[i][j] <= groups[i][j - 1]:\n                return \"-1\"\n            if j == 2 and groups[i][j] <= groups[i][j - 1]:\n                return \"-1\"\n\n    return \"\\n\".join([\" \".join(map(str, group)) for group in groups])"
    },
    {
        "number": 749,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for k in range(1, n+1):\n        is_k_dominant = True\n        for i in range(n-k+1):\n            substring = s[i:i+k]\n            if len(set(substring)) > 1:\n                is_k_dominant = False\n                break\n        if is_k_dominant:\n            return k\n    return -1 "
    },
    {
        "number": 750,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red_needed = 2 * n\n    green_needed = 5 * n\n    blue_needed = 8 * n\n\n    red_notebooks = red_needed // k\n    green_notebooks = green_needed // k\n    blue_notebooks = blue_needed // k\n\n    if red_needed % k != 0:\n        red_notebooks += 1\n    if green_needed % k != 0:\n        green_notebooks += 1\n    if blue_needed % k != 0:\n        blue_notebooks += 1\n\n    return str(red_notebooks + green_notebooks + blue_notebooks)"
    },
    {
        "number": 751,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    buses = 0\n    current_bus = 0\n\n    for group in a:\n        if current_bus + group > m:\n            buses += 1\n            current_bus = 0\n        current_bus += group\n\n    return str(buses + 1)"
    },
    {
        "number": 752,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = stdin.split('\\n')[1:n+1]\n    b = stdin.split('\\n')[n+1:]\n    \n    count = 0\n    for i in range(n):\n        if a[i] != b[i]:\n            count += 1\n    \n    return count"
    },
    {
        "number": 753,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a * d > b * c:\n        p = a * d\n        q = b * c\n    else:\n        p = b * c\n        q = a * d\n    return f\"{p}/{q}\""
    },
    {
        "number": 754,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    s = list(s)\n    count = 0\n\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n            s[i] = s[i + 1] = 'X'\n\n    return str(count)\n"
    },
    {
        "number": 755,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = 0\n    while x > 0:\n        if x >= 5:\n            x -= 5\n        elif x >= 4:\n            x -= 4\n        elif x >= 3:\n            x -= 3\n        elif x >= 2:\n            x -= 2\n        else:\n            x -= 1\n        steps += 1\n    return str(steps)"
    },
    {
        "number": 756,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, interesting_minutes = stdin.split()\n    interesting_minutes = list(map(int, interesting_minutes.split()))\n    boring_minutes = [i for i in range(1, 91) if i not in interesting_minutes]\n\n    boring_count = 0\n    watch_time = 0\n\n    for minute in range(1, 91):\n        if minute in interesting_minutes:\n            watch_time += 1\n            boring_count = 0\n        else:\n            boring_count += 1\n            if boring_count == 15:\n                break\n\n    return str(watch_time)\n"
    },
    {
        "number": 757,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    def dfs(i, visited, sockets):\n        if i == n:\n            return sockets >= m\n        if visited[i]:\n            return False\n        visited[i] = True\n        for j in range(n):\n            if not visited[j] and a[i] + a[j] <= k:\n                if dfs(j, visited, sockets + a[i] + a[j]):\n                    return True\n        visited[i] = False\n        return False\n\n    for i in range(n):\n        visited = [False] * n\n        if dfs(i, visited, a[i]):\n            return str(i + 1)\n    return \"-1\""
    },
    {
        "number": 758,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    operations = 0\n    red_balls = 0\n    blue_balls = 0\n\n    for ball in s:\n        if ball == 'R':\n            red_balls += 1\n        else:\n            blue_balls += 1\n\n    if blue_balls == 0:\n        return str(operations)\n\n    while red_balls > 0:\n        operations += 1\n        red_balls -= 1\n        blue_balls -= 1\n        if blue_balls == 0:\n            break\n        operations += 1\n        blue_balls += 1\n\n    return str(operations)"
    },
    {
        "number": 759,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm, H, D, C, N = map(int, stdin.split())\n    time = hh * 60 + mm\n    cat_hunger = H\n    bun_price = C\n    bun_discount = 0.8\n    bun_count = 0\n    total_cost = 0\n\n    while cat_hunger > 0:\n        if time >= 20 * 60:\n            bun_price *= bun_discount\n\n        bun_count = (cat_hunger + D - 1) // D\n        total_cost += bun_count * bun_price\n        cat_hunger -= bun_count * N\n        time += 1\n\n    return f\"{total_cost:.4f}\""
    },
    {
        "number": 760,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = s + k * 'a'\n    n = len(s)\n    max_length = 0\n\n    for i in range(n // 2):\n        if s[i] == s[i + n // 2]:\n            j = 1\n            while i - j >= 0 and i + n // 2 + j < n and s[i - j] == s[i + n // 2 + j]:\n                j += 1\n            max_length = max(max_length, 2 * j)\n\n    return max_length"
    },
    {
        "number": 761,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n\n    while len(values) > 1:\n        values = [max(values[i], values[i+1]) - min(values[i], values[i+1]) for i in range(0, len(values), 2)]\n\n    return str(values[0])"
    },
    {
        "number": 762,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, stdin.split())\n    sequence = list(map(int, input().split()))\n\n    even_count = sum(1 for num in sequence if num % 2 == 0)\n    odd_count = len(sequence) - even_count\n\n    if even_count != odd_count:\n        return \"0\"\n\n    max_cuts = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if sequence[i] % 2 == sequence[j] % 2:\n                max_cuts += 1\n\n    return str(max_cuts)\n"
    },
    {
        "number": 763,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, floors = stdin.split()\n    n = int(n)\n    floors = [int(x) for x in floors.split()]\n\n    total_electricity = 0\n    for i in range(n):\n        total_electricity += abs(i - floors[i])\n\n    return str(total_electricity)"
    },
    {
        "number": 764,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    y = stdin.readline().strip()\n\n    def shift_xor(x: str, k: int) -> str:\n        return x[k:] + x[:k]\n\n    count = 0\n    for k in range(n):\n        x = ''.join(['1' if y[i] != shift_xor(y, k)[i] else '0' for i in range(n)])\n        if x.count('1') == 0:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 765,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    times = 0\n    while S < T:\n        times += 1\n        T -= q - 1\n    return str(times)"
    },
    {
        "number": 766,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] != s[j]:\n                s[i], s[j] = s[j], s[i]\n                if is_adorable(s[:i+1]) and is_adorable(s[i+1:]):\n                    return \"Yes\"\n                s[i], s[j] = s[j], s[i]\n    return \"No\"\n\ndef"
    },
    {
        "number": 767,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n    x.sort()\n    count = 0\n    i = 0\n    j = 1\n\n    while i < n and j < n:\n        if x[j] - x[i] >= z:\n            count += 1\n            i = j + 1\n            j = i + 1\n        else:\n            j += 1\n\n    return str(count)"
    },
    {
        "number": 768,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split()[:3])\n    friends_opinions = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    liked_items = [0] * I\n    for friend_opinion in friends_opinions:\n        for i, item_liked in enumerate(friend_opinion):\n            if item_liked == 'Y':\n                liked_items[i] += 1\n\n    return str(sum(1 for like_count in liked_items if like_count >= T))"
    },
    {
        "number": 769,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    decimal_notation = str(a / b)\n    position = decimal_notation.find(str(c))\n    if position == -1:\n        return -1\n    else:\n        return position + 1"
    },
    {
        "number": 770,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, letters = stdin.split()\n    n = int(n)\n    letters = list(map(int, letters.split()))\n\n    unread_letters = sum(letters)\n    if unread_letters == 0:\n        return \"0\"\n\n    operations = 0\n    current_letter = 0\n    while unread_letters > 0:\n        if letters[current_letter] == 1:\n            operations += 1\n            letters[current_letter] = 0\n            unread_letters -= 1\n        current_letter += 1\n        if current_letter == n:\n            current_letter = 0\n\n    return str(operations)"
    },
    {
        "number": 771,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    numbers = list(map(int, stdin.split()[3:]))\n\n    def is_valid(selected_numbers):\n        for i in range(len(selected_numbers)):\n            for j in range(i + 1, len(selected_numbers)):\n                if (selected_numbers[j] - selected_numbers[i]) % m != 0:\n                    return False\n        return True\n\n    def backtrack(start, k, selected_numbers):\n        if k == 0:\n            if is_valid(selected_numbers):\n                return selected_numbers\n            return None\n\n        for i in range(start, len(numbers)):\n            if numbers[i] not in selected_numbers or selected_numbers.count(numbers[i]) < numbers.count(numbers[i]):\n                selected_numbers.append(numbers[i])\n                result = backtrack(i + 1, k - 1, selected_numbers)\n                if result is not None:\n                    return result\n                selected_numbers.pop()\n\n    result = backtrack(0, k, [])\n    if result is None:\n        return \"No\"\n    return \"Yes\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 772,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [list(map(int, line.split())) for line in stdin.splitlines()]\n    result = []\n    for row in lights:\n        result.append(\"\".join([\"1\" if x % 2 == 1 else \"0\" for x in row]))\n    return \"\\n\".join(result)"
    },
    {
        "number": 773,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    facts = []\n    for _ in range(q):\n        t, l, r, v = map(int, input().split())\n        facts.append((t, l, r, v))\n\n    def is_permutation(facts: List[Tuple[int, int, int, int]]) -> bool:\n        counts = [0] * (n + 1)\n        for t, l, r, v in facts:\n            if t == 1:\n                for i in range(l, r + 1):\n                    counts[i] = max(counts[i], v)\n            else:\n                for i in range(l, r + 1):\n                    counts[i] = min(counts[i], v)\n        return counts == list(range(1, n + 1))\n\n    if not is_permutation(facts):\n        return \"-1\"\n\n    def cost(facts: List[Tuple[int, int, int, int]]) -> int:\n        counts = [0] * (n + 1)\n        for t, l, r, v in facts:\n            if t == 1:\n                for i in range(l, r + 1):\n                    counts[i] = max(counts[i], v)\n            else:\n                for i in range(l, r + 1):\n                    counts[i] = min(counts[i], v)\n        return sum(count ** 2 for count in counts)\n\n    return str(cost(facts))"
    },
    {
        "number": 774,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    a = x\n    b = y\n    min_diff = float('inf')\n    min_a = 0\n    min_b = 0\n\n    for i in range(1, n + 1):\n        diff = abs(x / y - a / i)\n        if diff < min_diff:\n            min_diff = diff\n            min_a = a\n            min_b = i\n        elif diff == min_diff:\n            if i < min_b:\n                min_a = a\n                min_b = i\n        a += y\n\n    return f\"{min_a}/{min_b}\""
    },
    {
        "number": 775,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    holes = set(map(int, stdin.split()[3:]))\n    cups = [i for i in range(1, n+1)]\n    bone_position = 1\n\n    for _ in range(k):\n        u, v = map(int, stdin.split()[-2:])\n        cups[u-1], cups[v-1] = cups[v-1], cups[u-1]\n\n        if bone_position in holes:\n            bone_position = cups.index(bone_position) + 1\n\n    return str(bone_position)"
    },
    {
        "number": 776,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split()[:3])\n    mouses = []\n    for _ in range(int(stdin.split()[3])):\n        val, port = stdin.split()[4:].split()\n        mouses.append((int(val), port))\n\n    mouses.sort(key=lambda x: x[0], reverse=True)\n\n    usb_computers = a\n    ps2_computers = b\n    both_computers = c\n\n    total_cost = 0\n    equipped_computers = 0\n\n    for mouse in mouses:\n        if mouse[1] == \"USB\" and usb_computers > 0:\n            usb_computers -= 1\n            total_cost += mouse[0]\n            equipped_computers += 1\n        elif mouse[1] == \"PS/2\" and (ps2_computers > 0 or both_computers > 0):\n            if ps2_computers > 0:\n                ps2_computers -= 1\n            else:\n                both_computers -= 1\n            total_cost += mouse[0]\n            equipped_computers += 1\n\n    return str(equipped_computers) + \" \" + str(total_cost)"
    },
    {
        "number": 777,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count = 0\n    for i in range(n+1):\n        for j in range(i+1, n+1):\n            count += 1\n    return count"
    },
    {
        "number": 778,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return str(2**(2*n))\n\n    requirements = []\n    for _ in range(k):\n        x, sign, y = stdin.split()\n        requirements.append((int(x), sign, int(y)))\n\n    def is_valid(heights):\n        for i in range(2*n - 1):\n            if heights[i] > heights[i+1]:\n                return False\n        for i in range(2*n - 1):\n            if heights[i] < heights[i+1]:\n                return False\n        return True\n\n    def check_requirements(heights):\n        for x, sign, y in requirements:\n            if sign == '=':\n                if heights[x-1] != heights[y-1]:\n                    return False\n            elif sign == '>':\n                if heights[x-1] <= heights[y-1]:\n                    return False\n            elif sign == '<':\n                if heights[x-1] >= heights[y-1]:\n                    return False\n            elif sign == '>=':\n                if heights[x-1] < heights[y-1]:\n                    return False\n            elif sign == '<=':\n                if heights[x-1] > heights[y-1]:\n                    return False\n        return True\n\n    count = 0\n    for heights in itertools.permutations(range(1, n+1)):\n        if is_valid(heights) and check_requirements(heights):\n            count += 1\n\n    return str(count)\n\nimport sys\nfrom itertools import permutations\n\ninput_data = sys.stdin.read()\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 779,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for l in range(1, n + 1):\n        if n % l == 0:\n            result += 1\n    return str(result)"
    },
    {
        "number": 780,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_insertions(x, y, s):\n        if not s:\n            return 0\n        if s[0] == '0':\n            return min_insertions(x, y, s[1:])\n        if s[0] == str(x):\n            return min_insertions(x, y, s[1:]) + 1\n        if s[0] == str(y):\n            return min_insertions(x, y, s[1:]) + 1\n        return -1\n\n    result = []\n    for i in range(10):\n        row = []\n        for j in range(10):\n            row.append(min_insertions(i, j, stdin))\n        result.append(row)\n\n    return '\\n'.join([' '.join(map(str, row)) for row in result])\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 781,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    for i in range(len(board)):\n        if board[i][0] == \"B\":\n            continue\n        for j in range(1, len(board[i])):\n            if board[i][j] == board[i][j-1]:\n                return \"NO\"\n        board[i] = board[i][1:] + [board[i][0]]\n    return \"YES\""
    },
    {
        "number": 782,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, s = stdin.split('\\n')\n    m = int(m)\n    s = list(map(int, s.split()))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def find_sequence(s: list) -> str:\n        n = len(s)\n        sequence = []\n        for i in range(n):\n            sequence.append(s[i] - i)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if gcd(sequence[i], sequence[j]) not in s:\n                    return -1\n\n        return ' '.join(map(str, sequence))\n\n    result = find_sequence(s)\n    return result"
    },
    {
        "number": 783,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    houses = list(map(int, stdin.split()[1:]))\n    luxurious_houses = []\n\n    for i in range(n):\n        luxurious = True\n        for j in range(i + 1, n):\n            if houses[j] <= houses[i]:\n                luxurious = False\n                break\n        if luxurious:\n            luxurious_houses.append(i)\n\n    result = []\n    for i in range(n):\n        if i in luxurious_houses:\n            result.append(0)\n        else:\n            result.append(houses[i] - houses[luxurious_houses[0]])\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 784,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b <= a:\n        return \"NO\"\n\n    queue = [(a, [a])]\n    while queue:\n        num, path = queue.pop(0)\n        if num == b:\n            return \"YES\\n\" + str(len(path)) + \"\\n\" + \" \".join(map(str, path))\n        if num * 2 <= b:\n            queue.append((num * 2, path + [num * 2]))\n        if num * 10 + 1 <= b:\n            queue.append((num * 10 + 1, path + [num * 10 + 1]))\n\n    return \"NO\"\n"
    },
    {
        "number": 785,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    min_area = 6 * n\n    if a * b < min_area:\n        if a >= b:\n            a = min_area // b\n            b = min_area // a\n        else:\n            b = min_area // a\n            a = min_area // b\n    return f\"{min_area}\\n{a} {b}\""
    },
    {
        "number": 786,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    max_rating = 1900\n    current_rating = 1000\n    current_division = 1\n\n    for _ in range(n):\n        change, division = map(int, stdin.readline().split())\n\n        if current_division == 1 and division == 2:\n            if current_rating + change >= 1900:\n                return \"Infinity\"\n            else:\n                current_rating += change\n                current_division = 2\n        elif current_division == 2 and division == 1:\n            if current_rating + change <= 1899:\n                return \"Impossible\"\n            else:\n                current_rating += change\n                current_division = 1\n        else:\n            return \"Impossible\"\n\n    return str(current_rating)\n"
    },
    {
        "number": 787,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = stdin.split()\n    k = int(k)\n    if k > 26:\n        return \"NO\"\n\n    for i in range(1, k):\n        if q.count(q[:i]) > 1:\n            return \"NO\"\n\n    for i in range(1, k):\n        if q[:i] in q[i:]:\n            return \"NO\"\n\n    for i in range(1, k):\n        if q[i] in q[:i]:\n            return \"NO\"\n\n    for i in range(1, k):\n        if q[i] in q[i+1:]:\n            return \"NO\"\n\n    return \"YES\" + \"\\n\" + \"\\n\".join(q[i:i+k] for i in range(len(q)-k+1))\n"
    },
    {
        "number": 788,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return int(stdin[1:3])"
    },
    {
        "number": 789,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lucky_digits = set(['4', '7'])\n    lucky_numbers = []\n    for i in range(1, 10**9 + 1):\n        if all(digit in lucky_digits for digit in str(i)):\n            lucky_numbers.append(i)\n    return str(lucky_numbers.index(int(stdin)) + 1)"
    },
    {
        "number": 790,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:2*N+2:2]))\n    D = list(map(int, stdin.split()[3:2*N+3:2]))\n\n    def excite(i: int, E: List[int]) -> int:\n        energy = A[i]\n        for j in range(N):\n            if E[j] == i+1:\n                energy += A[j]\n        return energy\n\n    def change_bond(E: List[int]) -> int:\n        max_energy = 0\n        for i in range(N):\n            for j in range(N):\n                if i != j and E[i] != E[j]:\n                    new_E = E.copy()\n                    new_E[i] = j+1\n                    max_energy = max(max_energy, excite(i, new_E))\n        return max_energy\n\n    return str(change_bond([i+1 for i in range(N)]))"
    },
    {
        "number": 791,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bits = stdin.split()\n    n = int(n)\n    bits = list(bits)\n    carry = 0\n    changed_bits = 0\n\n    for i in range(n):\n        bit = int(bits[i])\n        if bit == 0:\n            bits[i] = 1\n            changed_bits += 1\n            break\n        elif bit == 1:\n            bits[i] = 0\n            carry = 1\n\n    if carry == 1:\n        for i in range(n):\n            bit = int(bits[i])\n            if bit == 0:\n                bits[i] = 1\n                changed_bits += 1\n                break\n            elif bit == 1:\n                bits[i] = 0\n                carry = 1\n\n    return str(changed_bits)"
    },
    {
        "number": 792,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    transactions = list(map(int, input().split()))\n\n    current_money = 0\n    days_to_deposit = 0\n\n    for transaction in transactions:\n        if transaction > 0:\n            if current_money + transaction > d:\n                return \"-1\"\n            current_money += transaction\n        elif transaction < 0:\n            if current_money + transaction < 0:\n                return \"-1\"\n            current_money += transaction\n        else:\n            if current_money > d:\n                return \"-1\"\n            days_to_deposit += 1\n\n    return str(days_to_deposit)"
    },
    {
        "number": 793,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:]))\n\n    def count_subsequences(sequence: list) -> int:\n        subsequences = [[]]\n        for num in sequence:\n            new_subsequences = []\n            for subsequence in subsequences:\n                new_subsequences.append(subsequence + [num])\n            subsequences.extend(new_subsequences)\n        return len(subsequences)\n\n    count_S = count_subsequences(S)\n    count_T = count_subsequences(T)\n\n    result = (count_S * count_T) % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 794,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if sum(a[:n]) == sum(a[n:]):\n        return \"-1\"\n\n    for i in range(n):\n        a[i], a[i+n] = a[i+n], a[i]\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 795,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = (a**2 + b**2)**0.5\n            if c <= n:\n                count += 1\n    return str(count)"
    },
    {
        "number": 796,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(n: int, k: int) -> int:\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if i == j:\n                    dp[i][j] += 1\n                dp[i][j] %= MOD\n        return dp[n][k]\n\n    return str(count_ways(n, k))"
    },
    {
        "number": 797,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    g_0, x, y, z = map(int, stdin.split())\n\n    def g(i: int, j: int) -> int:\n        return (g_0 + (x * i + y) * j) % z\n\n    matrix = [[g(i, j) for j in range(m)] for i in range(n)]\n\n    def submatrix_min_sum(matrix: List[List[int]], a: int, b: int) -> int:\n        submatrix_min = float('inf')\n        for i in range(n - a + 1):\n            for j in range(m - b + 1):\n                submatrix = [matrix[i + k][j:j + b] for k in range(a)]\n                submatrix_min_height = min(min(row) for row in submatrix)\n                submatrix_min = min(submatrix_min, submatrix_min_height)\n        return submatrix_min\n\n    return str(submatrix_min_sum(matrix, a, b))"
    },
    {
        "number": 798,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b + c > 6:\n        return \"Impossible\"\n    elif a + b + c == 6:\n        return \"0 1 1\"\n    elif a + b + c == 5:\n        return \"1 3 2\"\n    else:\n        return \"Impossible\""
    },
    {
        "number": 799,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    welfare = list(map(int, stdin.split()[1:]))\n    welfare.sort()\n    total_welfare = sum(welfare)\n    min_cost = 0\n    for i in range(n):\n        min_cost += (total_welfare - welfare[i])\n    return str(min_cost)"
    },
    {
        "number": 800,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    mannequins = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def angle(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        return abs(math.degrees(math.atan2(y2 - y1, x2 - x1)))\n\n    def min_angle(mannequins):\n        angles = [angle(mannequins[0], mannequins[i]) for i in range(1, len(mannequins))]\n        return min(angles)\n\n    return f\"{min_angle(mannequins):.6f}\""
    },
    {
        "number": 801,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    def mex(arr):\n        taken = set()\n        for x in arr:\n            taken.add(x)\n        for i in range(1, n+1):\n            if i not in taken:\n                return i\n        return -1\n    \n    def mex_of_subarrays(a):\n        m = len(a)\n        mex_list = []\n        for i in range(m):\n            for j in range(i, m):\n                mex_list.append(mex(a[i:j+1]))\n        return mex(mex_list)\n    \n    return str(mex_of_subarrays(a))"
    },
    {
        "number": 802,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    types = set(s)\n    visited = set()\n    count = 0\n\n    for i in range(n):\n        if s[i] not in visited:\n            visited.add(s[i])\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 803,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    hamsters = stdin.split('\\n')[1]\n    standing = hamsters.count('X')\n    if standing == n // 2:\n        return \"0\\n\" + hamsters\n    elif standing > n // 2:\n        return str(standing - n // 2) + \"\\n\" + hamsters\n    else:\n        return str(n // 2 - standing) + \"\\n\" + hamsters"
    },
    {
        "number": 804,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    k = int(k)\n    if len(set(s)) >= k:\n        return 0\n    else:\n        return \"impossible\""
    },
    {
        "number": 805,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    segments.sort(key=lambda x: x[0])\n\n    total_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][1] <= segments[j][0]:\n                total_length += segments[i][1] - segments[i][0]\n            elif segments[i][0] >= segments[j][1]:\n                total_length += segments[j][1] - segments[j][0]\n            else:\n                total_length += min(segments[i][1], segments[j][1]) - max(segments[i][0], segments[j][0])\n\n    return str(total_length)"
    },
    {
        "number": 806,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    if n == 1:\n        return str((r - l + 1) % (10**9 + 7))\n    elif n == 2:\n        return str((r - l + 1) * (r - l) % (10**9 + 7))\n    else:\n        return str((r - l + 1) * (r - l) % (10**9 + 7))"
    },
    {
        "number": 807,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0].split())\n    prices = list(map(int, stdin.split()[1].split()))\n\n    if n == 1:\n        return str(min(prices[0], c))\n\n    max_profit = 0\n    for i in range(1, n):\n        if prices[i] - prices[i - 1] > c:\n            max_profit += c\n        else:\n            max_profit += prices[i] - prices[i - 1]\n\n    return str(max_profit)\n"
    },
    {
        "number": 808,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a = int(x // 1)\n    b = 0\n    while x > 10:\n        x /= 10\n        b += 1\n    while x < 1:\n        x *= 10\n        b -= 1\n    if b == 0:\n        return f\"{a}\"\n    elif a == 1:\n        return f\"1E{b}\"\n    else:\n        return f\"{a}E{b}\""
    },
    {
        "number": 809,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a == 0:\n        return \"NO\"\n    if n > a * k:\n        return \"NO\"\n    if n > a + b:\n        return \"NO\"\n    if n > a + b * k:\n        return \"NO\"\n    if n > a * k + b * k:\n        return \"NO\"\n    if n > a * k + b * (k - 1):\n        return \"NO\"\n    if n > a * k + b * (k - 2):\n        return \"NO\"\n    if n > a * k + b * (k - 3):\n        return \"NO\"\n    if n > a * k + b * (k - 4):\n        return \"NO\"\n    if n > a * k + b * (k - 5):\n        return \"NO\"\n    if n > a * k + b * (k - 6):\n        return \"NO\"\n    if n > a * k + b * (k - 7):\n        return \"NO\"\n    if n > a * k + b * (k - 8):\n        return \"NO\"\n    if n > a * k + b * (k - 9):\n        return \"NO\"\n    if n > a * k + b * (k - 10):\n        return \"NO\"\n    if n > a * k + b * (k - 11):\n        return \"NO\"\n    if n > a * k + b * (k - 12):\n        return \"NO\"\n    if n > a * k + b * (k - 13):\n        return \"NO\"\n    if n > a * k + b * (k - 14):\n        return \"NO\"\n    if n > a * k + b * (k - 15):\n        return \"NO\"\n    if n > a * k + b * (k - 16):\n        return \"NO\"\n    if n > a * k + b * (k - 17):\n        return \"NO\"\n    if n > a * k + b * (k - 18):\n        return \"NO\"\n    if n > a * k + b * (k - 19):\n        return \"NO\"\n    if n > a * k + b * (k - 20):\n        return \"NO\"\n    if n > a * k + b * (k - 21):\n        return \"NO\"\n    if n > a * k + b * (k - 22):\n        return \"NO\"\n    if n > a * k + b * (k - 23):\n        return \"NO\"\n    if n > a * k + b * (k - 24):\n        return \"NO\"\n    if n > a * k + b * (k - 25):\n        return \"NO\"\n    if n > a * k + b * (k - 26):\n        return \"NO\"\n    if n > a * k + b * (k - 27):\n        return \"NO\"\n    if n > a * k + b * (k - 28):\n        return \"NO\"\n    if n > a * k + b * (k - 29):\n        return \"NO\"\n    if n > a * k + b * (k - 30):\n        return \"NO\"\n    if n > a * k + b * (k - 31):\n        return \"NO\"\n    if n > a * k + b * (k - 32):\n        return \"NO\"\n    if n > a * k + b * (k - 33):\n        return \"NO\"\n    if n > a * k + b * (k - 34):\n        return \"NO\"\n    if n > a * k + b * (k - 35):\n        return \"NO\"\n    if n > a * k + b * (k - 36):\n        return \"NO\"\n    if n > a * k + b * (k - 37):\n        return \"NO\"\n    if n > a * k + b * (k - 38):\n        return \"NO\"\n    if n > a * k + b * (k - 39):\n        return \""
    },
    {
        "number": 810,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 1000000007\n\n    def is_good(num: int) -> bool:\n        while num > 0:\n            digit = num % 10\n            if digit != a and digit != b:\n                return False\n            num //= 10\n        return True\n\n    def is_excellent(num: int) -> bool:\n        total = 0\n        while num > 0:\n            digit = num % 10\n            total += digit\n            num //= 10\n        return is_good(total)\n\n    count = 0\n    for i in range(1, b * 10**(n - 1)):\n        if is_excellent(i):\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 811,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    while a > 0:\n        hours += 1\n        a -= 1\n        if a < b:\n            a = b\n    return str(hours)"
    },
    {
        "number": 812,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        if is_arithmetic_progression(b[:i] + b[i+1:]):\n            return str(i+1)\n\n    return \"-1\"\n\ndef"
    },
    {
        "number": 813,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    arthur_likes = set(map(int, stdin.split()[3:3+a]))\n    alexander_likes = set(map(int, stdin.split()[3+a:]))\n\n    result = [''] * n\n    for i in range(1, n+1):\n        if i in arthur_likes:\n            result[i-1] = '1'\n        elif i in alexander_likes:\n            result[i-1] = '2'\n\n    return ''.join(result)\n"
    },
    {
        "number": 814,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cubes = list(map(int, stdin.split()[1:]))\n    result = []\n    \n    for i in range(n):\n        result.append(sum(cubes[:i+1]))\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 815,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V1, V2, V3, Vm = map(int, stdin.split())\n    if V1 > V2 > V3:\n        if V1 > Vm >= V2 > V3:\n            return f\"{V1}\\n{V2}\\n{V3}\"\n        elif V1 > Vm >= V3 > V2:\n            return f\"{V1}\\n{V3}\\n{V2}\"\n        elif V2 > Vm >= V1 > V3:\n            return f\"{V2}\\n{V1}\\n{V3}\"\n        elif V2 > Vm >= V3 > V1:\n            return f\"{V2}\\n{V3}\\n{V1}\"\n        elif V3 > Vm >= V1 > V2:\n            return f\"{V3}\\n{V1}\\n{V2}\"\n        elif V3 > Vm >= V2 > V1:\n            return f\"{V3}\\n{V2}\\n{V1}\"\n    return \"-1\""
    },
    {
        "number": 816,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 817,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    result = []\n\n    for i in range(n, 0, -1):\n        suffix = s[n - i:]\n        pairs = []\n        for j in range(i - 1):\n            if suffix[j] == suffix[j + 1]:\n                pairs.append((j, j + 1))\n        if pairs:\n            for pair in pairs:\n                suffix = suffix[:pair[0]] + suffix[pair[1]:]\n            result.append(suffix)\n\n    return result\n\n\ndef"
    },
    {
        "number": 818,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_number = 10**(n-1) * 2\n    max_number = 10**n - 1\n\n    for num in range(min_number, max_number+1):\n        if all(num % prime == 0 for prime in [2, 3, 5, 7]):\n            return str(num)\n\n    return \"-1\""
    },
    {
        "number": 819,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    subsegments = []\n    for i in range(k):\n        subsegments.append(a[i * (n // k): (i + 1) * (n // k)])\n\n    if n % k != 0:\n        for i in range(n % k):\n            subsegments[-1].append(a[n // k * k + i])\n\n    min_values = [min(subsegment) for subsegment in subsegments]\n    return str(max(min_values))"
    },
    {
        "number": 820,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0:2])\n    a = list(map(int, stdin.split('\\n')[2:]))\n    min_drives = float('inf')\n    for i in range(1, m + 1):\n        drives_needed = 0\n        current_size = 0\n        for j in range(n):\n            if current_size + a[j] <= i:\n                current_size += a[j]\n            else:\n                drives_needed += 1\n                current_size = a[j]\n        min_drives = min(min_drives, drives_needed)\n    return str(min_drives)"
    },
    {
        "number": 821,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    time_1 = s * v_1 + t_1\n    time_2 = s * v_2 + t_2\n    if time_1 < time_2:\n        return \"First\"\n    elif time_1 > time_2:\n        return \"Second\"\n    else:\n        return \"Friendship\""
    },
    {
        "number": 822,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists_killed = 0\n    for i in range(1, z + 1):\n        if i % n == 0 or i % m == 0:\n            artists_killed += 1\n    return str(artists_killed)"
    },
    {
        "number": 823,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n    current_x, current_y = 0, 0\n    direction = 0  # 0: right, 1: up, 2: left, 3: down\n\n    while current_x != x or current_y != y:\n        if direction == 0:\n            if current_x < x:\n                current_x += 1\n            else:\n                direction = 1\n                current_y += 1\n        elif direction == 1:\n            if current_y < y:\n                current_y += 1\n            else:\n                direction = 2\n                current_x -= 1\n        elif direction == 2:\n            if current_x > x:\n                current_x -= 1\n            else:\n                direction = 3\n                current_y -= 1\n        elif direction == 3:\n            if current_y > y:\n                current_y -= 1\n            else:\n                direction = 0\n                current_x += 1\n        turns += 1\n\n    return str(turns)"
    },
    {
        "number": 824,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_rsbs(s: str) -> bool:\n        n = len(s)\n        if n == 0 or n % 2 != 0:\n            return False\n        for i in range(n // 2):\n            if s[i] != \"(\" or s[n - i - 1] != \")\":\n                return False\n        return True\n\n    def count_rsbs_subsequences(s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            count = 0\n            for j in range(i):\n                if is_rsbs(s[j:i]):\n                    count += dp[j]\n            dp[i] = count\n        return dp[n]\n\n    return str(count_rsbs_subsequences(stdin) % (10**9 + 7))"
    },
    {
        "number": 825,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    max_count = 0\n    while N > 1:\n        z = None\n        for p in range(2, int(N**0.5)+1):\n            if N % p == 0:\n                e = 0\n                while N % p == 0:\n                    e += 1\n                    N //= p\n                if z is None or z > p**e:\n                    z = p**e\n        N //= z\n        max_count += 1\n    return str(max_count)"
    },
    {
        "number": 826,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + 1\n        j = 1\n        while j * (i - j) < i:\n            dp[i] = min(dp[i], dp[j] + dp[i - j])\n            j += 1\n\n    return str(dp[n])"
    },
    {
        "number": 827,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = stdin.split()\n    N = int(N)\n    T = int(T)\n    S = \"110\" * 10**10\n    count = 0\n    for i in range(len(S) - N + 1):\n        if S[i:i+N] == T:\n            count += 1\n    return str(count)"
    },
    {
        "number": 828,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, *superiors = map(int, stdin.split())\n    min_mistake = n\n    for i in range(n):\n        if i == s - 1:\n            continue\n        mistake = 0\n        for superior in superiors:\n            if superior == i:\n                mistake += 1\n        min_mistake = min(min_mistake, mistake)\n    return str(min_mistake)"
    },
    {
        "number": 829,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_good(string: str) -> bool:\n        return string.count('0') != string.count('1')\n\n    def cut(s: str) -> list[str]:\n        result = []\n        current = ''\n        for char in s:\n            current += char\n            if is_good(current):\n                result.append(current)\n                current = ''\n        if current:\n            result.append(current)\n        return result\n\n    cut_s = cut(s)\n    return str(len(cut_s)) + '\\n' + ' '.join(cut_s)"
    },
    {
        "number": 830,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    towers = list(map(int, stdin.split()[2:]))\n    min_instability = float('inf')\n    min_operations = []\n\n    def get_instability(towers):\n        return max(towers) - min(towers)\n\n    def perform_operation(towers, i, j):\n        if i == j:\n            return towers\n        towers[i - 1] -= 1\n        towers[j - 1] += 1\n        return towers\n\n    def backtrack(towers, operations, current_k):\n        nonlocal min_instability, min_operations\n        if current_k == 0:\n            instability = get_instability(towers)\n            if instability < min_instability:\n                min_instability = instability\n                min_operations = operations\n            return\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j:\n                    new_towers = perform_operation(towers.copy(), i, j)\n                    new_operations = operations + [(i, j)]\n                    backtrack(new_towers, new_operations, current_k - 1)\n\n    backtrack(towers, [], k)\n\n    result = [str(min_instability), str(len(min_operations))]\n    result.extend([' '.join(map(str, operation)) for operation in min_operations])\n    return '\\n'.join(result)\n"
    },
    {
        "number": 831,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.split()[0]\n    n = int(stdin.split()[1])\n    s_a = []\n\n    for i in range(n):\n        s, a = stdin.split()[2 + i].split()\n        s_a.append((s, int(a)))\n\n    def dfs(t: str, i: int, money: int, used: set) -> int:\n        if i == len(t):\n            return money\n\n        min_money = float('inf')\n        for j in range(n):\n            if s_a[j][0][0] == t[i] and s_a[j][1] > 0 and j not in used:\n                new_s = s_a[j][0][1:]\n                new_a = s_a[j][1] - 1\n                new_used = used.copy()\n                new_used.add(j)\n                min_money = min(min_money, dfs(t, i + 1, money + (i + 1) * j, new_used))\n                s_a[j] = (new_s, new_a)\n\n        return min_money\n\n    return dfs(t, 0, 0, set())\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 832,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    teams = {}\n    for i in range(1, n+1):\n        h, a = map(int, stdin.split('\\n')[i].split())\n        teams[i] = {'home': h, 'guest': a}\n\n    count = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if teams[i]['home'] == teams[j]['guest'] or teams[j]['home'] == teams[i]['guest']:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 833,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split()[0].split())\n    trees = []\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        trees.append((a, b))\n\n    trees.sort(key=lambda x: x[0])\n    result = 0\n    current_day = 1\n    for tree in trees:\n        if current_day < tree[0]:\n            result += (tree[0] - current_day) * v\n            current_day = tree[0]\n        if current_day == tree[0]:\n            result += min(tree[1], v)\n            current_day += 1\n            if tree[1] > v:\n                result += (tree[1] - v) * v\n                current_day += (tree[1] - v) // v\n    return str(result)"
    },
    {
        "number": 834,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_idempotent(g: Callable[[int], int]) -> bool:\n        return all(g(g(x)) == g(x) for x in range(1, n + 1))\n\n    for k in range(1, n + 1):\n        g = lambda x: f[f[x - 1] - 1]\n        if is_idempotent(g):\n            return str(k)\n\n    return \"Not found\""
    },
    {
        "number": 835,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = stdin.split()\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, [n_b, n_s, n_c, p_b, p_s, p_c, r])\n\n    max_hamburgers = min(n_b // recipe.count('B'), n_s // recipe.count('S'), n_c // recipe.count('C'))\n\n    return str(max_hamburgers)"
    },
    {
        "number": 836,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0].split())\n    street = stdin.split()[1]\n\n    houses = 0\n    shops = 0\n    for segment in street:\n        if segment == \"H\":\n            houses += 1\n        elif segment == \"S\":\n            shops += 1\n\n    if houses > shops:\n        return str(houses - shops)\n    else:\n        return \"-1\""
    },
    {
        "number": 837,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    t = 0\n    while n > 0:\n        if n % 2 == 0:\n            n //= 2\n            t += x\n        else:\n            n -= 1\n            t += x\n        t += y\n    return str(t)"
    },
    {
        "number": 838,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    table = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def is_valid(cell1, cell2):\n        return cell1[0] == cell2[0] or cell1[1] == cell2[1]\n    \n    def dfs(cell, visited):\n        if cell in visited:\n            return 0\n        visited.add(cell)\n        count = 1\n        for i in range(n):\n            for j in range(m):\n                if table[i][j] == table[cell[0]][cell[1]] and is_valid(cell, (i, j)):\n                    count += dfs((i, j), visited)\n        return count\n    \n    count = 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                count += dfs((i, j), visited)\n    \n    return str(count)"
    },
    {
        "number": 839,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g = []\n    for line in stdin.split(\"\\n\"):\n        g.append([int(x) for x in line.split()])\n\n    def happiness(line: list) -> int:\n        total = 0\n        for i in range(len(line)):\n            for j in range(i + 2, len(line), 2):\n                total += g[line[i] - 1][line[j] - 1]\n                total += g[line[j] - 1][line[i] - 1]\n        return total\n\n    max_happiness = 0\n    for perm in itertools.permutations([1, 2, 3, 4, 5]):\n        line = list(perm)\n        happiness_score = happiness(line)\n        max_happiness = max(max_happiness, happiness_score)\n\n    return str(max_happiness)"
    },
    {
        "number": 840,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    max_cookies = 0\n    \n    for i in range(n):\n        if a[i] <= k:\n            max_cookies += b[i] // a[i]\n            k -= a[i]\n    \n    return str(max_cookies)"
    },
    {
        "number": 841,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    queries = [int(line) for line in stdin.splitlines()[1:]]\n\n    def find_subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i:i+3] == \"1337\":\n                count += 1\n        return count\n\n    for n in queries:\n        for i in range(100000):\n            s = \"137\" * i\n            if find_subsequences(s) == n:\n                print(s)\n                break\n    return \"\" "
    },
    {
        "number": 842,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    i = 1\n    while True:\n        palindrome = str(i)\n        if palindrome == palindrome[::-1] and len(palindrome) % 2 == 0:\n            count += 1\n            if count == n:\n                return palindrome\n        i += 1"
    },
    {
        "number": 843,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, directions, lengths = stdin.split('\\n')\n    n = int(n)\n    directions = list(directions)\n    lengths = [int(x) for x in lengths.split()]\n\n    current_cell = 0\n    jumps = 0\n\n    while current_cell < n:\n        if directions[current_cell] == '>':\n            current_cell += lengths[current_cell]\n        else:\n            current_cell -= lengths[current_cell]\n        jumps += 1\n\n    return \"INFINITE\" if jumps == 0 else \"FINITE\""
    },
    {
        "number": 844,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if len(substring) % 2 == 0:\n                if substring.count('0') == substring.count('1'):\n                    max_length = max(max_length, len(substring))\n\n    return str(max_length)"
    },
    {
        "number": 845,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.split('\\n')\n    keyboard = \"qwertyuiopasdfghjkl;zxcvbnm,./\"\n    shift = 0\n    if direction == 'R':\n        shift = 1\n    elif direction == 'L':\n        shift = -1\n    result = \"\"\n    for char in message:\n        index = keyboard.index(char)\n        result += keyboard[(index + shift) % len(keyboard)]\n    return result"
    },
    {
        "number": 846,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    buttons = list(map(int, stdin.split()[2:]))\n    lights = [0] * n\n\n    for button in buttons:\n        for i in range(button - 1, n):\n            lights[i] = button\n\n    return \" \".join(map(str, lights))\n"
    },
    {
        "number": 847,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    cards = list(map(int, input().split()))\n    cards.sort()\n    total = sum(cards)\n    if total == 0:\n        return str(n)\n    elif total < 0:\n        return str(n + abs(total))\n    else:\n        return str(n - abs(total))"
    },
    {
        "number": 848,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"1\\n1 1\"\n    if n == 2:\n        return \"2\\n1 2\\n2 1\"\n    if n == 3 and k == 1:\n        return \"3\\n1 2\\n2 3\\n3 1\"\n    if n == 3 and k == 2:\n        return \"6\\n1 2\\n1 3\\n2 3\\n2 1\\n3 1\\n3 2\"\n    return \"-1\""
    },
    {
        "number": 849,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_smallr = a / b\n    p_zanoes = c / d\n    if p_smallr > p_zanoes:\n        return \"{:.6f}\".format(1 - p_smallr)\n    else:\n        return \"{:.6f}\".format(p_smallr)"
    },
    {
        "number": 850,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, numbers = stdin.split()\n    k = int(k)\n    numbers = list(map(int, numbers.split()))\n\n    def can_sum(a, b):\n        return any(a[i] == b[i] == '0' or a[i] == b[i] for i in range(len(a)))\n\n    numbers.sort(reverse=True)\n    result = []\n    for i in range(k):\n        for j in range(i+1, k):\n            if can_sum(str(numbers[i]), str(numbers[j])):\n                result.append(numbers[i])\n                result.append(numbers[j])\n                break\n        if len(result) == k:\n            break\n\n    return str(len(result)) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 851,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    schedule = list(map(int, stdin.split()))\n\n    eating_schedule = [0] * n\n    eating_schedule[0] = k\n    eating_schedule[-1] = k\n\n    for i in range(1, n - 1):\n        if schedule[i] == 0:\n            eating_schedule[i] = min(eating_schedule[i - 1], k - eating_schedule[i - 1])\n\n    max_break = 0\n    for i in range(1, n - 1):\n        if schedule[i] == 1:\n            max_break = max(max_break, eating_schedule[i - 1] - eating_schedule[i])\n\n    return str(max_break)"
    },
    {
        "number": 852,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    for i in range(0, len(test_cases), 2):\n        n, k, l = map(int, test_cases[i].split())\n        d = list(map(int, test_cases[i+1].split()))\n        p = [0] * (2*k)\n        for j in range(k):\n            p[j] = j\n        for j in range(k, 2*k):\n            p[j] = k-1-j\n        x = 0\n        t = 0\n        while x < n:\n            if t % 2 == 0:\n                x += 1\n            else:\n                x -= 1\n            t += 1\n            if x == n:\n                break\n            depth = d[x] + p[t % (2*k)]\n            if depth > l:\n                break\n        if x == n:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 853,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = stdin.split('\\n')\n    n = int(n)\n    cards = list(map(int, cards.split()))\n\n    def is_divisible_by_90(number: int) -> bool:\n        return number % 90 == 0\n\n    def find_largest_divisible_by_90(cards: list) -> int:\n        cards.sort(reverse=True)\n        result = 0\n        for card in cards:\n            if card == 0:\n                continue\n            if is_divisible_by_90(result + card):\n                result += card\n            else:\n                break\n        return result\n\n    largest_divisible_by_90 = find_largest_divisible_by_90(cards)\n    return str(largest_divisible_by_90) if largest_divisible_by_90 != 0 else \"-1\""
    },
    {
        "number": 854,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    total_candies = 0\n    current_booth = 1\n    current_candies = 0\n\n    while T >= a[current_booth - 1] and current_candies < n:\n        if T >= a[current_booth - 1]:\n            T -= a[current_booth - 1]\n            current_candies += 1\n        current_booth = (current_booth % n) + 1\n\n    total_candies += current_candies\n\n    return str(total_candies)"
    },
    {
        "number": 855,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    A = [list(map(int, line.split())) for line in stdin.split('\\n')[3:6]]\n    B = [list(map(int, line.split())) for line in stdin.split('\\n')[6:9]]\n\n    alice_score = 0\n    bob_score = 0\n\n    for i in range(k):\n        if i == 0:\n            alice_choice = a\n            bob_choice = b\n        else:\n            alice_choice = A[alice_score][bob_choice - 1]\n            bob_choice = B[bob_score][alice_choice - 1]\n\n        if alice_choice == bob_choice:\n            continue\n        elif alice_choice > bob_choice:\n            alice_score += 1\n        else:\n            bob_score += 1\n\n    return f\"{alice_score} {bob_score}\""
    },
    {
        "number": 856,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split('\\n')\n    result = []\n    for i in range(1, len(cases), 2):\n        n, k = map(int, cases[i-1].split())\n        a = list(map(int, cases[i].split()))\n        d = max(a)\n        for _ in range(k):\n            a = [d - x for x in a]\n        result.append(' '.join(map(str, a)))\n    return '\\n'.join(result)"
    },
    {
        "number": 857,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    sequence = list(map(int, stdin.split()[2:n+2]))\n    keys_with_fingerprints = set(map(int, stdin.split()[n+2:]))\n\n    longest_subsequence = []\n    for i in range(n):\n        if sequence[i] in keys_with_fingerprints:\n            longest_subsequence.append(sequence[i])\n        else:\n            longest_subsequence = []\n\n    return ' '.join(map(str, longest_subsequence))\n"
    },
    {
        "number": 858,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)"
    },
    {
        "number": 859,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.splitlines()\n    s2 = s2.replace('?', '+')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace('-', '+')\n    s2 = s2.replace('+', '-')\n    s2 = s2.replace"
    },
    {
        "number": 860,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"Possible\\n1\"\n\n    # Create a graph\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j and a[i] & (1 << j):\n                graph[i].append(j)\n\n    # Find a topological order\n    visited = [False] * n\n    order = []\n\n    def dfs(u: int):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n        order.append(u)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    # Check if the order is valid\n    for i in range(n):\n        for j in range(n):\n            if i != j and a[i] & (1 << j):\n                if order.index(i) > order.index(j):\n                    return \"Impossible\"\n\n    # Return the order\n    return \"Possible\\n\" + \" \".join(map(str, order[::-1]))"
    },
    {
        "number": 861,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    return str(2 * R)"
    },
    {
        "number": 862,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    entrance = 1\n    while a[entrance - 1] > 0:\n        entrance = (entrance % n) + 1\n    return str(entrance)"
    },
    {
        "number": 863,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, departure_time = map(int, stdin.split())\n    departure_hour, departure_minute = map(int, departure_time.split(':'))\n\n    # Calculate the number of buses Simion will meet on the way\n    total_buses = (departure_hour * 60 + departure_minute) // t_a + (departure_hour * 60 + departure_minute) // t_b\n\n    # Calculate the number of buses Simion will meet in the city A and B\n    buses_in_a = (departure_hour * 60 + departure_minute) // t_a\n    buses_in_b = (departure_hour * 60 + departure_minute) // t_b\n\n    # Calculate the number of buses Simion will meet on the way excluding the encounters in cities A and B\n    buses_on_the_way = total_buses - buses_in_a - buses_in_b\n\n    return str(buses_on_the_way)"
    },
    {
        "number": 864,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    food_types = list(map(int, stdin.split()[2:]))\n\n    if n > m:\n        return \"0\"\n\n    food_types_count = {}\n    for food_type in food_types:\n        if food_type in food_types_count:\n            food_types_count[food_type] += 1\n        else:\n            food_types_count[food_type] = 1\n\n    max_days = 0\n    for food_type in food_types_count:\n        max_days = max(max_days, food_types_count[food_type] // n)\n\n    return str(max_days)"
    },
    {
        "number": 865,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, T = map(int, lines[0].split())\n    dishes = []\n    for line in lines[1:]:\n        A, B = map(int, line.split())\n        dishes.append((A, B))\n\n    dishes.sort(key=lambda x: x[1], reverse=True)\n    happiness = 0\n    time_left = T - 0.5\n\n    for i in range(N):\n        if time_left <= 0:\n            break\n        A, B = dishes[i]\n        if time_left >= A:\n            happiness += B\n            time_left -= A\n\n    return str(happiness)"
    },
    {
        "number": 866,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def knight_moves(x: int, y: int) -> int:\n        if x < 0 or x > X or y < 0 or y > Y:\n            return 0\n        if x == X and y == Y:\n            return 1\n        return (knight_moves(x + 1, y + 2) + knight_moves(x + 2, y + 1)) % MOD\n\n    return str(knight_moves(0, 0))"
    },
    {
        "number": 867,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    else:\n        return str(N - 1)"
    },
    {
        "number": 868,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 1378 ** n\n    return str(result % 10)"
    },
    {
        "number": 869,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = min(a, b)\n    same_days = max(a, b)\n\n    if a == b:\n        same_days = max_days\n\n    return f\"{max_days} {same_days}\""
    },
    {
        "number": 870,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v_1, v_2 = map(int, stdin.split())\n    t = L / (v_1 + v_2)\n    if d >= L:\n        return \"0.00000000000000000000\"\n    elif d * 2 <= L:\n        return \"inf\"\n    else:\n        return str(t)"
    },
    {
        "number": 871,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    landings = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            h, m = map(int, line.split())\n            landings.append((h, m))\n\n    takeoff_time = (0, 0)\n    for i in range(len(landings)):\n        if i == 0:\n            if landings[i][1] - s >= 0:\n                takeoff_time = (landings[i][0], landings[i][1] - s)\n                break\n        else:\n            if landings[i][1] - s >= landings[i-1][1] + 1:\n                takeoff_time = (landings[i][0], landings[i][1] - s)\n                break\n\n    if takeoff_time == (0, 0):\n        return \"0 0\"\n    else:\n        return f\"{takeoff_time[0]} {takeoff_time[1]}\""
    },
    {
        "number": 872,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i] + a[j]) % 2 == 1:\n                a[i], a[j] = a[j], a[i]\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 873,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, original_state, target_state = stdin.split()\n    n = int(n)\n    original_state = list(original_state)\n    target_state = list(target_state)\n\n    def rotate_disk(disk: int, direction: str) -> None:\n        nonlocal original_state\n        if direction == 'CW':\n            original_state[disk] = str((int(original_state[disk]) + 1) % 10)\n        else:\n            original_state[disk] = str((int(original_state[disk]) - 1) % 10)\n\n    def is_target_state() -> bool:\n        return ''.join(original_state) == ''.join(target_state)\n\n    moves = 0\n    for disk in range(n):\n        if original_state[disk] != target_state[disk]:\n            if original_state[disk] < target_state[disk]:\n                direction = 'CW'\n            else:\n                direction = 'CCW'\n            while original_state[disk] != target_state[disk]:\n                rotate_disk(disk, direction)\n                moves += 1\n                if is_target_state():\n                    return moves\n    return moves\n"
    },
    {
        "number": 874,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    elif n == 2:\n        return \"2 1\"\n    else:\n        return \" \".join(str(i) for i in range(2, n+1)) + \" \" + \" \".join(str(i) for i in range(1, n))"
    },
    {
        "number": 875,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_color(matrix, i, j):\n        if i == j:\n            return '*'\n        return matrix[i - 1][j - 1]\n\n    def is_valid_move(matrix, i, j, k):\n        return get_color(matrix, i, k) == get_color(matrix, k, j)\n\n    def find_valid_moves(matrix, stones):\n        valid_moves = []\n        for i in range(1, n + 1):\n            if i not in stones:\n                for j in stones:\n                    if is_valid_move(matrix, i, j, stones[(stones.index(j) + 1) % len(stones)]):\n                        valid_moves.append((i, j))\n        return valid_moves\n\n    def move_stones(matrix, stones, moves):\n        for move in moves:\n            i, j = move\n            stones.remove(i)\n            stones.append(j)\n        return stones\n\n    def find_min_moves(matrix, stones):\n        valid_moves = find_valid_moves(matrix, stones)\n        if not valid_moves:\n            return -1\n        min_moves = len(valid_moves)\n        min_moves_list = []\n        for moves in itertools.permutations(valid_moves):\n            stones_after_moves = move_stones(matrix, stones.copy(), moves)\n            if stones_after_moves == [1, 2, 3]:\n                min_moves_list.append(moves)\n                if len(moves) < min_moves:\n                    min_moves = len(moves)\n        return min_moves, min_moves_list\n\n    n, stones = list(map(int, stdin.split()))\n    matrix = [list(line.strip()) for line in stdin.splitlines()[2:]]\n\n    min_moves, min_moves_list = find_min_moves(matrix, [stones[0], stones[1], stones[2]])\n\n    if min_moves == -1:\n        return \"-1\"\n    else:\n        return str(min_moves) + \"\\n\" + \"\\n\".join([\" \".join(map(str, move)) for move in min_moves_list])"
    },
    {
        "number": 876,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, input().split()))\n\n    def p(x):\n        y = [0] * (len(x) + 1)\n        for i in range(len(x)):\n            y[i + 1] = y[i] + x[i]\n        return y\n\n    i = 0\n    while True:\n        A = p(A)\n        i += 1\n        if k in A:\n            return str(i)"
    },
    {
        "number": 877,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    similar_problems = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        similar_problems.append((u, v))\n\n    def is_similar(problem1, problem2):\n        for similar_problem in similar_problems:\n            if (problem1, problem2) == similar_problem or (problem2, problem1) == similar_problem:\n                return True\n        return False\n\n    def count_ways(problems, used_problems, used_division1):\n        if len(problems) == 0:\n            return 1\n\n        count = 0\n        for i in range(len(problems)):\n            if not used_problems[i]:\n                if not used_division1 or all(is_similar(problems[i], p) for p in used_problems if p != -1):\n                    used_problems[i] = True\n                    count += count_ways(problems[:i] + problems[i+1:], used_problems, used_division1)\n                    used_problems[i] = False\n\n        return count\n\n    problems = list(range(1, n+1))\n    used_problems = [False] * n\n    count = count_ways(problems, used_problems, False)\n\n    return str(count)"
    },
    {
        "number": 878,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    types = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"Infinite\"\n\n    if types[0] == 1:\n        return \"Infinite\"\n\n    if types[0] == 2:\n        return \"Infinite\"\n\n    if types[0] == 3:\n        return \"Finite\"\n\n    if types[1] == 1:\n        return \"Infinite\"\n\n    if types[1] == 2:\n        return \"Infinite\"\n\n    if types[1] == 3:\n        return \"Infinite\"\n\n    if types[2] == 1:\n        return \"Infinite\"\n\n    if types[2] == 2:\n        return \"Infinite\"\n\n    if types[2] == 3:\n        return \"Infinite\"\n\n    return \"Infinite\"\n\n\ndef"
    },
    {
        "number": 879,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    path = [1]\n    for i in range(2, n+1):\n        path.append(i)\n        path.insert(p[i-1], i)\n    return ' '.join(map(str, path))"
    },
    {
        "number": 880,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = []\n    for i in range(1, n + 1):\n        for perm in itertools.permutations(range(1, n + 1), i):\n            p.extend(perm)\n\n    mod = 998244353\n    count = 0\n    for i in range(len(p)):\n        for j in range(i + n, len(p) + 1):\n            if sum(p[i:j]) == n * (n + 1) // 2:\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 881,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    while True:\n        i = 0\n        while i < n - 1:\n            if a[i] == a[i + 1]:\n                a[i] += 1\n                del a[i + 1]\n                n -= 1\n            else:\n                i += 1\n        if n == 1:\n            break\n\n    return str(n)"
    },
    {
        "number": 882,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    max_occurrences = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            for letter in 'abcdefghijklmnopqrstuvwxyz':\n                s_new = s[:i] + letter + s[i+1:]\n                occurrences = s_new.count(t)\n                if occurrences > max_occurrences:\n                    max_occurrences = occurrences\n    return max_occurrences"
    },
    {
        "number": 883,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, fingers = map(int, stdin.split())\n    count = 0\n    for i in range(1, 6):\n        if i != fingers:\n            count += 1\n    return str(count)"
    },
    {
        "number": 884,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    MOD = 998_244_353\n    result = 1\n\n    # Calculate the number of ways to build bridges between red islands\n    result *= (a * (a - 1)) // 2\n\n    # Calculate the number of ways to build bridges between blue islands\n    result *= (b * (b - 1)) // 2\n\n    # Calculate the number of ways to build bridges between purple islands\n    result *= (c * (c - 1)) // 2\n\n    # Calculate the number of ways to build bridges between red and blue islands\n    result *= a * b\n\n    # Calculate the number of ways to build bridges between red and purple islands\n    result *= a * c\n\n    # Calculate the number of ways to build bridges between blue and purple islands\n    result *= b * c\n\n    # Calculate the number of ways to build bridges between all islands\n    result *= a + b + c\n\n    return str(result % MOD)"
    },
    {
        "number": 885,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    tree = Graph(n)\n    for u, v in edges:\n        tree.add_edge(u, v)\n\n    def dfs(node, parent):\n        nonlocal result\n        for neighbor in tree.get_neighbors(node):\n            if neighbor != parent:\n                dfs(neighbor, node)\n                result += tree.independent_set_count(tree.get_subgraph(tree.get_edges(node, neighbor)))\n\n    result = 0\n    dfs(1, -1)\n    return str(result % 998244353)\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, u, v):\n        self.edges[u - 1].append(v - 1)\n        self.edges[v - 1].append(u - 1)\n\n    def get_neighbors(self, node):\n        return self.edges[node]\n\n    def get_edges(self, u, v):\n        edges = []\n        for w in self.edges[u]:\n            if w != v:\n                edges.append((u, w))\n        for w in self.edges[v]:\n            if w != u:\n                edges.append((v, w))\n        return edges\n\n    def get_subgraph(self, edges):\n        subgraph = Graph(self.n)\n        for u, v in edges:\n            subgraph.add_edge(u, v)\n        return subgraph\n\n    def independent_set_count(self, subgraph):\n        count = 0\n        for i in range(subgraph.n):\n            if not any(subgraph.edges[i]):\n                count += 1\n        return count"
    },
    {
        "number": 886,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return -1\n\n    digits = [int(d) for d in str(n)]\n    max_exchange_rate = -1\n\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[i] != digits[j]:\n                digits[i], digits[j] = digits[j], digits[i]\n                exchange_rate = int(\"\".join(map(str, digits)))\n                if exchange_rate % 2 == 0 and exchange_rate > max_exchange_rate:\n                    max_exchange_rate = exchange_rate\n                digits[i], digits[j] = digits[j], digits[i]\n\n    return str(max_exchange_rate)"
    },
    {
        "number": 887,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, buttons = stdin.split('\\n')\n    n = int(n)\n    buttons = list(map(int, buttons.split()))\n\n    if n == 1:\n        return \"YES\" if buttons[0] == 1 else \"NO\"\n\n    if buttons.count(1) == 1:\n        return \"YES\"\n\n    for i in range(n - 1):\n        if buttons[i] == 1 and buttons[i + 1] == 0:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 888,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    s = list(map(int, stdin.splitlines()[2].split()))\n    \n    p_to_s = [s.index(i) + 1 for i in p]\n    swap_count = 0\n    swap_operations = []\n    \n    for i in range(n):\n        if p[i] != s[i]:\n            j = p.index(s[i])\n            p[i], p[j] = p[j], p[i]\n            swap_count += abs(i - j)\n            swap_operations.append((i + 1, j + 1))\n    \n    return str(swap_count) + \"\\n\" + str(len(swap_operations)) + \"\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), swap_operations))"
    },
    {
        "number": 889,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    square = [list(line) for line in stdin.splitlines()]\n    for i in range(4):\n        for j in range(4):\n            if square[i][j] == \"#\":\n                if i > 0 and square[i - 1][j] == \"#\":\n                    if j > 0 and square[i][j - 1] == \"#\":\n                        return \"YES\"\n                if i < 3 and square[i + 1][j] == \"#\":\n                    if j < 3 and square[i][j + 1] == \"#\":\n                        return \"YES\"\n    return \"NO\""
    },
    {
        "number": 890,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n    \n    def is_valid(problems: List[int]) -> bool:\n        total_difficulty = sum(problems)\n        return l <= total_difficulty <= r and max(problems) - min(problems) >= x\n    \n    valid_problems = [i for i in range(n) if l <= c[i] <= r]\n    valid_problemsets = [problems for i in range(len(valid_problems)) for problems in itertools.combinations(valid_problems, i+1) if is_valid(c[list(problems)])]\n    \n    return str(len(valid_problemsets))"
    },
    {
        "number": 891,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    chips = list(stdin.split()[1])\n\n    for _ in range(k):\n        new_chips = []\n        for i in range(n):\n            neighbours = [chips[i - 1], chips[i + 1]]\n            if i == 0:\n                neighbours.append(chips[n - 1])\n            elif i == n - 1:\n                neighbours.append(chips[0])\n            white_neighbours = sum(1 for x in neighbours if x == 'W')\n            black_neighbours = sum(1 for x in neighbours if x == 'B')\n            if white_neighbours > black_neighbours:\n                new_chips.append('W')\n            else:\n                new_chips.append('B')\n        chips = new_chips\n\n    return ''.join(chips)"
    },
    {
        "number": 892,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    lcm = 1\n    k_max = 0\n    positions = []\n\n    for i in range(n):\n        for j in range(i, n):\n            lcm_subseq = lcm_of_subseq(a[i:j+1])\n            if lcm_subseq <= m and (j - i + 1) > k_max:\n                lcm = lcm_subseq\n                k_max = j - i + 1\n                positions = list(range(i, j+1))\n\n    return f\"{lcm} {k_max}\\n{' '.join(map(str, positions))}\"\n\ndef"
    },
    {
        "number": 893,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    edges = []\n    for i in range(2, n + 1):\n        u, v = map(int, stdin.split()[i].split())\n        edges.append((u, v))\n\n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, node)\n\n    def is_valid(visited):\n        if not visited:\n            return False\n        min_a = min(a[i] for i in visited)\n        max_a = max(a[i] for i in visited)\n        return max_a - min_a <= d\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    count = 0\n    for i in range(n):\n        visited = set()\n        dfs(i, visited, -1)\n        if is_valid(visited):\n            count += 1\n\n    return str(count % 1000000007)"
    },
    {
        "number": 894,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_1 = 0\n    y_1 = y\n    x_2 = x\n    y_2 = 0\n    return f\"{x_1} {y_1} {x_2} {y_2}\""
    },
    {
        "number": 895,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *shout_times, T = map(int, stdin.split())\n    shout_times.sort()\n    max_visited = 0\n    visited = 0\n    for i in range(n):\n        if shout_times[i] <= T:\n            visited += 1\n            max_visited = max(max_visited, visited)\n        else:\n            visited = 0\n    return str(max_visited)"
    },
    {
        "number": 896,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = a[i] ^ b[j]\n\n    for row in matrix:\n        if len(set(row)) != m:\n            return \"NO\"\n\n    for j in range(m):\n        if len(set([matrix[i][j] for i in range(n)])) != n:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join([\" \".join(map(str, row)) for row in matrix])\n"
    },
    {
        "number": 897,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    S_1 = list(map(int, stdin.split()[2:2+n]))\n    S_2 = list(map(int, stdin.split()[2+n:2+2*n]))\n\n    def is_lexicographically_greater(S_1, S_2):\n        for i in range(n):\n            if S_1[i] == 0 or S_2[i] == 0:\n                continue\n            if S_1[i] > S_2[i]:\n                return True\n            elif S_1[i] < S_2[i]:\n                return False\n        return False\n\n    count = 0\n    for i in range(m):\n        for j in range(m):\n            if i == j:\n                continue\n            S_1_new = [i if x == 0 else x for x in S_1]\n            S_2_new = [j if x == 0 else x for x in S_2]\n            if is_lexicographically_greater(S_1_new, S_2_new):\n                count += 1\n\n    P = count\n    Q = (m - 1) * (m - 2)\n    R = P * pow(Q, -1, 10**9 + 7)\n\n    return str(R)"
    },
    {
        "number": 898,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    a = [M // N] * N\n    a[0] += M % N\n    gcd = a[0]\n    for i in range(1, N):\n        gcd = math.gcd(gcd, a[i])\n    return str(gcd)"
    },
    {
        "number": 899,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    edges = []\n    for i in range(M):\n        a, b, c = map(int, stdin.split()[3*i+2:3*i+5])\n        edges.append((a, b, c))\n\n    def find_shortest_path(start: int, end: int, visited: set, dist: int, path: list) -> int:\n        if start == end:\n            return dist\n        min_dist = float('inf')\n        for i in range(len(edges)):\n            a, b, c = edges[i]\n            if a in visited and b not in visited:\n                new_visited = visited.copy()\n                new_visited.add(b)\n                new_path = path + [(a, b, c)]\n                min_dist = min(min_dist, find_shortest_path(b, end, new_visited, dist + c, new_path))\n            elif b in visited and a not in visited:\n                new_visited = visited.copy()\n                new_visited.add(a)\n                new_path = path + [(a, b, c)]\n                min_dist = min(min_dist, find_shortest_path(a, end, new_visited, dist + c, new_path))\n        return min_dist\n\n    count = 0\n    for i in range(M):\n        a, b, c = edges[i]\n        if find_shortest_path(a, b, {a}, 0, []) == float('inf'):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 900,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                for l in range(10):\n                    for m in range(10):\n                        for n in range(10):\n                            for o in range(10):\n                                for p in range(10):\n                                    for q in range(10):\n                                        for r in range(10):\n                                            for s in range(10):\n                                                for t in range(10):\n                                                    for u in range(10):\n                                                        for v in range(10):\n                                                            for w in range(10):\n                                                num = int(stdin.replace(\"?\", str(i)))\n                                                num = int(num.replace(\"?\", str(j)))\n                                                num = int(num.replace(\"?\", str(k)))\n                                                num = int(num.replace(\"?\", str(l)))\n                                                num = int(num.replace(\"?\", str(m)))\n                                                num = int(num.replace(\"?\", str(n)))\n                                                num = int(num.replace(\"?\", str(o)))\n                                                num = int(num.replace(\"?\", str(p)))\n                                                num = int(num.replace(\"?\", str(q)))\n                                                num = int(num.replace(\"?\", str(r)))\n                                                num = int(num.replace(\"?\", str(s)))\n                                                num = int(num.replace(\"?\", str(t)))\n                                                num = int(num.replace(\"?\", str(u)))\n                                                num = int(num.replace(\"?\", str(v)))\n                                                num = int(num.replace(\"?\", str(w)))\n                                                if num % 13 == 5:\n                                                    count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 901,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = []\n    for _ in range(m):\n        line = stdin.split('\\n')[1]\n        k, *members = map(int, line.split())\n        groups.append(members)\n\n    def is_traitor(universe: int, group: list) -> bool:\n        return any(abs(member) == universe for member in group)\n\n    def is_world_end(group: list) -> bool:\n        return all(is_traitor(abs(member), group) for member in group)\n\n    for universe in range(1, n + 1):\n        if any(is_traitor(universe, group) for group in groups):\n            if any(is_world_end(group) for group in groups):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 902,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    powers = list(map(int, input().split()))\n\n    line = [i for i in range(1, n + 1)]\n    winner = 0\n\n    while len(line) > 1:\n        loser = line.pop(0)\n        line.append(loser)\n        line.remove(loser)\n        winner = line[0]\n\n        if powers[winner - 1] >= powers[loser - 1]:\n            k -= 1\n        else:\n            k = k - 1\n\n        if k == 0:\n            break\n\n    return str(powers[winner - 1])\n"
    },
    {
        "number": 903,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    a.sort()\n    median = a[n // 2]\n\n    for i in range(k):\n        if a[i] < median:\n            a[i] += 1\n            if a[i] > median:\n                median += 1\n\n    return str(median)"
    },
    {
        "number": 904,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    max_volume = 0\n    for word in words:\n        volume = sum(1 for char in word if char.isupper())\n        max_volume = max(max_volume, volume)\n    return str(max_volume)"
    },
    {
        "number": 905,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    sugar_types = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        sugar_types.append((x, y))\n\n    max_sweets = -1\n    for sugar in sugar_types:\n        x, y = sugar\n        if x <= s:\n            sweets = (s - x) * 100 + y\n            if sweets > max_sweets:\n                max_sweets = sweets\n\n    return str(max_sweets)\n"
    },
    {
        "number": 906,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        return str((n * m) % 1000000007)\n    else:\n        return str(((n * m) % 1000000007) * 2)"
    },
    {
        "number": 907,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for x in range(1, n):\n        for y in range(x + 1, n + 1):\n            found = False\n            for a, b in pairs:\n                if a == x or a == y or b == x or b == y:\n                    found = True\n                    break\n            if found:\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 908,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    strings.sort(key=lambda x: (len(x), x))\n\n    total_energy = sum(c[i] for i in range(n) if strings[i] != strings[i][::-1])\n\n    if total_energy == 0:\n        return \"0\"\n    else:\n        return \"-1\""
    },
    {
        "number": 909,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a + b * c, a * b + c, a * b * c, (a + b) * c)\n    return str(max_value)"
    },
    {
        "number": 910,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n > a * b:\n        return \"-1\"\n\n    democrats = [(i, (i + 1) % n) for i in range(1, n, 2)]\n    republicans = [(i, (i + 1) % n) for i in range(2, n, 2)]\n\n    def is_valid(seats: List[Tuple[int, int]]) -> bool:\n        for seat in seats:\n            for party in [democrats, republicans]:\n                if seat in party:\n                    for neighbor in [(seat[0] - 1, seat[1]), (seat[0] + 1, seat[1]), (seat[0], seat[1] - 1), (seat[0], seat[1] + 1)]:\n                        if neighbor in party and neighbor != party[0]:\n                            return False\n        return True\n\n    def find_seats(seats: List[Tuple[int, int]]) -> bool:\n        if len(seats) == n:\n            return is_valid(seats)\n\n        for i in range(a):\n            for j in range(b):\n                if (i, j) not in seats:\n                    seats.append((i, j))\n                    if find_seats(seats):\n                        return True\n                    seats.pop()\n        return False\n\n    for i in range(a):\n        for j in range(b):\n            if find_seats([(i, j)]):\n                return \"\\n\".join([\" \".join(map(str, [0] * b if (i, j) not in seats else [seats.index((i, j) % n) + 1] * b) for j in range(b)) for i in range(a)])\n    return \"-1\""
    },
    {
        "number": 911,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:2*n+2:2]))\n    t = list(map(int, stdin.split()[3:2*n+3:2]))\n\n    def score(i, x):\n        return max(0, p[i] - c * x)\n\n    def solve(order):\n        total = 0\n        for i in order:\n            total += score(i, sum(t[:i]))\n        return total\n\n    limak_score = solve(range(n))\n    radewoosh_score = solve(range(n-1, -1, -1))\n\n    if limak_score > radewoosh_score:\n        return \"Limak\"\n    elif limak_score < radewoosh_score:\n        return \"Radewoosh\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 912,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_staircases(n: int, s: int, k: int, closed_restaurants: set) -> int:\n        staircases = 0\n        current_floor = s\n        while current_floor > 1:\n            if current_floor - 1 not in closed_restaurants:\n                return staircases\n            staircases += 1\n            current_floor -= 1\n        return staircases\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n, s, k = map(int, stdin.readline().split())\n        closed_restaurants = set(map(int, stdin.readline().split()))\n        result.append(min_staircases(n, s, k, closed_restaurants))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 913,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    r = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    if sum(r) < sum(b):\n        return \"-1\"\n\n    min_max_p = float(\"inf\")\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                p = [0] * n\n                p[i - 1] = 1\n                p[j - 1] = 1\n                if sum(p) == sum(r) - 1:\n                    min_max_p = min(min_max_p, max(p))\n\n    return str(min_max_p) if min_max_p != float(\"inf\") else \"-1\""
    },
    {
        "number": 914,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split()\n    n = int(n)\n    if len(s) % n != 0:\n        return \"-1\"\n    else:\n        sheet = s[:n]\n        return str(len(s) // n) + \"\\n\" + sheet"
    },
    {
        "number": 915,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k == 1:\n        return \"codeforces\"\n    elif k == 2:\n        return \"codeforcess\"\n    elif k == 3:\n        return \"codeforcesss\"\n    elif k == 4:\n        return \"codeforcessss\"\n    elif k == 5:\n        return \"codeforcesssss\"\n    elif k == 6:\n        return \"codeforcessssss\"\n    elif k == 7:\n        return \"codeforcesssssss\"\n    elif k == 8:\n        return \"codeforcessssssss\"\n    elif k == 9:\n        return \"codeforcesssssssss\"\n    elif k == 10:\n        return \"codeforcessssssssss\"\n    elif k == 11:\n        return \"codeforcesssssssssss\"\n    elif k == 12:\n        return \"codeforcessssssssssss\"\n    elif k == 13:\n        return \"codeforcesssssssssssss\"\n    elif k == 14:\n        return \"codeforcessssssssssssss\"\n    elif k == 15:\n        return \"codeforcesssssssssssssss\"\n    elif k == 16:\n        return \"codeforcessssssssssssssss\"\n    elif k == 17:\n        return \"codeforcesssssssssssssssss\"\n    elif k == 18:\n        return \"codeforcessssssssssssssssss\"\n    elif k == 19:\n        return \"codeforcesssssssssssssssssss\"\n    elif k == 20:\n        return \"codeforcessssssssssssssssssss\"\n    elif k == 21:\n        return \"codeforcesssssssssssssssssssss\"\n    elif k == 22:\n        return \"codeforcessssssssssssssssssssss\"\n    elif k == 23:\n        return \"codeforcesssssssssssssssssssssss\"\n    elif k == 24:\n        return \"codeforcessssssssssssssssssssssss\"\n    elif k == 25:\n        return \"codeforcesssssssssssssssssssssssss\"\n    elif k == 26:\n        return \"codeforcessssssssssssssssssssssssss\"\n    elif k == 27:\n        return \"codeforcesssssssssssssssssssssssssss\"\n    elif k == 28:\n        return \"codeforcessssssssssssssssssssssssssss\"\n    elif k == 29:\n        return \"codeforcesssssssssssssssssssssssssssss\"\n    elif k == 30:\n        return \"codeforcessssssssssssssssssssssssssssss\"\n    elif k == 31:\n        return \"codeforcesssssssssssssssssssssssssssssss\"\n    elif k == 32:\n        return \"codeforcessssssssssssssssssssssssssssssss\"\n    elif k == 33:\n        return \"codeforcesssssssssssssssssssssssssssssssss\"\n    elif k == 34:\n        return \"codeforcessssssssssssssssssssssssssssssssss\"\n    elif k == 35:\n        return \"codeforcesssssssssssssssssssssssssssssssssss\"\n    elif k == 36:\n        return \"codeforcessssssssssssssssssssssssssssssssssss\"\n    elif k == 37:\n        return \"codeforcesssssssssssssssssssssssssssssssssssss\"\n    elif k == 38:\n        return \"codeforcessssssssssssssssssssssssssssssssssssss\"\n    elif k == 39:\n        return \"codeforcesssssssssssssssssssssssssssssssssssss\"\n"
    },
    {
        "number": 916,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, apples, parents = stdin.split('\\n')\n    n = int(n)\n    apples = list(map(int, apples.split()))\n    parents = list(map(int, parents.split()))\n\n    def find_root(node: int) -> int:\n        if parents[node - 1] == node:\n            return node\n        return find_root(parents[node - 1])\n\n    root = find_root(1)\n\n    def find_leaves(node: int) -> List[int]:\n        leaves = []\n        for i in range(1, n + 1):\n            if parents[i - 1] == node and i not in leaves:\n                leaves.extend(find_leaves(i))\n        return leaves\n\n    leaves = find_leaves(root)\n\n    def count_ways(node: int) -> int:\n        if node in leaves:\n            return 1\n        count = 0\n        for i in range(1, n + 1):\n            if parents[i - 1] == node and i != node:\n                count += count_ways(i)\n        return count\n\n    count = count_ways(root)\n\n    def swap_and_count(u: int, v: int) -> int:\n        apples[u - 1], apples[v - 1] = apples[v - 1], apples[u - 1]\n        new_count = count_ways(root)\n        apples[u - 1], apples[v - 1] = apples[v - 1], apples[u - 1]\n        return new_count\n\n    ways_to_win = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if swap_and_count(i, j) > count:\n                ways_to_win += 1\n\n    return str(ways_to_win)"
    },
    {
        "number": 917,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m = map(int, stdin.split()[:3])\n    restrictions = []\n    for i in range(m):\n        l, r, x = map(int, stdin.split()[3*i+3:3*i+6])\n        restrictions.append((l, r, x))\n\n    def max_profit(heights):\n        profit = 0\n        for i in range(n):\n            profit += heights[i] ** 2\n        return profit\n\n    def is_valid(heights):\n        for l, r, x in restrictions:\n            if max(heights[l-1:r]) > x:\n                return False\n        return True\n\n    heights = [0] * n\n    max_profit_so_far = 0\n\n    for i in range(h+1):\n        for j in range(h+1):\n            for k in range(h+1):\n                heights[0] = i\n                heights[1] = j\n                heights[2] = k\n                if is_valid(heights):\n                    profit = max_profit(heights)\n                    max_profit_so_far = max(max_profit_so_far, profit)\n\n    return str(max_profit_so_far)"
    },
    {
        "number": 918,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    participants = {}\n    for line in stdin.split('\\n')[1:]:\n        surname, region, score = line.split()\n        if region not in participants:\n            participants[region] = []\n        participants[region].append((surname, int(score)))\n\n    result = []\n    for region in range(1, m + 1):\n        if len(participants[str(region)]) < 2:\n            result.append(\"?\")\n            continue\n\n        participants[str(region)].sort(key=lambda x: x[1], reverse=True)\n        team1 = participants[str(region)][0][0]\n        team2 = participants[str(region)][1][0]\n        if team1 == team2:\n            result.append(\"?\")\n        else:\n            result.append(f\"{team1} {team2}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 919,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    stages = list(stdin.split()[2])\n    stages.sort()\n\n    def is_valid(rocket: str) -> bool:\n        for i in range(len(rocket) - 1):\n            if abs(ord(rocket[i]) - ord(rocket[i + 1])) != 1:\n                return False\n        return True\n\n    def weight(rocket: str) -> int:\n        return sum(ord(stage) - ord('a') + 1 for stage in rocket)\n\n    def find_min_weight(rocket: str) -> int:\n        min_weight = float('inf')\n        for i in range(len(stages) - k + 1):\n            current_rocket = ''.join(stages[i:i + k])\n            if is_valid(current_rocket):\n                min_weight = min(min_weight, weight(current_rocket))\n        return min_weight\n\n    min_weight = find_min_weight(stages)\n    return str(min_weight) if min_weight != float('inf') else '-1'"
    },
    {
        "number": 920,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    guardposts = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    for i, guardpost in enumerate(guardposts, start=1):\n        chocolate_price, juice_price = min(guardpost[0], guardpost[2]), min(guardpost[1], guardpost[3])\n        if chocolate_price + juice_price <= n:\n            return f\"{i} {chocolate_price} {juice_price}\"\n\n    return \"-1\""
    },
    {
        "number": 921,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split()[0:2])\n    cups = list(map(int, stdin.split()[2:]))\n\n    # Check if it's possible to pour all the tea and satisfy all conditions\n    if sum(cups) < w:\n        return \"-1\"\n\n    # Calculate the minimum amount of tea that should be poured in each cup\n    min_tea = w // n\n    extra_tea = w % n\n\n    # Calculate the amount of tea that should be poured in each cup\n    result = []\n    for cup in cups:\n        if cup <= min_tea:\n            result.append(min_tea)\n        else:\n            result.append(min_tea + 1)\n\n    # Check if all conditions are satisfied\n    for i in range(n):\n        for j in range(n):\n            if result[i] < result[j] and cups[i] > cups[j]:\n                return \"-1\"\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 922,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    d = list(map(int, input().split()))\n    b = [0] * n\n    \n    for i in range(n):\n        for j in range(1, d[i] + 1):\n            if A - j >= d[i] - j:\n                b[i] += 1\n    \n    return \" \".join(map(str, b))"
    },
    {
        "number": 923,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, active_teeth = stdin.split()\n    n = int(n)\n    active_teeth = [int(x) for x in active_teeth.split()]\n\n    for i in range(n):\n        if active_teeth[i] != i:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 924,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alice_l, alice_r, alice_t = map(int, stdin.split()[:3])\n    bob_l, bob_r, bob_t = map(int, stdin.split()[3:])\n\n    alice_luckies = set(range(alice_l, alice_r + 1))\n    bob_luckies = set(range(bob_l, bob_r + 1))\n\n    max_length = 0\n    for i in range(min(alice_l, bob_l), max(alice_r, bob_r) + 1):\n        if i in alice_luckies and i in bob_luckies:\n            max_length += 1\n        else:\n            max_length = 0\n\n        if max_length > 0:\n            max_length += 1\n\n    return str(max_length)"
    },
    {
        "number": 925,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(100):\n        if str(i) == str(n) or str(i) == str(n)[::-1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 926,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stones = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    max_volume = 0\n    chosen_stones = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            a1, b1, c1 = stones[i]\n            a2, b2, c2 = stones[j]\n\n            if a1 * b2 == a2 * b1:\n                volume = a1 * b1 * min(c1, c2)\n                if volume > max_volume:\n                    max_volume = volume\n                    chosen_stones = [i + 1, j + 1]\n            elif a1 * b2 == b1 * c2:\n                volume = a1 * b1 * min(c1, c2)\n                if volume > max_volume:\n                    max_volume = volume\n                    chosen_stones = [i + 1, j + 1]\n            elif a2 * b1 == b2 * c1:\n                volume = a2 * b2 * min(c1, c2)\n                if volume > max_volume:\n                    max_volume = volume\n                    chosen_stones = [i + 1, j + 1]\n\n    return f\"{len(chosen_stones)}\\n{' '.join(map(str, chosen_stones))}\""
    },
    {
        "number": 927,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    digits = list(map(int, stdin.split()[2:]))\n\n    # Calculate the number of matchsticks needed for each digit\n    matchsticks = [2, 5, 5, 4, 5, 6, 3, 7, 6]\n    digit_count = [0] * 10\n    for i in range(M):\n        digit_count[digits[i]] += 1\n\n    # Sort the digits by the number of matchsticks needed\n    sorted_digits = sorted(digits, key=lambda x: matchsticks[x-1], reverse=True)\n\n    # Calculate the largest integer that can be formed with N matchsticks\n    result = 0\n    for digit in sorted_digits:\n        if N >= matchsticks[digit-1]:\n            result += digit * (10 ** digit_count[digit])\n            N -= matchsticks[digit-1] * digit_count[digit]\n        else:\n            break\n\n    return str(result)"
    },
    {
        "number": 928,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(N):\n        current_sum = A[i]\n        if current_sum >= K:\n            count += 1\n        for j in range(i+1, N):\n            current_sum += A[j]\n            if current_sum >= K:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 929,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0:2])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:H+1]]\n    \n    def count_even_coins(grid: List[List[int]]) -> int:\n        count = 0\n        for row in grid:\n            for cell in row:\n                if cell % 2 == 0:\n                    count += 1\n        return count\n    \n    def move_coin(grid: List[List[int]], y: int, x: int, dy: int, dx: int) -> None:\n        if 0 <= y + dy < H and 0 <= x + dx < W:\n            grid[y][x] -= 1\n            grid[y+dy][x+dx] += 1\n    \n    operations = []\n    max_even_coins = count_even_coins(grid)\n    \n    for y in range(H):\n        for x in range(W):\n            if grid[y][x] > 0:\n                for dy in [-1, 0, 1]:\n                    for dx in [-1, 0, 1]:\n                        if dy != 0 or dx != 0:\n                            new_grid = [row.copy() for row in grid]\n                            move_coin(new_grid, y, x, dy, dx)\n                            new_even_coins = count_even_coins(new_grid)\n                            if new_even_coins > max_even_coins:\n                                max_even_coins = new_even_coins\n                                operations.append((y, x, y+dy, x+dx))\n    \n    result = [str(len(operations))]\n    for operation in operations:\n        result.append(' '.join(map(str, operation)))\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 930,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Calculate the number of possible combinations of numbers of people in the n rooms now\n    result = 1\n    for i in range(n):\n        result = (result * (n - i)) % MOD\n\n    # Calculate the number of moves that can be done\n    moves = k * (n - 1)\n\n    # Calculate the number of possible combinations of numbers of people in the n rooms now after k moves\n    for i in range(moves):\n        result = (result * 2) % MOD\n\n    return str(result)"
    },
    {
        "number": 931,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, z, p = map(int, stdin.split())\n    candies = []\n    for _ in range(p):\n        i, j = map(int, input().split())\n        candies.append((i, j))\n\n    def rotate_clockwise(matrix):\n        return list(zip(*matrix[::-1]))\n\n    def rotate_counterclockwise(matrix):\n        return list(zip(*matrix))[::-1]\n\n    def horizontal_rotate(matrix):\n        return [list(row[::-1]) for row in matrix]\n\n    matrix = [[0] * m for _ in range(n)]\n    for i, j in candies:\n        matrix[i - 1][j - 1] = 1\n\n    for _ in range(x):\n        matrix = rotate_clockwise(matrix)\n    for _ in range(y):\n        matrix = horizontal_rotate(matrix)\n    for _ in range(z):\n        matrix = rotate_counterclockwise(matrix)\n\n    result = []\n    for i, j in candies:\n        new_i, new_j = matrix[i - 1][j - 1], j\n        result.append(f\"{new_i} {new_j}\")\n\n    return \"\\n\".join(result)\n\n\ninput_data = \"\"\"3 3 3 1 1 9\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 932,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[:2])\n    matrix_b = [list(map(int, input().split())) for _ in range(m)]\n\n    matrix_a = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for k in range(m):\n                matrix_a[i][j] |= matrix_b[k][j]\n            for k in range(n):\n                matrix_a[i][j] |= matrix_b[i][k]\n\n    for row in matrix_a:\n        if not all(row):\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, row)) for row in matrix_a)\n"
    },
    {
        "number": 933,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def correct_typos(word: str) -> str:\n        if len(word) <= 2:\n            return word\n\n        if word[0] == word[1] == word[2]:\n            return correct_typos(word[1:])\n\n        if word[-1] == word[-2] == word[-3]:\n            return correct_typos(word[:-1])\n\n        if word[0] == word[1] and word[1] == word[2]:\n            return correct_typos(word[2:])\n\n        if word[-1] == word[-2] and word[-2] == word[-3]:\n            return correct_typos(word[:-2])\n\n        return word\n\n    return correct_typos(stdin)"
    },
    {
        "number": 934,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    table_card, *hand_cards = stdin.split()\n    table_rank, table_suit = table_card[0], table_card[1]\n    can_play = False\n\n    for card in hand_cards:\n        rank, suit = card[0], card[1]\n        if rank == table_rank or suit == table_suit:\n            can_play = True\n            break\n\n    return \"YES\" if can_play else \"NO\""
    },
    {
        "number": 935,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1 or m == 1:\n        return \"Akshat\"\n    elif n == 2 or m == 2:\n        return \"Malvika\"\n    else:\n        return \"Akshat\""
    },
    {
        "number": 936,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    likes = [int(x) for x in stdin.split()[1:]]\n    photo_likes = {}\n    \n    for like in likes:\n        if like in photo_likes:\n            photo_likes[like] += 1\n        else:\n            photo_likes[like] = 1\n    \n    max_likes = 0\n    winner = None\n    \n    for photo, likes in photo_likes.items():\n        if likes > max_likes:\n            max_likes = likes\n            winner = photo\n        elif likes == max_likes and photo < winner:\n            winner = photo\n    \n    return str(winner)"
    },
    {
        "number": 937,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2*n+2:2]))\n    t = list(map(int, stdin.split()[3:2*n+3:2]))\n    \n    max_theorems = 0\n    for i in range(1, n - k + 2):\n        theorems = 0\n        for j in range(i, i + k):\n            if t[j-1] == 1:\n                theorems += a[j-1]\n        max_theorems = max(max_theorems, theorems)\n    \n    return str(max_theorems)"
    },
    {
        "number": 938,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    n = 0\n    p = []\n    m = 0\n    q = []\n\n    for i in range(1, a + 1):\n        if i <= b:\n            n += 1\n            p.append(i)\n        else:\n            m += 1\n            q.append(i)\n\n    return f\"{n}\\n{' '.join(map(str, p))}\\n{m}\\n{' '.join(map(str, q))}\""
    },
    {
        "number": 939,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    dances = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    colors = [0] * n\n    for dance in dances:\n        for dancer in dance:\n            colors[dancer - 1] += 1\n\n    for i in range(n):\n        if colors[i] == 0:\n            colors[i] = 1\n        elif colors[i] == 1:\n            colors[i] = 2\n        else:\n            colors[i] = 3\n\n    return \" \".join(map(str, colors))"
    },
    {
        "number": 940,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    sides = sorted([a, b, c])\n    area = 0.5 * sides[0] * sides[1]\n\n    if area > 0:\n        return \"0\"\n\n    for i in range(1, sides[2] + 1):\n        if i * i + area > 0:\n            return str(i)\n\n    return str(sides[2])\n"
    },
    {
        "number": 941,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))[2:]\n    n = sum(a[i] * b**(k-i-1) for i in range(k))\n    return \"even\" if n % 2 == 0 else \"odd\""
    },
    {
        "number": 942,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"Possible\" + \" \" + \"1\"\n\n    if n == 2:\n        if a[0] == 0 and a[1] == 0:\n            return \"Possible\" + \" \" + \"1\" + \" \" + \"1\"\n        elif a[0] == 1 and a[1] == 1:\n            return \"Possible\" + \" \" + \"2\" + \" \" + \"2\"\n        else:\n            return \"Impossible\"\n\n    if n == 3:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0:\n            return \"Possible\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\"\n        elif a[0] == 1 and a[1] == 1 and a[2] == 1:\n            return \"Possible\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\"\n        elif a[0] == 2 and a[1] == 2 and a[2] == 2:\n            return \"Possible\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\"\n        else:\n            return \"Impossible\"\n\n    if n == 4:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0:\n            return \"Possible\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\"\n        elif a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1:\n            return \"Possible\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\"\n        elif a[0] == 2 and a[1] == 2 and a[2] == 2 and a[3] == 2:\n            return \"Possible\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\"\n        elif a[0] == 3 and a[1] == 3 and a[2] == 3 and a[3] == 3:\n            return \"Possible\" + \" \" + \"4\" + \" \" + \"4\" + \" \" + \"4\" + \" \" + \"4\"\n        else:\n            return \"Impossible\"\n\n    if n == 5:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0:\n            return \"Possible\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\" + \" \" + \"1\"\n        elif a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1:\n            return \"Possible\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\" + \" \" + \"2\"\n        elif a[0] == 2 and a[1] == 2 and a[2] == 2 and a[3] == 2 and a[4] == 2:\n            return \"Possible\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\" + \" \" + \"3\"\n        elif a[0] == 3 and a[1] == 3 and a[2] == 3 and a[3] == 3 and a[4] == 3:\n            return \"Possible\" + \" \" + \"4\" + \" \" + \"4\" + \" \" + \"4\" + \" \" + \"4\" + \" \" + \"4\"\n        elif a[0] == 4 and a[1] == 4 and a[2] == 4 and a[3] == 4"
    },
    {
        "number": 943,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    integers = list(map(int, stdin.split('\\n')[1].split()))\n    even_sum = 0\n\n    for integer in integers:\n        if integer % 2 == 0:\n            even_sum += integer\n\n    return str(even_sum)"
    },
    {
        "number": 944,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    adj_list = [[] for _ in range(n)]\n    for u, v in roads:\n        adj_list[u-1].append(v-1)\n        adj_list[v-1].append(u-1)\n    \n    def dfs(node, visited, days):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                days = dfs(neighbor, visited, days)\n        return days + 1\n    \n    min_days = float('inf')\n    for i in range(n):\n        visited = [False] * n\n        min_days = min(min_days, dfs(i, visited, 0))\n    \n    def find_roads(days):\n        visited = [False] * n\n        result = []\n        for i in range(n):\n            if not visited[i]:\n                visited[i] = True\n                result.append(i)\n                for j in range(n):\n                    if not visited[j] and (i, j) in roads:\n                        visited[j] = True\n                        result.append(j)\n        return result\n    \n    result = []\n    for i in range(min_days):\n        result.append(find_roads(i))\n    \n    output = [str(min_days)]\n    for i in range(min_days):\n        output.append(str(len(result[i])) + ' ' + ' '.join(map(str, result[i])))\n    \n    return '\\n'.join(output)"
    },
    {
        "number": 945,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = list(map(int, stdin.split()[1:]))\n    points.sort()\n\n    for i in range(1, n):\n        if points[i] - points[i - 1] <= 2:\n            return \"yes\"\n\n    return \"no\"\n"
    },
    {
        "number": 946,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    responses = stdin.split()[1:]\n    hard_responses = [int(response) for response in responses if int(response) == 1]\n\n    if len(hard_responses) > 0:\n        return \"HARD\"\n    else:\n        return \"EASY\""
    },
    {
        "number": 947,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def find_pair(n):\n        for i in range(1, n):\n            if n % i == 0:\n                j = n - i\n                if i * j == n:\n                    return i, j\n\n    def min_lcm(a, b):\n        return min(lcm(a, b), lcm(b, a))\n\n    def min_pair(n):\n        a, b = find_pair(n)\n        return a, b\n\n    def min_lcm_pair(n):\n        a, b = find_pair(n)\n        return min_lcm(a, b)\n\n    def find_min_lcm_pair(n):\n        min_lcm_value = float('inf')\n        min_pair_value = None\n        for i in range(1, n):\n            if n % i == 0:\n                j = n - i\n                if i * j == n:\n                    lcm_value = min_lcm(i, j)\n                    if lcm_value < min_lcm_value:\n                        min_lcm_value = lcm_value\n                        min_pair_value = (i, j)\n        return min_pair_value\n\n    def process_test_case(n):\n        min_pair_value = find_min_lcm_pair(n)\n        return f\"{min_pair_value[0]} {min_pair_value[1]}\"\n\n    test_cases = stdin.split('\\n')[1:]\n    result = []\n    for test_case in test_cases:\n        n = int(test_case)\n        result.append(process_test_case(n))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 948,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    image = [list(line.strip()) for line in stdin.splitlines()[1:]]\n    faces = 0\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if image[i][j] == 'f' and image[i][j + 1] == 'a' and image[i + 1][j] == 'c' and image[i + 1][j + 1] == 'e':\n                faces += 1\n            elif image[i][j] == 'c' and image[i][j + 1] == 'e' and image[i + 1][j] == 'f' and image[i + 1][j + 1] == 'a':\n                faces += 1\n\n    return str(faces)"
    },
    {
        "number": 949,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    gcd = 1\n    for i in range(a, b+1):\n        gcd = gcd_euclid(gcd, i)\n    return str(gcd)\n\ndef"
    },
    {
        "number": 950,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    strings = [input() for _ in range(n)]\n    min_ops = 0\n    \n    # Check if there is at least one digit in the string\n    if not any(char.isdigit() for char in strings[0]):\n        min_ops += 1\n    \n    # Check if there is at least one lowercase (small) letter of the Latin alphabet in the string\n    if not any(char.islower() for char in strings[0]):\n        min_ops += 1\n    \n    # Check if there is at least one of three listed symbols in the string\n    if not any(char in ['#', '*', '&'] for char in strings[0]):\n        min_ops += 1\n    \n    # Move pointers to the left or right\n    for i in range(1, m):\n        if strings[0][i] == '#':\n            min_ops += 1\n        elif strings[0][i] == '*':\n            min_ops += 2\n        elif strings[0][i] == '&':\n            min_ops += 3\n    \n    return min_ops"
    },
    {
        "number": 951,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    n_digits = len(str(n))\n    min_diff = n_digits\n\n    for i in range(1, n_digits + 1):\n        for j in range(10**(n_digits - i)):\n            current_sum = sum(int(digit) for digit in str(j * 10**i + n))\n            if current_sum >= k:\n                min_diff = min(min_diff, i)\n                break\n\n    return str(min_diff)"
    },
    {
        "number": 952,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    roads = []\n    for i in range(m):\n        u, v, c = map(int, stdin.split()[3*i+2:3*i+5])\n        roads.append((u, v, c))\n\n    # Sort the roads by the number of traffic controllers required\n    roads.sort(key=lambda x: x[2])\n\n    # Initialize the graph\n    graph = {i: set() for i in range(1, n+1)}\n\n    # Build the graph\n    for u, v, c in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Initialize the visited and reversed sets\n    visited = set()\n    reversed_roads = set()\n\n    # Function to reverse the road\n    def reverse_road(u: int, v: int) -> None:\n        graph[u].remove(v)\n        graph[v].remove(u)\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # DFS function to find the minimum number of traffic controllers\n    def dfs(u: int) -> int:\n        if u in visited:\n            return 0\n        visited.add(u)\n        count = 1\n        for v in graph[u]:\n            if v not in visited:\n                count += dfs(v)\n        return count\n\n    # Find the minimum number of traffic controllers\n    min_controllers = float('inf')\n    for i in range(1, n+1):\n        if i not in visited:\n            count = dfs(i)\n            if count < min_controllers:\n                min_controllers = count\n\n    # Reverse the roads\n    for u, v, c in roads:\n        if (u, v) not in reversed_roads:\n            reverse_road(u, v)\n            reversed_roads.add((u, v))\n\n    # Output the result\n    return f\"{min_controllers} {len(reversed_roads)}\\n{' '.join(str(i) for i in reversed_roads)}\""
    },
    {
        "number": 953,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    A = [list(map(int, stdin.split('\\n')[i+2].split())) for i in range(n)]\n    \n    def is_prettier(a, b):\n        for i in range(n):\n            if a[i] == b[i]:\n                continue\n            for j in range(i+1, n):\n                if a[j] == b[j]:\n                    continue\n                if a[i] == b[j] and a[j] == b[i]:\n                    return True\n        return False\n    \n    prettiest = p.copy()\n    for i in range(n):\n        for j in range(i+1, n):\n            if A[i][j] == 1:\n                p_i, p_j = p[i], p[j]\n                p[i], p[j] = p_j, p_i\n                if is_prettier(p, prettiest):\n                    prettiest = p.copy()\n                p[i], p[j] = p_i, p_j\n    \n    return ' '.join(map(str, prettiest))"
    },
    {
        "number": 954,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    distinct_words = set()\n    for i in range(n):\n        distinct_words.add(s[i:] + s[:i])\n    return str(len(distinct_words))"
    },
    {
        "number": 955,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    juices = []\n    for i in range(n):\n        price, vitamins = stdin.readline().strip().split()\n        juices.append((int(price), vitamins))\n\n    min_price = float('inf')\n    for i in range(2**n):\n        bitmask = bin(i)[2:].zfill(n)\n        juice_indices = [j for j in range(n) if bitmask[j] == '1']\n        vitamins = set()\n        total_price = 0\n        for j in juice_indices:\n            price, vitamins_str = juices[j]\n            total_price += price\n            for vitamin in vitamins_str:\n                vitamins.add(vitamin)\n        if len(vitamins) == 3:\n            min_price = min(min_price, total_price)\n\n    return str(min_price) if min_price != float('inf') else '-1'"
    },
    {
        "number": 957,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    heidi = \"heidi\"\n    for i in range(len(s) - len(heidi) + 1):\n        if s[i:i+len(heidi)] == heidi:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 958,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def distance(s1: str, s2: str) -> int:\n        return sum(abs(ord(s1[i]) - ord(s2[i])) for i in range(len(s1)))\n\n    def is_nice(s: str) -> bool:\n        return all(s[i] != s[i + 1] for i in range(len(s) - 1))\n\n    for i in range(len(s)):\n        for c in range(ord('a'), ord('z') + 1):\n            if distance(s, s[:i] + chr(c) + s[i + 1:]) == k:\n                return s[:i] + chr(c) + s[i + 1:]\n\n    return \"-1\""
    },
    {
        "number": 959,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, mod = map(int, stdin.split()[:3])\n    matrix = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    \n    def is_special(matrix):\n        for row in matrix:\n            if row.count('1') != 2:\n                return False\n        for col in range(n):\n            if matrix[0][col] == '1' and matrix[1][col] == '1':\n                return False\n        return True\n    \n    def count_special(matrix):\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    matrix[i][j] = '0'\n                    if is_special(matrix):\n                        count += 1\n                    matrix[i][j] = '1'\n        return count\n    \n    return str(count_special(matrix) % mod)"
    },
    {
        "number": 960,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n // k\n    while (x * k) % n != 0:\n        x += 1\n    return str(x)"
    },
    {
        "number": 961,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    codes = list(map(int, stdin.split()[1:]))\n\n    def xor_sum(start: int, end: int) -> int:\n        result = 0\n        for i in range(start, end + 1):\n            result ^= codes[i]\n        return result\n\n    def max_comfort(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        max_comfort_segment = 0\n        for i in range(start, end + 1):\n            max_comfort_segment = max(max_comfort_segment, xor_sum(start, i))\n        return max_comfort_segment + max_comfort(i + 1, end)\n\n    return str(max_comfort(0, n - 1))"
    },
    {
        "number": 962,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_subgraph(subgraph: set) -> bool:\n        in_degrees = [0] * (N + 1)\n        out_degrees = [0] * (N + 1)\n\n        for vertex in subgraph:\n            for neighbor in graph[vertex]:\n                if neighbor in subgraph:\n                    out_degrees[vertex] += 1\n                    in_degrees[neighbor] += 1\n\n        return all(in_degree == 1 and out_degree == 1 for in_degree, out_degree in zip(in_degrees, out_degrees))\n\n    def find_valid_subgraph() -> str:\n        for i in range(1, 2 ** N):\n            subgraph = {vertex for bit, vertex in enumerate(range(1, N + 1)) if i & (1 << bit)}\n            if is_valid_subgraph(subgraph):\n                return subgraph\n        return set()\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            A, B = map(int, line.split())\n            graph[A].append(B)\n            graph[B].append(A)\n\n    valid_subgraph = find_valid_subgraph()\n    if not valid_subgraph:\n        return \"-1\"\n    else:\n        return str(len(valid_subgraph)) + \"\\n\" + \"\\n\".join(map(str, sorted(valid_subgraph)))"
    },
    {
        "number": 963,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    segments = []\n    for i in range(K):\n        L, R = map(int, stdin.split()[2:4])\n        segments.append((L, R))\n        stdin = stdin[4:]\n\n    def get_union(segments):\n        union = set()\n        for segment in segments:\n            union |= set(range(segment[0], segment[1] + 1))\n        return union\n\n    S = get_union(segments)\n    mod = 998244353\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    for i in range(2, N + 1):\n        count = 0\n        for d in S:\n            if i - d >= 1:\n                count += dp[i - d]\n                count %= mod\n        dp[i] = count\n\n    return str(dp[N])"
    },
    {
        "number": 964,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n    max_length = max(x1, x2, x3)\n    max_width = max(y1, y2, y3)\n    n = 0\n    while n * (n + 1) < 2 * max_length + 2 * max_width:\n        n += 1\n    if n * n < 2 * max_length + 2 * max_width:\n        return \"-1\"\n    else:\n        result = \"\"\n        for i in range(n):\n            result += \"A\" * x1 + \"B\" * x2 + \"C\" * x3 + \"\\n\"\n        for i in range(n):\n            result += \"B\" * y1 + \"A\" * y2 + \"C\" * y3 + \"\\n\"\n        for i in range(n):\n            result += \"C\" * y1 + \"B\" * y2 + \"A\" * y3 + \"\\n\"\n        return str(n) + \"\\n\" + result"
    },
    {
        "number": 965,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    statuses = stdin.split('\\n')[1]\n    count = 0\n\n    for i in range(n):\n        if statuses[i] != 'F':\n            all_folded = True\n            for j in range(n):\n                if j != i and statuses[j] != 'F':\n                    all_folded = False\n                    break\n            if all_folded:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 966,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin)\n    while True:\n        year += 1\n        if len(set(str(year))) == len(str(year)):\n            return str(year)"
    },
    {
        "number": 967,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    new_messages = 0\n    \n    for i in range(n):\n        if a[i] != i + 1:\n            new_messages += 1\n    \n    return str(new_messages)"
    },
    {
        "number": 968,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    people = []\n    for i in range(n):\n        first_name, last_name = stdin.readline().strip().split()\n        people.append((first_name, last_name))\n\n    permutation = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        if permutation[i] != i + 1:\n            return \"NO\"\n\n    people.sort(key=lambda x: x[0] + x[1])\n    for i in range(n):\n        if permutation[i] != people.index((people[i][0], people[i][1])) + 1:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 969,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    n = len(t)\n    dp = [0] * (n + 1)\n    for i in range(n + 1):\n        dp[i] = [0] * (n + 1)\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    if dp[n][n] == n:\n        ans = []\n        i, j = n, n\n        while i > 0 and j > 0:\n            if dp[i - 1][j] == dp[i][j]:\n                i -= 1\n            else:\n                ans.append((i, j))\n                i -= 1\n                j -= 1\n        ans.reverse()\n        return str(len(ans)) + \"\\n\" + \"\\n\".join(str(x) + \" \" + str(y) for x, y in ans)\n    else:\n        return \"-1\""
    },
    {
        "number": 970,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, positions = stdin.split()\n    n = int(n)\n    positions = list(map(int, positions.split()))\n\n    if n % 2 != 0:\n        return \"Invalid input\"\n\n    pieces = {}\n    for position in positions:\n        if position in pieces:\n            return \"Invalid input\"\n        pieces[position] = True\n\n    black_pieces = []\n    white_pieces = []\n\n    for i in range(1, n + 1):\n        if i in pieces:\n            if i % 2 == 0:\n                black_pieces.append(i)\n            else:\n                white_pieces.append(i)\n\n    if len(black_pieces) != len(white_pieces):\n        return \"Invalid input\"\n\n    black_pieces.sort()\n    white_pieces.sort()\n\n    moves = 0\n    for i in range(len(black_pieces)):\n        if black_pieces[i] - white_pieces[i] > 1:\n            moves += 2\n        elif white_pieces[i] - black_pieces[i] > 1:\n            moves += 2\n        else:\n            moves += 1\n\n    return moves"
    },
    {
        "number": 971,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, d = map(int, stdin.split()[:3])\n    oranges = list(map(int, stdin.split()[3:]))\n    waste_count = 0\n    juice_count = 0\n\n    for orange in oranges:\n        if orange <= b:\n            juice_count += orange\n        else:\n            waste_count += 1\n\n        if juice_count > d:\n            waste_count += 1\n            juice_count = 0\n\n    return str(waste_count)"
    },
    {
        "number": 972,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def dfs(x: int, y: int, color: str) -> bool:\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        if grid[x][y] != color:\n            return False\n        grid[x][y] = '0'\n        return all(dfs(x + dx, y + dy, color) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)] if (dx, dy) != (0, 0))\n\n    black_cells = [(x, y) for x in range(n) for y in range(m) if grid[x][y] == 'B']\n    for x, y in black_cells:\n        if dfs(x, y, 'B'):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 973,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    pasture = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_safe(x, y):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return False\n        if pasture[x][y] == 'W':\n            return False\n        return True\n\n    def dfs(x, y):\n        if not is_safe(x, y):\n            return False\n        pasture[x][y] = 'D'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(x + dx, y + dy)\n        return True\n\n    for x in range(R):\n        for y in range(C):\n            if pasture[x][y] == 'S' and dfs(x, y):\n                break\n        else:\n            continue\n        break\n    else:\n        return \"No\"\n\n    return \"Yes\\n\" + '\\n'.join([''.join(row) for row in pasture])\n"
    },
    {
        "number": 974,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    commands = stdin.split('\\n')[1:]\n    add_count = 0\n    remove_count = 0\n    for command in commands:\n        if command.startswith('add'):\n            add_count += 1\n        else:\n            remove_count += 1\n    \n    if add_count != n or remove_count != n:\n        return \"Invalid input\"\n    \n    reorder_count = 0\n    for i in range(n):\n        if commands[i].startswith('add'):\n            box_num = int(commands[i].split()[1])\n            if box_num != i+1:\n                reorder_count += 1\n    \n    return str(reorder_count)"
    },
    {
        "number": 975,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sherlock_card = stdin.split('\\n')[1]\n    moriarty_card = stdin.split('\\n')[2]\n\n    sherlock_flicks = 0\n    moriarty_flicks = 0\n\n    for i in range(n):\n        if sherlock_card[i] != moriarty_card[i]:\n            moriarty_flicks += 1\n        else:\n            sherlock_flicks += 1\n\n    return str(moriarty_flicks) + '\\n' + str(sherlock_flicks)"
    },
    {
        "number": 976,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    moments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        moments.append((l, r))\n\n    moments.sort(key=lambda m: m[0])\n    current_minute = 1\n    total_minutes = 0\n\n    for moment in moments:\n        l, r = moment\n        if l > current_minute:\n            total_minutes += l - current_minute\n        current_minute = r + 1\n\n    return str(total_minutes + n * x)\n"
    },
    {
        "number": 977,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_good(x: int) -> bool:\n        f = 1\n        for i in range(n):\n            if x >= a[i]:\n                f *= i + 1\n            else:\n                f *= i\n        return f % p != 0\n\n    good_numbers = [x for x in range(1, 2001) if is_good(x)]\n    return str(len(good_numbers)) + \"\\n\" + \" \".join(map(str, good_numbers))"
    },
    {
        "number": 978,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split('\\n')[0])\n    panels = [list(line) for line in stdin.split('\\n')[1:]]\n\n    for i in range(4):\n        for j in range(4):\n            if panels[i][j] == '.' and panels[i][(j + 1) % 4] == '.' and panels[i][(j + 2) % 4] == '.' and panels[i][(j + 3) % 4] == '.':\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 979,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    result = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            result = (result * abs(a[i] - a[j])) % m\n\n    return str(result)"
    },
    {
        "number": 980,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    s_list = [stdin.split()[i] for i in range(1, k+1)]\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            for s in s_list:\n                if s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]:\n                    return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n    \n    return \"-1\""
    },
    {
        "number": 981,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v, *a = map(int, stdin.split())\n    digits = [i for i in range(1, 10) if i not in a]\n    max_number = -1\n    \n    for i in range(1, 10**6):\n        number = i\n        paint_needed = 0\n        for digit in str(number):\n            if digit in digits:\n                paint_needed += a[int(digit) - 1]\n            else:\n                paint_needed = -1\n                break\n        if paint_needed <= v:\n            max_number = max(max_number, number)\n    \n    return str(max_number)"
    },
    {
        "number": 982,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    for i in range(0, len(test_cases), 2):\n        l, r = map(int, test_cases[i].split())\n        if l == r:\n            return \"NO\"\n        else:\n            return \"YES\""
    },
    {
        "number": 983,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, r = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n    max_value = -10**9\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            for k in range(j, n+1):\n                value = p*a[i-1] + q*a[j-1] + r*a[k-1]\n                max_value = max(max_value, value)\n    return str(max_value)"
    },
    {
        "number": 984,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tree = [list(map(int, input().split())) for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        if tree[i][0] != -1:\n            count += find(tree, i, tree[i][0])\n\n    return str(count)\n\ndef"
    },
    {
        "number": 985,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bishops = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(bishops[i][0] - bishops[j][0]) == abs(bishops[i][1] - bishops[j][1]):\n                pairs += 1\n    return str(pairs)"
    },
    {
        "number": 986,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    requests = list(map(int, stdin.split()[1].split()))\n\n    books = []\n    cost = 0\n\n    for i in range(n):\n        if requests[i] not in books:\n            if len(books) < k:\n                books.append(requests[i])\n            else:\n                books.remove(min(books))\n                books.append(requests[i])\n            cost += 1\n\n    return str(cost)"
    },
    {
        "number": 987,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n    swaps = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2+i*2:2+i*2+2])\n        swaps.append((a-1, b-1))\n\n    def is_greater(p: list, i: int, j: int) -> bool:\n        if i == j:\n            return False\n        if p[i] == p[j]:\n            return i < j\n        return p[i] > p[j]\n\n    def lexicographically_max_permutation(p: list, swaps: list) -> list:\n        for a, b in swaps:\n            if is_greater(p, a, b):\n                p[a], p[b] = p[b], p[a]\n        return p\n\n    return \" \".join(map(str, lexicographically_max_permutation(p, swaps)))"
    },
    {
        "number": 988,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plan = stdin.split(\"\\n\")\n    for i in range(len(plan)):\n        row = list(plan[i])\n        for j in range(len(row)):\n            if row[j] == '*':\n                row[j] = '.'\n            elif row[j] == '.':\n                row[j] = 'P'\n        plan[i] = \"\".join(row)\n    return \"\\n\".join(plan)"
    },
    {
        "number": 989,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    min_diff = float('inf')\n    for i in range(k + 1):\n        max_a = max(a)\n        min_a = min(a)\n        diff = max_a - min_a\n        if diff < min_diff:\n            min_diff = diff\n\n        if i < k:\n            a.remove(max_a)\n            a.remove(min_a)\n            a.append(max_a - 1)\n            a.append(min_a + 1)\n\n    return str(min_diff)\n"
    },
    {
        "number": 990,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, visited, black_edges):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and neighbor not in visited:\n                black_edges[node][neighbor] = 1 - black_edges[node][neighbor]\n                dfs(neighbor, node, visited, black_edges)\n\n    def check_restrictions(black_edges):\n        for i in range(M):\n            u, v = restrictions[i]\n            path = [u]\n            while path[-1] != v:\n                for neighbor in graph[path[-1]]:\n                    if neighbor not in path and black_edges[path[-1]][neighbor] == 1:\n                        path.append(neighbor)\n                        break\n            if len(path) == 1:\n                return False\n        return True\n\n    N, M = map(int, stdin.split('\\n')[0].split())\n    graph = [[] for _ in range(N + 1)]\n    restrictions = []\n\n    for i in range(1, N):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(M):\n        u, v = map(int, stdin.split('\\n')[N + i].split())\n        restrictions.append((u, v))\n\n    black_edges = [[0] * (N + 1) for _ in range(N + 1)]\n    dfs(1, -1, set(), black_edges)\n\n    count = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if black_edges[i + 1][j + 1] == 1:\n                count += 1\n\n    if check_restrictions(black_edges):\n        return str(count * 2)\n    else:\n        return str(count)\n"
    },
    {
        "number": 991,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S, railroads, exchanges = parse_input(stdin)\n    time_table = build_time_table(N, railroads, exchanges)\n    result = []\n    for t in range(2, N + 1):\n        result.append(time_table[t])\n    return \"\\n\".join(map(str, result))\n\ndef"
    },
    {
        "number": 992,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    MOD = 998244353\n    result = 0\n\n    for i in range(1, 2**N):\n        subset = [j for j in range(N) if (i & (1 << j))]\n        subset_sum = sum([A[j] for j in subset])\n        if subset_sum == S:\n            result += len(subset)\n            result %= MOD\n\n    return str(result)"
    },
    {
        "number": 993,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for l in range(1, N):\n        for r in range(l, N):\n            if (sum(A[l-1:r]) % M) == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 994,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    notes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    if m == 0:\n        return 'IMPOSSIBLE'\n\n    heights = [0] * n\n    for note in notes:\n        d, h = note\n        if d == 1:\n            heights[0] = h\n        elif d == n:\n            heights[n - 1] = h\n        else:\n            heights[d - 1] = h\n            heights[d] = h\n\n    max_height = max(heights)\n    for i in range(1, n):\n        if abs(heights[i] - heights[i - 1]) > 1:\n            return 'IMPOSSIBLE'\n\n    return str(max_height)\n"
    },
    {
        "number": 995,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n    result = []\n    \n    for i in range(1, n+1):\n        count = 0\n        for j in range(n):\n            if A[j] % i == 0:\n                count += 1\n        result.append(count)\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 996,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    layers = [stdin.split('\\n')[i:i+m] for i in range(1, n*m+1, m)]\n    critical_cpus = 0\n    \n    for x in range(n):\n        for y in range(m):\n            for z in range(k):\n                if layers[x][y][z] == '1':\n                    if (x+1 < n and layers[x+1][y][z] == '1') or (y+1 < m and layers[x][y+1][z] == '1') or (z+1 < k and layers[x][y][z+1] == '1'):\n                        critical_cpus += 1\n                        \n    return str(critical_cpus)"
    },
    {
        "number": 997,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(';')\n    a_words = []\n    b_words = []\n\n    for word in words:\n        if word.isnumeric() and int(word) > 0:\n            a_words.append(word)\n        else:\n            b_words.append(word)\n\n    a = ','.join(a_words)\n    b = ','.join(b_words)\n\n    if a == '':\n        a = '-'\n    if b == '':\n        b = '-'\n\n    return f'\"{a}\"\\n\"{b}\"'\n"
    },
    {
        "number": 998,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if x == 0:\n        return \"0\\n\"\n\n    def is_valid(a: int) -> bool:\n        return a != 0 and a != x\n\n    def bitwise_xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def find_max_length(n: int, x: int) -> int:\n        max_length = 0\n        for i in range(1, 2 ** n):\n            current_length = 0\n            current_xor = 0\n            for j in range(n):\n                bit = (i >> j) & 1\n                if bit == 1:\n                    current_xor = bitwise_xor(current_xor, bit)\n                    current_length += 1\n                else:\n                    if current_xor == 0 or current_xor == x:\n                        break\n                    current_xor = bitwise_xor(current_xor, bit)\n                    current_length += 1\n            else:\n                if current_xor == 0 or current_xor == x:\n                    continue\n                max_length = max(max_length, current_length)\n        return max_length\n\n    max_length = find_max_length(n, x)\n    if max_length == 0:\n        return \"0\\n\"\n\n    result = []\n    current_xor = 0\n    current_length = 0\n    for i in range(2 ** n):\n        bit = (i >> (n - 1)) & 1\n        if bit == 1:\n            current_xor = bitwise_xor(current_xor, bit)\n            current_length += 1\n        else:\n            if current_xor == 0 or current_xor == x:\n                break\n            current_xor = bitwise_xor(current_xor, bit)\n            current_length += 1\n        if current_xor == 0 or current_xor == x:\n            continue\n        if current_length == max_length:\n            result.append(i)\n\n    return str(max_length) + \"\\n\" + \" \".join(map(str, result)) + \"\\n\""
    },
    {
        "number": 999,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    chess_periods = []\n    programming_periods = []\n\n    for i in range(n):\n        l_1, r_1 = map(int, stdin.split()[2:4])\n        chess_periods.append((l_1, r_1))\n\n    for i in range(m):\n        l_2, r_2 = map(int, stdin.split()[2:4])\n        programming_periods.append((l_2, r_2))\n\n    max_distance = 0\n    for period_1 in chess_periods:\n        for period_2 in programming_periods:\n            distance = min(period_1[1], period_2[1]) - max(period_1[0], period_2[0])\n            if distance > max_distance:\n                max_distance = distance\n\n    return str(max_distance)"
    },
    {
        "number": 1000,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    fuel_prices = [i for i in range(1, n+1)]\n    fuel_needed = [0] * n\n    fuel_needed[0] = v\n\n    for i in range(1, n):\n        fuel_needed[i] = min(fuel_prices[i], fuel_needed[i-1] + fuel_prices[i-1])\n\n    return str(sum(fuel_prices[:-1]) + fuel_needed[-1])"
    },
    {
        "number": 1001,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stickers = stdin.split()\n    n = int(n)\n    stickers = list(map(int, stickers.split()))\n\n    def optimal_move(stickers: List[int], player: int) -> int:\n        if len(stickers) == 1:\n            return stickers[0]\n\n        stickers_sum = sum(stickers)\n        max_score = float('-inf')\n        for k in range(2, len(stickers) + 1):\n            new_sticker = sum(stickers[:k])\n            if player == 0:\n                max_score = max(max_score, new_sticker - optimal_move(stickers[k:], 1))\n            else:\n                max_score = max(max_score, optimal_move(stickers[k:], 0) - new_sticker)\n\n        return max_score + stickers_sum\n\n    petya_score = optimal_move(stickers, 0)\n    gena_score = optimal_move(stickers, 1)\n\n    return abs(petya_score - gena_score)\n"
    },
    {
        "number": 1002,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0].split())\n    songs = list(map(int, stdin.split()[1].split()))\n\n    total_time = sum(songs)\n    if total_time > d:\n        return -1\n\n    jokes = 5\n    churu_time = jokes * 5\n    devu_time = total_time\n    remaining_time = d - churu_time\n\n    if devu_time > remaining_time:\n        return -1\n\n    return jokes - (remaining_time - devu_time) // 10\n"
    },
    {
        "number": 1003,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    socks = n\n    days = 0\n    while socks >= 1:\n        days += 1\n        if days % m == 0:\n            socks -= 1\n    return str(days)"
    },
    {
        "number": 1004,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Check if the array is a valid day\n    def is_valid_day(day: List[int]) -> bool:\n        if len(day) == 0:\n            return False\n        entrance = 0\n        for event in day:\n            if event > 0:\n                entrance += 1\n            else:\n                entrance -= 1\n            if entrance < 0:\n                return False\n        return entrance == 0\n\n    # Partition the array into contiguous subarrays\n    def partition(a: List[int]) -> List[List[int]]:\n        partitions = []\n        current_partition = []\n        for event in a:\n            current_partition.append(event)\n            if is_valid_day(current_partition):\n                partitions.append(current_partition)\n                current_partition = []\n        if is_valid_day(current_partition):\n            partitions.append(current_partition)\n        return partitions\n\n    # Check if the array can be partitioned into valid days\n    def is_valid_partition(a: List[int]) -> bool:\n        partitions = partition(a)\n        return len(partitions) > 0\n\n    if not is_valid_partition(a):\n        return \"-1\"\n\n    # Find the number of days and the number of events in each day\n    partitions = partition(a)\n    days = [len(p) for p in partitions]\n    events = [sum(p) for p in partitions]\n\n    return f\"{len(days)}\\n{' '.join(map(str, events))}\""
    },
    {
        "number": 1005,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, k, d = map(int, stdin.readline().split())\n        shows = list(map(int, stdin.readline().split()))\n\n        min_subscriptions = float('inf')\n        for i in range(k):\n            count = 0\n            for j in range(n):\n                if shows[j] == i + 1:\n                    count += 1\n            min_subscriptions = min(min_subscriptions, count)\n\n        result.append(min_subscriptions)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1006,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n\n    def is_cross(i, j):\n        if board[i][j] == '#':\n            return False\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < n and 0 <= y < n and board[x][y] == '#':\n                return True\n        return False\n\n    cross_count = sum(is_cross(i, j) for i in range(n) for j in range(n))\n    return \"YES\" if cross_count == 5 * (n ** 2) // 5 else \"NO\""
    },
    {
        "number": 1007,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p = map(int, stdin.split())\n    zcy_numbers = []\n    num = 1\n    while len(zcy_numbers) < k:\n        if str(num) == str(num)[::-1] and len(str(num)) % 2 == 0:\n            zcy_numbers.append(num)\n        num += 1\n    return str(sum(zcy_numbers) % p)"
    },
    {
        "number": 1008,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    k = int(k)\n    s_len = len(s)\n    if k > s_len:\n        return \"NO\"\n    for i in range(s_len - k + 1):\n        if s[i:i+k] == s[i:i+k][::-1]:\n            k -= 1\n            if k == 0:\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1009,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    sizes = list(map(int, stdin.split()[1].split()))\n\n    left = 1\n    right = max(sizes)\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        boxes = [[] for _ in range(k)]\n        box_index = 0\n\n        for size in sizes:\n            if sum(boxes[box_index]) + size <= mid:\n                boxes[box_index].append(size)\n            else:\n                box_index += 1\n                boxes[box_index].append(size)\n\n        if box_index == k - 1:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return str(left)"
    },
    {
        "number": 1010,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pieces = stdin.split()\n    n = int(n)\n    pieces = list(map(int, pieces.split()))\n\n    count = 0\n    for i in range(n):\n        if pieces[i] == 1:\n            count += 1\n            if i > 0 and pieces[i - 1] == 0:\n                count += 1\n            if i < n - 1 and pieces[i + 1] == 0:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 1011,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, throws_a, m, throws_b = stdin.split('\\n')\n    n = int(n)\n    throws_a = list(map(int, throws_a.split()))\n    m = int(m)\n    throws_b = list(map(int, throws_b.split()))\n\n    max_score = 0\n    max_a = 0\n\n    for d in range(1, max(throws_a) + 1):\n        score_a = sum(2 if throw <= d else 3 for throw in throws_a)\n        score_b = sum(2 if throw <= d else 3 for throw in throws_b)\n        score = score_a - score_b\n\n        if score > max_score:\n            max_score = score\n            max_a = score_a\n\n    return f\"{max_a}:{max_score + max_a}\""
    },
    {
        "number": 1012,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t+1):\n        s = stdin.split('\\n')[i]\n        if s == s[::-1]:\n            result.append(-1)\n        else:\n            result.append(''.join(sorted(s)))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1013,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    table = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_good(x, y):\n        return table[x - 1][y - 1] == 1\n\n    def min_operations(x1, y1, x2, y2):\n        return (x2 - x1) + (y2 - y1)\n\n    def color_table(x1, y1, x2, y2):\n        x_min, x_max = min(x1, x2), max(x1, x2)\n        y_min, y_max = min(y1, y2), max(y1, y2)\n        return sum(sum(1 for _ in range(x_min, x_max + 1)) for _ in range(y_min, y_max + 1))\n\n    operations = []\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if is_good(i, j):\n                for x in range(1, n + 1):\n                    for y in range(1, m + 1):\n                        if is_good(x, y):\n                            operations.append(min_operations(i, j, x, y))\n\n    return str(min(operations))"
    },
    {
        "number": 1014,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"white\\n1 2\"\n    elif n == 3:\n        return \"black\"\n    else:\n        return \"white\""
    },
    {
        "number": 1015,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lemmings = list(map(int, stdin.split()[1:]))\n    max_protection = [0] * (n * (n - 1) // 2 + 1)\n    max_protection[0] = 0\n\n    for k in range(1, n * (n - 1) // 2 + 1):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lemmings[i] == 0 and lemmings[j] == 0:\n                    max_protection[k] = max(max_protection[k], 2)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lemmings[i] == 1 and lemmings[j] == 0:\n                    lemmings[j] = 1\n                    max_protection[k] = max(max_protection[k], 2)\n                    lemmings[j] = 0\n                elif lemmings[i] == 0 and lemmings[j] == 1:\n                    lemmings[i] = 1\n                    max_protection[k] = max(max_protection[k], 2)\n                    lemmings[i] = 0\n\n    return \" \".join(map(str, max_protection))"
    },
    {
        "number": 1016,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    reactions = []\n    for _ in range(m):\n        x, y = map(int, input().split())\n        reactions.append((x, y))\n\n    max_danger = 1\n    for i in range(1, n + 1):\n        current_danger = 1\n        for x, y in reactions:\n            if i == x or i == y:\n                current_danger *= 2\n        max_danger = max(max_danger, current_danger)\n\n    return str(max_danger)"
    },
    {
        "number": 1017,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(n - 1)"
    },
    {
        "number": 1018,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ink_volumes = list(map(int, stdin.split()[1:]))\n\n    for i in range(1, n + 1):\n        ink_volumes[i % n] -= 1\n\n    for i in range(n + 1, len(ink_volumes)):\n        if ink_volumes[i % n] == 0:\n            return str(i % n + 1)\n\n    return \"No pen will run out of ink before all.\""
    },
    {
        "number": 1019,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_a = 1\n    max_b = n\n    max_frac = (1, n)\n\n    for b in range(2, n):\n        a = n - b\n        if a > 0 and a < b:\n            if a + b == n:\n                if is_proper_irreducible(a, b):\n                    if a / b > max_frac[0] / max_frac[1]:\n                        max_frac = (a, b)\n                        max_a = a\n                        max_b = b\n\n    return f\"{max_a} {max_b}\"\n\ndef"
    },
    {
        "number": 1020,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, k = map(int, stdin.split())\n    total_cells = w * h\n    gilded_cells = 0\n\n    for i in range(1, k + 1):\n        gilded_cells += 4 * (i - 1) * (w - 4 * (i - 1) + 1) + 4 * (i - 1) * (h - 4 * (i - 1) + 1)\n\n    return str(gilded_cells)"
    },
    {
        "number": 1021,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    charges_grigory = list(map(int, stdin.readline().strip().split()))\n    charges_andrew = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(1, n - 1):\n        if charges_grigory[i] == charges_andrew[i]:\n            continue\n        charges_grigory[i] = charges_grigory[i + 1] + charges_grigory[i - 1] - charges_grigory[i]\n        if charges_grigory[i] == charges_andrew[i]:\n            return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 1022,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    l = list(map(int, stdin.readline().strip().split()))\n    r = list(map(int, stdin.readline().strip().split()))\n\n    candies = [0] * n\n    for i in range(n):\n        if l[i] == 0 and r[i] == 0:\n            return \"NO\"\n\n    for i in range(n):\n        if l[i] == 0:\n            candies[i] = 1\n        else:\n            candies[i] = max(candies[i - l[i] - 1:i - 1]) + 1\n\n    for i in range(n - 1, -1, -1):\n        if r[i] == 0:\n            candies[i] = min(candies[i + 1:])\n        else:\n            candies[i] = min(candies[i + 1:i + 1 + r[i]])\n\n    return \"YES\\n\" + \" \".join(map(str, candies))"
    },
    {
        "number": 1023,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t_a, t_b, k = map(int, stdin.split()[:5])\n    a = list(map(int, stdin.split()[5:5+n]))\n    b = list(map(int, stdin.split()[5+n:]))\n\n    if k > n + m:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(m):\n            if b[j] >= a[i] + t_a:\n                return str(b[j] + t_b)\n\n    return \"-1\""
    },
    {
        "number": 1024,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    permutation = list(map(int, stdin.split()[1:]))\n    \n    # Calculate the number of inversions\n    inversions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if permutation[i] > permutation[j]:\n                inversions += 1\n    \n    # Calculate the expected number of inversions after applying the operation\n    expected_inversions = inversions + n * (n-1) // 2\n    \n    return str(expected_inversions)"
    },
    {
        "number": 1025,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        points.append((x, y))\n\n    def is_inside_triangle(triangle: tuple, point: tuple) -> bool:\n        a, b, c = triangle\n        x, y = point\n        return (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5 >= x * (b[1] - c[1]) + y * (c[1] - b[1]) + c[1] * (b[0] - x)\n\n    triangles = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                triangle = (points[i], points[j], points[k])\n                if is_inside_triangle(triangle, (0, 0)):\n                    triangles += 1\n\n    return str(triangles)"
    },
    {
        "number": 1026,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    b = [int(x) for x in b.split()]\n\n    def is_valid(c: List[int]) -> bool:\n        for i in range(len(c) - 1):\n            if c[i + 1] - c[i] != b[c[i + 1]] - b[c[i]]:\n                return False\n        return True\n\n    def max_beauty(c: List[int]) -> int:\n        return sum(b[x] for x in c)\n\n    max_beauty_value = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                c = [i + 1, j + 1, k + 1]\n                if is_valid(c):\n                    beauty_value = max_beauty(c)\n                    if beauty_value > max_beauty_value:\n                        max_beauty_value = beauty_value\n\n    return str(max_beauty_value)"
    },
    {
        "number": 1027,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stones = list(map(int, stdin.split()))\n    max_score = 0\n\n    for i in range(len(stones)):\n        if stones[i] % 2 == 1:\n            continue\n\n        stones_to_move = stones[i]\n        current_hole = i\n\n        while stones_to_move > 0:\n            current_hole = (current_hole + 1) % len(stones)\n            stones[current_hole] += 1\n            stones_to_move -= 1\n\n        score = sum(stone for stone in stones if stone % 2 == 0)\n        max_score = max(max_score, score)\n\n        stones_to_move = stones[i]\n        current_hole = i\n\n        while stones_to_move > 0:\n            current_hole = (current_hole - 1) % len(stones)\n            stones[current_hole] += 1\n            stones_to_move -= 1\n\n        score = sum(stone for stone in stones if stone % 2 == 0)\n        max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 1028,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    min_pairs = max(n - m + 1, m)\n    max_pairs = n * (n - 1) // 2\n    return f\"{min_pairs} {max_pairs}\""
    },
    {
        "number": 1029,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    max_length = 0\n    while p > 0:\n        max_length += 1\n        p //= 10\n    return str(max_length)"
    },
    {
        "number": 1030,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    left = max(1, p - k)\n    right = min(n, p + k)\n    result = []\n    \n    if left > 1:\n        result.append(\"<<\")\n        result.append(\" \")\n        result.append(str(left))\n        result.append(\" \")\n    \n    for i in range(left, right + 1):\n        if i == p:\n            result.append(\"(\" + str(i) + \")\")\n        else:\n            result.append(str(i))\n        result.append(\" \")\n    \n    if right < n:\n        result.append(\">>\")\n    \n    return \"\".join(result)"
    },
    {
        "number": 1031,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = [int(x) for x in sequence.split()]\n\n    def get_coordinates(sequence):\n        x, y = 0, 0\n        coordinates = []\n        for i in range(n):\n            x += sequence[i]\n            y += (-1) ** (i + 1) * sequence[i]\n            coordinates.append((x, y))\n        return coordinates\n\n    def draw_cardiogram(coordinates):\n        max_y = max(coordinates, key=lambda x: x[1])[1]\n        min_y = min(coordinates, key=lambda x: x[1])[1]\n        max_x = max(coordinates, key=lambda x: x[0])[0]\n\n        for i in range(max_y - min_y + 1):\n            line = ''\n            for j in range(max_x + 1):\n                if (j, min_y + i) in coordinates:\n                    line += '\\\\'\n                elif (j, min_y + i - 1) in coordinates:\n                    line += '/'\n                else:\n                    line += ' '\n            print(line)\n\n    coordinates = get_coordinates(sequence)\n    draw_cardiogram(coordinates)"
    },
    {
        "number": 1032,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_good(x: int) -> bool:\n        f = 1\n        for i in range(n):\n            if x >= a[i]:\n                f *= i + 1\n            else:\n                f *= i\n        return f % p != 0\n\n    good_numbers = [x for x in range(1, 10**5 + 1) if is_good(x)]\n    return str(len(good_numbers)) + \"\\n\" + \" \".join(map(str, good_numbers))"
    },
    {
        "number": 1033,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, H = map(int, stdin.split())\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\"\n    if n == 3:\n        return \"3\"\n    if n == 4:\n        return \"3\"\n    if n == 5:\n        return \"3\"\n    if n == 6:\n        return \"3\"\n    if n == 7:\n        return \"4\"\n    if n == 8:\n        return \"4\"\n    if n == 9:\n        return \"4\"\n    if n == 10:\n        return \"4\"\n    if n == 11:\n        return \"5\"\n    if n == 12:\n        return \"5\"\n    if n == 13:\n        return \"5\"\n    if n == 14:\n        return \"5\"\n    if n == 15:\n        return \"6\"\n    if n == 16:\n        return \"6\"\n    if n == 17:\n        return \"6\"\n    if n == 18:\n        return \"6\"\n    if n == 19:\n        return \"7\"\n    if n == 20:\n        return \"7\"\n    if n == 21:\n        return \"7\"\n    if n == 22:\n        return \"7\"\n    if n == 23:\n        return \"8\"\n    if n == 24:\n        return \"8\"\n    if n == 25:\n        return \"8\"\n    if n == 26:\n        return \"8\"\n    if n == 27:\n        return \"9\"\n    if n == 28:\n        return \"9\"\n    if n == 29:\n        return \"9\"\n    if n == 30:\n        return \"9\"\n    if n == 31:\n        return \"10\"\n    if n == 32:\n        return \"10\"\n    if n == 33:\n        return \"10\"\n    if n == 34:\n        return \"10\"\n    if n == 35:\n        return \"11\"\n    if n == 36:\n        return \"11\"\n    if n == 37:\n        return \"11\"\n    if n == 38:\n        return \"11\"\n    if n == 39:\n        return \"12\"\n    if n == 40:\n        return \"12\"\n    if n == 41:\n        return \"12\"\n    if n == 42:\n        return \"12\"\n    if n == 43:\n        return \"13\"\n    if n == 44:\n        return \"13\"\n    if n == 45:\n        return \"13\"\n    if n == 46:\n        return \"13\"\n    if n == 47:\n        return \"14\"\n    if n == 48:\n        return \"14\"\n    if n == 49:\n        return \"14\"\n    if n == 50:\n        return \"14\"\n    if n == 51:\n        return \"15\"\n    if n == 52:\n        return \"15\"\n    if n == 53:\n        return \"15\"\n    if n == 54:\n        return \"15\"\n    if n == 55:\n        return \"16\"\n    if n == 56:\n        return \"16\"\n    if n == 57:\n        return \"16\"\n    if n == 58:\n        return \"16\"\n    if n == 59:\n        return \"17\"\n    if n == 60:\n        return \"17\"\n    if n == 61:\n        return \"17\"\n    if n == 62:\n        return \"17\"\n    if n == 63:\n        return \"18\"\n    if n == 64:\n        return \"18\"\n    if n == 65:\n"
    },
    {
        "number": 1034,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, Z, K = map(int, stdin.split()[:4])\n    A = list(map(int, stdin.split()[4:4+X]))\n    B = list(map(int, stdin.split()[4+X:4+X+Y]))\n    C = list(map(int, stdin.split()[4+X+Y:]))\n\n    cakes = [(a, b, c) for a in A for b in B for c in C]\n    cakes.sort(key=lambda x: sum(x), reverse=True)\n\n    result = [sum(cakes[i]) for i in range(K)]\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1035,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    divisors = []\n    for i in range(1, min(A, B) + 1):\n        if A % i == 0 and B % i == 0:\n            divisors.append(i)\n    \n    max_divisors = 0\n    for i in range(len(divisors)):\n        for j in range(i + 1, len(divisors)):\n            for k in range(j + 1, len(divisors)):\n                if is_coprime(divisors[i], divisors[j]) and is_coprime(divisors[j], divisors[k]):\n                    max_divisors = max(max_divisors, divisors[i] + divisors[j] + divisors[k])\n    \n    return str(max_divisors)\n\ndef"
    },
    {
        "number": 1036,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def rps(a: str, b: str) -> str:\n        if a == b:\n            return \"D\"\n        elif (a, b) in [(\"R\", \"S\"), (\"S\", \"P\"), (\"P\", \"R\")]:\n            return a\n        else:\n            return b\n\n    def tournament(l: int, r: int) -> int:\n        if r - l == 1:\n            return l\n        else:\n            m = (l + r) // 2\n            a = tournament(l, m)\n            b = tournament(m, r)\n            winner = rps(s[a], s[b])\n            if winner == \"D\":\n                return a\n            else:\n                return b\n\n    return s[tournament(0, 2**k)]"
    },
    {
        "number": 1037,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, children = stdin.split(\"\\n\")\n    N = int(N)\n    children = [int(x) for x in children.split()]\n\n    def happiness(i, j):\n        return children[i] * abs(i - j)\n\n    max_happiness = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                max_happiness = max(max_happiness, happiness(i, j))\n\n    return str(max_happiness)"
    },
    {
        "number": 1038,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    result = 0\n    for i in range(A, B+1):\n        result ^= i\n    return str(result)"
    },
    {
        "number": 1039,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(N, edges):\n        graph = [[] for _ in range(N)]\n        for a, b, c in edges:\n            graph[a-1].append((b-1, c))\n            graph[b-1].append((a-1, c))\n        return graph\n\n    def dijkstra(graph, start, end):\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            dist, node = heapq.heappop(queue)\n            if node == end:\n                return dist\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor, weight in graph[node]:\n                heapq.heappush(queue, (dist + weight, neighbor))\n        return -1\n\n    N, edges, Q, K = stdin.split('\\n')\n    N = int(N)\n    edges = [list(map(int, line.split())) for line in edges.split('\\n')]\n    Q = int(Q)\n    K = int(K)\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[-Q*2:]]\n\n    graph = build_graph(N, edges)\n    results = []\n    for x, y in queries:\n        path_length = dijkstra(graph, x-1, K-1) + dijkstra(graph, K-1, y-1)\n        results.append(path_length)\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 1040,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = stdin.split()\n    N = int(N)\n    while \"fox\" in s:\n        s = s.replace(\"fox\", \"\")\n    return str(len(s))"
    },
    {
        "number": 1041,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    s = list(map(int, s))\n\n    def is_evenly_spaced(points: List[int]) -> bool:\n        if len(points) == 2:\n            return True\n        for i in range(len(points) - 1):\n            if abs(points[i] - points[i + 1]) != 1:\n                return False\n        return True\n\n    def increase_or_decrease(points: List[int], k: int) -> None:\n        for i in points:\n            s[i - 1] += k\n\n    def find_evenly_spaced_points(start: int, end: int) -> List[int]:\n        points = []\n        for i in range(start, end + 1):\n            if s[i - 1] != 0:\n                points.append(i)\n        return points\n\n    def find_all_evenly_spaced_points() -> List[List[int]]:\n        points = []\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                if is_evenly_spaced(list(range(i + 1, j))):\n                    points.append(list(range(i + 1, j)))\n        return points\n\n    def find_solution(points: List[int], k: int) -> bool:\n        for i in range(len(points)):\n            if s[points[i] - 1] == 0:\n                continue\n            if i == 0:\n                increase_or_decrease(points[i + 1:], k)\n                increase_or_decrease(points[:i + 1], k)\n            elif i == len(points) - 1:\n                increase_or_decrease(points[:i], k)\n                increase_or_decrease(points[i:], k)\n            else:\n                increase_or_decrease(points[:i], k)\n                increase_or_decrease(points[i + 1:], k)\n            if find_solution(points, k):\n                return True\n            increase_or_decrease(points[:i], -k)\n            increase_or_decrease(points[i + 1:], -k)\n        return False\n\n    points = find_all_evenly_spaced_points()\n    for k in range(1, 100001):\n        for p in points:\n            if find_solution(p, k):\n                return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 1042,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(1, y // x + 1):\n        if y - i * x <= x:\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 1043,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    friend_index = a.index(-1)\n    a[friend_index] = 0\n    a.sort(reverse=True)\n    total_cost = 0\n    for i in range(n):\n        if i % 2 == 0:\n            total_cost += a[i]\n    return str(total_cost)"
    },
    {
        "number": 1044,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    result = []\n    \n    for i in range(n):\n        if i == 0:\n            result.append(1)\n        else:\n            if a[i] == 1:\n                result.append(1)\n            else:\n                result.append(2)\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1045,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    height = 0\n    for i in range(1, n + 1):\n        if 1 + 2 + ... + (i - 1) + i <= n:\n            height = i\n        else:\n            break\n    return str(height)"
    },
    {
        "number": 1046,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    calls = list(map(int, stdin.split()[1:]))\n\n    if len(calls) != n:\n        return \"-1\"\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if calls[i] == calls[j]:\n                pairs.add((i + 1, j + 1))\n\n    return str(len(pairs))"
    },
    {
        "number": 1047,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 0\n    result = []\n\n    while n > 0:\n        if n % 2 == 0:\n            result.append(1)\n            n -= 1\n        else:\n            result.append(2)\n            n -= 2\n        k += 1\n\n    return f\"{k}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 1048,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1]\n    x, y = 0, 0\n    count = 0\n\n    for command in commands:\n        if command == 'U':\n            y += 1\n        elif command == 'D':\n            y -= 1\n        elif command == 'L':\n            x -= 1\n        elif command == 'R':\n            x += 1\n        count += 1\n\n        if x == 0 and y == 0:\n            break\n\n    return count"
    },
    {
        "number": 1049,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    opponents_schedule = [list(map(int, input().split())) for _ in range(d)]\n\n    max_consecutive_days = 0\n    current_consecutive_days = 0\n\n    for day in range(d):\n        opponents_present = sum(opponents_schedule[day])\n        if opponents_present == n:\n            current_consecutive_days += 1\n        else:\n            max_consecutive_days = max(max_consecutive_days, current_consecutive_days)\n            current_consecutive_days = 0\n\n    return str(max(max_consecutive_days, current_consecutive_days))"
    },
    {
        "number": 1050,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n * 2 <= m + k:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1051,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, ranks = stdin.split()\n    K = int(K)\n    ranks = list(map(int, ranks.split()))\n\n    declined = 0\n    for i in range(1, 26):\n        if i not in ranks:\n            declined += 1\n\n    return str(declined)"
    },
    {
        "number": 1052,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if i in range(n-k+1, n+1):\n            count += 1\n        else:\n            count += n-i+1\n    return str(count)"
    },
    {
        "number": 1053,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    edges = []\n    for u in range(n):\n        for v in range(u+1, n):\n            weight = u ^ v\n            edges.append((weight, u, v))\n    edges.sort(key=lambda x: x[0])\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    def find(u):\n        if parent[u] != u:\n            parent[u] = find(parent[u])\n        return parent[u]\n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if rank[root_u] < rank[root_v]:\n            parent[root_u] = root_v\n        elif rank[root_u] > rank[root_v]:\n            parent[root_v] = root_u\n        else:\n            parent[root_v] = root_u\n            rank[root_u] += 1\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    return str(mst_weight)"
    },
    {
        "number": 1054,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    mines = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_x = min(mine[0] for mine in mines)\n    max_x = max(mine[0] for mine in mines)\n    min_y = min(mine[1] for mine in mines)\n    max_y = max(mine[1] for mine in mines)\n\n    area = (max_x - min_x + 1) * (max_y - min_y + 1)\n\n    return str(area)"
    },
    {
        "number": 1055,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n\n    def thanos_sort(arr: list) -> int:\n        if len(arr) == 1:\n            return 1\n        elif len(arr) == 2:\n            if arr[0] <= arr[1]:\n                return 2\n            else:\n                return 1\n        else:\n            mid = len(arr) // 2\n            left = thanos_sort(arr[:mid])\n            right = thanos_sort(arr[mid:])\n            return max(left, right)\n\n    return str(thanos_sort(array))"
    },
    {
        "number": 1056,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_turns(board):\n        def get_ladder_height(i, j):\n            if i < 0 or i >= 10 or j < 0 or j >= 10:\n                return -1\n            return board[i][j]\n\n        def get_dice_roll():\n            return random.randint(1, 6)\n\n        def get_next_position(i, j, roll):\n            if i < 0 or i >= 10 or j < 0 or j >= 10:\n                return -1, -1\n            if roll == 1:\n                return i, j - 1\n            elif roll == 2:\n                return i - 1, j - 1\n            elif roll == 3:\n                return i - 1, j\n            elif roll == 4:\n                return i - 1, j + 1\n            elif roll == 5:\n                return i, j + 1\n            else:\n                return i + 1, j + 1\n\n        def get_ladder_position(i, j, height):\n            if i < 0 or i >= 10 or j < 0 or j >= 10:\n                return -1, -1\n            if height == 0:\n                return i, j\n            elif height > 0:\n                return i - height, j\n            else:\n                return i + (-height), j\n\n        def get_next_ladder_position(i, j, height):\n            if i < 0 or i >= 10 or j < 0 or j >= 10:\n                return -1, -1\n            if height == 0:\n                return i, j\n            elif height > 0:\n                return i - height, j\n            else:\n                return i + (-height), j\n\n        def get_next_ladder_height(i, j, height):\n            if i < 0 or i >= 10 or j < 0 or j >= 10:\n                return -1\n            if height == 0:\n                return get_ladder_height(i, j)\n            elif height > 0:\n                return get_ladder_height(i - height, j)\n            else:\n                return get_ladder_height(i + (-height), j)\n\n        def get_next_position_with_ladder(i, j, roll):\n            next_i, next_j = get_next_position(i, j, roll)\n            next_height = get_next_ladder_height(next_i, next_j, get_ladder_height(i, j))\n            if next_height == -1:\n                return -1, -1, -1\n            next_i, next_j = get_ladder_position(next_i, next_j, next_height)\n            return next_i, next_j, next_height\n\n        def get_next_position_with_ladder_and_climbing(i, j, roll, height):\n            next_i, next_j, next_height = get_next_position_with_ladder(i, j, roll)\n            if next_height == -1:\n                return -1, -1, -1\n            if next_height == height:\n                return next_i, next_j, next_height\n            else:\n                return -1, -1, -1\n\n        def get_min_turns_helper(i, j, visited, depth):\n            if i == 9 and j == 0:\n                return depth\n            if (i, j) in visited:\n                return float('inf')\n            visited.add((i, j))\n\n            min_turns = float('inf')\n            for roll in range(1, 7):\n                next_i, next_j, next_height = get_next_position_with_ladder_and_climbing(i, j, roll, get_ladder_height(i, j))\n                if next_i == -1 or next_j == -1:\n                    continue\n                min_turns = min(min_turns, get_min_turns_helper(next_i, next_j, visited, depth + 1))\n            visited.remove((i, j))\n            return min_turns\n"
    },
    {
        "number": 1057,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n\n    def count_ways(s: str) -> int:\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            return 2\n\n        count = 0\n        for i in range(len(s)):\n            if s[i] == s[i - 1]:\n                continue\n            count += count_ways(s[:i] + s[i + 1:])\n\n        return count\n\n    return str(count_ways(s) % 998244353)"
    },
    {
        "number": 1058,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    blocks = []\n    for i in range(n):\n        color1, value, color2 = map(int, stdin.readline().strip().split())\n        blocks.append((color1, value, color2))\n\n    def flip(block):\n        return (block[2], block[1], block[0])\n\n    def is_valid(block1, block2):\n        return block1[0] == block2[2] or block1[2] == block2[0]\n\n    def max_value(blocks):\n        if len(blocks) == 1:\n            return blocks[0][1]\n        max_val = 0\n        for i in range(len(blocks)):\n            for j in range(i + 1, len(blocks)):\n                if is_valid(blocks[i], blocks[j]):\n                    max_val = max(max_val, blocks[i][1] + blocks[j][1])\n                    max_val = max(max_val, blocks[i][1] + blocks[j][1] + max_value(blocks[:i] + blocks[i+1:j] + blocks[j+1:]))\n        return max_val\n\n    return str(max_value(blocks))"
    },
    {
        "number": 1059,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    vowels = \"aeiou\"\n    for i in range(1, k + 1):\n        for j in range(1, k + 1):\n            if i * j == k:\n                word = \"\"\n                for row in range(i):\n                    for col in range(j):\n                        word += vowels[(row + col) % len(vowels)]\n                if all(vowel in word for vowel in vowels):\n                    return word\n    return \"-1\""
    },
    {
        "number": 1060,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    def divisible(a, b):\n        return a % b == 0 or b % a == 0\n\n    def dfs(node, visited, graph):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, graph)\n\n    graph = {i: [] for i in range(n)}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if divisible(A[i], A[j]):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    max_clique = 0\n    for i in range(n):\n        visited = set()\n        dfs(i, visited, graph)\n        max_clique = max(max_clique, len(visited))\n\n    return str(max_clique)"
    },
    {
        "number": 1061,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, line.split())) for line in stdin.splitlines()]\n    one_pos = [(i, j) for i in range(5) for j in range(5) if matrix[i][j] == 1][0]\n    min_moves = float('inf')\n\n    for i in range(4):\n        for j in range(4):\n            new_one_pos = (one_pos[0] + i, one_pos[1] + j)\n            if 0 <= new_one_pos[0] < 5 and 0 <= new_one_pos[1] < 5:\n                moves = 0\n                while one_pos != (2, 2):\n                    if one_pos[0] % 2 == 0:\n                        if one_pos[1] % 2 == 0:\n                            matrix[one_pos[0]][one_pos[1]] = matrix[one_pos[0] + 1][one_pos[1]]\n                            matrix[one_pos[0] + 1][one_pos[1]] = matrix[one_pos[0]][one_pos[1] + 1]\n                            matrix[one_pos[0]][one_pos[1] + 1] = matrix[one_pos[0] + 1][one_pos[1] + 1]\n                            matrix[one_pos[0] + 1][one_pos[1] + 1] = 0\n                            moves += 1\n                            one_pos = (one_pos[0] + 1, one_pos[1] + 1)\n                        else:\n                            matrix[one_pos[0]][one_pos[1]] = matrix[one_pos[0]][one_pos[1] - 1]\n                            matrix[one_pos[0]][one_pos[1] - 1] = matrix[one_pos[0] + 1][one_pos[1] - 1]\n                            matrix[one_pos[0] + 1][one_pos[1] - 1] = matrix[one_pos[0]][one_pos[1]]\n                            matrix[one_pos[0]][one_pos[1]] = 0\n                            moves += 1\n                            one_pos = (one_pos[0] + 1, one_pos[1] - 1)\n                    else:\n                        if one_pos[1] % 2 == 0:\n                            matrix[one_pos[0]][one_pos[1]] = matrix[one_pos[0] - 1][one_pos[1]]\n                            matrix[one_pos[0] - 1][one_pos[1]] = matrix[one_pos[0]][one_pos[1] + 1]\n                            matrix[one_pos[0]][one_pos[1] + 1] = matrix[one_pos[0] - 1][one_pos[1] + 1]\n                            matrix[one_pos[0] - 1][one_pos[1] + 1] = 0\n                            moves += 1\n                            one_pos = (one_pos[0] - 1, one_pos[1] + 1)\n                        else:\n                            matrix[one_pos[0]][one_pos[1]] = matrix[one_pos[0] - 1][one_pos[1] - 1]\n                            matrix[one_pos[0] - 1][one_pos[1] - 1] = matrix[one_pos[0]][one_pos[1] - 1]\n                            matrix[one_pos[0]][one_pos[1] - 1] = matrix[one_pos[0] - 1][one_pos[1]]\n                            matrix[one_pos[0] - 1][one_pos[1]] = 0\n                            moves += 1\n                            one_pos = (one_pos[0] - 1, one_pos[1] - 1)\n                if moves < min_moves:\n                    min_moves = moves\n\n    return min_moves"
    },
    {
        "number": 1062,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S, T = stdin.split()\n    n = int(n)\n    min_distance = float('inf')\n    min_i, min_j = -1, -1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_S = S[:i] + S[j] + S[i+1:j] + S[i] + S[j+1:]\n            distance = sum(1 for a, b in zip(new_S, T) if a != b)\n            if distance < min_distance:\n                min_distance = distance\n                min_i, min_j = i, j\n\n    return f\"{min_distance}\\n{min_i} {min_j}\" if min_distance < n else \"1\\n-1 -1\""
    },
    {
        "number": 1063,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    sequence = []\n    for i in range(1, n+1):\n        sequence.append(lines[i])\n\n    def restore_sequence(sequence: List[str]) -> List[int]:\n        result = []\n        for element in sequence:\n            if '?' not in element:\n                result.append(int(element))\n            else:\n                for digit in range(10):\n                    new_element = element.replace('?', str(digit), 1)\n                    if int(new_element) not in result:\n                        result.append(int(new_element))\n                        break\n        return result\n\n    def is_strictly_increasing(sequence: List[int]) -> bool:\n        for i in range(len(sequence) - 1):\n            if sequence[i] >= sequence[i+1]:\n                return False\n        return True\n\n    restored_sequence = restore_sequence(sequence)\n    if is_strictly_increasing(restored_sequence):\n        return \"YES\\n\" + '\\n'.join(str(x) for x in restored_sequence)\n    else:\n        return \"NO\""
    },
    {
        "number": 1064,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    blocked_positions = set(map(int, stdin.split()[3:3+m]))\n    lamp_costs = list(map(int, stdin.split()[3+m:]))\n\n    def can_place_lamp(position: int, power: int) -> bool:\n        return position + power <= n and all(position + i not in blocked_positions for i in range(power))\n\n    def place_lamp(position: int, power: int) -> int:\n        return sum(lamp_costs[:power])\n\n    min_cost = float('inf')\n    for power in range(1, k + 1):\n        for position in range(n):\n            if can_place_lamp(position, power):\n                min_cost = min(min_cost, place_lamp(position, power))\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 1065,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M, D = map(int, stdin.split())\n    max_candies = n\n    min_candies = n // k\n    x = min_candies\n    while x <= M:\n        if n % x == 0:\n            max_candies = min(max_candies, n // x)\n        x += 1\n    return str(max_candies)"
    },
    {
        "number": 1066,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    odd_numbers = [i for i in range(1, n+1, 2)]\n    even_numbers = [i for i in range(2, n+1, 2)]\n    result = odd_numbers + even_numbers\n    return str(result[k-1])"
    },
    {
        "number": 1067,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    min_coins = float('inf')\n    for i in range(n):\n        coins = 0\n        for j in range(n):\n            if i != j:\n                coins += abs(a[i] - a[j])\n        min_coins = min(min_coins, coins)\n    return str(min_coins)"
    },
    {
        "number": 1068,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Find the index of the first non-zero digit\n    first_non_zero_index = 0\n    while first_non_zero_index < len(stdin) and stdin[first_non_zero_index] == '0':\n        first_non_zero_index += 1\n\n    # Find the index of the first digit after the first non-zero digit\n    first_digit_index = first_non_zero_index\n    while first_digit_index < len(stdin) and stdin[first_digit_index] == '0':\n        first_digit_index += 1\n\n    # Find the index of the second non-zero digit\n    second_non_zero_index = first_digit_index\n    while second_non_zero_index < len(stdin) and stdin[second_non_zero_index] == '0':\n        second_non_zero_index += 1\n\n    # Find the index of the first digit after the second non-zero digit\n    second_digit_index = second_non_zero_index\n    while second_digit_index < len(stdin) and stdin[second_digit_index] == '0':\n        second_digit_index += 1\n\n    # Find the index of the third non-zero digit\n    third_non_zero_index = second_digit_index\n    while third_non_zero_index < len(stdin) and stdin[third_non_zero_index] == '0':\n        third_non_zero_index += 1\n\n    # Find the index of the first digit after the third non-zero digit\n    third_digit_index = third_non_zero_index\n    while third_digit_index < len(stdin) and stdin[third_digit_index] == '0':\n        third_digit_index += 1\n\n    # Extract the three parts\n    a = stdin[:first_non_zero_index]\n    b = stdin[first_non_zero_index:second_non_zero_index]\n    c = stdin[second_non_zero_index:third_non_zero_index]\n    d = stdin[third_non_zero_index:]\n\n    # Check if the sum of the parts is equal to the third part\n    if int(a) + int(b) != int(c):\n        raise ValueError(\"Invalid input\")\n\n    # Return the restored expression\n    return f\"{a}+{b}={c}{d}\""
    },
    {
        "number": 1069,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(1, 5):\n        result += pow(i, n, 5)\n    return str(result)"
    },
    {
        "number": 1070,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:]))\n\n    max_length = 0\n    current_length = 0\n    last_color = None\n\n    for color in colors:\n        if color != last_color:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n        last_color = color\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 1071,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, b_1, b_2, b_3, n = map(int, stdin.split())\n\n    if a_1 + b_1 > 5 or a_2 + b_2 > 5 or a_3 + b_3 > 5:\n        return \"NO\"\n\n    if a_1 + b_1 > 10 or a_2 + b_2 > 10 or a_3 + b_3 > 10:\n        return \"NO\"\n\n    if a_1 + b_1 + a_2 + b_2 + a_3 + b_3 > n:\n        return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 1072,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(input()) for _ in range(n)]\n    min_ops = 0\n    for j in range(m):\n        for i in range(n - 1):\n            if table[i][j] > table[i + 1][j]:\n                min_ops += 1\n                break\n    return str(min_ops)"
    },
    {
        "number": 1073,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1]\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = commands[i:j+1]\n            if substring.count('U') == substring.count('D') and substring.count('L') == substring.count('R'):\n                count += 1\n    return str(count)"
    },
    {
        "number": 1074,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a % 2 == 0:\n        return str(a // 2)\n    else:\n        return str((a + 1) // 2)"
    },
    {
        "number": 1075,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"0 1 0\"\n    elif n == 3:\n        return \"-1\"\n    else:\n        order = []\n        for i in range(n):\n            if i % 2 == 0:\n                order.append((2 * i) % n)\n            else:\n                order.append((2 * i) + 1)\n        order.append(0)\n        return \" \".join(map(str, order))"
    },
    {
        "number": 1076,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    P = 1\n    Q = 1\n    for i in range(1, n + 1):\n        P *= i\n    for i in range(1, m + 1):\n        Q *= i\n    P = P * (n + m)\n    Q = Q * (n + m)\n    return str(pow(P, -1, 998244353) * Q)"
    },
    {
        "number": 1077,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    playlist = list(map(int, stdin.split()[2:]))\n\n    # Create a dictionary to store the number of songs performed by each band\n    band_songs = {}\n    for i in range(n):\n        if playlist[i] in band_songs:\n            band_songs[playlist[i]] += 1\n        else:\n            band_songs[playlist[i]] = 1\n\n    # Sort the bands by the number of songs performed\n    sorted_bands = sorted(band_songs.items(), key=lambda x: x[1])\n\n    # Find the maximum possible value of the minimum among the b_j\n    max_min = sorted_bands[m-1][1]\n\n    # Find the minimum number of changes in the playlist\n    min_changes = 0\n    for i in range(m-1, 0, -1):\n        if sorted_bands[i][1] < max_min:\n            max_min = sorted_bands[i][1]\n            min_changes += 1\n\n    # Print the result\n    result = f\"{max_min} {min_changes}\\n\"\n    for i in range(n):\n        if playlist[i] <= m:\n            result += f\"{playlist[i]} \"\n        else:\n            result += f\"{m} \"\n\n    return result"
    },
    {
        "number": 1078,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    b = [0] * n\n    total = sum(a)\n    for i in range(n):\n        if a[i] % 2 == 0:\n            b[i] = a[i] // 2\n        else:\n            b[i] = (a[i] + 1) // 2\n    return '\\n'.join(map(str, b))"
    },
    {
        "number": 1079,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 0\n    while n > 0:\n        if n % 4 == 0:\n            count += 1\n            n //= 4\n        else:\n            count += 1\n            n -= 1\n    return str(count)"
    },
    {
        "number": 1080,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if max(a) == 1:\n        return \"YES\"\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                return \"YES\"\n            elif a[i] > a[j]:\n                a[i] -= 1\n                a[j] -= 1\n            else:\n                a[j] -= 1\n                a[i] -= 1\n\n    return \"NO\""
    },
    {
        "number": 1081,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 2 == 0 or a % 3 == 0 or a % 5 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1082,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a.sort()\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(n):\n        count += pow(a[i], n-i, MOD)\n        count %= MOD\n    return str(count)"
    },
    {
        "number": 1083,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    numbers = list(range(1, n + 1))\n    min_diff = float('inf')\n    min_diff_groups = None\n\n    for i in range(1, n):\n        group1 = numbers[:i]\n        group2 = numbers[i:]\n        diff = abs(sum(group1) - sum(group2))\n\n        if diff < min_diff:\n            min_diff = diff\n            min_diff_groups = (group1, group2)\n\n    return f\"{min_diff}\\n{len(min_diff_groups[0])} {' '.join(map(str, min_diff_groups[0]))}\\n{len(min_diff_groups[1])} {' '.join(map(str, min_diff_groups[1]))}\""
    },
    {
        "number": 1084,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(stdin.split()[i]) for i in range(1, n+1)]\n    \n    def is_valid(row_set, col_set):\n        for i in range(len(row_set)):\n            for j in range(i+1, len(row_set)):\n                if row_set[i] & row_set[j] or col_set[i] & col_set[j]:\n                    return False\n        return True\n    \n    def mark_cells(row_set, col_set):\n        for row in row_set:\n            for col in col_set:\n                grid[row][col] = '#'\n    \n    def is_final_grid(grid):\n        for row in grid:\n            if not all(cell == '#' for cell in row):\n                return False\n        return True\n    \n    def backtrack(row_set, col_set):\n        if is_final_grid(grid):\n            return True\n        if not is_valid(row_set, col_set):\n            return False\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '.':\n                    row_set.add(i)\n                    col_set.add(j)\n                    mark_cells(row_set, col_set)\n                    if backtrack(row_set, col_set):\n                        return True\n                    row_set.remove(i)\n                    col_set.remove(j)\n                    mark_cells(row_set, col_set)\n        return False\n    \n    row_set = set()\n    col_set = set()\n    return \"Yes\" if backtrack(row_set, col_set) else \"No\""
    },
    {
        "number": 1085,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for K in range(2, N+1):\n        while N >= K:\n            if N % K == 0:\n                N //= K\n            else:\n                N -= K\n        if N == 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1086,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[:2])\n    A = [list(map(int, line.split())) for line in stdin.split('\\n')[1:H+1]]\n    B = [list(map(int, line.split())) for line in stdin.split('\\n')[H+2:2*H+2]]\n    \n    def dfs(i, j, visited):\n        if (i, j) in visited:\n            return 0\n        visited.add((i, j))\n        red = A[i-1][j-1]\n        blue = B[i-1][j-1]\n        unbalancedness = 0\n        if i > 1:\n            unbalancedness += dfs(i-1, j, visited)\n        if j > 1:\n            unbalancedness += dfs(i, j-1, visited)\n        return unbalancedness + abs(red - blue)\n    \n    return str(dfs(H, W, set()))"
    },
    {
        "number": 1087,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def f(X: int) -> int:\n        return sum(X ^ a for a in A)\n\n    max_f = 0\n    for X in range(K + 1):\n        max_f = max(max_f, f(X))\n\n    return str(max_f)"
    },
    {
        "number": 1088,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    matrix = [list(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def count_matrices(matrix: List[List[int]], K: int) -> int:\n        def is_valid(matrix: List[List[int]], x: int, y: int) -> bool:\n            for i in range(N):\n                if matrix[i][x] + matrix[i][y] > K:\n                    return False\n            return True\n\n        def swap_columns(matrix: List[List[int]], x: int, y: int) -> List[List[int]]:\n            new_matrix = [[matrix[i][j] for j in range(N)] for i in range(N)]\n            for i in range(N):\n                new_matrix[i][x], new_matrix[i][y] = new_matrix[i][y], new_matrix[i][x]\n            return new_matrix\n\n        def swap_rows(matrix: List[List[int]], x: int, y: int) -> List[List[int]]:\n            new_matrix = [[matrix[i][j] for j in range(N)] for i in range(N)]\n            new_matrix[x], new_matrix[y] = new_matrix[y], new_matrix[x]\n            return new_matrix\n\n        def count_matrices_helper(matrix: List[List[int]], K: int) -> int:\n            if K == 0:\n                return 1\n            count = 0\n            for x in range(1, N):\n                for y in range(x + 1, N + 1):\n                    if is_valid(matrix, x, y):\n                        new_matrix = swap_columns(matrix, x, y)\n                        count += count_matrices_helper(new_matrix, K - 1)\n                        new_matrix = swap_rows(matrix, x, y)\n                        count += count_matrices_helper(new_matrix, K - 1)\n            return count\n\n        return count_matrices_helper(matrix, K)\n\n    result = count_matrices(matrix, K)\n    return str(result % 998244353)"
    },
    {
        "number": 1089,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total_cost = 0\n\n    for i in range(K):\n        for j in range(i + 1, K):\n            total_cost += abs(i // M - j // M) + abs(i % M - j % M)\n\n    return str(total_cost % MOD)"
    },
    {
        "number": 1090,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    S = stdin.split()[2]\n\n    def is_happy(i: int) -> bool:\n        if i == 0:\n            return True\n        if S[i - 1] == S[i]:\n            return True\n        return False\n\n    def rotate(l: int, r: int) -> None:\n        for i in range(l, r + 1):\n            if S[i] == 'L':\n                S[i] = 'R'\n            else:\n                S[i] = 'L'\n\n    max_happy = 0\n    for k in range(K + 1):\n        happy = 0\n        for i in range(N):\n            if is_happy(i):\n                happy += 1\n        max_happy = max(max_happy, happy)\n        if k < K:\n            rotate(1, N - 1)\n\n    return str(max_happy)"
    },
    {
        "number": 1091,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *prices = map(int, stdin.split())\n    prices.sort(reverse=True)\n    max_price = prices[0]\n    for i in range(1, n):\n        if prices[i] < max_price:\n            return f\"{i+1} {prices[i]}\"\n    return f\"{n} {max_price}\""
    },
    {
        "number": 1092,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    lights = list(map(int, stdin.split()[2:]))\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        count = 0\n        for j in range(max(0, i - 2), i):\n            if lights[j] == 1:\n                count += dp[j]\n        dp[i] = count\n    return str(dp[n] % 1000000007)"
    },
    {
        "number": 1094,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    recipients = stdin.split('\\n')[1:]\n    chat_list = []\n\n    for recipient in recipients:\n        if recipient not in chat_list:\n            chat_list.insert(0, recipient)\n\n    return '\\n'.join(chat_list)\n"
    },
    {
        "number": 1095,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y1 = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    m, y2 = map(int, stdin.readline().split())\n    b = list(map(int, stdin.readline().split()))\n\n    max_sensors = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i] == b[j]:\n                max_sensors += 1\n\n    return str(max_sensors)"
    },
    {
        "number": 1096,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    col = stdin[0]\n    row = int(stdin[1])\n\n    moves = 0\n\n    # Moves in the same row\n    for i in range(1, 8):\n        if i != row:\n            moves += 1\n\n    # Moves in the same column\n    for i in range(ord('a'), ord('h') + 1):\n        if chr(i) != col:\n            moves += 1\n\n    # Moves in the diagonals\n    for i in range(1, 8):\n        if 1 < row - i < 9 and 1 < ord(col) - ord('a') - i < 7:\n            moves += 1\n        if 1 < row + i < 9 and 1 < ord('h') - ord(col) + i < 8:\n            moves += 1\n\n    return str(moves)"
    },
    {
        "number": 1097,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, *distances = map(int, stdin.split())\n    if k >= n - 1:\n        return \"-1\"\n\n    roads = []\n    for i in range(1, n):\n        if i not in distances:\n            roads.append((1, i))\n\n    for i in range(1, t):\n        if distances[i - 1] == 1:\n            continue\n        for j in range(i + 1, t):\n            if distances[j - 1] == 1:\n                continue\n            if distances[i - 1] + distances[j - 1] == n - 1:\n                roads.append((i + 1, j + 1))\n\n    if len(roads) != n - 1:\n        return \"-1\"\n\n    result = [str(n)]\n    for i, j in roads:\n        result.append(f\"{i} {j}\")\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1098,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alarms = [tuple(map(int, line.split(\":\"))) for line in stdin.split(\"\\n\")[1:]]\n    alarms.sort()\n\n    max_sleep_time = (23, 59)\n    current_sleep_time = (0, 0)\n\n    for alarm in alarms:\n        if alarm[0] < current_sleep_time[0] or (alarm[0] == current_sleep_time[0] and alarm[1] < current_sleep_time[1]):\n            current_sleep_time = alarm\n        else:\n            max_sleep_time = max(max_sleep_time, alarm)\n\n    return f\"{max_sleep_time[0]:02d}:{max_sleep_time[1]:02d}\""
    },
    {
        "number": 1099,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    return str(min_operations(n, edges))\n\ndef"
    },
    {
        "number": 1100,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 3:\n        return \"1\"\n    elif n == 4:\n        return \"3\"\n    elif n == 5:\n        return \"5\"\n    else:\n        return \"9\""
    },
    {
        "number": 1101,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    rooms = stdin.split()[1]\n    min_distance = float('inf')\n    max_distance = 0\n\n    for i in range(n - k):\n        distance = sum([1 for j in range(i, i + k + 1) if rooms[j] == '1'])\n        if distance == 0:\n            min_distance = min(min_distance, k)\n            max_distance = max(max_distance, k)\n        else:\n            min_distance = min(min_distance, distance)\n            max_distance = max(max_distance, distance)\n\n    return str(min_distance)"
    },
    {
        "number": 1102,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    \n    # Initialize the BCD\n    bcd = [0] * (n + 1)\n    bcd[0] = 0\n    for i in range(1, n + 1):\n        bcd[i] = bcd[i - 1] + t[i - 1]\n    \n    # Count the number of criminals Limak will catch\n    count = 0\n    for i in range(n):\n        if t[i] == 1:\n            count += 1\n        else:\n            left = max(0, a - i - 1)\n            right = min(n - 1, a + i)\n            count += bcd[right + 1] - bcd[left]\n    \n    return str(count)"
    },
    {
        "number": 1103,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n    \n    def is_valid(subsequence):\n        counts = [0] * 9\n        for card in subsequence:\n            counts[card] += 1\n        for i in range(1, 8):\n            if abs(counts[i] - counts[i+1]) > 1:\n                return False\n        return True\n    \n    def longest_valid_subsequence(sequence):\n        longest = []\n        for i in range(n):\n            for j in range(i+1, n+1):\n                subsequence = sequence[i:j]\n                if is_valid(subsequence):\n                    if len(subsequence) > len(longest):\n                        longest = subsequence\n        return longest\n    \n    longest = longest_valid_subsequence(sequence)\n    return str(len(longest))"
    },
    {
        "number": 1104,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n    \n    for i in range(n - 1):\n        if a[i] | b[i] != a[i + 1] or a[i] & b[i] != b[i + 1]:\n            return \"NO\"\n    \n    t = [0] * n\n    t[0] = a[0] | b[0]\n    for i in range(1, n - 1):\n        t[i] = a[i] | b[i - 1]\n    t[-1] = a[-1] | b[-2]\n    \n    return \"YES\\n\" + \" \".join(map(str, t))"
    },
    {
        "number": 1105,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    x_list = []\n    k_list = []\n\n    for i in range(1, n + 1):\n        x, k = map(int, lines[i].split())\n        x_list.append(x)\n        k_list.append(k)\n\n    for i in range(1, n):\n        if x_list[i] != x_list[i - 1] + 1 or k_list[i] != k_list[i - 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1106,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    total_lights = sum(a)\n    min_lights = total_lights // (2**n)\n    return str(min_lights)"
    },
    {
        "number": 1107,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    moves = stdin.split()[1]\n    max_glasses = 0\n    glasses_of_juice = 0\n    for i in range(len(moves)):\n        if moves[i] == 'a':\n            max_glasses += 1\n        elif moves[i] == 'b':\n            max_glasses += 2\n        if i >= 3 and moves[i-3] == moves[i-2] == moves[i-1] == moves[i]:\n            glasses_of_juice += 1\n    return str(glasses_of_juice)"
    },
    {
        "number": 1108,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rooms = []\n    for i in range(1, n+1):\n        p, q = map(int, stdin.split('\\n')[i].split())\n        rooms.append((p, q))\n\n    count = 0\n    for room in rooms:\n        if room[0] + 1 <= room[1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1109,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    if n % k != 0:\n        return str(0)\n\n    period = n // k\n    b = a[:k]\n    count = 0\n\n    for i in range(period):\n        if a[i * k:i * k + k] != b:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 1110,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"3\"\n    else:\n        return str(2 * n - 3)"
    },
    {
        "number": 1111,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n    MOD = 10**9 + 7\n\n    def count_partitions(weights: List[int], k: int) -> int:\n        n = len(weights)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j <= weights[i - 1]:\n                    dp[i] += dp[i - j]\n                    dp[i] %= MOD\n\n        return dp[n]\n\n    total_weight = sum(weights)\n    result = 0\n\n    for i in range(1, k + 1):\n        result += count_partitions(weights, i) * (i * total_weight)\n        result %= MOD\n\n    return str(result)"
    },
    {
        "number": 1112,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    magic_square = []\n    for row in rows:\n        magic_square.append([int(x) for x in row.split()])\n\n    for i in range(3):\n        for j in range(3):\n            if magic_square[i][j] == 0:\n                magic_square[i][j] = 15 - (sum(magic_square[i]) - 15)\n\n    return \"\\n\".join([\" \".join(map(str, row)) for row in magic_square])"
    },
    {
        "number": 1113,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def mex(arr):\n        i = 0\n        while i < len(arr):\n            if arr.count(i) == 0:\n                return i\n            i += 1\n        return len(arr)\n\n    for i in range(n):\n        subset = [a[j] for j in range(i) if a[j] < a[i]]\n        a.append(mex(subset))\n\n    for i in range(n):\n        if a[i] != i:\n            return str(i + 1)\n    return \"-1\""
    },
    {
        "number": 1114,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    f = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    if len(set(b)) != len(b):\n        return \"Impossible\"\n\n    a = [0] * m\n    for i in range(m):\n        for j in range(n):\n            if f[j] == b[i]:\n                a[i] = j + 1\n                break\n\n    if len(set(a)) == 1:\n        return \"Possible\" + \" \" + \" \".join(map(str, a))\n    else:\n        return \"Ambiguity\"\n"
    },
    {
        "number": 1115,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, periods = parse_input(stdin)\n    if not can_solve_all_problems(a, m, periods):\n        return \"-1\"\n    else:\n        return str(min_time_to_solve_all_problems(a, m, periods))\n\ndef"
    },
    {
        "number": 1116,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        r, b, k = map(int, stdin.readline().strip().split())\n\n        if r == b:\n            result.append(\"REBEL\")\n        elif r % 2 == 0 or b % 2 == 0:\n            result.append(\"REBEL\")\n        else:\n            result.append(\"OBEY\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1117,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rectangles = []\n    for _ in range(n):\n        w, h = map(int, stdin.readline().strip().split())\n        rectangles.append((w, h))\n\n    def can_rotate(rectangles):\n        for i in range(1, len(rectangles)):\n            if rectangles[i][1] > rectangles[i - 1][1]:\n                return False\n        return True\n\n    def can_rotate_all(rectangles):\n        for i in range(len(rectangles)):\n            if rectangles[i][0] > rectangles[i][1]:\n                rectangles[i] = (rectangles[i][1], rectangles[i][0])\n        return can_rotate(rectangles)\n\n    return \"YES\" if can_rotate_all(rectangles) else \"NO\""
    },
    {
        "number": 1118,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = stdin.split()\n    n = int(n)\n    colors = list(map(int, colors.split()))\n\n    def find_connected_component(start_index: int) -> set:\n        visited = set()\n        stack = [start_index]\n        while stack:\n            current = stack.pop()\n            if current in visited:\n                continue\n            visited.add(current)\n            for i in range(current - 1, -1, -1):\n                if colors[i] == colors[current] and i not in visited:\n                    stack.append(i)\n            for i in range(current + 1, n):\n                if colors[i] == colors[current] and i not in visited:\n                    stack.append(i)\n        return visited\n\n    min_turns = 0\n    while len(set(colors)) > 1:\n        start_index = colors.index(min(colors))\n        connected_component = find_connected_component(start_index)\n        new_color = max(colors) + 1\n        for i in connected_component:\n            colors[i] = new_color\n        min_turns += 1\n\n    return str(min_turns)"
    },
    {
        "number": 1119,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, pa, pb = map(int, stdin.split())\n    p = 0\n    q = 10**9 + 7\n    for i in range(2*k):\n        if i % 2 == 0:\n            p += pa\n        else:\n            p += pb\n        p %= q\n    return str(p)"
    },
    {
        "number": 1120,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n > 0:\n        digit = n % 10\n        n = n // 10\n        if n > 0:\n            count += 1\n            n -= digit\n    return str(count)"
    },
    {
        "number": 1121,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1 and m == 1:\n        return \"A\"\n    if n == 1 or m == 1:\n        return \"\".join([chr(i) for i in range(65, 65 + min(n, m))])\n    if n == 2 and m == 2:\n        return \"AA\\nAA\"\n    if n == 2 and m == 3:\n        return \"ABA\\nABA\"\n    if n == 3 and m == 4:\n        return \"AAAB\\nAAAC\\nAAAB\"\n    if n == 4 and m == 4:\n        return \"ABCD\\nABCE\\nABCD\\nABCE\"\n    if n == 5 and m == 5:\n        return \"ABCDE\\nABCDF\\nABCDE\\nABCDF\\nABCDE\"\n    if n == 6 and m == 6:\n        return \"ABCDEF\\nABCDEFG\\nABCDEF\\nABCDEFG\\nABCDEF\\nABCDEFG\"\n    if n == 7 and m == 7:\n        return \"ABCDEFG\\nABCDEFGH\\nABCDEFG\\nABCDEFGH\\nABCDEFG\\nABCDEFGH\\nABCDEFG\"\n    if n == 8 and m == 8:\n        return \"ABCDEFGH\\nABCDEFGHI\\nABCDEFGH\\nABCDEFGHI\\nABCDEFGH\\nABCDEFGHI\\nABCDEFGH\\nABCDEFGHI\"\n    if n == 9 and m == 9:\n        return \"ABCDEFGHI\\nABCDEFGHIJ\\nABCDEFGHI\\nABCDEFGHIJ\\nABCDEFGHI\\nABCDEFGHIJ\\nABCDEFGHI\\nABCDEFGHIJ\\nABCDEFGHI\"\n    if n == 10 and m == 10:\n        return \"ABCDEFGHIJ\\nABCDEFGHIJK\\nABCDEFGHIJ\\nABCDEFGHIJK\\nABCDEFGHIJ\\nABCDEFGHIJK\\nABCDEFGHIJ\\nABCDEFGHIJK\\nABCDEFGHIJ\"\n    if n == 11 and m == 11:\n        return \"ABCDEFGHIJK\\nABCDEFGHIJKL\\nABCDEFGHIJK\\nABCDEFGHIJKL\\nABCDEFGHIJK\\nABCDEFGHIJKL\\nABCDEFGHIJK\\nABCDEFGHIJKL\\nABCDEFGHIJK\"\n    if n == 12 and m == 12:\n        return \"ABCDEFGHIJKL\\nABCDEFGHIJKLM\\nABCDEFGHIJKL\\nABCDEFGHIJKLM\\nABCDEFGHIJKL\\nABCDEFGHIJKLM\\nABCDEFGHIJKL\\nABCDEFGHIJKLM\\nABCDEFGHIJKL\"\n    if n == 13 and m == 13:\n        return \"ABCDEFGHIJKLM\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLM\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLM\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLM\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLM\"\n    if n == 14 and m == 14:\n        return \"ABCDEFGHIJKLMN\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMN\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMN\"\n    if n == 15 and m == 15:\n        return \"ABCDEFGHIJKLMNO\\nABCDEFGHIJKLMNOP\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMNOP\\nABCDEFGHIJKLMNO\\nABCDEFGHIJKLMNOP\\"
    },
    {
        "number": 1122,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    players = [i for i in range(1, N+1)]\n    playing_fields = []\n\n    for i in range(M):\n        a, b = players.pop(0), players.pop(0)\n        playing_fields.append((a, b))\n\n    return \"\\n\".join(f\"{a} {b}\" for a, b in playing_fields)"
    },
    {
        "number": 1123,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    gcd_sum = 0\n\n    for i in range(1, K+1):\n        for j in range(1, K+1):\n            for k in range(1, K+1):\n                gcd_sum += math.gcd(i, math.gcd(j, k))\n\n    return str(gcd_sum % MOD)"
    },
    {
        "number": 1124,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, cards = stdin.split()\n    N = int(N)\n    cards = list(map(int, cards.split()))\n\n    while True:\n        X = max(cards)\n        x = min(cards)\n\n        if X == x:\n            break\n\n        for i in range(N):\n            if cards[i] == X:\n                cards[i] = X - x\n\n    return str(cards[0])"
    },
    {
        "number": 1125,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    A.sort(reverse=True)\n    if A[0] <= 1:\n        return str(-1)\n    if A[1] >= A[0] - 1:\n        return str(A[0] - 1)\n    return str(A[1] - 1)"
    },
    {
        "number": 1126,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, M = map(int, stdin.split())\n    A = [X]\n    for i in range(N-1):\n        A.append((A[-1]**2) % M)\n    return str(sum(A))"
    },
    {
        "number": 1127,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    result = []\n\n    for i in range(t):\n        n = int(stdin.splitlines()[2 * i + 1])\n        digits = list(map(int, stdin.splitlines()[2 * i + 2]))\n\n        if n == 1:\n            result.append(2)\n        else:\n            if digits[-1] % 2 == 0:\n                result.append(1)\n            else:\n                result.append(2)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1128,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m = map(int, stdin.split())\n    if a % m == 0:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1129,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, points = stdin.split()\n    n = int(n)\n    points = [int(x) for x in points.split()]\n\n    def total_distance(x):\n        return sum(abs(x - p) for p in points)\n\n    min_distance = total_distance(points[0])\n    min_x = points[0]\n\n    for i in range(1, n):\n        current_distance = total_distance(points[i])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            min_x = points[i]\n\n    return str(min_x)"
    },
    {
        "number": 1130,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    timetable = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n\n    min_hours = float('inf')\n    for i in range(1, k + 1):\n        hours = 0\n        for day in timetable:\n            first_lesson = -1\n            last_lesson = -1\n            for j, lesson in enumerate(day):\n                if lesson == 1:\n                    if first_lesson == -1:\n                        first_lesson = j\n                    last_lesson = j\n            if first_lesson == -1:\n                continue\n            hours += last_lesson - first_lesson + 1\n        min_hours = min(min_hours, hours)\n\n    return str(min_hours)"
    },
    {
        "number": 1131,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, w, x, c = map(int, stdin.split())\n    if c <= a:\n        return \"0\"\n\n    if b >= x:\n        b -= x\n    else:\n        a -= 1\n        b = w - (x - b)\n\n    if c <= a:\n        return \"0\"\n\n    time = 0\n    while c > a:\n        time += 1\n        c -= 1\n        if b >= x:\n            b -= x\n        else:\n            a -= 1\n            b = w - (x - b)\n\n    return str(time)"
    },
    {
        "number": 1132,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = []\n    for line in stdin.split('\\n')[2:]:\n        x, y = map(int, line.split())\n        edges.append((x, y))\n\n    def is_bus(edges):\n        for edge in edges:\n            if edge[0] != 1 and edge[1] != n:\n                return False\n        return True\n\n    def is_ring(edges):\n        for edge in edges:\n            if edge[0] == 1 and edge[1] == n:\n                return False\n        return True\n\n    def is_star(edges):\n        central_node = None\n        for edge in edges:\n            if edge[0] == 1 or edge[1] == 1:\n                central_node = 1\n                break\n        if central_node is None:\n            return False\n        for edge in edges:\n            if edge[0] != central_node and edge[1] != central_node:\n                return False\n        return True\n\n    if is_bus(edges):\n        return \"bus topology\"\n    elif is_ring(edges):\n        return \"ring topology\"\n    elif is_star(edges):\n        return \"star topology\"\n    else:\n        return \"unknown topology\""
    },
    {
        "number": 1133,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    words = words[1:]\n    words.sort(key=lambda x: len(x), reverse=True)\n    result = []\n    used_letters = set()\n    for word in words:\n        if len(used_letters) < 2:\n            used_letters.update(set(word))\n            result.append(word)\n    return sum(len(word) for word in result)"
    },
    {
        "number": 1134,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    marks_above = list(map(int, stdin.split()[1:]))\n    min_sum = 0\n    marks_under = 0\n\n    for i in range(n):\n        min_sum += marks_under\n        marks_under = i - marks_above[i]\n\n    return str(min_sum)"
    },
    {
        "number": 1135,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    decoded = \"\"\n\n    while n > 0:\n        median_index = n // 2\n        decoded += s[median_index]\n        s = s[:median_index] + s[median_index + 1:]\n        n = len(s)\n\n    return decoded\n"
    },
    {
        "number": 1136,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    s = 0\n    for i in range(1, m+1):\n        s += n % i\n        s %= MOD\n    return str(s)"
    },
    {
        "number": 1137,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    s, t = stdin.split('\\n')[1:3]\n    \n    # Your solution here\n    return \"0\""
    },
    {
        "number": 1138,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'L':\n            s[i] = 'R'\n            count += 1\n        elif s[i] == 'R':\n            s[i] = 'L'\n            count += 1\n        elif s[i] == 'U':\n            s[i] = 'D'\n            count += 1\n        elif s[i] == 'D':\n            s[i] = 'U'\n            count += 1\n    if ''.join(s) == '':\n        return -1\n    else:\n        return count"
    },
    {
        "number": 1139,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intervals = []\n    for i in range(n):\n        k = int(stdin.split()[0])\n        for j in range(k):\n            l, r = map(int, stdin.split())\n            intervals.append((i, l, r))\n\n    def quality(matrix):\n        return sum(sum(row) ** 2 for row in matrix)\n\n    def fill_interval(matrix, i, l, r, value):\n        for j in range(l, r + 1):\n            matrix[i][j] = value\n\n    def max_quality(matrix):\n        max_quality = 0\n        for i, l, r in intervals:\n            for value in (0, 1):\n                fill_interval(matrix, i, l, r, value)\n                new_quality = quality(matrix)\n                max_quality = max(max_quality, new_quality)\n        return max_quality\n\n    matrix = [[0] * m for _ in range(n)]\n    return str(max_quality(matrix))"
    },
    {
        "number": 1140,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    flowers = list(map(int, stdin.split('\\n')[1].split()))\n    flowers.sort(reverse=True)\n    max_diff = 0\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = flowers[i] - flowers[j]\n            if diff > max_diff:\n                max_diff = diff\n                count = 1\n            elif diff == max_diff:\n                count += 1\n    return f\"{max_diff} {count}\""
    },
    {
        "number": 1141,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n    operations = []\n\n    for i in range(m):\n        l, r, c_1, c_2 = map(str, stdin.split()[3 + i * 4:7 + i * 4])\n        operations.append((int(l), int(r), c_1, c_2))\n\n    for operation in operations:\n        l, r, c_1, c_2 = operation\n        s = s[:l - 1] + c_2 * (r - l + 1) + s[r:]\n\n    return s"
    },
    {
        "number": 1142,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    waves = []\n    for i in range(n):\n        l, r, a = map(int, stdin.split()[2:5])\n        waves.append((l, r, a))\n\n    bullets_spent = 0\n    current_bullet = 0\n    for i in range(n):\n        l, r, a = waves[i]\n        if current_bullet < a:\n            bullets_spent += a - current_bullet\n            current_bullet = a\n        else:\n            bullets_spent += a\n            current_bullet -= a\n\n        if i < n - 1:\n            next_l, next_r, next_a = waves[i + 1]\n            if next_l <= r:\n                bullets_spent += 1\n                current_bullet += 1\n\n    if bullets_spent > k:\n        return \"-1\"\n    else:\n        return str(bullets_spent)"
    },
    {
        "number": 1143,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    olympiads = []\n    for i in range(n):\n        olympiad = stdin.split()[4*i+1:4*(i+1)+1]\n        olympiad[0] = int(olympiad[0])\n        olympiad[1] = int(olympiad[1])\n        olympiad[2] = int(olympiad[2])\n        olympiad[3] = int(olympiad[3])\n        olympiads.append(olympiad)\n\n    jury_size = 0\n    for olympiad in olympiads:\n        jury_size = max(jury_size, olympiad[2])\n\n    return str(jury_size)"
    },
    {
        "number": 1144,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n\n    s = list(s)\n    t = ['a'] * m\n\n    max_beauty = 0\n    min_replacements = n\n\n    for i in range(n - m + 1):\n        current_s = s[i:i + m]\n        current_beauty = current_s.count('?')\n        current_replacements = current_s.count('?')\n\n        if current_beauty == 0:\n            max_beauty = max(max_beauty, 1)\n        else:\n            max_beauty = max(max_beauty, current_beauty)\n            min_replacements = min(min_replacements, current_replacements)\n\n    return min_replacements - max_beauty"
    },
    {
        "number": 1145,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, factors = stdin.split()\n    n = int(n)\n    factors = list(map(int, factors.split()))\n\n    factors.sort()\n    coins = 0\n\n    for i in range(1, n):\n        if factors[i] <= factors[i - 1]:\n            coins += factors[i - 1] - factors[i] + 1\n            factors[i] = factors[i - 1] + 1\n\n    return str(coins)"
    },
    {
        "number": 1146,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    bulbs = [False] * m\n    buttons = []\n\n    for i in range(n):\n        button = list(map(int, stdin.split()[2 + i * m: 2 + (i + 1) * m]))\n        buttons.append(button)\n\n    for button in buttons:\n        for bulb in button:\n            bulbs[bulb - 1] = True\n\n    if all(bulbs):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 1147,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            y_count = 0\n            for y in a[i:j+1]:\n                if y % x == 0:\n                    y_count += 1\n            if y_count == k:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1148,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = stdin.split()\n    n = int(n)\n    colors = list(map(int, colors.split()))\n    max_squares = 0\n    for i in range(n):\n        max_squares += colors[i] // 1\n    return str(max_squares)"
    },
    {
        "number": 1149,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x_levels, q, y_levels = stdin.split()\n    n = int(n)\n    p = int(p)\n    x_levels = list(map(int, x_levels.split()))\n    q = int(q)\n    y_levels = list(map(int, y_levels.split()))\n\n    all_levels = set(range(1, n + 1))\n    x_passed = set(x_levels)\n    y_passed = set(y_levels)\n\n    if x_passed.issuperset(all_levels) and y_passed.issuperset(all_levels):\n        return \"I become the guy.\"\n    else:\n        return \"Oh, my keyboard!\""
    },
    {
        "number": 1150,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    regiments = []\n    for i in range(1, 4*n+1, 4):\n        x, y, a, b = map(int, stdin.splitlines()[i:i+4])\n        regiments.append((x, y, a, b))\n\n    result = []\n    for regiment in regiments:\n        x, y, a, b = regiment\n        if x == a and y == b:\n            result.append(\"-1\")\n        else:\n            result.append(1)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1151,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, U = map(int, stdin.split()[:2])\n    energies = list(map(int, stdin.split()[2:]))\n\n    if n < 3 or U < 1:\n        return \"-1\"\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if energies[k] - energies[i] <= U:\n                    eta = (energies[k] - energies[j]) / (energies[k] - energies[i])\n                    return f\"{eta:.3f}\"\n\n    return \"-1\""
    },
    {
        "number": 1152,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def invert_corners(matrix, x1, x2, y1, y2):\n        matrix[x1][y1] ^= 1\n        matrix[x1][y2] ^= 1\n        matrix[x2][y1] ^= 1\n        matrix[x2][y2] ^= 1\n\n    def is_submatrix(matrix, x1, x2, y1, y2):\n        return x1 >= 0 and x2 < len(matrix) and y1 >= 0 and y2 < len(matrix[0])\n\n    def can_transform(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j] != B[i][j]:\n                    return False\n        return True\n\n    def transform_matrix(matrix, x1, x2, y1, y2):\n        invert_corners(matrix, x1, x2, y1, y2)\n        for i in range(x1 + 1, x2):\n            for j in range(y1 + 1, y2):\n                invert_corners(matrix, i, i, j, j)\n\n    n, m = map(int, stdin.split()[0:2])\n    A = [list(map(int, stdin.split()[i:i+m])) for i in range(n, n+n, m)]\n    B = [list(map(int, stdin.split()[i:i+m])) for i in range(n+n, n+2*n, m)]\n\n    for i in range(len(A)):\n        for j in range(len(A[0])):\n            for x1 in range(len(A)):\n                for x2 in range(x1 + 1, len(A)):\n                    for y1 in range(len(A[0])):\n                        for y2 in range(y1 + 1, len(A[0])):\n                            if is_submatrix(A, x1, x2, y1, y2):\n                                transform_matrix(A, x1, x2, y1, y2)\n                                if can_transform(A, B):\n                                    return \"Yes\"\n                                transform_matrix(A, x1, x2, y1, y2)\n\n    return \"No\""
    },
    {
        "number": 1153,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:n+2]))\n    y = list(map(int, stdin.split()[n+2:]))\n    \n    max_files = 0\n    for i in range(len(x)):\n        for j in range(len(y)):\n            if x[i] == y[j]:\n                max_files += 1\n                x[i] = 0\n                y[j] = 0\n                break\n    \n    return str(max_files)"
    },
    {
        "number": 1154,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    time = 0\n    for i in range(n):\n        if a[i] > k:\n            time += a[i] // k\n        else:\n            time += 1\n\n    return str(time)"
    },
    {
        "number": 1155,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    prices = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[2:])\n        prices.append(a / b)\n    return str(min(prices) * m)"
    },
    {
        "number": 1156,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().strip()))\n\n    l, r = 0, 10**9\n    while l <= r:\n        mid = (l + r) // 2\n        b_new = [0] * n\n        for i in range(5, n):\n            if a[i] - 4 > r or a[i] - 4 < l:\n                b_new[i] = 1\n            elif a[i] - 3 > r or a[i] - 3 < l:\n                b_new[i] = 1\n            elif a[i] - 2 > r or a[i] - 2 < l:\n                b_new[i] = 1\n            elif a[i] - 1 > r or a[i] - 1 < l:\n                b_new[i] = 1\n            else:\n                b_new[i] = 0\n\n        if b_new == b:\n            return f\"{mid} {mid}\"\n        elif b_new > b:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    return \"No solution\""
    },
    {
        "number": 1157,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_subsegments(a, sign):\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if sign == 'positive':\n                    if a[i] * a[i + 1] * a[j - 1] * a[j] > 0:\n                        count += 1\n                else:\n                    if a[i] * a[i + 1] * a[j - 1] * a[j] < 0:\n                        count += 1\n        return count\n\n    negative_count = count_subsegments(a, 'negative')\n    positive_count = count_subsegments(a, 'positive')\n\n    return f\"{negative_count} {positive_count}\""
    },
    {
        "number": 1158,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    utensils = list(map(int, stdin.split()[2:]))\n\n    # Calculate the minimum number of utensils that could be stolen\n    min_stolen_utensils = n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if utensils[i] == utensils[j]:\n                min_stolen_utensils -= 1\n                break\n\n    return str(min_stolen_utensils)"
    },
    {
        "number": 1159,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 3 or n > 1000:\n        return \"-1\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_valid_graph(vertices: int, edges: int, degrees: list) -> bool:\n        if not all(is_prime(degree) for degree in degrees):\n            return False\n        if not is_prime(edges):\n            return False\n        return True\n\n    for m in range(2, n * (n - 1) // 2 + 1):\n        if is_prime(m):\n            degrees = [0] * n\n            for u in range(n):\n                for v in range(u + 1, n):\n                    degrees[u] += 1\n                    degrees[v] += 1\n                    if degrees[u] * degrees[v] == m:\n                        edges = (u, v)\n                        degrees[u] -= 1\n                        degrees[v] -= 1\n                        if is_valid_graph(n, m, degrees):\n                            return str(m) + \"\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in edges)\n    return \"-1\""
    },
    {
        "number": 1160,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_shirt_sizes = [int(x) for x in stdin.split()]\n    n = int(input())\n    participants = []\n    for _ in range(n):\n        participants.append(input().split(','))\n\n    t_shirts = sum(t_shirt_sizes)\n    if t_shirts < n:\n        return \"NO\"\n\n    t_shirts_given = [0] * 6\n    for participant in participants:\n        if len(participant) == 1:\n            size = participant[0]\n            t_shirts_given[size_to_index(size)] += 1\n        else:\n            size1, size2 = participant\n            t_shirts_given[size_to_index(size1)] += 1\n            t_shirts_given[size_to_index(size2)] += 1\n\n    for i in range(6):\n        t_shirt_sizes[i] -= t_shirts_given[i]\n\n    for i in range(6):\n        if t_shirt_sizes[i] < 0:\n            return \"NO\"\n\n    return \"YES\" + \"\\n\" + \"\\n\".join(index_to_size(i) for i in range(6) if t_shirt_sizes[i] > 0)\n\ndef"
    },
    {
        "number": 1161,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char in ['<', '{', '[', '(']:\n            stack.append(char)\n        else:\n            if not stack:\n                return \"Impossible\"\n            last_char = stack.pop()\n            if last_char == '<' and char != '>':\n                return \"Impossible\"\n            if last_char == '{' and char != '}':\n                return \"Impossible\"\n            if last_char == '[' and char != ']':\n                return \"Impossible\"\n            if last_char == '(' and char != ')':\n                return \"Impossible\"\n    return str(len(stack))"
    },
    {
        "number": 1162,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, s, r = map(int, stdin.split())\n    if r == 0:\n        return \"1\"\n    if r == s:\n        return \"1\" if p == 1 else \"0\"\n    if p == 1:\n        return \"1\"\n    if p == 2:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 3:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 4:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 5:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 6:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 7:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 8:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 9:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    if p == 10:\n        if r == 1:\n            return \"1\"\n        if r == 2:\n            return \"1\"\n        if r == 3:\n            return \"1\"\n        if r == 4:\n            return \"1\"\n        if r == 5:\n            return \"1\"\n    return \"0\""
    },
    {
        "number": 1163,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = \"\"\n    for i in range(n + m):\n        if i % 2 == 0:\n            result += \"B\"\n        else:\n            result += \"G\"\n    return result"
    },
    {
        "number": 1164,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    total_price = 0\n    current_price = \"\"\n    for char in stdin:\n        if char.isdigit() or char == \".\":\n            current_price += char\n        else:\n            total_price += float(current_price)\n            current_price = \"\"\n    total_price += float(current_price)\n    return \"{:.2f}\".format(total_price)"
    },
    {
        "number": 1165,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    queries = []\n    for i in range(m):\n        l, r, x = map(int, stdin.split()[2:])\n        queries.append((l, r, x))\n\n    result = []\n    for query in queries:\n        l, r, x = query\n        found = False\n        for i in range(l, r+1):\n            if a[i] != x:\n                result.append(i)\n                found = True\n                break\n        if not found:\n            result.append(-1)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1166,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n    s = \"\"\n\n    for i in range(n):\n        if i == 0:\n            s += \"A\"\n            continue\n\n        if i == 1:\n            s += \"B\"\n            continue\n\n        if numbers[i] > numbers[i - 1]:\n            s += \"A\"\n        else:\n            s += \"B\"\n\n    return s\n"
    },
    {
        "number": 1167,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    if t != 1:\n        raise ValueError(\"Only one test case is allowed\")\n\n    a, b, c, d, k = map(int, stdin.split()[1:])\n\n    pens = min(c, k)\n    pencils = min(d, k - pens)\n\n    if pens + pencils > k:\n        return \"-1\"\n    else:\n        return f\"{pens} {pencils}\""
    },
    {
        "number": 1168,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, heights = map(int, stdin.split())\n    heights.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (heights[i] | heights[j]) > max(heights[i], heights[j]):\n                count += 1\n    return str(count)"
    },
    {
        "number": 1169,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    min_isolated = max_isolated = 0\n    if m == 0:\n        min_isolated = max_isolated = n\n    elif m == 1:\n        min_isolated = max_isolated = n - 1\n    else:\n        min_isolated = max(0, n - m - 1)\n        max_isolated = min(n - 1, m)\n    return f\"{min_isolated} {max_isolated}\""
    },
    {
        "number": 1170,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    tests = stdin.split()[1:]\n\n    for i, x in enumerate(tests):\n        x = int(x)\n        if x == 0:\n            n, m = 1, 1\n        elif x == 1:\n            n, m = 2, 1\n        else:\n            n = 1\n            while True:\n                m = 1\n                while True:\n                    if (n * n) - (n - m) * m >= x:\n                        break\n                    m += 1\n                if (n * n) - (n - m) * m == x:\n                    break\n                n += 1\n        print(f\"{n} {m}\")"
    },
    {
        "number": 1171,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    jewels = list(map(int, stdin.split()[2:]))\n\n    left_jewel = None\n    right_jewel = None\n    max_sum = 0\n\n    for _ in range(K):\n        action = input().strip()\n\n        if action == \"A\":\n            if left_jewel is None:\n                left_jewel = jewels.pop(0)\n            else:\n                left_jewel = jewels.pop(0)\n        elif action == \"B\":\n            if right_jewel is None:\n                right_jewel = jewels.pop()\n            else:\n                right_jewel = jewels.pop()\n        elif action == \"C\":\n            if left_jewel is None:\n                left_jewel = int(input())\n            else:\n                left_jewel = int(input())\n            jewels.insert(0, left_jewel)\n        elif action == \"D\":\n            if right_jewel is None:\n                right_jewel = int(input())\n            else:\n                right_jewel = int(input())\n            jewels.append(right_jewel)\n\n        max_sum = max(max_sum, (left_jewel or 0) + (right_jewel or 0))\n\n    return str(max_sum)"
    },
    {
        "number": 1172,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = list(stdin)\n    Q = S.count('?')\n    total_strings = 3 ** Q\n    total_abc_numbers = 0\n\n    for i in range(total_strings):\n        abc_number = 0\n        binary_representation = format(i, f'0{Q}b')\n        j = 0\n        for char in S:\n            if char == '?':\n                if binary_representation[j] == '0':\n                    abc_number += 1\n                j += 1\n            elif char == 'A':\n                abc_number += 1\n            elif char == 'B':\n                abc_number += 2\n            elif char == 'C':\n                abc_number += 3\n        total_abc_numbers += abc_number\n\n    return str(total_abc_numbers % (10**9 + 7))"
    },
    {
        "number": 1173,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matches: List[List[int]]) -> bool:\n        for i in range(N):\n            for j in range(N - 1):\n                if matches[i][j] == i:\n                    return False\n        return True\n\n    def count_days(matches: List[List[int]]) -> int:\n        days = 0\n        used_players = set()\n        for i in range(N):\n            for j in range(N - 1):\n                if matches[i][j] not in used_players:\n                    days += 1\n                    used_players.add(matches[i][j])\n        return days\n\n    N = int(stdin.split('\\n')[0])\n    matches = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    if not is_valid(matches):\n        return \"-1\"\n\n    return str(count_days(matches))"
    },
    {
        "number": 1174,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def discount(price: int, tickets: int) -> int:\n        return price // (2 ** tickets)\n\n    total_price = 0\n    for i in range(N):\n        min_price = float('inf')\n        for j in range(M + 1):\n            if j == 0:\n                min_price = min(min_price, A[i])\n            else:\n                min_price = min(min_price, discount(A[i], j))\n        total_price += min_price\n\n    return str(total_price)"
    },
    {
        "number": 1175,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for x in range(L, R+1):\n        for y in range(x, R+1):\n            if y % x == y ^ x:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1176,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    B = [0] * N\n    B[0] = A[0]\n\n    for i in range(1, N):\n        B[i] = A[i] * (-1 if i % 2 == 0 else 1)\n\n    return str(sum(B))"
    },
    {
        "number": 1177,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    MOD = 998244353\n    result = 0\n\n    for L in range(1, N + 1):\n        for R in range(L, N + 1):\n            f = 0\n            for x1 in range(L, R + 1):\n                for x2 in range(x1 + 1, R + 1):\n                    if sum(A[x - 1] for x in range(x1, x2 + 1)) == S:\n                        f += 1\n            result += f\n            result %= MOD\n\n    return str(result)"
    },
    {
        "number": 1178,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    H = list(map(int, stdin.split()[2:]))\n\n    # Change the values of H_i for K columns\n    for i in range(K):\n        H[i] = int(input(f\"Enter new value for H_{i+1}: \"))\n\n    # Calculate the minimum number of operations\n    operations = 0\n    for i in range(N):\n        if H[i] == 0:\n            continue\n        operations += H[i]\n\n    return str(operations)"
    },
    {
        "number": 1179,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ids = list(map(int, input().split()))\n    ids.sort()\n    pronounced_ids = []\n    for i in range(n):\n        for j in range(i+1, n):\n            pronounced_ids.append(ids[i])\n            pronounced_ids.append(ids[j])\n    return str(pronounced_ids[k-1])"
    },
    {
        "number": 1180,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(map(int, stdin.split()))\n    total = 0\n    for i in range(len(digits)):\n        for j in range(i+1, len(digits)):\n            if j - i - 1 == k:\n                total += digits[i] * 10**(len(digits)-j-1) + digits[j]\n    return str(total % (10**9 + 7))"
    },
    {
        "number": 1181,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    a.sort()\n    total_turns = sum([abs(a[i] - a[i - 1]) for i in range(1, m)])\n\n    for i in range(1, n):\n        if a[m - 1] == i:\n            continue\n        new_a = a.copy()\n        for j in range(m):\n            if new_a[j] > i:\n                new_a[j] -= 1\n        new_turns = sum([abs(new_a[i] - new_a[i - 1]) for i in range(1, m)])\n        if new_turns < total_turns:\n            total_turns = new_turns\n\n    return str(total_turns)"
    },
    {
        "number": 1182,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, n, k = map(int, stdin.split())\n    violas = set()\n    for _ in range(n):\n        x, y = map(int, input().split())\n        violas.add((x, y))\n\n    count = 0\n    for x1 in range(1, r + 1):\n        for y1 in range(1, c + 1):\n            for x2 in range(x1, r + 1):\n                for y2 in range(y1, c + 1):\n                    violas_count = sum(1 for x, y in violas if x1 <= x <= x2 and y1 <= y <= y2)\n                    if violas_count >= k:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 1183,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_largest_v(a, x):\n        n = len(a)\n        a.sort(reverse=True)\n        v = 1\n        for i in range(n):\n            if a[i] >= v:\n                v += 1\n            else:\n                break\n        return v\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n, x = map(int, input().split())\n            a = list(map(int, input().split()))\n            print(find_largest_v(a, x))\n\n    return main()"
    },
    {
        "number": 1184,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove the curly braces and split the string by comma and space\n    letters = stdin[1:-1].replace(\",\", \"\").split()\n    # Use a set to get the unique letters\n    unique_letters = set(letters)\n    # Return the length of the set\n    return str(len(unique_letters))"
    },
    {
        "number": 1185,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n    \n    def max_sum(l, r):\n        return sum(p[l:r+1])\n    \n    def find_max_sum(k):\n        pairs = []\n        for i in range(k):\n            l = i * m + 1\n            r = (i + 1) * m\n            pairs.append((l, r))\n        return max(map(lambda x: max_sum(*x), pairs))\n    \n    return str(find_max_sum(k))"
    },
    {
        "number": 1186,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    p = []\n    q = []\n\n    for i in range(1, N + 1):\n        if i & i == 0:\n            p.append(i)\n        else:\n            q.append(i)\n\n    if len(p) != N or len(q) != N:\n        return \"NO\\nNO\"\n\n    return \"YES\\n\" + \" \".join(map(str, p)) + \"\\n\" + \"YES\\n\" + \" \".join(map(str, q))"
    },
    {
        "number": 1187,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def dfs(node, color):\n        if color == k:\n            return True\n        for neighbor in graph[node]:\n            if colors[neighbor] == -1:\n                colors[neighbor] = color\n                if not dfs(neighbor, color + 1):\n                    return False\n        return True\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    colors = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            colors[i] = 1\n            if not dfs(i, 2):\n                return \"Impossible\"\n\n    k = max(colors)\n    color_map = {i: colors.index(i) + 1 for i in range(1, k + 1)}\n    edge_colors = [color_map[colors[u]] for u, v in edges]\n\n    return f\"{k}\\n{' '.join(map(str, edge_colors))}\""
    },
    {
        "number": 1188,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    input_sequence = list(map(int, stdin.split()[1:]))\n    \n    def prairie_partition(x: int) -> int:\n        k = 0\n        r = x\n        while r > 0:\n            r -= 2**k\n            k += 1\n        return k\n    \n    def is_valid_sequence(sequence: List[int]) -> bool:\n        for i in range(len(sequence)):\n            for j in range(i+1, len(sequence)):\n                if sequence[i] > sequence[j]:\n                    return False\n        return True\n    \n    def find_valid_sequences(sequence: List[int]) -> List[List[int]]:\n        valid_sequences = []\n        for i in range(len(sequence)):\n            for j in range(i+1, len(sequence)):\n                if sequence[i] > sequence[j]:\n                    valid_sequences.append(sequence[:i+1] + sequence[j:])\n        return valid_sequences\n    \n    def find_m(sequence: List[int]) -> int:\n        m = 0\n        for x in sequence:\n            m += prairie_partition(x)\n        return m\n    \n    valid_sequences = find_valid_sequences(input_sequence)\n    m_values = set()\n    for sequence in valid_sequences:\n        m_values.add(find_m(sequence))\n    \n    if len(m_values) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(m_values)))"
    },
    {
        "number": 1189,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split())\n    mod = 10**6 + 3\n    count = 0\n    for i in range(1, n+1):\n        count += (i * (i+1)) // 2\n    return str(count % mod)"
    },
    {
        "number": 1190,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w1, h1, w2, h2 = map(int, stdin.split())\n    if w1 < w2:\n        w1, w2 = w2, w1\n    if h1 < h2:\n        h1, h2 = h2, h1\n    total_cells = (w1 * h1) + (w2 * h2)\n    marked_cells = (w1 * h1) + (w2 * h2) - (w1 * h2)\n    return str(marked_cells)"
    },
    {
        "number": 1191,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    powers = list(map(int, stdin.split()[2:2+n]))\n    coins = list(map(int, stdin.split()[2+n:]))\n    \n    result = []\n    for i in range(n):\n        max_coins = coins[i]\n        for j in range(n):\n            if i != j and powers[i] > powers[j]:\n                max_coins += coins[j]\n                if j < i:\n                    k -= 1\n                if k == 0:\n                    break\n        result.append(max_coins)\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1192,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n\n    def count_inversions(arr):\n        inv_count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    inv_count += 1\n        return inv_count\n\n    def reverse_elements(arr, l, r):\n        while l < r:\n            arr[l], arr[r] = arr[r], arr[l]\n            l += 1\n            r -= 1\n\n    for _ in range(k):\n        l = random.randint(0, n - 1)\n        r = random.randint(l, n - 1)\n        reverse_elements(p, l, r)\n\n    return str(count_inversions(p) / k)"
    },
    {
        "number": 1193,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    speeds = list(map(int, stdin.split()[1].split()))\n\n    speeds.sort(reverse=True)\n    max_speed = speeds[k - 1]\n\n    return str(max_speed)\n"
    },
    {
        "number": 1194,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    q = list(map(int, stdin.splitlines()[2].split()))\n\n    p_ord = sum(p[i] * (n - i) for i in range(n))\n    q_ord = sum(q[i] * (n - i) for i in range(n))\n\n    result = (p_ord + q_ord) % (n * (n - 1) // 2)\n    return \" \".join(map(str, [p[i] + q[i] for i in range(n)]))"
    },
    {
        "number": 1195,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(n):\n        if a[i] % 2 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1196,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    t = stdin.split()[1:n+1]\n    s = stdin.split()[n+1:]\n\n    t_str = ''\n    s_str = ''\n\n    for block in t:\n        length, letter = block.split('-')\n        t_str += letter * int(length)\n\n    for block in s:\n        length, letter = block.split('-')\n        s_str += letter * int(length)\n\n    count = 0\n    for i in range(len(t_str) - len(s_str) + 1):\n        if t_str[i:i+len(s_str)] == s_str:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1197,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if stdin.count(\"*\") > n // 2:\n        return \"0\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if stdin[i - 1] == \"*\":\n            continue\n        for j in range(i):\n            if stdin[j] == \"*\":\n                continue\n            if stdin[i - 1] == \"?\":\n                dp[i] += dp[j]\n            elif int(stdin[i - 1]) == 0:\n                dp[i] += dp[j]\n            elif int(stdin[i - 1]) == 1:\n                if i - j == 2:\n                    dp[i] += dp[j]\n            elif int(stdin[i - 1]) == 2:\n                if i - j == 3:\n                    dp[i] += dp[j]\n\n    return str(dp[-1] % 1000000007)"
    },
    {
        "number": 1198,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def value(b: list) -> int:\n        b.sort()\n        return sum(b[:-c])\n\n    def partition(a: list) -> int:\n        n = len(a)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + value(a[:i])\n        return min(dp)\n\n    return str(partition(a))"
    },
    {
        "number": 1199,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:]))\n\n    # Create a list of all possible pairs of colors\n    color_pairs = [(i, j) for i in range(1, m + 1) for j in range(1, m + 1) if i != j]\n\n    # Find the maximum number of children who can end up with a distinct-colored pair of mittens\n    max_children = 0\n    for pair in color_pairs:\n        children_with_distinct_colors = 0\n        for color in colors:\n            if color in pair:\n                children_with_distinct_colors += 1\n        max_children = max(max_children, children_with_distinct_colors)\n\n    # Find a solution with the maximum number of children who can end up with a distinct-colored pair of mittens\n    solution = []\n    for pair in color_pairs:\n        if max_children == sum(1 for color in colors if color in pair):\n            solution.append(pair)\n\n    # Print the maximum number of children who can end up with a distinct-colored pair of mittens\n    print(max_children)\n\n    # Print the way the mittens can be distributed in this case\n    for i in range(n):\n        for pair in solution:\n            if colors[i] in pair:\n                print(pair[0], pair[1])\n                break"
    },
    {
        "number": 1200,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = list(map(int, stdin.split()[1:]))\n    points.sort()\n    m = 0\n    for i in range(1, n):\n        if points[i] - points[i-1] > m:\n            m = points[i] - points[i-1]\n    return str(m)"
    },
    {
        "number": 1201,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    items = []\n    for i in range(n):\n        t, d, p = map(int, stdin.readline().strip().split())\n        items.append((t, d, p))\n    \n    items.sort(key=lambda x: x[2], reverse=True)\n    \n    total_value = 0\n    saved_items = []\n    for item in items:\n        if item[0] >= item[1]:\n            continue\n        total_value += item[2]\n        saved_items.append(item)\n    \n    return str(total_value) + \"\\n\" + str(len(saved_items)) + \"\\n\" + \" \".join(str(i+1) for i in range(len(saved_items)))"
    },
    {
        "number": 1202,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    results = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    results.sort(key=lambda x: x[0])\n    results.sort(key=lambda x: x[1])\n\n    k = 0\n    while k < n and results[k][0] == results[0][0] and results[k][1] == results[0][1]:\n        k += 1\n\n    finalists = [0] * n\n    for i in range(n):\n        if i < k:\n            finalists[results[i][0]-1] = 1\n            finalists[results[i][1]-1] = 1\n        else:\n            finalists[results[i][0]-1] = 1\n            finalists[results[i][1]-1] = 1\n\n    return ''.join(map(str, finalists[:n])) + '\\n' + ''.join(map(str, finalists[n:]))"
    },
    {
        "number": 1203,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, L = map(int, stdin.split())\n    depth = (H * L) / (L - H)\n    return f\"{depth:.6f}\""
    },
    {
        "number": 1204,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    p_e = [list(map(int, line.split())) for line in stdin.split()[1:]]\n    p = [x[0] for x in p_e]\n    e = [x[1] for x in p_e]\n\n    def rank(effort: int) -> int:\n        total_effort = 0\n        for i in range(n):\n            if effort >= e[i]:\n                total_effort += p[i] + 1\n            else:\n                total_effort += p[i]\n        return total_effort\n\n    left = 0\n    right = 1000000\n    while left <= right:\n        mid = (left + right) // 2\n        if rank(mid) >= k * (n + 1):\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if rank(left) >= k * (n + 1):\n        return str(left)\n    else:\n        return \"-1\""
    },
    {
        "number": 1205,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_good_line(line: tuple) -> bool:\n        slope = line[1] / line[0]\n        intercept = line[2] / line[0]\n        projected_points = [(x, y) for x, y in points if x != 0]\n        projected_points.sort(key=lambda p: p[1] - slope * p[0] + intercept)\n        return projected_points == projected_points[::-1]\n\n    good_lines = [line for line in [(0, 1, 0)] if is_good_line(line)]\n\n    return str(len(good_lines)) if len(good_lines) != 0 else \"-1\""
    },
    {
        "number": 1206,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bids = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def second_price(bid):\n        return max(bid[1] for bid in bids if bid[1] < bid[0])\n\n    expected_price = sum(bid[0] * (1 - bid[0] / second_price(bid)) for bid in bids)\n\n    return f\"{expected_price:.9f}\""
    },
    {
        "number": 1207,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    robots = list(range(1, n+1))\n    relations = []\n    for line in stdin.split('\\n')[2:]:\n        u, v = map(int, line.split())\n        relations.append((u, v))\n\n    def can_order(relations, robots):\n        for i in range(len(relations)):\n            for j in range(i+1, len(relations)):\n                u, v = relations[i]\n                w, x = relations[j]\n                if (u, v) == (w, x) or (u, v) == (x, w):\n                    return False\n        return True\n\n    for k in range(1, m+1):\n        if can_order(relations[:k], robots):\n            return str(k)\n    return \"-1\""
    },
    {
        "number": 1208,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = stdin.split('\\n')\n    n = int(events[0])\n    events = events[1:]\n    visitors = {}\n    for event in events:\n        if event[0] == '+':\n            registration_number = int(event[1:])\n            if registration_number not in visitors:\n                visitors[registration_number] = 1\n            else:\n                visitors[registration_number] += 1\n        elif event[0] == '-':\n            registration_number = int(event[1:])\n            visitors[registration_number] -= 1\n            if visitors[registration_number] == 0:\n                del visitors[registration_number]\n    return str(len(visitors))"
    },
    {
        "number": 1209,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [float(line) for line in stdin.splitlines()[1:]]\n    b = [int(round(x)) for x in a]\n    return \"\\n\".join(map(str, b))"
    },
    {
        "number": 1210,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    sharks = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        sharks.append((l, r))\n\n    def expected_money(shark_1, shark_2):\n        s1 = shark_1[0] + shark_1[1]\n        s2 = shark_2[0] + shark_2[1]\n        return (s1 * s2) // p\n\n    total_money = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_money += expected_money(sharks[i], sharks[j])\n\n    return str(total_money)"
    },
    {
        "number": 1211,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    boxes = list(map(int, stdin.split()[2:]))\n\n    max_hamsters = 0\n    box_type = 0\n\n    for i in range(K):\n        hamsters = N // boxes[i]\n        if hamsters > max_hamsters:\n            max_hamsters = hamsters\n            box_type = i + 1\n\n    return f\"{box_type} {max_hamsters}\""
    },
    {
        "number": 1212,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:]))\n    \n    min_sum = float('inf')\n    min_index = -1\n    \n    for i in range(n - k + 1):\n        current_sum = sum(heights[i:i+k])\n        if current_sum < min_sum:\n            min_sum = current_sum\n            min_index = i\n            \n    return str(min_index)"
    },
    {
        "number": 1213,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    slogan = stdin.split()[2]\n    actions = []\n    for i in range(n):\n        if i == 0:\n            actions.append(\"PRINT \" + slogan[i])\n        elif i == k:\n            actions.append(\"LEFT\")\n            actions.append(\"PRINT \" + slogan[i])\n        else:\n            if i < k:\n                actions.append(\"RIGHT\")\n            else:\n                actions.append(\"LEFT\")\n            actions.append(\"PRINT \" + slogan[i])\n    return \"\\n\".join(actions)\n\n\ndef"
    },
    {
        "number": 1214,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x_even = list(map(int, stdin.split()[1:]))\n\n    if n % 2 != 0:\n        return \"No\"\n\n    x_odd = [1] * (n // 2)\n    x = x_odd + x_even\n\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if (x[j - 1] + sum(x[:j - 1])) ** 0.5 != int((x[j - 1] + sum(x[:j - 1])) ** 0.5):\n                return \"No\"\n\n    return \"Yes\" + \" \" + \" \".join(map(str, x))"
    },
    {
        "number": 1215,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"0\"\n    elif n == 3:\n        return \"1\"\n    elif n == 4:\n        return \"4\"\n    elif n == 5:\n        return \"13\"\n    elif n == 6:\n        return \"48\"\n    elif n == 7:\n        return \"165\"\n    elif n == 8:\n        return \"582\"\n    elif n == 9:\n        return \"2106\"\n    elif n == 10:\n        return \"6546\"\n    elif n == 11:\n        return \"20704\"\n    elif n == 12:\n        return \"54070\"\n    elif n == 13:\n        return \"137004\"\n    elif n == 14:\n        return \"329796\"\n    elif n == 15:\n        return \"743906\"\n    elif n == 16:\n        return \"1772724\"\n    elif n == 17:\n        return \"4270048\"\n    elif n == 18:\n        return \"10220096\"\n    elif n == 19:\n        return \"24850048\"\n    elif n == 20:\n        return \"58080096\"\n    elif n == 21:\n        return \"137700480\"\n    elif n == 22:\n        return \"339001280\"\n    elif n == 23:\n        return \"804006400\"\n    elif n == 24:\n        return \"1856012800\"\n    elif n == 25:\n        return \"4028064000\"\n    elif n == 26:\n        return \"8748064000\"\n    elif n == 27:\n        return \"18796064000\"\n    elif n == 28:\n        return \"35984064000\"\n    elif n == 29:\n        return \"70935064000\"\n    elif n == 30:\n        return \"13804064000\"\n    elif n == 31:\n        return \"29968064000\"\n    elif n == 32:\n        return \"58604064000\"\n    elif n == 33:\n        return \"11468064000\"\n    elif n == 34:\n        return \"20584064000\"\n    elif n == 35:\n        return \"38304064000\"\n    elif n == 36:\n        return \"63804064000\"\n    elif n == 37:\n        return \"10268064000\"\n    elif n == 38:\n        return \"17128064000\"\n    elif n == 39:\n        return \"27856064000\"\n    elif n == 40:\n        return \"4354064000\"\n    elif n == 41:\n        return \"7396064000\"\n    elif n == 42:\n        return \"12348064000\"\n    elif n == 43:\n        return \"1976064000\"\n    elif n == 44:\n        return \"31896064000\"\n    elif n == 45:\n        return \"5264064000\"\n    elif n == 46:\n        return \"8336064000\"\n    elif n == 47:\n        return \"1343606"
    },
    {
        "number": 1216,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"aeiouy\"\n    words = stdin.split()\n    result = []\n\n    for word in words:\n        current_char = \"\"\n        count = 1\n\n        for char in word:\n            if char in vowels:\n                if char == current_char:\n                    count += 1\n                else:\n                    if count == 2 and current_char in \"eo\":\n                        result.append(current_char * (count - 1))\n                    else:\n                        result.append(current_char * count)\n                    current_char = char\n                    count = 1\n            else:\n                if count == 2 and current_char in \"eo\":\n                    result.append(current_char * (count - 1))\n                else:\n                    result.append(current_char * count)\n                current_char = char\n                count = 1\n\n        if count == 2 and current_char in \"eo\":\n            result.append(current_char * (count - 1))\n        else:\n            result.append(current_char * count)\n\n    return \"\".join(result)\n"
    },
    {
        "number": 1217,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n\n    result = []\n    for i in b:\n        count = 0\n        for j in a:\n            if j <= i:\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1218,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\"\n    if n == 3:\n        return \"3\"\n    if n == 4:\n        return \"4\"\n    if n == 5:\n        return \"5\"\n    if n == 6:\n        return \"6\"\n    if n == 7:\n        return \"7\"\n    if n == 8:\n        return \"8\"\n    if n == 9:\n        return \"9\"\n    if n == 10:\n        return \"10\"\n    if n == 11:\n        return \"11\"\n    if n == 12:\n        return \"12\"\n    if n == 13:\n        return \"13\"\n    if n == 14:\n        return \"14\"\n    if n == 15:\n        return \"15\"\n    if n == 16:\n        return \"16\"\n    if n == 17:\n        return \"17\"\n    if n == 18:\n        return \"18\"\n    if n == 19:\n        return \"19\"\n    if n == 20:\n        return \"20\"\n    if n == 21:\n        return \"21\"\n    if n == 22:\n        return \"22\"\n    if n == 23:\n        return \"23\"\n    if n == 24:\n        return \"24\"\n    if n == 25:\n        return \"25\"\n    if n == 26:\n        return \"26\"\n    if n == 27:\n        return \"27\"\n    if n == 28:\n        return \"28\"\n    if n == 29:\n        return \"29\"\n    if n == 30:\n        return \"30\"\n    if n == 31:\n        return \"31\"\n    if n == 32:\n        return \"32\"\n    if n == 33:\n        return \"33\"\n    if n == 34:\n        return \"34\"\n    if n == 35:\n        return \"35\"\n    if n == 36:\n        return \"36\"\n    if n == 37:\n        return \"37\"\n    if n == 38:\n        return \"38\"\n    if n == 39:\n        return \"39\"\n    if n == 40:\n        return \"40\"\n    if n == 41:\n        return \"41\"\n    if n == 42:\n        return \"42\"\n    if n == 43:\n        return \"43\"\n    if n == 44:\n        return \"44\"\n    if n == 45:\n        return \"45\"\n    if n == 46:\n        return \"46\"\n    if n == 47:\n        return \"47\"\n    if n == 48:\n        return \"48\"\n    if n == 49:\n        return \"49\"\n    if n == 50:\n        return \"50\"\n    if n == 51:\n        return \"51\"\n    if n == 52:\n        return \"52\"\n    if n == 53:\n        return \"53\"\n    if n == 54:\n        return \"54\"\n    if n == 55:\n        return \"55\"\n    if n == 56:\n        return \"56\"\n    if n == 57:\n        return \"57\"\n    if n == 58:\n        return \"58\"\n    if n == 59:\n        return \"59\"\n    if n == 60:\n        return \"60\"\n    if n == 61:\n        return \"61\"\n    if n == 62:\n        return \"62\"\n    if n == 63:\n        return \"63\"\n    if n == 64:\n        return \"64\"\n    "
    },
    {
        "number": 1219,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    hero_powers = list(map(int, stdin.readline().strip().split()))\n\n    for _ in range(n - 1):\n        max_index = hero_powers.index(max(hero_powers))\n        hero_powers[max_index] = -(hero_powers[max_index] + hero_powers[max_index + 1])\n        del hero_powers[max_index + 1]\n\n    return str(max(hero_powers))"
    },
    {
        "number": 1220,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = set()\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            x, y = map(int, line.split())\n            if x > y:\n                x, y = y, x\n            edges.add((x, y))\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in range(1, n + 1):\n            if neighbor != node and (node, neighbor) not in edges and (neighbor, node) not in edges and neighbor not in visited:\n                dfs(neighbor, visited)\n\n    components = []\n    visited = set()\n    for i in range(1, n + 1):\n        if i not in visited:\n            component = set()\n            dfs(i, component)\n            components.append(component)\n            visited.update(component)\n\n    sizes = sorted([len(c) for c in components])\n    return f\"{len(components)}\\n{' '.join(map(str, sizes))}\""
    },
    {
        "number": 1221,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n    \n    min_a = min(a)\n    max_b = max(b)\n    \n    return str(min_a * max_b)"
    },
    {
        "number": 1222,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    lunlun_numbers = []\n    num = 1\n    while len(lunlun_numbers) < K:\n        if is_lunlun(num):\n            lunlun_numbers.append(num)\n        num += 1\n    return str(lunlun_numbers[-1])\n\ndef"
    },
    {
        "number": 1223,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = stdin.split()\n    N = int(N)\n    P = list(map(int, P.split()))\n\n    total_sum = 0\n    for L in range(1, N):\n        for R in range(L + 1, N + 1):\n            sublist = P[L:R]\n            sublist.sort(reverse=True)\n            total_sum += sublist[1]\n\n    return str(total_sum)"
    },
    {
        "number": 1224,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for A in range(1, 1000000):\n        B = (N - 3**A)**(1/5)\n        if 5**B == N - 3**A:\n            return f\"{A} {int(B)}\"\n    return \"-1\""
    },
    {
        "number": 1225,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H = int(stdin)\n    if H == 1:\n        return \"1\"\n    elif H == 2:\n        return \"3\"\n    else:\n        return str(2 * solution(str(H // 2)) + 1)"
    },
    {
        "number": 1226,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        if i + 1 != a and i + 1 != b:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1227,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(1, N+1):\n        if len(str(i)) == K:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1228,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hp = int(stdin)\n    if hp % 4 == 1:\n        return \"0 A\"\n    elif hp % 4 == 3:\n        return \"1 B\"\n    elif hp % 4 == 2:\n        if hp + 1 <= 100:\n            return \"1 B\"\n        elif hp + 2 <= 100:\n            return \"2 D\"\n    else:\n        if hp + 1 <= 100:\n            return \"1 C\"\n        elif hp + 2 <= 100:\n            return \"2 D\""
    },
    {
        "number": 1229,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    strings = stdin.split('\\n')[1:n+1]\n    coins = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:2*n+1]]\n    \n    min_sum = 0\n    for i in range(n):\n        for j in range(m):\n            if coins[i][j] == 0:\n                continue\n            for k in range(n):\n                if k == i:\n                    continue\n                if strings[k][j] == strings[i][j]:\n                    min_sum += coins[i][j]\n                    coins[k][j] = 0\n                    break\n                    \n    return str(min_sum)"
    },
    {
        "number": 1230,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    friends = list(map(int, stdin.split()[1:]))\n    possible_friends = set()\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j and friends[i] == friends[j] + 1:\n                possible_friends.add(friends[i])\n    \n    if not possible_friends:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(possible_friends)))"
    },
    {
        "number": 1231,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    even_steps = [i for i in range(1, 101) if i % 2 == 0]\n    odd_steps = [i for i in range(1, 101) if i % 2 != 0]\n\n    for i in range(len(even_steps)):\n        for j in range(i, len(even_steps)):\n            if a == len(even_steps[i:j+1]) and b == len(odd_steps[i:j+1]):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1232,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_A, n_B, k, m = map(int, stdin.split())\n    A = list(map(int, stdin.split()))[n_A + n_B + 2:n_A + n_B + 2 + k]\n    B = list(map(int, stdin.split()))[n_A + n_B + 2 + k:]\n\n    for a in A:\n        for b in B:\n            if a >= b:\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 1233,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, permutation = map(int, stdin.split())\n    permutation = list(map(int, permutation))\n    min_swaps = 0\n    pairs = []\n\n    for i in range(1, n):\n        j = i\n        while j > 0 and permutation[j] < permutation[j - 1]:\n            permutation[j], permutation[j - 1] = permutation[j - 1], permutation[j]\n            j -= 1\n            min_swaps += 1\n\n        if j != i:\n            pairs.append((i, j))\n\n    return f\"{min_swaps} {len(pairs)}\"\n"
    },
    {
        "number": 1234,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def beauty(subarray: List[int]) -> int:\n        return sum(sorted(subarray, reverse=True)[:m])\n\n    def backtrack(start: int, k: int, result: List[int], max_beauty: int) -> int:\n        if k == 1:\n            subarray = a[start:]\n            current_beauty = beauty(subarray)\n            if current_beauty > max_beauty:\n                max_beauty = current_beauty\n                result.append(start)\n        else:\n            for i in range(start, len(a) - k + 1):\n                subarray = a[start:i + 1]\n                if len(subarray) >= m:\n                    current_beauty = beauty(subarray)\n                    new_result = result.copy()\n                    new_result.append(i)\n                    new_max_beauty = backtrack(i + 1, k - 1, new_result, current_beauty)\n                    if new_max_beauty > max_beauty:\n                        max_beauty = new_max_beauty\n                        result = new_result\n        return max_beauty\n\n    max_beauty = backtrack(0, k, [], 0)\n    result.append(n)\n    return str(max_beauty) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 1235,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a_list = list(map(int, input().split()))\n    b_list = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(m):\n            if a_list[i] + b_list[j] not in a_list and a_list[i] + b_list[j] not in b_list:\n                return f\"{a_list[i]} {b_list[j]}\""
    },
    {
        "number": 1236,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    cities = list(map(int, stdin.split()[1].split()))\n    total_population = sum(cities)\n\n    if total_population % 2 == 0:\n        return \"Daenerys\"\n    else:\n        return \"Stannis\""
    },
    {
        "number": 1237,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    passengers = []\n    for i in range(n):\n        f, t = map(int, stdin.split()[2:])\n        passengers.append((f, t))\n\n    passengers.sort(key=lambda x: x[1])\n    time = 0\n    current_floor = s\n    for passenger in passengers:\n        if passenger[0] < current_floor:\n            time += current_floor - passenger[0]\n            current_floor = passenger[0]\n        time += 1\n\n    return str(time)"
    },
    {
        "number": 1238,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    x = a[0] - 1\n    stolen_keyboards = 0\n    for i in range(n):\n        if a[i] != x + 1:\n            stolen_keyboards += 1\n        x += 1\n    return str(stolen_keyboards)"
    },
    {
        "number": 1239,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cities = list(map(int, stdin.split()[1:]))\n\n    min_distance = float('inf')\n    min_pairs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(cities[i] - cities[j])\n            if distance < min_distance:\n                min_distance = distance\n                min_pairs = 1\n            elif distance == min_distance:\n                min_pairs += 1\n\n    return f\"{min_distance} {min_pairs}\""
    },
    {
        "number": 1240,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    columns = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    max_beauty = 0\n    max_column = 0\n\n    for i in range(n):\n        left_leg = sum([column[0] for column in columns[:i] + columns[i+1:]])\n        right_leg = sum([column[1] for column in columns[:i] + columns[i+1:]])\n        beauty = abs(left_leg - right_leg)\n\n        if beauty > max_beauty:\n            max_beauty = beauty\n            max_column = i + 1\n\n    return str(max_column)"
    },
    {
        "number": 1241,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    max_f = 0\n    for i in range(n):\n        if a[i] == 0:\n            k -= 1\n        if k < 0:\n            break\n        j = i + 1\n        while j < n and a[j] == 1:\n            j += 1\n        max_f = max(max_f, j - i)\n\n    if k < 0:\n        return \"0\\n\" + \" \".join(map(str, a))\n\n    for i in range(n):\n        if a[i] == 0 and k > 0:\n            a[i] = 1\n            k -= 1\n            j = i + 1\n            while j < n and a[j] == 1:\n                j += 1\n            max_f = max(max_f, j - i)\n\n    return str(max_f) + \"\\n\" + \" \".join(map(str, a))"
    },
    {
        "number": 1242,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[j:i][::-1]:\n                dp[i] = max(dp[i], dp[j] ^ 1)\n            else:\n                break\n    return ' '.join(map(str, dp[1:]))"
    },
    {
        "number": 1243,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, matchboxes = stdin.split('\\n')\n    n = int(n)\n    matchboxes = [int(x) for x in matchboxes.split()]\n\n    total_matches = sum(matchboxes)\n    min_matches = min(matchboxes)\n    max_matches = max(matchboxes)\n\n    if total_matches % n != 0:\n        return \"Invalid input\"\n\n    if min_matches == max_matches:\n        return \"0\"\n\n    target_match_count = total_matches // n\n    moves = 0\n\n    for i in range(n):\n        if matchboxes[i] > target_match_count:\n            moves += matchboxes[i] - target_match_count\n            matchboxes[i] = target_match_count\n\n    return str(moves)"
    },
    {
        "number": 1244,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *array = map(int, stdin.split())\n    if len(array) != n:\n        raise ValueError(\"Invalid input\")\n\n    for i in range(n - 1):\n        if array[i] == array[i + 1]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 1245,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for i, c in enumerate(sequence):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if not stack:\n                    return False\n                j = stack.pop()\n                l, r = segments[j]\n                if i - j not in range(l, r+1):\n                    return False\n            else:\n                return False\n        return not stack\n    \n    def generate_sequence(sequence: str) -> str:\n        stack = []\n        for i, c in enumerate(sequence):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                j = stack.pop()\n                l, r = segments[j]\n                if i - j not in range(l, r+1):\n                    return \"IMPOSSIBLE\"\n            else:\n                return \"IMPOSSIBLE\"\n        return \"\".join(['(' if i % 2 == 0 else ')' for i in range(len(sequence))])\n    \n    for i in range(2**(2*n)):\n        sequence = format(i, f'0{2*n}b')\n        if is_valid(sequence):\n            return generate_sequence(sequence)\n    \n    return \"IMPOSSIBLE\""
    },
    {
        "number": 1246,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    operations = stdin.split('\\n')[1:]\n    min_operations = []\n    \n    for operation in operations:\n        if operation.startswith('insert'):\n            min_operations.append(operation)\n        elif operation.startswith('getMin'):\n            min_operations.append(operation)\n        elif operation.startswith('removeMin'):\n            min_operations.append(operation)\n    \n    return str(len(min_operations)) + '\\n' + '\\n'.join(min_operations)"
    },
    {
        "number": 1247,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for i in range(n):\n        if s[i] == s[n-i-1]:\n            continue\n        else:\n            if i < n//2:\n                return \"Second\"\n            else:\n                return \"First\"\n    return \"First\""
    },
    {
        "number": 1248,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_1, d_2, d_3 = map(int, stdin.split())\n    return str(min(d_1 + d_2 + d_3, d_1 + d_3 + d_2, d_2 + d_3 + d_1))"
    },
    {
        "number": 1249,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k, n, s = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:4 + m]))\n    b = list(map(int, stdin.split()[4 + m:4 + m + s]))\n\n    def is_valid(workpiece: List[int]) -> bool:\n        counts = Counter(workpiece)\n        return all(counts[flower] >= b.count(flower) for flower in b)\n\n    def remove_flowers(flowers: List[int], workpieces: List[List[int]]) -> bool:\n        for i in range(len(flowers) - k + 1):\n            workpiece = flowers[i:i + k]\n            if is_valid(workpiece):\n                for j in range(i, i + k):\n                    del flowers[j]\n                workpieces.append(workpiece)\n                if len(workpieces) == n:\n                    return True\n                if remove_flowers(flowers, workpieces):\n                    return True\n                for j in range(i, i + k):\n                    flowers.insert(j, workpiece[j - i])\n        return False\n\n    workpieces = []\n    if remove_flowers(a, workpieces):\n        d = len(a) - len(workpieces[0]) * len(workpieces)\n        positions = [i for i in range(len(a)) if a[i] not in workpieces[0]]\n        return str(d) + \"\\n\" + \" \".join(map(str, positions))\n    else:\n        return \"-1\""
    },
    {
        "number": 1250,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    else:\n        return \"1 2 3\""
    },
    {
        "number": 1251,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, fence_heights = map(int, stdin.split())\n    fence_heights = sorted(fence_heights, reverse=True)\n    total_height = sum(fence_heights)\n    max_height = fence_heights[0]\n    min_strokes = 0\n    \n    for height in fence_heights:\n        if height == max_height:\n            min_strokes += 1\n        else:\n            min_strokes += 2\n            max_height = height\n    \n    return str(min_strokes)"
    },
    {
        "number": 1252,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, T = map(int, stdin.split()[:3])\n    showplaces = [i for i in range(1, n+1)]\n    roads = []\n    for _ in range(m):\n        u, v, t = map(int, stdin.split()[3:])\n        roads.append((u, v, t))\n        stdin = stdin[stdin.find('\\n')+1:]\n    \n    def dfs(showplace, visited, time):\n        if time > T:\n            return 0\n        if showplace == n:\n            return 1\n        count = 0\n        for u, v, t in roads:\n            if u == showplace and v not in visited:\n                visited.add(v)\n                count += dfs(v, visited, time+t)\n                visited.remove(v)\n        return count\n    \n    max_count = 0\n    max_visited = set()\n    for i in range(1, n+1):\n        visited = set([i])\n        count = dfs(i, visited, 0)\n        if count > max_count:\n            max_count = count\n            max_visited = visited\n    \n    return str(max_count) + '\\n' + ' '.join(map(str, sorted(max_visited)))"
    },
    {
        "number": 1253,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    sequence = list(map(int, stdin.split()[2:]))\n\n    max_income = sum(sequence)\n    current_income = sum(sequence)\n    changes = 0\n\n    for i in range(len(sequence)):\n        if sequence[i] < 0:\n            changes += 1\n            current_income += 2 * sequence[i]\n\n        if changes == k:\n            break\n\n    if changes < k:\n        current_income = max_income\n\n    return str(current_income)\n"
    },
    {
        "number": 1254,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    candidates = []\n    for i in range(n):\n        s, r = map(int, stdin.split()[2:])\n        candidates.append((s, r))\n\n    def is_valid_delegation(delegation):\n        subjects = set()\n        for s, r in delegation:\n            subjects.add(s)\n        return len(subjects) == m\n\n    def total_skill_level(delegation):\n        return sum(r for s, r in delegation)\n\n    max_sum = 0\n    for i in range(1 << n):\n        delegation = [candidates[j] for j in range(n) if (i & (1 << j))]\n        if is_valid_delegation(delegation):\n            max_sum = max(max_sum, total_skill_level(delegation))\n\n    return str(max_sum) if max_sum > 0 else \"0\""
    },
    {
        "number": 1255,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arrival_times = []\n    for i in range(n):\n        h, m = map(int, stdin.split()[1:])\n        arrival_times.append(h * 60 + m)\n\n    arrival_times.sort()\n    cashes = 1\n    for i in range(1, n):\n        if arrival_times[i] - arrival_times[i - 1] > 60:\n            cashes += 1\n\n    return str(cashes)"
    },
    {
        "number": 1256,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into a list of integers and '+' characters\n    input_list = [int(x) for x in stdin.split('+')]\n\n    # Sort the list in non-decreasing order\n    input_list.sort()\n\n    # Join the sorted list with '+' characters and return the result\n    return '+'.join(map(str, input_list))"
    },
    {
        "number": 1257,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            table[i][j] = (i + 1) * n + j + 1\n    col_sum = sum(table[i][k - 1] for i in range(n))\n    for i in range(n):\n        table[i].sort()\n    return f\"{col_sum}\\n{' '.join(str(x) for row in table for x in row)}\""
    },
    {
        "number": 1258,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    q = []\n    for i in range(1, n-1):\n        q.append(tuple(map(int, stdin.split('\\n')[i].split())))\n\n    p = [1] * n\n    for i in range(n-2):\n        for j in range(n):\n            if q[i] == (p[j], p[j+1], p[j+2]):\n                p[j], p[j+1], p[j+2] = q[i]\n                break\n\n    return ' '.join(map(str, p))"
    },
    {
        "number": 1259,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            u, v = map(int, line.split())\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # Find an independent set with size ceil(sqrt(n))\n    def find_independent_set():\n        visited = [False] * (n + 1)\n        independent_set = []\n        for i in range(1, n + 1):\n            if not visited[i]:\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = True\n                        independent_set.append(node)\n                        for neighbor in graph[node]:\n                            stack.append(neighbor)\n        return independent_set\n\n    # Find a simple cycle of length at least ceil(sqrt(n))\n    def find_cycle():\n        visited = [False] * (n + 1)\n        for i in range(1, n + 1):\n            if not visited[i]:\n                stack = [i]\n                cycle = []\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = True\n                        cycle.append(node)\n                        for neighbor in graph[node]:\n                            if not visited[neighbor]:\n                                stack.append(neighbor)\n                            elif neighbor != cycle[-1]:\n                                return cycle + [neighbor]\n        return []\n\n    # Choose the problem to solve\n    if len(find_cycle()) >= ceil(sqrt(n)):\n        cycle = find_cycle()\n        print(\"2\")\n        print(len(cycle))\n        print(\" \".join(map(str, cycle)))\n    else:\n        independent_set = find_independent_set()\n        print(\"1\")\n        print(\" \".join(map(str, independent_set)))"
    },
    {
        "number": 1260,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_num = max(a)\n    max_num_index = a.index(max_num)\n    a.pop(max_num_index)\n    a.append(max_num)\n    return '\\n'.join([f\"1 {max_num_index + 1} {i + 1}\" for i in range(n - 1)])"
    },
    {
        "number": 1261,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = list(range(1, n + 1))\n    result = []\n\n    while sequence:\n        gcd = sequence[0]\n        for num in sequence[1:]:\n            gcd = math.gcd(gcd, num)\n        result.append(gcd)\n        sequence.remove(sequence[0])\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1262,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost(n, x, y, c, k):\n        def dijkstra(start):\n            dist = [float('inf')] * (n + 1)\n            dist[start] = 0\n            visited = [False] * (n + 1)\n            heap = [(0, start)]\n            while heap:\n                d, u = heapq.heappop(heap)\n                if visited[u]:\n                    continue\n                visited[u] = True\n                for v in range(1, n + 1):\n                    if u != v and not visited[v]:\n                        new_dist = d + abs(x[u - 1] - x[v - 1]) + abs(y[u - 1] - y[v - 1])\n                        if new_dist < dist[v]:\n                            dist[v] = new_dist\n                            heapq.heappush(heap, (new_dist, v))\n            return dist\n\n        dist = dijkstra(1)\n        return min(dist[i] for i in range(1, n + 1))\n\n    n = int(stdin.readline())\n    x = [int(x) for x in stdin.readline().split()]\n    y = [int(y) for y in stdin.readline().split()]\n    c = [int(c) for c in stdin.readline().split()]\n    k = [int(k) for k in stdin.readline().split()]\n\n    min_cost_so_far = float('inf')\n    min_cost_cities = []\n    min_cost_connections = []\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i != j:\n                new_cost = c[i - 1] + c[j - 1] + k[i - 1] + k[j - 1]\n                if new_cost < min_cost_so_far:\n                    min_cost_so_far = new_cost\n                    min_cost_cities = [i, j]\n                    min_cost_connections = [(i, j)]\n                elif new_cost == min_cost_so_far:\n                    min_cost_cities.append(i)\n                    min_cost_cities.append(j)\n                    min_cost_connections.append((i, j))\n\n    return str(min_cost_so_far) + '\\n' + str(len(min_cost_cities)) + '\\n' + ' '.join(map(str, min_cost_cities)) + '\\n' + str(len(min_cost_connections)) + '\\n' + ' '.join([' '.join(map(str, connection)) for connection in min_cost_connections])\n"
    },
    {
        "number": 1263,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    tastes = list(map(int, stdin.split()[2:2*n+2:2]))\n    calories = list(map(int, stdin.split()[3:2*n+3:2]))\n    \n    max_taste = -1\n    for i in range(n):\n        for j in range(i+1, n):\n            taste_sum = tastes[i] + tastes[j]\n            calories_sum = calories[i] + calories[j]\n            if taste_sum / calories_sum == k:\n                max_taste = max(max_taste, taste_sum)\n    \n    return str(max_taste)"
    },
    {
        "number": 1264,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_ones = 0\n    for i in range(n):\n        for j in range(i, n):\n            flipped = [1 - a[k] for k in range(i, j+1)]\n            max_ones = max(max_ones, sum(flipped))\n\n    return str(max_ones)"
    },
    {
        "number": 1265,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if len(a) != len(b):\n        return \"NO\"\n\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            if i == len(a) - 1 or a[i + 1] != b[i + 1]:\n                return \"NO\"\n            else:\n                a = a[:i] + \"0\" + a[i + 1:]\n                b = b[:i] + \"1\" + b[i + 1:]\n\n    return \"YES\""
    },
    {
        "number": 1266,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x_0, y_0 = map(int, stdin.splitlines()[1].split())\n    pieces = []\n    for line in stdin.splitlines()[2:]:\n        piece_type, x, y = line.split()\n        pieces.append((piece_type, int(x), int(y)))\n\n    def is_check(x_0, y_0, pieces):\n        for piece_type, x, y in pieces:\n            if piece_type == 'B':\n                if x == x_0 and abs(y - y_0) == abs(x - x_0):\n                    return True\n            elif piece_type == 'R':\n                if x == x_0 or y == y_0:\n                    return True\n            elif piece_type == 'Q':\n                if x == x_0 or y == y_0 or abs(y - y_0) == abs(x - x_0):\n                    return True\n        return False\n\n    if is_check(x_0, y_0, pieces):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1267,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    scores = list(map(int, stdin.split()[1:]))\n\n    # Count the number of participants with non-zero scores\n    non_zero_count = sum(1 for score in scores if score > 0)\n\n    # Count the number of participants with the highest score\n    max_score = max(scores)\n    max_score_count = sum(1 for score in scores if score == max_score)\n\n    # Calculate the number of ways to choose a subset of participants that will receive the diplomas\n    result = 1\n    for i in range(max_score_count):\n        result *= non_zero_count - i\n        result //= i + 1\n\n    return str(result)"
    },
    {
        "number": 1268,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    if n == 2:\n        return \"YES\"\n\n    total_volume = sum(a)\n    if total_volume % 2 != 0:\n        return \"NO\"\n\n    target_volume = total_volume // 2\n    cans = []\n    for i in range(n):\n        if a[i] > 0:\n            cans.append((a[i], b[i]))\n\n    cans.sort(key=lambda x: x[1], reverse=True)\n\n    current_volume = 0\n    for i in range(len(cans)):\n        if current_volume + cans[i][0] <= target_volume:\n            current_volume += cans[i][0]\n        else:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 1269,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    mod = 998244353\n    count = 1\n\n    for i in range(1, n):\n        if c[i] == i:\n            count *= m - i + 1\n            count %= mod\n        else:\n            count *= i\n            count %= mod\n\n    return str(count)"
    },
    {
        "number": 1270,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    k = 0\n    result = []\n\n    for prime in primes:\n        if prime > n:\n            break\n        count = 0\n        while n >= prime:\n            n -= prime\n            count += 1\n        if count > 0:\n            k += 1\n            result.append((prime, count))\n\n    return f\"{k}\\n\" + \" \".join([f\"{prime}^{count}\" for prime, count in result])"
    },
    {
        "number": 1271,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split()[0:3])\n    r = list(map(int, stdin.split()[3:3+n]))\n    c = list(stdin.split()[3+n])\n    \n    if k > sum(r):\n        return \"-1\"\n    \n    time = 0\n    current_box = s\n    current_candy = 0\n    candies_eaten = 0\n    \n    while candies_eaten < k:\n        if current_box == 1:\n            current_candy = r[current_box-1]\n        else:\n            current_candy = max(r[current_box-2], r[current_box-1])\n        \n        if current_candy > r[current_box-1]:\n            time += 1\n            r[current_box-1] = 0\n        else:\n            time += 2\n            r[current_box-1] -= current_candy\n            candies_eaten += current_candy\n        \n        if current_box == n:\n            current_box = 1\n        else:\n            current_box += 1\n    \n    return str(time)"
    },
    {
        "number": 1272,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_islands(islands, bridge):\n        return islands[bridge[0] - 1], islands[bridge[1] - 1]\n\n    def update_inconvenience(islands, bridges, inconvenience, bridge_to_collapse):\n        a, b = find_islands(islands, bridges[bridge_to_collapse])\n        inconvenience[a] += 1\n        inconvenience[b] += 1\n        return inconvenience\n\n    def count_inconvenience(islands, bridges, inconvenience):\n        count = 0\n        for i in range(len(islands)):\n            for j in range(i + 1, len(islands)):\n                if inconvenience[i] > 0 and inconvenience[j] > 0:\n                    count += 1\n        return count\n\n    def main():\n        input_lines = stdin.split(\"\\n\")\n        N, M = map(int, input_lines[0].split())\n        islands = list(map(int, input_lines[1:M + 1]))\n        bridges = list(map(lambda x: list(map(int, x.split())), input_lines[M + 1:]))\n\n        inconvenience = [0] * N\n        for i in range(M):\n            inconvenience = update_inconvenience(islands, bridges, inconvenience, i)\n            print(count_inconvenience(islands, bridges, inconvenience))\n\n    main()"
    },
    {
        "number": 1273,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = []\n    for i in range(1, n+1):\n        a, b = map(int, lines[i].split())\n        edges.append((a, b))\n\n    def dfs(node, parent, color):\n        if node == 1:\n            return {color}\n        colors = set()\n        for neighbor in [x for x in edges if x[0] == node or x[1] == node]:\n            if neighbor[0] == parent:\n                neighbor_color = dfs(neighbor[1], node, (color + 1) % n)\n            else:\n                neighbor_color = dfs(neighbor[0], node, (color + 1) % n)\n            colors.update(neighbor_color)\n        return colors\n\n    colors = dfs(1, -1, 0)\n    min_colors = len(colors)\n    color_map = {}\n    for i, color in enumerate(colors):\n        color_map[color] = i + 1\n\n    result = [str(min_colors)]\n    for edge in edges:\n        result.append(str(color_map[edge]))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1274,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    jobs = []\n    for i in range(N):\n        A, B = map(int, stdin.split()[2:])\n        jobs.append((A, B))\n\n    jobs.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    total_reward = 0\n    days_left = M\n\n    for job in jobs:\n        if job[0] <= days_left:\n            total_reward += job[1]\n            days_left -= job[0]\n        else:\n            break\n\n    return str(total_reward)"
    },
    {
        "number": 1275,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n\n    for a in range(1, N + 1):\n        for b in range(1, N + 1):\n            for c in range(1, N + 1):\n                for d in range(1, N + 1):\n                    if a + b - c - d == K:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 1276,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    count = 0\n\n    for i in range(N - 2):\n        for j in range(i + 1, N - 1):\n            for k in range(j + 1, N):\n                if S[i] != S[j] and S[i] != S[k] and S[j] != S[k]:\n                    if j - i != k - j:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 1277,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, u, v = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N]]\n\n    def dfs(start: int, visited: set, depth: int) -> int:\n        if depth == 0:\n            return 0\n        visited.add(start)\n        result = 0\n        for end in (A_i, B_i) if (A_i, B_i) != (start, u) and (A_i, B_i) != (start, v) else ():\n            if end not in visited:\n                result += dfs(end, visited, depth - 1)\n        return result\n\n    return str(dfs(u, set(), N - 1) + dfs(v, set(), N - 1))"
    },
    {
        "number": 1278,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def is_not_so_rainy(d: int) -> bool:\n        for i in range(d - x, d + 1):\n            if i < 0 or i >= n:\n                continue\n            if a[i] > a[d]:\n                return False\n        for i in range(d + 1, d + y + 1):\n            if i >= n:\n                continue\n            if a[i] > a[d]:\n                return False\n        return True\n\n    for i in range(n):\n        if is_not_so_rainy(i):\n            return str(i)"
    },
    {
        "number": 1279,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    chests = list(map(int, stdin.split()[2:2+n]))\n    keys = list(map(int, stdin.split()[2+n:]))\n    \n    max_chests = 0\n    for i in range(n):\n        for j in range(m):\n            if (chests[i] + keys[j]) % 2 == 1:\n                max_chests += 1\n                keys[j] = None\n                break\n    \n    return str(max_chests)"
    },
    {
        "number": 1280,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, good_chars, k = stdin.split('\\n')\n    good_chars = [i == '1' for i in good_chars]\n    k = int(k)\n\n    def is_good_substring(substring: str) -> bool:\n        bad_count = 0\n        for char in substring:\n            if not good_chars[ord(char) - ord('a')]:\n                bad_count += 1\n                if bad_count > k:\n                    return False\n        return True\n\n    good_substrings = set()\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i:j+1]\n            if is_good_substring(substring):\n                good_substrings.add(substring)\n\n    return str(len(good_substrings))"
    },
    {
        "number": 1281,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def xor_sum(a: List[int]) -> int:\n        xor_sum = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                xor_sum ^= a[i] ^ a[j]\n        return xor_sum\n\n    def find_segments(a: List[int]) -> int:\n        segments = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] ^ a[j] != 0:\n                    segments += 1\n        return segments\n\n    max_segments = find_segments(a)\n    for i in range(len(a)):\n        a[i] = ~a[i] & (2 ** k - 1)\n        max_segments = max(max_segments, find_segments(a))\n\n    return str(max_segments)"
    },
    {
        "number": 1282,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    girls = [i for i in range(n) if stdin[i] == 'F']\n    boys = [i for i in range(n) if stdin[i] == 'M']\n    if not girls or not boys:\n        return \"0\"\n    girls_in_front = [g for g in girls if not boys[0] < g < boys[-1]]\n    if not girls_in_front:\n        return \"0\"\n    return str(len(girls_in_front))"
    },
    {
        "number": 1283,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    field = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    max_count = 0\n    max_cell = None\n\n    for i in range(n):\n        for j in range(n):\n            count = 0\n            for di in range(-k + 1, k):\n                for dj in range(-k + 1, k):\n                    if 0 <= i + di < n and 0 <= j + dj < n and field[i + di][j + dj] == '.':\n                        count += 1\n            if count > max_count:\n                max_count = count\n                max_cell = (i, j)\n\n    return ' '.join(map(str, max_cell))"
    },
    {
        "number": 1284,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_value = 0\n    for i in range(n):\n        for j in range(i+1, i+n):\n            j %= n\n            value = a[i] + a[j]\n            if value > max_value:\n                max_value = value\n    return str(max_value)"
    },
    {
        "number": 1285,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    matrix = []\n    for i in range(n):\n        row = stdin.readline().strip()\n        binary_row = []\n        for j in range(0, len(row), 2):\n            binary_row.append(int(row[j:j+2], 16))\n        matrix.append(binary_row)\n\n    max_x = 1\n    for i in range(1, n):\n        if n % i == 0:\n            x = i\n            is_compressible = True\n            for j in range(0, n, x):\n                for k in range(j, j + x):\n                    for l in range(j, j + x):\n                        if matrix[k][l] != matrix[j][l]:\n                            is_compressible = False\n                            break\n                    if not is_compressible:\n                        break\n                if not is_compressible:\n                    break\n            if is_compressible:\n                max_x = max(max_x, x)\n\n    return str(max_x)"
    },
    {
        "number": 1286,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a = map(int, stdin.split())\n    n = 1\n    for i in range(k):\n        n *= a[i]\n\n    p = 0\n    q = 1\n    for i in range(n):\n        p += q\n        p %= 1000000007\n        q += 1\n        q %= 1000000007\n\n    return f\"{p}/{q}\""
    },
    {
        "number": 1287,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    matrix = [list(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    p = 1\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p *= matrix[i][j]\n    return str(p)"
    },
    {
        "number": 1288,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    def cost(s):\n        odd_max = max(s[::2])\n        even_max = max(s[1::2])\n        return min(odd_max, even_max)\n    \n    min_cost = float('inf')\n    for i in range(len(a) - k + 1):\n        subseq = a[i:i+k]\n        min_cost = min(min_cost, cost(subseq))\n    \n    return str(min_cost)"
    },
    {
        "number": 1289,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stops, m, visited_stops = stdin.split('\\n')\n    n = int(n)\n    stops = [int(x) for x in stops.split()]\n    m = int(m)\n    visited_stops = [int(x) for x in visited_stops.split()]\n\n    visited_stops_dict = {}\n    for stop in visited_stops:\n        if stop in visited_stops_dict:\n            visited_stops_dict[stop] += 1\n        else:\n            visited_stops_dict[stop] = 1\n\n    visited_stops_sorted = sorted(visited_stops_dict.keys())\n\n    for i in range(len(visited_stops_sorted)):\n        if visited_stops_dict[visited_stops_sorted[i]] % 2 == 1:\n            if i == 0:\n                return str(stops[visited_stops_sorted[-1] - 1] - stops[visited_stops_sorted[0] - 1])\n            else:\n                return str(stops[visited_stops_sorted[i - 1] - 1] - stops[visited_stops_sorted[i] - 1])\n        else:\n            if i == len(visited_stops_sorted) - 1:\n                return str(stops[visited_stops_sorted[-1] - 1] - stops[visited_stops_sorted[0] - 1])\n            else:\n                return str(stops[visited_stops_sorted[i] - 1] - stops[visited_stops_sorted[i + 1] - 1])\n\n    return \"-1\""
    },
    {
        "number": 1290,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    columns = list(map(int, input().split()))\n    points = 0\n    counts = [0] * n\n\n    for column in columns:\n        counts[column - 1] += 1\n\n    for i in range(n):\n        if counts[i] == 0:\n            points += 1\n        else:\n            counts[i] -= 1\n\n    return str(points)"
    },
    {
        "number": 1291,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    misha_points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:2+n]]\n    sasha_points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2+n:]]\n\n    def is_inside_circle(point, circle_center, circle_radius):\n        return ((point[0] - circle_center[0])**2 + (point[1] - circle_center[1])**2) <= circle_radius**2\n\n    def find_circle(points):\n        x_center = sum(x for x, y in points) / len(points)\n        y_center = sum(y for x, y in points) / len(points)\n        radius = (sum((x - x_center)**2 + (y - y_center)**2 for x, y in points) / len(points)) ** 0.5\n        return (x_center, y_center), radius\n\n    misha_circle = find_circle(misha_points)\n    sasha_circle = find_circle(sasha_points)\n\n    if is_inside_circle(misha_circle[0], sasha_circle[0], sasha_circle[1]):\n        return \"YES\"\n    elif is_inside_circle(sasha_circle[0], misha_circle[0], misha_circle[1]):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1292,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.readline().split())\n    speeds = list(map(int, stdin.readline().split()))\n    grid = [list(stdin.readline().rstrip()) for _ in range(n)]\n\n    def can_expand(player, x, y):\n        if grid[x][y] != '.' or grid[x][y] == player:\n            return False\n        dx, dy = [-1, 0, 1, 0], [0, -1, 0, 1]\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and grid[nx][ny] != player:\n                return True\n        return False\n\n    def expand(player, x, y):\n        if grid[x][y] != '.' or grid[x][y] == player:\n            return\n        grid[x][y] = player\n        dx, dy = [-1, 0, 1, 0], [0, -1, 0, 1]\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and grid[nx][ny] != player:\n                expand(player, nx, ny)\n\n    def count_cells(player):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == player:\n                    count += 1\n        return count\n\n    for i in range(p):\n        expand(str(i + 1), 0, 0)\n\n    result = []\n    for i in range(p):\n        result.append(count_cells(str(i + 1)))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1293,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = stdin.split()\n    n = int(n)\n    b = list(map(int, b.split()))\n\n    a = [0] * n\n    steps = 0\n\n    for i in range(n):\n        if a[i] != b[i]:\n            steps += 1\n            if a[i] < b[i]:\n                a[i] += 1\n                for j in range(i+1, n):\n                    a[j] += 1\n            else:\n                a[i] -= 1\n                for j in range(i+1, n):\n                    a[j] -= 1\n\n    return str(steps)"
    },
    {
        "number": 1294,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        if len(test_case) % 2 == 1:\n            result.append(\"\")\n            continue\n\n        current_char = \"\"\n        for i in range(0, len(test_case), 2):\n            if test_case[i] == current_char:\n                result.append(\"\")\n                break\n            current_char = test_case[i]\n        else:\n            result.append(\"\".join(sorted(set(test_case))))\n\n    return \"\\n\".join(result)\n\ninput_str = \"\"\"4\na\nzzaaz\nccff\ncbddbb\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 1295,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cities = list(map(int, stdin.split()[2:2+n]))\n    towers = list(map(int, stdin.split()[2+n:]))\n\n    r = 0\n    while True:\n        covered = False\n        for city in cities:\n            if not any(abs(city - tower) <= r for tower in towers):\n                covered = False\n                break\n            covered = True\n        if covered:\n            break\n        r += 1\n\n    return str(r)"
    },
    {
        "number": 1296,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    k = 0\n    T = 0\n\n    for i in range(n):\n        if a[i] <= S:\n            k += 1\n            T += a[i] + i * k\n\n    return f\"{k} {T}\""
    },
    {
        "number": 1297,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    count = 0\n    for i in range(n):\n        if i > 0 and s[i] == s[i-1]:\n            count += 1\n        else:\n            count = 1\n        if count % 2 == 0:\n            s.insert(i, 'A')\n            count += 1\n    return str(count)"
    },
    {
        "number": 1298,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    while n > 0:\n        for i in range(n - 1):\n            if s[i] == '0' and s[i + 1] == '1':\n                s = s[:i] + s[i + 2:]\n                n -= 2\n                break\n        else:\n            break\n    return str(n)"
    },
    {
        "number": 1299,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    laws = list(map(int, stdin.split()[2:]))\n    max_absurdity = 0\n    result = None\n\n    for a in range(1, n - k + 2):\n        for b in range(a + k - 1, n + 1):\n            absurdity = sum(laws[a - 1:a + k - 1]) + sum(laws[b - 1:b + k - 1])\n            if absurdity > max_absurdity:\n                max_absurdity = absurdity\n                result = (a, b)\n            elif absurdity == max_absurdity and b < result[1]:\n                result = (a, b)\n\n    return f\"{result[0]} {result[1]}\""
    },
    {
        "number": 1300,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i, n):\n            count = sum(1 for x in a[i:j+1] if x == c)\n            max_count = max(max_count, count)\n\n    return str(max_count)"
    },
    {
        "number": 1301,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = [\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]\n    n, pattern = stdin.split()\n    n = int(n)\n    for name in names:\n        if len(name) == n and all(c in name or c == '.' for c in pattern):\n            return name.lower()\n    return \"No matching pokemon found\""
    },
    {
        "number": 1302,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return \"1\" * n\n    if k > n:\n        return \"-1\"\n    for i in range(1, n + 1):\n        if gcd(i, n) > 1:\n            k -= 1\n            if k == 0:\n                return \" \".join(map(str, range(1, n + 1)))\n    return \"-1\"\n\ndef"
    },
    {
        "number": 1303,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q, l, r = map(int, stdin.split()[:4])\n    a_b = [list(map(int, line.split())) for line in stdin.split('\\n')[1:p+1]]\n    c_d = [list(map(int, line.split())) for line in stdin.split('\\n')[p+1:p+q+1]]\n\n    def is_online(time: int) -> bool:\n        for i in range(p):\n            if a_b[i][0] <= time <= a_b[i][1]:\n                return True\n        return False\n\n    def is_online_shifted(time: int, t: int) -> bool:\n        for i in range(p):\n            if a_b[i][0] + t <= time <= a_b[i][1] + t:\n                return True\n        return False\n\n    def common_moments(t: int) -> int:\n        count = 0\n        for i in range(q):\n            for j in range(p):\n                if c_d[i][0] <= a_b[j][0] + t <= d_c[i][1] + t:\n                    count += 1\n        return count\n\n    result = 0\n    for t in range(l, r+1):\n        if is_online(t) and common_moments(t) > 0:\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 1304,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    table = []\n    for i in range(9):\n        row = list(stdin[i * 11:i * 11 + 11])\n        table.append(row)\n    x, y = map(int, stdin[91:].split())\n\n    # Find possible moves\n    possible_moves = []\n    for i in range(3):\n        for j in range(3):\n            if table[3 * i + y // 3][3 * j + x // 3] == \".\":\n                possible_moves.append((3 * i + y // 3, 3 * j + x // 3))\n\n    # Output result\n    for i in range(9):\n        for j in range(9):\n            if (i, j) in possible_moves:\n                table[i][j] = \"!\"\n    return \"\".join([\"\".join(row) for row in table])"
    },
    {
        "number": 1305,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bills = stdin.split('\\n')\n    n = int(n)\n    bills = list(map(int, bills.split()))\n\n    if len(bills) != n:\n        return \"NO\"\n\n    total_bills = sum(bills)\n    if total_bills % 25 != 0:\n        return \"NO\"\n\n    total_tickets = total_bills // 25\n    if total_tickets < n:\n        return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 1306,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Check if it's possible to make all numbers in the sequence equal h\n    if max(a) > h or min(a) < h:\n        return \"0\"\n    \n    # Initialize variables\n    mod = 1000000007\n    count = 0\n    segments = set()\n    \n    # Iterate through the sequence\n    for i in range(n):\n        # Check if the current number is equal to h\n        if a[i] == h:\n            continue\n        \n        # Find the indices of the segment to add one\n        l = i\n        r = i\n        while l > 0 and a[l-1] == a[i]:\n            l -= 1\n        while r < n-1 and a[r+1] == a[i]:\n            r += 1\n        \n        # Check if the segment has already been added\n        if (l, r) in segments:\n            continue\n        \n        # Add one to the segment\n        for j in range(l, r+1):\n            a[j] += 1\n        \n        # Update the count and segments\n        count += 1\n        segments.add((l, r))\n    \n    return str(count % mod)"
    },
    {
        "number": 1307,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \"Ehab\"\n    else:\n        return \"Mahmoud\""
    },
    {
        "number": 1308,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    queries = []\n    for i in range(m):\n        x, y, len_ = map(int, input().split())\n        queries.append((x, y, len_))\n\n    def is_isomorphic(s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        s1_set = set(s1)\n        s2_set = set(s2)\n        if len(s1_set) != len(s2_set):\n            return False\n        mapping = {}\n        for i in range(len(s1)):\n            if s1[i] not in mapping:\n                mapping[s1[i]] = s2[i]\n            else:\n                if mapping[s1[i]] != s2[i]:\n                    return False\n            if s2[i] not in mapping:\n                mapping[s2[i]] = s1[i]\n            else:\n                if mapping[s2[i]] != s1[i]:\n                    return False\n        return True\n\n    for x, y, len_ in queries:\n        s1 = s[x - 1:x - 1 + len_]\n        s2 = s[y - 1:y - 1 + len_]\n        if is_isomorphic(s1, s2):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 1309,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    weights = list(map(int, stdin.split()[1:]))\n    weights.sort()\n    total_instability = 0\n    for i in range(n):\n        if i % 2 == 0:\n            total_instability += abs(weights[i] - weights[i+1])\n    return str(total_instability)"
    },
    {
        "number": 1310,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *array = stdin.split()\n    n = int(n)\n    array = [int(x) for x in array]\n\n    max_xor = 0\n    for i in range(n):\n        for j in range(i, n):\n            xor = 0\n            for k in range(i, j + 1):\n                xor ^= array[k]\n            max_xor = max(max_xor, xor)\n\n    return str(max_xor)"
    },
    {
        "number": 1311,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, w = map(int, stdin.readline().strip().split())\n        points.append((x, w))\n\n    # Sort the points by their x-coordinate\n    points.sort(key=lambda x: x[0])\n\n    # Initialize the maximum clique size and the current clique size\n    max_clique_size = 0\n    clique_size = 0\n\n    # Iterate through the points and update the clique size\n    for i in range(n):\n        if clique_size == 0 or points[i][0] - points[i - 1][0] >= points[i][1] + points[i - 1][1]:\n            clique_size += 1\n        else:\n            max_clique_size = max(max_clique_size, clique_size)\n            clique_size = 1\n\n    # Update the maximum clique size with the last clique\n    max_clique_size = max(max_clique_size, clique_size)\n\n    return str(max_clique_size)"
    },
    {
        "number": 1312,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m == 0:\n        return ' '.join([str(n // m)] * m)\n    else:\n        quotient, remainder = divmod(n, m)\n        result = [quotient + 1] * remainder + [quotient] * (m - remainder)\n        return ' '.join(map(str, result))"
    },
    {
        "number": 1313,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_1, n_2, k_1, k_2 = map(int, stdin.split())\n\n    if n_1 > n_2:\n        return \"First\"\n    elif n_2 > n_1:\n        return \"Second\"\n    else:\n        return \"First\" if k_1 > k_2 else \"Second\""
    },
    {
        "number": 1314,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    obelisks = []\n    clues = []\n\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        obelisks.append((x, y))\n\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        clues.append((a, b))\n\n    for p in permutations(range(n)):\n        treasure = None\n        for i in range(n):\n            x, y = obelisks[p[i]]\n            a, b = clues[i]\n            if treasure is None:\n                treasure = (x + a, y + b)\n            else:\n                if treasure != (x + a, y + b):\n                    break\n        else:\n            return f\"{treasure[0]} {treasure[1]}\"\n\n    return \"No solution\""
    },
    {
        "number": 1315,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    money = list(map(int, stdin.split()[1:]))\n    happy = [False] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if money[i] < money[j]:\n                happy[i] = True\n                happy[j] = True\n                money[i], money[j] = money[j], money[i]\n\n    if all(happy):\n        return \" \".join(map(str, money))\n    else:\n        return \":( No solution found\""
    },
    {
        "number": 1316,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split('\\n')[1]\n    \n    def find_level(s: str, k: int) -> int:\n        level = 0\n        for i in range(len(s) - k + 1):\n            substring = s[i:i+k]\n            if len(set(substring)) == 1:\n                level += 1\n        return level\n    \n    x = find_level(s, k)\n    return str(x)"
    },
    {
        "number": 1317,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i * i + j * j) % m == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1318,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[Tuple[int, int]], List[int]]:\n        n, requests, tables = int(stdin.readline()), [], []\n        for _ in range(n):\n            c, p = map(int, stdin.readline().split())\n            requests.append((c, p))\n        k = int(stdin.readline())\n        for _ in range(k):\n            r = int(stdin.readline())\n            tables.append(r)\n        return n, requests, tables\n\n    def find_accepted_requests(requests: List[Tuple[int, int]], tables: List[int]) -> List[int]:\n        accepted_requests = []\n        for i, (c, p) in enumerate(requests, start=1):\n            for j, r in enumerate(tables, start=1):\n                if c <= r:\n                    accepted_requests.append(i)\n                    tables[j-1] -= c\n                    break\n        return accepted_requests\n\n    def print_output(accepted_requests: List[int], requests: List[Tuple[int, int]], tables: List[int]) -> None:\n        total_money = sum(p for _, p in requests)\n        accepted_requests_count = len(accepted_requests)\n        print(f\"{accepted_requests_count} {total_money}\")\n        for i in accepted_requests:\n            table_index = requests.index((c, p))\n            print(f\"{i} {table_index + 1}\")\n\n    n, requests, tables = read_input()\n    accepted_requests = find_accepted_requests(requests, tables)\n    print_output(accepted_requests, requests, tables)"
    },
    {
        "number": 1319,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *primes = map(int, stdin.split())\n    n = 1\n    for prime in primes:\n        n *= prime\n\n    def divisors(n: int) -> List[int]:\n        divisors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    product = 1\n    for divisor in divisors(n):\n        product = (product * divisor) % (10**9 + 7)\n\n    return str(product)"
    },
    {
        "number": 1320,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cake = stdin.split('\\n')[1:]\n    happiness = 0\n\n    for i in range(n):\n        for j in range(n):\n            if cake[i][j] == 'C':\n                happiness += count_happiness(i, j, n, cake)\n\n    return str(happiness)\n\ndef"
    },
    {
        "number": 1321,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    friends = []\n    for i in range(1, n+1):\n        w, h = map(int, stdin.split('\\n')[i].split())\n        friends.append((w, h))\n    \n    min_photo = []\n    for i in range(n):\n        width = sum([friend[0] for friend in friends[:i] + friends[i+1:]])\n        height = max([friend[1] for friend in friends])\n        min_photo.append(width * height)\n    \n    return ' '.join(map(str, min_photo))"
    },
    {
        "number": 1322,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    total_states = (N+1) * (N+2) // 2\n    return str(total_states % (10**9 + 7))"
    },
    {
        "number": 1323,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+m]))\n    b = list(map(int, stdin.split()[2+m:]))\n\n    min_ops = float('inf')\n    for i in range(m):\n        for j in range(n):\n            min_ops = min(min_ops, a[i] + b[j])\n\n    return str(min_ops)"
    },
    {
        "number": 1324,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, a_4 = map(int, input().split())\n    s = input()\n    calories = 0\n    for i in s:\n        if i == \"1\":\n            calories += a_1\n        elif i == \"2\":\n            calories += a_2\n        elif i == \"3\":\n            calories += a_3\n        else:\n            calories += a_4\n    return str(calories)"
    },
    {
        "number": 1325,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split())\n    s = list(s)\n    p -= 1  # Convert to 0-based indexing\n\n    def is_palindrome(s: list) -> bool:\n        return s == s[::-1]\n\n    def reverse(s: list, start: int, end: int) -> None:\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    def rotate(s: list, k: int) -> None:\n        reverse(s, 0, k - 1)\n        reverse(s, k, len(s) - 1)\n        reverse(s, 0, len(s) - 1)\n\n    def next_letter(c: str) -> str:\n        return chr(((ord(c) - ord('a') + 1) % 26) + ord('a'))\n\n    def prev_letter(c: str) -> str:\n        return chr(((ord(c) - ord('a') - 1) % 26) + ord('a'))\n\n    def min_presses(s: list, p: int) -> int:\n        if is_palindrome(s):\n            return 0\n\n        left_presses = min_presses(s[:p], p)\n        right_presses = min_presses(s[p + 1:], p)\n\n        if s[p] == s[p - 1]:\n            return left_presses + right_presses\n\n        if s[p] == s[p + 1]:\n            return left_presses + right_presses + 1\n\n        if s[p] < s[p + 1]:\n            s[p] = next_letter(s[p])\n            rotate(s, p + 1)\n            return left_presses + right_presses + 1\n\n        if s[p] > s[p + 1]:\n            s[p] = prev_letter(s[p])\n            rotate(s, p + 1)\n            return left_presses + right_presses + 1\n\n    return min_presses(s, p)"
    },
    {
        "number": 1326,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    f = [1] * (N + 1)\n    for i in range(2, N + 1):\n        for j in range(i, N + 1, i):\n            f[j] += 1\n    result = sum([i * f[i] for i in range(1, N + 1)])\n    return str(result)"
    },
    {
        "number": 1327,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    cakes = []\n    for i in range(N):\n        x, y, z = map(int, stdin.split()[3*i+2:3*i+5])\n        cakes.append((x, y, z))\n\n    max_value = 0\n    for i in range(1, 2**N):\n        selected_cakes = []\n        for j in range(N):\n            if i & (1 << j):\n                selected_cakes.append(cakes[j])\n\n        if len(selected_cakes) != M:\n            continue\n\n        total_beauty = sum(abs(x) for x, _, _ in selected_cakes)\n        total_tastiness = sum(abs(y) for _, y, _ in selected_cakes)\n        total_popularity = sum(abs(z) for _, _, z in selected_cakes)\n\n        value = total_beauty + total_tastiness + total_popularity\n        max_value = max(max_value, value)\n\n    return str(max_value)"
    },
    {
        "number": 1328,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_min_cost(N, M_a, M_b, packages):\n        min_cost = float('inf')\n        for i in range(2**N):\n            a_sum = 0\n            b_sum = 0\n            cost = 0\n            for j in range(N):\n                if (i >> j) & 1:\n                    a_sum += packages[j][0]\n                    b_sum += packages[j][1]\n                    cost += packages[j][2]\n            if a_sum * M_b == b_sum * M_a:\n                min_cost = min(min_cost, cost)\n        return min_cost\n\n    N, M_a, M_b = map(int, stdin.readline().split())\n    packages = []\n    for i in range(N):\n        a, b, c = map(int, stdin.readline().split())\n        packages.append((a, b, c))\n\n    if gcd(M_a, M_b) != 1:\n        return \"-1\"\n\n    min_cost = find_min_cost(N, M_a, M_b, packages)\n    return str(min_cost) if min_cost != float('inf') else \"-1\""
    },
    {
        "number": 1329,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    factorial = 1\n    for i in range(1, N+1):\n        factorial *= i\n\n    count = 0\n    for i in range(1, factorial+1):\n        divisor_count = 0\n        for j in range(1, i+1):\n            if i % j == 0:\n                divisor_count += 1\n        if divisor_count == 75:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1330,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mex(s: set) -> int:\n        for i in range(len(s)):\n            if i not in s:\n                return i\n        return len(s)\n\n    def find_team(students: List[int], clubs: List[int]) -> int:\n        team = set()\n        for i in range(len(students)):\n            if clubs[i] not in team:\n                team.add(clubs[i])\n        return mex(team)\n\n    def process_day(students: List[int], clubs: List[int], k: int) -> int:\n        students.pop(k - 1)\n        clubs.pop(k - 1)\n        return find_team(students, clubs)\n\n    n, m = map(int, stdin.readline().split())\n    potentials = list(map(int, stdin.readline().split()))\n    clubs = list(map(int, stdin.readline().split()))\n    d = int(stdin.readline())\n    k = list(map(int, stdin.readline().split()))\n\n    for i in range(d):\n        strength = process_day(potentials, clubs, k[i])\n        print(strength)"
    },
    {
        "number": 1331,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    alarm_clocks = list(map(int, stdin.split()[3:]))\n    alarm_clocks.sort()\n    \n    count = 0\n    for i in range(len(alarm_clocks) - k + 1):\n        if alarm_clocks[i+k-1] - alarm_clocks[i] >= m:\n            count += 1\n    \n    return str(len(alarm_clocks) - count)"
    },
    {
        "number": 1332,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c_1, c_2, c_3, c_4, c_5 = map(int, stdin.split())\n    b = max(c_1, c_2, c_3, c_4, c_5)\n    if b == 0:\n        return \"-1\"\n    elif c_1 == b and c_2 == b and c_3 == b and c_4 == b and c_5 == b:\n        return str(b)\n    else:\n        return \"-1\""
    },
    {
        "number": 1333,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    snake = \"\"\n    for i in range(1, n+1):\n        if i % 2 == 1:\n            snake += \"#\" * m\n        else:\n            snake += \".\" * m\n        if i < n:\n            snake += \"\\n\"\n    return snake"
    },
    {
        "number": 1334,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    letters = sorted(set(s))\n    t = \"\"\n    for letter in letters:\n        if s.index(letter) < k:\n            t += letter\n            k -= 1\n    return t"
    },
    {
        "number": 1335,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    m = 0\n    for i in range(n):\n        m += a[i]\n\n    d = round(100 * m / n)\n\n    interesting_solutions = 0\n    for i in range(n):\n        if a[i] == d:\n            interesting_solutions += 1\n\n    return str(interesting_solutions)"
    },
    {
        "number": 1336,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dolls = []\n    for i in range(n):\n        out, in_ = map(int, stdin.readline().strip().split())\n        dolls.append((out, in_))\n\n    dolls.sort(key=lambda x: x[1])\n\n    def is_big_enough(subset: List[int]) -> bool:\n        for i in range(len(subset)):\n            for j in range(i + 1, len(subset)):\n                if dolls[subset[j]][1] > dolls[subset[i]][0]:\n                    return False\n        return True\n\n    def extra_space(subset: List[int]) -> int:\n        space = 0\n        for i in range(len(subset)):\n            space += dolls[subset[i]][1] - dolls[subset[i]][0]\n        return space\n\n    def count_big_enough_subsets(n: int) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    subset = [i, j, k]\n                    if is_big_enough(subset):\n                        count += 1\n        return count\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                subset = [i, j, k]\n                if is_big_enough(subset):\n                    result += count_big_enough_subsets(n - 3)\n\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 1337,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, languages, m, audio_languages, subtitles_languages = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    languages = [int(x) for x in languages.split()]\n    audio_languages = [int(x) for x in audio_languages.split()]\n    subtitles_languages = [int(x) for x in subtitles_languages.split()]\n\n    max_very_pleased = 0\n    max_almost_satisfied = 0\n    max_movie_index = -1\n\n    for i in range(m):\n        very_pleased = 0\n        almost_satisfied = 0\n        for j in range(n):\n            if languages[j] == audio_languages[i] or languages[j] == subtitles_languages[i]:\n                very_pleased += 1\n            elif languages[j] == audio_languages[i] ^ languages[j] == subtitles_languages[i]:\n                almost_satisfied += 1\n\n        if very_pleased > max_very_pleased or (very_pleased == max_very_pleased and almost_satisfied > max_almost_satisfied):\n            max_very_pleased = very_pleased\n            max_almost_satisfied = almost_satisfied\n            max_movie_index = i\n\n    return str(max_movie_index + 1)"
    },
    {
        "number": 1338,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if 1 <= n <= 8:\n        return subproblem_b1(n, m)\n    else:\n        return subproblem_b2(n, m)\n\ndef"
    },
    {
        "number": 1339,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = []\n    for i in range(1, n+1):\n        l, r = map(int, stdin.split('\\n')[i].split())\n        segments.append((l, r))\n\n    for i, (l, r) in enumerate(segments, start=1):\n        covered = True\n        for l2, r2 in segments:\n            if l2 < l and r2 > r:\n                covered = False\n                break\n        if covered:\n            return str(i)\n\n    return \"-1\""
    },
    {
        "number": 1340,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = list(map(int, stdin.split()[1:]))\n\n    # Count the frequency of each color\n    color_freq = {}\n    for color in colors:\n        if color in color_freq:\n            color_freq[color] += 1\n        else:\n            color_freq[color] = 1\n\n    # Calculate the minimum number of operations\n    min_operations = 0\n    for color, freq in color_freq.items():\n        min_operations += (freq // 2) * 2\n\n    return str(min_operations)"
    },
    {
        "number": 1341,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    position = 0\n    for instruction in t:\n        if s[position] == instruction:\n            position += 1\n    return str(position + 1)"
    },
    {
        "number": 1342,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = stdin.split()\n    n = int(n)\n    balls = list(map(int, balls.split()))\n\n    # Calculate the maximum number of sets that can be formed\n    max_sets = sum(balls)\n\n    # Initialize the minimum number of sets to 1\n    min_sets = 1\n\n    # Check if the maximum number of sets is less than or equal to 1\n    if max_sets <= 1:\n        return str(max_sets)\n\n    # Check if the maximum number of sets is greater than 1\n    while min_sets < max_sets:\n        mid_sets = (min_sets + max_sets) // 2\n        if is_valid(balls, mid_sets):\n            min_sets = mid_sets + 1\n        else:\n            max_sets = mid_sets\n\n    return str(min_sets - 1)\n\n\ndef"
    },
    {
        "number": 1343,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    roads = []\n    for _ in range(m):\n        u, v, l = map(int, stdin.split()[-3:])\n        roads.append((u, v, l))\n\n    storages = list(map(int, stdin.split()[-k:])) if k > 0 else []\n\n    def dfs(city, visited, path_length, storage_city):\n        if city in visited:\n            return float('inf')\n        visited.add(city)\n        if city in storages:\n            return path_length\n        result = float('inf')\n        for u, v, l in roads:\n            if u == city:\n                result = min(result, dfs(v, visited, path_length + l, storage_city))\n            elif v == city:\n                result = min(result, dfs(u, visited, path_length + l, storage_city))\n        visited.remove(city)\n        return result\n\n    min_cost = float('inf')\n    for i in range(1, n + 1):\n        if i not in storages:\n            cost = dfs(i, set(), 0, None)\n            if cost != float('inf'):\n                min_cost = min(min_cost, cost)\n\n    return str(min_cost) if min_cost != float('inf') else \"-1\""
    },
    {
        "number": 1344,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    max_len = 1\n    current_len = 1\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n\n    return str(max(max_len, current_len))"
    },
    {
        "number": 1345,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *array = map(int, stdin.split())\n    result = []\n\n    for i in range(n):\n        if array[i] <= 0:\n            result.append(\"-\")\n        elif array[i] >= array[0]:\n            result.append(\"+\")\n        else:\n            result.append(\"-\")\n\n    return \"\".join(result)\n"
    },
    {
        "number": 1346,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        d, x, y = extended_gcd(b, a % b)\n        return d, y, x - (a // b) * y\n\n    def mod_inverse(a, m):\n        d, x, _ = extended_gcd(a, m)\n        if d != 1:\n            raise Exception(\"Inverse doesn't exist\")\n        return x % m\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def find_t(a, b, p):\n        h = [0] * (n + m)\n        for i in range(n):\n            h[i] = a[i]\n        for i in range(m):\n            h[i + n - 1] = b[i]\n\n        for i in range(n + m - 1, -1, -1):\n            if h[i] % p != 0:\n                return i\n\n    if not is_prime(p):\n        raise Exception(\"p is not prime\")\n\n    gcd_a = a[0]\n    for i in range(1, n):\n        gcd_a = gcd(gcd_a, a[i])\n\n    gcd_b = b[0]\n    for i in range(1, m):\n        gcd_b = gcd(gcd_b, b[i])\n\n    if gcd_a != 1 or gcd_b != 1:\n        raise Exception(\"Cumulative GCD of coefficients is not 1\")\n\n    t = find_t(a, b, p)\n    return str(t)"
    },
    {
        "number": 1347,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_synonyms(synonyms: List[str]) -> Dict[str, str]:\n        synonym_dict = {}\n        for synonym in synonyms:\n            x, y = synonym.split()\n            synonym_dict[x] = y\n            synonym_dict[y] = x\n        return synonym_dict\n\n    def replace_word(word: str, synonym_dict: Dict[str, str]) -> str:\n        if word in synonym_dict:\n            return synonym_dict[word]\n        return word\n\n    def replace_essay(essay: str, synonym_dict: Dict[str, str]) -> str:\n        return ' '.join([replace_word(word, synonym_dict) for word in essay.split()])\n\n    def count_r(essay: str) -> int:\n        return essay.lower().count('r')\n\n    def min_r_length(essay: str, synonym_dict: Dict[str, str]) -> Tuple[int, int]:\n        min_r = float('inf')\n        min_length = float('inf')\n        for i in range(len(synonym_dict)):\n            new_essay = replace_essay(essay, synonym_dict)\n            new_r = count_r(new_essay)\n            new_length = len(new_essay)\n            if new_r < min_r or (new_r == min_r and new_length < min_length):\n                min_r = new_r\n                min_length = new_length\n            essay = new_essay\n        return min_r, min_length\n\n    input_lines = stdin.split('\\n')\n    m = int(input_lines[0])\n    essay = input_lines[1]\n    n = int(input_lines[2])\n    synonyms = input_lines[3:]\n\n    synonym_dict = get_synonyms(synonyms)\n    min_r, min_length = min_r_length(essay, synonym_dict)\n\n    return f\"{min_r} {min_length}\""
    },
    {
        "number": 1348,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    d = list(map(int, stdin.split()[1].split()))\n\n    if k == 0:\n        return \"-1\"\n\n    graph = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if d[i] + d[j] == k:\n                graph[i][j] = graph[j][i] = 1\n\n    m = sum(sum(row) for row in graph) // 2\n    if m == 0:\n        return \"-1\"\n\n    result = [f\"{i + 1} {j + 1}\" for i in range(n) for j in range(i + 1, n) if graph[i][j] == 1]\n    return f\"{m}\\n{' '.join(result)}\""
    },
    {
        "number": 1349,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().strip().split())\n        taps = list(map(int, stdin.readline().strip().split()))\n        taps.sort()\n\n        watered = [False] * n\n        seconds = 0\n\n        for tap in taps:\n            if not watered[tap - 1]:\n                watered[tap - 1] = True\n                for i in range(tap - 1, max(-1, tap - k), -1):\n                    if not watered[i]:\n                        watered[i] = True\n                for i in range(tap + 1, min(n, tap + k), 1):\n                    if not watered[i]:\n                        watered[i] = True\n\n        while not all(watered):\n            seconds += 1\n            for i in range(n):\n                if not watered[i]:\n                    watered[i] = True\n\n        result.append(seconds)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1350,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    \n    freq = [0] * k\n    for char in s:\n        freq[ord(char) - ord('A')] += 1\n    \n    max_length = 0\n    for i in range(len(s)):\n        current_freq = freq.copy()\n        current_length = 1\n        for j in range(i + 1, len(s)):\n            current_freq[ord(s[j]) - ord('A')] -= 1\n            if all(f == 0 for f in current_freq):\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                break\n    \n    return str(max_length)"
    },
    {
        "number": 1351,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    for i in range(l, r+1):\n        if len(set(str(i))) == len(str(i)):\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 1352,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def f(l, r):\n        return sorted(filter(lambda x: x < l or x > r, a))\n\n    count = 0\n    for l in range(1, x + 1):\n        for r in range(l, x + 1):\n            if f(l, r) == sorted(f(l, r)):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1353,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    min_sum = 0\n    one_ride_tickets = n // m\n    min_sum += one_ride_tickets * a\n    min_sum += (n % m) * a\n    min_sum = min(min_sum, n * b)\n    return str(min_sum)"
    },
    {
        "number": 1354,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, m = map(int, stdin.split()[:4])\n    ships = [i for i in range(1, n + 1, a)][:k]\n    shots = list(map(int, stdin.split()[4:]))\n\n    for shot in shots:\n        if shot in ships:\n            return str(shots.index(shot) + 1)\n\n    return \"-1\""
    },
    {
        "number": 1355,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    n_gon = [tuple(map(float, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    lines = [tuple(map(float, line.split())) for line in stdin.split('\\n')[n+1:]]\n    \n    def is_inside(point, polygon):\n        x, y = point\n        n = len(polygon)\n        inside = False\n        x1, y1 = polygon[0]\n        for i in range(1, n+1):\n            x2, y2 = polygon[i % n]\n            if y1 <= y < y2 or y2 <= y < y1:\n                x3 = (x1 + x2) / 2\n                if x < x3:\n                    inside = not inside\n            x1, y1 = x2, y2\n        return inside\n    \n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n    \n    def intersection(a1, a2, b1, b2):\n        x1, y1 = a1\n        x2, y2 = a2\n        x3, y3 = b1\n        x4, y4 = b2\n        if (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4) == 0:\n            return None\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))\n        return (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n    \n    def common_part(line1, line2):\n        a1, a2 = line1\n        b1, b2 = line2\n        intersection_point = intersection(a1, a2, b1, b2)\n        if intersection_point is None:\n            return 0\n        if is_inside(intersection_point, [a1, a2]) and is_inside(intersection_point, [b1, b2]):\n            return distance(intersection_point, a1)\n        return 0\n    \n    result = [common_part(line, (n_gon[i], n_gon[(i+1) % n]) if n_gon[i] < n_gon[(i+1) % n] else (n_gon[(i+1) % n], n_gon[i])) for i in range(n)]\n    return '\\n'.join(map(str, result))\n\ninput_data = '''4 3\n0 0\n1 0\n1 1\n0 1\n0 0 1 1\n0 0 0 1\n0 0 1 -1'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 1356,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    s.sort()\n    i = 0\n    j = n - 1\n    while i < j:\n        if s[i] == 'a':\n            i += 1\n        else:\n            j -= 1\n    mid = i\n    left = s[:mid]\n    right = s[mid:]\n    return max(len(left), len(right))"
    },
    {
        "number": 1357,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    time = 0\n    visited = [False] * (n + 1)\n    visited[1] = True\n\n    for i in range(m):\n        if not visited[a[i]]:\n            time += abs(a[i] - a[i - 1])\n            visited[a[i]] = True\n\n    return str(time)\n"
    },
    {
        "number": 1358,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    strings = []\n    for _ in range(k):\n        string, beauty = stdin.split()\n        strings.append((string, int(beauty)))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def max_beauty(strings: List[Tuple[str, int]]) -> int:\n        max_beauty = 0\n        for i in range(len(strings)):\n            for j in range(len(strings)):\n                if i != j:\n                    s1, b1 = strings[i]\n                    s2, b2 = strings[j]\n                    s = s1 + s2\n                    if is_palindrome(s):\n                        max_beauty = max(max_beauty, b1 + b2)\n        return max_beauty\n\n    return str(max_beauty(strings))"
    },
    {
        "number": 1359,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    def is_rhombus(a, b, c, d):\n        return (a, b) in roads and (b, c) in roads and (a, d) in roads and (d, c) in roads\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    if is_rhombus(i, j, k, l):\n                        count += 1\n                    if is_rhombus(i, j, l, k):\n                        count += 1\n    \n    return str(count)"
    },
    {
        "number": 1360,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    exams = []\n    for i in range(1, n + 1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        exams.append((a, b))\n\n    exams.sort(key=lambda x: x[1])\n    last_day = 0\n    for exam in exams:\n        last_day = max(last_day, exam[1])\n\n    return str(last_day)"
    },
    {
        "number": 1361,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    max_difficulty = 0\n    for i in range(1, n - 1):\n        max_difficulty = max(max_difficulty, abs(heights[i] - heights[i + 1]))\n\n    min_difficulty = max_difficulty\n    for i in range(1, n - 1):\n        new_heights = heights[:i] + heights[i + 1:]\n        new_difficulty = max(abs(new_heights[j] - new_heights[j + 1]) for j in range(len(new_heights) - 1))\n        min_difficulty = min(min_difficulty, new_difficulty)\n\n    return str(min_difficulty)"
    },
    {
        "number": 1362,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, m = map(int, stdin.split()[:3])\n    tops = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:3+n]]\n    tops.sort(key=lambda x: x[0])\n    balance = 0\n    negative_days = 0\n    \n    for i in range(m):\n        balance -= p\n        for j in range(n):\n            if tops[j][0] == i+1:\n                balance += tops[j][1]\n        if balance < 0:\n            negative_days += 1\n    \n    return str(negative_days)"
    },
    {
        "number": 1364,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sushi_types = stdin.split()\n    n = int(n)\n    sushi_types = [int(x) for x in sushi_types]\n\n    tuna_count = sushi_types.count(1)\n    eel_count = sushi_types.count(2)\n\n    if tuna_count > eel_count:\n        tuna_count, eel_count = eel_count, tuna_count\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if sushi_types[i:j].count(1) == tuna_count and sushi_types[i:j].count(2) == eel_count:\n                max_length = max(max_length, j - i)\n\n    return str(max_length)"
    },
    {
        "number": 1365,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return str((2**n - 1) % (10**9 + 7))\n    elif k == 1:\n        return str((2**n - 1) % (10**9 + 7))\n    else:\n        return str((2**(n - k) - 1) % (10**9 + 7))"
    },
    {
        "number": 1366,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bottles = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    unopenable_bottles = 0\n    for bottle in bottles:\n        if not any(bottle[0] == other[1] or bottle[1] == other[0] for other in bottles):\n            unopenable_bottles += 1\n\n    return str(unopenable_bottles)"
    },
    {
        "number": 1367,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    watched_episodes = set(map(int, stdin.split('\\n')[1].split()))\n    unwatched_episode = [i for i in range(1, n+1) if i not in watched_episodes][0]\n    return str(unwatched_episode)"
    },
    {
        "number": 1368,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split()[:3])\n    values = list(map(int, stdin.split()[3:]))\n\n    values.sort(reverse=True)\n    max_mean = sum(values[:A]) / A\n    count = 1\n\n    for i in range(A, B + 1):\n        mean = (sum(values[:i]) + sum(values[i:])) / (N - i + 1)\n        if abs(mean - max_mean) < 1e-6:\n            count += 1\n\n    return f\"{max_mean:.6f}\\n{count}\""
    },
    {
        "number": 1369,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    x_center = sum(x for x, y in points) / len(points)\n    y_center = sum(y for x, y in points) / len(points)\n    radius = max(abs(x - x_center), abs(y - y_center))\n    return f\"{radius:.6f}\""
    },
    {
        "number": 1370,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split()[:3])\n    S = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def count_white_squares(i: int, j: int) -> int:\n        count = 0\n        for k in range(i, i + H):\n            for l in range(j, j + W):\n                count += S[k][l]\n        return count\n\n    def cut_bar(i: int, j: int) -> int:\n        return count_white_squares(0, 0) + count_white_squares(i, j)\n\n    min_cuts = float('inf')\n    for i in range(1, H):\n        for j in range(1, W):\n            if cut_bar(i, j) <= K:\n                min_cuts = min(min_cuts, i + j - 2)\n\n    return str(min_cuts)"
    },
    {
        "number": 1371,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin)\n    MOD = 10**9 + 7\n    dp = [0] * (S + 1)\n    dp[0] = 1\n    dp[1] = 0\n    dp[2] = 1\n    dp[3] = 1\n\n    for i in range(4, S + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD\n\n    return str(dp[S])"
    },
    {
        "number": 1372,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, N = map(int, stdin.split()[:2])\n    spells = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    total_magic_points = 0\n    for A, B in spells:\n        if H - A >= 0:\n            H -= A\n            total_magic_points += B\n        else:\n            break\n\n    return str(total_magic_points)"
    },
    {
        "number": 1373,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    result = 0\n    for i in range(K, N+2):\n        result += (10**100) * (i - K + 1)\n        result %= MOD\n    return str(result)"
    },
    {
        "number": 1374,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a = stdin.split()\n    N = int(N)\n    a = list(map(int, a.split()))\n\n    def median(l: int, r: int) -> int:\n        b = sorted(a[l:r+1])\n        return b[len(b)//2]\n\n    m = [median(i, j) for i in range(N) for j in range(i, N)]\n    m.sort()\n\n    if len(m) % 2 == 0:\n        return str((m[len(m)//2] + m[len(m)//2 - 1]) / 2)\n    else:\n        return str(m[len(m)//2])"
    },
    {
        "number": 1375,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    count = 0\n    for i in range(2, n - 1):\n        left_sum = sum(a[:i])\n        right_sum = sum(a[i:])\n        if left_sum == right_sum:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1376,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    sasha_dist = 0\n    dima_dist = 0\n\n    for i in range(n):\n        sasha_dist += a.index(i + 1) + 1\n        dima_dist += a.index(n - i) + 1\n\n    return str(sasha_dist + dima_dist)"
    },
    {
        "number": 1377,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, radii = map(int, stdin.split())\n    radii.sort()\n    pillars = [[] for _ in range(n)]\n\n    for i in range(n):\n        pillars[i].append(radii[i])\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and (len(pillars[j]) == 0 or pillars[j][-1] < radii[i]):\n                pillars[j].append(radii[i])\n                break\n        else:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 1378,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    chosen_points = list(map(int, stdin.splitlines()[1].split()))\n\n    # Calculate the area of the polygon\n    area = 0\n    for i in range(n):\n        area += chosen_points[i] * (i + 1)\n\n    # Calculate the area of the polygon with the chosen points\n    max_area = 0\n    result = []\n    for i in range(n):\n        new_area = area - chosen_points[i] * (i + 1)\n        if new_area > max_area:\n            max_area = new_area\n            result = [chosen_points[i]]\n        elif new_area == max_area:\n            result.append(chosen_points[i])\n\n    # Return the chosen points\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1379,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[0].split())\n    minutes = list(map(int, stdin.split()[1].split()))\n    days = [0] * n\n    days_count = 1\n    last_break = 0\n\n    for i in range(n):\n        if minutes[i] - last_break >= d:\n            days[i] = days_count\n            last_break = minutes[i]\n        else:\n            days_count += 1\n            days[i] = days_count\n            last_break = minutes[i]\n\n    return str(days_count) + \"\\n\" + \" \".join(map(str, days))\n\ninput_data = input()\nprint(solution(input_data)) "
    },
    {
        "number": 1380,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    heights = list(map(int, stdin.split()[1].split()))\n\n    def is_beautiful(heights: List[int], k: int) -> bool:\n        for i in range(len(heights) - 1):\n            if heights[i] + 1 - heights[i] != k:\n                return False\n        return True\n\n    def find_min_actions(heights: List[int], k: int) -> int:\n        actions = []\n        for i in range(len(heights)):\n            if heights[i] + 1 - heights[i] == k:\n                continue\n            elif heights[i] + 1 - heights[i] > k:\n                actions.append((\"-\", i, heights[i] - k))\n            else:\n                actions.append((\"+\", i, k - heights[i]))\n        return actions\n\n    if is_beautiful(heights, k):\n        return \"0\\n\"\n    else:\n        actions = find_min_actions(heights, k)\n        result = str(len(actions)) + \"\\n\"\n        for action in actions:\n            result += action[0] + \" \" + str(action[1]) + \" \" + str(action[2]) + \"\\n\"\n        return result"
    },
    {
        "number": 1381,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, s, p = map(int, stdin.split())\n    packs_needed = (n * k) // s\n    return str(packs_needed)"
    },
    {
        "number": 1382,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def find_odd_cycles(graph: List[List[int]]) -> List[List[int]]:\n        def dfs(node: int, path: List[int], visited: Set[int], cycles: List[List[int]]) -> None:\n            visited.add(node)\n            path.append(node)\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    dfs(neighbor, path, visited, cycles)\n                elif neighbor != path[-1]:\n                    cycle = []\n                    cycle_node = neighbor\n                    while cycle_node != node:\n                        cycle.append(cycle_node)\n                        cycle_node = path[path.index(cycle_node) - 1]\n                    cycle.append(node)\n                    cycles.append(cycle)\n\n            path.pop()\n            visited.remove(node)\n\n        cycles = []\n        visited = set()\n        for node in range(n):\n            if node not in visited:\n                dfs(node, [], visited, cycles)\n\n        return cycles\n\n    def count_odd_cycles(graph: List[List[int]]) -> int:\n        cycles = find_odd_cycles(graph)\n        return len(cycles)\n\n    def count_odd_cycles_with_t_edges(graph: List[List[int]], t: int) -> int:\n        def add_edge(node1: int, node2: int, graph: List[List[int]]) -> List[List[int]]:\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n            return graph\n\n        def is_odd_cycle(cycle: List[int]) -> bool:\n            return len(cycle) % 2 == 1\n\n        def is_valid_cycle(cycle: List[int]) -> bool:\n            return all(cycle.count(node) <= 1 for node in range(n))\n\n        def is_valid_graph(graph: List[List[int]]) -> bool:\n            return all(len(edges) == len(set(edges)) for edges in graph)\n\n        def count_odd_cycles_with_t_edges_helper(graph: List[List[int]], t: int, current_cycle: List[int], visited: Set[int]) -> int:\n            if t == 0:\n                return 0\n            if not current_cycle:\n                return count_odd_cycles_with_t_edges_helper(graph, t - 1, [0], set())\n            if len(current_cycle) == 1:\n                for node in range(n):\n                    if node not in visited:\n                        visited.add(node)\n                        new_cycle = current_cycle + [node]\n                        if is_odd_cycle(new_cycle) and is_valid_cycle(new_cycle):\n                            count = count_odd_cycles_with_t_edges_helper(graph, t - 1, new_cycle, visited)\n                            if count:\n                                return count\n                return 0\n            else:\n                for neighbor in graph[current_cycle[-1]]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        new_cycle = current_cycle + [neighbor]\n                        if is_odd_cycle(new_cycle) and is_valid_cycle(new_cycle):\n                            count = count_odd_cycles_with_t_edges_helper(graph, t - 1, new_cycle, visited)\n                            if count:\n                                return count\n                return 0\n\n        graph = [[0] * n for _ in range(n)]\n        for a, b in edges:\n            add_edge(a - 1, b - 1, graph)\n\n        if not is_valid_graph(graph):\n            return 0\n\n        return count_odd_cycles_with_t_edges_helper(graph, t, [], set())\n\n    t = count_odd_cycles(edges)\n    w = count_odd_"
    },
    {
        "number": 1383,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n\n    def is_permutation(x: int) -> bool:\n        for i in range(n):\n            if (a[i] + x) % m != b[i]:\n                return False\n        return True\n\n    x = 0\n    while not is_permutation(x):\n        x += 1\n\n    return str(x)"
    },
    {
        "number": 1384,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    games = stdin.split()[1:]\n    max_games = 0\n    current_games = 0\n\n    for i in range(n):\n        if games[i] == '1':\n            current_games += 1\n            max_games = max(max_games, current_games)\n        else:\n            current_games = 0\n\n    return str(max_games)"
    },
    {
        "number": 1385,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lexemes = []\n    in_quotes = False\n    current_lexeme = \"\"\n\n    for char in stdin:\n        if char == \"\\\"\":\n            in_quotes = not in_quotes\n        elif char == \" \" and not in_quotes:\n            if current_lexeme:\n                lexemes.append(current_lexeme)\n                current_lexeme = \"\"\n        else:\n            current_lexeme += char\n\n    if current_lexeme:\n        lexemes.append(current_lexeme)\n\n    result = \"\"\n    for i, lexeme in enumerate(lexemes):\n        result += f\"<{lexeme}>\"\n        if i < len(lexemes) - 1:\n            result += \"\\n\"\n\n    return result"
    },
    {
        "number": 1386,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    MOD = 998244353\n    dp = [[0] * (h + 1) for _ in range(w + 1)]\n    dp[0][0] = 1\n    for i in range(1, w + 1):\n        for j in range(1, h + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n    return str(dp[w][h])"
    },
    {
        "number": 1387,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    visited = [False] * n\n    visited[0] = True\n\n    for i in range(n - 1):\n        if visited[i] and i + a[i] < n:\n            visited[i + a[i]] = True\n\n    if visited[t - 1]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1388,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent):\n        nonlocal total_cost\n        if visited[node]:\n            return\n        visited[node] = True\n        if node == 1:\n            if b[node] == c[node]:\n                return\n            else:\n                total_cost += a[node]\n                b[node] = c[node]\n                return\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node)\n\n    n = int(stdin.readline())\n    a = []\n    b = []\n    c = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        line = stdin.readline().split()\n        a.append(int(line[0]))\n        b.append(int(line[1]))\n        c.append(int(line[2]))\n        for j in range(i + 1, n + 1):\n            line = stdin.readline().split()\n            if int(line[0]) == i and int(line[1]) == j:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = [False] * (n + 1)\n    total_cost = 0\n    dfs(1, -1)\n\n    if all(b[i] == c[i] for i in range(1, n + 1)):\n        return str(total_cost)\n    else:\n        return \"-1\""
    },
    {
        "number": 1389,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    feature = [list(line.strip()) for line in stdin.splitlines()[n:]]\n    value = 0\n    for i in range(n):\n        for j in range(m):\n            if feature[i][j] == \"W\":\n                value += 1\n            else:\n                value -= 1\n    return str(value)"
    },
    {
        "number": 1390,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    puzzles = list(map(int, stdin.split()[2:]))\n\n    puzzles.sort()\n    max_diff = puzzles[-1] - puzzles[0]\n\n    for i in range(len(puzzles) - n + 1):\n        diff = puzzles[i + n - 1] - puzzles[i]\n        if diff < max_diff:\n            max_diff = diff\n\n    return str(max_diff)"
    },
    {
        "number": 1391,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, p = map(int, stdin.split())\n    b = list(map(int, b.split()))\n    p = list(map(int, p.split()))\n\n    b.sort(reverse=True)\n    p.sort(reverse=True)\n\n    rented_bikes = 0\n    total_personal_money = 0\n\n    for i in range(n):\n        if rented_bikes == m:\n            break\n        if b[i] >= p[rented_bikes]:\n            rented_bikes += 1\n            total_personal_money += b[i] - p[rented_bikes]\n\n    return str(rented_bikes) + \" \" + str(total_personal_money)\n"
    },
    {
        "number": 1392,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    for num in a:\n        if all(digit <= k for digit in str(num)):\n            count += 1\n    return str(count)"
    },
    {
        "number": 1393,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s_len, t_len = len(s), len(t)\n    yay_count, whoops_count = 0, 0\n\n    for i in range(s_len):\n        if s[i] == t[i]:\n            yay_count += 1\n        elif s[i].lower() == t[i].lower():\n            whoops_count += 1\n\n    return f\"{yay_count} {whoops_count}\""
    },
    {
        "number": 1394,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    s_prime = s.replace(\"a\", \"\")\n    t = s + s_prime\n    if t == s:\n        return s\n    else:\n        return \":(\""
    },
    {
        "number": 1395,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    num = int(stdin[0])\n    m = int(stdin[1])\n\n    min_remainder = num % m\n    for i in range(1, len(str(num))):\n        shifted_num = int(str(num)[i:] + str(num)[:i])\n        remainder = shifted_num % m\n        if remainder < min_remainder:\n            min_remainder = remainder\n\n    return str(min_remainder)"
    },
    {
        "number": 1396,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[0].split())\n    balls = list(map(int, stdin.split()[1].split()))\n\n    max_balls = 0\n    for i in range(n):\n        if balls[i] == x:\n            left = i - 1\n            right = i + 1\n            while left >= 0 and right < n and balls[left] == balls[right]:\n                left -= 1\n                right += 1\n            max_balls += right - left - 1\n\n    return str(max_balls)"
    },
    {
        "number": 1397,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    blocked_pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(city, visited, path, graph):\n        if len(path) > 2:\n            return False\n        if city == n:\n            return True\n        visited[city] = True\n        for neighbor in graph[city]:\n            if not visited[neighbor]:\n                path.append(neighbor)\n                if dfs(neighbor, visited, path, graph):\n                    return True\n                path.pop()\n        visited[city] = False\n        return False\n\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = blocked_pairs[i]\n        graph[a].append(b)\n        graph[b].append(a)\n\n    min_roads = n - 1\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        path = [i]\n        if dfs(i, visited, path, graph):\n            min_roads = min(min_roads, len(path) - 1)\n\n    result = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in blocked_pairs and (j, i) not in blocked_pairs:\n                result.append((i, j))\n\n    return str(min_roads) + '\\n' + '\\n'.join([' '.join(map(str, edge)) for edge in result[:min_roads]])"
    },
    {
        "number": 1398,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, measurements = stdin.split('\\n')\n    n = int(n)\n    measurements = list(map(int, measurements.split()))\n    \n    min_result = min(measurements)\n    max_result = max(measurements)\n    \n    if max_result <= 2 * min_result:\n        return \"0\"\n    \n    min_to_remove = float('inf')\n    max_to_remove = float('inf')\n    \n    for i in range(n):\n        if measurements[i] == min_result:\n            min_to_remove = min(min_to_remove, i)\n        elif measurements[i] == max_result:\n            max_to_remove = min(max_to_remove, i)\n    \n    return str(min(min_to_remove, max_to_remove))"
    },
    {
        "number": 1399,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    points = set()\n    for segment in segments:\n        Ax, Ay, Bx, By = segment\n        if Ax == Bx:\n            points.update(range(min(Ay, By), max(Ay, By) + 1))\n        elif Ay == By:\n            points.update(range(min(Ax, Bx), max(Ax, Bx) + 1))\n        else:\n            if Ax > Bx:\n                Ax, Bx = Bx, Ax\n                Ay, By = By, Ay\n            k = (By - Ay) / (Bx - Ax)\n            b = By - k * Bx\n            for x in range(Ax, Bx + 1):\n                y = k * x + b\n                points.add((x, int(y)))\n\n    return str(len(points))"
    },
    {
        "number": 1400,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    def expected_crosswords(t: List[int], T: int) -> int:\n        dp = [0] * (T + 1)\n        dp[0] = 1\n\n        for i in range(1, T + 1):\n            for j in range(1, n + 1):\n                if i - t[j - 1] >= 0:\n                    dp[i] += dp[i - t[j - 1]]\n\n        return dp[T]\n\n    p = expected_crosswords(t, T)\n    q = expected_crosswords(t, T + 1) - p\n\n    result = p * pow(q, -1, 10**9 + 7)\n\n    return str(result)"
    },
    {
        "number": 1401,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[int], List[Tuple[int, int]]]:\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        edges = []\n        for _ in range(n - 1):\n            p, c = map(int, stdin.readline().split())\n            edges.append((p, c))\n        return n, a, edges\n\n    def build_tree(n: int, a: List[int], edges: List[Tuple[int, int]]) -> List[List[int]]:\n        tree = [[] for _ in range(n + 1)]\n        for p, c in edges:\n            tree[p].append((c, p))\n        return tree\n\n    def dfs(tree: List[List[int]], visited: List[bool], sad_vertices: List[bool], vertex: int) -> None:\n        visited[vertex] = True\n        for c, p in tree[vertex]:\n            if not visited[p]:\n                dfs(tree, visited, sad_vertices, p)\n            sad_vertices[vertex] |= sad_vertices[p] and c > a[p]\n\n    def count_leaves(tree: List[List[int]]) -> int:\n        count = 0\n        for vertex in range(1, len(tree)):\n            if not tree[vertex]:\n                count += 1\n        return count\n\n    n, a, edges = read_input()\n    tree = build_tree(n, a, edges)\n    visited = [False] * (n + 1)\n    sad_vertices = [False] * (n + 1)\n    dfs(tree, visited, sad_vertices, 1)\n    leaves_to_remove = count_leaves(tree) - sum(sad_vertices)\n    return str(leaves_to_remove)"
    },
    {
        "number": 1402,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    template1 = stdin.split('\\n')[1]\n    template2 = stdin.split('\\n')[2]\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                count += 1\n\n    return str(count % 1000000007)"
    },
    {
        "number": 1403,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort(reverse=True)\n\n    count = 0\n    for i in range(len(a)):\n        if a[i] <= K:\n            count += 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 1404,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    array = list(map(int, stdin.split()[1:]))\n\n    def restore(i: int) -> int:\n        if i == 0:\n            return max(1, array[1])\n        elif i == n - 1:\n            return max(1, array[n - 2])\n        else:\n            return max(1, min(restore(i - 1), restore(i + 1)))\n\n    result = 1\n    for i in range(n):\n        if array[i] == -1:\n            result *= restore(i)\n            result %= 998244353\n\n    return str(result)"
    },
    {
        "number": 1405,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_fibonacci_ish(fib_seq: List[int]) -> bool:\n        if len(fib_seq) < 2:\n            return False\n        a, b = fib_seq[:2]\n        for i in range(2, len(fib_seq)):\n            if fib_seq[i] != a + b:\n                return False\n            a, b = b, a + b\n        return True\n\n    def longest_fibonacci_ish_prefix(a: List[int]) -> int:\n        max_len = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                fib_seq = a[i:j + 1]\n                if is_fibonacci_ish(fib_seq):\n                    max_len = max(max_len, len(fib_seq))\n        return max_len\n\n    return str(longest_fibonacci_ish_prefix(a))"
    },
    {
        "number": 1406,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    if n > k * d:\n        return \"-1\"\n\n    result = []\n    for i in range(d):\n        buses = [j for j in range(1, k + 1)]\n        random.shuffle(buses)\n        result.append(\" \".join(str(buses[j % len(buses)] + 1) for j in range(n)))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1407,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_prime_row(row: list) -> bool:\n        return all(is_prime(num) for num in row)\n\n    def is_prime_col(col: list) -> bool:\n        return all(is_prime(matrix[i][j]) for i in range(n))\n\n    def count_moves(matrix: list) -> int:\n        moves = 0\n        for i in range(n):\n            for j in range(m):\n                if not is_prime(matrix[i][j]):\n                    matrix[i][j] += 1\n                    moves += 1\n                    if is_prime_row(matrix[i]) or is_prime_col(matrix[j]):\n                        return moves\n        return moves\n\n    return str(count_moves(matrix))"
    },
    {
        "number": 1408,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    books = []\n    for i in range(1, n+1):\n        t, w = map(int, stdin.split('\\n')[i].split())\n        books.append((t, w))\n\n    books.sort(key=lambda x: x[0])\n\n    total_thickness = 0\n    for i in range(n):\n        if books[i][0] == 1:\n            total_thickness += books[i][1]\n        else:\n            break\n\n    return str(total_thickness)"
    },
    {
        "number": 1409,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    participants = list(map(int, input().split()))\n\n    # Count the number of teams that can be formed with each participant\n    team_counts = [0] * n\n    for participant in participants:\n        for i in range(min(participant, 5)):\n            team_counts[i] += 1\n\n    # Calculate the maximum number of teams that can be formed\n    max_teams = 0\n    for count in team_counts:\n        max_teams += count // 3\n\n    # Check if the maximum number of teams is at least k\n    if max_teams >= k:\n        return str(max_teams)\n    else:\n        return \"0\""
    },
    {
        "number": 1410,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, colors, vertex, color, visited, cost):\n        visited[vertex] = True\n        colors[vertex] = color\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                dfs(graph, colors, neighbor, (color + 1) % 3, visited, cost)\n                cost[0] += min(c1[vertex], c2[neighbor], c3[neighbor])\n\n    n = int(stdin.readline())\n    c1 = list(map(int, stdin.readline().split()))\n    c2 = list(map(int, stdin.readline().split()))\n    c3 = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    colors = [0] * n\n    visited = [False] * n\n    cost = [0]\n    dfs(graph, colors, 0, 0, visited, cost)\n\n    if any(colors[i] == colors[j] and colors[j] == colors[k] for i in range(n) for j in range(i + 1, n) for k in range(j + 1, n)):\n        return \"-1\"\n\n    return str(cost[0]) + \"\\n\" + \" \".join(map(str, colors))"
    },
    {
        "number": 1411,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, S = map(int, lines[0].split())\n    pizza_types = [0, 0]\n    total_happiness = 0\n\n    for i in range(1, N + 1):\n        s, a, b = map(int, lines[i].split())\n        pizza_types[0] += s // S\n        pizza_types[1] += s // S\n        total_happiness += a * (s // S) + b * (s // S)\n\n    return str(total_happiness)"
    },
    {
        "number": 1412,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    coupons = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[2:])\n        coupons.append((l, r))\n\n    def count_products(coupons, product_id):\n        count = 0\n        for coupon in coupons:\n            if coupon[0] <= product_id <= coupon[1]:\n                count += 1\n        return count\n\n    max_products = 0\n    chosen_coupons = []\n    for i in range(n):\n        for j in range(i+1, n):\n            product_id = coupons[i][0]\n            count = count_products([coupons[i], coupons[j]], product_id)\n            if count > max_products:\n                max_products = count\n                chosen_coupons = [i+1, j+1]\n\n    return str(max_products) + \"\\n\" + \" \".join(map(str, chosen_coupons))"
    },
    {
        "number": 1413,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    even_substrings = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if int(substring) % 2 == 0:\n                even_substrings += 1\n\n    return str(even_substrings)"
    },
    {
        "number": 1414,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(input()) for _ in range(n)]\n\n    def dfs(x: int, y: int, visited: set) -> int:\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return 0\n\n        if table[x][y] == \"D\":\n            return dfs(x, y - 1, visited) + dfs(x - 1, y, visited) + dfs(x, y + 1, visited) + dfs(x + 1, y, visited)\n        elif table[x][y] == \"I\":\n            return dfs(x, y - 1, visited) + dfs(x + 1, y, visited)\n        elif table[x][y] == \"M\":\n            return dfs(x, y - 1, visited) + dfs(x - 1, y, visited)\n        elif table[x][y] == \"A\":\n            return dfs(x, y - 1, visited) + dfs(x + 1, y, visited)\n        else:\n            return 0\n\n    max_count = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == \"D\":\n                count = dfs(i, j, set())\n                max_count = max(max_count, count)\n\n    if max_count == 0:\n        return \"Poor Dima!\"\n    elif max_count == float('inf'):\n        return \"Poor Inna!\"\n    else:\n        return max_count"
    },
    {
        "number": 1415,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, x_0, y_0, s = stdin.split()\n    x = int(x)\n    y = int(y)\n    x_0 = int(x_0)\n    y_0 = int(y_0)\n    s = s.strip()\n\n    def is_valid_move(x: int, y: int, x_0: int, y_0: int, direction: str) -> bool:\n        if direction == 'L':\n            return 0 <= y - 1 < y\n        elif direction == 'R':\n            return 0 <= y + 1 < y\n        elif direction == 'U':\n            return 0 <= x - 1 < x\n        elif direction == 'D':\n            return 0 <= x + 1 < x\n        else:\n            return False\n\n    def move(x: int, y: int, direction: str) -> tuple[int, int]:\n        if direction == 'L':\n            return x, y - 1\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'U':\n            return x - 1, y\n        elif direction == 'D':\n            return x + 1, y\n        else:\n            return x, y\n\n    def is_mine_position(x: int, y: int, x_0: int, y_0: int, s: str) -> bool:\n        x_current, y_current = x_0, y_0\n        for direction in s:\n            if not is_valid_move(x_current, y_current, x_0, y_0, direction):\n                return False\n            x_current, y_current = move(x_current, y_current, direction)\n        return x_current == x and y_current == y\n\n    result = [0] * (len(s) + 1)\n    for k in range(len(s) + 1):\n        if not is_mine_position(x_0, y_0, x_0, y_0, s[:k]):\n            result[k] = 1\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 1416,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    cups = list(map(int, stdin.split()))\n    girls = cups[:n]\n    boys = cups[n:]\n    girls.sort(reverse=True)\n    boys.sort(reverse=True)\n    total_water = 0\n    for i in range(n):\n        total_water += min(girls[i], boys[i])\n    return str(total_water)"
    },
    {
        "number": 1417,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    \n    total_permutations = n * factorial\n    distinct_subarrays = 0\n    \n    for i in range(1, total_permutations + 1):\n        for j in range(i + 1, total_permutations + 1):\n            distinct_subarrays += 1\n    \n    return str(distinct_subarrays % 998244353)"
    },
    {
        "number": 1418,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [0] * (n + 1)\n    a[1] = 1\n    for i in range(2, n + 1):\n        a[i] = a[i - 1] + 1\n        for j in range(2, i):\n            if i % j == 0 and a[j] == a[i]:\n                a[i] += 1\n    return \" \".join(str(x) for x in a[1:])"
    },
    {
        "number": 1419,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, text = stdin.split('\\n')\n    k = int(k)\n    words = text.split()\n    width = 0\n    current_line = 0\n    current_word = 0\n\n    while current_line < k and current_word < len(words):\n        word = words[current_word]\n        if '-' in word:\n            hyphen_index = word.index('-')\n            if current_line + 1 < k:\n                width = max(width, len(word[:hyphen_index]) + len(word[hyphen_index:]) + 1)\n                current_line += 1\n            else:\n                width = max(width, len(word[:hyphen_index]) + len(word[hyphen_index:]))\n                break\n        else:\n            if current_line + 1 < k:\n                width = max(width, len(word) + 1)\n                current_line += 1\n            else:\n                width = max(width, len(word))\n                break\n        current_word += 1\n\n    return str(width)"
    },
    {
        "number": 1420,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split()[0:2])\n    lanterns = list(map(int, stdin.split()[2:]))\n\n    # Sort the lanterns in ascending order\n    lanterns.sort()\n\n    # Initialize the minimum light radius\n    d = float('inf')\n\n    # Iterate through the lanterns and update the minimum light radius\n    for i in range(n):\n        if i == 0:\n            d = min(d, lanterns[i] - 0)\n        elif i == n - 1:\n            d = min(d, l - lanterns[i])\n        else:\n            d = min(d, (lanterns[i] - lanterns[i - 1]) / 2)\n\n    return f\"{d:.9f}\""
    },
    {
        "number": 1421,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_roots(edges):\n        roots = set(range(1, n + 1))\n        for u, v in edges:\n            if u in roots:\n                roots.remove(u)\n            if v in roots:\n                roots.remove(v)\n        return roots\n\n    def find_max_pleasantness(gifts, edges):\n        pleasantness_sum = 0\n        for u, v in edges:\n            if u in gifts and v in gifts:\n                return \"Impossible\"\n            pleasantness_sum += a[u - 1]\n            pleasantness_sum += a[v - 1]\n        return pleasantness_sum\n\n    n, *a = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    roots = find_roots(edges)\n    if len(roots) != 1:\n        return \"Impossible\"\n\n    gifts = set(roots)\n    for u, v in edges:\n        if u in gifts:\n            gifts.add(v)\n        elif v in gifts:\n            gifts.add(u)\n\n    return find_max_pleasantness(gifts, edges)"
    },
    {
        "number": 1422,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    weights = [int(c) for c in stdin]\n    m = int(input())\n\n    def can_put_weights(weights: List[int], m: int) -> bool:\n        if m == 0:\n            return True\n        if not weights:\n            return False\n\n        for i in range(len(weights)):\n            if weights[i] == 0:\n                continue\n            left_weights = weights[:i] + [weights[i] - 1] * weights[i]\n            right_weights = weights[i+1:] + [weights[i] - 1] * weights[i]\n\n            if can_put_weights(left_weights, m - weights[i]) and can_put_weights(right_weights, m - weights[i]):\n                return True\n\n        return False\n\n    if can_put_weights(weights, m):\n        result = []\n        for i in range(len(weights)):\n            if weights[i] == 0:\n                continue\n            left_weights = weights[:i] + [weights[i] - 1] * weights[i]\n            right_weights = weights[i+1:] + [weights[i] - 1] * weights[i]\n\n            if can_put_weights(left_weights, m - weights[i]) and can_put_weights(right_weights, m - weights[i]):\n                result.append(weights[i])\n                m -= weights[i]\n                break\n\n        return \"YES\\n\" + \" \".join(map(str, result))\n    else:\n        return \"NO\""
    },
    {
        "number": 1423,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    p = list(map(int, stdin.split()[3+n:]))\n\n    for i in range(n):\n        if p[i] == i + 1:\n            continue\n        else:\n            return \"-1\"\n\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i] + p[i] - 1\n\n    return \" \".join(map(str, b))\n"
    },
    {
        "number": 1424,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    x = [int(x) for x in stdin.split()[3:]]\n    x.append(0)\n    count = 0\n    for i in range(m + 1):\n        for j in range(i + 1, m + 2):\n            diff = bin(x[i] ^ x[j]).count('1')\n            if diff <= k:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1425,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n):\n        if numbers[i] >= sum(numbers[(i-1)%n], numbers[(i+1)%n]):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1426,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S, T = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start: int, end: int) -> int:\n        visited = [False] * (N + 1)\n        queue = [(start, 0)]\n        while queue:\n            node, depth = queue.pop(0)\n            if node == end:\n                return depth\n            if not visited[node]:\n                visited[node] = True\n                for neighbor in graph[node]:\n                    queue.append((neighbor, depth + 1))\n        return -1\n\n    ken_ken_pa_count = bfs(S, T)\n    if ken_ken_pa_count == -1:\n        return \"-1\"\n    else:\n        return str(ken_ken_pa_count // 3)"
    },
    {
        "number": 1427,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(B: List[int]) -> bool:\n        for i in range(N):\n            for j in range(i+1, N):\n                if A[i] * B[i] != A[j] * B[j]:\n                    return False\n        return True\n\n    B = [1] * N\n    min_sum = sum(B)\n    while not is_valid(B):\n        B = [b+1 for b in B]\n        min_sum = sum(B)\n\n    return str(min_sum % (10**9 + 7))"
    },
    {
        "number": 1428,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_grid(grid: List[List[int]]) -> bool:\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                for x in range(n):\n                    for y in range(n):\n                        if (i + j) % 3 == (x + y) % 3:\n                            if grid[i][j] != grid[x][y]:\n                                return False\n                        else:\n                            if grid[i][j] == grid[x][y]:\n                                return False\n        return True\n\n    def min_wrongness(grid: List[List[int]]) -> int:\n        n = len(grid)\n        wrongness = 0\n        for i in range(n):\n            for j in range(n):\n                for x in range(n):\n                    for y in range(n):\n                        if (i + j) % 3 == (x + y) % 3:\n                            if grid[i][j] != grid[x][y]:\n                                wrongness += d[grid[i][j]][grid[x][y]]\n                        else:\n                            if grid[i][j] == grid[x][y]:\n                                wrongness += d[grid[i][j]][grid[x][y]]\n        return wrongness\n\n    def repaint_grid(grid: List[List[int]]) -> int:\n        n = len(grid)\n        min_wrongness_value = float('inf')\n        for i in range(n):\n            for j in range(n):\n                for color in range(1, C + 1):\n                    if color != grid[i][j]:\n                        new_grid = [row[:] for row in grid]\n                        new_grid[i][j] = color\n                        if is_good_grid(new_grid):\n                            wrongness = min_wrongness(new_grid)\n                            if wrongness < min_wrongness_value:\n                                min_wrongness_value = wrongness\n        return min_wrongness_value\n\n    N, C = map(int, stdin.readline().split())\n    d = [list(map(int, stdin.readline().split())) for _ in range(C)]\n    grid = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    return str(repaint_grid(grid))"
    },
    {
        "number": 1429,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    complementary_map = {\n        'A': 'T',\n        'T': 'A',\n        'C': 'G',\n        'G': 'C'\n    }\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N+1):\n            substring = S[i:j]\n            complementary_substring = ''.join([complementary_map[c] for c in substring[::-1]])\n            if substring != complementary_substring and substring[::-1] != complementary_substring:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1430,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    S = stdin.split()[2]\n\n    max_consecutive = 0\n    current_consecutive = 0\n\n    for i in range(N):\n        if S[i] == '1':\n            current_consecutive += 1\n        else:\n            max_consecutive = max(max_consecutive, current_consecutive)\n            current_consecutive = 0\n\n    max_consecutive = max(max_consecutive, current_consecutive)\n\n    for _ in range(K):\n        l, r = map(int, input().split())\n        S = list(S)\n        for i in range(l-1, r):\n            S[i] = '1' if S[i] == '0' else '0'\n        S = ''.join(S)\n\n        current_consecutive = 0\n        for i in range(N):\n            if S[i] == '1':\n                current_consecutive += 1\n            else:\n                max_consecutive = max(max_consecutive, current_consecutive)\n                current_consecutive = 0\n\n        max_consecutive = max(max_consecutive, current_consecutive)\n\n    return str(max_consecutive)"
    },
    {
        "number": 1431,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a = stdin.split()\n    N = int(N)\n    a = list(map(int, a.split()))\n\n    def is_good_set(choices: List[int]) -> bool:\n        for i in range(1, N + 1):\n            count = sum(choices[j] for j in range(N) if j % i == 0)\n            if count % 2 != a[i - 1]:\n                return False\n        return True\n\n    for i in range(2**N):\n        choices = [int(x) for x in bin(i)[2:].zfill(N)]\n        if is_good_set(choices):\n            return \"1\\n\" + \" \".join(str(j + 1) for j in range(N) if choices[j] == 1)\n\n    return \"-1\""
    },
    {
        "number": 1432,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = stdin.split()\n    N = int(N)\n    A = list(map(int, A.split()))\n\n    rain = [0] * N\n    for i in range(N):\n        rain[(i - 1) % N] += A[i]\n        rain[i] += A[i]\n        rain[(i + 1) % N] += A[i]\n\n    for i in range(N):\n        rain[i] = rain[i] // 2\n\n    return \" \".join(map(str, rain))"
    },
    {
        "number": 1433,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    plan = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_good_position(x, y, direction):\n        if plan[x][y] == 1:\n            return False\n        if direction == 'left':\n            return any(plan[x][i] == 1 for i in range(y+1, m))\n        elif direction == 'right':\n            return any(plan[x][i] == 1 for i in range(y-1, -1, -1))\n        elif direction == 'up':\n            return any(plan[i][y] == 1 for i in range(x+1, n))\n        else:\n            return any(plan[i][y] == 1 for i in range(x-1, -1, -1))\n\n    good_positions = 0\n    for x in range(n):\n        for y in range(m):\n            if plan[x][y] == 0:\n                good_positions += 4\n            else:\n                if x > 0 and plan[x-1][y] == 0:\n                    good_positions -= 1\n                if x < n-1 and plan[x+1][y] == 0:\n                    good_positions -= 1\n                if y > 0 and plan[x][y-1] == 0:\n                    good_positions -= 1\n                if y < m-1 and plan[x][y+1] == 0:\n                    good_positions -= 1\n\n    return str(good_positions)"
    },
    {
        "number": 1434,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    degrees = []\n    xors = []\n    for i in range(1, n + 1):\n        degree, xor = map(int, stdin.split('\\n')[i].split())\n        degrees.append(degree)\n        xors.append(xor)\n\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if degrees[i] == degrees[j] and xors[i] ^ xors[j] == degrees[i]:\n                edges.append((i, j))\n\n    m = len(edges)\n    output = str(m) + '\\n'\n    for edge in edges:\n        output += str(edge[0]) + ' ' + str(edge[1]) + '\\n'\n\n    return output"
    },
    {
        "number": 1435,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    count = 0\n    while a > 0:\n        if a % 10 == 9:\n            count += 1\n        a //= 10\n    return str(count)"
    },
    {
        "number": 1436,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = [int(x) for x in stdin.split()]\n    untreated_crimes = 0\n    officers = []\n\n    for event in events:\n        if event == -1:\n            untreated_crimes += 1\n        else:\n            officers.append(event)\n\n        while officers and officers[-1] <= untreated_crimes:\n            officers.pop()\n\n    return str(untreated_crimes)"
    },
    {
        "number": 1437,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def base64_to_int(char: str) -> int:\n        if char.isdigit():\n            return ord(char) - ord('0')\n        elif char.isupper():\n            return ord(char) - ord('A') + 10\n        elif char.islower():\n            return ord(char) - ord('a') + 36\n        elif char == '-':\n            return 62\n        elif char == '_':\n            return 63\n        else:\n            raise ValueError(\"Invalid character\")\n\n    def int_to_base64(num: int) -> str:\n        if 0 <= num <= 9:\n            return chr(ord('0') + num)\n        elif 10 <= num <= 35:\n            return chr(ord('A') + num - 10)\n        elif 36 <= num <= 61:\n            return chr(ord('a') + num - 36)\n        elif num == 62:\n            return '-'\n        elif num == 63:\n            return '_'\n        else:\n            raise ValueError(\"Invalid number\")\n\n    def count_pairs(s: str) -> int:\n        s_int = 0\n        for char in s:\n            s_int <<= 6\n            s_int += base64_to_int(char)\n\n        count = 0\n        for i in range(1, len(s) + 1):\n            for j in range(i, len(s) + 1):\n                if (s_int & (s_int << (i * 6) >> (j * 6) << (j * 6) >> (i * 6) & s_int)) == s_int:\n                    count += 1\n\n        return count % (10**9 + 7)\n\n    return str(count_pairs(stdin))"
    },
    {
        "number": 1438,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    max_cookies = 0\n    for i in range(n):\n        if b[i] >= a[i]:\n            max_cookies += b[i] // a[i]\n            k -= b[i] % a[i]\n        else:\n            max_cookies += b[i] // a[i]\n            k -= b[i] % a[i]\n            if k >= a[i] - b[i]:\n                max_cookies += 1\n                k -= a[i] - b[i]\n\n    return str(max_cookies)"
    },
    {
        "number": 1439,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    sequence = list(map(int, stdin.split()[2:]))\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if sum(sequence[i:j]) % m == 0:\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 1440,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sticks = stdin.split()\n    n = int(n)\n    sticks = list(map(int, sticks.split()))\n\n    triangles = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if sticks[i] + sticks[j] > sticks[k] and sticks[j] + sticks[k] > sticks[i] and sticks[k] + sticks[i] > sticks[j]:\n                    triangles += 1\n\n    return str(triangles)"
    },
    {
        "number": 1441,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, throws = map(int, stdin.split())\n    max_throws = [int(x) for x in stdin.split()[1:]]\n    result = 1\n    for i in range(n):\n        result *= (max_throws[i] + 1)\n    return str(result % 1000000007)"
    },
    {
        "number": 1442,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    orders = [line.strip().split() for line in stdin.split()[2:]]\n\n    buy_orders = []\n    sell_orders = []\n\n    for order in orders:\n        direction, price, volume = order\n        price = int(price)\n        volume = int(volume)\n\n        if direction == 'B':\n            buy_orders.append((price, volume))\n        else:\n            sell_orders.append((price, volume))\n\n    buy_orders.sort(reverse=True)\n    sell_orders.sort()\n\n    result = []\n    for i in range(s):\n        if i < len(buy_orders):\n            result.append(('B', *buy_orders[i]))\n        if i < len(sell_orders):\n            result.append(('S', *sell_orders[i]))\n\n    return '\\n'.join([f'{direction} {price} {volume}' for direction, price, volume in result])\n"
    },
    {
        "number": 1443,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lengths = list(map(int, stdin.readline().strip().split()))\n    terrain_types = stdin.readline().strip()\n\n    def get_time(movement_type: str, length: int) -> int:\n        if movement_type == \"G\":\n            return length * 5\n        elif movement_type == \"W\":\n            return length * 3\n        else:\n            return length\n\n    def get_stamina(movement_type: str, length: int) -> int:\n        if movement_type == \"G\" or movement_type == \"W\":\n            return length\n        else:\n            return 0\n\n    time = 0\n    stamina = 0\n    current_position = 0\n\n    for i in range(n):\n        movement_type = terrain_types[i]\n        length = lengths[i]\n\n        time += get_time(movement_type, length - current_position)\n        stamina += get_stamina(movement_type, length - current_position)\n\n        if stamina < 0:\n            stamina = 0\n\n        if stamina >= 2:\n            stamina -= 2\n            time += 10\n        else:\n            stamina = 0\n\n        current_position = length\n\n    return time"
    },
    {
        "number": 1444,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split())\n    x = list(map(int, x.split()))\n    x.sort()\n    min_avg_commute = float('inf')\n    result = []\n\n    for i in range(n - k + 1):\n        avg_commute = sum([abs(x[j] - x[j + 1]) for j in range(i, i + k - 1)]) / (k * (k - 1) / 2)\n        if avg_commute < min_avg_commute:\n            min_avg_commute = avg_commute\n            result = [j + 1 for j in range(i, i + k)]\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 1445,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cubes = stdin.split()[1:]\n    for i in range(n):\n        if cubes[i] == str(i + 1):\n            continue\n        else:\n            for j in range(i, n):\n                if cubes[j] == str(i + 1):\n                    cubes[i], cubes[j] = cubes[j], cubes[i]\n                    break\n    return \" \".join(cubes)"
    },
    {
        "number": 1446,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    bacteria = [[] for _ in range(k)]\n    for _ in range(m):\n        u, v, x = map(int, stdin.readline().split())\n        bacteria[u - 1].append((v - 1, x))\n        bacteria[v - 1].append((u - 1, x))\n\n    def dfs(start: int, visited: set, cost: int) -> int:\n        if start in visited:\n            return cost\n        visited.add(start)\n        min_cost = float('inf')\n        for neighbor, neighbor_cost in bacteria[start]:\n            if neighbor not in visited:\n                min_cost = min(min_cost, dfs(neighbor, visited, cost + neighbor_cost))\n        return min_cost\n\n    d = [[0] * k for _ in range(k)]\n    for i in range(k):\n        for j in range(k):\n            if i == j:\n                continue\n            start = sum(c[:i]) + 1\n            end = start + c[i]\n            visited = set()\n            d[i][j] = dfs(start, visited, 0)\n            if d[i][j] == float('inf'):\n                d[i][j] = -1\n\n    if any(d[i][j] == -1 for i in range(k) for j in range(k)):\n        return \"No\"\n    else:\n        for row in d:\n            print(\" \".join(map(str, row)))\n        return \"Yes\""
    },
    {
        "number": 1447,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1:\n        return \"1.000000000000000\"\n    else:\n        return \"{:.6f}\".format(1 - (m - 1) / (n * m))"
    },
    {
        "number": 1448,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0].split())\n    m = int(stdin.split()[1])\n    grasshoppers = []\n    for i in range(m):\n        x, y = map(int, stdin.split()[2 + i].split())\n        grasshoppers.append((x, y))\n\n    result = []\n    for grasshopper in grasshoppers:\n        x, y = grasshopper\n        if x >= 0 and x <= n and y >= 0 and y <= n:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1449,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(b_list, k):\n        return len(set(sum(b, []))) <= k\n\n    def find_min_m(a, n, k):\n        m = 1\n        while True:\n            b_list = [[a[j] // m for j in range(n)] for _ in range(m)]\n            if is_valid(b_list, k):\n                return m\n            m += 1\n\n    def main():\n        t = int(stdin.readline())\n        for _ in range(t):\n            n, k = map(int, stdin.readline().split())\n            a = list(map(int, stdin.readline().split()))\n            if n == 1:\n                print(-1)\n            else:\n                print(find_min_m(a, n, k))\n\n    main()"
    },
    {
        "number": 1450,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    i = 0\n    while i < n - 1:\n        if s[i] == '0' and s[i+1] == '1':\n            s[i], s[i+1] = s[i+1], s[i]\n            i += 1\n        elif s[i] == '1' and s[i+1] == '2':\n            s[i], s[i+1] = s[i+1], s[i]\n            i += 1\n        i += 1\n    return ''.join(s)"
    },
    {
        "number": 1451,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    numbers = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for num in numbers:\n        num_str = str(num)\n        lucky_digits = 0\n\n        for digit in num_str:\n            if digit in ['4', '7']:\n                lucky_digits += 1\n\n        if lucky_digits <= k:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1452,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, r, c = stdin.split()\n    h, w = int(h), int(w)\n    r = list(map(int, r.split()))\n    c = list(map(int, c.split()))\n\n    def count_ways(r, c, h, w):\n        MOD = 1000000007\n        dp = [[0] * (w + 1) for _ in range(h + 1)]\n        dp[0][0] = 1\n        for i in range(1, h + 1):\n            for j in range(w + 1):\n                if j > 0:\n                    dp[i][j] += dp[i - 1][j - 1]\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                dp[i][j] %= MOD\n        return dp[h][w]\n\n    return str(count_ways(r, c, h, w))"
    },
    {
        "number": 1453,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    x = [0] * (n + 1)\n    for k in range(1, n + 1):\n        for i in range(1, n - k + 2):\n            j = i + k - 1\n            x[k] = min(x[k], x[k - 1] + (i * a[i - 1] + j * a[j - 1]))\n    return ' '.join(map(str, x[1:]))"
    },
    {
        "number": 1454,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_increasing(matrix: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if i > 0 and matrix[i][j] <= matrix[i - 1][j]:\n                    return False\n                if j > 0 and matrix[i][j] <= matrix[i][j - 1]:\n                    return False\n        return True\n\n    def replace_zeros(matrix: List[List[int]]) -> int:\n        max_sum = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 0:\n                    min_value = float('inf')\n                    for k in range(i - 1, -1, -1):\n                        min_value = min(min_value, matrix[k][j])\n                    for k in range(i + 1, n):\n                        min_value = min(min_value, matrix[k][j])\n                    for k in range(j - 1, -1, -1):\n                        min_value = min(min_value, matrix[i][k])\n                    for k in range(j + 1, m):\n                        min_value = min(min_value, matrix[i][k])\n                    matrix[i][j] = min_value + 1\n                max_sum += matrix[i][j]\n        return max_sum\n\n    if is_increasing(matrix):\n        return str(replace_zeros(matrix))\n    else:\n        return \"-1\""
    },
    {
        "number": 1455,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = 1\n    while True:\n        if (n * (n - 1)) // 2 <= m * (m - 1):\n            break\n        m += 1\n\n    pieces = []\n    for i in range(1, n + 1):\n        r = i\n        c = m - i + 1\n        pieces.append((r, c))\n\n    result = [str(m)] + [f\"{r} {c}\" for r, c in pieces]\n    return \"\\n\".join(result)"
    },
    {
        "number": 1456,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    board = [list(line) for line in stdin.split('\\n')[1:]]\n    attacked = {(i, j) for i in range(n) for j in range(n) if board[i][j] == 'x'}\n\n    def is_valid_move(x, y, dx, dy):\n        return 0 <= x + dx < n and 0 <= y + dy < n and (x + dx, y + dy) not in attacked\n\n    def find_valid_moves(x, y):\n        valid_moves = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if is_valid_move(x, y, dx, dy):\n                valid_moves.append((dx, dy))\n        return valid_moves\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                valid_moves = find_valid_moves(i, j)\n                if valid_moves:\n                    board[i][j] = '.'\n                    for dx, dy in valid_moves:\n                        board[i + dx][j + dy] = 'x'\n                    return 'YES\\n' + '\\n'.join([''.join(row) for row in board])\n    return 'NO'"
    },
    {
        "number": 1457,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ai_name, phone_name = stdin.split()\n    min_replacements = len(ai_name)\n    \n    for i in range(len(ai_name) - len(phone_name) + 1):\n        if phone_name in ai_name[i:i + len(phone_name)]:\n            min_replacements = min(min_replacements, i + len(phone_name) - ai_name.find(phone_name, i))\n    \n    return min_replacements"
    },
    {
        "number": 1458,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i:j] == s[i:j][::-1]:\n                return \"YES\\n{} {}\".format(i + 1, j)\n\n    return \"NO\""
    },
    {
        "number": 1459,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, distances, s, t = stdin.split()\n    n = int(n)\n    s = int(s)\n    t = int(t)\n    distances = [int(distance) for distance in distances.split()]\n\n    def get_distance(s: int, t: int) -> int:\n        if s == t:\n            return 0\n        distance = 0\n        while s != t:\n            distance += distances[(s - 1) % n]\n            s = (s + 1) % n\n        return distance\n\n    return str(min(get_distance(s, t), get_distance(t, s)))\n"
    },
    {
        "number": 1460,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 12\n    result = f\"{k}\\n\"\n    result += \"1 0\\n\"\n    result += \"2 0\\n\"\n    result += \"0 1\\n\"\n    result += \"1 1\\n\"\n    result += \"2 1\\n\"\n    result += \"3 1\\n\"\n    result += \"0 2\\n\"\n    result += \"1 2\\n\"\n    result += \"2 2\\n\"\n    result += \"3 2\\n\"\n    result += \"1 3\\n\"\n    result += \"2 3\\n\"\n    return result"
    },
    {
        "number": 1461,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    f = list(map(int, stdin.split()[2:2*n+2]))\n    w = list(map(int, stdin.split()[2*n+2:]))\n    \n    result = []\n    for i in range(n):\n        s = 0\n        m = float('inf')\n        for j in range(k):\n            if i + j < n:\n                s += w[i + j]\n                m = min(m, w[i + j])\n        result.append((s, m))\n    \n    return '\\n'.join(f'{s} {m}' for s, m in result)"
    },
    {
        "number": 1462,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    cards = stdin.split()[2:]\n    coins = 0\n    for card in cards:\n        coins += cards.count(card)\n    return str(coins)"
    },
    {
        "number": 1463,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != 1:\n                found = False\n                for k in range(n):\n                    if grid[i][k] + grid[k][j] == grid[i][j]:\n                        found = True\n                        break\n                if not found:\n                    return \"No\"\n    return \"Yes\""
    },
    {
        "number": 1464,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    titles = stdin.split('\\n')[1:]\n\n    def is_original(title: str) -> bool:\n        for t in titles:\n            if title in t:\n                return False\n        return True\n\n    def find_shortest_original(titles: List[str]) -> str:\n        shortest_original = ''\n        for title in titles:\n            if len(title) > len(shortest_original) and is_original(title):\n                shortest_original = title\n        return shortest_original\n\n    return find_shortest_original(titles)"
    },
    {
        "number": 1465,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    initial_arrangement = list(stdin.split()[1])\n\n    def find_pairs(arrangement):\n        pairs = []\n        for i in range(len(arrangement) - 1):\n            if arrangement[i] != arrangement[i + 1]:\n                pairs.append((i + 1, i + 2))\n        return pairs\n\n    def turn_pairs(pairs):\n        new_pairs = []\n        for pair in pairs:\n            if pair[0] % 2 == 1:\n                new_pairs.append((pair[0] - 1, pair[1]))\n            else:\n                new_pairs.append((pair[0] + 1, pair[1]))\n        return new_pairs\n\n    def check_finish(pairs):\n        for pair in pairs:\n            if initial_arrangement[pair[0] - 1] != initial_arrangement[pair[1] - 1]:\n                return False\n        return True\n\n    current_pairs = find_pairs(initial_arrangement)\n    for _ in range(k):\n        if check_finish(current_pairs):\n            break\n        current_pairs = turn_pairs(current_pairs)\n\n    if check_finish(current_pairs):\n        result = []\n        for pair in current_pairs:\n            result.append(pair[0])\n        return \"\\n\".join(str(len(result)) + \" \" + \" \".join(map(str, result)))\n    else:\n        return \"-1\""
    },
    {
        "number": 1466,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    # Calculate the shortest path from vertex 1 to all other vertices\n    d = [float('inf')] * n\n    d[1] = 0\n    for _ in range(n - 1):\n        for x, y, w in edges:\n            d[y] = min(d[y], d[x] + w)\n    \n    # Find the edges that should be retained\n    good_vertices = set()\n    for x, y, w in edges:\n        if d[x] + w == d[y]:\n            good_vertices.add(x)\n            good_vertices.add(y)\n    \n    # Calculate the number of good vertices\n    good_vertices = len(good_vertices)\n    \n    # Calculate the number of edges that should be retained\n    e = min(k, good_vertices)\n    \n    # Find the indices of the edges that should be retained\n    retained_edges = set()\n    for i, (x, y, w) in enumerate(edges):\n        if d[x] + w == d[y]:\n            retained_edges.add(i)\n    \n    # Print the result\n    return f\"{e}\\n{' '.join(map(str, retained_edges))}\""
    },
    {
        "number": 1467,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(division):\n        subsets = [[] for _ in range(len(division))]\n        for i in range(n):\n            for j in range(len(division)):\n                if i in division[j]:\n                    subsets[j].append(a[i])\n        for subset in subsets:\n            if len(subset) > 1:\n                xor = 0\n                for num in subset:\n                    xor ^= num\n                if xor == 0:\n                    return False\n        return True\n\n    max_division = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                division = [[i], [j], [k]]\n                if is_valid(division):\n                    max_division = division\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n\n    if max_division:\n        return str(len(max_division))\n    else:\n        return \"-1\""
    },
    {
        "number": 1468,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    hashtags = []\n\n    for _ in range(n):\n        hashtag = stdin.readline().strip()\n        hashtags.append(hashtag)\n\n    hashtags.sort()\n\n    for hashtag in hashtags:\n        print(hashtag)"
    },
    {
        "number": 1469,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.strip())\n    N = 2 * L\n    M = 2 * L - 1\n    result = f\"{N} {M}\\n\"\n    \n    for i in range(1, L):\n        result += f\"1 {i+1} {i}\\n\"\n        result += f\"{i+1} {i+2} {i}\\n\"\n    \n    for i in range(L, 2*L):\n        result += f\"{i} {i+1} {i-L+1}\\n\"\n    \n    return result"
    },
    {
        "number": 1470,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x <= 1:\n        return \"0\"\n    elif x == 2:\n        return \"1\"\n    elif x == 3:\n        return \"2\"\n    elif x == 4:\n        return \"2\"\n    elif x == 5:\n        return \"3\"\n    elif x == 6:\n        return \"3\"\n    elif x == 7:\n        return \"4\"\n    else:\n        return \"4\""
    },
    {
        "number": 1471,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, color):\n        nonlocal colors\n        colors[node] = color\n        for neighbor, length in graph[node]:\n            if colors[neighbor] == -1:\n                dfs(neighbor, 1 - color)\n\n    N = int(stdin.readline())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        u, v, w = map(int, stdin.readline().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    colors = [-1] * (N + 1)\n    dfs(1, 0)\n\n    return \"\\n\".join(str(colors[i]) for i in range(1, N + 1))"
    },
    {
        "number": 1472,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    graph = [[0] * N for _ in range(N)]\n    for i in range(N - 1):\n        graph[i][i + 1] = 1\n    graph[X - 1][Y - 1] = 1\n    graph[Y - 1][X - 1] = 1\n\n    def bfs(start: int) -> int:\n        visited = [False] * N\n        visited[start] = True\n        queue = [start]\n        distance = [0] * N\n        distance[start] = 0\n\n        while queue:\n            current = queue.pop(0)\n            for neighbor in range(N):\n                if not visited[neighbor] and graph[current][neighbor] == 1:\n                    visited[neighbor] = True\n                    distance[neighbor] = distance[current] + 1\n                    queue.append(neighbor)\n        return distance\n\n    distances = bfs(X - 1)\n    result = []\n    for k in range(1, N):\n        count = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if distances[i] + distances[j] == k:\n                    count += 1\n        result.append(count)\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1473,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = {}\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        if a == 0:\n            students[b] = 0\n        elif b == 0:\n            students[a] = 0\n        else:\n            students[a] = b\n            students[b] = a\n    \n    result = []\n    while students:\n        current = min(students.keys())\n        result.append(current)\n        next_student = students.pop(current)\n        if next_student != 0:\n            students.pop(next_student)\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 1474,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    h = [int(x) for x in stdin.split()[1:]]\n\n    MOD = 1000000007\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if h[i] == h[j]:\n                dp[i] += dp[j]\n                dp[i] %= MOD\n\n    return str(dp[-1])"
    },
    {
        "number": 1475,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, k, x = map(int, stdin.split()[:4])\n    digits = list(map(int, stdin.split()[4:]))\n    \n    # Calculate the number of occurrences of each digit in each block\n    occurrences = []\n    for i in range(n):\n        occurrences.append([digits.count(j) for j in range(1, 10)])\n    \n    # Calculate the number of ways to choose one digit from each block\n    result = 1\n    for i in range(n):\n        result *= occurrences[i][k % 10]\n        k //= 10\n    \n    # Calculate the result modulo x\n    result %= x\n    \n    return str(result)"
    },
    {
        "number": 1476,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\\n1\"\n    if n == 2:\n        return \"2\\n1 2\"\n    if n == 3:\n        return \"2\\n1 3\"\n    if n == 4:\n        return \"4\\n1 4 2 3\"\n    if n == 5:\n        return \"5\\n1 5 2 6 3 4\"\n    if n == 6:\n        return \"6\\n1 5 3 6 2 4\"\n    if n == 7:\n        return \"7\\n1 7 2 8 3 9 4 5 6\"\n    if n == 8:\n        return \"8\\n1 8 2 9 3 10 4 11 5 12 6 7\"\n    if n == 9:\n        return \"9\\n1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16\"\n    if n == 10:\n        return \"10\\n1 10 2 11 3 12 4 13 5 14 6 15 7 16 8 17 9 18\"\n    if n == 11:\n        return \"11\\n1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18 9 19 10 20\"\n    if n == 12:\n        return \"12\\n1 12 2 13 3 14 4 15 5 16 6 17 7 18 8 19 9 20 10 21 11 22\"\n    if n == 13:\n        return \"13\\n1 13 2 14 3 15 4 16 5 17 6 18 7 19 8 20 9 21 10 22 11 23 12 24\"\n    if n == 14:\n        return \"14\\n1 14 2 15 3 16 4 17 5 18 6 19 7 20 8 21 9 22 10 23 11 24 12 25 13 26\"\n    if n == 15:\n        return \"15\\n1 15 2 16 3 17 4 18 5 19 6 20 7 21 8 22 9 23 10 24 11 25 12 26 13 27 14 28\"\n    if n == 16:\n        return \"16\\n1 16 2 17 3 18 4 19 5 20 6 21 7 22 8 23 9 24 10 25 11 26 12 27 13 28 14 29 15 30\"\n    if n == 17:\n        return \"17\\n1 17 2 18 3 19 4 20 5 21 6 22 7 23 8 24 9 25 10 26 11 27 12 28 13 29 14 30 15 31 16 32\"\n    if n == 18:\n        return \"18\\n1 18 2 19 3 20 4 21 5 22 6 23 7 24 8 25 9 26 10 27 11 28 12 29 13 30 14 3"
    },
    {
        "number": 1477,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        line1 = input().split()\n        N, M = map(int, line1)\n        E = list(map(int, input().split()))\n        dependencies = []\n        for _ in range(M):\n            line = input().split()\n            dependencies.append((int(line[0]), int(line[1])))\n        return N, M, E, dependencies\n\n    def dfs(task, visited, graph, coprocessor_tasks):\n        if visited[task]:\n            return\n        visited[task] = True\n        for neighbor in graph[task]:\n            dfs(neighbor, visited, graph, coprocessor_tasks)\n        coprocessor_tasks.append(task)\n\n    N, M, E, dependencies = read_input()\n    graph = [[] for _ in range(N)]\n    for dependency in dependencies:\n        graph[dependency[0]].append(dependency[1])\n\n    coprocessor_tasks = []\n    visited = [False] * N\n    for task in range(N):\n        if E[task] == 1:\n            dfs(task, visited, graph, coprocessor_tasks)\n\n    return str(len(coprocessor_tasks))\n\nprint(solution(stdin=None)) "
    },
    {
        "number": 1478,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_comments(comments: str) -> List[str]:\n        result = []\n        current_level = 0\n        current_comment = \"\"\n        for char in comments:\n            if char == \",\":\n                if current_level == 0:\n                    result.append(current_comment)\n                    current_comment = \"\"\n                else:\n                    current_comment += \",\"\n            else:\n                current_comment += char\n                if char == \"0\":\n                    current_level -= 1\n                elif char == \"1\":\n                    current_level += 1\n        result.append(current_comment)\n        return result\n\n    def print_comments(comments: List[str]) -> None:\n        max_depth = 0\n        for comment in comments:\n            depth = comment.count(\",\") + 1\n            max_depth = max(max_depth, depth)\n\n        for i in range(max_depth):\n            level_comments = [comment for comment in comments if comment.count(\",\") == i]\n            print(\" \".join(level_comments))\n\n    comments = parse_comments(stdin)\n    print_comments(comments)"
    },
    {
        "number": 1479,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    field = [list(stdin.split()[i]) for i in range(n)]\n    spider_count = 0\n    for row in field:\n        spider_count += row.count(\"L\") + row.count(\"R\") + row.count(\"U\") + row.count(\"D\")\n    if spider_count != k:\n        return \"Invalid input\"\n\n    result = []\n    for i in range(m):\n        spider_count = 0\n        for j in range(n):\n            if field[j][i] == \"L\" or field[j][i] == \"R\" or field[j][i] == \"U\" or field[j][i] == \"D\":\n                spider_count += 1\n        result.append(spider_count)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1480,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    leader = 1\n    result = []\n    for i in range(k):\n        leader = (leader + a[i] - 1) % n + 1\n        result.append(leader)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1481,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    board = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def count_adjacent_os(i: int, j: int) -> int:\n        count = 0\n        if i > 0 and board[i - 1][j] == 'o':\n            count += 1\n        if i < n - 1 and board[i + 1][j] == 'o':\n            count += 1\n        if j > 0 and board[i][j - 1] == 'o':\n            count += 1\n        if j < n - 1 and board[i][j + 1] == 'o':\n            count += 1\n        return count\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x':\n                continue\n            if count_adjacent_os(i, j) % 2 != 0:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 1482,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    # Create a list of segments for each child\n    segments = [[] for _ in range(k)]\n\n    # Assign segments to each child\n    for i in range(k):\n        segments[i].append(a[i])\n\n    # Assign remaining segments to each child\n    for i in range(k):\n        for j in range(n):\n            if j != i:\n                segments[i].append(j + 1)\n\n    # Print the segments for each child\n    for i in range(k):\n        print(\" \".join(map(str, segments[i])))"
    },
    {
        "number": 1483,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    result = []\n    \n    for i in range(1, n+1):\n        count = 0\n        current = i\n        while count < 2:\n            current = p[current-1]\n            count += 1\n        result.append(current)\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1484,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def is_good(arr):\n        for i in range(len(arr)):\n            if arr[i] == -1:\n                continue\n            for j in range(i + 1, len(arr)):\n                if arr[j] == -1:\n                    continue\n                if arr[i] == arr[j]:\n                    return False\n        return True\n\n    count = 0\n    for i in range(k + 1):\n        for j in range(k + 1):\n            for l in range(k + 1):\n                for r in range(k + 1):\n                    if i == j or j == l or l == r or i == r:\n                        continue\n                    new_a = a.copy()\n                    new_a[new_a.index(-1)] = i\n                    new_a[new_a.index(-1)] = j\n                    new_a[new_a.index(-1)] = l\n                    new_a[new_a.index(-1)] = r\n                    if is_good(new_a):\n                        count += 1\n\n    return str(count % 998244353)"
    },
    {
        "number": 1485,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a_list = list(map(int, stdin.split()[2:]))\n    \n    def count_ways(n: int, m: int, a_list: list) -> int:\n        if n == 0:\n            return 1\n        if n > m:\n            return 0\n        \n        count = 0\n        for i in range(1, m + 1):\n            if i >= n:\n                break\n            count += count_ways(n - i, i, a_list)\n        return count\n    \n    return str(count_ways(n, m, a_list))"
    },
    {
        "number": 1486,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x_coordinates = list(map(int, stdin.split()[1:]))\n\n    min_max_costs = []\n    for i in range(n):\n        min_cost = float('inf')\n        max_cost = float('-inf')\n        for j in range(n):\n            if i != j:\n                cost = abs(x_coordinates[i] - x_coordinates[j])\n                min_cost = min(min_cost, cost)\n                max_cost = max(max_cost, cost)\n        min_max_costs.append((min_cost, max_cost))\n\n    result = \"\"\n    for min_cost, max_cost in min_max_costs:\n        result += f\"{min_cost} {max_cost}\\n\"\n\n    return result"
    },
    {
        "number": 1487,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    n = len(s)\n    if s == t:\n        return s\n    for p in range(1, 2**n):\n        p_binary = bin(p)[2:].zfill(n)\n        if p_binary.count('0') == s.count('0') and p_binary.count('1') == t.count('1'):\n            return p_binary\n    return \"impossible\""
    },
    {
        "number": 1488,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    distances = list(map(int, stdin.split('\\n')[1].split()))\n    total_distance = 0\n    routes = []\n\n    # Generate all possible routes\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                route = [distances[i], distances[j], distances[k]]\n                route.sort()\n                routes.append(route)\n\n    # Calculate the total distance traveled for each route\n    for route in routes:\n        total_distance += abs(route[0] - 0) + abs(route[1] - route[0]) + abs(route[2] - route[1])\n\n    # Calculate the average distance traveled\n    average_distance = total_distance / len(routes)\n\n    # Calculate the numerator and denominator of the average distance\n    numerator = int(average_distance)\n    denominator = 1\n\n    return f\"{numerator} {denominator}\""
    },
    {
        "number": 1489,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def count_pictures(points):\n        n = len(points)\n        dp = [0] * (1 << n)\n        MOD = 10**9 + 7\n\n        for i in range(n):\n            dp[1 << i] = 4\n\n        for mask in range(1, 1 << n):\n            for i in range(n):\n                if mask & (1 << i):\n                    for j in range(i + 1, n):\n                        if mask & (1 << j):\n                            dp[mask] += 4\n                            dp[mask | (1 << j)] -= 2\n                            dp[mask | (1 << i)] -= 2\n                            dp[mask | (1 << i) | (1 << j)] += 1\n\n        return sum(dp) % MOD\n\n    return str(count_pictures(points))"
    },
    {
        "number": 1490,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    a_set = set(a)\n    k = 0\n    result = []\n    \n    for i in range(1, 10**9+1):\n        if i not in a_set:\n            k += 1\n            result.append(i)\n            if sum(result) > m:\n                result.pop()\n                k -= 1\n            if k == n:\n                break\n                \n    return str(k) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 1491,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    piles = list(map(int, stdin.split()[1:]))\n\n    def is_square(num: int) -> bool:\n        return int(num ** 0.5) ** 2 == num\n\n    def find_min_moves(piles: list) -> int:\n        piles.sort()\n        moves = 0\n        for i in range(n // 2):\n            if not is_square(piles[i]):\n                moves += 1\n            if not is_square(piles[n - i - 1]):\n                moves += 1\n        return moves\n\n    return str(find_min_moves(piles))"
    },
    {
        "number": 1492,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    map_str = stdin.split('\\n')[1:]\n    map_list = [list(row) for row in map_str]\n\n    def find_burnt_trees(map_list: List[List[str]]) -> List[Tuple[int, int]]:\n        burnt_trees = []\n        for i in range(n):\n            for j in range(m):\n                if map_list[i][j] == 'X':\n                    burnt_trees.append((i, j))\n        return burnt_trees\n\n    def find_neighbors(tree: Tuple[int, int]) -> List[Tuple[int, int]]:\n        i, j = tree\n        neighbors = [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]\n        return [(x, y) for x, y in neighbors if 0 <= x < n and 0 <= y < m]\n\n    def find_max_time(burnt_trees: List[Tuple[int, int]]) -> int:\n        max_time = 0\n        for tree in burnt_trees:\n            time = 0\n            queue = [tree]\n            visited = set()\n            while queue:\n                new_queue = []\n                for tree in queue:\n                    if tree not in visited:\n                        visited.add(tree)\n                        time += 1\n                        new_queue.extend(find_neighbors(tree))\n                queue = new_queue\n            max_time = max(max_time, time)\n        return max_time\n\n    burnt_trees = find_burnt_trees(map_list)\n    max_time = find_max_time(burnt_trees)\n\n    certificate = [['.' for _ in range(m)] for _ in range(n)]\n    for tree in burnt_trees:\n        certificate[tree[0]][tree[1]] = 'X'\n\n    return f\"{max_time}\\n{''.join([''.join(row) for row in certificate])}\""
    },
    {
        "number": 1493,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    chessboard = [list(line.strip()) for line in stdin.splitlines()[1:]]\n    result = [\"-\" * m] * n\n\n    def is_valid(i, j, color):\n        if chessboard[i][j] == \".\":\n            if i > 0 and chessboard[i - 1][j] == \".\":\n                if result[i - 1][j] == color:\n                    return False\n            if j > 0 and chessboard[i][j - 1] == \".\":\n                if result[i][j - 1] == color:\n                    return False\n            return True\n        return False\n\n    def place_chessman(i, j, color):\n        if is_valid(i, j, color):\n            result[i][j] = color\n            return True\n        return False\n\n    def backtrack(i, j, color):\n        if i == n:\n            return True\n        for k in range(m):\n            if chessboard[i][k] == \".\":\n                if place_chessman(i, k, color):\n                    if backtrack(i + 1, 0, \"B\" if color == \"W\" else \"W\"):\n                        return True\n                    place_chessman(i, k, \"-\")\n        return False\n\n    if backtrack(0, 0, \"W\"):\n        return \"\\n\".join(result)\n    else:\n        return \"No solution exists.\" "
    },
    {
        "number": 1494,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p = stdin.split()\n    ans = []\n    for x in range(len(s) + 1):\n        s_prime = s[:len(s) - x]\n        count = 0\n        i = 0\n        while i < len(s_prime):\n            if s_prime[i:i + len(p)] == p:\n                count += 1\n                i += len(p)\n            else:\n                i += 1\n        ans.append(count)\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 1495,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *volumes = map(int, stdin.split())\n    volumes.sort()\n    min_operations = 0\n    for i in range(n):\n        if i % 2 == 0:\n            min_operations += volumes[i] - volumes[i+1]\n        else:\n            min_operations += volumes[i+1] - volumes[i]\n    return str(min_operations)"
    },
    {
        "number": 1496,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    gadgets = []\n    for i in range(m):\n        t, c = map(int, stdin.readline().split())\n        gadgets.append((t, c))\n\n    def get_cost(day: int, currency: int) -> int:\n        if currency == 1:\n            return a[day - 1]\n        else:\n            return b[day - 1]\n\n    def get_gadgets_cost(gadgets: List[Tuple[int, int]], day: int) -> int:\n        total_cost = 0\n        for t, c in gadgets:\n            if t == 1:\n                total_cost += c * get_cost(day, 1)\n            else:\n                total_cost += c * get_cost(day, 2)\n        return total_cost\n\n    def can_buy_gadgets(gadgets: List[Tuple[int, int]], day: int, k: int, s: int) -> bool:\n        total_cost = get_gadgets_cost(gadgets, day)\n        return total_cost <= s\n\n    for day in range(1, n + 1):\n        if can_buy_gadgets(gadgets, day, k, s):\n            return str(day)\n\n    return \"-1\""
    },
    {
        "number": 1497,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    room = [list(line) for line in stdin.split('\\n')[1:n+1]]\n    \n    def clean_rows(room: list, col: int) -> int:\n        count = 0\n        for row in room:\n            if row[col] == '1':\n                count += 1\n            else:\n                break\n        return count\n    \n    max_clean_rows = 0\n    for col in range(n):\n        clean_rows_count = clean_rows(room, col)\n        if clean_rows_count > max_clean_rows:\n            max_clean_rows = clean_rows_count\n    \n    return str(max_clean_rows)"
    },
    {
        "number": 1498,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    tasks = []\n    for i in range(q):\n        t, k, d = map(int, stdin.split()[2*i+2:2*i+5])\n        tasks.append((t, k, d))\n\n    tasks.sort(key=lambda x: x[0])\n    servers = [i+1 for i in range(n)]\n    result = []\n\n    for task in tasks:\n        t, k, d = task\n        unoccupied_servers = [server for server in servers if server not in result]\n        if len(unoccupied_servers) >= k:\n            result.extend(sorted(unoccupied_servers)[:k])\n            servers = [server for server in servers if server not in result]\n        else:\n            result.append(-1)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1499,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = []\n    for i in range(1, m + 1):\n        if i <= 2 * n:\n            if i % 2 == 1:\n                result.append(i // 2 + n)\n            else:\n                result.append(i // 2 + n - 1)\n        else:\n            result.append((i - 2 * n) + 2 * n)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1501,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    p = stdin.split()[2]\n    y = list(map(int, stdin.split()[3:]))\n\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(n - len(p) + 1):\n        if all(i + j in y for j in range(len(p))):\n            count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 1502,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 3 == 0:\n        return str(a + 7)\n    elif a % 3 == 1:\n        return str(a + 6)\n    else:\n        return str(a + 5)"
    },
    {
        "number": 1503,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    permutations = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def common_part(permutation: list) -> list:\n        common = []\n        for i in range(len(permutation)):\n            if i == 0 or permutation[i] == permutation[i - 1]:\n                common.append(permutation[i])\n            else:\n                break\n        return common\n\n    def delete_prefix_suffix(permutation: list) -> list:\n        prefix = common_part(permutation)\n        suffix = common_part(permutation[::-1])\n        return permutation[len(prefix):len(permutation) - len(suffix)]\n\n    ways = 1\n    for i in range(m):\n        ways *= len(delete_prefix_suffix(permutations[i]))\n\n    return str(ways)"
    },
    {
        "number": 1504,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        l1, r1 = map(int, stdin.readline().split())\n        l2, r2 = map(int, stdin.readline().split())\n\n        al1, ar1 = l1, r1\n        bl1, br1 = l2, r2\n\n        steps = 0\n        while True:\n            if al1 == bl1 and ar1 == br1:\n                break\n\n            if al1 < bl1:\n                al1 += 1\n            else:\n                bl1 += 1\n\n            if ar1 > br1:\n                ar1 -= 1\n            else:\n                br1 -= 1\n\n            steps += 1\n\n        result.append(steps)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1505,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    px, py, vx, vy, a, b, c, d = map(int, stdin.split())\n    \n    # Calculate the coordinates of the arrow points\n    p1x = px + a * vx\n    p1y = py + a * vy\n    p2x = px + (a + b) * vx\n    p2y = py + (a + b) * vy\n    p3x = px + (a + b + c) * vx\n    p3y = py + (a + b + c) * vy\n    p4x = px + (a + b + c + d) * vx\n    p4y = py + (a + b + c + d) * vy\n    \n    # Calculate the intersection point of the triangle and rectangle\n    p5x = px + (a + b + c) * vx\n    p5y = py + (a + b + c) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p6x = px + (a + b + c) * vx + (c - d) * vx\n    p6y = py + (a + b + c) * vy + (c - d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p7x = px + (a + b + c) * vx + (c + d) * vx\n    p7y = py + (a + b + c) * vy + (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p8x = px + (a + b + c) * vx - (c + d) * vx\n    p8y = py + (a + b + c) * vy - (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p9x = px + (a + b + c) * vx - (c - d) * vx\n    p9y = py + (a + b + c) * vy - (c - d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p10x = px + (a + b + c) * vx - (c + d) * vx\n    p10y = py + (a + b + c) * vy - (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p11x = px + (a + b + c) * vx - (c - d) * vx\n    p11y = py + (a + b + c) * vy - (c - d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p12x = px + (a + b + c) * vx + (c - d) * vx\n    p12y = py + (a + b + c) * vy + (c - d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p13x = px + (a + b + c) * vx + (c + d) * vx\n    p13y = py + (a + b + c) * vy + (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p14x = px + (a + b + c) * vx - (c + d) * vx\n    p14y = py + (a + b + c) * vy - (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p15x = px + (a + b + c) * vx - (c - d) * vx\n    p15y = py + (a + b + c) * vy - (c - d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p16x = px + (a + b + c) * vx - (c + d) * vx\n    p16y = py + (a + b + c) * vy - (c + d) * vy\n    \n    # Calculate the coordinates of the intersection point\n    p17x = px + (a + b + c) * vx - (c - d) * vx\n    p17y = py + (a + b + c) *"
    },
    {
        "number": 1506,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    M = 1\n    f_a = 0\n    mod = 10**9 + 7\n\n    for i in range(2, n + 1):\n        if a[M] < a[i]:\n            f_a += a[M]\n            M = i\n\n    result = f_a * n\n\n    return str(result % mod)"
    },
    {
        "number": 1507,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    guests = stdin.split()[n+1:]\n    doors = [False] * 26\n    unguarded = False\n    \n    for guest in guests:\n        door = ord(guest) - ord('A')\n        if doors[door]:\n            unguarded = True\n        doors[door] = True\n        \n        if sum(doors) > k:\n            unguarded = True\n            break\n        \n        doors[door] = False\n    \n    return \"YES\" if unguarded else \"NO\""
    },
    {
        "number": 1508,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    max_value = 0\n    max_arrangement = []\n\n    def find_max_arrangement(arrangement, current_value):\n        nonlocal max_value, max_arrangement\n        if current_value > max_value:\n            max_value = current_value\n            max_arrangement = arrangement.copy()\n\n    def backtrack(start, current_arrangement, current_value):\n        if start == n:\n            find_max_arrangement(current_arrangement, current_value)\n            return\n\n        for i in range(start, n):\n            current_arrangement.append(a[i])\n            current_value += a[i] - (i - start)\n            backtrack(start + 1, current_arrangement, current_value)\n            current_value -= a[i] - (i - start)\n            current_arrangement.pop()\n\n    backtrack(0, [], 0)\n\n    return ' '.join(map(str, max_arrangement))"
    },
    {
        "number": 1509,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n\n    def f(l, r):\n        visited = [False] * n\n        count = 0\n        for i in range(l, r + 1):\n            if not visited[i]:\n                count += 1\n                dfs(i, visited)\n        return count\n\n    def dfs(i, visited):\n        visited[i] = True\n        if i > 0 and not visited[i - 1]:\n            dfs(i - 1, visited)\n        if i < n - 1 and not visited[i + 1]:\n            dfs(i + 1, visited)\n\n    result = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            result += f(l, r)\n\n    return str(result)"
    },
    {
        "number": 1510,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:]))\n    \n    min_a = min(a)\n    max_b = max(b)\n    \n    if min_a >= max_b:\n        return \"0\"\n    \n    operations = 0\n    for i in range(n):\n        if a[i] < max_b:\n            operations += max_b - a[i]\n            a[i] = max_b\n    \n    for i in range(m):\n        if b[i] > min_a:\n            operations += b[i] - min_a\n            b[i] = min_a\n    \n    return str(operations)"
    },
    {
        "number": 1511,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    instructions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    locked_cores = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if instructions[i][j] > 0:\n                if locked_cores[i] == 0:\n                    locked_cores[i] = j + 1\n                else:\n                    locked_cores[i] = min(locked_cores[i], j + 1)\n                    \n    return '\\n'.join(map(str, locked_cores))"
    },
    {
        "number": 1512,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    records = []\n    for i in range(n):\n        if all(p[j] < p[i] for j in range(i)):\n            records.append(p[i])\n\n    if len(records) == n:\n        return str(min(records))\n    else:\n        return str(max(set(p) - set(records)))"
    },
    {
        "number": 1513,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    broken_segments = list(map(int, stdin.split()[3:]))\n\n    tape_length = 0\n    pieces_used = 0\n    current_position = 0\n\n    for segment in broken_segments:\n        if segment > current_position:\n            tape_length += segment - current_position\n            pieces_used += 1\n            current_position = segment\n\n    if pieces_used > k:\n        return \"IMPOSSIBLE\"\n\n    return tape_length\n"
    },
    {
        "number": 1514,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b_prime = list(map(int, stdin.split('\\n')[1].split()))\n    c_prime = list(map(int, stdin.split('\\n')[2].split()))\n\n    for i in range(n - 1):\n        if b_prime[i] > c_prime[i]:\n            b_prime[i], c_prime[i] = c_prime[i], b_prime[i]\n\n    b_prime.sort()\n    c_prime.sort()\n\n    if b_prime == c_prime:\n        return \"-1\"\n\n    a = [0] * n\n    for i in range(n - 1):\n        a[i] = b_prime[i]\n        a[i + 1] = c_prime[i]\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 1515,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x = map(int, stdin.split())\n    if x == 1:\n        return \"Impossible\"\n    if p == 1:\n        return \"1\"\n    if p == 2:\n        return \"10\"\n    if p == 3:\n        return \"100\"\n    if p == 4:\n        return \"1000\"\n    if p == 5:\n        return \"10000\"\n    if p == 6:\n        return \"102564\"\n    if p == 7:\n        return \"1025649\"\n    if p == 8:\n        return \"10256497\"\n    if p == 9:\n        return \"102564975\"\n    if p == 10:\n        return \"1025649753\"\n    return \"Impossible\""
    },
    {
        "number": 1516,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 998244353\n    result = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            a_i = str(a[i])\n            a_j = str(a[j])\n            a_i_len = len(a_i)\n            a_j_len = len(a_j)\n            f_result = \"\"\n            \n            if a_i_len >= a_j_len:\n                for k in range(a_i_len):\n                    if k < a_j_len:\n                        f_result += a_j[k]\n                    f_result += a_i[k]\n                if a_i_len > a_j_len:\n                    f_result += a_i[a_j_len:]\n            else:\n                for k in range(a_j_len):\n                    if k < a_i_len:\n                        f_result += a_i[k]\n                    f_result += a_j[k]\n                if a_j_len > a_i_len:\n                    f_result += a_j[a_i_len:]\n            \n            result += int(f_result) % MOD\n    \n    return str(result % MOD)"
    },
    {
        "number": 1517,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                for l in range(1, n + 1):\n                    if i != j and i != k and i != l and j != k and j != l and k != l:\n                        count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 1518,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    operations = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n:\n            if is_prime(j - i + 1):\n                a[i], a[j] = a[j], a[i]\n                operations.append(f\"{i + 1} {j + 1}\")\n            j += 1\n        i += 1\n    return f\"{len(operations)}\\n{' '.join(operations)}\"\n\ndef"
    },
    {
        "number": 1519,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, a = map(int, stdin.split()[0].split())\n    customers = []\n    for i in range(n):\n        t, l = map(int, stdin.split()[i+1].split())\n        customers.append((t, l))\n\n    breaks = L - sum([l for _, l in customers]) - (n-1)*a\n    if breaks < 0:\n        return \"0\"\n    else:\n        return str(breaks)"
    },
    {
        "number": 1520,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    result = strings[0]\n    for i in range(1, n):\n        result = multiply_strings(result, strings[i])\n    return str(max_beauty(result))\n\ndef"
    },
    {
        "number": 1521,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, n = map(int, stdin.split()[:2])\n    numbers = list(map(int, stdin.split()[2:]))\n    conflicts = []\n\n    for i, number in enumerate(numbers):\n        bucket = number % p\n        if bucket in conflicts:\n            return str(i)\n        else:\n            conflicts.append(bucket)\n\n    return \"-1\""
    },
    {
        "number": 1522,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    keys = {}\n    doors = {}\n    for i in range(1, 2*n-1, 2):\n        keys[i] = s[i]\n    for i in range(0, 2*n-2, 2):\n        doors[i] = s[i]\n\n    for i in range(1, n):\n        if doors[i-1] == keys[2*i-1]:\n            return str(i-1)\n    return str(n-1)"
    },
    {
        "number": 1523,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jobs = list(map(int, stdin.split()[2:2*n+2:2]))\n    times = list(map(int, stdin.split()[3:2*n+3:2]))\n\n    # Sort jobs by frequency\n    freq = {}\n    for job in jobs:\n        if job in freq:\n            freq[job] += 1\n        else:\n            freq[job] = 1\n\n    sorted_jobs = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\n    # Assign jobs to idlers\n    assigned_jobs = [0] * n\n    for i in range(k):\n        assigned_jobs[i] = sorted_jobs[i][0]\n\n    # Calculate total time\n    total_time = 0\n    for i in range(n):\n        if assigned_jobs[i] == 0:\n            total_time += times[i]\n\n    return str(total_time)"
    },
    {
        "number": 1524,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = list(stdin)\n    N = len(S)\n    children = [1] * N\n\n    for _ in range(10**100):\n        for i in range(N):\n            if S[i] == 'L':\n                children[i - 1] += children[i]\n            else:\n                children[i + 1] += children[i]\n\n    return ' '.join(map(str, children))"
    },
    {
        "number": 1525,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n\n    def is_valid_amidakuji(H: int, W: int, K: int) -> bool:\n        if H < 1 or H > 100 or W < 1 or W > 8 or K < 1 or K > W:\n            return False\n\n        lines = [[False] * (H + 1) for _ in range(W + 1)]\n\n        def is_valid_move(x: int, y: int) -> bool:\n            if x < 0 or x > W or y < 0 or y > H:\n                return False\n            if lines[x][y]:\n                return False\n            lines[x][y] = True\n            return True\n\n        def dfs(x: int, y: int, k: int) -> bool:\n            if k == 0:\n                return True\n            if x == W:\n                return False\n            if y == H:\n                return dfs(x + 1, 0, k - 1)\n\n            if is_valid_move(x, y):\n                if dfs(x, y + 1, k):\n                    return True\n            if is_valid_move(x + 1, y, k):\n                if dfs(x + 1, y, k):\n                    return True\n            return False\n\n        return dfs(0, 0, K)\n\n    return str(is_valid_amidakuji(H, W, K) % 1000000007)"
    },
    {
        "number": 1526,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    min_value = min(A, B, C)\n    max_value = max(A, B, C)\n    operations = 0\n\n    while A != B or B != C or C != A:\n        if A == B == C:\n            break\n        if A == min_value:\n            A += 1\n            B += 1\n            C += 1\n        elif B == min_value:\n            B += 1\n            A += 2\n        else:\n            C += 2\n        operations += 1\n\n    return str(operations)"
    },
    {
        "number": 1527,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0:2])\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:H+1]]\n    start_pos = None\n    goal_pos = None\n\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '..':\n                if start_pos is None:\n                    start_pos = (i, j)\n                elif goal_pos is None:\n                    goal_pos = (i, j)\n                else:\n                    break\n\n    def bfs(start, goal):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, moves = queue.pop(0)\n            if current == goal:\n                return moves\n            visited.add(current)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                x, y = current[0] + dx, current[1] + dy\n                if 0 <= x < H and 0 <= y < W and (x, y) not in visited and maze[x][y] == '..':\n                    queue.append(((x, y), moves + 1))\n        return -1\n\n    return str(bfs(start_pos, goal_pos))"
    },
    {
        "number": 1528,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    total_layers = 2**N - 1\n    if X > total_layers:\n        return \"Invalid input\"\n    else:\n        return 2**(N-X) - 1"
    },
    {
        "number": 1529,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    sentences = lines[1:]\n\n    result = []\n\n    for sentence in sentences:\n        if sentence.endswith(\"lala.\") and sentence.startswith(\"miao.\"):\n            result.append(\"OMG>.< I don't know!\")\n        elif sentence.endswith(\"lala.\"):\n            result.append(\"Freda's\")\n        elif sentence.startswith(\"miao.\"):\n            result.append(\"Rainbow's\")\n        else:\n            result.append(\"OMG>.< I don't know!\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1531,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, esthetic_appeals = map(int, stdin.split())\n    esthetic_appeals = list(map(int, esthetic_appeals.split()))\n    \n    total_esthetic_appeal = sum(esthetic_appeals)\n    first_tree_esthetic_appeal = esthetic_appeals[0]\n    last_tree_esthetic_appeal = esthetic_appeals[-1]\n    \n    if first_tree_esthetic_appeal == last_tree_esthetic_appeal:\n        if n == 2:\n            return f\"{total_esthetic_appeal} 0\"\n        else:\n            return f\"{total_esthetic_appeal - esthetic_appeals[1]} 1\"\n    else:\n        if n == 2:\n            return f\"{total_esthetic_appeal} 0\"\n        else:\n            return f\"{total_esthetic_appeal - esthetic_appeals[1]} 1\""
    },
    {
        "number": 1532,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    S = set(range(1, n+1))\n    I = [0] * (n-1)\n    \n    for k in range(2, n+1):\n        min_imp = float('inf')\n        for M in itertools.combinations(S, k):\n            imp = 0\n            for a, b in itertools.combinations(M, 2):\n                imp = max(imp, math.gcd(a, b))\n            min_imp = min(min_imp, imp)\n        I[k-2] = min_imp\n    \n    return ' '.join(map(str, I))"
    },
    {
        "number": 1533,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    names = lines[1:]\n    result = []\n\n    for name in names:\n        if name in names[:names.index(name)]:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1534,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_count = stdin.count(\"a\")\n    b_count = stdin.count(\"b\")\n    max_length = a_count + b_count\n\n    if a_count >= 3 and b_count >= 3:\n        max_length = min(a_count, b_count) * 2 + max(a_count, b_count)\n\n    return max_length"
    },
    {
        "number": 1535,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_0, y_0 = map(int, stdin.split()[:3])\n    stormtroopers = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[3:])\n        stormtroopers.append((x, y))\n\n    def is_on_line(x, y):\n        return y - y_0 == (x - x_0) * (y_0 - y) / (x_0 - x)\n\n    shots = 0\n    while stormtroopers:\n        shots += 1\n        new_stormtroopers = []\n        for trooper in stormtroopers:\n            if not is_on_line(*trooper):\n                new_stormtroopers.append(trooper)\n        stormtroopers = new_stormtroopers\n\n    return str(shots)"
    },
    {
        "number": 1536,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, stdin.splitlines()[i].split())\n        points.append((x, y, z, i))\n\n    def is_perfectly_balanced(a, b):\n        x_min, x_max = min(a[0], b[0]), max(a[0], b[0])\n        y_min, y_max = min(a[1], b[1]), max(a[1], b[1])\n        z_min, z_max = min(a[2], b[2]), max(a[2], b[2])\n        for point in points:\n            if point[3] not in (a[3], b[3]):\n                if x_min <= point[0] <= x_max and y_min <= point[1] <= y_max and z_min <= point[2] <= z_max:\n                    return False\n        return True\n\n    def find_perfectly_balanced_pair():\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_perfectly_balanced(points[i], points[j]):\n                    return i + 1, j + 1\n        return None\n\n    result = []\n    for _ in range(n // 2):\n        pair = find_perfectly_balanced_pair()\n        if pair is None:\n            return \"Impossible\"\n        result.extend(pair)\n        points.remove(points[pair[0] - 1])\n        points.remove(points[pair[1] - 1])\n\n    return \"\\n\".join(f\"{a} {b}\" for a, b in enumerate(result, start=1))"
    },
    {
        "number": 1537,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    board = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def count_white_lines(board: List[List[str]]) -> int:\n        rows = sum(1 for row in board if all(cell == 'W' for cell in row))\n        cols = sum(1 for col in zip(*board) if all(cell == 'W' for cell in col))\n        return rows + cols\n\n    max_white_lines = 0\n    for i in range(n - k + 1):\n        for j in range(n - k + 1):\n            for r in range(i, i + k):\n                for c in range(j, j + k):\n                    board[r][c] = 'W'\n            max_white_lines = max(max_white_lines, count_white_lines(board))\n            for r in range(i, i + k):\n                for c in range(j, j + k):\n                    board[r][c] = 'B' if board[r][c] == 'W' else 'B'\n\n    return str(max_white_lines)"
    },
    {
        "number": 1538,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, boxes = stdin.split()\n    n = int(n)\n    boxes = [int(x) for x in boxes.split()]\n\n    visible_boxes = set(range(1, n + 1))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if boxes[i] < boxes[j]:\n                visible_boxes.discard(i + 1)\n                visible_boxes.discard(j + 1)\n\n    return str(len(visible_boxes))"
    },
    {
        "number": 1539,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, legs, costs = stdin.split('\\n')\n    n = int(n)\n    legs = list(map(int, legs.split()))\n    costs = list(map(int, costs.split()))\n\n    max_leg = max(legs)\n    stable_legs = legs.count(max_leg)\n    if stable_legs >= n // 2:\n        return \"0\"\n\n    min_cost = float('inf')\n    for i in range(stable_legs, n):\n        min_cost = min(min_cost, costs[i])\n\n    return str(sum(costs[:stable_legs]) + min_cost)"
    },
    {
        "number": 1540,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = [list(map(int, input().split())) for _ in range(n)]\n    events = [list(map(int, input().split())) for _ in range(k)]\n\n    notifications = [0] * n\n\n    for event in events:\n        x, y = event\n        for i in range(n):\n            if a[i][y-1] == 1:\n                if i != x-1:\n                    notifications[i] += 1\n\n    return \" \".join(map(str, notifications))"
    },
    {
        "number": 1541,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    pivot = s.index(\"^\")\n    left_sum = 0\n    right_sum = 0\n\n    for i in range(pivot):\n        if s[i] == \"=\":\n            continue\n        elif s[i] == \"^\":\n            continue\n        else:\n            left_sum += int(s[i])\n\n    for i in range(pivot + 1, len(s)):\n        if s[i] == \"=\":\n            continue\n        elif s[i] == \"^\":\n            continue\n        else:\n            right_sum += int(s[i])\n\n    if left_sum == right_sum:\n        return \"balance\"\n    elif left_sum > right_sum:\n        return \"left\"\n    else:\n        return \"right\""
    },
    {
        "number": 1542,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    shops, prices, days = stdin.split('\\n')\n    prices = list(map(int, prices.split()))\n    days = list(map(int, days.split()))\n\n    result = []\n    for day in days:\n        result.append(sum([1 for price in prices if price <= day]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1543,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cities = []\n    for i in range(n):\n        x, c = stdin.readline().strip().split()\n        cities.append((int(x), c))\n\n    cities.sort(key=lambda x: x[0])\n    total_length = 0\n    prev_city = None\n\n    for city in cities:\n        if city[1] == 'B' or city[1] == 'R':\n            if prev_city and prev_city[1] == city[1]:\n                total_length += abs(prev_city[0] - city[0])\n            prev_city = city\n\n    return str(total_length)"
    },
    {
        "number": 1544,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fixed_bugs = 5\n    new_features = 3\n    total_pennants = fixed_bugs + new_features\n\n    if n > total_pennants:\n        return \"0\"\n\n    combinations = 0\n    for i in range(n, total_pennants + 1):\n        combinations += math.comb(total_pennants, i)\n\n    return str(combinations)"
    },
    {
        "number": 1545,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, a = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    s = list(s)\n\n    def is_valid(substring: str) -> bool:\n        for char in substring:\n            if substring.count(char) > a[ord(char) - ord('a')]:\n                return False\n        return True\n\n    def find_valid_splits(start: int, end: int) -> int:\n        if start > end:\n            return 1\n        count = 0\n        for i in range(start, end + 1):\n            if is_valid(''.join(s[start:i])):\n                count += find_valid_splits(i, end)\n        return count\n\n    valid_splits = find_valid_splits(0, n - 1)\n    max_length = 0\n    min_substrings = n\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = ''.join(s[i:j])\n            if is_valid(substring):\n                max_length = max(max_length, len(substring))\n                min_substrings = min(min_substrings, len(substring))\n\n    return f\"{valid_splits % (10**9 + 7)}\\n{max_length}\\n{min_substrings}\""
    },
    {
        "number": 1546,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arcs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find_cycle(arcs: List[Tuple[int, int]]) -> List[int]:\n        visited = [False] * (n + 1)\n        cycle = []\n        current = 1\n\n        while not visited[current]:\n            visited[current] = True\n            cycle.append(current)\n            current = next(iter([a for a, b in arcs if a == current or b == current]), None)\n\n        return cycle\n\n    cycle = find_cycle(arcs)\n\n    if len(cycle) != n:\n        return \"-1\"\n\n    return \" \".join(map(str, cycle))"
    },
    {
        "number": 1547,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    operations = stdin.split()[3:]\n    table = [[0] * m for _ in range(n)]\n\n    for i in range(k):\n        op, r_or_c, color = operations[i].split()\n        r_or_c = int(r_or_c)\n        color = int(color)\n\n        if op == '1':\n            for j in range(m):\n                table[r_or_c - 1][j] = color\n        else:\n            for j in range(n):\n                table[j][r_or_c - 1] = color\n\n    return '\\n'.join([' '.join(map(str, row)) for row in table])\n"
    },
    {
        "number": 1548,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sticks = list(map(int, stdin.readline().strip().split()))\n    sticks.sort(reverse=True)\n    max_distance = 0\n\n    for i in range(n):\n        max_distance += sticks[i] * sticks[i]\n\n    return str(max_distance)"
    },
    {
        "number": 1549,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    host_cities = list(map(int, stdin.split()[3:n+3]))\n    years = [int(x) for x in stdin.split()[n+3:]]\n\n    # Create a dictionary to store the number of times each city hosted the olympiad\n    city_count = {}\n    for city in host_cities:\n        if city in city_count:\n            city_count[city] += 1\n        else:\n            city_count[city] = 1\n\n    # Create a list to store the host cities for each year\n    host_cities_list = []\n    for year in years:\n        # Find the city with the smallest count\n        min_count = float('inf')\n        min_city = -1\n        for city in range(1, m+1):\n            if city in city_count and city_count[city] < min_count:\n                min_count = city_count[city]\n                min_city = city\n        # Add the city to the list\n        host_cities_list.append(min_city)\n        # Update the count for the selected city\n        city_count[min_city] += 1\n\n    return ' '.join(map(str, host_cities_list))"
    },
    {
        "number": 1550,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, initial_state = stdin.split()\n    n = int(n)\n    initial_state = list(initial_state)\n\n    def add_one(digits: list) -> list:\n        carry = 1\n        for i in range(len(digits) - 1, -1, -1):\n            digit = int(digits[i])\n            digit += carry\n            carry = digit // 10\n            digit %= 10\n            digits[i] = str(digit)\n        if carry:\n            digits.insert(0, '1')\n        return digits\n\n    def shift_right(digits: list) -> list:\n        last_digit = digits.pop()\n        digits.insert(0, last_digit)\n        return digits\n\n    def smallest_number(digits: list) -> str:\n        while True:\n            digits = add_one(digits)\n            digits = shift_right(digits)\n            if digits[0] != '0':\n                break\n        return ''.join(digits)\n\n    return smallest_number(initial_state)"
    },
    {
        "number": 1551,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    people = []\n    for i in range(n):\n        x, v, t = map(int, stdin.split()[2:5])\n        people.append((x, v, t))\n\n    def find_min_time(people, bomb_pos):\n        min_time = float('inf')\n        for person in people:\n            if person[0] == bomb_pos:\n                min_time = 0\n            elif person[0] < bomb_pos:\n                min_time = min(min_time, (bomb_pos - person[0]) / person[1])\n            else:\n                min_time = min(min_time, (person[0] - bomb_pos) / person[1])\n        return min_time\n\n    min_time = float('inf')\n    for i in range(1000000):\n        min_time = min(min_time, find_min_time(people, i))\n\n    return '{:.6f}'.format(min_time)"
    },
    {
        "number": 1552,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, skills = stdin.split()\n    n = int(n)\n    skills = list(map(int, skills.split()))\n\n    teams = 0\n    team_members = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (\n                    skills[i] != skills[j]\n                    and skills[i] != skills[k]\n                    and skills[j] != skills[k]\n                ):\n                    team_members.append((i + 1, j + 1, k + 1))\n                    teams += 1\n\n    if teams == 0:\n        return \"0\"\n\n    return f\"{teams}\\n{' '.join([' '.join(map(str, member)) for member in team_members])}\""
    },
    {
        "number": 1553,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    bottles = list(map(int, stdin.split()[2:]))\n\n    bottles.sort(reverse=True)\n    shelves = [0] * (h + 1)\n    k = 0\n\n    for bottle in bottles:\n        for i in range(h, bottle - 1, -1):\n            if shelves[i] == 0:\n                shelves[i] = 1\n                k += 1\n                break\n\n    return str(k)"
    },
    {
        "number": 1554,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, types = map(int, stdin.split())\n    types = [types[i-1] for i in range(n, 0, -1)]\n    types_dict = {}\n    for i in range(n):\n        if types[i] not in types_dict:\n            types_dict[types[i]] = [i+1]\n        else:\n            types_dict[types[i]].append(i+1)\n    \n    max_segments = 0\n    for key in types_dict:\n        if len(types_dict[key]) > 1:\n            max_segments += len(types_dict[key]) - 1\n    \n    if max_segments == 0:\n        return \"-1\"\n    \n    result = []\n    for key in types_dict:\n        if len(types_dict[key]) > 1:\n            for i in range(len(types_dict[key]) - 1):\n                result.append(f\"{types_dict[key][i]} {types_dict[key][i+1]}\")\n    \n    return f\"{max_segments}\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 1555,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = [list(map(str, stdin.split()[i:i+m])) for i in range(n, n+m*n, m)]\n    evaluations = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \">\":\n                evaluations[i] += 1\n            elif a[i][j] == \"<\":\n                evaluations[j] += 1\n    if max(evaluations) > max(evaluations[i] + evaluations[j] for i in range(n) for j in range(m) if a[i][j] == \"=\"):\n        return \"No\"\n    else:\n        return \"Yes\\n\" + \" \".join(map(str, evaluations)) + \"\\n\" + \" \".join(map(str, [sum(evaluations[:i+1]) for i in range(m)]))"
    },
    {
        "number": 1556,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i] % x\n\n    return \" \".join(map(str, b))\n\n\ndef"
    },
    {
        "number": 1557,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, a_1, c_1, h_2, a_2 = map(int, stdin.split())\n    n = 0\n    while h_2 > 0:\n        n += 1\n        h_1 += c_1\n        h_2 -= a_2\n        if h_1 <= 0:\n            return \"0\"\n    return str(n)\n\ndef"
    },
    {
        "number": 1558,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, avg = map(int, stdin.split()[:3])\n    exams = []\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        exams.append((a, b))\n\n    total_grade = sum(a for a, _ in exams)\n    total_essays = sum(b for _, b in exams)\n\n    if total_grade / n >= avg:\n        return \"0\"\n\n    min_essays = total_essays\n    for a, b in exams:\n        if a < r:\n            min_essays = min(min_essays, total_essays - b + r - a)\n\n    return str(min_essays)\n"
    },
    {
        "number": 1559,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A = map(int, stdin.split())\n    P = str(A + 1)\n    while len(P) < L:\n        P += P\n    return P[:L]"
    },
    {
        "number": 1560,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cockroaches = stdin.split()[1]\n\n    if n == 1:\n        return \"0\"\n\n    black_count = cockroaches.count(\"b\")\n    red_count = n - black_count\n\n    if black_count == 0 or red_count == 0:\n        return \"0\"\n\n    if black_count % 2 == 0 and red_count % 2 == 0:\n        return \"0\"\n\n    if black_count % 2 == 0:\n        return str(red_count // 2)\n\n    if red_count % 2 == 0:\n        return str(black_count // 2)\n\n    return \"1\""
    },
    {
        "number": 1561,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    classroom = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def count_empty_seats(row: int, col: int, direction: str) -> int:\n        count = 0\n        if direction == 'row':\n            for i in range(col, col + k):\n                if classroom[row][i] == '.':\n                    count += 1\n                else:\n                    return count\n        else:\n            for i in range(row, row + k):\n                if classroom[i][col] == '.':\n                    count += 1\n                else:\n                    return count\n        return count\n\n    def find_seats(row: int, col: int, direction: str) -> int:\n        count = 0\n        if direction == 'row':\n            for i in range(col, m):\n                if classroom[row][i] == '.':\n                    count += 1\n                    if count == k:\n                        return 1\n                else:\n                    count = 0\n            return 0\n        else:\n            for i in range(row, n):\n                if classroom[i][col] == '.':\n                    count += 1\n                    if count == k:\n                        return 1\n                else:\n                    count = 0\n            return 0\n\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if classroom[i][j] == '.':\n                result += find_seats(i, j, 'row')\n                result += find_seats(i, j, 'col')\n\n    return result"
    },
    {
        "number": 1562,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q, safe_columns = stdin.split()\n    n, m, k, q = int(n), int(m), int(k), int(q)\n    safe_columns = [int(x) for x in safe_columns.split()]\n\n    treasure_coordinates = []\n    for _ in range(k):\n        r, c = stdin.split()\n        r, c = int(r), int(c)\n        treasure_coordinates.append((r, c))\n\n    def is_safe_column(column: int) -> bool:\n        return column in safe_columns\n\n    def manhattan_distance(cell1: tuple, cell2: tuple) -> int:\n        return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1])\n\n    def get_minimum_moves(treasure_coordinates: list) -> int:\n        minimum_moves = 0\n        for treasure in treasure_coordinates:\n            if treasure[1] == 1:\n                minimum_moves += treasure[0] - 1\n            else:\n                safe_column = next(filter(is_safe_column, range(1, m + 1)))\n                minimum_moves += manhattan_distance(treasure, (treasure[0], safe_column))\n                minimum_moves += treasure[0] - 1\n\n        return minimum_moves\n\n    return str(get_minimum_moves(treasure_coordinates))"
    },
    {
        "number": 1563,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:]))\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:])\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    max_diversity = 0\n    result = 0\n\n    for color in set(colors):\n        vertices = [i for i, c in enumerate(colors) if c == color]\n        diversity = 0\n\n        for vertex in vertices:\n            neighbors = set(colors[i] for i in graph[vertex])\n            diversity += len(neighbors.difference({color}))\n\n        if diversity > max_diversity:\n            max_diversity = diversity\n            result = color\n\n    return str(result)"
    },
    {
        "number": 1564,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    t = stdin.split('\\n')[2]\n\n    if s == t:\n        return \"-1\"\n\n    k = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            k += 1\n\n    if k % 2 != 0:\n        return \"-1\"\n\n    result = []\n    for i in range(n):\n        if s[i] != t[i]:\n            result.append((i, t.index(s[i])))\n\n    return str(k // 2) + '\\n' + '\\n'.join([f\"{x[0]} {x[1]}\" for x in result])"
    },
    {
        "number": 1565,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, n = map(int, stdin.split())\n    n_str = str(n)\n    min_sum = float('inf')\n    for i in range(1, l):\n        left = int(n_str[:i])\n        right = int(n_str[i:])\n        if left == 0 or right == 0:\n            continue\n        current_sum = left + right\n        if current_sum < min_sum:\n            min_sum = current_sum\n    return str(min_sum)"
    },
    {
        "number": 1566,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_lair(lair_corners, grid):\n        x1, y1, x2, y2 = lair_corners\n        if x1 < 0 or x2 > N or y1 < 0 or y2 > N:\n            return False\n        for y in range(y1, y2 + 1):\n            for x in range(x1, x2 + 1):\n                if grid[y][x] == 0:\n                    return False\n        return True\n\n    def count_zombie_contamination(lair_corners, grid):\n        x1, y1, x2, y2 = lair_corners\n        count = 0\n        for y in range(y1, y2 + 1):\n            for x in range(x1, x2 + 1):\n                if grid[y][x] > 0:\n                    count += 1\n        return count\n\n    N = int(stdin.readline().strip())\n    grid = [list(map(int, stdin.readline().strip())) for _ in range(N)]\n\n    for y1 in range(N):\n        for x1 in range(N):\n            for y2 in range(y1, N):\n                for x2 in range(x1, N):\n                    lair_corners = (x1, y1, x2, y2)\n                    if is_valid_lair(lair_corners, grid):\n                        zombie_contamination = count_zombie_contamination(lair_corners, grid)\n                        if zombie_contamination == N * N:\n                            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 1567,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    result = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for l in range(j + 1, n + 1):\n                for m in range(l + 1, n + 1):\n                    if k == 4:\n                        result += 1\n                    elif k == 3:\n                        result += (i * j * l * m) % mod\n                    elif k == 2:\n                        result += (i * j + i * l + i * m + j * l + j * m + l * m) % mod\n                    else:\n                        result += (i + j + l + m) % mod\n\n    return str(result % mod)"
    },
    {
        "number": 1568,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B, C, T = map(int, stdin.split())\n    t = list(map(int, input().split()))\n\n    # Calculate the cost of each message after T minutes\n    costs = [A] * n\n    for i in range(n):\n        for j in range(t[i], T):\n            costs[i] -= B\n\n    # Calculate the maximum amount of money Vasya can hold after T minutes\n    max_money = 0\n    for i in range(n):\n        max_money += costs[i]\n        max_money += C * (n - i - 1)\n\n    return str(max_money)"
    },
    {
        "number": 1569,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    roads = []\n    for i in range(m):\n        x, y, z = map(int, stdin.split()[3*i+2:3*i+5])\n        roads.append((x, y, z))\n\n    # Find the shortest path between city 1 and n\n    def shortest_path(start, end, visited, graph):\n        queue = [(start, [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    if neighbor == end:\n                        return path + [neighbor]\n                    else:\n                        visited.add(neighbor)\n                        queue.append((neighbor, path + [neighbor]))\n        return None\n\n    graph = {i+1: [] for i in range(n)}\n    for x, y, z in roads:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    path = shortest_path(1, n, set(), graph)\n    if not path:\n        return \"0\"\n\n    # Find the affected roads\n    affected_roads = set()\n    for i in range(len(path)-1):\n        affected_roads.add((min(path[i], path[i+1]), max(path[i], path[i+1])))\n\n    # Find the repaired roads\n    repaired_roads = set()\n    for x, y, z in roads:\n        if (x, y) in affected_roads or (y, x) in affected_roads:\n            continue\n        if z == 0:\n            repaired_roads.add((x, y, 1))\n\n    # Find the blown up roads\n    blown_up_roads = set()\n    for x, y, z in roads:\n        if (x, y) in affected_roads or (y, x) in affected_roads:\n            continue\n        if z == 1:\n            blown_up_roads.add((x, y, 0))\n\n    # Output the result\n    result = []\n    for x, y, z in repaired_roads:\n        result.append(f\"{x} {y} {z}\")\n    for x, y, z in blown_up_roads:\n        result.append(f\"{x} {y} {z}\")\n\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 1570,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, w = map(int, stdin.split())\n    if w * k > n:\n        return str(w * k - n)\n    else:\n        return \"0\""
    },
    {
        "number": 1571,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T = stdin.split()\n    n, m = len(S), len(T)\n    MOD = 998244353\n\n    def count_magic_spells(s: str, t: str) -> int:\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, i + 1):\n                if s[i - j:i] == t[:j]:\n                    dp[i] += dp[i - j]\n                    dp[i] %= MOD\n        return dp[-1]\n\n    return str(count_magic_spells(S, T))"
    },
    {
        "number": 1572,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    def is_good(l: int, r: int) -> bool:\n        if l + 2 > r:\n            return True\n        return all(a[i] == a[i] - 1 + a[i] - 2 for i in range(l + 2, r + 1))\n\n    def longest_good_segment(l: int, r: int) -> int:\n        if not is_good(l, r):\n            return 0\n        if r - l + 1 == 2:\n            return 2\n        mid = (l + r) // 2\n        return max(longest_good_segment(l, mid), longest_good_segment(mid + 1, r)) + 1\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, longest_good_segment(i, n - 1))\n\n    return str(max_length)"
    },
    {
        "number": 1573,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    friends = []\n    for _ in range(n):\n        money, friendship = map(int, stdin.split())\n        friends.append((money, friendship))\n\n    friends.sort(key=lambda x: x[0])\n    total_friendship = 0\n    for i in range(n):\n        total_friendship += friends[i][1]\n        for j in range(i + 1, n):\n            if friends[j][0] - friends[i][0] >= d:\n                total_friendship += friends[j][1]\n                break\n\n    return str(total_friendship)"
    },
    {
        "number": 1574,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    def dfs(node, visited, depth):\n        if depth == 3:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, depth + 1):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(1, n + 1):\n        if dfs(i, set(), 0):\n            return str(3)\n    \n    return \"-1\""
    },
    {
        "number": 1575,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_s, t_f, t = map(int, stdin.split()[:3])\n    n = int(stdin.split()[3])\n    visitors = list(map(int, stdin.split()[4:]))\n\n    # Calculate the time when the receptionist stops serving the last visitor\n    receptionist_stop_time = t_f - t\n\n    # Calculate the time when the receptionist starts serving the first visitor\n    receptionist_start_time = t_s + t\n\n    # Calculate the time when the receptionist starts serving the last visitor\n    receptionist_last_visitor_start_time = receptionist_stop_time - t\n\n    # Calculate the time when the receptionist stops serving the last visitor\n    receptionist_last_visitor_stop_time = receptionist_last_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the first visitor\n    receptionist_first_visitor_start_time = receptionist_start_time + t\n\n    # Calculate the time when the receptionist stops serving the first visitor\n    receptionist_first_visitor_stop_time = receptionist_first_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the second visitor\n    receptionist_second_visitor_start_time = receptionist_first_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the second visitor\n    receptionist_second_visitor_stop_time = receptionist_second_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the third visitor\n    receptionist_third_visitor_start_time = receptionist_second_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the third visitor\n    receptionist_third_visitor_stop_time = receptionist_third_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the fourth visitor\n    receptionist_fourth_visitor_start_time = receptionist_third_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the fourth visitor\n    receptionist_fourth_visitor_stop_time = receptionist_fourth_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the fifth visitor\n    receptionist_fifth_visitor_start_time = receptionist_fourth_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the fifth visitor\n    receptionist_fifth_visitor_stop_time = receptionist_fifth_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the sixth visitor\n    receptionist_sixth_visitor_start_time = receptionist_fifth_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the sixth visitor\n    receptionist_sixth_visitor_stop_time = receptionist_sixth_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the seventh visitor\n    receptionist_seventh_visitor_start_time = receptionist_sixth_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the seventh visitor\n    receptionist_seventh_visitor_stop_time = receptionist_seventh_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the eighth visitor\n    receptionist_eighth_visitor_start_time = receptionist_seventh_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the eighth visitor\n    receptionist_eighth_visitor_stop_time = receptionist_eighth_visitor_start_time + t\n\n    # Calculate the time when the receptionist starts serving the ninth visitor\n    receptionist_ninth_visitor_start_time = receptionist_eighth_visitor_stop_time + t\n\n    # Calculate the time when the receptionist stops serving the ninth visitor\n    receptionist_ninth_visitor_stop_time = receptionist_ninth_visitor_start_time + t"
    },
    {
        "number": 1576,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = \"\"\n    for i in range(len(stdin)):\n        if i % 2 == 0:\n            s = stdin[i] + s\n        else:\n            s = s + stdin[i]\n    return s"
    },
    {
        "number": 1577,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    anton_wins = s.count('A')\n    danik_wins = s.count('D')\n\n    if anton_wins > danik_wins:\n        return \"Anton\"\n    elif danik_wins > anton_wins:\n        return \"Danik\"\n    else:\n        return \"Friendship\""
    },
    {
        "number": 1578,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    max_sum = 0\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                remainder = i % j\n                max_sum += remainder\n\n    return str(max_sum)"
    },
    {
        "number": 1579,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a, b, c, d):\n        return a != c and b != d\n\n    def add_dot(a, b, c, d):\n        return (a, b), (a, d), (c, b), (c, d)\n\n    def count_dots(dots):\n        count = 0\n        for dot in dots:\n            count += dot.count(True)\n        return count\n\n    def find_max_operations(dots):\n        max_operations = 0\n        for a in range(N):\n            for b in range(N):\n                for c in range(N):\n                    for d in range(N):\n                        if is_valid(a, b, c, d):\n                            new_dots = add_dot(a, b, c, d)\n                            new_count = count_dots(new_dots)\n                            if new_count == N + 1:\n                                max_operations += 1\n        return max_operations\n\n    N = int(stdin.readline())\n    dots = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().split())\n        dots.append((x, y))\n\n    return str(find_max_operations(dots))"
    },
    {
        "number": 1580,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    pairs = []\n    for i in range(M):\n        X, Y, Z = map(int, stdin.split()[3*i:3*(i+1)])\n        pairs.append((X, Y, Z))\n\n    def is_even(x: int, y: int, z: int) -> bool:\n        return (x + y + z) % 2 == 0\n\n    def magic_cost(card: int) -> int:\n        return 1\n\n    def min_cost(N: int) -> int:\n        if N == 1:\n            return 1\n        if N == 2:\n            return 2\n        return min(min_cost(N-1) + magic_cost(N-1), min_cost(N-2) + magic_cost(N-2))\n\n    total_cost = 0\n    for pair in pairs:\n        X, Y, Z = pair\n        if is_even(X, Y, Z):\n            total_cost += min_cost(Y - X + 1)\n\n    return str(total_cost)"
    },
    {
        "number": 1581,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_sequences(n: int, k: int) -> int:\n        if k == 1:\n            return 1\n        if n == 1:\n            return count_sequences(n, k - 1)\n        return (count_sequences(n - 1, k) + count_sequences(n - 1, k - 1)) % MOD\n\n    return str(count_sequences(N, K))"
    },
    {
        "number": 1582,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i % 10 == j // 10 and j % 10 == i // 10:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1583,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x = map(int, stdin.split())\n    if x > a**2 * b:\n        return \"Error: x is greater than the volume of the bottle.\"\n    elif x == a**2 * b:\n        return \"0.000000000\"\n    else:\n        angle = 2 * math.degrees(math.acos(math.sqrt(x / (a**2 * b))))\n        return f\"{angle:.10f}\""
    },
    {
        "number": 1584,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sticks = stdin.split(\"\\n\")\n    N = int(N)\n    sticks = list(map(int, sticks.split()))\n\n    def is_valid_triangle(a, b, c):\n        return a < b + c and b < c + a and c < a + b\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if is_valid_triangle(sticks[i], sticks[j], sticks[k]):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 1585,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    max_length = 0\n    for i in range(X, Y+1):\n        for j in range(i+1, Y+1):\n            if j % i == 0:\n                length = 2\n                while (j * length) <= Y:\n                    if j * length <= Y and (j * (length+1)) > Y:\n                        max_length = max(max_length, length)\n                        break\n                    length += 1\n    return str(max_length)"
    },
    {
        "number": 1586,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 2:\n        return \"1\"\n\n    zeros = 0\n    while n >= 5:\n        n //= 5\n        zeros += n\n\n    return str(zeros)"
    },
    {
        "number": 1587,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, stones = stdin.split()\n    N = int(N)\n    operations = 0\n\n    for i in range(N - 1):\n        if stones[i] == 'W' and stones[i + 1] == 'R':\n            if i == 0:\n                operations += 1\n            else:\n                operations += 2\n\n    return str(operations)"
    },
    {
        "number": 1588,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_str = stdin.split('\\n')\n    n = int(n)\n    x = list(map(int, x_str.split()))\n    s = 10**6\n    y = [i for i in range(1, s+1) if i not in x]\n    m = len(y)\n    y_sum = sum(y)\n    x_sum = sum(x)\n    x_minus_one_sum = sum(x_i - 1 for x_i in x)\n    y_minus_one_sum = s * m - y_sum\n    if x_minus_one_sum == y_minus_one_sum:\n        return f\"{m}\\n{' '.join(map(str, y))}\"\n    else:\n        return \"No solution\""
    },
    {
        "number": 1589,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    floors = stdin.split('\\n')[1:]\n    lights_on = 0\n\n    for i in range(n):\n        for j in range(m):\n            if floors[i][2 * j] == '1' or floors[i][2 * j + 1] == '1':\n                lights_on += 1\n\n    return str(lights_on)"
    },
    {
        "number": 1590,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    MOD = 10**9 + 7\n    f = lambda l, r: sum((a[l - 1 + i] * (i + 1) for i in range(r - l + 1)))\n\n    total_sum = sum(f(l, r) for l in range(1, n + 1) for r in range(l, n + 1))\n    return str(total_sum % MOD)"
    },
    {
        "number": 1591,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    sets = [[] for _ in range(k)]\n    for i in range(n):\n        sets[a[i] - 1].append(i)\n    max_students = 0\n    for i in range(k):\n        if len(sets[i]) % 2 == 0:\n            max_students += len(sets[i]) // 2\n        else:\n            max_students += len(sets[i]) // 2 + 1\n    return str(max_students)"
    },
    {
        "number": 1592,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tasks = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    tasks.sort(key=lambda x: x[0])\n    queue = []\n    last_sent_time = 0\n    max_queue_size = 0\n    \n    for task in tasks:\n        receiving_time, messages_count = task\n        while queue and queue[0][0] <= receiving_time:\n            queue.pop(0)\n        queue.append((receiving_time + messages_count, messages_count))\n        max_queue_size = max(max_queue_size, len(queue))\n        last_sent_time = max(last_sent_time, receiving_time + messages_count - 1)\n    \n    return f\"{last_sent_time} {max_queue_size}\""
    },
    {
        "number": 1593,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    locations = []\n    for i in range(n):\n        x, y, k = map(int, stdin.split()[3*i:3*(i+1)])\n        locations.append((x, y, k))\n\n    total_population = sum(k for _, _, k in locations)\n    if total_population < s:\n        return \"-1\"\n\n    min_radius = float(\"inf\")\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1, k1 = locations[i]\n            x2, y2, k2 = locations[j]\n            radius = ((x1-x2)**2 + (y1-y2)**2)**0.5\n            if k1 + k2 + total_population - k1 - k2 <= s:\n                min_radius = min(min_radius, radius)\n\n    return str(min_radius)"
    },
    {
        "number": 1594,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    songs = []\n    for _ in range(n):\n        c, t = map(int, stdin.split()[:2])\n        songs.append((c, t))\n\n    moments = list(map(int, stdin.split()[2 * n + 1:]))\n\n    total_duration = sum(c * t for c, t in songs)\n    current_duration = 0\n    current_song = 1\n    result = []\n\n    for moment in moments:\n        while current_duration < moment * 60:\n            current_duration += songs[current_song - 1][1]\n            current_song += songs[current_song - 1][0]\n        result.append(current_song)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1595,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sum, limit = map(int, stdin.split())\n    if sum > limit * (limit + 1) // 2:\n        return \"-1\"\n\n    n = 0\n    for i in range(1, limit + 1):\n        if sum - i <= limit * (limit + 1) // 2 - (limit - i) * (limit - i + 1) // 2:\n            n = i\n            break\n\n    if n == 0:\n        return \"-1\"\n\n    S = []\n    for i in range(1, n + 1):\n        S.append(i)\n\n    return str(n) + \"\\n\" + \" \".join(map(str, S))\n\n\ndef"
    },
    {
        "number": 1596,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.lower()\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i] == 'w':\n            count += 1\n        elif stdin[i] == 'm':\n            count += 1\n    return count % (10**9 + 7)"
    },
    {
        "number": 1597,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = stdin.split('\\n')[1:n+1]\n    pseudonyms = stdin.split('\\n')[n+1:]\n    \n    max_quality = 0\n    max_matching = []\n    \n    for i in range(n):\n        for j in range(n):\n            lcp = 0\n            while lcp < min(len(students[i]), len(pseudonyms[j])) and students[i][lcp] == pseudonyms[j][lcp]:\n                lcp += 1\n            quality = lcp\n            if quality > max_quality:\n                max_quality = quality\n                max_matching = [(i+1, j+1)]\n            elif quality == max_quality:\n                max_matching.append((i+1, j+1))\n    \n    result = str(max_quality) + '\\n'\n    for match in max_matching:\n        result += str(match[0]) + ' ' + str(match[1]) + '\\n'\n    \n    return result"
    },
    {
        "number": 1598,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    t = ['0'] * n\n    max_zeroes = n\n    \n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j+1].count('0') <= max_zeroes:\n                t[i:j+1] = ['1'] * (j-i+1)\n                max_zeroes = s[i:j+1].count('0')\n    \n    return ''.join(t)"
    },
    {
        "number": 1599,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    n = int(s[0])\n    m = int(s[1])\n    queries = []\n    for i in range(m):\n        l, r = map(int, input().split())\n        queries.append((l, r))\n\n    for l, r in queries:\n        count = 0\n        for i in range(l, r):\n            if s[i] == \"#\":\n                count += 1\n        print(count)"
    },
    {
        "number": 1600,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    max_blocks = 1\n    for i in range(n - 1):\n        if heights[i] > heights[i + 1]:\n            max_blocks += 1\n\n    return str(max_blocks)"
    },
    {
        "number": 1601,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, stdin.splitlines()[i].split())\n        points.append((x, y, z, i))\n\n    def is_perfectly_balanced(a, b):\n        x_min, x_max = min(a[0], b[0]), max(a[0], b[0])\n        y_min, y_max = min(a[1], b[1]), max(a[1], b[1])\n        z_min, z_max = min(a[2], b[2]), max(a[2], b[2])\n        for point in points:\n            if point[3] not in (a[3], b[3]):\n                if x_min <= point[0] <= x_max and y_min <= point[1] <= y_max and z_min <= point[2] <= z_max:\n                    return False\n        return True\n\n    def find_perfectly_balanced_pair():\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_perfectly_balanced(points[i], points[j]):\n                    return i + 1, j + 1\n        return None\n\n    result = []\n    for _ in range(n // 2):\n        pair = find_perfectly_balanced_pair()\n        if pair is None:\n            return \"Impossible\"\n        result.extend(pair)\n        points.remove(points[pair[0] - 1])\n        points.remove(points[pair[1] - 1])\n\n    return \"\\n\".join(f\"{a} {b}\" for a, b in enumerate(result, start=1))"
    },
    {
        "number": 1602,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n\n    def f(x, y):\n        return (x | y) - y\n\n    def value(array):\n        if len(array) == 1:\n            return array[0]\n        else:\n            return f(value(array[:-1]), array[-1])\n\n    max_value = value(array)\n    max_array = array\n\n    for permutation in itertools.permutations(array):\n        if value(permutation) > max_value:\n            max_value = value(permutation)\n            max_array = permutation\n\n    return \" \".join(map(str, max_array))"
    },
    {
        "number": 1603,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stones, m = map(int, stdin.split('\\n')[0].split())\n    stones = list(map(int, stdin.split('\\n')[1].split()))\n    questions = []\n    for i in range(2, m+2):\n        questions.append(list(map(int, stdin.split('\\n')[i].split())))\n\n    def sum_costs(l, r, costs):\n        return sum(costs[l-1:r])\n\n    def sum_cheapest_costs(l, r, costs):\n        costs.sort()\n        return sum(costs[:r-l+1])\n\n    answers = []\n    for question in questions:\n        if question[0] == 1:\n            answers.append(sum_costs(question[1], question[2], stones))\n        else:\n            answers.append(sum_cheapest_costs(question[1], question[2], stones))\n\n    return '\\n'.join(map(str, answers))\n\n\ndef"
    },
    {
        "number": 1604,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    lamps = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[2*i+2:2*i+4])\n        lamps.append((l, r))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid(lamps):\n        l, r = lamps[0]\n        for i in range(1, len(lamps)):\n            l1, r1 = lamps[i]\n            l = lcm(l, l1)\n            r = r * r1 // gcd(r, r1)\n            if l > r:\n                return False\n        return True\n\n    def count_valid(lamps):\n        count = 0\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                for k in range(j + 1, len(lamps)):\n                    if is_valid([lamps[i], lamps[j], lamps[k]]):\n                        count += 1\n        return count\n\n    valid_lamps = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_valid([lamps[i], lamps[j], lamps[k]]):\n                    valid_lamps.append([lamps[i], lamps[j], lamps[k]])\n\n    return str(count_valid(valid_lamps) % 998244353)"
    },
    {
        "number": 1605,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def merge_chars(s: str) -> str:\n        result = []\n        prev_char = None\n        count = 0\n\n        for char in s:\n            if char == prev_char:\n                count += 1\n            else:\n                if prev_char is not None:\n                    result.append(prev_char + str(count))\n                prev_char = char\n                count = 1\n\n        if prev_char is not None:\n            result.append(prev_char + str(count))\n\n        return ''.join(result)\n\n    def count_good_substrings(s: str, length: int) -> int:\n        count = 0\n        for i in range(len(s) - length + 1):\n            substring = s[i:i + length]\n            if is_palindrome(merge_chars(substring)):\n                count += 1\n        return count\n\n    even_length_good_substrings = count_good_substrings(stdin, 2)\n    odd_length_good_substrings = count_good_substrings(stdin, 3)\n\n    return f\"{even_length_good_substrings} {odd_length_good_substrings}\""
    },
    {
        "number": 1606,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split('\\n')[0].split())\n    matrix = [list(map(int, stdin.split('\\n')[i+1].split())) for i in range(n)]\n    queries = stdin.split('\\n')[n+2:]\n\n    def unusual_square(matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        return sum(sum(matrix[i][j] * matrix[j][i] for j in range(n)) for i in range(n))\n\n    def flip_row(matrix: List[List[int]], row: int) -> None:\n        matrix[row] = [1 - x for x in matrix[row]]\n\n    def flip_col(matrix: List[List[int]], col: int) -> None:\n        for i in range(n):\n            matrix[i][col] = 1 - matrix[i][col]\n\n    result = []\n    for query in queries:\n        if query[0] == '1':\n            flip_row(matrix, int(query[2:]))\n        elif query[0] == '2':\n            flip_col(matrix, int(query[2:]))\n        else:\n            result.append(str(unusual_square(matrix)))\n\n    return ''.join(result)"
    },
    {
        "number": 1607,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    def count_beautiful_bicolorings(n: int, k: int) -> int:\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n        if k == n:\n            return 2\n        if k > n:\n            return 0\n\n        count = 0\n        for i in range(n):\n            if i % 2 == 0:\n                count += count_beautiful_bicolorings(n, k - 1)\n            else:\n                count += count_beautiful_bicolorings(n, k - 2)\n        return count % mod\n\n    return str(count_beautiful_bicolorings(n, k))"
    },
    {
        "number": 1608,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if all(math.gcd(a[i], a[k]) == 1 for k in range(i+1, j)):\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 1609,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    inventory_numbers = list(map(int, stdin.split()[1:]))\n\n    # Create a dictionary to store the current inventory numbers and their indices\n    inventory_dict = {inventory_numbers[i]: i for i in range(n)}\n\n    # Sort the inventory numbers and assign new inventory numbers\n    sorted_inventory_numbers = sorted(inventory_numbers)\n    for i in range(n):\n        inventory_dict[sorted_inventory_numbers[i]] = i + 1\n\n    # Create the final inventory numbers list\n    final_inventory_numbers = [inventory_dict[inventory_numbers[i]] for i in range(n)]\n\n    return \" \".join(map(str, final_inventory_numbers))"
    },
    {
        "number": 1610,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    for i in range(1, n + 1):\n        result.append(i)\n    for i in range(k):\n        for j in range(n - 1, i, -1):\n            if result[j] > result[j - 1]:\n                result[j], result[j - 1] = result[j - 1], result[j]\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1611,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, lengths = map(int, stdin.split())\n    lengths.sort(reverse=True)\n    min_length = 1\n    for i in range(n):\n        if sum(lengths[:i+1]) >= i+1:\n            min_length = max(min_length, lengths[i] - sum(lengths[:i+1]) + i+1)\n    return str(min_length)"
    },
    {
        "number": 1612,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = [line.split() for line in stdin.split('\\n')[1:n+1]]\n    result = []\n\n    for i in range(n):\n        card = cards[i]\n        m = int(card[0])\n        numbers = set(card[1:])\n        balls = set(range(1, 101))\n        can_win = True\n\n        for number in balls:\n            if number not in numbers:\n                continue\n            balls.remove(number)\n            if len(balls) == 0:\n                can_win = False\n                break\n\n        if can_win:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1614,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    width = 0\n    for i in range(n):\n        if a[i] > h:\n            width += 2\n        else:\n            width += 1\n\n    return str(width)"
    },
    {
        "number": 1615,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    segments = []\n    for line in stdin.split()[1:]:\n        l, r = map(int, line.split())\n        segments.append((l, r))\n\n    def value(segments):\n        count = 0\n        for l, r in segments:\n            count += r - l + 1\n        return count\n\n    def move(segments, i, direction):\n        l, r = segments[i]\n        if direction == \"left\":\n            segments[i] = (l - 1, r)\n        else:\n            segments[i] = (l, r + 1)\n        return segments\n\n    def is_divisible(value, k):\n        return value % k == 0\n\n    def min_moves(segments, k):\n        current_value = value(segments)\n        if is_divisible(current_value, k):\n            return 0\n\n        for i in range(len(segments)):\n            for direction in [\"left\", \"right\"]:\n                new_segments = move(segments.copy(), i, direction)\n                new_value = value(new_segments)\n                if is_divisible(new_value, k):\n                    return 1\n                else:\n                    moves = min_moves(new_segments, k)\n                    if moves > 0:\n                        return 1 + moves\n        return -1\n\n    return str(min_moves(segments, k))"
    },
    {
        "number": 1616,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def count_divisors(num: int) -> int:\n        divisors = 0\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors += 2 if i * i == num else 1\n        return divisors\n\n    max_divisors = max(map(count_divisors, a))\n    if max_divisors > 7:\n        return \"-1\"\n\n    def is_perfect_square(num: int) -> bool:\n        return int(num**0.5)**2 == num\n\n    def find_shortest_subsequence(a: List[int]) -> int:\n        n = len(a)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if is_perfect_square(a[i] * a[j]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    return str(find_shortest_subsequence(a))"
    },
    {
        "number": 1617,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fun_values = set()\n    for k in range(1, n + 1):\n        fun_value = 0\n        current_person = 1\n        for _ in range(k):\n            fun_value += current_person\n            current_person = (current_person % n) + 1\n        fun_values.add(fun_value)\n    return \" \".join(map(str, sorted(fun_values)))"
    },
    {
        "number": 1618,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stairs = stdin.split('\\n', 1)\n    n = int(n)\n    stairs = list(map(int, stairs.split()))\n    m, boxes = stdin.split('\\n', 2)[1:]\n    m = int(m)\n    boxes = boxes.split('\\n')\n    boxes = [list(map(int, box.split())) for box in boxes]\n\n    heights = []\n    for box in boxes:\n        w, h = box\n        height = 0\n        for i in range(w):\n            if stairs[i] - height >= h:\n                height = stairs[i] - h\n            else:\n                height = stairs[i]\n        heights.append(height)\n\n    return '\\n'.join(map(str, heights))\n\n\ndef"
    },
    {
        "number": 1619,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_well_connected(vertices1, vertices2):\n        def is_intersecting(p1, p2, p3, p4):\n            def on_segment(p1, p2, p3):\n                return (min(p1[0], p2[0]) <= p3[0] <= max(p1[0], p2[0]) and\n                        min(p1[1], p2[1]) <= p3[1] <= max(p1[1], p2[1]))\n\n            def orientation(p1, p2, p3):\n                return (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p3[1] - p2[1]) * (p2[0] - p1[0])\n\n            return (on_segment(p1, p2, p3) or on_segment(p1, p3, p2)) and (orientation(p1, p2, p3) != orientation(p1, p3, p2))\n\n        for i in range(len(vertices1)):\n            p1 = vertices1[i]\n            p2 = vertices1[(i + 1) % len(vertices1)]\n            for j in range(len(vertices2)):\n                p3 = vertices2[j]\n                p4 = vertices2[(j + 1) % len(vertices2)]\n                if is_intersecting(p1, p2, p3, p4):\n                    return False\n        return True\n\n    def read_polygon(input_lines):\n        vertices = []\n        for line in input_lines:\n            x, y, z = map(int, line.split())\n            vertices.append((x, y, z))\n        return vertices\n\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    vertices1 = read_polygon(input_lines[1:n+1])\n    m = int(input_lines[n+1])\n    vertices2 = read_polygon(input_lines[n+2:])\n\n    return \"YES\" if is_well_connected(vertices1, vertices2) else \"NO\""
    },
    {
        "number": 1620,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"a\"\n    elif n == 2:\n        return \"ab\"\n    else:\n        result = [\"a\"] * (n - 1)\n        result.append(\"b\")\n        return \"\".join(result)"
    },
    {
        "number": 1621,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k, w = stdin.split('\\n')\n    w = [int(x) for x in w.split()]\n    w_dict = {chr(i): w[i-97] for i in range(97, 123)}\n\n    def f(s: str) -> int:\n        return sum(w_dict[c] * i for i, c in enumerate(s, 1))\n\n    max_value = 0\n    for i in range(len(s) + 1):\n        for j in range(i + 1, len(s) + 1):\n            for c in range(97, 97 + k):\n                new_s = s[:i] + chr(c) + s[j:]\n                max_value = max(max_value, f(new_s))\n\n    return max_value"
    },
    {
        "number": 1622,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    events = stdin.split('\\n')[1:]\n    boss = [0] * (n + 1)\n    packets = []\n    queries = []\n\n    for event in events:\n        t, *args = map(int, event.split())\n        if t == 1:\n            x, y = args\n            boss[x] = y\n        elif t == 2:\n            x = args[0]\n            packets.append(x)\n        elif t == 3:\n            x, i = args\n            queries.append((x, i))\n\n    for x, i in queries:\n        packet = packets[i - 1]\n        while packet != 0:\n            if packet == x:\n                print(\"YES\")\n                break\n            packet = boss[packet]\n        else:\n            print(\"NO\")"
    },
    {
        "number": 1623,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    min_sum = sum(range(1, l + 1))\n    max_sum = sum(range(1, r + 1))\n    return f\"{min_sum} {max_sum}\""
    },
    {
        "number": 1624,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(m):\n        for i in range(n):\n            if i % m == 0:\n                count = 1\n            if i % m != 0 and count < 2:\n                return False\n            if i % m == 0:\n                count = 0\n        return True\n\n    def sum_of_squares(m):\n        groups = [a[i:i + m] for i in range(0, n, m)]\n        return sum(sum(group) ** 2 for group in groups)\n\n    min_sum_of_squares = float('inf')\n    for m in range(2, n + 1):\n        if is_valid(m):\n            sum_of_squares_value = sum_of_squares(m)\n            if sum_of_squares_value < min_sum_of_squares:\n                min_sum_of_squares = sum_of_squares_value\n\n    return str(min_sum_of_squares)"
    },
    {
        "number": 1625,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    matrix = [[0] * (2**n) for _ in range(2**n)]\n    \n    def fill_matrix(matrix, numbers, row, col, n):\n        if n == 0:\n            matrix[row][col] = numbers.pop(0)\n            return\n        \n        fill_matrix(matrix, numbers, row, col, n-1)\n        fill_matrix(matrix, numbers, row, col+2**(n-1), n-1)\n        fill_matrix(matrix, numbers, row+2**(n-1), col+2**(n-1), n-1)\n        fill_matrix(matrix, numbers, row+2**(n-1), col, n-1)\n    \n    fill_matrix(matrix, numbers, 0, 0, n)\n    \n    def max_beauty(matrix, n):\n        if n == 0:\n            return matrix[0][0]\n        \n        max_val = max(max(row) for row in matrix)\n        submatrices = [matrix[:2**(n-1), :2**(n-1)], matrix[:2**(n-1), 2**(n-1):], matrix[2**(n-1):, 2**(n-1):], matrix[2**(n-1):, :2**(n-1)]]\n        return max_val + sum(max_beauty(submatrix, n-1) for submatrix in submatrices)\n    \n    return str(max_beauty(matrix, n))"
    },
    {
        "number": 1626,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n//k]))\n    b = list(map(int, stdin.split()[2+n//k:]))\n    \n    def is_good(phone_number: str) -> bool:\n        for i in range(k):\n            block = phone_number[i*k:(i+1)*k]\n            block_int = int(block)\n            if block_int % a[i] != 0:\n                return False\n            if int(block[0]) != b[i]:\n                return False\n        return True\n    \n    good_phone_numbers = 0\n    for i in range(10**(n-k)):\n        phone_number = str(i).zfill(n)\n        if is_good(phone_number):\n            good_phone_numbers += 1\n    \n    return str(good_phone_numbers % (10**9 + 7))"
    },
    {
        "number": 1627,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    operations = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and heights[j] >= heights[i]:\n            j += 1\n        if j - i > 1:\n            operations.append((i + 1, j))\n        i = j\n\n    return \"\\n\".join(f\"{l} {r}\" for l, r in operations)\n"
    },
    {
        "number": 1628,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    while True:\n        found = False\n        for i in range(len(s) - 1):\n            if s[i] == 'y' and s[i + 1] == 'x':\n                s[i], s[i + 1] = s[i + 1], s[i]\n                found = True\n                break\n        if not found:\n            break\n\n    while True:\n        found = False\n        for i in range(len(s) - 1):\n            if s[i] == 'x' and s[i + 1] == 'y':\n                s.pop(i)\n                s.pop(i)\n                found = True\n                break\n        if not found:\n            break\n\n    return ''.join(s)\n"
    },
    {
        "number": 1629,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    balls = list(map(int, stdin.split()[2:]))\n    \n    for i in range(x, n):\n        balls[i] += balls[i+1]\n    balls[x-1] += balls[x]\n    balls[x-1] -= 1\n    \n    for i in range(x-2, -1, -1):\n        balls[i] += balls[i+1]\n    \n    return \" \".join(map(str, balls[:x] + balls[x+1:]))"
    },
    {
        "number": 1630,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    clubs = []\n    for i in range(n):\n        team, hometown = stdin.split()[1+i].split()\n        clubs.append((team, hometown))\n\n    short_names = []\n    for club in clubs:\n        team, hometown = club\n        if team[0:3] == hometown[0]:\n            short_names.append(team[0:3])\n        elif team[0:2] == hometown[0:2]:\n            short_names.append(team[0:2] + hometown[0])\n        else:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(short_names)\n\n\ndef"
    },
    {
        "number": 1631,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.split('\\n')[1:]\n    sorted_names = sorted(names)\n\n    if sorted_names == names:\n        return \"Impossible\"\n\n    for i in range(26):\n        modified_names = [name[::-1] for name in names]\n        modified_names = [''.join([chr(((ord(c) - ord('a') + i) % 26) + ord('a')) for c in name]) for name in modified_names]\n        sorted_modified_names = sorted(modified_names)\n\n        if sorted_modified_names == names:\n            return ''.join([chr(ord('a') + (j + i) % 26) for j in range(26)])\n\n    return \"Impossible\""
    },
    {
        "number": 1632,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    balls = list(map(int, stdin.split()[1:]))\n    balls.sort()\n\n    def count_combinations(balls, target):\n        count = 0\n        for i in range(len(balls)):\n            for j in range(i + 1, len(balls)):\n                if balls[i] + balls[j] == target:\n                    count += 1\n        return count\n\n    total_combinations = (n * (n - 1)) // 2\n    andrew_wins = count_combinations(balls, balls[0] + balls[1])\n    jerry_wins = count_combinations(balls, balls[-1] + balls[-2])\n\n    probability = (andrew_wins * jerry_wins) / total_combinations\n\n    return str(probability)"
    },
    {
        "number": 1633,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    moves = [tuple(map(int, line.split())) for line in stdin.split()[3:]]\n\n    board = [[0] * m for _ in range(n)]\n    for i, j in moves:\n        board[i - 1][j - 1] = 1\n        if board[i - 1][j - 1] == board[i - 2][j - 1] == board[i - 1][j - 2] == 1:\n            return str(moves.index((i, j)) + 1)\n    return \"0\""
    },
    {
        "number": 1634,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c_1, c_2, c_3, c_4 = map(int, stdin.split()[0].split())\n    n, m = map(int, stdin.split()[1].split())\n    a = list(map(int, stdin.split()[2].split()))\n    b = list(map(int, stdin.split()[3].split()))\n\n    min_cost = float('inf')\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            cost = 0\n            if i > 0:\n                cost += i * c_1\n            if j > 0:\n                cost += j * c_1\n            if i > 0 or j > 0:\n                cost += c_2\n            if i == n or j == m:\n                cost += c_3\n            if i == n and j == m:\n                cost += c_4\n            min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 1635,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cafes = stdin.splitlines()[1].split()\n    last_visit = {}\n    for i, cafe in enumerate(cafes):\n        last_visit[cafe] = i\n    max_visit = -1\n    result = None\n    for cafe in cafes:\n        if last_visit[cafe] > max_visit:\n            max_visit = last_visit[cafe]\n            result = cafe\n    return result"
    },
    {
        "number": 1636,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_aesthetically_pleasing(points, w):\n        n = len(points)\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            for j in range(n + 1):\n                if j >= points[i - 1][0] and dp[i - 1][j - points[i - 1][0]]:\n                    dp[i][j] = True\n        for i in range(n):\n            if dp[n][w[i]] and dp[n][w[i] - 1]:\n                return True\n        return False\n\n    def find_aesthetically_pleasing_numbering(points, w):\n        n = len(points)\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            for j in range(n + 1):\n                if j >= points[i - 1][0] and dp[i - 1][j - points[i - 1][0]]:\n                    dp[i][j] = True\n        for i in range(n, 0, -1):\n            for j in range(n, 0, -1):\n                if dp[i][j]:\n                    return i\n        return -1\n\n    def find_point_with_special_value(points, w, numbering):\n        for i in range(len(points)):\n            if numbering[i] == w[i]:\n                return points[i]\n        return None\n\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n    w = list(map(int, stdin.readline().split()))\n\n    if is_aesthetically_pleasing(points, w):\n        numbering = [find_aesthetically_pleasing_numbering(points, w)]\n        point = find_point_with_special_value(points, w, numbering)\n        if point is not None:\n            print(\"YES\")\n            print(f\"{point[0]} {point[1]}\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")"
    },
    {
        "number": 1637,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    scores = []\n    for i in range(n):\n        scores.append(list(map(int, stdin.split()[2*i+2:2*i+4])))\n    hates = []\n    for i in range(m):\n        hates.append(list(map(int, stdin.split()[2*m+2*i:2*m+2*i+2])))\n    \n    def get_score(person1, person2):\n        return scores[person1][0] + scores[person2][1]\n    \n    def get_sum_of_scores(person):\n        total_score = 0\n        for i in range(n):\n            if i != person:\n                total_score += get_score(person, i)\n        return total_score\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (i, j) not in hates and (j, i) not in hates:\n                get_score(i, j)\n    \n    result = []\n    for i in range(n):\n        result.append(get_sum_of_scores(i))\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1638,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = list(map(int, stdin.split()[1:]))\n\n    floors = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if m[j] < m[i]:\n                floors[i] = max(floors[i], floors[j] + 1)\n        for k in range(i + 1, n):\n            if m[k] < m[i]:\n                floors[i] = max(floors[i], floors[k] - 1)\n\n    return \" \".join(map(str, floors))"
    },
    {
        "number": 1639,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_length = 1\n    current_length = 1\n    for i in range(1, n):\n        if a[i] >= a[i-1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    return str(max(max_length, current_length))"
    },
    {
        "number": 1640,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if abs(a[i] - a[j-1]) > 1:\n                total += a[j-1] - a[i]\n            elif abs(a[i] - a[j-1]) <= 1:\n                total += 0\n    return str(total)"
    },
    {
        "number": 1641,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s, t = map(int, stdin.split()[:4])\n    cars = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    gas_stations = list(map(int, stdin.split('\\n')[n+1].split()))\n\n    def fuel_time(distance, mode):\n        if mode == 'normal':\n            return distance / 2\n        else:\n            return distance / 1\n\n    def fuel_cost(distance, mode):\n        if mode == 'normal':\n            return 1\n        else:\n            return 2\n\n    def fuel_tank_capacity(car):\n        return car[1]\n\n    def fuel_needed(distance, mode, tank_capacity):\n        return distance * fuel_cost(distance, mode)\n\n    def can_reach_cinema(car, gas_stations):\n        mode = 'normal'\n        distance = 0\n        fuel_left = fuel_tank_capacity(car)\n        for gas_station in gas_stations:\n            if distance + gas_station > s:\n                return False\n            time_to_gas_station = fuel_time(distance, mode)\n            distance_to_gas_station = distance + gas_station\n            fuel_needed_to_gas_station = fuel_needed(distance_to_gas_station, mode, fuel_left)\n            if fuel_needed_to_gas_station > fuel_left:\n                return False\n            fuel_left -= fuel_needed_to_gas_station\n            distance = distance_to_gas_station\n            time_to_cinema = fuel_time(s - distance, mode)\n            if time_to_cinema <= t:\n                return True\n        return False\n\n    min_price = float('inf')\n    min_car = None\n    for car in cars:\n        if can_reach_cinema(car, gas_stations):\n            if car[0] < min_price:\n                min_price = car[0]\n                min_car = car\n\n    return str(min_car[0]) if min_car else '-1'"
    },
    {
        "number": 1642,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        points.append((x, y))\n\n    def cross_product(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def is_convex(points):\n        n = len(points)\n        for i in range(n):\n            a, b, c = points[i-2], points[i-1], points[(i+1) % n]\n            if cross_product(a, b, c) < 0:\n                return False\n        return True\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a, b, c = points[i], points[j], points[k]\n                distance = max(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(b[0] - c[0]), abs(b[1] - c[1]), abs(c[0] - a[0]), abs(c[1] - a[1]))\n                max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 1643,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    t = ['0'] * n\n    max_zeros = n\n    \n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            zeros = substring.count('0')\n            if zeros == max_zeros:\n                t[i:j+1] = ['1'] * (j-i+1)\n            elif zeros > max_zeros:\n                max_zeros = zeros\n                t = ['0'] * n\n                t[i:j+1] = ['1'] * (j-i+1)\n                \n    return ''.join(t)"
    },
    {
        "number": 1644,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rings = []\n    for _ in range(n):\n        a, b, h = map(int, stdin.readline().strip().split())\n        rings.append((a, b, h))\n\n    rings.sort(key=lambda x: x[1], reverse=True)\n    height = 0\n    for i in range(n):\n        height = max(height, rings[i][2])\n        for j in range(i):\n            if rings[j][1] <= rings[i][0]:\n                height = max(height, rings[i][2] + rings[j][2])\n\n    return str(height)"
    },
    {
        "number": 1645,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(subarray: List[int]) -> bool:\n        return sum(subarray) != 0\n\n    def good_subarrays(array: List[int]) -> int:\n        count = 0\n        for i in range(len(array)):\n            for j in range(i + 1, len(array) + 1):\n                if is_good(array[i:j]):\n                    count += 1\n        return count\n\n    return str(good_subarrays(a))"
    },
    {
        "number": 1646,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    while True:\n        new_s = \"\"\n        i = 0\n        while i < len(s):\n            if s[i:i+2] == \"11\":\n                new_s += \"1\"\n                i += 2\n            else:\n                new_s += s[i]\n                i += 1\n        if new_s == s:\n            return new_s\n        s = new_s"
    },
    {
        "number": 1647,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    valya_pullover = stdin.split('\\n')[1]\n    tolya_tshirt = stdin.split('\\n')[2]\n\n    mana = 0\n    spells = []\n\n    for i in range(n):\n        if valya_pullover[i] != tolya_tshirt[i]:\n            mana += 1\n            spells.append((valya_pullover[i], tolya_tshirt[i]))\n\n    return str(mana) + '\\n' + '\\n'.join([' '.join(spell) for spell in spells])\n\n\ninput_str = '''3\nabb\ndad'''\nprint(solution(input_str))\n\ninput_str = '''8\ndrpepper\ncocacola'''\nprint(solution(input_str)) "
    },
    {
        "number": 1648,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Calculate the number of ways to arrange the N balls so that Takahashi will need exactly i moves to collect all the blue balls\n    def count_ways(i: int) -> int:\n        if i == 0:\n            return 1\n        if i > N:\n            return 0\n        if i == 1:\n            return K\n        if i == 2:\n            return pow(K, 2, MOD)\n        return pow(K, i, MOD) + pow(K, i - 1, MOD) + pow(K, i - 2, MOD)\n\n    # Print the number of ways for each i such that 1 <= i <= K\n    for i in range(1, K + 1):\n        print(count_ways(i))"
    },
    {
        "number": 1649,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    total = A + B + C + D\n    if total % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1650,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin, 2)\n    count = 0\n    for a in range(L + 1):\n        for b in range(L + 1):\n            if a + b <= L and a ^ b == a:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1651,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P = map(int, stdin.split())\n    for i in range(1, S // 2 + 1):\n        if i * (S - i) == P:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 1652,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin\n    T = \"\"\n    operations = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\n\n    while S != T:\n        for operation in operations:\n            if S.endswith(operation):\n                T += operation\n                break\n        else:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1653,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T, Q = stdin.split('\\n')\n    queries = []\n    for _ in range(Q):\n        a, b, c, d = map(int, input().split())\n        queries.append((a, b, c, d))\n\n    def can_transform(source: str, target: str) -> bool:\n        if len(source) != len(target):\n            return False\n        for s, t in zip(source, target):\n            if s == t:\n                continue\n            elif s == 'A' and t == 'B':\n                continue\n            elif s == 'B' and t == 'C':\n                continue\n            elif s == 'C' and t == 'A':\n                continue\n            else:\n                return False\n        return True\n\n    result = []\n    for a, b, c, d in queries:\n        source = S[a - 1:b]\n        target = T[c - 1:d]\n        if can_transform(source, target):\n            result.append('1')\n        else:\n            result.append('0')\n\n    return ''.join(result)\n"
    },
    {
        "number": 1654,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s = list(s)\n    t = list(t)\n    max_suitability = 0\n    max_suitability_string = \"\"\n\n    def swap(s, i, j):\n        s[i], s[j] = s[j], s[i]\n\n    def count_occurrences(s, t):\n        count = 0\n        for i in range(len(s) - len(t) + 1):\n            if s[i:i + len(t)] == t:\n                count += 1\n        return count\n\n    def find_max_suitability(s, t):\n        nonlocal max_suitability, max_suitability_string\n        for i in range(len(s)):\n            if s[i] == '?':\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    s[i] = c\n                    suitability = count_occurrences(s, t)\n                    if suitability > max_suitability:\n                        max_suitability = suitability\n                        max_suitability_string = ''.join(s)\n                    s[i] = '?'\n\n    find_max_suitability(s, t)\n    return max_suitability_string"
    },
    {
        "number": 1655,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, claws = stdin.split()\n    n = int(n)\n    claws = list(map(int, claws.split()))\n\n    alive = [True] * n\n\n    for i in range(n):\n        for j in range(i - claws[i], i):\n            if j >= 0:\n                alive[j] = False\n\n    return str(alive.count(True))\n"
    },
    {
        "number": 1656,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_wows(s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i:i+3] == \"vvv\":\n                count += 1\n                i += 3\n            else:\n                i += 1\n        return count\n\n    return str(count_wows(stdin))"
    },
    {
        "number": 1657,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    devices = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            a, b = map(int, line.split())\n            devices.append((a, b))\n\n    max_time = float('inf')\n    for i in range(n):\n        a, b = devices[i]\n        if b == 0:\n            return 0.0\n        max_time = min(max_time, b / a)\n\n    if max_time == float('inf'):\n        return -1.0\n    else:\n        return max_time"
    },
    {
        "number": 1658,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    d = list(map(int, stdin.split()[2:]))\n    \n    MOD = 10**9 + 7\n    \n    def count_nodes(node, depth):\n        if depth > x:\n            return 0\n        count = 1\n        for i in range(n):\n            count += count_nodes(node * n + i + 1, depth + d[i])\n        return count % MOD\n    \n    return str(count_nodes(1, 0))"
    },
    {
        "number": 1659,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    ice_cream_packs = x\n    distressed_kids = 0\n\n    for operation in stdin.split('\\n')[1:]:\n        if operation[0] == '+':\n            ice_cream_packs += int(operation[2:])\n        else:\n            if ice_cream_packs >= int(operation[2:]):\n                ice_cream_packs -= int(operation[2:])\n            else:\n                distressed_kids += 1\n\n    return f\"{ice_cream_packs} {distressed_kids}\""
    },
    {
        "number": 1660,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = []\n    for line in stdin.split('\\n')[1:]:\n        u, v, w = map(int, line.split())\n        edges.append((u, v, w))\n\n    def dfs(u: int, visited: set, path: list, max_path: list) -> None:\n        visited.add(u)\n        path.append(u)\n        for v, w in edges:\n            if v == u and v not in visited and w > path[-1]:\n                dfs(v, visited, path, max_path)\n        if len(path) > len(max_path):\n            max_path[:] = path\n\n    max_path = []\n    for i in range(1, n + 1):\n        dfs(i, set(), [], max_path)\n\n    return str(len(max_path) - 1)"
    },
    {
        "number": 1661,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    c = list(map(int, stdin.split()[2:2+n]))\n    a = list(map(int, stdin.split()[2+n:]))\n    \n    games_bought = 0\n    for i in range(n):\n        if a[0] >= c[i]:\n            a.pop(0)\n            games_bought += 1\n        else:\n            break\n            \n    return str(games_bought)"
    },
    {
        "number": 1662,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, cards = stdin.split('\\n')\n    m = int(m)\n    cards = list(map(int, cards.split()))\n\n    stairs = []\n    for i in range(1, m):\n        if cards[i] - cards[i - 1] == 1:\n            stairs.append(cards[i])\n\n    if len(stairs) == 0:\n        return \"0\\n\"\n\n    max_stairs = max(stairs)\n    result = [max_stairs]\n    for i in range(len(stairs) - 1, -1, -1):\n        if stairs[i] == max_stairs:\n            result.append(stairs[i - 1])\n            max_stairs = stairs[i - 1]\n\n    return str(len(result)) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 1663,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    total_sum = 0\n    for i in range(1, len(str(n))):\n        for j in range(len(str(n)) - i):\n            start = j\n            end = j + i\n            substring = str(n)[start:end]\n            if substring.isdigit():\n                new_n = int(str(n)[:start] + str(n)[end:])\n                total_sum += new_n\n    return str(total_sum % (10**9 + 7))"
    },
    {
        "number": 1664,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n\n    variables = {}\n    for line in lines:\n        if '=' in line:\n            lvalue, rvalue = line.split('=')\n            variables[lvalue] = rvalue\n        else:\n            lvalue, arg1, op, arg2 = line.split()\n            if op == '$':\n                variables[lvalue] = arg1 + arg2\n            elif op == '^':\n                variables[lvalue] = arg1 + arg2\n            elif op == '#':\n                variables[lvalue] = arg1 + arg2\n            elif op == '&':\n                variables[lvalue] = arg1 + arg2\n\n    result = []\n    for line in lines:\n        if '=' in line:\n            lvalue, rvalue = line.split('=')\n            if rvalue in variables:\n                result.append(lvalue + '=' + variables[rvalue])\n            else:\n                result.append(line)\n        else:\n            lvalue, arg1, op, arg2 = line.split()\n            if arg1 in variables:\n                arg1 = variables[arg1]\n            if arg2 in variables:\n                arg2 = variables[arg2]\n            if op == '$':\n                result.append(lvalue + '=' + arg1 + arg2)\n            elif op == '^':\n                result.append(lvalue + '=' + arg1 + arg2)\n            elif op == '#':\n                result.append(lvalue + '=' + arg1 + arg2)\n            elif op == '&':\n                result.append(lvalue + '=' + arg1 + arg2)\n\n    return str(len(result)) + '\\n' + '\\n'.join(result)"
    },
    {
        "number": 1665,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for line in stdin.split('\\n')[1:]:\n        u, v = map(int, line.split())\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    def dfs(node, parent, visited, labels):\n        visited.add(node)\n        for child in graph[node]:\n            if child != parent:\n                if child not in visited:\n                    labels = dfs(child, node, visited, labels)\n                else:\n                    labels.append(labels.pop())\n        return labels\n    \n    visited = set()\n    labels = dfs(0, -1, visited, list(range(n-1)))\n    return ' '.join(map(str, labels))"
    },
    {
        "number": 1666,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    n = 0\n    for c in range(a, x+1):\n        d = b + (c - a)\n        if d <= y:\n            n += 1\n    return str(n) + '\\n' + '\\n'.join(f'{c} {d}' for c in range(a, x+1) for d in range(b, y+1) if c + (d - b) <= x)"
    },
    {
        "number": 1667,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    distances = list(map(int, stdin.split()[1:]))\n    \n    # Calculate the number of locations\n    locations = 1\n    for i in range(1, n):\n        if distances[i] < distances[i-1]:\n            locations += 1\n    \n    # Calculate the minimum distance between locations\n    min_distance = max(distances)\n    for i in range(1, n):\n        if distances[i] < distances[i-1]:\n            min_distance = min(min_distance, distances[i] - distances[i-1])\n    \n    return str(min_distance)"
    },
    {
        "number": 1668,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_pin(pin: str) -> bool:\n        return len(pin) == 4 and pin.isdigit()\n\n    def is_unique(pins: List[str]) -> bool:\n        return len(set(pins)) == len(pins)\n\n    def change_pin(pin: str, index: int) -> str:\n        digits = list(pin)\n        digits[index - 1] = str((int(digits[index - 1]) + 1) % 10)\n        return ''.join(digits)\n\n    def find_min_changes(pins: List[str]) -> int:\n        min_changes = 0\n        for i in range(4):\n            new_pins = [change_pin(pin, i + 1) for pin in pins]\n            if is_unique(new_pins):\n                return min_changes + 1\n            min_changes += 1\n        return -1\n\n    def process_test_case(n: int, pins: List[str]) -> str:\n        if not all(is_valid_pin(pin) for pin in pins):\n            return \"Invalid input\"\n\n        min_changes = find_min_changes(pins)\n        if min_changes == -1:\n            return \"No solution\"\n\n        new_pins = [change_pin(pin, min_changes + 1) for pin in pins]\n        return f\"{min_changes}\\n{''.join(new_pins)}\\n\"\n\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    result = []\n\n    for i in range(1, t * 2, 2):\n        n = int(test_cases[i])\n        pins = test_cases[i + 1 : i + 1 + n]\n        result.append(process_test_case(n, pins))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1669,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, reserved_tokens, m = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    reserved_tokens = reserved_tokens.split()\n\n    # Parse input source code\n    source_lines = stdin.split('\\n', m)[m:]\n    tokens = []\n    for line in source_lines:\n        i = 0\n        while i < len(line):\n            if line[i] == '#':\n                break\n            if line[i].isdigit():\n                j = i + 1\n                while j < len(line) and line[j].isdigit():\n                    j += 1\n                tokens.append(line[i:j])\n                i = j\n            elif line[i].isalpha() or line[i] in ['_', '$']:\n                j = i + 1\n                while j < len(line) and (line[j].isalnum() or line[j] in ['_', '$']):\n                    j += 1\n                word = line[i:j]\n                if word not in reserved_tokens:\n                    tokens.append(word)\n                else:\n                    tokens.append(word)\n                i = j\n            else:\n                tokens.append(line[i])\n                i += 1\n\n    # Minify source code\n    minified_tokens = []\n    word_map = {}\n    for token in tokens:\n        if token in reserved_tokens:\n            minified_tokens.append(token)\n        elif token.isalpha():\n            if token not in word_map:\n                word_map[token] = chr(ord('a') + len(word_map))\n            minified_tokens.append(word_map[token])\n        else:\n            minified_tokens.append(token)\n\n    # Output minified source code\n    minified_source = ' '.join(minified_tokens)\n    return minified_source"
    },
    {
        "number": 1670,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    home_team, away_team = stdin.splitlines()[:2]\n    fouls = stdin.splitlines()[2:]\n\n    home_players = {}\n    away_players = {}\n\n    for foul in fouls:\n        minute, team, player_num, card_type = foul.split()\n        minute, player_num = int(minute), int(player_num)\n\n        if card_type == \"y\":\n            if team == \"h\":\n                if player_num not in home_players:\n                    home_players[player_num] = minute\n            else:\n                if player_num not in away_players:\n                    away_players[player_num] = minute\n        else:\n            if team == \"h\":\n                if player_num in home_players:\n                    home_players[player_num] = -1\n            else:\n                if player_num in away_players:\n                    away_players[player_num] = -1\n\n    result = []\n    for player_num, minute in home_players.items():\n        if minute != -1:\n            result.append(f\"{home_team} {player_num} {minute}\")\n    for player_num, minute in away_players.items():\n        if minute != -1:\n            result.append(f\"{away_team} {player_num} {minute}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1671,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    m = list(map(int, m.split()))\n\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(m[i] - m[j])\n            if diff < min_diff:\n                min_diff = diff\n\n    return str(min_diff)"
    },
    {
        "number": 1672,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    magnets = stdin.split('\\n')\n    groups = 1\n    for i in range(1, len(magnets)):\n        if magnets[i] == magnets[i-1]:\n            groups += 1\n    return str(groups)"
    },
    {
        "number": 1673,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def min_distance(i, j):\n        return min(abs(a[i] - a[j]), abs(a[i] - a[j] + k), abs(a[i] - a[j] - k))\n\n    def subsequence_beauty(subsequence):\n        return min(min_distance(i, j) for i in range(len(subsequence)) for j in range(i + 1, len(subsequence)))\n\n    total_beauty = 0\n    for i in range(n - k + 1):\n        subsequence = a[i:i + k]\n        total_beauty += subsequence_beauty(subsequence)\n\n    return str(total_beauty % 998244353)"
    },
    {
        "number": 1674,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    s = stdin.split()[2+n]\n    \n    dmg = 0\n    broken_buttons = set()\n    consecutive_presses = 0\n    \n    for i in range(n):\n        if s[i] not in broken_buttons:\n            dmg += a[i]\n            consecutive_presses += 1\n            if consecutive_presses == k:\n                broken_buttons.add(s[i])\n                consecutive_presses = 0\n        else:\n            consecutive_presses = 0\n            \n    return str(dmg)"
    },
    {
        "number": 1675,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    teams = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        teams.append((x, y))\n\n    result = []\n    for i in range(n):\n        home_games = 0\n        away_games = 0\n        for j in range(n):\n            if i == j:\n                continue\n            if teams[i][0] == teams[j][0] or teams[i][1] == teams[j][1]:\n                away_games += 1\n            else:\n                home_games += 1\n        result.append((home_games, away_games))\n\n    return '\\n'.join([f'{home} {away}' for home, away in result])"
    },
    {
        "number": 1676,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split()[0:2])\n    queries = []\n    for line in stdin.split('\\n')[1:]:\n        t, d = map(int, line.split())\n        queries.append((t, d))\n\n    queries.sort(key=lambda x: x[0])\n    server_free = True\n    queue = []\n    result = []\n\n    for query in queries:\n        t, d = query\n        if server_free:\n            server_free = False\n            result.append(t + d)\n        elif len(queue) < b:\n            queue.append(query)\n        else:\n            result.append(-1)\n\n        if not server_free:\n            if queue:\n                server_free = True\n                next_query = queue.pop(0)\n                result.append(next_query[0] + next_query[1])\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1677,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n    max_length = 0\n    for i in range(n):\n        current_length = 1\n        for j in range(i+1, n):\n            if b[j] - b[j-1] == b[j-1] - b[j-2]:\n                current_length += 1\n            else:\n                break\n        max_length = max(max_length, current_length)\n    return str(max_length)"
    },
    {
        "number": 1678,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] < t:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1679,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    decoded_number = 0\n    current_digit = 0\n    for char in s:\n        if char == '1':\n            current_digit += 1\n        else:\n            decoded_number = decoded_number * 10 + current_digit\n            current_digit = 0\n    decoded_number = decoded_number * 10 + current_digit\n    return str(decoded_number)"
    },
    {
        "number": 1680,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    sequence = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x = sequence[i]\n            y = sequence[j]\n            diff_bits = 0\n            for bit in range(32):\n                if ((x >> bit) & 1) != ((y >> bit) & 1):\n                    diff_bits += 1\n            if diff_bits == k:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1681,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = stdin.split()\n    n = len(colors)\n    m = len(set(colors))\n    max_area = -1\n\n    for i in range(1, m + 1):\n        for combo in itertools.combinations(colors, i):\n            area = sum([colors.count(color) for color in combo])\n            if area > max_area:\n                max_area = area\n\n    return str(max_area)"
    },
    {
        "number": 1682,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2*n+2]))\n    b = list(map(int, stdin.split()[2*n+2:]))\n    \n    min_price = min(b)\n    max_price = max(b)\n    \n    if k == 0:\n        return str(max_price * n)\n    \n    if k >= n:\n        return str(sum(a))\n    \n    min_price_to_buy_now = min(a[:k])\n    max_price_to_buy_later = max(a[k:])\n    \n    return str(min_price_to_buy_now * k + max_price_to_buy_later * (n - k))"
    },
    {
        "number": 1683,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def f(x, y):\n        p = len(str(x))\n        q = len(str(y))\n        if p >= q:\n            return int(str(x)[:q] + str(y) + str(x)[q:])\n        else:\n            return int(str(y)[:p] + str(x) + str(y)[p:])\n\n    total = 0\n    for i in range(n):\n        for j in range(n):\n            total += f(a[i], a[j])\n\n    return str(total % 998244353)"
    },
    {
        "number": 1684,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    segments = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2:])\n        segments.append((a, b))\n\n    def is_rotationally_symmetrical(segments: list) -> bool:\n        for i in range(1, n):\n            if not any(is_segment_rotated(segment, i) for segment in segments):\n                return False\n        return True\n\n    def is_segment_rotated(segment: tuple, k: int) -> bool:\n        a, b = segment\n        return (a - k) % n == b or (b - k) % n == a\n\n    if is_rotationally_symmetrical(segments):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1685,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    queries = []\n    for _ in range(q):\n        u, s = stdin.split()\n        queries.append((int(u), s))\n\n    def traverse(u: int, s: str) -> int:\n        if not s:\n            return u\n        direction = s[0]\n        if direction == 'U':\n            return traverse(u // 2, s[1:])\n        elif direction == 'L':\n            return traverse(2 * u, s[1:])\n        else:\n            return traverse(2 * u + 1, s[1:])\n\n    return '\\n'.join(str(traverse(u, s)) for u, s in queries)"
    },
    {
        "number": 1686,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    ip_addresses = stdin.split()[2:]\n\n    def is_valid_ip_address(ip_address: str) -> bool:\n        parts = ip_address.split('.')\n        if len(parts) != 4:\n            return False\n        for part in parts:\n            if len(part) > 3 or not part.isdigit():\n                return False\n            if int(part) > 255:\n                return False\n        return True\n\n    def count_ones(mask: str) -> int:\n        return sum(1 for bit in mask if bit == '1')\n\n    def get_network_address(ip_address: str, subnet_mask: str) -> str:\n        ip_address_parts = ip_address.split('.')\n        subnet_mask_parts = subnet_mask.split('.')\n        network_address_parts = []\n        for i in range(4):\n            network_address_parts.append(str(int(ip_address_parts[i]) & int(subnet_mask_parts[i])))\n        return '.'.join(network_address_parts)\n\n    def find_subnet_mask(ip_addresses: List[str], k: int) -> str:\n        max_ones_count = 0\n        result_subnet_mask = ''\n        for i in range(256):\n            subnet_mask = f'{i}.255.255.255'\n            network_addresses = set()\n            for ip_address in ip_addresses:\n                network_address = get_network_address(ip_address, subnet_mask)\n                network_addresses.add(network_address)\n            if len(network_addresses) == k:\n                ones_count = count_ones(subnet_mask)\n                if ones_count > max_ones_count:\n                    max_ones_count = ones_count\n                    result_subnet_mask = subnet_mask\n        return result_subnet_mask\n\n    valid_ip_addresses = [ip_address for ip_address in ip_addresses if is_valid_ip_address(ip_address)]\n    if len(valid_ip_addresses) != n:\n        return '-1'\n\n    subnet_mask = find_subnet_mask(valid_ip_addresses, k)\n    if subnet_mask == '':\n        return '-1'\n    else:\n        return subnet_mask"
    },
    {
        "number": 1687,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    lcm_result = array[0]\n    for i in range(1, n):\n        lcm_result = lcm(lcm_result, array[i])\n\n    if lcm_result == 1:\n        return \"-1\"\n    else:\n        return str(lcm_result)"
    },
    {
        "number": 1688,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    coolnesses = list(map(int, stdin.split()[1:]))\n    results = []\n\n    for i in range(n):\n        current_coolness = coolnesses[i]\n        max_coolness = current_coolness\n        count = 1\n\n        while True:\n            current_coolness = coolnesses[(i + count) % n]\n            max_coolness = max(max_coolness, current_coolness)\n            count += 1\n\n            if current_coolness < max_coolness / 2:\n                break\n\n        results.append(count)\n\n    return \" \".join(map(str, results))"
    },
    {
        "number": 1689,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bus_config = stdin.split('\\n')[1:]\n\n    for i in range(n):\n        row = bus_config[i]\n        for j in range(4):\n            if row[j] == 'O' and row[j+1] == 'O':\n                if j == 0:\n                    if bus_config[i][j+2] == '|' and bus_config[i][j+3] == 'O':\n                        bus_config[i] = bus_config[i][:j+1] + '+' + bus_config[i][j+2:]\n                        bus_config[i+1] = bus_config[i+1][:j+1] + '+' + bus_config[i+1][j+2:]\n                        return \"YES\\n\" + \"\\n\".join(bus_config)\n                elif j == 2:\n                    if bus_config[i][j-2] == '|' and bus_config[i][j-1] == 'O':\n                        bus_config[i] = bus_config[i][:j] + '+' + bus_config[i][j+1:]\n                        bus_config[i+1] = bus_config[i+1][:j] + '+' + bus_config[i+1][j+1:]\n                        return \"YES\\n\" + \"\\n\".join(bus_config)\n                else:\n                    return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 1690,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    x = [0] * n\n    max_chocolates = 0\n\n    for i in range(n):\n        for j in range(i):\n            if x[j] >= x[i]:\n                x[i] = 0\n                break\n        else:\n            x[i] = a[i]\n\n        max_chocolates += x[i]\n\n    return str(max_chocolates)"
    },
    {
        "number": 1691,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sections = [1] * n\n    \n    for i in range(n):\n        x = (i + 1) % n\n        y = (x + k - 1) % n\n        sections[x] += sections[y]\n        sections[y] += sections[x]\n    \n    return \" \".join(map(str, sections))"
    },
    {
        "number": 1692,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = int(stdin[i:j])\n            if substring % 4 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1693,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    m = list(map(int, stdin.readline().strip().split()))\n\n    floors = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if m[j] < m[i]:\n                floors[i] = max(floors[i], floors[j] + 1)\n        for k in range(i + 1, n):\n            if m[k] < m[i]:\n                floors[i] = max(floors[i], floors[k] - 1)\n\n    return \" \".join(map(str, floors))"
    },
    {
        "number": 1694,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, f = map(int, stdin.split()[:4])\n    steps = []\n    for _ in range(m):\n        t, l, r = map(int, stdin.split()[4:])\n        steps.append((t, l, r))\n\n    def find_path(s, f, steps):\n        path = [\"X\"] * m\n        for i, (t, l, r) in enumerate(steps):\n            if s in range(l, r + 1):\n                if s == l:\n                    path[i] = \"R\"\n                elif s == r:\n                    path[i] = \"L\"\n                else:\n                    path[i] = \"X\"\n                s = l if s == r else r\n            if s == f:\n                return path\n        return None\n\n    path = find_path(s, f, steps)\n    if path is None:\n        return \"IMPOSSIBLE\"\n    return \"\".join(path)"
    },
    {
        "number": 1695,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    students = stdin.split()[2:-m]\n    correct_answers = list(map(int, stdin.split()[-m:]))\n\n    max_score = 0\n    for i in range(1, 2**m):\n        binary_str = format(i, f'0{m}b')\n        score = 0\n        for j in range(m):\n            if binary_str[j] == '1':\n                score += correct_answers[j]\n        max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 1696,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    centers = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:k+1]]\n    max_x, max_y = max(centers, key=lambda x: x[0])\n    min_x, min_y = min(centers, key=lambda x: x[0]), min(centers, key=lambda x: x[1])\n    return str(max(max_x - min_x, max_y - min_y))"
    },
    {
        "number": 1697,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def dfs(x: int, y: int, color: str, visited: set) -> bool:\n        if (x, y) in visited:\n            return False\n        visited.add((x, y))\n        if board[x][y] != color:\n            return False\n        if x == 0 and y == 0:\n            return True\n        if x > 0 and board[x - 1][y] == color and dfs(x - 1, y, color, visited):\n            return True\n        if x < n - 1 and board[x + 1][y] == color and dfs(x + 1, y, color, visited):\n            return True\n        if y > 0 and board[x][y - 1] == color and dfs(x, y - 1, color, visited):\n            return True\n        if y < m - 1 and board[x][y + 1] == color and dfs(x, y + 1, color, visited):\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, board[i][j], set()):\n                return \"Yes\"\n    return \"No\""
    },
    {
        "number": 1698,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    floors = list(map(int, stdin.split()[2:]))\n\n    # Initialize the elevator on the first floor\n    elevator_floor = 1\n    time = 0\n\n    # Sort the floors in ascending order\n    floors.sort()\n\n    # Iterate through the floors and move the elevator\n    for i in range(len(floors)):\n        # Move the elevator to the current floor\n        time += abs(elevator_floor - floors[i])\n        elevator_floor = floors[i]\n\n        # Move the elevator to the next floor\n        if i < len(floors) - 1:\n            time += abs(elevator_floor - floors[i+1])\n            elevator_floor = floors[i+1]\n\n    # Move the elevator back to the first floor\n    time += abs(elevator_floor - 1)\n\n    return str(time)"
    },
    {
        "number": 1699,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(i * m + j + 1)\n        table.append(row)\n    return '\\n'.join([' '.join(map(str, row)) for row in table])"
    },
    {
        "number": 1700,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    red_brackets = \"\"\n    blue_brackets = \"\"\n    red_depth = 0\n    blue_depth = 0\n\n    for char in s:\n        if char == \"(\":\n            red_brackets += char\n            red_depth += 1\n        else:\n            blue_brackets += char\n            blue_depth += 1\n\n        if red_depth > blue_depth:\n            blue_depth = red_depth\n            blue_brackets += char\n        else:\n            red_depth = blue_depth\n            red_brackets += char\n\n    return red_brackets + blue_brackets"
    },
    {
        "number": 1701,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    servers = {}\n    for i in range(n):\n        name, ip = stdin.split()[2*i:2*(i+1)]\n        servers[ip] = name\n\n    commands = []\n    for i in range(m):\n        command, ip = stdin.split()[2*n+2*i:2*n+2*(i+1)]\n        commands.append(f\"{command} {ip}; # {servers[ip]}\")\n\n    return \"\\n\".join(commands)"
    },
    {
        "number": 1702,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    participants = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    def get_max_point_value(solvers_fraction: float) -> int:\n        if solvers_fraction <= 0.5:\n            return 500\n        elif solvers_fraction <= 0.25:\n            return 1000\n        elif solvers_fraction <= 0.125:\n            return 1500\n        elif solvers_fraction <= 0.0625:\n            return 2000\n        else:\n            return 3000\n\n    def get_solvers_fraction(participant_solved_problems: int) -> float:\n        return participant_solved_problems / n\n\n    def get_score(participant_solved_problems: int, participant_submission_time: int) -> int:\n        solvers_fraction = get_solvers_fraction(participant_solved_problems)\n        max_point_value = get_max_point_value(solvers_fraction)\n        return max_point_value - participant_submission_time * max_point_value / 250\n\n    vasya_score = sum(get_score(participant[0], participant[1]) for participant in participants)\n    petya_score = sum(get_score(participant[0], participant[2]) for participant in participants)\n\n    if vasya_score > petya_score:\n        return str(int(vasya_score - petya_score))\n    else:\n        return \"-1\""
    },
    {
        "number": 1703,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bracket_sequences = stdin.split('\\n')[1:]\n\n    def is_regular(bracket_sequence: str) -> bool:\n        stack = []\n        for char in bracket_sequence:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def concatenate_sequences(s1: str, s2: str) -> str:\n        return s1 + s2\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and is_regular(concatenate_sequences(bracket_sequences[i], bracket_sequences[j])):\n                count += 1\n            if i == j and is_regular(concatenate_sequences(bracket_sequences[i], bracket_sequences[j])):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1704,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [bin(i)[2:].zfill(7) for i in range(10)]\n    max_number = -1\n    \n    for i in range(10**n):\n        current_number = 0\n        current_sticks = 0\n        for j in range(n):\n            current_digit = i // (10**(n-j-1)) % 10\n            current_number += current_digit * (10**j)\n            for l in range(7):\n                if digits[current_digit][l] == '1':\n                    current_sticks += 1\n                    if current_sticks > k:\n                        break\n            if current_sticks > k:\n                break\n        if current_sticks == k:\n            max_number = max(max_number, current_number)\n    \n    return str(max_number)"
    },
    {
        "number": 1705,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    doors = list(map(int, stdin.readline().strip().split()))\n\n    left_exit = [0] * n\n    right_exit = [0] * n\n\n    for i, door in enumerate(doors):\n        if door == 0:\n            left_exit[i] = 1\n        else:\n            right_exit[i] = 1\n\n    for i in range(n):\n        if left_exit[i] == 1 and right_exit[i] == 1:\n            return str(i + 1)\n\n    return \"Impossible\"\n"
    },
    {
        "number": 1706,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    operations = []\n    k = 0\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def append_substring(s: str, i: int, reverse: bool) -> str:\n        if reverse:\n            return s + s[i::-1]\n        else:\n            return s + s[:i:-1]\n\n    while not is_palindrome(s):\n        if k >= 30:\n            break\n        for i in range(2, n - 1):\n            if not is_palindrome(append_substring(s, i, True)):\n                s = append_substring(s, i, True)\n                operations.append(f\"L {i}\")\n                k += 1\n                break\n        for i in range(2, n - 1):\n            if not is_palindrome(append_substring(s, i, False)):\n                s = append_substring(s, i, False)\n                operations.append(f\"R {i}\")\n                k += 1\n                break\n\n    return f\"{k}\\n{''.join(operations)}\""
    },
    {
        "number": 1707,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    choices = list(map(int, stdin.split()[1:]))\n    pairs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x = choices[i]\n            y = choices[j]\n            if abs(x) == abs(y) or abs(x - y) == abs(x + y):\n                pairs += 1\n\n    return str(pairs)"
    },
    {
        "number": 1708,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    c = list(map(int, stdin.split()[2+n:2+2*n]))\n    remain = a.copy()\n    total_cost = []\n\n    for j in range(m):\n        t, d = map(int, stdin.split()[2+2*n+j].split())\n        if remain[t-1] >= d:\n            remain[t-1] -= d\n            total_cost.append(d * c[t-1])\n        else:\n            total_cost.append(0)\n\n    return \"\\n\".join(map(str, total_cost))\n"
    },
    {
        "number": 1709,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    colors = list(map(int, stdin.readline().split()))\n    paint_costs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def dfs(start: int, color: int) -> int:\n        if colors[start] != 0:\n            return 0\n        colors[start] = color\n        total_cost = paint_costs[start][color]\n        for i in range(start + 1, n):\n            if colors[i] == 0:\n                total_cost += dfs(i, color)\n        colors[start] = 0\n        return total_cost\n\n    min_cost = float('inf')\n    for color in range(1, m + 1):\n        colors_copy = colors.copy()\n        total_cost = dfs(0, color)\n        if total_cost != 0:\n            groups = 1\n            for i in range(1, n):\n                if colors_copy[i] != colors_copy[i - 1]:\n                    groups += 1\n            if groups == k:\n                min_cost = min(min_cost, total_cost)\n\n    return str(min_cost) if min_cost != float('inf') else \" -1\""
    },
    {
        "number": 1710,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    array = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray = array[i:j]\n            p = 1\n            s = 0\n\n            for num in subarray:\n                p *= num\n                s += num\n\n            if p / s == k:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1711,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, m):\n        for j in range(i + 1, m + 1):\n            for k in range(1, n - 1):\n                for l in range(k + 1, n):\n                    for m in range(l + 1, n + 1):\n                        if i == j or k == l or k == m or l == m:\n                            continue\n                        a = [i] * k + [j] * (l - k) + [i] * (n - l)\n                        if a[k:l] == a[l:]:\n                            count += 1\n    return str(count % 998244353)"
    },
    {
        "number": 1712,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[:3])\n    monsters = list(map(int, stdin.split()[3:]))\n    result = []\n\n    for i in range(n):\n        if monsters[i] % max(x, y) == 0:\n            result.append(\"Both\")\n        elif monsters[i] % x == 0:\n            result.append(\"Vanya\")\n        else:\n            result.append(\"Vova\")\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 1713,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, shuffling_operations = map(int, stdin.split())\n    p = list(map(int, input().split()))\n\n    if s == t:\n        return \"0\"\n\n    for i in range(n):\n        if p[i] == s:\n            s = i + 1\n\n    if s == t:\n        return \"1\"\n\n    for i in range(n):\n        if p[i] == t:\n            t = i + 1\n\n    if s == t:\n        return \"2\"\n\n    return \"-1\"\n"
    },
    {
        "number": 1714,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [1] * (2 * n)\n    for i in range(1, 2 * n):\n        a[i] = a[i - 1] + 1\n    for i in range(2 * n):\n        if i % 2 == 0:\n            a[i] = a[i] + k\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1715,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, Q = map(int, stdin.split()[:3])\n    shrines = list(map(int, stdin.split()[3:3+A]))\n    temples = list(map(int, stdin.split()[3+A:3+A+B]))\n    starting_points = list(map(int, stdin.split()[3+A+B:]))\n\n    def min_distance(starting_point: int, shrines: list, temples: list) -> int:\n        shrines.sort()\n        temples.sort()\n        min_dist = float('inf')\n        for shrine in shrines:\n            for temple in temples:\n                if shrine < temple:\n                    dist = abs(starting_point - shrine) + abs(temple - shrine)\n                    min_dist = min(min_dist, dist)\n        return min_dist\n\n    results = []\n    for starting_point in starting_points:\n        results.append(min_distance(starting_point, shrines, temples))\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 1716,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M, Q = map(int, lines[0].split())\n    trains = [tuple(map(int, lines[i].split())) for i in range(1, M+1)]\n    queries = [tuple(map(int, lines[i].split())) for i in range(M+1, M+1+Q)]\n\n    def count_trains(p, q):\n        count = 0\n        for L, R in trains:\n            if p <= L and R <= q:\n                count += 1\n        return count\n\n    result = [count_trains(p, q) for p, q in queries]\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1717,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    x = N + 1\n    while True:\n        found = True\n        for y in range(2, N + 1):\n            if x % y != 1:\n                found = False\n                break\n        if found:\n            return str(x)\n        x += 1"
    },
    {
        "number": 1718,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    min_value = min(A)\n    max_value = max(A)\n\n    if min_value == max_value:\n        return \"0\"\n\n    if K == 2:\n        return str(max_value - min_value)\n\n    if K == N:\n        return \"1\"\n\n    if K == 1:\n        return str(N - 1)\n\n    if K == 3:\n        return str(max_value - min_value)\n\n    if K == 4:\n        return str(max_value - min_value)\n\n    if K % 2 == 0:\n        return str(max_value - min_value)\n\n    if K % 2 == 1:\n        return str(max_value - min_value - 1)"
    },
    {
        "number": 1719,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(N):\n        for j in range(4):\n            if i == 0 or j != 0:\n                dp[i + 1] += dp[i]\n            if i >= 1 and j == 0:\n                dp[i + 1] -= 1\n        dp[i + 1] %= MOD\n    return str(dp[N])"
    },
    {
        "number": 1720,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    room = [list(line.strip()) for line in stdin.split('\\n')[1:-1]]\n    x_1, y_1, x_2, y_2 = map(int, stdin.split('\\n')[-1].split())\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and room[x][y] == '.'\n\n    def bfs(x_start, y_start, x_end, y_end):\n        queue = [(x_start, y_start, 0)]\n        visited = set()\n        while queue:\n            x, y, time = queue.pop(0)\n            if (x, y) == (x_end, y_end):\n                return time\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny):\n                        queue.append((nx, ny, time + 1))\n        return -1\n\n    return str(bfs(x_1 - 1, y_1 - 1, x_2 - 1, y_2 - 1))"
    },
    {
        "number": 1721,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    swaps = 0\n\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            swaps += 1\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\n\n    return swaps\n"
    },
    {
        "number": 1722,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = stdin.split('\\n')[1:]\n    students.sort()\n\n    def count_chatty_pairs(students):\n        chatty_pairs = 0\n        for i in range(len(students)):\n            for j in range(i + 1, len(students)):\n                if students[i][0] == students[j][0]:\n                    chatty_pairs += 1\n        return chatty_pairs\n\n    min_chatty_pairs = float('inf')\n    for i in range(2 ** n):\n        classroom1 = []\n        classroom2 = []\n        for j in range(n):\n            if (i >> j) & 1:\n                classroom1.append(students[j])\n            else:\n                classroom2.append(students[j])\n        chatty_pairs = count_chatty_pairs(classroom1) + count_chatty_pairs(classroom2)\n        min_chatty_pairs = min(min_chatty_pairs, chatty_pairs)\n\n    return str(min_chatty_pairs)"
    },
    {
        "number": 1723,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"-1\\n1 2\\n\"\n    elif n == 8:\n        return \"1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n4 7\\n4 8\\n1 2\\n1 3\\n2 4\\n2 5\\n2 6\\n3 7\\n6 8\\n\"\n    else:\n        return \"-1\\n-1\\n\""
    },
    {
        "number": 1724,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m, 2)\n\n    def f(x: int) -> int:\n        result = 0\n        for i in range(n):\n            result += a[i] * (x >> i & 1)\n        return result\n\n    max_f = 0\n    for x in range(m + 1):\n        max_f = max(max_f, f(x))\n\n    return str(max_f)"
    },
    {
        "number": 1725,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n\n    min_value = min(min(row) for row in matrix)\n    max_value = max(max(row) for row in matrix)\n\n    if d > max_value - min_value:\n        return \"-1\"\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            moves += abs(matrix[i][j] - min_value)\n\n    return str(moves)\n"
    },
    {
        "number": 1726,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    total_time = sum(a) + t\n    if total_time <= n * 86400:\n        return str(total_time // 86400 + 1)\n    else:\n        return str(n)"
    },
    {
        "number": 1727,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    trees = []\n    for _ in range(n):\n        x, h = map(int, stdin.readline().strip().split())\n        trees.append((x, h))\n\n    trees.sort(key=lambda x: x[0])\n    cut_trees = 0\n    current_height = 0\n\n    for tree in trees:\n        x, h = tree\n        if x > current_height:\n            cut_trees += 1\n            current_height = x + h\n\n    return str(cut_trees)"
    },
    {
        "number": 1728,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = list(map(int, stdin.readline().strip().split()))\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(node: int, parent: int, color: int) -> int:\n        nonlocal steps\n        if color != colors[node]:\n            steps += 1\n            colors[node] = color\n        for child in range(1, n + 1):\n            if child != parent and edges[child - 1] == node:\n                dfs(child, node, color)\n\n    steps = 0\n    dfs(1, -1, colors[1])\n    return str(steps)"
    },
    {
        "number": 1729,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    sequence = stdin.split()[2]\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    def interpret(s: str) -> str:\n        cp = 0\n        dp = 1\n        result = []\n        while cp < len(s):\n            if s[cp] == '<':\n                dp = -1\n                s = s[:cp] + s[cp+1:]\n            elif s[cp] == '>':\n                dp = 1\n                s = s[:cp] + s[cp+1:]\n            else:\n                digit = int(s[cp])\n                result.append(digit)\n                s = s[:cp] + str(digit-1) + s[cp+1:]\n                cp += dp\n            cp += dp\n        return result\n\n    def count_digits(s: str) -> List[int]:\n        result = [0] * 10\n        for digit in interpret(s):\n            result[digit] += 1\n        return result\n\n    answers = []\n    for query in queries:\n        l, r = query\n        answers.append(' '.join(map(str, count_digits(sequence[l-1:r]))))\n\n    return '\\n'.join(answers)"
    },
    {
        "number": 1730,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[-2:])\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                cycle = dfs(neighbor, visited, path)\n                if cycle:\n                    return cycle\n            elif neighbor in path:\n                cycle = path[path.index(neighbor):]\n                cycle.append(node)\n                return cycle\n        path.pop()\n        visited.remove(node)\n        return False\n    \n    for i in range(1, n+1):\n        cycle = dfs(i, set(), [])\n        if cycle and len(cycle) >= k+1:\n            return str(len(cycle)) + \"\\n\" + \" \".join(map(str, cycle))\n    return \"No cycle found\" "
    },
    {
        "number": 1731,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(1, m + 1):\n                for l in range(k, m + 1):\n                    if i <= j and k <= l:\n                        count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1732,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards_lengths, cards_costs = stdin.split('\\n')\n    n = int(n)\n    cards_lengths = list(map(int, cards_lengths.split()))\n    cards_costs = list(map(int, cards_costs.split()))\n\n    if n == 0:\n        return \"-1\"\n\n    cards_lengths.sort(reverse=True)\n    cards_costs.sort(reverse=True)\n\n    total_cost = 0\n    for i in range(n):\n        total_cost += cards_costs[i]\n        if total_cost > 1000000:\n            return \"-1\"\n\n    return str(total_cost)\n\n\ndef"
    },
    {
        "number": 1733,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, roads = stdin.split(\"\\n\")\n    n = int(n)\n    x = int(x)\n    y = int(y)\n    roads = [tuple(map(int, road.split())) for road in roads.split(\"\\n\")]\n\n    def dfs(start: int, visited: set) -> set:\n        visited.add(start)\n        for a, b in roads:\n            if a == start and b not in visited:\n                dfs(b, visited)\n        return visited\n\n    visited_from_x = dfs(x, set())\n    visited_from_y = dfs(y, set())\n\n    count = 0\n    for a, b in roads:\n        if a != x and a != y and b != x and b != y:\n            if a in visited_from_x and b in visited_from_y:\n                count += 1\n            if a in visited_from_y and b in visited_from_x:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1734,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    phone_numbers = stdin.split('\\n')[1:]\n\n    result = []\n\n    for number in phone_numbers:\n        shortest_sequence = \"\"\n        for i in range(1, 10):\n            sequence = str(i)\n            for j in range(1, 10):\n                if number.find(sequence + str(j)) != -1:\n                    shortest_sequence = sequence + str(j)\n                    break\n            if shortest_sequence:\n                break\n        result.append(shortest_sequence)\n\n    return \"\\n\".join(result)\n\n\ninput_data = \"\"\"3\n123456789\n100000000\n100123456\"\"\"\noutput = solution(input_data)\nprint(output)\n\ninput_data = \"\"\"4\n123456789\n193456789\n134567819\n934567891\"\"\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 1735,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    player = 1\n    while True:\n        if len(s) == 0:\n            return \"Yes\" if player == 2 else \"No\"\n        i = 0\n        while i < len(s) - 1:\n            if s[i] == s[i+1]:\n                s.pop(i)\n                s.pop(i)\n                break\n            i += 1\n        else:\n            return \"Yes\" if player == 1 else \"No\"\n        player = 2 if player == 1 else 1"
    },
    {
        "number": 1736,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    books = list(map(int, stdin.split()[2:]))\n    max_books = 0\n    current_time = 0\n    current_book = 0\n\n    while current_book < n and current_time + books[current_book] <= t:\n        current_time += books[current_book]\n        current_book += 1\n        max_books += 1\n\n    return str(max_books)"
    },
    {
        "number": 1737,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_project_description(line: str) -> Tuple[str, int]:\n        name, version = line.split()\n        return name, int(version)\n\n    def read_dependencies(n: int, lines: List[str]) -> List[Tuple[str, int]]:\n        dependencies = []\n        for i in range(n):\n            name, version = read_project_description(lines[i])\n            dependencies.append((name, version))\n        return dependencies\n\n    def find_actual_version(name: str, versions: List[Tuple[str, int]]) -> Tuple[str, int]:\n        actual_version = max(versions, key=lambda x: x[1])\n        return actual_version[0], actual_version[1]\n\n    def find_dependencies(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies = []\n        for dep in projects:\n            if dep[0] == project[0]:\n                continue\n            if dep[1] == project[1]:\n                dependencies.append(dep)\n        return dependencies\n\n    def resolve_collisions(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> Tuple[str, int]:\n        actual_version = find_actual_version(project[0], projects)\n        return actual_version[0], actual_version[1]\n\n    def find_minimal_set(projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        minimal_set = []\n        for project in projects:\n            if project[0] == \"a\" and project[1] == 3:\n                minimal_set.append(project)\n            else:\n                continue\n\n            dependencies = find_dependencies(project, projects)\n            while dependencies:\n                new_dependencies = []\n                for dep in dependencies:\n                    if dep[0] not in [p[0] for p in minimal_set]:\n                        minimal_set.append(dep)\n                    new_dependencies.extend(find_dependencies(dep, projects))\n                dependencies = new_dependencies\n\n        return minimal_set\n\n    def main():\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        projects = []\n        for i in range(1, n + 1):\n            name, version = read_project_description(lines[i])\n            projects.append((name, version))\n\n        for i in range(n + 1, len(lines)):\n            if not lines[i]:\n                break\n            name, version = read_project_description(lines[i])\n            projects.append((name, version))\n\n        minimal_set = find_minimal_set(projects)\n        minimal_set.sort()\n        for project in minimal_set:\n            print(project[0], project[1])\n\n    main()"
    },
    {
        "number": 1738,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    compressed_version = \"\"\n    while s:\n        count = 1\n        while len(s) > 1 and s[0] == s[1]:\n            count += 1\n            s = s[1:]\n        compressed_version += str(count) + s[0]\n        s = s[1:]\n    return compressed_version\n\ndef"
    },
    {
        "number": 1739,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    s = 1\n    t = 0\n    for i in range(n):\n        s += x ** a[i]\n        t += a[i]\n    gcd = math.gcd(s, t)\n    return str(gcd % 1000000007)"
    },
    {
        "number": 1740,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    kittens = [i for i in range(1, n+1)]\n    for line in stdin.splitlines()[1:]:\n        x, y = map(int, line.split())\n        kittens[x-1] = kittens[y-1]\n    return \" \".join(map(str, kittens))"
    },
    {
        "number": 1741,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    animals = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        animals.append((x, y))\n\n    # Find the center of the reserve\n    x_center = sum(x for x, y in animals) / n\n    y_center = sum(y for x, y in animals) / n\n\n    # Find the radius of the reserve\n    radius = 0\n    for x, y in animals:\n        radius = max(radius, ((x - x_center) ** 2 + (y - y_center) ** 2) ** 0.5)\n\n    # Check if the reserve intersects the river\n    intersects_river = False\n    for x, y in animals:\n        if y == 0:\n            intersects_river = True\n            break\n\n    # Check if the reserve is possible\n    if intersects_river:\n        return \"-1\"\n    else:\n        return str(radius)"
    },
    {
        "number": 1742,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n    changes = []\n    for i in range(m):\n        u, v = map(int, stdin.split()[2+m+i].split())\n        changes.append((u, v))\n\n    max_moves = 0\n    for i in range(n-1, 0, -1):\n        if p[i] == n:\n            max_moves += 1\n            for u, v in changes:\n                if u == p[i-1] and v == p[i]:\n                    max_moves += 1\n                    p[i-1], p[i] = p[i], p[i-1]\n                    break\n    return str(max_moves)"
    },
    {
        "number": 1743,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n    c = list(map(int, c.split()))\n\n    def get_joy(i: int) -> int:\n        if i == 0 or i == n - 1:\n            return a[i]\n        return max(a[i], b[i], c[i])\n\n    def get_total_joy(feed_order: list) -> int:\n        total_joy = 0\n        for i in range(n):\n            total_joy += get_joy(feed_order[i])\n        return total_joy\n\n    max_total_joy = 0\n    for perm in permutations(range(n)):\n        total_joy = get_total_joy(perm)\n        max_total_joy = max(max_total_joy, total_joy)\n\n    return str(max_total_joy)"
    },
    {
        "number": 1744,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    times = list(map(int, stdin.split()[2:]))\n    result = []\n\n    for i in range(n):\n        count = 0\n        for j in range(i):\n            if times[j] > M - sum(times[i+1:]) - count:\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))\n\ninput_data = \"7 15\\n1 2 3 4 5 6 7\"\nprint(solution(input_data))\n\ninput_data = \"5 100\\n80 40 40 40 60\"\nprint(solution(input_data)) "
    },
    {
        "number": 1745,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_pipe(pipe: List[Tuple[int, int]]) -> bool:\n        def is_turn(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool:\n            return (p1[0] - p2[0]) * (p1[1] - p2[1]) != (p1[0] - p3[0]) * (p1[1] - p3[1])\n\n        def is_border_square(x: int, y: int) -> bool:\n            return x == 0 or x == n - 1 or y == 0 or y == m - 1\n\n        def is_side_adjacent(p1: Tuple[int, int], p2: Tuple[int, int]) -> bool:\n            return abs(p1[0] - p2[0]) == 1 or abs(p1[1] - p2[1]) == 1\n\n        if len(pipe) < 2:\n            return False\n\n        for i in range(len(pipe) - 1):\n            if not is_turn(pipe[i], pipe[i + 1], (pipe[i][0] + (pipe[i + 1][0] - pipe[i][0]) // 2, pipe[i][1] + (pipe[i + 1][1] - pipe[i][1]) // 2)):\n                return False\n\n        for x, y in pipe:\n            if not (0 <= x < n and 0 <= y < m):\n                return False\n\n        if not is_border_square(pipe[0][0], pipe[0][1]) or not is_border_square(pipe[-1][0], pipe[-1][1]):\n            return False\n\n        for i in range(len(pipe) - 1):\n            if not is_side_adjacent(pipe[i], pipe[i + 1]):\n                return False\n\n        for x, y in pipe:\n            if grid[x][y] == '#':\n                return False\n\n        return True\n\n    def count_distinct_pipes(grid: List[List[str]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        count = 0\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '.':\n                    for k in range(j, m):\n                        if grid[i][k] == '.':\n                            for l in range(i, n):\n                                if grid[l][k] == '.':\n                                    pipe = [(i, j), (i, k), (l, k)]\n                                    if is_valid_pipe(pipe):\n                                        count += 1\n\n        return count\n\n    n, m = map(int, stdin.split())\n    grid = [list(input()) for _ in range(n)]\n    return str(count_distinct_pipes(grid))"
    },
    {
        "number": 1746,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    parents = [int(line) - 1 for line in stdin.splitlines()[1:]]\n\n    def dfs(node: int, parent: int) -> int:\n        leaf_count = 0\n        for child in range(1, n + 1):\n            if child != parent and parents[child - 1] == node:\n                leaf_count += dfs(child, node)\n        return leaf_count\n\n    leaf_count = dfs(1, -1)\n    if leaf_count >= 3:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1747,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_length = 0\n    max_segment = (0, 0)\n\n    for i in range(n):\n        current_length = 1\n        current_set = set([a[i]])\n\n        for j in range(i + 1, n):\n            if len(current_set) <= k:\n                current_set.add(a[j])\n                current_length += 1\n            else:\n                break\n\n        if current_length > max_length:\n            max_length = current_length\n            max_segment = (i + 1, i + max_length)\n\n    return f\"{max_segment[0]} {max_segment[1]}\""
    },
    {
        "number": 1748,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    piles = [int(x) for x in lines[1].split()]\n    temps = [int(x) for x in lines[2].split()]\n    \n    melted = [0] * n\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            piles[j] = max(0, piles[j] - temps[i])\n        melted[i] = sum(piles)\n    \n    return \" \".join(str(x) for x in melted)"
    },
    {
        "number": 1749,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:n+3]))\n    b = list(map(int, stdin.split()[n+4:]))\n\n    for i in range(l-1, r):\n        if a[i] != b[i]:\n            return \"LIE\"\n\n    return \"TRUTH\""
    },
    {
        "number": 1750,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for line in stdin.split('\\n')[1:]:\n        x, y = map(int, line.split())\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    \n    def dfs(node, visited, color):\n        visited.add(node)\n        colors[node] = color\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, (color + 1) % k)\n    \n    min_colors = n\n    for k in range(1, n+1):\n        colors = [-1] * n\n        visited = set()\n        for i in range(n):\n            if colors[i] == -1:\n                dfs(i, visited, 0)\n        if all(colors[i] != colors[j] for i in range(n) for j in range(i+1, n)):\n            min_colors = k\n            break\n    \n    return str(min_colors) + \"\\n\" + \" \".join(map(str, colors))"
    },
    {
        "number": 1751,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for p in permutations(range(1, n+1)):\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i):\n                if p[j] > p[i]:\n                    graph[i].append(j)\n            for j in range(i+1, n):\n                if p[j] > p[i]:\n                    graph[i].append(j)\n\n        visited = [False] * n\n        cycles = 0\n        for i in range(n):\n            if not visited[i]:\n                cycles += 1\n                dfs(i, visited, graph)\n\n        if cycles == n:\n            count += 1\n\n    return str(count % MOD)\n\ndef"
    },
    {
        "number": 1752,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n    heights.sort()\n    result = []\n    for i in range(n):\n        result.append(heights[i])\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1753,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    harmonize = [tuple(map(int, line.split())) for line in stdin.splitlines()[m+1:]]\n    harmonize = set(harmonize)\n\n    def is_harmonize(a: int, b: int) -> bool:\n        return (a, b) in harmonize or (b, a) in harmonize\n\n    def dfs(color: int, visited: set, rooks: list) -> bool:\n        if len(rooks) == 5000:\n            return True\n\n        for x in range(1, 10**9 + 1):\n            for y in range(1, 10**9 + 1):\n                if (x, y) not in visited:\n                    visited.add((x, y))\n                    rooks.append((color, x, y))\n\n                    for other_color in range(1, n + 1):\n                        if other_color != color and is_harmonize(color, other_color):\n                            if dfs(other_color, visited.copy(), rooks):\n                                return True\n\n                    rooks.pop()\n                    visited.remove((x, y))\n\n        return False\n\n    result = []\n    for color in range(1, n + 1):\n        visited = set()\n        rooks = []\n        if dfs(color, visited, rooks):\n            result.append(f\"{len(rooks)}\\n{''.join(f'{x} {y}\\n' for x, y, _ in rooks)}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1754,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    powers = list(map(int, stdin.split()[3:3+n]))\n    schools = list(map(int, stdin.split()[3+n:3+2*n]))\n    chosen_ones = list(map(int, stdin.split()[3+2*n:]))\n\n    chosen_ones_schools = set(schools[i-1] for i in chosen_ones)\n    made_up_schools = set(range(1, m+1)) - chosen_ones_schools\n\n    min_schools = float('inf')\n    for schools_count in range(1, len(made_up_schools)+1):\n        for schools_combination in itertools.combinations(made_up_schools, schools_count):\n            new_schools = chosen_ones_schools.union(schools_combination)\n            new_powers = [max(powers[i] for i in range(n) if schools[i] in new_schools)] * k\n            if new_powers == sorted(new_powers, reverse=True):\n                min_schools = min(min_schools, schools_count)\n\n    return str(min_schools)"
    },
    {
        "number": 1755,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    if k != 0:\n        b = list(map(int, stdin.split()[n+2:]))\n    else:\n        b = []\n\n    if not all(a[i] <= a[i+1] for i in range(n-1)):\n        return \"-1\"\n\n    b_set = set(b)\n    operations = 0\n    for i in range(n):\n        if i not in b_set:\n            operations += a[i] - i - 1\n\n    return str(operations)"
    },
    {
        "number": 1756,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0].split())\n    days_per_month = list(map(int, stdin.split()[1].split()))\n    total_days = sum(days_per_month)\n    max_hugs = 0\n\n    for i in range(total_days - x + 1):\n        hugs = 0\n        for j in range(x):\n            current_day = i + j\n            current_month = 0\n            days_sum = 0\n            while days_sum < current_day:\n                days_sum += days_per_month[current_month]\n                current_month += 1\n            hugs += current_month\n        max_hugs = max(max_hugs, hugs)\n\n    return str(max_hugs)"
    },
    {
        "number": 1757,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fib = [1, 1]\n    for i in range(2, n):\n        fib.append(fib[-1] + fib[-2])\n    name = \"\"\n    for i in range(n):\n        if i in fib:\n            name += \"O\"\n        else:\n            name += \"o\"\n    return name"
    },
    {
        "number": 1758,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if s == t:\n        return \"0\"\n\n    for i in range(n):\n        if s[i] != t[i]:\n            break\n\n    if i == n - 1:\n        return \"-1\"\n\n    for j in range(i, n):\n        if s[j] != t[j]:\n            break\n\n    if j == n - 1:\n        return \"-1\"\n\n    if s[i:j+1] == t[i:j+1][::-1]:\n        return str(j - i + 1)\n\n    return \"-1\""
    },
    {
        "number": 1759,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[:2])\n    pictures = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    times = [0] * m\n    for i in range(n):\n        for j in range(m):\n            times[j] += pictures[j][i]\n    \n    return ' '.join(map(str, times))"
    },
    {
        "number": 1760,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    directions = []\n    for i in range(n):\n        if s[i] == 'U':\n            directions.append('D')\n        else:\n            directions.append('U')\n    durations = []\n    for i in range(n):\n        if i == 0:\n            durations.append(1)\n        else:\n            durations.append(durations[-1] + 1)\n    for i in range(n):\n        if i == 0:\n            durations[i] = durations[i] + 1\n        elif i == n - 1:\n            durations[i] = durations[i] + 1\n        else:\n            if s[i] == 'U':\n                durations[i] = durations[i] + 1\n            else:\n                durations[i] = durations[i] + 2\n    for i in range(n):\n        if i == 0:\n            durations[i] = durations[i] + 1\n        elif i == n - 1:\n            durations[i] = durations[i] + 1\n        else:\n            if s[i] == 'U':\n                durations[i] = durations[i] + 1\n            else:\n                durations[i] = durations[i] + 2\n    return ' '.join(map(str, durations))"
    },
    {
        "number": 1761,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = []\n    n = int(stdin.split('\\n')[0])\n    for i in range(1, n + 1):\n        words.append(stdin.split('\\n')[i])\n\n    encoded_message = stdin.split('\\n')[n + 1]\n\n    decoded_message = \"\"\n    for word in words:\n        decoded_message += word + \"<3\"\n\n    decoded_message = decoded_message[:-3]\n\n    if encoded_message == decoded_message:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 1762,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    videos = []\n    for line in stdin.split('\\n')[1:]:\n        s, m = map(int, line.split())\n        videos.append((s, m))\n\n    servers = [0] * k\n    queue = []\n    for video in videos:\n        s, m = video\n        while not any(servers):\n            servers.sort()\n            queue.append(video)\n            servers.pop(0)\n        servers.append(s + m * 60)\n\n    for video in queue:\n        servers.append(video[0] + video[1] * 60)\n\n    servers.sort()\n    return '\\n'.join(map(str, servers))"
    },
    {
        "number": 1763,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, R, M = map(int, stdin.split()[:4])\n    h = list(map(int, stdin.split()[4:]))\n\n    min_height = min(h)\n    total_cost = 0\n\n    for i in range(N):\n        total_cost += (h[i] - min_height) * M\n        h[i] = min_height\n\n    return str(total_cost)"
    },
    {
        "number": 1764,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    s_t_options = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            s = a.count(1)\n            t = a.count(2)\n            if s > t:\n                s_t_options.add((s, t))\n            s, t = t, s\n            if s > t:\n                s_t_options.add((s, t))\n    return str(len(s_t_options)) + '\\n' + '\\n'.join([f\"{s} {t}\" for s, t in sorted(s_t_options)])"
    },
    {
        "number": 1765,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_list = map(int, stdin.split())\n    a_list.sort()\n    result = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if a_list[i] & a_list[j] & a_list[k] == 0:\n                    result.append((a_list[i], a_list[j], a_list[k]))\n    \n    if not result:\n        return \"0\\n\"\n    \n    max_length = max(len(x) for x in result)\n    max_result = [x for x in result if len(x) == max_length]\n    \n    return str(len(max_result[0])) + \"\\n\" + \" \".join(str(x) for x in max_result[0])"
    },
    {
        "number": 1766,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = stdin.split('\\n')\n    n = int(n)\n    cards = list(map(int, cards.split()))\n\n    sereja_sum = 0\n    dima_sum = 0\n\n    for i in range(n // 2):\n        sereja_sum += cards.pop(0)\n        dima_sum += cards.pop()\n\n    if n % 2 != 0:\n        sereja_sum += cards.pop(0)\n\n    return f\"{sereja_sum} {dima_sum}\""
    },
    {
        "number": 1767,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    def f(x, l, r):\n        result = 0\n        for i in range(l, r + 1):\n            result |= x[i]\n        return result\n\n    max_sum = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            max_sum = max(max_sum, f(a, l, r) + f(b, l, r))\n\n    return str(max_sum)"
    },
    {
        "number": 1768,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, q = stdin.split('\\n')\n    n = int(n)\n    q = int(q)\n    s = list(s)\n\n    def find_koyomity(s: str, c: str) -> int:\n        max_koyomity = 0\n        current_koyomity = 0\n        for i in range(len(s)):\n            if s[i] == c:\n                current_koyomity += 1\n            else:\n                max_koyomity = max(max_koyomity, current_koyomity)\n                current_koyomity = 0\n        return max(max_koyomity, current_koyomity)\n\n    for i in range(q):\n        m, c = map(str, input().split())\n        m = int(m)\n        s[:m] = c * m\n        print(find_koyomity(s, c))"
    },
    {
        "number": 1769,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    N = A + B + 1\n    stops = [i for i in range(1, N + 1)]\n    return \" \".join(map(str, stops))"
    },
    {
        "number": 1770,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_steps(n: int, x: int, y: int, d: int) -> int:\n        if x > y:\n            x, y = y, x\n        if x == y:\n            return 0\n        if (y - x) % d != 0:\n            return -1\n        return (y - x) // d\n\n    output = []\n    for case in stdin.strip().split('\\n'):\n        n, x, y, d = map(int, case.split())\n        output.append(str(min_steps(n, x, y, d)))\n    return '\\n'.join(output)\n"
    },
    {
        "number": 1771,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, w_max = map(int, stdin.split()[0:3])\n    clouds = []\n    for i in range(n):\n        x, v = map(int, stdin.split()[3:5])\n        clouds.append((x, v))\n\n    def is_valid_pair(i, j):\n        x_i, v_i = clouds[i]\n        x_j, v_j = clouds[j]\n        return abs(x_i - x_j) >= l\n\n    def cover_moon(i, j, w):\n        x_i, v_i = clouds[i]\n        x_j, v_j = clouds[j]\n        return x_i + v_i * w <= x_j and x_j + v_j * w >= x_i\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid_pair(i, j):\n                for w in range(-w_max, w_max + 1):\n                    if cover_moon(i, j, w):\n                        count += 1\n                        break\n\n    return str(count)"
    },
    {
        "number": 1772,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    flowers = list(map(int, stdin.split()[1:]))\n    large_bouquets = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (flowers[i] + flowers[j]) % 2 == 1:\n                large_bouquets += 1\n    \n    return str(large_bouquets)"
    },
    {
        "number": 1773,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    trees = []\n    for i in range(1, n + 1):\n        x, a = map(int, stdin.splitlines()[i].split())\n        trees.append((x, a))\n\n    trees.sort(key=lambda x: x[0])\n    max_apples = 0\n    current_apples = 0\n    current_position = 0\n    direction = 1\n\n    for tree in trees:\n        if tree[0] == current_position:\n            current_apples += tree[1]\n        elif tree[0] > current_position:\n            max_apples = max(max_apples, current_apples)\n            current_apples = tree[1]\n            current_position = tree[0]\n            direction *= -1\n        else:\n            break\n\n    return str(max_apples)"
    },
    {
        "number": 1774,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if \"H\" in stdin and \"Q\" in stdin:\n        if stdin.count(\"H\") == stdin.count(\"Q\") + 1:\n            return \"Yes\"\n        else:\n            return \"No\"\n    else:\n        return \"No\""
    },
    {
        "number": 1775,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    droids = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def max_consecutive_droids(droids: List[List[int]]) -> int:\n        max_length = 0\n        current_length = 0\n        for i in range(len(droids)):\n            if all(droids[i]):\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 0\n        return max_length\n    \n    max_length = max_consecutive_droids(droids)\n    result = [0] * m\n    \n    for i in range(m):\n        for j in range(n):\n            if droids[j][i] > 0:\n                result[i] += 1\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1776,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression, operators = stdin.split()\n    plus, minus = map(int, operators.split())\n    \n    max_value = float('-inf')\n    for i in range(2**(plus + minus)):\n        binary = bin(i)[2:].zfill(plus + minus)\n        new_expression = expression\n        for j, op in enumerate(binary):\n            if op == '0':\n                new_expression = new_expression.replace('?', '-', 1)\n            else:\n                new_expression = new_expression.replace('?', '+', 1)\n        value = eval(new_expression)\n        max_value = max(max_value, value)\n    \n    return str(max_value)"
    },
    {
        "number": 1777,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bracket_sequences = stdin.split('\\n')[1:]\n\n    def is_correct_bracket_sequence(sequence: str) -> bool:\n        count = 0\n        for char in sequence:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    def is_valid_pair(sequence1: str, sequence2: str) -> bool:\n        return is_correct_bracket_sequence(sequence1 + sequence2)\n\n    def find_valid_pairs(sequences: list) -> list:\n        pairs = []\n        for i in range(len(sequences)):\n            for j in range(i + 1, len(sequences)):\n                if is_valid_pair(sequences[i], sequences[j]):\n                    pairs.append((sequences[i], sequences[j]))\n        return pairs\n\n    valid_pairs = find_valid_pairs(bracket_sequences)\n    return str(len(valid_pairs))"
    },
    {
        "number": 1778,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a_list = list(map(int, stdin.splitlines()[1].split()))\n    b_list = list(map(int, stdin.splitlines()[2].split()))\n\n    a_score = 0\n    b_score = 0\n\n    while a_list and b_list:\n        a_max = max(a_list)\n        b_max = max(b_list)\n\n        if a_max > b_max:\n            a_list.remove(a_max)\n            a_score += a_max\n        else:\n            b_list.remove(b_max)\n            b_score += b_max\n\n    return str(a_score - b_score)"
    },
    {
        "number": 1779,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    layout1, layout2, text = stdin.split('\\n')\n    layout_map = dict(zip(layout1, layout2))\n    result = ''\n    for char in text:\n        if char.isalpha():\n            result += layout_map[char.lower()].upper() if char.isupper() else layout_map[char.lower()]\n        else:\n            result += char\n    return result"
    },
    {
        "number": 1780,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    queries = []\n    for i in range(m):\n        l, r = map(int, stdin.split()[2+n+i].split())\n        queries.append((l, r))\n\n    def check_query(l, r):\n        if sum(a[l:r+1]) == 0:\n            return 1\n        else:\n            return 0\n\n    responses = []\n    for query in queries:\n        responses.append(check_query(query[0], query[1]))\n\n    return \" \".join(map(str, responses))"
    },
    {
        "number": 1782,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k * 2 > n:\n        return \"-1\"\n\n    result = [0] * n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if i == j:\n                continue\n            for l in range(n):\n                result[l] = (i + j + l) % k + 1\n                if l > 0 and result[l] == result[l - 1]:\n                    break\n            else:\n                return \" \".join(map(str, result))\n\n    return \"-1\""
    },
    {
        "number": 1783,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    weeks = n - k + 1\n    total_sleep = 0\n\n    for i in range(weeks):\n        total_sleep += sum(a[i:i+k])\n\n    average_sleep = total_sleep / weeks\n\n    return f\"{average_sleep:.6f}\""
    },
    {
        "number": 1784,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    piles = list(map(int, input().split()))\n\n    def is_valid(painted_piles):\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                for c in range(1, k + 1):\n                    if abs(painted_piles[i].count(c) - painted_piles[j].count(c)) > 1:\n                        return False\n        return True\n\n    def paint_piles(piles):\n        painted_piles = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(piles[i]):\n                for c in range(1, k + 1):\n                    if not painted_piles[i] or painted_piles[i][-1] != c:\n                        painted_piles[i].append(c)\n                        break\n        return painted_piles\n\n    for i in range(1, k + 1):\n        painted_piles = paint_piles(piles)\n        if is_valid(painted_piles):\n            return \"YES\\n\" + \"\\n\".join([\" \".join(map(str, p)) for p in painted_piles])\n\n    return \"NO\""
    },
    {
        "number": 1785,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    MOD = 10**9 + 7\n\n    def h(s1: str, s2: str) -> int:\n        return sum(1 for i in range(len(s1)) if s1[i] == s2[i])\n\n    def shift(s: str, i: int) -> str:\n        return s[i:] + s[:i]\n\n    def vasya_distance(s1: str, s2: str) -> int:\n        return sum(h(shift(s1, i), shift(s2, j)) for i in range(n) for j in range(n))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            t = shift(s, i + j)\n            distance = vasya_distance(s, t)\n            max_distance = max(max_distance, distance)\n\n    return str(max_distance % MOD)"
    },
    {
        "number": 1786,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, n = map(int, stdin.split()[:3])\n    cuts = stdin.split()[3:]\n    max_area = 0\n    for i in range(n):\n        if cuts[i][0] == 'H':\n            y = int(cuts[i][2:])\n            max_area = max(max_area, w * (h - y))\n        else:\n            x = int(cuts[i][2:])\n            max_area = max(max_area, (h - 1) * (w - x))\n        print(max_area)"
    },
    {
        "number": 1787,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        if s[i] == 'a':\n            dp[i + 1] += dp[i]\n        else:\n            for j in range(i):\n                if s[j] == 'b':\n                    dp[i + 1] += dp[j]\n            dp[i + 1] %= MOD\n\n    return str(dp[-1])"
    },
    {
        "number": 1788,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    X = (A + B) // 2\n    Y = (A - B) // 2\n    return f\"{X} {Y}\""
    },
    {
        "number": 1789,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n\n    if a == b:\n        return str(0)\n\n    if a > b:\n        a, b = b, a\n\n    if a == 1:\n        return str(b * x)\n\n    if b == 1:\n        return str((100 - a + 1) * x)\n\n    if a == 2:\n        return str(min(b * x, (100 - a + 1) * x))\n\n    if b == 100:\n        return str((100 - a + 1) * x)\n\n    if a == 99:\n        return str(b * x)\n\n    return str(min(b * x, (100 - a + 1) * x))"
    },
    {
        "number": 1790,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = set()\n    for i in range(1, n+1):\n        stop_info = stdin.split('\\n')[i].split()\n        stop_lines = set(map(int, stop_info[1:]))\n        lines.intersection_update(stop_lines)\n    return ' '.join(map(str, sorted(lines)))"
    },
    {
        "number": 1791,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fold(s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if i % 2 == 0:\n                stack.append(s[i])\n            else:\n                stack.append(s[i])\n        return ''.join(stack)\n\n    def find_piles(s: str) -> int:\n        piles = []\n        for i in range(len(s)):\n            if i == 0 or s[i] != s[i - 1]:\n                piles.append([s[i]])\n            else:\n                piles[-1].append(s[i])\n        return max(len(p) for p in piles)\n\n    folded = fold(stdin)\n    return find_piles(folded)"
    },
    {
        "number": 1792,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:m+1]]\n    s, b, k, h = map(int, stdin.split(\"\\n\")[m+1].split())\n    spaceships = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[m+2:m+2+s]]\n    bases = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[m+2+s:]]\n    \n    # Calculate the shortest distance between each pair of nodes\n    distances = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        distances[i][i] = 0\n    for u, v in edges:\n        distances[u][v] = 1\n        distances[v][u] = 1\n    for k in range(n):\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])\n    \n    # Calculate the maximum number of bases that can be attacked\n    max_attacked_bases = 0\n    for base_location in [b[0] for b in bases]:\n        spaceships_attacking_base = [s for s in spaceships if s[0] == base_location]\n        if len(spaceships_attacking_base) > 0:\n            max_attacked_bases += 1\n    \n    # Calculate the minimum cost in terms of gold\n    min_cost = max_attacked_bases * k + h * (s - max_attacked_bases)\n    \n    return str(min_cost)"
    },
    {
        "number": 1793,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, S, w, p = stdin.split()\n    n, L, S = int(n), int(L), int(S)\n    w, p = list(map(int, w)), list(map(int, p))\n\n    def dfs(node: int, parent: int) -> int:\n        if node == 1:\n            return 0\n        path_sum = w[node]\n        path_length = 1\n        current = node\n        while current != 1:\n            current = p[current]\n            path_sum += w[current]\n            path_length += 1\n        if path_length > L or path_sum > S:\n            return -1\n        return path_length\n\n    paths = []\n    for i in range(2, n + 1):\n        path_length = dfs(i, p[i])\n        if path_length != -1:\n            paths.append(path_length)\n\n    return str(len(paths)) if paths else \"-1\""
    },
    {
        "number": 1794,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    total = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if j <= a[i]:\n                total += j - i\n\n    return str(total)"
    },
    {
        "number": 1795,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, planes = stdin.split('\\n')\n    n = int(n)\n    planes = [int(x) for x in planes.split()]\n\n    for i in range(n):\n        for j in range(n):\n            if planes[i] == planes[j] and i != j:\n                for k in range(n):\n                    if planes[j] == planes[k] and k != j:\n                        if planes[i] == planes[k]:\n                            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1796,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = 0\n    for line in stdin.split('\\n'):\n        if line == '++X':\n            x += 1\n        elif line == '--X':\n            x -= 1\n    return str(x)"
    },
    {
        "number": 1797,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    n = int(n)\n    p = list(map(int, p.split()))\n\n    # Calculate the number of pairs (x, y) such that person can start at station x and, after taking some subway trains (possibly zero), arrive at station y\n    def count_pairs(p):\n        pairs = 0\n        for i in range(n):\n            for j in range(n):\n                if p[i] == j:\n                    pairs += 1\n        return pairs\n\n    # Calculate the maximum possible value of convenience\n    def max_convenience(p):\n        max_convenience = count_pairs(p)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    p_copy = p.copy()\n                    p_copy[i] = j\n                    max_convenience = max(max_convenience, count_pairs(p_copy))\n        return max_convenience\n\n    return str(max_convenience(p))"
    },
    {
        "number": 1798,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n    x_dict = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            if sequence[i] == sequence[j]:\n                if sequence[i] not in x_dict:\n                    x_dict[sequence[i]] = [i, j]\n                else:\n                    x_dict[sequence[i]].append(j)\n    result = []\n    for x in x_dict:\n        positions = x_dict[x]\n        if len(positions) > 1:\n            common_diff = positions[1] - positions[0]\n            for i in range(len(positions)-1):\n                if positions[i+1] - positions[i] != common_diff:\n                    break\n            else:\n                result.append((x, common_diff))\n        else:\n            result.append((x, 0))\n    return str(len(result)) + '\\n' + '\\n'.join(f\"{x} {p}\" for x, p in result)"
    },
    {
        "number": 1799,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    teams = []\n    for i in range(n):\n        t, w = map(int, stdin.readline().split())\n        teams.append((t, w))\n\n    teams.sort(key=lambda x: (-x[0], x[1]))\n    best_place = 0\n    for i in range(n):\n        if teams[i][0] <= teams[i][1]:\n            best_place += 1\n        else:\n            break\n\n    return str(best_place)"
    },
    {
        "number": 1800,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    managers = []\n    for i in range(m):\n        t, r = map(int, stdin.split()[2+n+i*2:2+n+i*2+2])\n        managers.append((t, r))\n\n    for manager in managers:\n        if manager[0] == 1:\n            a[:manager[1]] = sorted(a[:manager[1]])\n        else:\n            a[:manager[1]] = sorted(a[:manager[1]], reverse=True)\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1801,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    a.sort()\n    b.sort()\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if a[i] <= b[j]:\n                count += 1\n    return str(count % m)"
    },
    {
        "number": 1802,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n    heights.sort()\n    max_buns = 0\n    min_height = heights[0]\n    step = heights[1] - heights[0]\n\n    for i in range(1, n):\n        if heights[i] - heights[i - 1] == step:\n            max_buns += 1\n        else:\n            step = heights[i] - heights[i - 1]\n            max_buns += 2\n\n    return str(max_buns) + \"\\n\" + str(min_height) + \" \" + str(step)"
    },
    {
        "number": 1803,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, initial_birds, m, shots = stdin.split('\\n')\n    n = int(n)\n    initial_birds = list(map(int, initial_birds.split()))\n    m = int(m)\n    shots = [list(map(int, shot.split())) for shot in shots.split('\\n')]\n\n    birds_on_wires = initial_birds.copy()\n\n    for shot in shots:\n        x, y = shot\n        birds_on_wires[x - 1] -= y\n        if x - 2 >= 0:\n            birds_on_wires[x - 2] += y\n        if x + 1 < n:\n            birds_on_wires[x + 1] += y\n\n    return '\\n'.join(map(str, birds_on_wires))"
    },
    {
        "number": 1804,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_optimal_restaurant(hotels, restaurants):\n        min_distance = float('inf')\n        min_index = -1\n        for i, restaurant in enumerate(restaurants):\n            dist = min(distance(hotel[0], hotel[1], restaurant[0], restaurant[1]) for hotel in hotels)\n            if dist < min_distance:\n                min_distance = dist\n                min_index = i\n        return min_distance, min_index\n\n    N, M, C, hotels, H, restaurants = stdin.split('\\n')\n    N, M, C, H = map(int, [N, M, C, H])\n    hotels = [list(map(int, line.split())) for line in hotels.split('\\n')]\n    restaurants = [list(map(int, line.split())) for line in restaurants.split('\\n')]\n\n    min_distance, min_index = find_optimal_restaurant(hotels, restaurants)\n    return f\"{min_distance}\\n{min_index}\""
    },
    {
        "number": 1805,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split()[0])\n    result = []\n    for _ in range(q):\n        n = int(stdin.split()[1])\n        if n == 2:\n            result.append(2)\n        elif n == 5:\n            result.append(1)\n        else:\n            result.append(0)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1806,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    intervals = [list(map(int, stdin.split()[2*i:2*(i+1)])) for i in range(n)]\n    queries = [list(map(int, stdin.split()[2*n+2*i:2*(n+i+1)]) for i in range(m)]\n\n    def is_covered(intervals, x, y):\n        for l, r in intervals:\n            if l <= x and y <= r:\n                return True\n        return False\n\n    result = []\n    for x, y in queries:\n        covered = False\n        for i in range(n):\n            l, r = intervals[i]\n            if is_covered([[l, r], [x, y]], x, y):\n                covered = True\n                break\n        result.append(1 if covered else -1)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1807,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    segments = {\n        0: 6,\n        1: 2,\n        2: 5,\n        3: 5,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 3,\n        8: 7,\n        9: 6\n    }\n    total_segments = 0\n    for i in range(a, b+1):\n        total_segments += segments[i]\n    return str(total_segments)"
    },
    {
        "number": 1808,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    if x >= min(a):\n        return str(sum(a))\n\n    result = 0\n    for i in range(n):\n        if a[i] > x:\n            result += a[i]\n        else:\n            result += x\n            k -= 1\n            if k == 0:\n                break\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 1809,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    weights = list(map(int, stdin.split()[2:2+n]))\n    books = list(map(int, stdin.split()[2+n:]))\n\n    def total_weight(order: list) -> int:\n        total = 0\n        for i in range(len(order)):\n            total += weights[order[i]-1]\n        return total\n\n    def find_min_weight(order: list) -> int:\n        min_weight = float('inf')\n        for i in range(len(order)):\n            for j in range(i+1, len(order)):\n                new_order = order[:i] + order[j:j+1] + order[i:i+1] + order[j+1:]\n                min_weight = min(min_weight, total_weight(new_order))\n        return min_weight\n\n    return str(find_min_weight(books))"
    },
    {
        "number": 1810,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if all(i % j == 0 for j in range(2, 11)):\n            count += 1\n    return str(count)"
    },
    {
        "number": 1811,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    road = stdin.split('\\n')[1]\n\n    can_reach_end = True\n    current_sector = 1\n\n    while current_sector < n:\n        next_sectors = [current_sector + i for i in range(1, k + 1) if current_sector + i <= n]\n        if not next_sectors:\n            can_reach_end = False\n            break\n\n        next_sector = next_sectors[-1]\n        if road[next_sector - 1] == \"#\":\n            can_reach_end = False\n            break\n\n        current_sector = next_sector\n\n    return \"YES\" if can_reach_end else \"NO\""
    },
    {
        "number": 1812,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(line) for line in stdin.split('\\n')[1:]]\n\n    def find_k(a_i):\n        k = 1\n        while True:\n            if str(2**k)[:100].find(str(a_i)) != -1:\n                return k\n            k += 1\n\n    k = [find_k(a_i) for a_i in a]\n\n    return '\\n'.join(str(k_i) for k_i in k)"
    },
    {
        "number": 1813,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, l = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def is_valid(start: int, end: int) -> bool:\n        if end - start + 1 < l:\n            return False\n        if max(a[start:end+1]) - min(a[start:end+1]) > s:\n            return False\n        return True\n\n    def find_min_pieces(start: int) -> int:\n        if start >= n:\n            return 0\n        if not is_valid(start, start):\n            return -1\n        min_pieces = float('inf')\n        for end in range(start+1, n+1):\n            if is_valid(start, end):\n                min_pieces = min(min_pieces, find_min_pieces(end))\n        return min_pieces + 1\n\n    return str(find_min_pieces(0))"
    },
    {
        "number": 1814,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_time(x1, y1, x2, y2, stairs, elevators, max_speed):\n        if x1 == x2 and y1 == y2:\n            return 0\n\n        if x1 == x2:\n            return abs(y1 - y2)\n\n        if y1 == y2:\n            return abs(x1 - x2) * 2\n\n        if x1 > x2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n\n        if y1 in stairs:\n            return min_time(x1, y1, x2, y2, stairs, elevators, max_speed)\n\n        if y1 in elevators:\n            elevator_speed = max_speed\n            elevator_floor = elevators.index(y1)\n            if elevator_floor > x1:\n                elevator_speed *= -1\n            return min_time(x1, y1, x2, y2, stairs, elevators, max_speed) + abs(x1 - elevator_floor) * elevator_speed\n\n        return min_time(x1, y1, x2, y2, stairs, elevators, max_speed) + 2\n\n    def process_queries(stdin: str) -> str:\n        n, m, c_l, c_e, v = map(int, stdin.split()[:5])\n        stairs = list(map(int, stdin.split()[5:5 + c_l]))\n        elevators = list(map(int, stdin.split()[5 + c_l:]))\n\n        q = int(stdin.split()[-1])\n        queries = [list(map(int, stdin.split()[i:i + 4])) for i in range(5 + c_l + c_e, 5 + c_l + c_e + q * 4, 4)]\n\n        result = []\n        for query in queries:\n            x1, y1, x2, y2 = query\n            result.append(min_time(x1, y1, x2, y2, stairs, elevators, v))\n\n        return \"\\n\".join(map(str, result))\n\n    return process_queries(stdin)"
    },
    {
        "number": 1815,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    color_count = {}\n    max_streak = 0\n\n    for i in range(n):\n        color = colors[i]\n        if color not in color_count:\n            color_count[color] = 1\n        else:\n            color_count[color] += 1\n\n        if len(color_count) == len(set(colors[:i+1])):\n            max_streak = i + 1\n\n    return str(max_streak)"
    },
    {
        "number": 1816,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, fragments = stdin.split()\n    n = int(n)\n    fragments = list(map(int, fragments.split()))\n\n    time_units = 0\n    current_sector = 1\n\n    for fragment in fragments:\n        time_units += abs(current_sector - fragment)\n        current_sector = fragment\n\n    return str(time_units)"
    },
    {
        "number": 1817,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    numbers.sort(reverse=True)\n\n    return str(numbers[0])"
    },
    {
        "number": 1818,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x % 2 == 0:\n            return f(x // 2)\n        else:\n            return f(x // 2) + 1\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if f(a[i]) == f(a[j]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1819,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        n, x = map(int, stdin.readline().strip().split())\n        remaining_numbers = list(range(1, n + 1))\n        for i in range(1, n + 1):\n            if i <= len(remaining_numbers):\n                remaining_numbers.remove(i)\n            else:\n                break\n        result.append(remaining_numbers[x - 1])\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1820,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_triangle_possible(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def find_triple(a):\n        n = len(a)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if not is_triangle_possible(a[i], a[j], a[k]):\n                        return i + 1, j + 1, k + 1\n        return -1\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        triple = find_triple(a)\n        if triple == -1:\n            result.append(\"-1\")\n        else:\n            result.append(\" \".join(map(str, sorted(triple))))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1821,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    notes = list(map(int, stdin.split()[1:]))\n\n    def is_melody(subsequence):\n        for i in range(len(subsequence) - 1):\n            if (subsequence[i + 1] - subsequence[i]) % 7 != 1:\n                return False\n        return True\n\n    def find_melody(subsequence):\n        for i in range(len(subsequence) - 1):\n            if (subsequence[i + 1] - subsequence[i]) % 7 != 1:\n                return False\n        return True\n\n    def find_max_sum(notes):\n        max_sum = 0\n        for i in range(len(notes)):\n            for j in range(i + 1, len(notes)):\n                subsequence1 = notes[i:j]\n                if is_melody(subsequence1):\n                    for k in range(j, len(notes)):\n                        subsequence2 = notes[j:k]\n                        if is_melody(subsequence2):\n                            max_sum = max(max_sum, len(subsequence1) + len(subsequence2))\n        return max_sum\n\n    max_sum = find_max_sum(notes)\n    return str(max_sum)"
    },
    {
        "number": 1822,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queue = [i for i in range(1, n+1)]\n\n    for i in range(n):\n        if a[i] != 0:\n            queue.remove(a[i])\n            queue.append(a[i])\n\n    if x in queue:\n        return str(queue.index(x)+1)\n    else:\n        return \"Not in queue\""
    },
    {
        "number": 1823,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    genres = list(map(int, stdin.split()[2:]))\n\n    min_stresses = k\n    excluded_genre = 0\n\n    for i in range(1, k + 1):\n        stresses = 0\n        for j in range(n):\n            if genres[j] != i:\n                stresses += 1\n        if stresses < min_stresses:\n            min_stresses = stresses\n            excluded_genre = i\n\n    return str(excluded_genre)"
    },
    {
        "number": 1824,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    errors = list(map(int, stdin.split('\\n')[1].split()))\n    errors2 = list(map(int, stdin.split('\\n')[2].split()))\n    errors3 = list(map(int, stdin.split('\\n')[3].split()))\n\n    for error in errors:\n        if error in errors2 and error in errors3:\n            errors2.remove(error)\n            errors3.remove(error)\n\n    return str(errors2[0]) + '\\n' + str(errors3[0])"
    },
    {
        "number": 1825,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strings = []\n    for i in range(1, n + 1):\n        string, k, *positions = stdin.split('\\n')[i].split()\n        positions = [int(x) for x in positions]\n        strings.append((string, k, positions))\n\n    strings.sort(key=lambda x: (x[0], x[2]))\n\n    result = \"\"\n    for string, k, positions in strings:\n        for _ in range(k):\n            result += string\n\n    return result\n\n\ndef"
    },
    {
        "number": 1826,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    moves = stdin.split('\\n')[1]\n    i = 0\n    while i < n - 1:\n        if moves[i:i+2] in ['UR', 'RU']:\n            moves = moves[:i] + 'D' + moves[i+2:]\n            n -= 1\n        else:\n            i += 1\n    return str(n)"
    },
    {
        "number": 1828,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    dangerous_turns = 0\n\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[i + 1]\n\n        if (x1 == x2 and y1 == y2) or (abs(x1 - x2) == 1 and abs(y1 - y2) == 1):\n            continue\n\n        if (x1 == x2 and y1 < y2) or (x1 < x2 and y1 == y2):\n            dangerous_turns += 1\n\n    return str(dangerous_turns)"
    },
    {
        "number": 1829,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    words_poland = stdin.split('\\n')[1:n+1]\n    words_enemy = stdin.split('\\n')[n+1:]\n\n    def play_game(words_poland, words_enemy):\n        turn = 0\n        while True:\n            if turn % 2 == 0:\n                if not words_poland:\n                    return False\n                word = words_poland.pop(0)\n            else:\n                if not words_enemy:\n                    return True\n                word = words_enemy.pop(0)\n            turn += 1\n\n    if play_game(words_poland, words_enemy):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1830,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    rooks = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    board = [[0] * n for _ in range(n)]\n\n    def is_under_attack(x: int, y: int) -> bool:\n        for i in range(m):\n            if rooks[i][0] == x or rooks[i][1] == y:\n                return True\n        return False\n\n    result = []\n    for i in range(m):\n        x, y = rooks[i]\n        board[x - 1][y - 1] = 1\n        result.append(sum(sum(row) for row in board) - sum(row.count(1) for row in board))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1831,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    connectors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    def dfs(connector, visited):\n        visited.add(connector)\n        for c in connectors:\n            if connector in c and c[0] not in visited and c[1] not in visited:\n                dfs(c[0], visited)\n                dfs(c[1], visited)\n    \n    for i in range(1, n+1):\n        visited = set()\n        dfs(i, visited)\n        if len(visited) != n:\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 1832,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases:\n        n = int(test_case)\n        a = list(map(int, input().split()))\n\n        s = [\"\"] * (n + 1)\n        for i in range(n + 1):\n            s[i] = \"a\" * a[i]\n\n        for i in range(n):\n            s[i] += \"b\" * (a[i + 1] - a[i])\n\n        for i in range(n + 1):\n            result.append(s[i])\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1833,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    MOD = 10**9 + 7\n    result = 0\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            subsequence = a[j:i]\n            if all(x % i == 0 for x in subsequence):\n                result += 1\n\n    return str(result % MOD)"
    },
    {
        "number": 1834,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"1\"\n\n    for i in range(2, n, 2):\n        if a[i] < a[i - 2]:\n            a[i - 2], a[i] = a[i], a[i - 2]\n\n    for i in range(3, n, 2):\n        if a[i] > a[i - 2]:\n            return \"Impossible\"\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 1835,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def swap_strings(s1: str, s2: str, a: int, b: int) -> None:\n        nonlocal s1, s2\n        s1 = s1[:a] + s2[b] + s1[a + 1:]\n        s2 = s2[:b] + s1[a] + s2[b + 1:]\n\n    def max_palindromic_strings(strings: List[str]) -> int:\n        n = len(strings)\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_palindrome(strings[i] + strings[j]):\n                    count += 1\n        return count\n\n    def read_input(stdin: str) -> List[List[str]]:\n        test_cases = stdin.strip().split('\\n')\n        Q = int(test_cases[0])\n        test_cases = test_cases[1:]\n        inputs = []\n        for i in range(Q):\n            n = int(test_cases[0])\n            strings = test_cases[1:n + 1]\n            inputs.append(strings)\n            test_cases = test_cases[n + 1:]\n        return inputs\n\n    inputs = read_input(stdin)\n    results = []\n    for strings in inputs:\n        results.append(max_palindromic_strings(strings))\n    return '\\n'.join(map(str, results))\n"
    },
    {
        "number": 1836,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    segments = []\n    for line in stdin.split('\\n')[1:]:\n        u, v = map(int, line.split())\n        segments.append((u, v))\n\n    def is_tail(tail: List[int]) -> bool:\n        for i in range(len(tail) - 1):\n            if (tail[i], tail[i + 1]) not in segments:\n                return False\n        return True\n\n    def is_spine(spine: Tuple[int, int]) -> bool:\n        return spine in segments\n\n    def hedgehog_beauty(tail: List[int], spines: List[Tuple[int, int]]) -> int:\n        return len(tail) * len(spines)\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                tail = [i, j, k]\n                if not is_tail(tail):\n                    continue\n                spines = [(tail[i], tail[i + 1]) for i in range(len(tail) - 1)]\n                spines.extend([(tail[i], tail[i + 1]) for i in range(len(tail) - 2, 0, -1)])\n                beauty = hedgehog_beauty(tail, spines)\n                max_beauty = max(max_beauty, beauty)\n\n    return str(max_beauty)"
    },
    {
        "number": 1837,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    fixed_points = [i for i in range(n) if a[i] == i]\n    if len(fixed_points) == n:\n        return str(n)\n\n    for i in range(n):\n        if a[i] == i:\n            continue\n        for j in range(n):\n            if a[j] == i:\n                a[i], a[j] = a[j], a[i]\n                fixed_points = [i for i in range(n) if a[i] == i]\n                return str(len(fixed_points))\n\n    return str(len(fixed_points))"
    },
    {
        "number": 1838,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_relation(relations, x, y, t):\n        for relation in relations:\n            if relation[0] == x and relation[1] == y:\n                return False\n            if relation[0] == y and relation[1] == x:\n                return False\n        return True\n\n    def add_relation(relations, x, y, t):\n        if is_valid_relation(relations, x, y, t):\n            relations.append((x, y, t))\n            return \"YES\"\n        return \"NO\"\n\n    def find_relation(relations, x, y):\n        for relation in relations:\n            if relation[0] == x and relation[1] == y:\n                return 1\n            if relation[0] == y and relation[1] == x:\n                return 2\n        return 3\n\n    n, m, q = map(int, stdin.readline().split())\n    words = stdin.readline().split()\n    relations = []\n\n    for _ in range(m):\n        t, x, y = map(str, stdin.readline().split())\n        if t == \"1\":\n            print(add_relation(relations, x, y, 1))\n        else:\n            print(add_relation(relations, x, y, 2))\n\n    for _ in range(q):\n        x, y = map(str, stdin.readline().split())\n        print(find_relation(relations, x, y))"
    },
    {
        "number": 1839,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    intersections = stdin.split('\\n')[1:]\n    asphalted_roads = set()\n    days_with_asphalt = set()\n\n    for i, intersection in enumerate(intersections):\n        h, v = map(int, intersection.split())\n        if (h, v) not in asphalted_roads:\n            asphalted_roads.add((h, v))\n            days_with_asphalt.add(i + 1)\n\n    return ' '.join(map(str, sorted(days_with_asphalt)))\n"
    },
    {
        "number": 1840,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, b = map(int, stdin.split()[:2])\n    spaceships = list(map(int, stdin.split()[2:2+s]))\n    bases = []\n    for _ in range(b):\n        d, g = map(int, stdin.split()[2+s+b:2+s+b+2])\n        bases.append((d, g))\n\n    def max_gold(spaceship: int) -> int:\n        max_gold = 0\n        for base in bases:\n            if spaceship <= base[0]:\n                max_gold += base[1]\n        return max_gold\n\n    result = [max_gold(spaceship) for spaceship in spaceships]\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1841,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    l = []\n    for i in range(m):\n        l.append(int(input()))\n\n    for i in l:\n        distinct_count = len(set(a[i-1:]))\n        print(distinct_count)"
    },
    {
        "number": 1842,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    delta = b**2 - 4*a*c\n    if delta < 0:\n        return \"No real roots\"\n    x1 = (-b + delta**0.5) / (2*a)\n    x2 = (-b - delta**0.5) / (2*a)\n    return f\"{max(x1, x2):.6f}\\n{min(x1, x2):.6f}\""
    },
    {
        "number": 1843,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, t+1):\n        n = int(stdin.split('\\n')[i])\n        sum = 0\n        for j in range(1, n+1):\n            if j & (j-1) == 0:\n                sum -= j\n            else:\n                sum += j\n        result.append(sum)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1844,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def find_subset(a, gcd_target):\n        for i in range(1, len(a) + 1):\n            for subset in itertools.combinations(a, i):\n                if gcd(sum(subset), gcd_target) == 1:\n                    return i\n        return -1\n\n    result = find_subset(a, 1)\n    return str(result)"
    },
    {
        "number": 1845,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, powers = stdin.split()\n    n = int(n)\n    powers = list(map(int, powers.split()))\n\n    min_power = sum(powers)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for x in range(1, powers[i] + 1):\n                    if powers[i] % x == 0:\n                        new_power = (powers[i] // x) * powers[j] + (powers[j] * x)\n                        min_power = min(min_power, new_power)\n\n    return str(min_power)"
    },
    {
        "number": 1846,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    temperatures = list(map(int, stdin.split()[1:]))\n\n    if n < 2:\n        return \"0\"\n\n    negative_count = 0\n    positive_count = 0\n    for temperature in temperatures:\n        if temperature < 0:\n            negative_count += 1\n        elif temperature > 0:\n            positive_count += 1\n\n    if negative_count == 0 or positive_count == 0:\n        return \"0\"\n\n    return str(min(negative_count, positive_count))\n"
    },
    {
        "number": 1847,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_0, y_0, x_1, y_1 = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    allowed_cells = []\n    for _ in range(n):\n        r, a, b = map(int, stdin.readline().split())\n        allowed_cells.append((r, a, b))\n\n    def is_allowed(cell: tuple) -> bool:\n        for allowed_cell in allowed_cells:\n            if cell[0] == allowed_cell[0] and cell[1] >= allowed_cell[1] and cell[1] <= allowed_cell[2]:\n                return True\n        return False\n\n    def get_neighbors(cell: tuple) -> list:\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            neighbor = (cell[0] + dx, cell[1] + dy)\n            if 1 <= neighbor[0] <= 10**9 and 1 <= neighbor[1] <= 10**9:\n                neighbors.append(neighbor)\n        return neighbors\n\n    def bfs(start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, distance = queue.pop(0)\n            if current == end:\n                return distance\n            if current not in visited:\n                visited.add(current)\n                for neighbor in get_neighbors(current):\n                    if is_allowed(neighbor):\n                        queue.append((neighbor, distance + 1))\n        return -1\n\n    return str(bfs((x_0, y_0), (x_1, y_1)))"
    },
    {
        "number": 1848,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_happy = 0\n    for i in range(n - 1):\n        if a[i] + 1 > a[i + 1]:\n            max_happy += 1\n    return str(max_happy)"
    },
    {
        "number": 1849,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    modulo = 998244353\n    count = [0] * (n + 1)\n\n    for i in range(10 ** n):\n        num = str(i).zfill(n)\n        for length in range(1, n + 1):\n            for j in range(n - length + 1):\n                block = num[j:j + length]\n                if all(c == block[0] for c in block):\n                    count[length] += 1\n\n    return \" \".join(str(c % modulo) for c in count)"
    },
    {
        "number": 1850,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split()[0:2])\n    current_ranking = list(map(int, stdin.split()[2:N+2]))\n    next_points = list(map(int, stdin.split()[N+2:]))\n    \n    for i in range(N):\n        if current_ranking[i] == next_points[D-1]:\n            return str(i+1)\n    \n    return str(N)"
    },
    {
        "number": 1851,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    days = 1\n    read_pages = set()\n    while True:\n        read_pages.add(days)\n        if all(page in read_pages for page in a):\n            break\n        days += 1\n\n    return str(days)"
    },
    {
        "number": 1852,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_full_binary_tree(n: int) -> bool:\n        return 2 ** (n - 1) <= 2 ** n - 1\n\n    def is_complete_binary_tree(n: int) -> bool:\n        return 2 ** (n - 1) <= 2 ** n - 1\n\n    def find_parent(n: int, removed_vertex: int) -> int:\n        parent = 0\n        for i in range(n - 1, 0, -1):\n            if removed_vertex <= 2 ** i - 1:\n                removed_vertex += 2 ** i - 1\n                parent = 2 ** i - 1\n            else:\n                removed_vertex -= 2 ** i\n        return parent\n\n    def mcdic_generation(n: int, edges: list) -> bool:\n        if not is_full_binary_tree(n):\n            return False\n\n        vertices = set()\n        for edge in edges:\n            vertices.add(edge[0])\n            vertices.add(edge[1])\n\n        if len(vertices) != 2 ** n - 1:\n            return False\n\n        for i in range(1, n):\n            if not is_complete_binary_tree(i):\n                return False\n\n        return True\n\n    def find_answers(n: int, edges: list) -> list:\n        if not mcdic_generation(n, edges):\n            return []\n\n        removed_vertex = 2 ** n - 2\n        parent = find_parent(n, removed_vertex)\n        return [parent]\n\n    n = int(stdin.readline().strip())\n    edges = []\n    for i in range(2 ** n - 3):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    answers = find_answers(n, edges)\n    return str(len(answers)) + \"\\n\" + \" \".join(map(str, answers))"
    },
    {
        "number": 1853,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    if all(p[0] != i and p[1] != i and p[0] != j and p[1] != j and p[0] != k and p[1] != k and p[0] != l and p[1] != l for p in pairs):\n                        first_array = [i, j, k, l]\n                        second_array = [i, j, i, l]\n                        for pair in pairs:\n                            if first_array[pair[0] - 1] > first_array[pair[1] - 1]:\n                                if second_array[pair[0] - 1] > second_array[pair[1] - 1]:\n                                    continue\n                                else:\n                                    return \"NO\"\n                            elif first_array[pair[0] - 1] < first_array[pair[1] - 1]:\n                                if second_array[pair[0] - 1] < second_array[pair[1] - 1]:\n                                    continue\n                                else:\n                                    return \"NO\"\n                            else:\n                                if second_array[pair[0] - 1] == second_array[pair[1] - 1]:\n                                    continue\n                                else:\n                                    return \"NO\"\n                        return \"YES\\n\" + \" \".join(map(str, first_array)) + \"\\n\" + \" \".join(map(str, second_array))\n    return \"NO\""
    },
    {
        "number": 1854,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, degrees = stdin.split()\n    n = int(n)\n    degrees = list(map(int, degrees.split()))\n\n    if n == 1:\n        return \"NO\"\n\n    graph = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if degrees[i] > 0 and degrees[j] > 0:\n                graph[i][j] = 1\n                graph[j][i] = 1\n                degrees[i] -= 1\n                degrees[j] -= 1\n\n    if any(degrees):\n        return \"NO\"\n\n    diameter = 0\n    for i in range(n):\n        visited = [False] * n\n        max_distance = 0\n        queue = [(i, 0)]\n        while queue:\n            node, distance = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                max_distance = max(max_distance, distance)\n                for neighbor in range(n):\n                    if graph[node][neighbor] == 1:\n                        queue.append((neighbor, distance + 1))\n        diameter = max(diameter, max_distance)\n\n    if diameter == 0:\n        return \"NO\"\n\n    result = f\"YES {diameter}\\n{n - 1}\\n\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                result += f\"{i + 1} {j + 1}\\n\"\n\n    return result"
    },
    {
        "number": 1855,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    p.sort()\n\n    def find_partitions(start: int, end: int, k: int) -> List[List[int]]:\n        if k == 1:\n            return [[start, end]]\n        partitions = []\n        for i in range(start, end - k + 1):\n            for partition in find_partitions(i + 1, end, k - 1):\n                partitions.append([i] + partition)\n        return partitions\n\n    def partition_value(partition: List[int]) -> int:\n        max_value = 0\n        for i in range(k):\n            max_value += max(partition[i])\n        return max_value\n\n    max_partition_value = 0\n    max_partitions = []\n    for partition in find_partitions(0, n, k):\n        value = partition_value(partition)\n        if value > max_partition_value:\n            max_partition_value = value\n            max_partitions = [partition]\n        elif value == max_partition_value:\n            max_partitions.append(partition)\n\n    return f\"{max_partition_value} {len(max_partitions)}\""
    },
    {
        "number": 1856,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    passwords = stdin.split('\\n')[1:]\n\n    def is_equivalent(password1: str, password2: str) -> bool:\n        for letter in password1:\n            if letter in password2:\n                return True\n        return False\n\n    def get_equivalent_passwords(password: str) -> set:\n        equivalent_passwords = set()\n        for p in passwords:\n            if is_equivalent(password, p):\n                equivalent_passwords.add(p)\n        return equivalent_passwords\n\n    def get_minimal_passwords(password: str) -> int:\n        equivalent_passwords = get_equivalent_passwords(password)\n        if password in equivalent_passwords:\n            equivalent_passwords.remove(password)\n        return len(equivalent_passwords) + 1\n\n    minimal_passwords = []\n    for password in passwords:\n        minimal_passwords.append(get_minimal_passwords(password))\n\n    return str(min(minimal_passwords))"
    },
    {
        "number": 1857,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(n * (n - 1) * (n - 2) // 6)"
    },
    {
        "number": 1858,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            s1 = set(range(1, i+1))\n            s2 = set(range(i+1, j+1))\n            s3 = set(range(j+1, n+1))\n            if len(s1) > 0 and len(s2) > 0 and len(s3) > 0:\n                if math.gcd(sum(s1), sum(s2)) > 1:\n                    return \"Yes\\n\" + str(len(s1)) + \" \" + \" \".join(map(str, s1)) + \"\\n\" + str(len(s2)) + \" \" + \" \".join(map(str, s2))\n    return \"No\""
    },
    {
        "number": 1859,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n != 0:\n        d = 2\n        while n % d != 0:\n            d += 1\n        n -= d\n        count += 1\n    return str(count)"
    },
    {
        "number": 1860,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_offices = 0\n    for i in range(1, n+1):\n        max_offices += 7**i\n    return str(max_offices)"
    },
    {
        "number": 1861,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = [list(input()) for _ in range(n)]\n    count = 0\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for l in range(j + 1, n):\n                set_found = True\n                for feature in range(k):\n                    if cards[i][feature] == cards[j][feature] == cards[l][feature]:\n                        set_found = False\n                        break\n                    elif cards[i][feature] != cards[j][feature] != cards[l][feature]:\n                        set_found = False\n                        break\n                if set_found:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 1862,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    socks = list(map(int, stdin.split()[1:]))\n    table = 0\n    max_table = 0\n\n    for i in range(2 * n):\n        if socks[i] not in socks[:i]:\n            table += 1\n            max_table = max(max_table, table)\n        else:\n            table -= 1\n\n    return str(max_table)"
    },
    {
        "number": 1863,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    prices = []\n    for _ in range(n):\n        a, g = map(int, stdin.readline().strip().split())\n        prices.append((a, g))\n\n    total_price = sum(sum(price) for price in prices)\n    if total_price != 1000 * n:\n        return \"-1\"\n\n    total_price_a = 0\n    total_price_g = 0\n    for a, g in prices:\n        total_price_a += a\n        total_price_g += g\n\n    if abs(total_price_a - total_price_g) > 500:\n        return \"-1\"\n\n    result = \"\"\n    for i in range(n):\n        if total_price_a < total_price_g:\n            result += \"A\"\n            total_price_a += prices[i][0]\n            total_price_g -= prices[i][1]\n        else:\n            result += \"G\"\n            total_price_a -= prices[i][0]\n            total_price_g += prices[i][1]\n\n    return result"
    },
    {
        "number": 1864,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, values = map(int, stdin.split())\n    values = sorted(values)\n    unfortunate_sum = -1\n\n    for i in range(1, n):\n        for j in range(i):\n            if values[i] - values[j] in values:\n                unfortunate_sum = values[i] - values[j]\n                break\n        if unfortunate_sum != -1:\n            break\n\n    return str(unfortunate_sum)"
    },
    {
        "number": 1865,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n    swaps = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if array[i] > array[j]:\n                swaps.append((i, j))\n    return str(len(swaps)) + '\\n' + '\\n'.join(map(lambda x: f\"{x[0]} {x[1]}\", swaps))"
    },
    {
        "number": 1866,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    pairs = [(1, 2)]\n    return str(len(pairs)) + \"\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in pairs)"
    },
    {
        "number": 1867,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n    max_count = 0\n    max_index = 0\n    count = 1\n    index = 0\n\n    for i in range(1, n):\n        if array[i] == array[i - 1]:\n            count += 1\n        else:\n            if count > max_count:\n                max_count = count\n                max_index = index\n            count = 1\n            index = i\n\n    if count > max_count:\n        max_count = count\n        max_index = index\n\n    return f\"{max_index + 1} {max_index + max_count}\""
    },
    {
        "number": 1868,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, size_a = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n    a = set(range(1, size_a + 1))\n\n    def count_strings(n: int, m: int, b: List[int], a: Set[int]) -> int:\n        if n == 0:\n            return 1\n        if n < 0 or m == 0:\n            return 0\n\n        count = 0\n        for i in range(m):\n            k = b[i]\n            if k > n:\n                continue\n\n            for c in a:\n                if n - k >= 0:\n                    count += count_strings(n - k, m, b, a - {c})\n                if k >= 2:\n                    count += count_strings(n - k, m, b, a - {c})\n\n        return count\n\n    result = count_strings(n, m, b, a)\n    return str(result % 998244353)"
    },
    {
        "number": 1869,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    min_ops = 0\n    \n    for i in range(1, n+1):\n        if a.count(i) > 0:\n            min_ops += a.count(i)\n            a = [x for x in a if x != i]\n    \n    return str(min_ops)"
    },
    {
        "number": 1870,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0:2])\n    times = list(map(int, stdin.split()[2:]))\n    words = []\n    last_time = 0\n\n    for time in times:\n        if time - last_time <= c:\n            words.append(time)\n        else:\n            words = [time]\n        last_time = time\n\n    return str(len(words))"
    },
    {
        "number": 1871,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0].split())\n    chapters = list(map(int, stdin.split()[1].split()))\n\n    total_time = 0\n    for i in range(n):\n        total_time += chapters[i] * x\n        x = max(1, x - 1)\n\n    return str(total_time)"
    },
    {
        "number": 1872,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    pi = 3.141592653589793\n    area = (n * r ** 2) / (4 * pi)\n    return f\"{area:.7f}\""
    },
    {
        "number": 1873,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    books = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if books[i] != books[j]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 1874,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_3, l_4, l_5 = map(int, stdin.split())\n    # Calculate the area of the triangle base\n    area_triangle = l_3 * l_3 / 2\n    # Calculate the area of the square base\n    area_square = l_4 * l_4\n    # Calculate the area of the pentagon base\n    area_pentagon = l_5 * l_5 * (3 * np.sqrt(3) - 6) / 6\n    # Calculate the volume of each pyramid\n    volume_triangle = area_triangle * l_3 / 3\n    volume_square = area_square * l_4 / 3\n    volume_pentagon = area_pentagon * l_5 / 3\n    # Calculate the total volume\n    total_volume = volume_triangle + volume_square + volume_pentagon\n    return str(total_volume)"
    },
    {
        "number": 1875,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_quadrilateral(quad):\n        return len(quad) == 4 and len(set(quad)) == 4\n\n    def area(quad):\n        return abs((points[quad[0]][0] - points[quad[2]][0]) * (points[quad[1]][1] - points[quad[0]][1]) - (points[quad[0]][0] - points[quad[1]][0]) * (points[quad[2]][1] - points[quad[0]][1])))\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    quad = (i, j, k, l)\n                    if is_quadrilateral(quad) and area(quad) > max_area:\n                        max_area = area(quad)\n\n    return f\"{max_area:.6f}\""
    },
    {
        "number": 1876,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    edges = []\n    for line in stdin.split('\\n')[2:]:\n        u, v, x = map(int, line.split())\n        edges.append((u, v, x))\n\n    def dfs(u, v, visited, path):\n        if u == v:\n            return True\n        visited.add(u)\n        for neighbor, color in graph[u]:\n            if neighbor not in visited and color == 0:\n                path.append(neighbor)\n                if dfs(neighbor, v, visited, path):\n                    return True\n                path.pop()\n        visited.remove(u)\n        return False\n\n    graph = [[] for _ in range(n)]\n    for u, v, x in edges:\n        graph[u - 1].append((v - 1, x))\n        graph[v - 1].append((u - 1, x))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                visited = set()\n                path = [i]\n                if dfs(i, j, visited, path) and dfs(j, k, visited, path) and dfs(k, i, visited, path):\n                    count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1877,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    moves = stdin.split()[1]\n    coins = 0\n    x, y = 0, 0\n    for move in moves:\n        if move == 'U':\n            y += 1\n        else:\n            x += 1\n        if x == y:\n            coins += 1\n    return str(coins)"
    },
    {
        "number": 1878,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rectangles = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    table = [[0] * 100 for _ in range(100)]\n\n    for x1, y1, x2, y2 in rectangles:\n        for i in range(y1 - 1, y2):\n            for j in range(x1 - 1, x2):\n                table[i][j] += 1\n\n    return str(sum(sum(row) for row in table))"
    },
    {
        "number": 1879,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, sx, sy, ex, ey = map(int, stdin.split()[:5])\n    directions = stdin.split()[5]\n    x, y = sx, sy\n    time = 0\n\n    for direction in directions:\n        if direction == \"E\":\n            x += 1\n        elif direction == \"S\":\n            y -= 1\n        elif direction == \"W\":\n            x -= 1\n        elif direction == \"N\":\n            y += 1\n\n        time += 1\n\n        if x == ex and y == ey:\n            return str(time)\n\n    return \"-1\"\n"
    },
    {
        "number": 1880,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    digits = [int(d) for d in str(num)]\n    shuffled_digits = [digits[0], digits[2], digits[4], digits[3], digits[1]]\n    shuffled_num = int(''.join(map(str, shuffled_digits)))\n    result = shuffled_num ** 5\n    activation_code = str(result)[-5:]\n    return activation_code"
    },
    {
        "number": 1881,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    pixels = list(map(int, stdin.split()[2:]))\n    \n    # Group colors and assign keys\n    groups = {}\n    for pixel in pixels:\n        if pixel not in groups:\n            groups[pixel] = pixel // k\n    \n    # Sort groups and assign keys\n    sorted_groups = sorted(groups.items(), key=lambda x: x[0])\n    for i in range(len(sorted_groups)):\n        sorted_groups[i] = (sorted_groups[i][0], i)\n    \n    # Replace colors with group keys\n    result = [groups[pixel] for pixel in pixels]\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 1882,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[0:2])\n    problems = []\n    for i in range(n):\n        a, t = map(int, stdin.split()[2:])\n        problems.append((a, t))\n\n    def score(problems: List[Tuple[int, int]]) -> int:\n        score = 0\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                if problems[j][1] <= problems[i][1]:\n                    score += 1\n        return score\n\n    max_score = 0\n    best_problems = []\n    for i in range(1, n + 1):\n        for subset in itertools.combinations(range(1, n + 1), i):\n            subset_problems = [problems[j - 1] for j in subset]\n            subset_score = score(subset_problems)\n            if subset_score > max_score:\n                max_score = subset_score\n                best_problems = subset\n\n    return f\"{max_score}\\n{len(best_problems)}\\n{' '.join(map(str, best_problems))}\""
    },
    {
        "number": 1883,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, types, ski_tracks = stdin.split('\\n')\n    n = int(n)\n    types = list(map(int, types.split()))\n    ski_tracks = list(map(int, ski_tracks.split()))\n\n    mountains = [i for i in range(1, n + 1) if types[i - 1] == 0]\n    hotel = [i for i in range(1, n + 1) if types[i - 1] == 1][0]\n\n    paths = []\n    for mountain in mountains:\n        path = [mountain]\n        current = mountain\n        while current != hotel:\n            next_track = ski_tracks[current - 1]\n            if next_track == 0:\n                break\n            path.append(next_track)\n            current = next_track\n        if current == hotel:\n            paths.append(path)\n\n    if not paths:\n        return \"0\\n\"\n\n    max_path = max(paths, key=len)\n    return f\"{len(max_path)}\\n{' '.join(map(str, max_path))}\\n\""
    },
    {
        "number": 1884,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, x2 = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:]))\n\n    # Check if it is possible to deploy both services using the given servers\n    if x1 > max(c) or x2 > max(c):\n        return \"No\"\n\n    # Find the number of servers used for each of the services\n    k1 = k2 = 0\n    for i in range(n):\n        if c[i] >= x1:\n            k1 += 1\n        if c[i] >= x2:\n            k2 += 1\n\n    # Check if it is possible to deploy both services using the given servers\n    if k1 == 0 or k2 == 0:\n        return \"No\"\n\n    # Find the indices of the servers used for each of the services\n    servers1 = []\n    servers2 = []\n    for i in range(n):\n        if c[i] >= x1 / k1:\n            servers1.append(i+1)\n        if c[i] >= x2 / k2:\n            servers2.append(i+1)\n\n    # Print the result\n    return \"Yes\\n{}\\n{}\\n{}\".format(k1, \" \".join(map(str, servers1)), \" \".join(map(str, servers2)))"
    },
    {
        "number": 1885,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(5, 8):\n        for j in range(i, 8):\n            for k in range(j, 8):\n                for l in range(k, 8):\n                    for m in range(l, 8):\n                        count += 1\n    return str(count)"
    },
    {
        "number": 1886,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin[0].upper() + stdin[1:]"
    },
    {
        "number": 1887,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    heights_1 = list(map(int, stdin.splitlines()[1].split()))\n    heights_2 = list(map(int, stdin.splitlines()[2].split()))\n\n    max_height = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i % 2 == 0 and j % 2 == 0:\n                max_height = max(max_height, heights_1[i] + heights_1[j])\n            elif i % 2 == 1 and j % 2 == 1:\n                max_height = max(max_height, heights_2[i] + heights_2[j])\n            elif i % 2 == 0 and j % 2 == 1:\n                max_height = max(max_height, heights_1[i] + heights_2[j])\n            else:\n                max_height = max(max_height, heights_2[i] + heights_1[j])\n\n    return str(max_height)"
    },
    {
        "number": 1888,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    debts = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split()[2:5])\n        debts.append((a, b, c))\n\n    debts.sort(key=lambda x: x[2], reverse=True)\n\n    total_debt = sum(x[2] for x in debts)\n    min_debt = total_debt\n\n    for i in range(m):\n        a, b, c = debts[i]\n        for j in range(i + 1, m):\n            d, e, f = debts[j]\n            if a == d or b == e or c == f:\n                continue\n\n            new_debt = total_debt - c - f\n            if new_debt < min_debt:\n                min_debt = new_debt\n\n    return str(min_debt)"
    },
    {
        "number": 1889,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    rounds = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split('\\n')[n+1:n+q+1]]\n    \n    def score(grid: List[List[int]]) -> int:\n        max_score = 0\n        for row in grid:\n            current_score = 0\n            for cell in row:\n                if cell == 1:\n                    current_score += 1\n                else:\n                    max_score = max(max_score, current_score)\n                    current_score = 0\n            max_score = max(max_score, current_score)\n        return max_score\n    \n    for i, j in rounds:\n        grid[i-1][j-1] ^= 1\n        print(score(grid))"
    },
    {
        "number": 1890,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = stdin.split()\n    n = len(a) * int(k)\n    mod = 1000000007\n\n    def count_ways(n: int, k: int) -> int:\n        if n == 0:\n            return 1\n        if k == 0:\n            return 0\n        if n % 5 != 0:\n            return 0\n\n        return (count_ways(n - 1, k - 1) + count_ways(n - 2, k - 1) + count_ways(n - 3, k - 1) + count_ways(n - 4, k - 1)) % mod\n\n    return str(count_ways(n, k))"
    },
    {
        "number": 1891,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split()[:4])\n    avengers = list(map(int, stdin.split()[4:]))\n\n    def power_needed(base_length: int, avenger_count: int) -> int:\n        return A * avenger_count * base_length\n\n    def destroy_base(base_length: int, avenger_count: int) -> int:\n        if avenger_count == 0:\n            return power_needed(base_length, avenger_count)\n        else:\n            return min(power_needed(base_length, avenger_count), destroy_base(base_length // 2, avenger_count // 2) + destroy_base(base_length // 2, avenger_count - avenger_count // 2))\n\n    base_length = 2 ** n\n    avenger_count = len(avengers)\n    avenger_positions = set(avengers)\n\n    for position in range(1, base_length + 1):\n        if position not in avenger_positions:\n            avenger_count += 1\n\n    return destroy_base(base_length, avenger_count)"
    },
    {
        "number": 1892,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1:]\n    simple_statements = commands.count('s')\n    for_statements = commands.count('f')\n\n    if simple_statements == 0:\n        return str((for_statements + 1) % (10**9 + 7))\n\n    if for_statements == 0:\n        return str(simple_statements % (10**9 + 7))\n\n    if simple_statements == 1:\n        return str((for_statements * 2 + 1) % (10**9 + 7))\n\n    if for_statements == 1:\n        return str((simple_statements * 2 + 1) % (10**9 + 7))\n\n    return str((simple_statements * for_statements * 2 + simple_statements + for_statements + 1) % (10**9 + 7))"
    },
    {
        "number": 1893,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    transistors = n * 2 ** (t // 24)\n    return f\"{transistors:.6f}\""
    },
    {
        "number": 1894,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    house = stdin.split('\\n')[1:]\n    seconds = 0\n    direction = 'right'\n    for i in range(n):\n        floor = house[i]\n        for j in range(m):\n            if floor[j] == '.':\n                return str(seconds)\n            elif floor[j] == '+':\n                if direction == 'right':\n                    direction = 'left'\n                else:\n                    direction = 'right'\n            elif floor[j] == '#':\n                if direction == 'right':\n                    direction = 'left'\n                else:\n                    direction = 'right'\n            seconds += 2\n    return 'Never'"
    },
    {
        "number": 1895,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    events = stdin.split()[2:]\n    happy_friends = 0\n    current_handle = \"\"\n    for event in events:\n        if event[0] == \"1\":\n            current_handle = event[2:]\n        else:\n            if current_handle == event:\n                happy_friends += 1\n    return str(happy_friends)"
    },
    {
        "number": 1896,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"1\"\n    elif n == 1:\n        return \"7\"\n    else:\n        return str((n * 6) + 1)"
    },
    {
        "number": 1897,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOUY\"\n    def simple_prettiness(s: str) -> float:\n        return sum(1 for c in s if c in vowels) / len(s)\n\n    def prettiness(s: str) -> float:\n        return sum(simple_prettiness(s[i:j+1]) for i in range(len(s)) for j in range(i, len(s)))\n\n    return f\"{prettiness(stdin):.6f}\""
    },
    {
        "number": 1898,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hate_count = 1\n    love_count = 1\n    result = \"\"\n\n    for i in range(n):\n        if i % 2 == 0:\n            result += f\"I hate that \"\n            hate_count += 1\n        else:\n            result += f\"I love that \"\n            love_count += 1\n\n    result += f\"I hate it\"\n\n    return result"
    },
    {
        "number": 1899,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m, k = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:n+4]))\n    segments = []\n    for _ in range(s):\n        l, r = map(int, stdin.split()[n+4:n+6])\n        segments.append((l, r))\n\n    def kth_order_statistic(multiset: list, k: int) -> int:\n        multiset.sort()\n        return multiset[k-1]\n\n    def covered_elements(segments: list) -> set:\n        covered = set()\n        for l, r in segments:\n            covered.update(range(l, r+1))\n        return covered\n\n    def choose_segments(segments: list, m: int, k: int) -> int:\n        for i in range(1, len(segments)+1):\n            for comb in itertools.combinations(segments, i):\n                covered = covered_elements(comb)\n                if len(covered) >= k:\n                    return kth_order_statistic(list(covered), k)\n        return -1\n\n    return str(choose_segments(segments, m, k))"
    },
    {
        "number": 1900,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    participants = list(map(int, stdin.split()[3:]))\n\n    teams_formed = 0\n    for i in range(n):\n        if i + k <= n and participants[i:i+k] == [participants[i]] * k:\n            teams_formed += 1\n\n    return str(n * m - teams_formed * k)"
    },
    {
        "number": 1901,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    c = list(map(int, stdin.split()[2:2+n]))\n    friends = []\n    for i in range(m):\n        x, y = map(int, stdin.split()[2+n+i].split())\n        friends.append((x, y))\n        friends.append((y, x))\n    \n    def dfs(node, visited, gold):\n        if node in visited:\n            return gold\n        visited.add(node)\n        for friend in friends:\n            if friend[0] == node:\n                gold = dfs(friend[1], visited, gold)\n        return gold\n    \n    min_gold = float('inf')\n    for i in range(n):\n        visited = set()\n        min_gold = min(min_gold, dfs(i, visited, c[i]))\n    \n    return str(min_gold)"
    },
    {
        "number": 1902,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    autocomplete_count = 0\n    for word in words:\n        if len(word) > 1:\n            autocomplete_count += len(word) - 1\n    return autocomplete_count + len(stdin)"
    },
    {
        "number": 1903,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    physics_cups = []\n    informatics_cups = []\n\n    for _ in range(n):\n        c, w = map(int, stdin.split()[3:5])\n        physics_cups.append((c, w))\n\n    for _ in range(m):\n        c, w = map(int, stdin.split()[5:7])\n        informatics_cups.append((c, w))\n\n    physics_cups.sort(key=lambda x: x[0], reverse=True)\n    informatics_cups.sort(key=lambda x: x[0], reverse=True)\n\n    physics_exposed = []\n    informatics_exposed = []\n    total_significance = 0\n\n    for cup in physics_cups:\n        if cup[1] <= d:\n            physics_exposed.append(cup)\n            total_significance += cup[0]\n            d -= cup[1]\n\n    for cup in informatics_cups:\n        if cup[1] <= d:\n            informatics_exposed.append(cup)\n            total_significance += cup[0]\n            d -= cup[1]\n\n    if not physics_exposed or not informatics_exposed:\n        return \"0\"\n\n    return str(total_significance)\n"
    },
    {
        "number": 1904,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, a = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    s = list(s)\n\n    def is_hard(subseq: str) -> bool:\n        return 'hard' in subseq\n\n    def find_hard_subseq(s: str) -> str:\n        for i in range(len(s) - 2):\n            if is_hard(s[i:i+3]):\n                return s[i:i+3]\n        return ''\n\n    def min_ambiguity(s: str, a: list) -> int:\n        min_amb = 0\n        for i in range(len(s)):\n            min_amb += a[i]\n            if is_hard(s[:i+1]):\n                return min_amb\n        return min_amb\n\n    hard_subseq = find_hard_subseq(s)\n    if hard_subseq:\n        s.remove(hard_subseq[1])\n        a.remove(a[s.index(hard_subseq[1])])\n    return str(min_ambiguity(s, a))"
    },
    {
        "number": 1905,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    matrix = [[0] * m for _ in range(n)]\n    operations = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    for operation in operations:\n        if operation[0] == 1:\n            row = operation[1] - 1\n            matrix[row] = matrix[row][-1:] + matrix[row][:-1]\n        elif operation[0] == 2:\n            col = operation[1] - 1\n            col_values = [matrix[i][col] for i in range(n)]\n            col_values = col_values[-1:] + col_values[:-1]\n            for i in range(n):\n                matrix[i][col] = col_values[i]\n        else:\n            row, col, value = operation[1] - 1, operation[2] - 1, operation[3]\n            matrix[row][col] = value\n\n    return '\\n'.join([' '.join(map(str, row)) for row in matrix])"
    },
    {
        "number": 1906,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if not any(i % j == 0 for j in range(2, 11)):\n            count += 1\n    return str(count)"
    },
    {
        "number": 1907,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dancers = []\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().strip().split())\n        dancers.append((x, y, r))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(p, c, r):\n        return distance(p, c) <= r\n\n    def is_intersect(c1, r1, c2, r2):\n        return distance(c1, c2) <= r1 + r2\n\n    def area(c1, r1, c2, r2):\n        if is_intersect(c1, r1, c2, r2):\n            return 0\n        return math.pi * (r1 ** 2 + r2 ** 2 - distance(c1, c2) ** 2) / 2\n\n    def spaciousness(c1, r1, c2, r2):\n        if is_inside(c1, c2, r2):\n            return area(c1, r1, c2, r2)\n        if is_inside(c2, c1, r1):\n            return area(c2, r2, c1, r1)\n        return area(c1, r1, c1, r1) + area(c2, r2, c2, r2)\n\n    def max_spaciousness(dancers):\n        n = len(dancers)\n        max_spaciousness = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                max_spaciousness += spaciousness(dancers[i], dancers[i + 1], dancers[j], dancers[j + 1])\n        return max_spaciousness\n\n    return str(max_spaciousness(dancers))"
    },
    {
        "number": 1908,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    w = list(map(int, stdin.split()[2:2+n]))\n    xy = []\n    for i in range(m):\n        xy.append(list(map(int, stdin.split()[2+n+i*2:2+n+i*2+2])))\n\n    def can_survive(order: list) -> bool:\n        food_left = [w[i] for i in range(n)]\n        for friend in order:\n            for food in xy[friend-1]:\n                if food_left[food-1] > 0:\n                    food_left[food-1] -= 1\n        return all(food == 0 for food in food_left)\n\n    for order in itertools.permutations(range(1, m+1)):\n        if can_survive(order):\n            return \"ALIVE\\n\" + \" \".join(map(str, order))\n    return \"DEAD\""
    },
    {
        "number": 1909,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    powers = list(map(int, stdin.split()[2:]))\n\n    min_power = float('inf')\n    min_task = 1\n\n    for i in range(n):\n        power = sum(powers[i::n])\n        if power < min_power:\n            min_power = power\n            min_task = i + 1\n\n    return str(min_task)"
    },
    {
        "number": 1910,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    A = B = M = Z = 0\n    result = 0\n\n    for i in range(2 * n - 2):\n        if i % 4 == 0:\n            A += 1\n        elif i % 4 == 1:\n            B += 1\n        elif i % 4 == 2:\n            M += 1\n        else:\n            Z += 1\n\n        if A == n and B == n and M == n and Z == n:\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 1911,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    min_cost = float('inf')\n    for i in range(1, n - k + 2):\n        subarrays = [a[j:j+k] for j in range(i, n, k)]\n        max_diff = max(max(subarray) - min(subarray) for subarray in subarrays)\n        min_cost = min(min_cost, max_diff)\n\n    return str(min_cost)"
    },
    {
        "number": 1912,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    for _ in range(T):\n        r, g, b, w = map(int, stdin.readline().strip().split())\n        if r == 0 and g == 0 and b == 0 and w == 0:\n            print(\"Yes\")\n        elif r == 0 or g == 0 or b == 0 or w == 0:\n            print(\"No\")\n        else:\n            print(\"Yes\")"
    },
    {
        "number": 1913,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *tanks = map(int, stdin.split())\n    product = 1\n    for tank in tanks:\n        product *= tank\n    return str(product)"
    },
    {
        "number": 1914,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.split('\\n')[0]\n    n = int(stdin.split('\\n')[1])\n    s = stdin.split('\\n')[2:]\n\n    def f(t: str, s: str) -> int:\n        return t.count(s)\n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result += f(t, s[i] + s[j])\n\n    return str(result)"
    },
    {
        "number": 1915,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    table = [[0 for _ in range(n)] for _ in range(n)]\n    table[0] = [1] * n\n    for i in range(1, n):\n        table[i][0] = table[i - 1][0] + 1\n        for j in range(1, n):\n            table[i][j] = table[i - 1][j] + table[i][j - 1]\n    return str(max(table[-1]))"
    },
    {
        "number": 1916,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    \n    c = [a[i] & b[j] for i in range(n) for j in range(m)]\n    return str(max(c))"
    },
    {
        "number": 1917,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def f(b):\n        return sum(b[i] * (a[i] - b[i] ** 2) for i in range(n))\n\n    def is_valid(b):\n        return all(0 <= b[i] <= a[i] for i in range(n)) and sum(b) == k\n\n    best_f = float('-inf')\n    best_b = None\n\n    for b in itertools.product(*[range(a[i] + 1) for i in range(n)]):\n        if is_valid(b):\n            current_f = f(b)\n            if current_f > best_f:\n                best_f = current_f\n                best_b = b\n\n    return ' '.join(map(str, best_b))"
    },
    {
        "number": 1918,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, initial_assignment = stdin.split('\\n')\n    n = int(n)\n    p = list(map(int, p.split()))\n    initial_assignment = list(initial_assignment)\n\n    alice_team = [p[i] for i in range(n) if initial_assignment[i] == 'A']\n    bob_team = [p[i] for i in range(n) if initial_assignment[i] == 'B']\n\n    bob_team_strength = sum(bob_team)\n    alice_team_strength = sum(alice_team)\n\n    if bob_team_strength >= alice_team_strength:\n        return str(bob_team_strength)\n    else:\n        return str(alice_team_strength)"
    },
    {
        "number": 1919,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \"1\"\n    else:\n        return \"2\""
    },
    {
        "number": 1920,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    friends = []\n    for i in range(n):\n        gender, a, b = stdin.readline().strip().split()\n        friends.append((gender, int(a), int(b)))\n\n    max_friends = 0\n    for i in range(1, 366):\n        male_count = 0\n        female_count = 0\n        for gender, a, b in friends:\n            if a <= i <= b:\n                if gender == 'M':\n                    male_count += 1\n                else:\n                    female_count += 1\n        if male_count == female_count:\n            max_friends = max(max_friends, male_count + female_count)\n\n    return str(max_friends)"
    },
    {
        "number": 1921,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    sx, sy, fx, fy = map(int, stdin.split()[2:])\n    locations = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, time = queue.pop(0)\n            if current == end:\n                return time\n            if current in visited:\n                continue\n            visited.add(current)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = current[0] + dx, current[1] + dy\n                if 1 <= new_x <= n and 1 <= new_y <= n:\n                    queue.append(((new_x, new_y), time + 1))\n        return -1\n\n    time = bfs((sx, sy), (fx, fy))\n    if time == -1:\n        return \"IMPOSSIBLE\"\n\n    for location in locations:\n        if location[0] == sx or location[1] == sy:\n            time = min(time, bfs((sx, sy), location))\n\n    return time"
    },
    {
        "number": 1922,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    total_cards = N * M\n    flipped_cards = 0\n\n    for i in range(N):\n        for j in range(M):\n            flipped_cards += 1\n            for x in range(max(0, i - 1), min(i + 2, N)):\n                for y in range(max(0, j - 1), min(j + 2, M)):\n                    if x != i or y != j:\n                        flipped_cards -= 1\n\n    return str(total_cards - flipped_cards)"
    },
    {
        "number": 1923,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, skewers = stdin.split(\"\\n\")\n    N = int(N)\n    skewers = [int(x) for x in skewers.split()]\n\n    skewers.sort()\n    max_ingredients = 0\n\n    for i in range(N):\n        max_ingredients += skewers[2 * i]\n\n    return str(max_ingredients)"
    },
    {
        "number": 1924,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (c_2 + 1) for _ in range(r_2 + 1)]\n    dp[1][1] = 1\n\n    for i in range(1, r_2 + 1):\n        for j in range(1, c_2 + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n\n    result = 0\n    for i in range(r_1, r_2 + 1):\n        for j in range(c_1, c_2 + 1):\n            result += dp[i][j]\n            result %= MOD\n\n    return str(result)"
    },
    {
        "number": 1925,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, N = map(int, stdin.split())\n    x = N\n    while True:\n        if (A * x // B) - (A * (x // B)) >= (A * (x // B)) - (A * (x - 1) // B):\n            return str(A * (x // B) - (A * (x // B)))\n        x -= 1"
    },
    {
        "number": 1926,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = []\n    \n    for k in range(1, n):\n        heap = [i for i in range(1, n+1)]\n        heapify(heap, k)\n        violations = 0\n        \n        for i in range(1, n):\n            if a[i] < a[heap[i]]:\n                violations += 1\n        \n        count.append(violations)\n    \n    return \" \".join(map(str, count))\n\ndef"
    },
    {
        "number": 1927,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a_list = list(map(int, stdin.split()[2:]))\n    p = list(range(1, n+1))\n    positions = []\n\n    for a in a_list:\n        if p.index(a) != 0:\n            p.insert(0, p.pop(p.index(a)))\n        positions.append(p.copy())\n\n    result = []\n    for i in range(1, n+1):\n        min_pos = n\n        max_pos = 1\n        for j in range(m):\n            if i in positions[j]:\n                min_pos = min(min_pos, positions[j].index(i)+1)\n                max_pos = max(max_pos, positions[j].index(i)+1)\n        result.append((min_pos, max_pos))\n\n    return \" \".join([f\"{min_pos} {max_pos}\" for min_pos, max_pos in result])"
    },
    {
        "number": 1928,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    paths = []\n    penalty = 0\n\n    for i in range(k):\n        path = []\n        for j in range(i + 1):\n            if j == 0:\n                matrix[0][0] = 1\n                path.append((1, 1))\n            else:\n                for x in range(n):\n                    for y in range(m):\n                        if matrix[x][y] == 0:\n                            matrix[x][y] = 1\n                            path.append((x + 1, y + 1))\n                            break\n        paths.append(path)\n        penalty += len(path)\n\n    return str(penalty) + \"\\n\" + \"\\n\".join([\" \".join(map(str, path)) for path in paths])\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 1929,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = map(int, stdin.split()[:3])\n    crimes = list(map(int, stdin.split()[3:]))\n    \n    def is_valid(start: int, end: int) -> bool:\n        return all(crimes[i] <= t for i in range(start, end + 1))\n    \n    def count_ways(start: int, end: int) -> int:\n        if not is_valid(start, end):\n            return 0\n        if end - start + 1 == c:\n            return 1\n        return count_ways(start + 1, end) + count_ways(start, end - 1)\n    \n    return str(count_ways(0, n - 1))"
    },
    {
        "number": 1930,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    def count_inversions(arr):\n        inv_count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    inv_count += 1\n        return inv_count\n\n    def find_valid_permutation(p):\n        valid_permutations = []\n        for i in range(len(p)):\n            if p[i] == -1:\n                for j in range(1, n + 1):\n                    if j not in p:\n                        p[i] = j\n                        valid_permutations.append(p.copy())\n                        p[i] = -1\n            elif p[i] != -1:\n                continue\n        return valid_permutations\n\n    valid_permutations = find_valid_permutation(p)\n    total_inversions = 0\n    for permutation in valid_permutations:\n        total_inversions += count_inversions(permutation)\n\n    expected_inversions = total_inversions / len(valid_permutations)\n    P = int(expected_inversions)\n    Q = 1\n    result = P * Q ** -1\n    return str(result % 998244353)"
    },
    {
        "number": 1931,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_pyramid(n: int) -> int:\n        if n == 1:\n            return 1\n        elif n % 2 == 0:\n            return build_pyramid(n // 2) + build_pyramid(n // 2)\n        else:\n            return build_pyramid(n // 2) + build_pyramid(n // 2 + 1)\n\n    t = int(stdin.strip().split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.strip().split('\\n')[i])\n        result.append(build_pyramid(n))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1932,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    faces = {\n        \"Tetrahedron\": 4,\n        \"Cube\": 6,\n        \"Octahedron\": 8,\n        \"Dodecahedron\": 12,\n        \"Icosahedron\": 20\n    }\n\n    total_faces = 0\n    for polyhedron in stdin.split(\"\\n\")[1:]:\n        total_faces += faces[polyhedron]\n\n    return str(total_faces)"
    },
    {
        "number": 1933,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    def score(a):\n        s = 0\n        for j in range(1, m + 1):\n            i = next((i for i in range(1, n + 1) if a[i - 1][j - 1] == 1), None)\n            if i is not None:\n                count = sum(a[i - 1][j - 1:j - 1 + min(k, n - i + 1)])\n                s += count\n        return s\n\n    def replace(a):\n        min_ones = min(sum(row) for row in a)\n        return min_ones, sum(row.count(0) for row in a) - min_ones\n\n    max_score = score(a)\n    min_replacements = replace(a)[1]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                a[i][j] = 0\n                new_score = score(a)\n                if new_score > max_score:\n                    max_score = new_score\n                    min_replacements = replace(a)[1]\n                a[i][j] = 1\n\n    return f\"{max_score} {min_replacements}\""
    },
    {
        "number": 1934,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    sequence = list(map(int, stdin.split()[2:]))\n    queries = []\n    for i in range(m):\n        l, r = map(int, stdin.split()[2:])\n        queries.append((l, r))\n\n    def min_distance(sequence, l, r):\n        min_dist = float('inf')\n        for i in range(l, r + 1):\n            for j in range(i + 1, r + 1):\n                if sequence[i] == sequence[j]:\n                    min_dist = min(min_dist, abs(i - j))\n        return min_dist\n\n    result = []\n    for l, r in queries:\n        result.append(min_distance(sequence, l, r))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1935,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, g, r = map(int, stdin.split())\n    d = list(map(int, d.split()))\n    d.sort()\n\n    def is_safe(x: int) -> bool:\n        return x in d\n\n    def time_to_cross(start: int, end: int) -> int:\n        time = 0\n        while start < end:\n            if is_safe(start):\n                time += g\n            else:\n                time += r\n            start += 1\n        return time\n\n    min_time = float('inf')\n    for i in range(len(d) - 1):\n        if d[i] == 0:\n            min_time = min(min_time, time_to_cross(d[i], d[i + 1]))\n        elif d[i] == n:\n            min_time = min(min_time, time_to_cross(d[i], d[i + 1]))\n        else:\n            min_time = min(min_time, time_to_cross(d[i], d[i + 1]) + time_to_cross(d[i + 1], d[i]))\n\n    return str(min_time) if min_time != float('inf') else \"-1\""
    },
    {
        "number": 1936,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_pair(l, r):\n        for x in range(l, r):\n            for y in range(x + 1, r + 1):\n                if lcm(x, y) >= l and lcm(x, y) <= r:\n                    return x, y\n        return -1, -1\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        l, r = map(int, stdin.readline().split())\n        x, y = find_pair(l, r)\n        print(x, y)"
    },
    {
        "number": 1937,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n\n    a = [0] * n\n    for i in range(n):\n        a[i] = b[i] - b[n - i - 1]\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1938,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    segments = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def f(l, r):\n        return r - l + 1\n    \n    def intersection(seg1, seg2):\n        l1, r1 = seg1\n        l2, r2 = seg2\n        return max(l1, l2), min(r1, r2)\n    \n    def count_points(segments):\n        if len(segments) == 1:\n            return f(*segments[0])\n        else:\n            mid = len(segments) // 2\n            left = count_points(segments[:mid])\n            right = count_points(segments[mid:])\n            return left + right - intersection_count(segments[:mid], segments[mid:])\n    \n    def intersection_count(segments1, segments2):\n        count = 0\n        for seg1 in segments1:\n            for seg2 in segments2:\n                l, r = intersection(seg1, seg2)\n                if l <= r:\n                    count += f(l, r)\n        return count\n    \n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                result += intersection_count([segments[i], segments[j], segments[k]], segments[k+1:])\n                result %= 1000000007\n    \n    return str(result)"
    },
    {
        "number": 1939,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        row = [0] * n\n        for j in range(n):\n            row[j] = (i + j + 1) % k\n        table.append(row)\n    return '\\n'.join([' '.join(map(str, row)) for row in table])"
    },
    {
        "number": 1940,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    w = list(map(int, stdin.split()[2:]))\n\n    # Calculate the maximum number of pebbles of each type that can be collected in a single day\n    max_pebbles_per_day = [k // n] * n\n    for i in range(k % n):\n        max_pebbles_per_day[i] += 1\n\n    # Calculate the minimum number of days needed to collect all the pebbles\n    min_days = sum([w[i] // max_pebbles_per_day[i] + 1 for i in range(n)])\n\n    return str(min_days)"
    },
    {
        "number": 1941,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        l, t, m = map(int, input().split())\n        queries.append((l, t, m))\n\n    def karafs_height(i: int) -> int:\n        return A + (i - 1) * B\n\n    def can_eat(l: int, r: int, m: int) -> bool:\n        eaten = 0\n        for i in range(l, r + 1):\n            if karafs_height(i) <= m:\n                eaten += 1\n            if eaten > m:\n                return False\n        return True\n\n    for l, t, m in queries:\n        r = l\n        while r <= t:\n            if can_eat(l, r, m):\n                print(r)\n                break\n            r += 1\n        else:\n            print(-1)"
    },
    {
        "number": 1942,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        n, l, r = map(int, stdin.readline().split())\n        # Create a complete directed graph K_n\n        graph = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i][j] = 1\n                    graph[j][i] = 1\n        # Find the lexicographically smallest cycle\n        cycle = []\n        visited = [False] * n\n        current = 0\n        while not all(visited):\n            cycle.append(current)\n            visited[current] = True\n            neighbors = [i for i in range(n) if graph[current][i] == 1 and not visited[i]]\n            if len(neighbors) == 0:\n                break\n            current = neighbors[0]\n        # Find the segment of the cycle to print\n        cycle_segment = cycle[l - 1:] + cycle[:l - 1]\n        print(*cycle_segment)\n    return \"\""
    },
    {
        "number": 1943,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def calculate_expected_score(bracket: list) -> float:\n        def calculate_probability(team1: int, team2: int) -> float:\n            return float(matrix[team1 - 1][team2 - 1]) / 100\n\n        def calculate_game_probability(team1: int, team2: int) -> float:\n            return calculate_probability(team1, team2) * calculate_probability(team2, team1)\n\n        def calculate_round_probability(teams: list) -> float:\n            probability = 1\n            for i in range(len(teams) // 2):\n                probability *= calculate_game_probability(teams[i * 2], teams[i * 2 + 1])\n            return probability\n\n        def calculate_bracket_probability(bracket: list) -> float:\n            probability = 1\n            for i in range(N):\n                probability *= calculate_round_probability(bracket[i])\n            return probability\n\n        def calculate_score(bracket: list) -> float:\n            score = 0\n            for i in range(N):\n                for j in range(len(bracket[i]) // 2):\n                    if bracket[i][j * 2] > bracket[i][j * 2 + 1]:\n                        score += 2 ** (N - i - 1)\n            return score\n\n        return calculate_probability(1, 2) * calculate_bracket_probability(bracket) * calculate_score(bracket)\n\n    def generate_brackets(N: int) -> list:\n        def generate_bracket(N: int, depth: int) -> list:\n            if depth == 0:\n                return [1]\n            bracket = []\n            for i in range(2 ** (N - depth)):\n                left = generate_bracket(N, depth - 1)\n                right = generate_bracket(N, depth - 1)\n                bracket.append(left + right)\n            return bracket\n\n        return generate_bracket(N, N)\n\n    def find_max_expected_score(brackets: list) -> float:\n        max_score = 0\n        for bracket in brackets:\n            score = calculate_expected_score(bracket)\n            if score > max_score:\n                max_score = score\n        return max_score\n\n    N = int(stdin.readline().strip())\n    matrix = [list(map(int, stdin.readline().strip().split())) for _ in range(2 ** N)]\n\n    brackets = generate_brackets(N)\n    max_score = find_max_expected_score(brackets)\n\n    return str(max_score)"
    },
    {
        "number": 1944,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    laptops = []\n    for i in range(1, n+1):\n        a, b = map(int, stdin.splitlines()[i].split())\n        laptops.append((a, b))\n    \n    laptops.sort(key=lambda x: x[0])\n    \n    for i in range(n-1):\n        if laptops[i][1] > laptops[i+1][1]:\n            return \"Happy Alex\"\n    \n    return \"Poor Alex\""
    },
    {
        "number": 1945,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    requests = stdin.split('\\n')\n    q = int(requests[0])\n    handles = {}\n    for i in range(1, q+1):\n        old, new = requests[i].split()\n        handles[old] = new\n    n = len(handles)\n    result = \"\"\n    for old, new in handles.items():\n        result += f\"{old} {new}\\n\"\n    return f\"{n}\\n{result}\""
    },
    {
        "number": 1946,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a_x = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    b_y = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:n+m+1]]\n\n    a_x.sort(key=lambda x: x[1], reverse=True)\n    b_y.sort(key=lambda x: x[1], reverse=True)\n\n    total_income = 0\n    for i in range(min(n, m)):\n        total_income += a_x[i][1] + b_y[i][1]\n\n    return str(total_income)"
    },
    {
        "number": 1947,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, l = map(int, stdin.split()[:3])\n    hairlines = list(map(int, stdin.split()[3:]))\n    hairdresser_time = 0\n    for i in range(m):\n        t, p, d = map(int, stdin.split()[3:])\n        if t == 0:\n            hairdresser_time = 0\n            for j in range(n):\n                if hairlines[j] > l:\n                    hairdresser_time += 1\n            print(hairdresser_time)\n        else:\n            hairlines[p-1] += d\n    return \"\"\n\ninput_str = input()\nsolution(input_str) "
    },
    {
        "number": 1948,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, node)\n        if len(visited) == n:\n            return parent\n        return None\n\n    alice_parent = dfs(1, set(), None)\n    bob_parent = dfs(x, set(), None)\n\n    alice_moves = 0\n    bob_moves = 0\n\n    while alice_parent != bob_parent:\n        alice_moves += 1\n        alice_parent = graph[alice_parent][0]\n\n    while bob_parent != alice_parent:\n        bob_moves += 1\n        bob_parent = graph[bob_parent][0]\n\n    return str(alice_moves + bob_moves)"
    },
    {
        "number": 1949,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    for i in range(k):\n        min_non_zero = min(filter(lambda x: x != 0, a))\n        if min_non_zero == 0:\n            print(0)\n            break\n        print(min_non_zero)\n        a = [x - min_non_zero if x != 0 else x for x in a]\n    return \"\""
    },
    {
        "number": 1950,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = map(int, stdin.split())\n    balls = [balls[i:i+n] for i in range(0, len(balls), n)]\n    min_penalty = float('inf')\n\n    for k in [2, 3]:\n        penalty = 0\n        for i in range(n):\n            penalty += balls[i][i]\n            balls[i] = balls[i][:i] + balls[i][i+1:]\n\n        for i in range(n):\n            penalty += sum(balls[i])\n\n        min_penalty = min(min_penalty, penalty)\n\n    return str(min_penalty)"
    },
    {
        "number": 1951,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    events = stdin.split('\\n')[1:]\n    prices = []\n    for event in events:\n        if event[0] == '+':\n            prices.append(len(prices) + 1)\n        else:\n            price = int(event.split()[1])\n            if price not in prices:\n                return \"NO\"\n            prices.remove(price)\n    if not prices:\n        return \"YES\\n\" + \" \".join(map(str, range(1, n + 1)))\n    else:\n        return \"NO\""
    },
    {
        "number": 1952,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    m = list(map(int, stdin.split()[2:n+2]))\n    c = list(map(int, stdin.split()[n+2:]))\n\n    testcases = []\n    for i in range(n):\n        testcases.append([m[i]])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if m[i] == m[j]:\n                testcases[i].append(m[j])\n                testcases[j].append(m[i])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if m[i] > m[j]:\n                testcases[i].append(m[j])\n                testcases[j].append(m[i])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if m[i] < m[j]:\n                testcases[i].append(m[j])\n                testcases[j].append(m[i])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if m[i] != m[j]:\n                testcases[i].append(m[j])\n                testcases[j].append(m[i])\n\n    testcases.sort(key=lambda x: len(x), reverse=True)\n\n    result = []\n    for i in range(len(testcases)):\n        if len(testcases[i]) <= k:\n            result.append(testcases[i])\n\n    return result\n\n\ndef"
    },
    {
        "number": 1953,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, times = map(int, stdin.split())\n    times.sort(reverse=True)\n    not_disappointed = 0\n    for time in times:\n        if time <= len(times):\n            not_disappointed += 1\n            times.remove(time)\n    return str(not_disappointed)"
    },
    {
        "number": 1954,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, q+1):\n        n, f = map(int, stdin.split('\\n')[i].split())\n        count = 0\n        for j in range(1, n+1):\n            if n % j == 0:\n                count += 1\n        result.append(count)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1955,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    d = list(map(int, stdin.split()[2:2+n]))\n    a = list(map(int, stdin.split()[2+n:]))\n    \n    # Initialize the graph\n    graph = [[0 for _ in range(m)] for _ in range(m)]\n    for i in range(m):\n        for j in range(m):\n            if i != j:\n                graph[i][j] = float('inf')\n    \n    # Calculate the shortest path between subjects\n    for i in range(m):\n        for j in range(m):\n            if i != j:\n                for k in range(n):\n                    if d[k] == i+1:\n                        graph[i][j] = min(graph[i][j], k+1)\n                        break\n                    elif d[k] == j+1:\n                        graph[i][j] = min(graph[i][j], k+1)\n                        break\n    \n    # Calculate the longest path between subjects\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                graph[i][j] = max(graph[i][j], graph[i][k] + graph[k][j])\n    \n    # Check if it is possible to pass all exams\n    for i in range(m):\n        if graph[i][i] == float('inf'):\n            return '-1'\n    \n    # Calculate the minimum number of days\n    min_days = 0\n    for i in range(m):\n        min_days += graph[i][i] + a[i]\n    \n    return str(min_days)"
    },
    {
        "number": 1956,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    rounds = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def can_win(s_i, e_i):\n        return s_i * 2 > e_i\n\n    def can_lose(s_i, e_i):\n        return s_i + 1 > e_i\n\n    can_win_count = 0\n    can_lose_count = 0\n\n    for s_i, e_i in rounds:\n        if can_win(s_i, e_i):\n            can_win_count += 1\n        if can_lose(s_i, e_i):\n            can_lose_count += 1\n\n    return f\"{int(can_win_count % 2 == 1)} {int(can_lose_count % 2 == 1)}\""
    },
    {
        "number": 1957,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split()[:3])\n    sizes = list(map(int, stdin.split()[3:]))\n\n    total_size = sum(sizes)\n    blocked_holes = 0\n\n    for size in sizes:\n        if size == total_size:\n            return str(blocked_holes)\n        if size > total_size - B:\n            return str(blocked_holes)\n        blocked_holes += 1\n\n    return str(blocked_holes)"
    },
    {
        "number": 1958,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    apples = 1\n    total_money = 0\n\n    for i in range(n):\n        if stdin.split('\\n')[i] == \"half\":\n            apples += 1\n            total_money += p * apples // 2\n        else:\n            apples += 2\n            total_money += p * apples // 2\n\n    return str(total_money)"
    },
    {
        "number": 1959,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    eugeny_cards = list(map(int, stdin.split()[2:]))\n\n    # Check if there is a solution\n    even_count = 0\n    odd_count = 0\n    for card in eugeny_cards:\n        if card % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    if even_count != odd_count:\n        return \"-1\"\n\n    # Create a list of cards for Nikolay\n    nikolay_cards = list(range(1, m + 1))\n\n    # Find the minimum number of exchanges\n    exchanges = 0\n    for i in range(n):\n        if eugeny_cards[i] != nikolay_cards[i]:\n            exchanges += 1\n\n    # Create the output list\n    output_list = []\n    for i in range(n):\n        if eugeny_cards[i] != nikolay_cards[i]:\n            output_list.append(nikolay_cards[i])\n        else:\n            output_list.append(eugeny_cards[i])\n\n    return str(exchanges) + \"\\n\" + \" \".join(map(str, output_list))"
    },
    {
        "number": 1960,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Initialize the groups\n    group1 = set()\n    group2 = set()\n    group3 = set()\n\n    # Initialize the longest increasing subsequence\n    lis = [a[0]]\n\n    # Iterate through the sequence\n    for i in range(1, n):\n        # If the current element is greater than the last element of the longest increasing subsequence\n        if a[i] > lis[-1]:\n            # Extend the longest increasing subsequence\n            lis.append(a[i])\n        else:\n            # Find the index of the smallest element in the longest increasing subsequence that is greater than or equal to the current element\n            index = bisect_left(lis, a[i])\n\n            # If the current element belongs to no longest increasing subsequences\n            if index == 0:\n                group1.add(i)\n            # If the current element belongs to at least one but not every longest increasing subsequence\n            elif index == len(lis):\n                group2.add(i)\n            # If the current element belongs to every longest increasing subsequence\n            else:\n                group3.add(i)\n\n            # Replace the smallest element in the longest increasing subsequence with the current element\n            lis[index] = a[i]\n\n    # Create the output string\n    output = \"\"\n    for i in range(n):\n        if i in group1:\n            output += \"1\"\n        elif i in group2:\n            output += \"2\"\n        else:\n            output += \"3\"\n\n    return output"
    },
    {
        "number": 1961,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def can_paint(x: int, y: int) -> bool:\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if 0 <= i < n and 0 <= j < m and grid[i][j] == '#':\n                    return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if can_paint(i, j):\n                    return \"YES\"\n                elif can_paint(i + 1, j) and can_paint(i, j + 1) and can_paint(i + 1, j + 1):\n                    return \"YES\"\n                elif can_paint(i, j + 1) and can_paint(i + 1, j) and can_paint(i + 1, j + 1):\n                    return \"YES\"\n                elif can_paint(i + 1, j) and can_paint(i, j - 1) and can_paint(i + 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i, j - 1) and can_paint(i + 1, j) and can_paint(i + 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i, j - 1) and can_paint(i - 1, j) and can_paint(i - 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i - 1, j) and can_paint(i, j + 1) and can_paint(i - 1, j + 1):\n                    return \"YES\"\n                elif can_paint(i - 1, j) and can_paint(i, j - 1) and can_paint(i - 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i - 1, j) and can_paint(i + 1, j) and can_paint(i + 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i + 1, j) and can_paint(i, j - 1) and can_paint(i + 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i - 1, j) and can_paint(i, j + 1) and can_paint(i - 1, j + 1):\n                    return \"YES\"\n                elif can_paint(i, j - 1) and can_paint(i - 1, j) and can_paint(i - 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i, j + 1) and can_paint(i - 1, j) and can_paint(i - 1, j + 1):\n                    return \"YES\"\n                elif can_paint(i, j - 1) and can_paint(i + 1, j) and can_paint(i + 1, j - 1):\n                    return \"YES\"\n                elif can_paint(i, j + 1) and can_paint(i + 1, j) and can_paint(i + 1, j + 1):\n                    return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1962,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l, staves = map(int, stdin.split())\n    staves = list(map(int, staves.split()))\n\n    staves.sort()\n    min_stave_length = staves[0]\n    max_stave_length = staves[-1]\n\n    if l >= max_stave_length:\n        return str(n * max_stave_length)\n\n    if l >= min_stave_length:\n        return str(0)\n\n    max_volumes = []\n    for i in range(n):\n        max_volumes.append(max_stave_length * k)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max_volumes[i] - max_volumes[j] > l:\n                return str(0)\n\n    return str(sum(max_volumes))\n"
    },
    {
        "number": 1963,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_l = 0\n    max_r = 0\n    max_diff = 0\n    result = []\n\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            j = l\n            while j <= r:\n                if all(a[l] % a[i] == 0 for i in range(l, r + 1)):\n                    if r - l > max_diff:\n                        max_diff = r - l\n                        max_l = l\n                        max_r = r\n                        result = [l]\n                    elif r - l == max_diff:\n                        result.append(l)\n                    break\n                j += 1\n\n    return f\"{len(result)} {max_diff}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 1964,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cashiers = [int(x) for x in stdin.split('\\n')[1].split()]\n    queues = []\n    for i in range(n):\n        queues.append([int(x) for x in stdin.split('\\n')[2+i].split()])\n\n    total_time = 0\n    for i in range(n):\n        total_time += cashiers[i] * 5\n        for j in range(cashiers[i]):\n            total_time += queues[i][j] * 5\n            total_time += 15\n\n    return str(total_time)"
    },
    {
        "number": 1965,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def infect_accounts(n: int, x: int, ratings: List[int]) -> int:\n        infected = [False] * n\n        infected[0] = True\n        contests = 0\n\n        while not all(infected):\n            contests += 1\n            for i in range(1, n):\n                if not infected[i] and ratings[i] == x:\n                    infected[i] = True\n\n        return contests\n\n    def read_input(stdin: str) -> List[Tuple[int, int, List[int]]]:\n        test_cases = []\n        lines = stdin.split(\"\\n\")\n        t = int(lines[0])\n\n        for i in range(1, t * 2 + 1, 2):\n            n, x = map(int, lines[i].split())\n            ratings = list(map(int, lines[i + 1].split()))\n            test_cases.append((n, x, ratings))\n\n        return test_cases\n\n    test_cases = read_input(stdin)\n    result = []\n\n    for n, x, ratings in test_cases:\n        result.append(str(infect_accounts(n, x, ratings)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1966,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pieces = [[] for _ in range(4)]\n    for i, piece in enumerate(stdin.split('\\n\\n')):\n        for row in piece.split('\\n'):\n            pieces[i].append(list(map(int, row)))\n    \n    def is_valid(board: List[List[int]]) -> bool:\n        for i in range(2 * n):\n            for j in range(2 * n):\n                if board[i][j] == 1:\n                    if i > 0 and board[i - 1][j] == 1:\n                        return False\n                    if j > 0 and board[i][j - 1] == 1:\n                        return False\n        return True\n    \n    def merge_pieces(pieces: List[List[List[int]]) -> List[List[int]]:\n        board = [[0] * (2 * n) for _ in range(2 * n)]\n        for i, piece in enumerate(pieces):\n            for row in range(n):\n                for col in range(n):\n                    board[i * n + row][col * n + col] = piece[row][col]\n        return board\n    \n    def count_changes(board: List[List[int]]) -> int:\n        changes = 0\n        for i in range(2 * n):\n            for j in range(2 * n):\n                if board[i][j] == 0:\n                    changes += 1\n        return changes\n    \n    valid_boards = []\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                if i != j and i != k and j != k:\n                    board = merge_pieces([pieces[i], pieces[j], pieces[k]])\n                    if is_valid(board):\n                        valid_boards.append(board)\n    \n    min_changes = float('inf')\n    for board in valid_boards:\n        changes = count_changes(board)\n        if changes < min_changes:\n            min_changes = changes\n    \n    return str(min_changes)"
    },
    {
        "number": 1967,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    image = stdin.split('\\n')[1:]\n    rotated_image = [''.join([row[i] for row in image]) for i in range(w-1, -1, -1)]\n    flipped_image = [''.join([row[::-1] for row in rotated_image])]\n    zoomed_image = [''.join([char*2 for char in row]) for row in flipped_image]\n    return '\\n'.join([''.join(zoomed_image[i:i+2]) for i in range(0, len(zoomed_image), 2)])\n\ninput_str = \"3 2\\n.*.\\n.*.\"\nprint(solution(input_str))\n\ninput_str = \"9 20\\n**.......\\n****.....\\n******...\\n*******..\\n..******.\\n....****.\\n......***\\n*.....***\\n*********\\n*********\\n*********\\n*********\\n....**...\\n...****..\\n..******.\\n.********\\n****..***\\n***...***\\n**.....**\\n*.......*\"\nprint(solution(input_str)) "
    },
    {
        "number": 1968,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split()[0].split())\n    sellers = []\n    for i in range(1, n+1):\n        k = int(stdin.split()[i*2-1])\n        prices = list(map(int, stdin.split()[i*2:i*2+k]))\n        sellers.append((k, prices))\n\n    p = 0\n    q = []\n    for i in range(n):\n        k, prices = sellers[i]\n        for j in range(k):\n            if prices[j] <= v:\n                p += 1\n                q.append(i+1)\n                break\n\n    return str(p) + \"\\n\" + \" \".join(map(str, sorted(q)))\n"
    },
    {
        "number": 1969,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    matrix = [list(line) for line in stdin.split('\\n')[1:n+1]]\n    cross_count = 0\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if matrix[i][j] == 'X' and matrix[i-1][j-1] == 'X' and matrix[i-1][j+1] == 'X' and matrix[i+1][j-1] == 'X' and matrix[i+1][j+1] == 'X':\n                cross_count += 1\n\n    return str(cross_count)"
    },
    {
        "number": 1970,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, dx, dy, board):\n        return 0 <= x + dx < 8 and 0 <= y + dy < 8 and board[x + dx][y + dy] != \"#\"\n\n    def move_semiknight(x, y, dx, dy, board):\n        if is_valid_move(x, y, dx, dy, board):\n            board[x + dx][y + dy] = \"K\"\n            board[x][y] = \".\"\n            return True\n        return False\n\n    def find_meeting_square(board):\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == \"K\":\n                    x1, y1 = i, j\n                    break\n            else:\n                continue\n            break\n\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == \"K\":\n                    x2, y2 = i, j\n                    break\n            else:\n                continue\n            break\n\n        for dx, dy in [(-2, 2), (-2, -2), (2, 2), (2, -2)]:\n            if move_semiknight(x1, y1, dx, dy, board) and move_semiknight(x2, y2, -dx, -dy, board):\n                return True\n\n        return False\n\n    def process_board(board):\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == \"K\":\n                    board[i][j] = \".\"\n\n        return find_meeting_square(board)\n\n    result = []\n    for board in stdin.strip().split(\"\\n\\n\"):\n        board_list = [list(row) for row in board.split(\"\\n\")]\n        result.append(\"YES\" if process_board(board_list) else \"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1971,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    q = [0] * n\n    for i in range(n):\n        q[p[i] - 1] = i + 1\n\n    if q == p:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, q))"
    },
    {
        "number": 1972,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    a = [0] * 500000\n    for _ in range(q):\n        t, x, y = map(int, stdin.readline().strip().split())\n        if t == 1:\n            a[x - 1] += y\n        else:\n            result = sum(a[:x - 1])\n            for i in range(x, 500000, x):\n                result += a[i - 1]\n            print(result)\n    return \"\""
    },
    {
        "number": 1973,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    color_count = {}\n    max_streak = 0\n\n    for i in range(n):\n        color = colors[i]\n        if color not in color_count:\n            color_count[color] = 1\n        else:\n            color_count[color] += 1\n\n        if len(color_count) == len(set(colors[:i+1])):\n            max_streak = i + 1\n\n    return str(max_streak)"
    },
    {
        "number": 1974,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    robbers = []\n    searchlights = []\n\n    for i in range(n):\n        x, y = map(int, stdin.split()[2:4])\n        robbers.append((x, y))\n\n    for i in range(m):\n        x, y = map(int, stdin.split()[2:4])\n        searchlights.append((x, y))\n\n    def is_safe(robber, searchlight):\n        return robber[0] > searchlight[0] and robber[1] > searchlight[1]\n\n    def move_up(robber):\n        return (robber[0], robber[1] + 1)\n\n    def move_right(robber):\n        return (robber[0] + 1, robber[1])\n\n    def min_moves(robber_index, searchlight_index, moves):\n        if robber_index == n and searchlight_index == m:\n            return moves\n\n        if robber_index == n:\n            return min_moves(0, searchlight_index + 1, moves + 1)\n\n        if searchlight_index == m:\n            return min_moves(robber_index + 1, 0, moves + 1)\n\n        move_up_result = min_moves(robber_index, searchlight_index + 1, moves + 1)\n        move_right_result = min_moves(robber_index + 1, searchlight_index, moves + 1)\n\n        if is_safe(robbers[robber_index], searchlights[searchlight_index]):\n            return min(move_up_result, move_right_result)\n        else:\n            return min(move_up_result, move_right_result, min_moves(robber_index, searchlight_index + 1, moves + 1))\n\n    return str(min_moves(0, 0, 0))"
    },
    {
        "number": 1975,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    boys = [i for i in range(1, n+1)]\n    girls = [i for i in range(1, m+1)]\n    k = min(n, m)\n    result = []\n    \n    for i in range(k):\n        result.append(f\"{boys[i]} {girls[i]}\")\n    \n    return str(k) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 1976,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split()[:4])\n    broken_pixels = []\n    for _ in range(q):\n        x, y, t = map(int, stdin.split()[4:])\n        broken_pixels.append((x, y, t))\n\n    broken_pixels.sort(key=lambda x: x[2])\n\n    for i in range(len(broken_pixels)):\n        x, y, t = broken_pixels[i]\n        for j in range(i + 1, len(broken_pixels)):\n            x2, y2, t2 = broken_pixels[j]\n            if abs(x - x2) < k and abs(y - y2) < k:\n                return str(t)\n\n    return \"-1\""
    },
    {
        "number": 1977,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    matrix = [list(row) for row in stdin.split()[2:]]\n    min_path = \"\"\n\n    def dfs(path: str, row: int, col: int, k_left: int) -> None:\n        nonlocal min_path\n        if row == n and col == n:\n            if not min_path or path < min_path:\n                min_path = path\n            return\n\n        if k_left == 0:\n            return\n\n        if row < n:\n            dfs(path + matrix[row][col], row + 1, col, k_left - 1)\n\n        if col < n:\n            dfs(path + matrix[row][col], row, col + 1, k_left - 1)\n\n    dfs(\"\", 0, 0, k)\n    return min_path\n\n\ndef"
    },
    {
        "number": 1978,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, graph, m, path = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    path = list(map(int, path.split()))\n\n    def shortest_path(start, end):\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            current, path = queue.pop(0)\n            if current == end:\n                return path\n            visited.add(current)\n            for i in range(n):\n                if graph[current][i] == '1' and i not in path:\n                    queue.append((i, path + [i]))\n        return None\n\n    def good_subsequence(path):\n        subseq = [path[0]]\n        for i in range(1, len(path)):\n            if shortest_path(subseq[-1], path[i]) is not None:\n                subseq.append(path[i])\n        return subseq\n\n    shortest_good_subseq = good_subsequence(path)\n    return str(len(shortest_good_subseq)) + '\\n' + ' '.join(map(str, shortest_good_subseq))"
    },
    {
        "number": 1979,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    def count_matches(a: list, b: list) -> int:\n        count = 0\n        for i in range(n):\n            if a[i] == b[i]:\n                count += 1\n        return count\n\n    def shift_left(a: list, k: int) -> list:\n        return a[k:] + a[:k]\n\n    def shift_right(a: list, k: int) -> list:\n        return a[-k:] + a[:-k]\n\n    max_matches = count_matches(a, b)\n    for k in range(n):\n        max_matches = max(max_matches, count_matches(shift_left(a, k), shift_left(b, k)))\n        max_matches = max(max_matches, count_matches(shift_right(a, k), shift_right(b, k)))\n\n    return str(max_matches)"
    },
    {
        "number": 1980,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split()[:2])\n    problems = []\n    for line in stdin.split('\\n')[1:]:\n        d, c = map(int, line.split())\n        problems.append((d, c))\n\n    def gap(l, r):\n        if l == r:\n            return 0\n        max_diff = 0\n        for i in range(l, r):\n            diff = problems[i + 1][0] - problems[i][0]\n            max_diff = max(max_diff, diff)\n        return max_diff ** 2\n\n    max_profit = 0\n    for l in range(n):\n        for r in range(l, n):\n            profit = sum(problem[1] for problem in problems[l:r + 1]) - gap(l, r)\n            max_profit = max(max_profit, profit)\n\n    return str(max_profit)"
    },
    {
        "number": 1981,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cats = list(map(int, stdin.split()[2:]))\n    tree = [[] for _ in range(n+1)]\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            x, y = map(int, line.split())\n            tree[x].append(y)\n            tree[y].append(x)\n    \n    def dfs(node, parent, cats_count):\n        if len(tree[node]) == 1:\n            return 1\n        if cats_count >= m:\n            return 0\n        if cats[node-1] == 1:\n            cats_count += 1\n        result = 0\n        for child in tree[node]:\n            if child != parent:\n                result += dfs(child, node, cats_count)\n        return result\n    \n    return str(dfs(1, -1, 0))"
    },
    {
        "number": 1982,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        if k == 1:\n            if n % 2 != 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            odd_sum = 0\n            for i in range(k):\n                odd_sum += (2 * i + 1)\n            if n == odd_sum:\n                print(\"YES\")\n            else:\n                print(\"NO\")"
    },
    {
        "number": 1983,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_increasing_subsequence(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    test_cases = stdin.split(\"\\n\")\n    result = []\n    for i in range(1, len(test_cases), 2):\n        n = int(test_cases[i])\n        arr = list(map(int, test_cases[i + 1].split()))\n        new_arr = arr * n\n        lis = longest_increasing_subsequence(new_arr)\n        result.append(lis)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1984,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split()[:4])\n    levels = stdin.split('\\n')[1:]\n    levels = [list(level) for level in levels]\n\n    def get_diff(level1, level2):\n        diff = 0\n        for i in range(n):\n            for j in range(m):\n                if level1[i][j] != level2[i][j]:\n                    diff += 1\n        return diff\n\n    def get_min_transfer_bytes(levels):\n        min_bytes = 0\n        for i in range(1, k):\n            min_bytes += get_diff(levels[i], levels[i - 1])\n        return min_bytes\n\n    def get_transfer_order(levels):\n        transfer_order = []\n        for i in range(1, k):\n            diff = get_diff(levels[i], levels[i - 1])\n            if diff == 0:\n                transfer_order.append((i, 0))\n            else:\n                transfer_order.append((i, i - 1))\n        return transfer_order\n\n    min_bytes = get_min_transfer_bytes(levels)\n    transfer_order = get_transfer_order(levels)\n\n    output = str(min_bytes) + '\\n'\n    for pair in transfer_order:\n        output += ' '.join(map(str, pair)) + '\\n'\n\n    return output"
    },
    {
        "number": 1985,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+k]))\n    b = list(map(int, stdin.split()[2+k:]))\n    b.sort()\n    \n    options = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if b[i] + b[j] + b[k] == sum(a):\n                    options.append(b[i])\n                    options.append(b[j])\n                    options.append(b[k])\n    \n    return str(len(options)) if options else \"0\""
    },
    {
        "number": 1986,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    restaurants = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            f, t = map(int, line.split())\n            restaurants.append((f, t))\n\n    max_joy = -1\n    for f, t in restaurants:\n        if t <= k:\n            joy = f\n        else:\n            joy = f - (t - k)\n        max_joy = max(max_joy, joy)\n\n    return str(max_joy)"
    },
    {
        "number": 1987,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_1, c_2 = map(int, stdin.split()[:3])\n    visitors = stdin.split()[3]\n\n    def get_price(x):\n        return c_1 + c_2 * (x - 1) ** 2\n\n    def get_min_price(visitors):\n        min_price = float('inf')\n        for i in range(1, len(visitors) + 1):\n            if visitors.count('1') >= i:\n                price = get_price(i)\n                min_price = min(min_price, price)\n        return min_price\n\n    min_price = get_min_price(visitors)\n    return str(min_price)"
    },
    {
        "number": 1988,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        s = test_cases[i + 1]\n        s_prime = s\n        k = 1\n\n        for j in range(1, n):\n            substring = s[j:j + k]\n            reversed_substring = substring[::-1]\n            s_prime = s_prime[:j] + reversed_substring + s_prime[j + k:]\n\n            if s_prime < s:\n                s = s_prime\n                k = j\n\n        result.append((s, k))\n\n    output = \"\"\n    for i in range(0, len(result)):\n        output += result[i][0] + \"\\n\" + str(result[i][1]) + \"\\n\"\n\n    return output"
    },
    {
        "number": 1989,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    def f(l, r, x):\n        return sum(1 for i in range(l, r + 1) if a[i] == x)\n\n    count = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if f(1, i, a[i]) > f(j, n, a[j]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1990,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    commands = stdin.split()[1]\n    stack = []\n    colors = 0\n    result = []\n\n    for command in commands:\n        if command == \"L\":\n            if stack:\n                stack.pop()\n        elif command == \"R\":\n            pass\n        elif command in \"abcdefghijklmnopqrstuvwxyz\":\n            stack.append(command)\n        else:\n            if command == \"(\":\n                stack.append(command)\n            elif command == \")\":\n                if not stack or stack[-1] != \"(\":\n                    result.append(-1)\n                    colors = 0\n                else:\n                    stack.pop()\n                    if colors == 0:\n                        colors += 1\n                    result.append(colors)\n            else:\n                result.append(-1)\n                colors = 0\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1991,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def special_exchange(arr: List[int], start: int, end: int) -> List[int]:\n        if start >= end:\n            return arr\n        for i in range(start, end):\n            if i != arr[i]:\n                j = i - 1\n                while j >= start and arr[j] == i:\n                    j -= 1\n                if j < start:\n                    continue\n                arr[i], arr[j] = arr[j], arr[i]\n                return special_exchange(arr, start, end)\n        return arr\n\n    def min_special_exchanges(arr: List[int]) -> int:\n        n = len(arr)\n        count = 0\n        for i in range(n):\n            if arr[i] != i + 1:\n                count += 1\n                arr = special_exchange(arr, 0, i + 1)\n        return count\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        arr = list(map(int, stdin.readline().split()))\n        result.append(min_special_exchanges(arr))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1992,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    initial_order = list(map(int, stdin.split()[1].split()))\n    planned_order = list(map(int, stdin.split()[2].split()))\n\n    # Calculate the number of gestures needed to launch the applications in the initial order\n    gestures = 0\n    current_screen = 1\n    for app_id in initial_order:\n        if app_id == 1:\n            gestures += 1\n        else:\n            app_index = initial_order.index(app_id)\n            if app_index >= k:\n                gestures += app_index // k\n                current_screen = app_index // k + 1\n            else:\n                gestures += app_index // k\n\n    # Calculate the number of gestures needed to launch the applications in the planned order\n    for app_id in planned_order:\n        app_index = initial_order.index(app_id)\n        if app_index >= k:\n            gestures += app_index // k - current_screen + 1\n            current_screen = app_index // k + 1\n        else:\n            gestures += app_index // k - current_screen + 1\n\n    return str(gestures)"
    },
    {
        "number": 1993,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def dfs(x: int, y: int, visited: set) -> int:\n        if (x, y) in visited or field[x][y] == '*':\n            return 0\n        visited.add((x, y))\n        return 1 + sum(dfs(x + dx, y + dy, visited) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])\n\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if field[i][j] == '*':\n                visited = set()\n                count = dfs(i, j, visited)\n                row.append(str(count % 10))\n            else:\n                row.append('.')\n        result.append(''.join(row))\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 1994,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    prefix_dict = {}\n    suffix_dict = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            prefix = s[i:j]\n            suffix = s[n-j+i:n-i+1]\n            if prefix == suffix:\n                if prefix not in prefix_dict:\n                    prefix_dict[prefix] = 1\n                else:\n                    prefix_dict[prefix] += 1\n                if suffix not in suffix_dict:\n                    suffix_dict[suffix] = 1\n                else:\n                    suffix_dict[suffix] += 1\n    result = []\n    for prefix in prefix_dict:\n        if prefix in suffix_dict:\n            result.append((len(prefix), prefix_dict[prefix] * suffix_dict[prefix]))\n    result.sort(key=lambda x: x[0])\n    k = len(result)\n    output = str(k) + '\\n'\n    for item in result:\n        output += ' '.join(map(str, item)) + '\\n'\n    return output"
    },
    {
        "number": 1995,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m = stdin.split('\\n')[0], int(stdin.split('\\n')[1])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[2:2+m]]\n\n    for l, r, k in queries:\n        s = s[:l-1] + s[l-1:r] + s[l-1:l-1+k] + s[r:]\n\n    return s"
    },
    {
        "number": 1996,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    actions = stdin.readlines()\n    selected_letter = None\n    shocks = 0\n    for action in actions:\n        if action[0] == \"!\":\n            word = action[2:]\n            if selected_letter is None or selected_letter in word:\n                shocks += 1\n        elif action[0] == \"?\":\n            guess = action[2:]\n            if selected_letter is None:\n                selected_letter = guess\n            elif guess == selected_letter:\n                break\n    return str(shocks)"
    },
    {
        "number": 1997,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(node, parent):\n        nonlocal max_result, min_result\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n            if len(graph[node]) == 0:\n                max_result = max(max_result, node)\n                min_result = min(min_result, node)\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n    max_result = 0\n    min_result = float('inf')\n    dfs(1, None)\n\n    return str(max_result) + ' ' + str(min_result)"
    },
    {
        "number": 1998,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split()[:4])\n    shots = list(stdin.split()[4])\n    ships = []\n    for i in range(n - b + 1):\n        if shots[i:i+b].count('1') == b:\n            ships.append(i)\n    min_cells = n\n    for i in range(n):\n        if i not in ships:\n            min_cells = min(min_cells, sum(1 for j in range(n) if shots[j] == '0' and abs(i - j) < a))\n    cells_to_shoot = [i for i in range(n) if shots[i] == '0']\n    return str(min_cells) + '\\n' + ' '.join(map(str, cells_to_shoot))"
    },
    {
        "number": 1999,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    while True:\n        min_val = min(arr)\n        count = arr.count(min_val)\n        if count < 2:\n            break\n        first_occurrence = arr.index(min_val)\n        second_occurrence = arr.index(min_val, first_occurrence + 1)\n        arr = arr[:first_occurrence] + [2 * min_val] + arr[second_occurrence + 1:]\n    return str(len(arr)) + \"\\n\" + \" \".join(map(str, arr))"
    },
    {
        "number": 2000,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i] + a[j]) & (a[i] + a[j] - 1) == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2001,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    deliciousness = list(map(int, stdin.split()[2:]))\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.split()[2:])\n        queries.append((l, r))\n\n    def max_enjoyment(l, r):\n        enjoyment = 0\n        for i in range(l, r + 1):\n            enjoyment += deliciousness[i - 1]\n        return enjoyment\n\n    result = []\n    for l, r in queries:\n        result.append(max_enjoyment(l, r))\n\n    return \"\\n\".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 2002,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def find_ancestors(u: int, parent: List[int]) -> Set[int]:\n        ancestors = {u}\n        for v in range(1, n + 1):\n            if v != u and parent[v] != -1:\n                ancestors.update(find_ancestors(v, parent))\n        return ancestors\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_beauty(u: int, v: int, parent: List[int]) -> int:\n        if u == v:\n            return x[u - 1]\n        ancestors = find_ancestors(u, parent)\n        path = []\n        while v not in ancestors:\n            path.append(v)\n            v = parent[v]\n        path.append(v)\n        return gcd(x[u - 1], *[x[v - 1] for v in path[::-1]])\n\n    parent = [-1] * (n + 1)\n    for a, b in edges:\n        parent[b] = a\n\n    result = 0\n    for u in range(1, n + 1):\n        for v in range(1, n + 1):\n            if u != v:\n                result += find_beauty(u, v, parent)\n                result %= 10**9 + 7\n\n    return str(result)"
    },
    {
        "number": 2003,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    q = int(queries[0])\n    A = set()\n    A.add(0)\n\n    for query in queries[1:]:\n        if query[0] == '+':\n            x = int(query[2:])\n            A.add(x)\n        elif query[0] == '-':\n            x = int(query[2:])\n            A.remove(x)\n        else:\n            x = int(query[2:])\n            max_xor = 0\n            for a in A:\n                max_xor = max(max_xor, x ^ a)\n            print(max_xor)"
    },
    {
        "number": 2004,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    tanks = [0] * n\n    bombs = []\n    destroyed = 0\n\n    for i in range(n):\n        if tanks[i] == 0:\n            bombs.append(i + 1)\n            tanks[i] = 1\n            destroyed += 1\n\n            for j in range(max(0, i - 1), min(i + 2, n)):\n                if tanks[j] == 0:\n                    tanks[j] = 1\n                    destroyed += 1\n\n    return f\"{len(bombs)}\\n{' '.join(map(str, bombs))}\""
    },
    {
        "number": 2005,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, n_1, n_2 = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    \n    # Sort the wealth of candidates in descending order\n    a.sort(reverse=True)\n    \n    # Initialize the sum of arithmetic means of wealth\n    sum_mean = 0\n    \n    # Initialize the number of candidates in the first city\n    num_candidates_1 = 0\n    \n    # Initialize the number of candidates in the second city\n    num_candidates_2 = 0\n    \n    # Iterate through the candidates\n    for i in range(n):\n        # If the number of candidates in the first city is less than the planned number\n        if num_candidates_1 < n_1:\n            # Add the wealth of the candidate to the sum of arithmetic means\n            sum_mean += a[i]\n            # Increment the number of candidates in the first city\n            num_candidates_1 += 1\n        # If the number of candidates in the second city is less than the planned number\n        elif num_candidates_2 < n_2:\n            # Add the wealth of the candidate to the sum of arithmetic means\n            sum_mean += a[i]\n            # Increment the number of candidates in the second city\n            num_candidates_2 += 1\n        else:\n            break\n    \n    # Calculate the arithmetic mean of wealth for each city\n    mean_1 = sum_mean / n_1\n    mean_2 = (sum_mean - a[0]) / n_2\n    \n    # Return the maximum possible sum of arithmetic means of wealth of cities' residents\n    return max(mean_1, mean_2)"
    },
    {
        "number": 2006,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    matrix = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def find_dwarf(matrix: List[List[str]]) -> Tuple[int, int]:\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'G':\n                    return i, j\n        return -1, -1\n\n    def find_candy(matrix: List[List[str]]) -> Tuple[int, int]:\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'S':\n                    return i, j\n        return -1, -1\n\n    def move_dwarf(matrix: List[List[str]], dwarf_row: int, dwarf_col: int, candy_row: int, candy_col: int) -> int:\n        moves = 0\n        while dwarf_col != candy_col:\n            dwarf_col += 1\n            moves += 1\n            if dwarf_col == m:\n                return -1\n        return moves\n\n    dwarf_row, dwarf_col = find_dwarf(matrix)\n    candy_row, candy_col = find_candy(matrix)\n\n    if dwarf_row == -1 or dwarf_col == -1 or candy_row == -1 or candy_col == -1:\n        return -1\n\n    moves = move_dwarf(matrix, dwarf_row, dwarf_col, candy_row, candy_col)\n\n    return moves"
    },
    {
        "number": 2007,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    letters = list(stdin.split()[2])\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[2:])\n        graph[x-1].append(y-1)\n\n    def dfs(node: int, visited: set, path: str) -> int:\n        visited.add(node)\n        max_value = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                new_path = path + letters[node]\n                max_value = max(max_value, dfs(neighbor, visited.copy(), new_path))\n        return max_value\n\n    max_value = 0\n    for i in range(n):\n        max_value = max(max_value, dfs(i, set(), letters[i]))\n\n    return str(max_value)"
    },
    {
        "number": 2008,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = []\n    for i in range(1, n+1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        students.append((a, b, i))\n\n    students.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n    total_dissatisfaction = 0\n    for i in range(n):\n        a, b, position = students[i]\n        total_dissatisfaction += a * (position - 1) + b * (n - position)\n\n    return str(total_dissatisfaction)"
    },
    {
        "number": 2009,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    r1, c1 = map(int, stdin.readline().strip().split())\n    r2, c2 = map(int, stdin.readline().strip().split())\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def bfs(grid, r1, c1, r2, c2):\n        queue = [(r1, c1)]\n        visited = set()\n        while queue:\n            r, c = queue.pop(0)\n            if (r, c) == (r2, c2):\n                return True\n            visited.add((r, c))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r < n and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] == '0':\n                    queue.append((new_r, new_c))\n        return False\n\n    def create_tunnel(grid, r1, c1, r2, c2):\n        queue = [(r1, c1, 0)]\n        visited = set()\n        while queue:\n            r, c, cost = queue.pop(0)\n            if (r, c) == (r2, c2):\n                return cost\n            visited.add((r, c))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r < n and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] == '0':\n                    queue.append((new_r, new_c, cost + 1))\n        return -1\n\n    if bfs(grid, r1, c1, r2, c2):\n        return 0\n    else:\n        return create_tunnel(grid, r1, c1, r2, c2)"
    },
    {
        "number": 2010,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    array = list(map(int, stdin.split()[2:2+n]))\n    operations = stdin.split()[2+n:]\n    for i in range(m):\n        operation_type = int(operations[i*3])\n        if operation_type == 1:\n            v, x = map(int, operations[i*3+1:i*3+3])\n            array[v-1] = x\n        elif operation_type == 2:\n            y = int(operations[i*3+1])\n            array = [a+y for a in array]\n        elif operation_type == 3:\n            q = int(operations[i*3+1])\n            print(array[q-1])"
    },
    {
        "number": 2011,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    debts = []\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            u, v, d = map(int, line.split())\n            debts.append((u, v, d))\n\n    def consolidate(a, b, c, d, z):\n        nonlocal debts\n        debts = [(u, v, d) for u, v, d in debts if u != a and u != b and u != c and u != d and v != a and v != b and v != c and v != d]\n        debts.append((a, b, d(a, b) - z))\n        debts.append((c, d, d(c, d) - z))\n        debts.append((a, d, d(a, b) + d(c, d) - z))\n        debts.append((b, d, d(a, b) + d(c, d) - z))\n        debts.append((c, b, d(c, d) - z))\n        debts.append((a, c, d(a, b) + d(c, d) - z))\n\n    def total_debt():\n        return sum(d for _, _, d in debts)\n\n    while len(debts) > 1:\n        debts.sort(key=lambda x: x[2], reverse=True)\n        a, b, c, d, z = debts[0][0], debts[0][1], debts[1][0], debts[1][1], min(debts[0][2], debts[1][2])\n        consolidate(a, b, c, d, z)\n\n    return f\"{len(debts)}\\n{' '.join(f'{u} {v} {d}' for u, v, d in debts)}\"\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 2012,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = stdin.split()\n    n = int(n)\n    c = list(map(int, c.split()))\n\n    result = []\n    for i in range(n):\n        if c[i] == 0:\n            continue\n        for j in range(c[i]):\n            result.append(chr(97 + i))\n\n    return \"\".join(result)\n"
    },
    {
        "number": 2013,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    chips = []\n    for i in range(k):\n        x, y = map(int, stdin.split()[3 + i * 2:5 + i * 2])\n        chips.append((x, y))\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def get_new_position(x, y, action):\n        if action == 'L':\n            return x, y - 1\n        elif action == 'R':\n            return x, y + 1\n        elif action == 'D':\n            return x + 1, y\n        elif action == 'U':\n            return x - 1, y\n        else:\n            return x, y\n\n    def is_reachable(x, y, action):\n        new_x, new_y = get_new_position(x, y, action)\n        return is_valid(new_x, new_y)\n\n    def is_visited(x, y, visited):\n        return (x, y) in visited\n\n    def dfs(x, y, visited, action_sequence):\n        if len(action_sequence) >= 2 * n * m:\n            return -1\n\n        if is_visited(x, y, visited):\n            return action_sequence\n\n        visited.add((x, y))\n\n        for action in ['L', 'R', 'D', 'U']:\n            if is_reachable(x, y, action):\n                new_x, new_y = get_new_position(x, y, action)\n                new_action_sequence = action_sequence + action\n                result = dfs(new_x, new_y, visited, new_action_sequence)\n                if result != -1:\n                    return result\n\n        return -1\n\n    visited = set()\n    for i in range(k):\n        x, y = chips[i]\n        visited.add((x, y))\n\n    for i in range(k):\n        x, y = chips[i]\n        action_sequence = dfs(x, y, visited, '')\n        if action_sequence != -1:\n            return len(action_sequence), action_sequence\n\n    return -1, -1\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 2014,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    permutations = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def lcs(x: str, y: str) -> int:\n        m, n = len(x), len(y)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif x[i - 1] == y[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    lcs_length = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            lcs_length = max(lcs_length, lcs(str(permutations[i]), str(permutations[j])))\n\n    return lcs_length"
    },
    {
        "number": 2015,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        r, g, b = map(int, stdin.split('\\n')[i].split())\n\n        if r == 0 or g == 0 or b == 0:\n            result.append(\"No\")\n        else:\n            result.append(\"Yes\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2016,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, m = map(int, stdin.split())\n    spells = []\n    mana = m\n    for _ in range(q):\n        k, a, b = map(int, stdin.split())\n        if k == 1:\n            x, y = (a + len(spells)) % 1000001 + 1, (b + len(spells)) % 1000001 + 1\n            spells.append((x, y))\n        else:\n            t, h = (a + len(spells)) % 1000001 + 1, (b + len(spells)) % 1000001 + 1\n            if mana >= h:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n            mana = m\n    return \"\""
    },
    {
        "number": 2017,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    swaps = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    p = list(range(1, 10**9+1))\n    \n    for a, b in swaps:\n        p[a-1], p[b-1] = p[b-1], p[a-1]\n    \n    inversions = 0\n    for i in range(len(p)):\n        for j in range(i+1, len(p)):\n            if p[i] > p[j]:\n                inversions += 1\n    \n    return str(inversions)"
    },
    {
        "number": 2018,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    questions = stdin.split()[3:]\n    for i in range(0, len(questions), 4):\n        sx, sy, ex, ey = map(int, questions[i:i+4])\n        if sx == 1 and sy < 1 or sy > n:\n            print(\"NO\")\n        elif sx == 2 and sy < 1 or sy > m:\n            print(\"NO\")\n        elif ex == 1 and ey < 1 or ey > n:\n            print(\"NO\")\n        elif ex == 2 and ey < 1 or ey > m:\n            print(\"NO\")\n        elif sx == ex and sy == ey:\n            print(\"YES\")\n        elif sx == 1 and ex == 2:\n            print(\"YES\")\n        elif sx == 2 and ex == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2019,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    for case in cases:\n        s = case\n        while len(s) > 1:\n            if s[0] == s[1]:\n                s = s[2:]\n            else:\n                s = s[1:]\n        if len(s) == 0:\n            print(\"DA\")\n        else:\n            print(\"NET\")"
    },
    {
        "number": 2020,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    clocks = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def is_vertical(a, b):\n        return a[0] == b[0]\n    \n    def is_horizontal(a, b):\n        return a[1] == b[1]\n    \n    def get_segments(clocks):\n        segments = []\n        for i in range(len(clocks)):\n            for j in range(i+1, len(clocks)):\n                if is_vertical(clocks[i], clocks[j]):\n                    segments.append((clocks[i], clocks[j]))\n                elif is_horizontal(clocks[i], clocks[j]):\n                    segments.append((clocks[i], clocks[j]))\n        return segments\n    \n    def get_min_moves(segments):\n        min_moves = float('inf')\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                moves = 0\n                for segment in segments:\n                    if segment[0] in (segments[i][0], segments[i][1]) and segment[1] in (segments[j][0], segments[j][1]):\n                        moves += 1\n                min_moves = min(min_moves, moves)\n        return min_moves\n    \n    segments = get_segments(clocks)\n    min_moves = get_min_moves(segments)\n    \n    return str(min_moves)"
    },
    {
        "number": 2021,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, q = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    q = list(map(int, q.split()))\n\n    def min_cost(i: int) -> int:\n        q_i = q[i]\n        a_sorted = sorted(a, reverse=True)\n        total_cost = sum(a_sorted[:q_i - 1])\n        for j in range(q_i - 1, n):\n            total_cost += a_sorted[j]\n        return total_cost\n\n    return \" \".join(map(str, [min_cost(i) for i in range(m)]))\n\n\ndef"
    },
    {
        "number": 2022,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[-2:])\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Find an independent set with size ceil(k/2)\n    def find_independent_set(graph: List[List[int]], k: int) -> List[int]:\n        visited = [False] * (len(graph) + 1)\n        independent_set = []\n        for i in range(1, len(graph)):\n            if not visited[i]:\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = True\n                        independent_set.append(node)\n                        for neighbor in graph[node]:\n                            stack.append(neighbor)\n        return independent_set[:len(independent_set)//2]\n    \n    # Find a simple cycle of length at most k\n    def find_cycle(graph: List[List[int]], k: int) -> List[int]:\n        visited = [False] * (len(graph) + 1)\n        for i in range(1, len(graph)):\n            if not visited[i]:\n                stack = [i]\n                cycle = []\n                while stack:\n                    node = stack[-1]\n                    if not visited[node]:\n                        visited[node] = True\n                        cycle.append(node)\n                        for neighbor in graph[node]:\n                            if not visited[neighbor]:\n                                stack.append(neighbor)\n                            elif neighbor != stack[-2]:\n                                return cycle + [neighbor]\n                    else:\n                        stack.pop()\n        return []\n    \n    # Check if there is a simple cycle of length at most k\n    if find_cycle(graph, k):\n        cycle = find_cycle(graph, k)\n        return \"2\\n\" + str(len(cycle)) + \"\\n\" + \" \".join(map(str, cycle))\n    else:\n        independent_set = find_independent_set(graph, k)\n        return \"1\\n\" + \" \".join(map(str, independent_set))"
    },
    {
        "number": 2023,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:2+2*n]))\n    queries = []\n    for i in range(2+2*n, 2+2*n+m):\n        query_type, *params = stdin.split()[i].split(' ')\n        queries.append((int(query_type), *map(int, params)))\n\n    for query in queries:\n        if query[0] == 1:\n            x, y, k = query[1:]\n            b[y:y+k] = [a[x+i] for i in range(k)]\n        else:\n            x = query[1]\n            print(b[x])"
    },
    {
        "number": 2024,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, weights = map(int, stdin.split())\n    weights = sorted(weights, reverse=True)\n    max_weight = 0\n    emotional_orders = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if weights[i] >= 2 * weights[j]:\n                emotional_orders += 1\n            elif 2 * weights[i] <= weights[j]:\n                emotional_orders += 1\n\n    return str(emotional_orders % 998244353)"
    },
    {
        "number": 2025,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    q = int(queries[0])\n    results = []\n\n    for i in range(1, q + 1):\n        n = int(queries[i])\n        if n <= 1:\n            results.append(-1)\n        else:\n            max_summands = 0\n            for j in range(2, n):\n                if n % j == 0:\n                    max_summands += 1\n            results.append(max_summands)\n\n    return '\\n'.join(map(str, results))\n"
    },
    {
        "number": 2026,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    movements = stdin.split('\\n')[1]\n    x, y = 0, 0\n    visited = set()\n    min_length = 0\n    \n    for movement in movements:\n        if movement == 'L':\n            x -= 1\n        elif movement == 'R':\n            x += 1\n        elif movement == 'U':\n            y += 1\n        elif movement == 'D':\n            y -= 1\n        \n        if (x, y) not in visited:\n            visited.add((x, y))\n            min_length += 1\n    \n    return str(min_length)"
    },
    {
        "number": 2027,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a_list = list(map(int, stdin.split('\\n')[1].split()))\n\n    b_list = []\n    for i in range(n):\n        b_list.append(a_list[i] - sum(range(1, n+1)))\n\n    return ' '.join(map(str, b_list))"
    },
    {
        "number": 2028,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_seating_arrangements(n: int, desks: List[Tuple[int, int]]) -> int:\n        def dfs(current_seating: List[int], current_desk: int, used_desks: Set[int]) -> int:\n            if current_desk == 2 * n:\n                return 1\n            count = 0\n            for i in range(1, 2 * n + 1):\n                if i not in used_desks and (current_seating[current_desk - 1] == i or i == current_seating[current_desk - 1]):\n                    current_seating[current_desk] = i\n                    used_desks.add(i)\n                    count += dfs(current_seating, current_desk + 1, used_desks)\n                    used_desks.remove(i)\n                    current_seating[current_desk] = 0\n            return count\n\n        current_seating = [0] * 2 * n\n        current_desk = 1\n        used_desks = set()\n        for engineer, desired_desk in desks:\n            current_seating[current_desk - 1] = engineer\n            used_desks.add(engineer)\n            current_desk += 1\n        return dfs(current_seating, current_desk, used_desks)\n\n    n = int(stdin.readline().strip())\n    desks = []\n    for _ in range(n):\n        current_desk, desired_desk = map(int, stdin.readline().strip().split())\n        desks.append((current_desk, desired_desk))\n\n    return str(count_seating_arrangements(n, desks) % 1000000007)"
    },
    {
        "number": 2029,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    edges = []\n    for line in stdin.split('\\n')[2:]:\n        a, b = map(int, line.split())\n        edges.append((a, b))\n\n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, node)\n\n    def find_diameter(node, visited, parent):\n        visited.add(node)\n        max_distance = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                distance = find_diameter(neighbor, visited, node)\n                max_distance = max(max_distance, distance)\n        return max_distance + 1\n\n    graph = {i: set() for i in range(1, n + 1)}\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    visited = set()\n    max_diameter = 0\n    for node in graph:\n        if node not in visited:\n            diameter = find_diameter(node, visited, None)\n            max_diameter = max(max_diameter, diameter)\n\n    weights = [1] * (n - 1)\n    total_weight = sum(weights)\n    if total_weight > s:\n        weights = [w * (s / total_weight) for w in weights]\n    else:\n        weights = [w + (s - total_weight) / (n - 1) for w in weights]\n\n    return str(max_diameter)"
    },
    {
        "number": 2030,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    max_prob = list(map(float, stdin.splitlines()[1].split()))\n    min_prob = list(map(float, stdin.splitlines()[2].split()))\n\n    a_prob = [0] * n\n    b_prob = [0] * n\n\n    for i in range(n):\n        a_prob[i] = max_prob[i] * (i + 1)\n        b_prob[i] = min_prob[i] * (i + 1)\n\n    a_prob = [round(x, 6) for x in a_prob]\n    b_prob = [round(x, 6) for x in b_prob]\n\n    a_prob = [str(x) for x in a_prob]\n    b_prob = [str(x) for x in b_prob]\n\n    return \" \".join(a_prob) + \"\\n\" + \" \".join(b_prob)"
    },
    {
        "number": 2031,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, requests = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m)\n    requests = [list(map(int, request.split())) for request in requests.split('\\n')]\n\n    def is_subsequence(subseq: List[int], seq: List[int]) -> bool:\n        i = j = 0\n        while i < len(seq) and j < len(subseq):\n            if seq[i] == subseq[j]:\n                j += 1\n            i += 1\n        return j == len(subseq)\n\n    def max_sum_subsequence(seq: List[int], k: int) -> List[int]:\n        subsequences = []\n        for i in range(len(seq) - k + 1):\n            subseq = seq[i:i + k]\n            if is_subsequence(subseq, seq):\n                subsequences.append(subseq)\n        return max(subsequences, key=sum)\n\n    def lexicographically_minimal_subsequence(subseq: List[int], seq: List[int]) -> List[int]:\n        i = 0\n        while i < len(seq) and seq[i] == subseq[0]:\n            i += 1\n        return seq[:i]\n\n    results = []\n    for k, pos in requests:\n        subseq = max_sum_subsequence(a, k)\n        results.append(subseq[pos - 1])\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 2032,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m, k = map(int, input().split())\n        castles = []\n        for _ in range(n):\n            a, b, c = map(int, input().split())\n            castles.append((a, b, c))\n        portals = []\n        for _ in range(m):\n            u, v = map(int, input().split())\n            portals.append((u, v))\n        return n, m, k, castles, portals\n\n    def find_best_strategy(n: int, m: int, k: int, castles: list, portals: list) -> int:\n        def dfs(i: int, remaining_warriors: int, defended_castles: set, score: int) -> int:\n            if i == n:\n                return score\n            a, b, c = castles[i]\n            if remaining_warriors < a:\n                return -1\n            if i in defended_castries:\n                return dfs(i + 1, remaining_warriors, defended_castles, score)\n            new_warriors = remaining_warriors - a\n            new_defended_castles = defended_castles.copy()\n            new_defended_castries.add(i)\n            new_score = score + c\n            result = dfs(i + 1, new_warriors, new_defended_castries, new_score)\n            if result != -1:\n                return result\n            for u, v in portals:\n                if u == i:\n                    new_warriors += b\n                    new_defended_castries.add(u)\n                    new_score += c\n                    result = dfs(i + 1, new_warriors, new_defended_castries, new_score)\n                    if result != -1:\n                        return result\n            return -1\n\n        return dfs(0, k, set(), 0)\n\n    n, m, k, castles, portals = read_input()\n    result = find_best_strategy(n, m, k, castles, portals)\n    return str(result)"
    },
    {
        "number": 2033,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:-1]]\n    k = int(stdin.split('\\n')[-2])\n    path = list(map(int, stdin.split('\\n')[-1].split()))\n\n    # Build the graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Dijkstra's algorithm to find the shortest path\n    def dijkstra(graph, start, end):\n        queue = [(0, start, [])]\n        visited = set()\n        while queue:\n            (cost, current, path) = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                path = path + [current]\n                if current == end:\n                    return path\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        queue.append((cost + 1, neighbor, path))\n        return None\n\n    # Find the shortest path from s to t\n    shortest_path = dijkstra(graph, path[0], path[-1])\n\n    # Count the number of rebuilds\n    rebuilds = 0\n    for i in range(len(shortest_path) - 1):\n        if shortest_path[i] != path[i]:\n            rebuilds += 1\n\n    return f\"{rebuilds} {rebuilds}\""
    },
    {
        "number": 2034,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        x, y = map(int, input().split())\n        roads.append((x, y))\n\n    def dfs(city, visited):\n        visited.add(city)\n        for x, y in roads:\n            if x == city:\n                dfs(y, visited)\n            elif y == city:\n                dfs(x, visited)\n\n    visited = set()\n    for i in range(1, n + 1):\n        if i not in visited:\n            dfs(i, visited)\n\n    return len(visited)\n"
    },
    {
        "number": 2035,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sx, sy = map(int, stdin.split()[:3])\n    students = []\n    for line in stdin.split('\\n')[1:n+1]:\n        x, y = map(int, line.split())\n        students.append((x, y))\n\n    max_students = 0\n    tent_location = (0, 0)\n\n    for x in range(sx+1):\n        for y in range(sy+1):\n            if (x, y) != (sx, sy):\n                students_visiting_tent = set()\n                for student in students:\n                    if abs(student[0] - x) + abs(student[1] - y) <= abs(student[0] - sx) + abs(student[1] - sy):\n                        students_visiting_tent.add(student)\n                if len(students_visiting_tent) > max_students:\n                    max_students = len(students_visiting_tent)\n                    tent_location = (x, y)\n\n    return f\"{max_students}\\n{tent_location[0]} {tent_location[1]}\""
    },
    {
        "number": 2036,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, S_x, S_y = map(int, stdin.split())\n    visited = set()\n    result = []\n\n    def dfs(x, y):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        result.append((x, y))\n\n        if x > 1:\n            dfs(x - 1, y)\n        if x < n:\n            dfs(x + 1, y)\n        if y > 1:\n            dfs(x, y - 1)\n        if y < m:\n            dfs(x, y + 1)\n\n    dfs(S_x, S_y)\n    return '\\n'.join(f'{x} {y}' for x, y in result)"
    },
    {
        "number": 2037,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    difficulties = list(map(int, stdin.split()[2:]))\n    held_rounds = [0] * m\n\n    for i in range(m):\n        if len(set(difficulties[:i+1])) == n:\n            held_rounds[i] = 1\n\n    return ''.join(map(str, held_rounds))"
    },
    {
        "number": 2038,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    swaps = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if 2 * abs(i - j) >= n:\n                swaps.append((i, j))\n    return str(len(swaps)) + \"\\n\" + \"\\n\".join([\" \".join(map(str, swap)) for swap in swaps])"
    },
    {
        "number": 2039,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    local_extrema = 0\n\n    for i in range(1, n - 1):\n        if a[i] < a[i - 1] and a[i] < a[i + 1]:\n            local_extrema += 1\n        elif a[i] > a[i - 1] and a[i] > a[i + 1]:\n            local_extrema += 1\n\n    return str(local_extrema)"
    },
    {
        "number": 2040,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b_list = [int(x) for x in stdin.split('\\n')[1:]]\n    a_list = []\n    for b in b_list:\n        a = 1\n        while sum(int(digit) for digit in str(a)) != b:\n            a += 1\n        a_list.append(a)\n    return '\\n'.join(str(x) for x in a_list)"
    },
    {
        "number": 2041,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, requests = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    m = int(m)\n    requests = [list(map(int, request.split())) for request in requests.split('\\n')]\n\n    def is_subsequence(subseq: list, seq: list) -> bool:\n        i = j = 0\n        while i < len(seq) and j < len(subseq):\n            if seq[i] == subseq[j]:\n                j += 1\n            i += 1\n        return j == len(subseq)\n\n    def find_optimal_subsequence(seq: list, k: int) -> list:\n        subsequences = []\n        for i in range(len(seq) - k + 1):\n            subseq = seq[i:i + k]\n            if all(is_subsequence(subseq, seq[:j]) for j in range(len(seq) + 1)):\n                subsequences.append(subseq)\n        return max(subsequences, key=lambda subseq: (sum(subseq), subseq))\n\n    answers = []\n    for request in requests:\n        k, pos = request\n        subseq = find_optimal_subsequence(a, k)\n        answers.append(subseq[pos - 1])\n\n    return '\\n'.join(map(str, answers))"
    },
    {
        "number": 2042,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    museum = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    starting_positions = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split('\\n')[n+1:n+1+k]]\n\n    def dfs(x: int, y: int, visited: set) -> int:\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        count = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '*':\n                count += dfs(nx, ny, visited)\n        return count\n\n    result = []\n    for x, y in starting_positions:\n        visited = set()\n        result.append(dfs(x-1, y-1, visited))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2043,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    count = 0\n    for i in range(len(t)):\n        if t[:i] in s or t[i:] in s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2044,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    t = [0] * n\n    current_page = 1\n    for i in range(n):\n        if a[i] > m:\n            t[i] = a[i] // m\n            current_page += a[i] // m\n        else:\n            current_page += 1\n            t[i] = 1\n    return \" \".join(map(str, t))"
    },
    {
        "number": 2045,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    n = len(words)\n    result = words[0]\n\n    for i in range(1, n):\n        prefix = \"\"\n        suffix = result\n\n        while suffix and not words[i].startswith(suffix):\n            prefix += suffix[0]\n            suffix = suffix[1:]\n\n        result = result[:-len(suffix)] + words[i][len(suffix):]\n\n    return result\n"
    },
    {
        "number": 2046,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    snacks = list(map(int, stdin.split()[1:]))\n    snack_tower = []\n    \n    for i in range(n):\n        snack_tower.append(snacks[i])\n        while len(snack_tower) > 1 and snack_tower[-1] < snack_tower[-2]:\n            snack_tower[-2], snack_tower[-1] = snack_tower[-1], snack_tower[-2]\n        print(\" \".join(map(str, snack_tower)))\n        snack_tower.pop()\n        \ninput_str = input()\nsolution(input_str) "
    },
    {
        "number": 2047,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n    x_k = [0] * n\n    for i in range(n - 1):\n        x, k = map(int, stdin.readline().strip().split())\n        x_k[x - 1] = k\n\n    for i in range(n):\n        if b[i] < a[i]:\n            return \"NO\"\n\n    for i in range(n):\n        if b[i] > a[i]:\n            b[i] -= a[i]\n            a[i] = 0\n        else:\n            a[i] -= b[i]\n            b[i] = 0\n\n    for i in range(n):\n        if a[i] > 0:\n            if i == 0:\n                return \"NO\"\n            j = i - 1\n            while j >= 0 and b[j] > 0:\n                k = min(b[j], a[i] // x_k[j])\n                b[j] -= k\n                a[i] -= k * x_k[j]\n                if a[i] == 0:\n                    break\n            if a[i] > 0:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2048,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, c = stdin.split('\\n')\n    n = int(n)\n    s = list(map(int, s.split()))\n    c = list(map(int, c.split()))\n\n    min_cost = float('inf')\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if s[i] < s[j] < s[k]:\n                    cost = c[i] + c[j] + c[k]\n                    min_cost = min(min_cost, cost)\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 2049,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    array = list(map(int, stdin.split()[2:]))\n    queries = []\n    for _ in range(m):\n        l, r = map(int, stdin.split()[:2])\n        queries.append((l, r))\n\n    def is_ladder(subarray: List[int]) -> bool:\n        non_decreasing = True\n        non_increasing = True\n        for i in range(1, len(subarray)):\n            if subarray[i] < subarray[i - 1]:\n                non_decreasing = False\n            if subarray[i] > subarray[i - 1]:\n                non_increasing = False\n            if not non_decreasing and not non_increasing:\n                return False\n        return True\n\n    result = []\n    for l, r in queries:\n        subarray = array[l - 1:r]\n        if is_ladder(subarray):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2050,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sets = []\n    for i in range(1, n+1):\n        sets.append([i*k, (i+1)*k, (i+2)*k, (i+3)*k])\n    return str(k*n) + \"\\n\" + \"\\n\".join([\" \".join(map(str, s)) for s in sets])"
    },
    {
        "number": 2051,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    socks_colors = list(map(int, stdin.split()[3:]))\n    instructions = [list(map(int, stdin.split()[3+i*2:3+i*2+2])) for i in range(m)]\n\n    def count_different_colors(instructions: list) -> int:\n        colors = set()\n        for l, r in instructions:\n            colors.add(socks_colors[l-1])\n            colors.add(socks_colors[r-1])\n        return len(colors)\n\n    min_socks_to_change = float('inf')\n    for i in range(k):\n        socks_colors_copy = socks_colors.copy()\n        for j in range(n):\n            if socks_colors[j] == i+1:\n                socks_colors_copy[j] = (i+1) % k + 1\n        if count_different_colors(instructions) == 1:\n            min_socks_to_change = min(min_socks_to_change, socks_colors.count(i+1))\n\n    return min_socks_to_change"
    },
    {
        "number": 2052,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l = map(int, stdin.split()[0:2])\n    stones = list(map(int, stdin.split()[2:]))\n    stones.insert(0, 0)\n    stones.append(w)\n    max_frogs = 0\n\n    for i in range(len(stones) - 1):\n        for j in range(i + 1, len(stones)):\n            if stones[j] - stones[i] <= l:\n                max_frogs += 1\n\n    return str(max_frogs)"
    },
    {
        "number": 2053,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    def swap(arr1, arr2, i, j):\n        arr1[i], arr2[j] = arr2[j], arr1[i]\n\n    def min_swap(a, b):\n        s_a = sum(a)\n        s_b = sum(b)\n        v = abs(s_a - s_b)\n        k = 0\n        swaps = []\n\n        for i in range(len(a)):\n            for j in range(len(b)):\n                swap(a, b, i, j)\n                new_s_a = sum(a)\n                new_s_b = sum(b)\n                new_v = abs(new_s_a - new_s_b)\n\n                if new_v < v:\n                    v = new_v\n                    k = 1\n                    swaps = [(i + 1, j + 1)]\n                elif new_v == v and k < 2:\n                    k += 1\n                    swaps.append((i + 1, j + 1))\n\n                swap(a, b, i, j)\n\n        return v, k, swaps\n\n    v, k, swaps = min_swap(a, b)\n\n    output = [str(v), str(k)]\n    for swap in swaps:\n        output.append(\" \".join(map(str, swap)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 2054,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def craft_shovel(sticks, diamonds):\n        return sticks >= 2 and diamonds >= 1\n\n    def craft_sword(sticks, diamonds):\n        return sticks >= 2 and diamonds >= 1\n\n    def sell_tool(tool):\n        return 1\n\n    def calculate_emeralds(sticks, diamonds):\n        shovels = sticks // 2\n        swords = diamonds // 2\n\n        if shovels > swords:\n            shovels, swords = swords, shovels\n\n        emeralds = 0\n        while shovels > 0 and swords > 0:\n            if craft_shovel(sticks, diamonds):\n                sticks -= 2\n                diamonds -= 1\n                emeralds += sell_tool(\"shovel\")\n                shovels -= 1\n            else:\n                sticks -= 2\n                diamonds -= 1\n                emeralds += sell_tool(\"sword\")\n                swords -= 1\n\n        return emeralds\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        sticks, diamonds = map(int, stdin.readline().split())\n        emeralds = calculate_emeralds(sticks, diamonds)\n        result.append(emeralds)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2055,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = int(stdin.readline())\n    for case in range(cases):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n\n        total_connections = sum(a)\n        total_capacity = sum(b)\n\n        if total_connections > total_capacity:\n            print(\"NO\")\n        else:\n            print(\"YES\")"
    },
    {
        "number": 2056,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def bitwise_operation(i, j):\n        x = a[i]\n        y = a[j]\n        a[i] = x & y\n        a[j] = x | y\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            bitwise_operation(i, j)\n\n    return str(sum(x ** 2 for x in a))"
    },
    {
        "number": 2057,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    notes = [int(x) for x in stdin.split()]\n    rooms = set()\n    for i, note in enumerate(notes):\n        if note == 0:\n            rooms.add(i)\n        else:\n            rooms.add(note)\n            rooms.add(i)\n    return str(len(rooms))"
    },
    {
        "number": 2058,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    hamming_sum = 0\n    for i in range(len(b) - len(a) + 1):\n        substring = b[i:i+len(a)]\n        hamming_sum += sum([int(a[j]) ^ int(substring[j]) for j in range(len(a))])\n    return str(hamming_sum)"
    },
    {
        "number": 2059,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    k = 0\n    while True:\n        is_k_extension = True\n        for i in range(n):\n            for j in range(n):\n                if k * abs(i - j) > min(a[i], a[j]):\n                    is_k_extension = False\n                    break\n            if not is_k_extension:\n                break\n        if is_k_extension:\n            return str(k)\n        k += 1"
    },
    {
        "number": 2060,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(n):\n        x = int(stdin.readline().strip())\n        if x % 3 == 0:\n            result.append(\"YES\")\n        elif x % 7 == 0:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2061,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    map_data = stdin.split('\\n')[1:]\n    lakes = []\n    lake_count = 0\n\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j] or map_data[i][j] == '*':\n            return\n        visited[i][j] = True\n        if map_data[i][j] == '.':\n            lake_count += 1\n            if lake_count == k:\n                return\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                dfs(x, y, visited)\n\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                visited = [[False for _ in range(m)] for _ in range(n)]\n                dfs(i, j, visited)\n                if lake_count == k:\n                    return \"0\\n\" + \"\\n\".join(map_data)\n                lakes.append(visited)\n\n    min_cells = float('inf')\n    for lake in lakes:\n        cells = sum(row.count(False) for row in lake)\n        if cells < min_cells:\n            min_cells = cells\n\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                for lake in lakes:\n                    if lake[i][j]:\n                        map_data[i][j] = '*'\n                        break\n\n    return str(min_cells) + \"\\n\" + \"\\n\".join(map_data)"
    },
    {
        "number": 2062,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, video_cards = stdin.split('\\n')\n    video_cards = [int(x) for x in video_cards.split()]\n    max_power = 0\n    for i in range(len(video_cards)):\n        for j in range(i+1, len(video_cards)):\n            if video_cards[j] % video_cards[i] == 0:\n                total_power = sum(video_cards) - video_cards[i] + video_cards[j]\n                if total_power > max_power:\n                    max_power = total_power\n    return str(max_power)"
    },
    {
        "number": 2063,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, *flowers = map(int, stdin.split())\n    flowers = [0] + flowers\n    for i in range(1, n+1):\n        flowers[i] += flowers[i-1]\n    max_height = 0\n    for i in range(n-w+1):\n        max_height = max(max_height, flowers[i+w] - flowers[i])\n    return str(max_height)"
    },
    {
        "number": 2064,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_number = 0\n    for i in range(1, 10):\n        max_number = max(max_number, i * 7 ** (n - 1))\n    return str(max_number)"
    },
    {
        "number": 2065,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    relations = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:-1]]\n    wishes = list(map(int, stdin.split('\\n')[-1].split()))\n\n    candidates = set()\n    for wish in wishes:\n        candidates.add(wish)\n        for relation in relations:\n            if wish in relation:\n                candidates.add(relation[0])\n\n    if len(candidates) != n:\n        return \"-1\"\n\n    return str(n) + \"\\n\" + \"\\n\".join(map(str, sorted(candidates)))\n\n\ninput_data = \"\"\"3 2\n1 2\n2 3\n1 2 1\"\"\"\noutput = solution(input_data)\nprint(output)\n\ninput_data = \"\"\"4 2\n1 2\n3 4\n1 2 3 3\"\"\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 2066,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    result = []\n\n    for query in queries:\n        if len(query) == 1:\n            result.append(query)\n            continue\n\n        ugly_pairs = []\n        for i in range(len(query) - 1):\n            if abs(ord(query[i]) - ord(query[i + 1])) == 1:\n                ugly_pairs.append((i, i + 1))\n\n        if not ugly_pairs:\n            result.append(query)\n            continue\n\n        for i in range(len(ugly_pairs)):\n            for j in range(i + 1, len(ugly_pairs)):\n                if ugly_pairs[i][0] == ugly_pairs[j][1] - 1 or ugly_pairs[i][1] == ugly_pairs[j][0] + 1:\n                    ugly_pairs[i], ugly_pairs[j] = ugly_pairs[j], ugly_pairs[i]\n\n        new_query = \"\"\n        for i in range(len(query)):\n            if i not in [pair[0] for pair in ugly_pairs] and i not in [pair[1] for pair in ugly_pairs]:\n                new_query += query[i]\n\n        if not new_query:\n            result.append(\"No answer\")\n        else:\n            result.append(new_query)\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2067,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    vertical_spells = set(map(int, stdin.split('\\n')[1:n+1]))\n    horizontal_spells = []\n    for i in range(m):\n        x1, x2, y = map(int, stdin.split('\\n')[n+1+i].split())\n        horizontal_spells.append((x1, x2, y))\n    \n    def is_blocked(x, y):\n        for x1, x2, y1 in horizontal_spells:\n            if x1 <= x <= x2 and y1 == y:\n                return True\n        for x1 in vertical_spells:\n            if x1 == x:\n                return True\n        return False\n    \n    def min_spells_to_remove():\n        count = 0\n        for x in range(1, 10**9):\n            if not is_blocked(x, 1):\n                count += 1\n                break\n        return count\n    \n    return str(min_spells_to_remove())"
    },
    {
        "number": 2068,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    repost_dict = {}\n    for i in range(n):\n        line = stdin.readline().strip()\n        name1, name2 = line.split(\" reposted \")\n        name1 = name1.lower()\n        name2 = name2.lower()\n        if name1 not in repost_dict:\n            repost_dict[name1] = name2\n        else:\n            repost_dict[name1] = repost_dict[name1] + \" \" + name2\n\n    max_length = 0\n    for name in repost_dict:\n        current_length = 0\n        current_name = name\n        while current_name in repost_dict:\n            current_length += 1\n            current_name = repost_dict[current_name]\n        max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 2069,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n    foe_pairs = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2+i*2:2+i*2+2])\n        foe_pairs.append((a-1, b-1))\n\n    def is_valid(interval: tuple) -> bool:\n        for foe_pair in foe_pairs:\n            if foe_pair[0] in interval and foe_pair[1] in interval:\n                return False\n        return True\n\n    valid_intervals = []\n    for i in range(n):\n        for j in range(i, n):\n            if is_valid((i, j)):\n                valid_intervals.append((i, j))\n\n    return str(len(valid_intervals))"
    },
    {
        "number": 2070,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    x_values, s = stdin.split('\\n')\n    x_values = [int(x) for x in x_values.split()]\n\n    # Calculate the sum of values of all letters (except for the first and the last one)\n    sum_values = sum(x_values[1:-1])\n\n    # Initialize variables\n    count = 0\n    n = len(s)\n\n    # Iterate through the string\n    for i in range(n):\n        for j in range(i + 2, n):\n            if s[i] == s[j]:\n                # Check if the substring starts and ends with the same letter\n                if j - i > 1:\n                    # Check if the substring is interesting to B\n                    if s[i] == s[i + 1] == s[j - 1]:\n                        count += 1\n\n    # Calculate the answer\n    answer = count + sum_values\n\n    return str(answer)"
    },
    {
        "number": 2071,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    row1 = list(map(int, stdin.readline().strip().split()))\n    row2 = list(map(int, stdin.readline().strip().split()))\n    \n    def dfs(x, y, visited, weights):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        weights[0] += row1[x]\n        weights[1] += row2[y]\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < n and 0 <= new_y < n:\n                dfs(new_x, new_y, visited, weights)\n                \n    visited = set()\n    weights = [0, 0]\n    dfs(0, 0, visited, weights)\n    return str(weights[0] + weights[1])"
    },
    {
        "number": 2072,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    v = list(map(int, stdin.readline().strip().split()))\n    \n    # Calculate the time needed for each friend to reach the point where all friends meet\n    time = [abs(x[i]) / v[i] for i in range(n)]\n    \n    # Calculate the time needed for all friends to meet at the same point\n    min_time = max(time)\n    \n    return str(min_time)"
    },
    {
        "number": 2073,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    roads = list(map(int, stdin.split()[1:]))\n\n    def is_confusing(roads: list) -> bool:\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                cycle = [i]\n                while not visited[cycle[-1]]:\n                    visited[cycle[-1]] = True\n                    cycle.append(roads[cycle[-1]])\n                if cycle[-1] == i:\n                    return True\n        return False\n\n    count = 0\n    for i in range(2 ** n):\n        flipped_roads = [roads[j] if (i & (1 << j)) else j for j in range(n)]\n        if not is_confusing(flipped_roads):\n            count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2074,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    costs = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    max_cost = float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if costs[i][j] > max_cost:\n                max_cost = costs[i][j]\n    \n    return str(max_cost)"
    },
    {
        "number": 2075,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split('\\n')[1]\n\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for char in sequence:\n            if char == '(':\n                stack.append(char)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def count_valid_sequences(n: int, m: int, s: str) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(m):\n            new_dp = [0] * (n + 1)\n            for j in range(n + 1):\n                if j - s[i] >= 0:\n                    new_dp[j] += dp[j - s[i]]\n                    new_dp[j] %= mod\n                if j >= 1:\n                    new_dp[j] += dp[j - 1]\n                    new_dp[j] %= mod\n            dp = new_dp\n\n        return dp[n]\n\n    valid_sequences = count_valid_sequences(n, m, s)\n    return str(valid_sequences)"
    },
    {
        "number": 2076,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n    for i in range(t):\n        a, b, c = map(int, stdin.split()[1:])\n        if a == 0:\n            result.append(str(b + c))\n        elif b == 0:\n            result.append(str(a + c))\n        elif c == 0:\n            result.append(str(a + b))\n        else:\n            result.append(str(max(a + b + c, a + 2 * b, b + 2 * c)))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2077,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, topics = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[-2:])\n        graph[a].append(b)\n        graph[b].append(a)\n    desired_topics = list(map(int, stdin.split()[-n:]))\n\n    def find_best_topic(visited: set, current: int) -> int:\n        best_topic = float('inf')\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                best_topic = min(best_topic, desired_topics[neighbor - 1])\n        return best_topic\n\n    visited = set()\n    result = []\n    for i in range(1, n + 1):\n        if i not in visited:\n            best_topic = find_best_topic(visited, i)\n            if best_topic == float('inf'):\n                return -1\n            result.append(best_topic)\n            visited.add(i)\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 2078,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    h_segments = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    v_segments = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:n+m+1]]\n    \n    def is_inside(x, y):\n        return 0 <= x < 1000000 and 0 <= y < 1000000\n    \n    def is_intersect(x1, y1, x2, y2, lx, ly, rx, ry):\n        return (min(x1, x2) <= lx <= max(x1, x2) and min(y1, y2) <= ly <= max(y1, y2)) or (min(x1, x2) <= rx <= max(x1, x2) and min(y1, y2) <= ry <= max(y1, y2))\n    \n    def count_pieces(x1, y1, x2, y2):\n        count = 0\n        for h_segment in h_segments:\n            if is_intersect(x1, y1, x2, y2, h_segment[0], h_segment[1], h_segment[0], h_segment[2]):\n                count += 1\n        for v_segment in v_segments:\n            if is_intersect(x1, y1, x2, y2, v_segment[0], v_segment[1], v_segment[0], v_segment[2]):\n                count += 1\n        return count\n    \n    result = 0\n    for h_segment in h_segments:\n        for v_segment in v_segments:\n            if is_inside(h_segment[0], v_segment[1]) and is_inside(h_segment[0], v_segment[2]):\n                result += count_pieces(h_segment[0], v_segment[1], h_segment[0], v_segment[2])\n            elif is_inside(h_segment[1], v_segment[1]) and is_inside(h_segment[1], v_segment[2]):\n                result += count_pieces(h_segment[1], v_segment[1], h_segment[1], v_segment[2])\n            elif is_inside(h_segment[2], v_segment[1]) and is_inside(h_segment[2], v_segment[2]):\n                result += count_pieces(h_segment[2], v_segment[1], h_segment[2], v_segment[2])\n            else:\n                result += 1\n    \n    return str(result)"
    },
    {
        "number": 2079,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    widths = list(map(int, stdin.readline().split()))\n    order = list(stdin.readline())\n\n    introverts = [i for i, x in enumerate(order) if x == '0']\n    extroverts = [i for i, x in enumerate(order) if x == '1']\n\n    seats = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(2):\n            seats[i].append((i, j))\n\n    for i in introverts:\n        min_width = min(widths)\n        min_row = widths.index(min_width)\n        seats[min_row].pop()\n        widths[min_row] += min_width\n\n    for i in extroverts:\n        max_width = max(widths)\n        max_row = widths.index(max_width)\n        seats[max_row].pop()\n        widths[max_row] -= max_width\n\n    result = []\n    for i in order:\n        if i == '0':\n            result.append(seats[introverts.pop(0)][0][0] + 1)\n        else:\n            result.append(seats[extroverts.pop(0)][0][0] + 1)\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2080,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split()[0])\n    result = []\n\n    for i in range(q):\n        n = int(stdin.split()[i + 1])\n        max_edges = n * (n - 1) // 2\n        min_bridges = max_edges // 2\n\n        if min_bridges == 0:\n            result.append(0)\n        else:\n            result.append(min_bridges)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2081,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    imbalance_value = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            imbalance_value += max(a[i:j+1]) - min(a[i:j+1])\n\n    return str(imbalance_value)"
    },
    {
        "number": 2082,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(p, q):\n        return min(a[p - 1], a[q - 1])\n\n    def count_f(p, q):\n        return sum(f(p, x) for x in areas if x != p)\n\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    areas = set(range(1, n + 1))\n\n    total_f = 0\n    for p in areas:\n        for q in areas:\n            if p != q:\n                total_f += count_f(p, q)\n\n    return str(total_f / (n * (n - 1)))"
    },
    {
        "number": 2083,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_mean(a, T, p):\n        mean = 0\n        for t in range(T, len(a) + 1):\n            mean = (mean + a[t - 1]) / c\n        return mean\n\n    def calculate_error(approx, real):\n        return abs(approx - real) / real\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        n, T, c = map(int, lines[0].split())\n        a = list(map(int, lines[1].split()))\n        m = int(lines[2])\n        p = list(map(int, lines[3].split()))\n        return n, T, c, a, m, p\n\n    def main(stdin: str) -> str:\n        n, T, c, a, m, p = parse_input(stdin)\n        real_mean = [calculate_mean(a, T, p[j]) for j in range(m)]\n        approx_mean = [calculate_mean(a, T, p[j]) for j in range(m)]\n        error = [calculate_error(approx_mean[j], real_mean[j]) for j in range(m)]\n\n        output = []\n        for j in range(m):\n            output.append(f\"{real_mean[j]:.5f} {approx_mean[j]:.5f} {error[j]:.5f}\")\n        return \"\\n\".join(output)\n\n    return main(stdin)"
    },
    {
        "number": 2084,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    for i in range(n):\n        if a[i] <= k:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2085,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def value(subsequence):\n        return sum(2 ** i for i, x in enumerate(subsequence) if x & (1 << i))\n\n    max_value = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            subsequence = a[i:j]\n            max_value = max(max_value, value(subsequence))\n\n    return str(max_value)"
    },
    {
        "number": 2086,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, s, f = map(int, stdin.split())\n    max_participants = 0\n    start_hour = 0\n\n    for i in range(s, f + 1):\n        participants = sum(a[max(0, j - i):min(n, j + i + 1):i])\n        if participants > max_participants:\n            max_participants = participants\n            start_hour = i\n\n    return str(start_hour)"
    },
    {
        "number": 2087,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    result = 0\n    for a in range(1, A+1):\n        for b in range(1, B+1):\n            for c in range(1, C+1):\n                result += a * b * c\n    return str(result % 998244353)"
    },
    {
        "number": 2088,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    adjacency_list = [[] for _ in range(n)]\n    for i in range(2, n + 1):\n        parent = int(stdin.readline().strip())\n        adjacency_list[parent - 1].append(i - 1)\n        adjacency_list[i - 1].append(parent - 1)\n\n    def dfs(node: int, parent: int, color: int) -> int:\n        happy_junctions = 1\n        colors = {color}\n        for child in adjacency_list[node]:\n            if child != parent:\n                subtree_colors = dfs(child, node, (color + 1) % 4)\n                happy_junctions += subtree_colors\n                colors.update(subtree_colors)\n        return colors\n\n    min_colors = [0] * (n + 1)\n    min_colors[1] = 1\n    colors = dfs(0, -1, 0)\n    for i in range(2, n + 1):\n        min_colors[i] = len(colors)\n        colors.add((colors.pop() + 1) % 4)\n\n    return \" \".join(map(str, min_colors[1:]))"
    },
    {
        "number": 2089,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    not_connected = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and (i, j) not in roads and (j, i) not in roads:\n                if i == s or i == t or j == s or j == t:\n                    not_connected += 1\n    return str(not_connected)"
    },
    {
        "number": 2090,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    songs = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            t, b = map(int, line.split())\n            songs.append((t, b))\n\n    songs.sort(key=lambda x: x[1])\n    total_pleasure = 0\n    for i in range(k):\n        total_pleasure += songs[i][0]\n\n    return str(total_pleasure * songs[0][1])\n"
    },
    {
        "number": 2091,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_prefix_suffix(s: str, t: str) -> bool:\n        return s.startswith(t) and s.endswith(t)\n\n    def longest_palindrome(s: str) -> str:\n        n = len(s)\n        max_length = 1\n        start = 0\n\n        for i in range(n):\n            for j in range(i, n):\n                if is_palindrome(s[i:j+1]):\n                    if j - i + 1 > max_length:\n                        max_length = j - i + 1\n                        start = i\n        return s[start:start+max_length]\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        s = stdin.readline().strip()\n        t = longest_palindrome(s)\n        a, b = \"\", \"\"\n\n        for i in range(len(s) - len(t) + 1):\n            if is_prefix_suffix(s, s[i:i+len(t)]):\n                a, b = s[:i], s[i+len(t):]\n                break\n\n        result.append(a + b)\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2092,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, k, t = map(int, stdin.split()[:4])\n    soldiers = list(map(int, stdin.split()[4:4+m]))\n    traps = [list(map(int, stdin.split()[i:i+3])) for i in range(4+m, 4+m+k*3, 3)]\n\n    def is_valid(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_disarmed(trap):\n        return trap[1] == 0\n\n    def is_disarmable(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_disarm_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_safe_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_valid_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_move(trap):\n        return trap[1] != 0 and trap[1] != n\n\n    def is_squad_move(trap):\n        return trap[1] != 0 and trap[1] != n\n\n    def is_safe_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_valid_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_squad_move(trap):\n        return trap[1] != 0 and trap[1] != n\n\n    def is_safe_trap_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_valid_trap_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_disarm_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_valid_trap_disarm_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe_trap_disarm_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_disarm_squad_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_valid_trap_disarm_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe_trap_disarm_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_disarm_trap_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_valid_trap_disarm_trap_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe_trap_disarm_trap_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_disarm_trap_disarm_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_valid_trap_disarm_trap_disarm_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe_trap_disarm_trap_disarm_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_trap_disarm_trap_disarm_squad_move(trap):\n        return trap[1] == 0 or trap[1] == n\n\n    def is_valid_trap_disarm_trap_disarm_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def is_safe_trap_disarm_trap_disarm_squad_move(soldier, trap):\n        return soldier >= trap[2]\n\n    def"
    },
    {
        "number": 2093,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *episodes = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if episodes[i] > episodes[j] and episodes[i] % episodes[j] == 0:\n                count += episodes[i] // episodes[j]\n            elif episodes[j] > episodes[i] and episodes[j] % episodes[i] == 0:\n                count += episodes[j] // episodes[i]\n    return str(count)"
    },
    {
        "number": 2094,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def count_suits(h: List[int]) -> int:\n        total_points = sum(h)\n        count = 0\n        for i in range(k):\n            points = sum(h[j] for j in range(n) if (h[j] + i) % k == 1)\n            if points > total_points:\n                count += 1\n        return count\n\n    return str(count_suits(h) % 998244353)"
    },
    {
        "number": 2095,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    good_cars = []\n    for i in range(n):\n        if matrix[i][i] == -1:\n            good_cars.append(i+1)\n\n    return str(len(good_cars)) + '\\n' + ' '.join(map(str, good_cars))"
    },
    {
        "number": 2096,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cubes = list(map(int, stdin.split()[1:]))\n    \n    max_count = 0\n    max_heaps = []\n    \n    for i in range(2**n):\n        heaps = [[] for _ in range(2)]\n        for j in range(n):\n            heaps[i >> j & 1].append(cubes[j])\n        \n        count = len(set([str(heaps[0][k]) + str(heaps[1][k]) for k in range(n)]))\n        \n        if count > max_count:\n            max_count = count\n            max_heaps = heaps\n    \n    result = []\n    for i in range(n):\n        result.append(max_heaps[0][i] if i < len(max_heaps[0]) else 0)\n        result.append(max_heaps[1][i] if i < len(max_heaps[1]) else 0)\n    \n    return str(max_count) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 2097,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i+1].split()))\n\n        steps = 0\n        while sum(a) == 0 or prod(a) == 0:\n            for j in range(n):\n                a[j] += 1\n            steps += 1\n\n        result.append(str(steps))\n\n    return \"\\n\".join(result)\n\ndef"
    },
    {
        "number": 2098,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = []\n    for line in stdin.splitlines()[1:]:\n        a, b = map(int, line.split())\n        edges.append((a, b))\n\n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, node)\n        if len(visited) == n:\n            return True\n        return False\n\n    def find_tree(edges):\n        graph = {i: [] for i in range(1, n + 1)}\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        for i in range(1, n + 1):\n            if dfs(i, set(), None):\n                return True\n        return False\n\n    if find_tree(edges):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2099,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M, T = map(int, stdin.split()[0:3])\n    queries = stdin.split()[3:]\n    queries_time = [datetime.datetime.strptime(query, '%H:%M:%S') for query in queries]\n\n    def is_valid(user_ids: List[int]) -> bool:\n        online_users = defaultdict(list)\n        for i, query_time in enumerate(queries_time):\n            online_users[user_ids[i]].append((query_time, query_time + timedelta(seconds=T)))\n\n        max_online_users = 0\n        for user_id in online_users:\n            online_periods = sorted(online_users[user_id], key=lambda x: x[0])\n            current_online_users = 1\n            for i in range(1, len(online_periods)):\n                if online_periods[i][0] <= online_periods[i - 1][1]:\n                    current_online_users += 1\n                else:\n                    break\n            max_online_users = max(max_online_users, current_online_users)\n\n        return max_online_users <= M\n\n    def find_solution(n: int, M: int, T: int) -> str:\n        user_ids = list(range(1, n + 1))\n        if is_valid(user_ids):\n            return '\\n'.join(map(str, user_ids))\n        else:\n            return \"No solution\"\n\n    return find_solution(n, M, T)"
    },
    {
        "number": 2100,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cupboards = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    left_door_status = cupboards[0][0]\n    right_door_status = cupboards[0][1]\n\n    for i in range(1, n):\n        if cupboards[i][0] != left_door_status:\n            left_door_status = 1 - left_door_status\n        if cupboards[i][1] != right_door_status:\n            right_door_status = 1 - right_door_status\n\n    return str(left_door_status + right_door_status)"
    },
    {
        "number": 2101,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B = map(int, stdin.split()[0].split())\n    r_lengths = list(map(int, stdin.split()[1].split()))\n    g_lengths = list(map(int, stdin.split()[2].split()))\n    b_lengths = list(map(int, stdin.split()[3].split()))\n\n    max_area = 0\n    for i in range(R):\n        for j in range(G):\n            for k in range(B):\n                area = r_lengths[i] * g_lengths[j]\n                max_area = max(max_area, area)\n\n                area = r_lengths[i] * b_lengths[k]\n                max_area = max(max_area, area)\n\n                area = g_lengths[j] * b_lengths[k]\n                max_area = max(max_area, area)\n\n    return str(max_area)"
    },
    {
        "number": 2102,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    strings = list(map(int, stdin.split()[:6]))\n    notes = list(map(int, stdin.split()[6:]))\n    n = len(notes)\n\n    def find_note(note: int) -> tuple:\n        for i in range(6):\n            if note > strings[i]:\n                return i, note - strings[i]\n\n    def find_difference(notes: list) -> int:\n        frets = []\n        for note in notes:\n            string, fret = find_note(note)\n            frets.append((string, fret))\n        return max(frets, key=lambda x: x[1])[1] - min(frets, key=lambda x: x[1])[1]\n\n    return str(find_difference(notes))"
    },
    {
        "number": 2103,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    b = [0] * n\n    for i in range(n):\n        if a[i] == 0:\n            b[i] = 1\n        else:\n            b[i] = a[i] - 1\n\n    return \" \".join(map(str, b))\n\n\ndef"
    },
    {
        "number": 2104,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    if r - l + 1 > 3 * 10**5 or (r - l + 1) % 2 == 0:\n        return \"NO\"\n\n    numbers = list(range(l, r + 1))\n    pairs = []\n    for i in range(len(numbers) // 2):\n        for j in range(i + 1, len(numbers)):\n            if math.gcd(numbers[i], numbers[j]) == 1:\n                pairs.append((numbers[i], numbers[j]))\n\n    if len(pairs) == len(numbers) // 2:\n        result = [\"YES\"]\n        for pair in pairs:\n            result.append(f\"{pair[0]} {pair[1]}\")\n        return \"\\n\".join(result)\n    else:\n        return \"NO\""
    },
    {
        "number": 2105,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().split()\n    t = stdin.readline().split()\n    q = int(stdin.readline())\n    s_t = s + t\n    s_t.sort()\n    result = []\n    for _ in range(q):\n        y = int(stdin.readline())\n        if y == 1:\n            result.append(s_t[0] + s_t[1])\n        else:\n            index = (y - 1) * 2\n            if index >= len(s_t):\n                index -= len(s_t)\n            result.append(s_t[index] + s_t[index + 1])\n    return \"\\n\".join(result)"
    },
    {
        "number": 2106,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split()[0].split())\n    distances = list(map(int, stdin.split('\\n')[1].split()))\n    supplies = list(map(int, stdin.split('\\n')[2].split()))\n\n    fuel_needed = 0\n    time_needed = 0\n    fuel_tank = supplies[0]\n\n    for i in range(m):\n        fuel_needed += distances[i]\n        time_needed += distances[i] / 1\n\n        fuel_tank -= distances[i]\n        if fuel_tank < 0:\n            fuel_tank = 0\n\n        if i < m - 1:\n            fuel_tank += supplies[i + 1]\n            if fuel_tank > fuel_needed:\n                fuel_tank = fuel_needed\n\n        fuel_tank += k * (fuel_needed - fuel_tank)\n\n    return str(time_needed)"
    },
    {
        "number": 2107,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split()[:4])\n    notes = [list(map(int, input().split())) for _ in range(n)]\n    song = list(map(int, input().split()))\n\n    def complexity(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    max_complexity = 0\n    for i in range(s):\n        for j in range(i + 1, s):\n            x1, y1 = None, None\n            x2, y2 = None, None\n            for x in range(n):\n                for y in range(m):\n                    if notes[x][y] == song[i]:\n                        x1, y1 = x, y\n                    if notes[x][y] == song[j]:\n                        x2, y2 = x, y\n            if x1 is not None and x2 is not None:\n                max_complexity = max(max_complexity, complexity(x1, y1, x2, y2))\n\n    return str(max_complexity)"
    },
    {
        "number": 2108,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    n1, n2, n3 = map(int, stdin.split()[2:5])\n    edges = []\n    for i in range(m):\n        u, v = map(int, stdin.split()[5+i*2:7+i*2])\n        edges.append((u, v))\n\n    def dfs(u, label, visited):\n        visited[u] = True\n        if label == 1:\n            n1 -= 1\n        elif label == 2:\n            n2 -= 1\n        elif label == 3:\n            n3 -= 1\n\n        for v in range(1, n+1):\n            if not visited[v] and (u, v) in edges:\n                dfs(v, label, visited)\n\n    def is_valid(visited):\n        for u in range(1, n+1):\n            for v in range(u+1, n+1):\n                if (u, v) in edges and abs(visited[u] - visited[v]) != 1:\n                    return False\n        return True\n\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        dfs(i, 1, visited)\n        if n1 == 0 and n2 == 0 and n3 == 0 and is_valid(visited):\n            result = \"\".join([str(visited[j]) for j in range(1, n+1)])\n            return \"YES\\n\" + result\n\n    return \"NO\""
    },
    {
        "number": 2109,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n\n    first_set = []\n    second_set = []\n    third_set = []\n\n    for num in array:\n        if num < 0:\n            first_set.append(num)\n        elif num > 0:\n            second_set.append(num)\n        else:\n            third_set.append(num)\n\n    return f\"{len(first_set)}\\n{' '.join(map(str, first_set))}\\n{len(second_set)}\\n{' '.join(map(str, second_set))}\\n{len(third_set)}\\n{' '.join(map(str, third_set))}\""
    },
    {
        "number": 2110,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m, k = map(int, stdin.split()[:4])\n    freight_trains = [tuple(map(int, line.split())) for line in stdin.split()[4:]]\n\n    def is_valid_schedule(t: int) -> bool:\n        freight_trains_to_cancel = []\n        for freight_train in freight_trains:\n            if freight_train[1] == 0:\n                if freight_train[0] * m + t >= k:\n                    freight_trains_to_cancel.append(freight_train)\n            else:\n                if freight_train[0] * m + t + freight_train[1] >= k:\n                    freight_trains_to_cancel.append(freight_train)\n        return freight_trains_to_cancel\n\n    min_canceled_trains = n\n    optimal_t = 0\n    for t in range(m // 2):\n        freight_trains_to_cancel = is_valid_schedule(t)\n        if len(freight_trains_to_cancel) < min_canceled_trains:\n            min_canceled_trains = len(freight_trains_to_cancel)\n            optimal_t = t\n\n    return f\"{min_canceled_trains} {optimal_t}\\n\" + \"\\n\".join(map(str, is_valid_schedule(optimal_t)))"
    },
    {
        "number": 2111,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    actions = stdin.split()[2:]\n    chocolate = [[0] * n for _ in range(n)]\n    anti_diagonal = [0] * (2 * n - 1)\n\n    def eat_chocolate(x: int, y: int, direction: str) -> int:\n        count = 0\n        if direction == 'U':\n            while x > 0 and y < n:\n                count += 1\n                x -= 1\n                y += 1\n        else:\n            while x < n and y > 0:\n                count += 1\n                x += 1\n                y -= 1\n        return count\n\n    for i in range(q):\n        x, y, direction = map(int, actions[i * 2:i * 2 + 2])\n        x -= 1\n        y -= 1\n        anti_diagonal[x + y] = i + 1\n        chocolate[x][y] = eat_chocolate(x, y, direction)\n\n    return '\\n'.join(map(str, anti_diagonal[n - 1:]))\n"
    },
    {
        "number": 2112,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x, k, y = map(int, stdin.split()[2:5])\n    a = list(map(int, stdin.split()[5:n+5]))\n    b = list(map(int, stdin.split()[n+5:]))\n\n    mana = 0\n    for i in range(len(a)):\n        if a[i] not in b:\n            return \"-1\"\n        if a[i] == b[0]:\n            break\n        mana += x\n\n    for i in range(len(b)):\n        if a[i] != b[i]:\n            return \"-1\"\n\n    for i in range(len(b)-1):\n        if b[i] > b[i+1]:\n            mana += y\n            b[i], b[i+1] = b[i+1], b[i]\n\n    return str(mana)"
    },
    {
        "number": 2113,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n]]\n\n    def is_bipartite(graph):\n        colors = [-1] * n\n        colors[0] = 0\n        queue = [0]\n\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if colors[neighbor] == -1:\n                    colors[neighbor] = 1 - colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n        return True\n\n    def add_edges(graph, edges):\n        for edge in edges:\n            graph[edge[0]].add(edge[1])\n            graph[edge[1]].add(edge[0])\n\n    max_edges = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            graph = [set() for _ in range(n)]\n            add_edges(graph, edges)\n            graph[i].add(j)\n            graph[j].add(i)\n            if is_bipartite(graph):\n                max_edges += 1\n\n    return str(max_edges)"
    },
    {
        "number": 2114,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"-1\"\n\n    board = []\n    for i in range(1, N * N + 1):\n        row = []\n        for j in range(1, N * N + 1):\n            row.append(i * N + j)\n        board.append(row)\n\n    rook_moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queen_moves = [(1, 1), (1, -1), (-1, 1), (-1, -1), (1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def is_valid_move(x: int, y: int, moves: list) -> bool:\n        for move in moves:\n            new_x, new_y = x + move[0], y + move[1]\n            if 0 <= new_x < N and 0 <= new_y < N:\n                return True\n        return False\n\n    def get_min_move(x: int, y: int, moves: list) -> tuple:\n        min_move = (0, 0)\n        min_value = float('inf')\n        for move in moves:\n            new_x, new_y = x + move[0], y + move[1]\n            if 0 <= new_x < N and 0 <= new_y < N:\n                value = board[new_x][new_y]\n                if value < min_value:\n                    min_move = move\n                    min_value = value\n        return min_move\n\n    def rook_move(x: int, y: int) -> int:\n        vuns = 0\n        visited = set()\n        while True:\n            visited.add((x, y))\n            min_move = get_min_move(x, y, rook_moves)\n            x += min_move[0]\n            y += min_move[1]\n            if (x, y) in visited:\n                break\n            vuns += 1\n        return vuns\n\n    def queen_move(x: int, y: int) -> int:\n        vuns = 0\n        visited = set()\n        while True:\n            visited.add((x, y))\n            min_move = get_min_move(x, y, queen_moves)\n            x += min_move[0]\n            y += min_move[1]\n            if (x, y) in visited:\n                break\n            vuns += 1\n        return vuns\n\n    rook_vuns = rook_move(0, 0)\n    queen_vuns = queen_move(0, 0)\n\n    if rook_vuns < queen_vuns:\n        for row in board:\n            print(\" \".join(map(str, row)))\n    else:\n        print(\"-1\")\n\ninput_str = input()\nsolution(input_str) "
    },
    {
        "number": 2115,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n    result = []\n\n    while True:\n        has_equal_consecutive = False\n        for i in range(len(sequence) - 1):\n            if sequence[i] == sequence[i + 1]:\n                has_equal_consecutive = True\n                if sequence[i] == x:\n                    sequence[i] = x + 1\n                else:\n                    sequence.pop(i)\n                    sequence.pop(i)\n                break\n        if not has_equal_consecutive:\n            break\n\n    return str(len(sequence)) + \"\\n\" + \" \".join(map(str, sequence))\n"
    },
    {
        "number": 2116,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    items = list(map(int, stdin.split()[1:k+1]))\n    customers = [list(map(int, line.split())) for line in stdin.split()[k+1:]]\n\n    def pos(item: int) -> int:\n        return items.index(item) + 1\n\n    total_time = 0\n    for customer in customers:\n        time = sum(pos(item) for item in customer)\n        total_time += time\n\n    return str(total_time)"
    },
    {
        "number": 2117,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, count):\n        visited[start] = True\n        count[0] += 1\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, count)\n\n    def max_planets(graph, K):\n        max_count = 0\n        for i in range(1, len(graph) + 1):\n            count = [0]\n            visited = [False] * (len(graph) + 1)\n            dfs(graph, i, visited, count)\n            if count[0] > max_count:\n                max_count = count[0]\n        return max_count\n\n    N = int(stdin.readline().strip())\n    graph = [[] for _ in range(N + 1)]\n\n    for _ in range(N - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    result = []\n    for K in range(1, N + 1):\n        result.append(max_planets(graph, K))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2118,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > 2 * n - 2:\n        return \"-1\"\n\n    a = [i for i in range(1, n + 1)]\n    count = 0\n\n    def mergesort(a, l, r):\n        nonlocal count\n        if l >= r - 1:\n            return\n\n        mid = (l + r) // 2\n        mergesort(a, l, mid)\n        mergesort(a, mid, r)\n\n        i = l\n        j = mid\n        temp = []\n        while i < mid and j < r:\n            if a[i] <= a[j]:\n                temp.append(a[i])\n                i += 1\n            else:\n                temp.append(a[j])\n                j += 1\n                count += mid - i\n\n        while i < mid:\n            temp.append(a[i])\n            i += 1\n\n        while j < r:\n            temp.append(a[j])\n            j += 1\n\n        a[l:r] = temp\n\n    mergesort(a, 0, n)\n\n    if count != k:\n        return \"-1\"\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 2119,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, l, r = map(int, stdin.split())\n    a_str = str(a)\n    l_str = str(l)\n    r_str = str(r)\n\n    def is_beautiful(partition: List[str]) -> bool:\n        return all(s[0] != '0' for s in partition)\n\n    def is_in_range(partition: List[str]) -> bool:\n        return all(l_str <= s <= r_str for s in partition)\n\n    def count_partitions(a_str: str) -> int:\n        n = len(a_str)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if a_str[j] <= a_str[i]:\n                    dp[i] += dp[j]\n                    dp[i] %= 998244353\n        return dp[-1]\n\n    def count_beautiful_partitions(a_str: str) -> int:\n        n = len(a_str)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if a_str[j] <= a_str[i]:\n                    if is_beautiful(a_str[j:i+1]):\n                        dp[i] += dp[j]\n                        dp[i] %= 998244353\n        return dp[-1]\n\n    def count_in_range_partitions(a_str: str) -> int:\n        n = len(a_str)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if a_str[j] <= a_str[i]:\n                    if is_in_range(a_str[j:i+1]):\n                        dp[i] += dp[j]\n                        dp[i] %= 998244353\n        return dp[-1]\n\n    return str(count_beautiful_partitions(a_str) * count_in_range_partitions(a_str))"
    },
    {
        "number": 2120,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    v = list(map(int, stdin.split()[2:2+n]))\n    ropes = []\n    for i in range(m):\n        ropes.append(tuple(map(int, stdin.split('\\n')[2+n+i].split())))\n\n    def dfs(node, visited):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        total_cost = v[node]\n        for rope in ropes:\n            if rope[0] == node:\n                total_cost += dfs(rope[1], visited)\n        return total_cost\n\n    visited = [False] * n\n    min_cost = float('inf')\n    for i in range(n):\n        min_cost = min(min_cost, dfs(i, visited))\n\n    return str(min_cost)"
    },
    {
        "number": 2121,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[2 + i].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    def dfs(node: int, visited: set) -> int:\n        visited.add(node)\n        min_time = a[node]\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                min_time = min(min_time, dfs(neighbor, visited))\n        return min_time\n\n    max_grade = 0\n    for root in range(n):\n        visited = set()\n        max_grade = max(max_grade, dfs(root, visited))\n\n    return str(max_grade)"
    },
    {
        "number": 2122,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, *request_sequence = map(int, stdin.split())\n    count = 0\n    books_read = set()\n\n    for book_id in request_sequence:\n        if book_id not in books_read:\n            count += 1\n            books_read.add(book_id)\n            if len(books_read) == k:\n                books_read.remove(request_sequence[count - k])\n\n    return str(count)"
    },
    {
        "number": 2123,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, heights = stdin.split()\n    n = int(n)\n    heights = list(map(int, heights.split()))\n\n    min_dollars = 0\n    for i in range(n):\n        min_dollars += max(0, heights[i] - heights[i + 1])\n\n    return str(min_dollars)"
    },
    {
        "number": 2124,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    chats = stdin.split(\"\\n\")\n    t = int(chats[0])\n    result = []\n\n    for i in range(1, t * 2, 2):\n        users = chats[i].split()\n        messages = chats[i + 1].split(\"\\n\")\n        recovered_messages = []\n\n        for message in messages:\n            if \":\" in message:\n                sender, text = message.split(\":\", 1)\n                if sender in users:\n                    recovered_messages.append(f\"{sender}:{text}\")\n            else:\n                recovered_messages.append(f\"?:{message}\")\n\n        if len(recovered_messages) == len(messages):\n            result.append(\"\\n\".join(recovered_messages))\n        else:\n            result.append(\"Impossible\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2125,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    blanket = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid_flag(subrectangle):\n        colors = set(subrectangle[0])\n        for row in subrectangle:\n            if len(set(row)) != len(colors):\n                return False\n        return True\n\n    def get_subrectangles(rectangle):\n        subrectangles = []\n        for i in range(len(rectangle) - 2):\n            for j in range(len(rectangle[0]) - 2):\n                subrectangle = [rectangle[i][j:j + 3], rectangle[i + 1][j:j + 3], rectangle[i + 2][j:j + 3]]\n                subrectangles.append(subrectangle)\n        return subrectangles\n\n    valid_subrectangles = [subrectangle for subrectangle in get_subrectangles(blanket) if is_valid_flag(subrectangle)]\n\n    return str(len(valid_subrectangles))"
    },
    {
        "number": 2126,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.readline().split())\n    front_view = list(map(int, stdin.readline().split()))\n    left_view = list(map(int, stdin.readline().split()))\n    top_view = []\n    for _ in range(n):\n        top_view.append(list(map(int, stdin.readline().split())))\n\n    # Calculate the heights of the object\n    heights = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if top_view[i][j] == 1:\n                heights[i][j] = left_view[j]\n\n    # Calculate the final output\n    output = \"\"\n    for i in range(n):\n        for j in range(m):\n            output += str(heights[i][j]) + \" \"\n        output = output.strip() + \"\\n\"\n\n    return output"
    },
    {
        "number": 2127,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split(\"\\n\")\n    n = int(queries[0])\n    bills = []\n    for i in range(1, n):\n        query = queries[i].split()\n        if query[0] == \"+\":\n            bills.append((int(query[1]), int(query[2])))\n        elif query[0] == \"?\":\n            h, w = int(query[1]), int(query[2])\n            fits = True\n            for bill in bills:\n                if bill[0] > h or bill[1] > w:\n                    fits = False\n                    break\n            print(\"YES\" if fits else \"NO\")"
    },
    {
        "number": 2128,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p_list = stdin.split()\n    n = int(n)\n    p_list = list(map(int, p_list.split()))\n\n    M = 998244353\n    p = 0\n    q = 1\n\n    for i in range(n):\n        p += p_list[i] * q\n        q *= (100 - p_list[i])\n\n        p %= M\n        q %= M\n\n    return str(p)"
    },
    {
        "number": 2129,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_roads(n, m, roads):\n        adj_list = [[] for _ in range(n)]\n        for u, v in roads:\n            adj_list[u - 1].append(v - 1)\n            adj_list[v - 1].append(u - 1)\n        return adj_list\n\n    def count_roads(adj_list):\n        count = [0] * len(adj_list)\n        for i in range(len(adj_list)):\n            for j in adj_list[i]:\n                count[i] += 1\n                count[j] += 1\n        return count\n\n    def find_max_cities(n, m, roads):\n        adj_list = find_roads(n, m, roads)\n        count = count_roads(adj_list)\n        max_cities = 0\n        for i in range(n):\n            for j in range(n):\n                if count[i] == count[j]:\n                    max_cities += 1\n        return max_cities\n\n    def find_oriented_roads(n, m, roads):\n        adj_list = find_roads(n, m, roads)\n        count = count_roads(adj_list)\n        max_cities = 0\n        max_roads = []\n        for i in range(n):\n            for j in range(n):\n                if count[i] == count[j]:\n                    max_cities += 1\n                    max_roads.append((i + 1, j + 1))\n        return max_cities, max_roads\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        roads = []\n        for _ in range(m):\n            u, v = map(int, stdin.readline().split())\n            roads.append((u, v))\n        max_cities = find_max_cities(n, m, roads)\n        result.append(max_cities)\n\n    for max_cities, max_roads in result:\n        print(max_cities)\n        for u, v in max_roads:\n            print(u, v)\n\n    return result"
    },
    {
        "number": 2130,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n    b_set = set(b)\n    for perm in itertools.permutations(b):\n        a = [perm[0]]\n        for i in range(1, n):\n            a.append(a[-1] ^ perm[i])\n        if all(a[i] < a[i + 1] for i in range(n - 1)):\n            return \"Yes\\n\" + \" \".join(map(str, perm))\n    return \"No\"\n\nimport sys\nimport itertools\n\ninput_data = sys.stdin.read()\nprint(solution(input_data)) "
    },
    {
        "number": 2131,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path)\n        path.append(node)\n\n    graph = {i: set() for i in range(1, n + 1)}\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    paths = []\n    for i in range(1, n + 1):\n        visited = set()\n        path = []\n        dfs(i, visited, path)\n        paths.append(path)\n\n    for i in range(len(paths)):\n        for j in range(i + 1, len(paths)):\n            if set(paths[i]) & set(paths[j]):\n                break\n        else:\n            continue\n        break\n    else:\n        return \"No\"\n\n    result = [\"Yes\", str(len(paths))]\n    for path in paths:\n        result.append(\" \".join(map(str, path)))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2132,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = stdin.split('\\n')\n    n = int(events[0])\n    events = events[1:]\n    speed = 0\n    speed_limit = 0\n    overtake_allowed = True\n    no_overtake_allowed = False\n    no_speed_limit = False\n    rule_violations = 0\n\n    for event in events:\n        event_type, event_value = event.split()\n        event_type = int(event_type)\n        event_value = int(event_value)\n\n        if event_type == 1:\n            speed = event_value\n        elif event_type == 2:\n            overtake_allowed = True\n        elif event_type == 3:\n            speed_limit = event_value\n        elif event_type == 4:\n            overtake_allowed = False\n        elif event_type == 5:\n            no_speed_limit = True\n        elif event_type == 6:\n            no_overtake_allowed = True\n\n        if speed > speed_limit and not no_speed_limit:\n            rule_violations += 1\n        if not overtake_allowed and no_overtake_allowed:\n            rule_violations += 1\n\n    return str(rule_violations)"
    },
    {
        "number": 2133,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors, edges = stdin.split('\\n')\n    n = int(n)\n    colors = list(map(int, colors.split()))\n    edges = [list(map(int, edge.split())) for edge in edges.split('\\n')]\n\n    def dfs(node: int, parent: int) -> int:\n        color = colors[node - 1]\n        count = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                count += dfs(neighbor, node)\n        return count if color == 0 else 0\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0] - 1].append(edge[1])\n        graph[edge[1] - 1].append(edge[0])\n\n    min_operations = float('inf')\n    for i in range(1, n + 1):\n        operations = dfs(i, -1)\n        min_operations = min(min_operations, operations)\n\n    return str(min_operations)"
    },
    {
        "number": 2134,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def is_calm(i, j):\n        return (a[i] & (1 << j)) == (a[j] & (1 << j))\n\n    def can_work_together(i, j):\n        return is_calm(i, j) and is_calm(j, i)\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_work_together(i, j):\n                max_sum = max(max_sum, b[i] + b[j])\n\n    return str(max_sum)"
    },
    {
        "number": 2135,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, r1, c1, r2, c2):\n        for i in range(r1, r2 + 1):\n            for j in range(c1, c2 + 1):\n                if grid[i][j] == '#':\n                    return False\n        return True\n\n    def count_ways(grid, r1, c1, r2, c2):\n        count = 0\n        for i in range(r1, r2):\n            for j in range(c1, c2):\n                if grid[i][j] == '.' and grid[i][j + 1] == '.' and is_valid(grid, r1, c1, i, j) and is_valid(grid, r1, c1, i, j + 1):\n                    count += 1\n                if grid[i][j] == '.' and grid[i + 1][j] == '.' and is_valid(grid, r1, c1, i, j) and is_valid(grid, r1, c1, i + 1, j):\n                    count += 1\n        return count\n\n    h, w = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(h)]\n    q = int(stdin.readline())\n\n    for _ in range(q):\n        r1, c1, r2, c2 = map(int, stdin.readline().split())\n        print(count_ways(grid, r1, c1, r2, c2))"
    },
    {
        "number": 2136,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def invert_cell(grid: List[List[str]], row: int, col: int) -> None:\n        if grid[row][col] == '0':\n            grid[row][col] = '1'\n        else:\n            grid[row][col] = '0'\n\n    def is_valid_move(grid: List[List[str]], row: int, col: int, digit: str) -> bool:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return False\n        if grid[row][col] == 'S' or grid[row][col] == 'F':\n            return True\n        return grid[row][col] == digit\n\n    def traverse(grid: List[List[str]], row: int, col: int, digit: str) -> bool:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        if not is_valid_move(grid, row, col, digit):\n            return False\n        if grid[row][col] == 'S' or grid[row][col] == 'F':\n            return False\n\n        if grid[row][col] == '0':\n            digit = '0'\n        else:\n            digit = '1'\n\n        if traverse(grid, row + 1, col, digit):\n            return True\n        if traverse(grid, row, col + 1, digit):\n            return True\n        if traverse(grid, row - 1, col, digit):\n            return True\n        if traverse(grid, row, col - 1, digit):\n            return True\n\n        return False\n\n    test_cases = stdin.split('\\n')\n    test_cases = test_cases[1:]\n    result = []\n\n    for test_case in test_cases:\n        n = int(test_case)\n        grid = [['S'] + ['0'] * (n - 1) + ['F']]\n        for i in range(1, n):\n            grid.append(['0'] * i + ['1'] * (n - 1 - i) + ['0'])\n        grid.append(['0'] * (n - 1) + ['S'] + ['0'])\n\n        inverted_cells = []\n        for i in range(2):\n            row = random.randint(1, n - 2)\n            col = random.randint(1, n - 2)\n            while (row, col) in inverted_cells or (row, col) == (0, 0) or (row, col) == (n - 1, n - 1):\n                row = random.randint(1, n - 2)\n                col = random.randint(1, n - 2)\n            invert_cell(grid, row, col)\n            inverted_cells.append((row, col))\n\n        if traverse(grid, 0, 0, '0'):\n            result.append('0')\n        else:\n            result.append('1')\n\n        for row, col in inverted_cells:\n            print(row, col)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2137,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    ghosts = []\n    for i in range(n):\n        x, Vx, Vy = map(int, stdin.split()[3:])\n        ghosts.append((x, Vx, Vy))\n\n    def get_collisions(ghosts):\n        collisions = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                xi, Vxi, Vyi = ghosts[i]\n                xj, Vxj, Vyj = ghosts[j]\n                t = (xi - xj) / (Vxj - Vxi)\n                if t > 0:\n                    collisions.append((i, j, t))\n        return collisions\n\n    def get_experience(ghosts, collisions):\n        experience = 0\n        for i, j, t in collisions:\n            experience += 2\n        return experience\n\n    collisions = get_collisions(ghosts)\n    experience = get_experience(ghosts, collisions)\n    return str(experience)"
    },
    {
        "number": 2138,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, degrees = stdin.split('\\n')\n    n = int(n)\n    degrees = [int(d) for d in degrees.split()]\n\n    # Create a dictionary to store the edges\n    edges = {}\n\n    # Iterate through the degrees\n    for i in range(n):\n        for j in range(i + 1, n):\n            if degrees[i] == degrees[j]:\n                # Add the edge to the dictionary\n                if degrees[i] not in edges:\n                    edges[degrees[i]] = []\n                edges[degrees[i]].append((i + 1, j + 1))\n\n    # Print the number of edges\n    print(sum([len(edge) for edge in edges.values()]))\n\n    # Print the edges\n    for edge in edges.values():\n        for e in edge:\n            print(e[0], e[1])"
    },
    {
        "number": 2139,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if \"bear\" in s[i:j]:\n                count += 1\n    return count"
    },
    {
        "number": 2140,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m, *a_i = stdin.split()\n    a_i = [int(i) for i in a_i]\n    for i in range(m):\n        s = s[:a_i[i]-1] + s[a_i[i]-1:][::-1] + s[a_i[i]:]\n    return s"
    },
    {
        "number": 2141,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row.append(\"W\")\n            else:\n                row.append(\"B\")\n        board.append(row)\n    return \"\\n\".join([\"\".join(row) for row in board])"
    },
    {
        "number": 2142,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(a: list, b: list) -> bool:\n        i = j = 0\n        while i < len(a) and j < len(b):\n            if a[i] == b[j]:\n                i += 1\n            j += 1\n        return i == len(a)\n\n    def find_subsequence(a: list, b: list) -> list:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a) + 1):\n                subsequence = a[i:j]\n                if is_subsequence(subsequence, b):\n                    return subsequence\n        return []\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n\n        subsequence = find_subsequence(a, b)\n        if subsequence:\n            print(\"YES\")\n            print(len(subsequence), *subsequence)\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2143,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sweets = list(map(int, stdin.split()[1:]))\n    sweets.sort()\n    max_children = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if sweets[i] + sweets[j] != sweets[j] + sweets[i+1]:\n                max_children += 1\n    return str(max_children)"
    },
    {
        "number": 2144,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def count_x(a, m):\n        count = 0\n        for x in range(m):\n            if gcd(a, m) == gcd(a + x, m):\n                count += 1\n        return count\n\n    T = int(stdin.readline())\n    result = []\n    for _ in range(T):\n        a, m = map(int, stdin.readline().split())\n        result.append(count_x(a, m))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2145,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    for _ in range(T):\n        x, y = map(int, stdin.readline().strip().split())\n        if x == y:\n            print(\"YES\")\n        elif x % 2 == 0 and x > 1:\n            if y == 3 * x // 2:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        elif x > 1:\n            if y == x - 1:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2146,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    shortcuts = list(map(int, stdin.split()[1:]))\n    \n    m = [0] * n\n    for i in range(1, n):\n        m[i] = min(m[j] + abs(j - i) for j in range(i) if shortcuts[j] == i)\n    \n    return \" \".join(map(str, m))"
    },
    {
        "number": 2147,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rules = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(rule_order: list) -> bool:\n        used_servers = set()\n        for rule_index in rule_order:\n            a, b, c = rules[rule_index - 1]\n            used_servers.add(a)\n            used_servers.add(b)\n            used_servers.add(c)\n            if len(used_servers) > n:\n                return False\n        return True\n\n    valid_orders = []\n    for permutation in itertools.permutations(range(1, 4 * n + 1)):\n        if is_valid(permutation):\n            valid_orders.append(permutation)\n\n    if not valid_orders:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(str(rule_index) for rule_index in valid_orders[0])"
    },
    {
        "number": 2148,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n    y = [10**100] * n\n\n    for i in range(n):\n        x_i = x[i]\n        y_i = 10**100\n        while y_i > 0:\n            y_i = y_i - r / (x_i * 2)\n            if y_i < 0:\n                y_i = 0\n            for j in range(i):\n                if abs(x_i - x[j]) < r and abs(y_i - y[j]) < r:\n                    y_i = y[j] - r / (x_i * 2)\n                    if y_i < 0:\n                        y_i = 0\n                    break\n        y[i] = y_i\n\n    return \" \".join(map(str, y))\n"
    },
    {
        "number": 2149,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    h = list(map(int, stdin.split()[2:]))\n    total_points = 0\n    for i in range(n):\n        total_points += h[i]\n    total_points = total_points % 998244353\n    return str(total_points)"
    },
    {
        "number": 2150,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n    a = [0] * n\n    a[0] = 0\n    for i in range(1, n):\n        a[i] = b[i] + a[i-1]\n    return \" \".join(map(str, a))"
    },
    {
        "number": 2151,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split()[0])\n    result = []\n\n    for i in range(q):\n        n = int(stdin.split(\"\\n\")[1 + i * 2].split()[0])\n        s = stdin.split(\"\\n\")[2 + i * 2]\n\n        if n < 2:\n            result.append(\"NO\")\n            continue\n\n        parts = []\n        current_part = [s[0]]\n\n        for j in range(1, n):\n            if int(s[j]) < int(s[j - 1]):\n                parts.append(\"\".join(current_part))\n                current_part = [s[j]]\n            else:\n                current_part.append(s[j])\n\n        parts.append(\"\".join(current_part))\n\n        if len(parts) < 2:\n            result.append(\"NO\")\n        else:\n            result.append(\"YES\")\n            result.append(str(len(parts)))\n            result.append(\" \".join(parts))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2152,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a_p = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    a_p.sort(key=lambda x: x[1])\n    total_cost = 0\n    for i in range(n):\n        total_cost += a_p[i][0] * a_p[i][1]\n    return str(total_cost)"
    },
    {
        "number": 2153,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    def is_discrete(i, j):\n        if i + 1 == j:\n            return True\n        max_height = max(heights[i + 1:j])\n        min_height = min(heights[i + 1:j])\n        if max_height < min_height:\n            return True\n        max_height = max(heights[i:j])\n        min_height = min(heights[i:j])\n        if max_height < min_height:\n            return True\n        return False\n\n    jumps = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if is_discrete(i, j):\n                jumps += 1\n\n    return str(jumps)"
    },
    {
        "number": 2154,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    prices = list(map(int, stdin.split()[1:]))\n\n    # Initialize variables\n    max_profit = 0\n    min_price = prices[0]\n\n    # Iterate through the prices\n    for i in range(1, N):\n        # Update the minimum price\n        min_price = min(min_price, prices[i])\n\n        # Calculate the profit if we sell on this day\n        profit = prices[i] - min_price\n\n        # Update the maximum profit\n        max_profit = max(max_profit, profit)\n\n    return str(max_profit)"
    },
    {
        "number": 2155,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    n = int(math.sqrt(t))\n    if n * n != t:\n        return \"-1\"\n\n    matrix = [[0] * n for _ in range(n)]\n    zero_coords = (0, 0)\n\n    for i in range(t):\n        if a[i] == 0:\n            zero_coords = (i // n, i % n)\n        else:\n            matrix[i // n][i % n] = a[i]\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                continue\n            matrix[i][j] = abs(i - zero_coords[0]) + abs(j - zero_coords[1])\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                return f\"{n} {n}\\n{i+1} {j+1}\"\n\n    return \"-1\""
    },
    {
        "number": 2156,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, q = map(int, stdin.split('\\n')[0].split())\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def f(subsequence):\n        subsequence_length = len(subsequence)\n        while subsequence_length > 1:\n            new_subsequence = []\n            for i in range(0, subsequence_length, 2):\n                if i + 1 < subsequence_length:\n                    new_subsequence.append((subsequence[i] + subsequence[i + 1]) % 10)\n            subsequence = new_subsequence\n            subsequence_length = len(subsequence)\n        return subsequence[0]\n\n    results = []\n    for query in queries:\n        subsequence = sequence[query[0] - 1:query[1]]\n        results.append(f(subsequence))\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 2157,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    array = list(map(int, stdin.split()[2:]))\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.split()[2:])\n        queries.append((l, r))\n\n    # Your solution here\n    return str(max_sum)"
    },
    {
        "number": 2158,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    connections = {}\n    for line in stdin.split('\\n')[1:]:\n        u, v, c = map(int, line.split())\n        connections[(u, v)] = c\n        connections[(v, u)] = c\n\n    def dfs(node, visited, cost):\n        if node in visited:\n            return 0\n        visited.add(node)\n        max_cost = 0\n        for neighbor in connections:\n            if neighbor[0] == node:\n                max_cost = max(max_cost, dfs(neighbor[1], visited, cost + connections[neighbor]))\n        return max_cost\n\n    return str(dfs(0, set(), 0))"
    },
    {
        "number": 2159,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    colors = list(map(int, stdin.splitlines()[1].split()))\n    count = [0] * n\n\n    for i in range(n):\n        for j in range(i, n):\n            color_count = {}\n            for k in range(i, j + 1):\n                if colors[k] not in color_count:\n                    color_count[colors[k]] = 1\n                else:\n                    color_count[colors[k]] += 1\n            dominant_color = max(color_count, key=color_count.get)\n            count[dominant_color - 1] += 1\n\n    return \" \".join(map(str, count))"
    },
    {
        "number": 2160,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n\n    def count_scenarios(start: int, end: int, questions: List[int]) -> int:\n        if not questions:\n            return 1 if start == end else 0\n\n        question = questions[0]\n        count = 0\n\n        if start == question - 1 or start == question:\n            count += count_scenarios(start, end, questions[1:])\n\n        if start == question + 1 or start == question:\n            count += count_scenarios(start, end, questions[1:])\n\n        if start == end - 1 or start == end:\n            count += count_scenarios(start, end, questions[1:])\n\n        return count\n\n    return count_scenarios(1, n, x)"
    },
    {
        "number": 2161,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    phone_books = stdin.split('\\n')[1:]\n\n    friends = {}\n\n    for entry in phone_books:\n        name, *numbers = entry.split()\n        numbers = list(dict.fromkeys(numbers))\n\n        for number in numbers:\n            if number in friends:\n                friends[number].append(name)\n            else:\n                friends[number] = [name]\n\n    result = []\n    for number, names in friends.items():\n        if len(names) == 1:\n            result.append(f\"{names[0]} 1 {number}\")\n        else:\n            result.append(f\"{names[0]} {len(names)} {' '.join(names)}\")\n\n    return str(len(result)) + '\\n' + '\\n'.join(result)"
    },
    {
        "number": 2162,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k1, k2, k3 = map(int, stdin.split()[0].split())\n    a1 = list(map(int, stdin.split()[1].split()))\n    a2 = list(map(int, stdin.split()[2].split()))\n    a3 = list(map(int, stdin.split()[3].split()))\n\n    # Check if the input is valid\n    if len(a1) != k1 or len(a2) != k2 or len(a3) != k3:\n        return \"Invalid input\"\n\n    # Check if the problems are unique\n    problems = a1 + a2 + a3\n    if len(problems) != len(set(problems)):\n        return \"Invalid input\"\n\n    # Check if the problems are in the correct range\n    if not all(1 <= x <= len(problems) for x in problems):\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a1 != problems[:k1]:\n        return \"Invalid input\"\n\n    # Check if the second contestant has the remaining k2 problems\n    if a2 != problems[k1:k1+k2]:\n        return \"Invalid input\"\n\n    # Check if the third contestant has the remaining k3 problems\n    if a3 != problems[k1+k2:]:\n        return \"Invalid input\"\n\n    # Check if the first contestant has the first k1 problems\n    if a"
    },
    {
        "number": 2163,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total = 0\n    mod = 10**9 + 7\n\n    for i in range(1, m + 1):\n        total += pow(2, m - i, mod)\n        total %= mod\n\n    return str(total)"
    },
    {
        "number": 2164,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_prefix_suffix(s: str, t: str) -> bool:\n        return s.startswith(t) and s.endswith(t)\n\n    def longest_palindrome(s: str) -> str:\n        n = len(s)\n        longest = \"\"\n        for i in range(n):\n            for j in range(i, n):\n                substring = s[i:j+1]\n                if is_palindrome(substring) and len(substring) > len(longest) and is_prefix_suffix(s, substring):\n                    longest = substring\n        return longest\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        s = stdin.readline().strip()\n        result.append(longest_palindrome(s))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2165,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2*n]))\n    t = list(map(int, stdin.split()[2*n:]))\n    \n    x = [0] * n\n    for i in range(n):\n        if sum(x) == T:\n            break\n        x[i] = (T - sum(t[j] * x[j] for j in range(i))) / (T - sum(t[j] * x[j] for j in range(i+1)))\n    \n    return f\"{max(x):.6f}\""
    },
    {
        "number": 2166,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    permutation = list(map(int, stdin.split()[1:]))\n\n    def count_permutations(n: int, permutation: list) -> int:\n        count = 0\n        for i in range(n):\n            if permutation[i] == -1:\n                continue\n            for j in range(i + 1, n):\n                if permutation[j] == -1:\n                    continue\n                if i != j and permutation[i] == permutation[j]:\n                    continue\n                count += 1\n        return count\n\n    return str(count_permutations(n, permutation) % 1000000007)"
    },
    {
        "number": 2167,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *arr = map(int, stdin.split())\n    arr.sort()\n    max_count = 0\n    count = 1\n    for i in range(1, n):\n        if arr[i] == arr[i-1]:\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 1\n    return str(max_count)"
    },
    {
        "number": 2168,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    companies = []\n    for i in range(1, n+1):\n        company = stdin.split('\\n')[i].split()\n        companies.append([int(x) for x in company])\n\n    total_increase = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            max_salary_diff = max(companies[i][1:]) - max(companies[j][1:])\n            if max_salary_diff == 0:\n                total_increase += max(companies[i][1:])\n                companies[i+j] = companies[i] + companies[j]\n                companies[i] = []\n                companies[j] = []\n                break\n\n    return str(total_increase)"
    },
    {
        "number": 2169,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_square(x, y, grid):\n        return grid[x][y]\n\n    def set_square(x, y, value, grid):\n        grid[x][y] = value\n\n    def is_valid_move(x, y, grid, target_value):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and get_square(x, y, grid) == target_value\n\n    def move_piece(x, y, grid, target_value, magic_points):\n        new_x, new_y = x, y\n        while is_valid_move(new_x, new_y, grid, target_value):\n            new_x, new_y = new_x + 1, new_y + 1\n        magic_points += abs(new_x - x) + abs(new_y - y)\n        set_square(x, y, target_value, grid)\n        return magic_points\n\n    def process_test(grid, start_x, start_y, target_value, magic_points):\n        magic_points += move_piece(start_x, start_y, grid, target_value, magic_points)\n        return magic_points\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        h, w, d = map(int, lines[0].split())\n        grid = [list(map(int, line.split())) for line in lines[1:-1]]\n        q = int(lines[-1])\n        tests = []\n        for i in range(q):\n            l, r = map(int, lines[-q + i].split())\n            tests.append((l, r))\n        return h, w, d, grid, q, tests\n\n    h, w, d, grid, q, tests = read_input(stdin)\n    results = []\n    for test in tests:\n        start_x, start_y = next((x, y) for x in range(len(grid)) for y in range(len(grid[0])) if get_square(x, y, grid) == test[0])\n        magic_points = 0\n        magic_points = process_test(grid, start_x, start_y, test[1], magic_points)\n        results.append(magic_points)\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2170,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    mod = 10**9 + 7\n\n    for i in range(1, M+1):\n        for j in range(i+1, M+1):\n            for k in range(j+1, M+1):\n                for l in range(k+1, M+1):\n                    if i != j and i != k and i != l and j != k and j != l and k != l:\n                        count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 2171,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"yes\"\n    elif a == 1:\n        return \"yes\"\n    elif a == 2:\n        return \"no\"\n    elif a == 3:\n        return \"yes\"\n    elif a == 6:\n        return \"yes\"\n    elif a == 7:\n        return \"yes\"\n    elif a == 10:\n        return \"no\"\n    else:\n        return \"no\""
    },
    {
        "number": 2172,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    words = {}\n    for i in range(m):\n        a, b = stdin.split()[2*i:2*(i+1)]\n        words[a] = b\n        words[b] = a\n    \n    lecture = stdin.split()[-n:]\n    result = []\n    for word in lecture:\n        if word in words:\n            result.append(words[word])\n        else:\n            result.append(word)\n    \n    return \" \".join(result)"
    },
    {
        "number": 2173,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, ratings = stdin.split('\\n')\n    n = int(n)\n    ratings = list(map(int, ratings.split()))\n\n    ratings.sort(reverse=True)\n    total_rating = sum(ratings)\n    result = [0] * n\n\n    for i in range(n):\n        if total_rating >= ratings[i]:\n            result[i] = ratings[i]\n            total_rating -= ratings[i]\n        else:\n            result[i] = total_rating\n            break\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2174,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    moves = 0\n    for i in range(n):\n        if sequence[i] != i + 1:\n            moves += abs(sequence[i] - (i + 1))\n\n    return str(moves)"
    },
    {
        "number": 2175,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, vessels, m = map(int, stdin.split('\\n')[0].split())\n    vessels = list(map(int, stdin.split('\\n')[1].split()))\n    queries = stdin.split('\\n')[2:]\n\n    water_levels = [0] * n\n\n    for query in queries:\n        query_type, *args = query.split()\n        if query_type == \"1\":\n            p, x = map(int, args)\n            water_levels[p - 1] += x\n            if p < n:\n                overflow = min(water_levels[p] - vessels[p], 0)\n                water_levels[p] -= overflow\n                water_levels[p + 1] += overflow\n        elif query_type == \"2\":\n            k = int(args[0])\n            print(water_levels[k - 1])"
    },
    {
        "number": 2176,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = []\n    for i in range(1, n+1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        s.append((a, b))\n\n    def is_good(s: list) -> bool:\n        first_elements = [x[0] for x in s]\n        second_elements = [x[1] for x in s]\n        return not (sorted(first_elements) == first_elements or sorted(second_elements) == second_elements)\n\n    def permute(s: list, p: list) -> list:\n        return [s[p[i]-1] for i in range(len(p))]\n\n    def count_good_permutations(s: list) -> int:\n        count = 0\n        for p in permutations(list(range(1, n+1))):\n            if is_good(permute(s, p)):\n                count += 1\n        return count\n\n    return str(count_good_permutations(s) % 998244353)"
    },
    {
        "number": 2177,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def conc(a: int, b: int) -> str:\n        return str(a) + str(b)\n\n    def is_valid(a: int, b: int) -> bool:\n        return a * b + a + b == int(conc(a, b))\n\n    def count_pairs(A: int, B: int) -> int:\n        count = 0\n        for a in range(1, A + 1):\n            for b in range(1, B + 1):\n                if is_valid(a, b):\n                    count += 1\n        return count\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        A, B = map(int, stdin.readline().split())\n        result.append(count_pairs(A, B))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2178,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n    \n    result = []\n    for i in range(n):\n        if b[i] in a:\n            index = a.index(b[i])\n            result.append(index + 1)\n            a = a[index + 1:]\n        else:\n            result.append(0)\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 2179,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, u = map(int, stdin.split()[:3])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[3:-1]]\n    u -= 1\n\n    def find_shortest_path_tree(graph: List[List[int]], start: int) -> Tuple[int, List[int]]:\n        visited = [False] * len(graph)\n        distances = [float('inf')] * len(graph)\n        parents = [-1] * len(graph)\n\n        distances[start] = 0\n        queue = [start]\n\n        while queue:\n            current = queue.pop(0)\n            visited[current] = True\n\n            for neighbor, weight in enumerate(graph[current]):\n                if not visited[neighbor] and distances[current] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[current] + weight\n                    parents[neighbor] = current\n                    queue.append(neighbor)\n\n        return sum(distances), [i for i, parent in enumerate(parents) if parent != -1]\n\n    def find_minimum_tree(graph: List[List[int]]) -> int:\n        min_weight = float('inf')\n        min_tree = []\n\n        for i in range(len(graph)):\n            if i != u:\n                weight, tree = find_shortest_path_tree(graph, i)\n                if weight < min_weight:\n                    min_weight = weight\n                    min_tree = tree\n\n        return min_weight, min_tree\n\n    graph = [[0] * n for _ in range(n)]\n\n    for u, v, w in edges:\n        u -= 1\n        v -= 1\n        graph[u][v] = w\n        graph[v][u] = w\n\n    min_weight, min_tree = find_minimum_tree(graph)\n    min_tree = [i + 1 for i in min_tree]\n\n    return f\"{min_weight}\\n{' '.join(map(str, min_tree))}\"\n"
    },
    {
        "number": 2180,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    max_coders = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'C'\n                if is_valid(board, i, j):\n                    max_coders += 1\n                board[i][j] = '.'\n\n    return str(max_coders) + '\\n' + '\\n'.join([''.join(row) for row in board])\n\ndef"
    },
    {
        "number": 2181,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(float, stdin.split())\n    n = int(input())\n    for i in range(1, n + 1):\n        x = a * i * d\n        y = 0\n        print(f\"{x:.4f} {y:.4f}\")"
    },
    {
        "number": 2182,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = stdin.split('\\n')[1:]\n\n    for i in range(n):\n        number = numbers[i]\n        if len(number) > 2 and number[-2:] == '00':\n            number = number[:-2]\n        if len(number) > 1 and number[0] == '0':\n            number = number[1:]\n        if len(number) % 2 == 1:\n            number = '0' + number\n        if len(number) > 1 and number[0] == '0':\n            number = number[1:]\n        if len(number) % 2 == 1:\n            number = '0' + number\n\n        if len(number) % 2 == 0:\n            for j in range(len(number) // 2):\n                if int(number[2 * j:2 * j + 2]) % 60 != 0:\n                    print(\"cyan\")\n                    break\n            else:\n                print(\"red\")\n        else:\n            print(\"cyan\")"
    },
    {
        "number": 2184,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_truth_table(table: str) -> str:\n        x = table[0] == '1'\n        y = table[1] == '1'\n        z = table[2] == '1'\n        return 'x' if x else '!x' if not (x or y or z) else '(x|y&z)' if y and z else '(x|y)' if y else '(x|z)'\n\n    def parse_expression(expression: str) -> str:\n        stack = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                while stack and stack[-1] != '(':\n                    yield stack.pop()\n                stack.pop()\n            else:\n                while stack and stack[-1] == '(':\n                    yield stack.pop()\n                stack.append(char)\n        while stack:\n            yield stack.pop()\n\n    def merge_expressions(expressions: List[str]) -> str:\n        def merge(left: str, right: str) -> str:\n            if left == right:\n                return left\n            if left == 'x':\n                return right\n            if right == 'x':\n                return left\n            if left == 'y':\n                return right\n            if right == 'y':\n                return left\n            if left == 'z':\n                return right\n            if right == 'z':\n                return left\n            return '(' + left + '|' + right + ')'\n\n        expressions = list(parse_expression(expressions[0]))\n        for expression in expressions[1:]:\n            expression = list(parse_expression(expression))\n            while expression:\n                if not expressions or expressions[-1] == '(':\n                    expressions.append(expression.pop(0))\n                else:\n                    expressions[-1] = merge(expressions[-1], expression.pop(0))\n        return ''.join(expressions)\n\n    n = int(stdin.readline())\n    expressions = [parse_truth_table(stdin.readline()[:8]) for _ in range(n)]\n    return '\\n'.join(merge_expressions(expressions))\n\ninput_data = '''4\n00110011\n00000111\n11110000\n00011111'''\nprint(solution(input_data)) "
    },
    {
        "number": 2185,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(cases), 4):\n        n = int(cases[i])\n        a = list(map(int, cases[i+1].split()))\n        b = list(map(int, cases[i+2].split()))\n\n        if a == b:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2186,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    strings = stdin.split('\\n')[1:n+1]\n    queries = stdin.split('\\n')[n+1:]\n\n    for query in queries:\n        found = False\n        for string in strings:\n            if len(string) == len(query) and string != query and string[:i] + query[i+1:] == query[:i] + query[i:]:\n                found = True\n                break\n        print(\"YES\" if found else \"NO\")"
    },
    {
        "number": 2187,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_operations(a: List[int]) -> int:\n        count = 0\n        for i in range(len(a) - 1):\n            if a[i] >= a[i + 1]:\n                count += a[i] - a[i + 1] + 1\n                a[i + 1] = a[i]\n        return count\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(min_operations(a))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2188,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_good(sequence: List[int]) -> bool:\n        for i in range(len(sequence) - 1):\n            if sequence[i] < sequence[i + 1]:\n                return False\n        return True\n\n    def find_good_sequence(pairs: List[Tuple[int, int]]) -> List[int]:\n        sequence = []\n        for pair in pairs:\n            sequence.extend(pair)\n        sequence.sort()\n        for i in range(len(sequence) - 1):\n            if sequence[i] < sequence[i + 1]:\n                sequence[i], sequence[i + 1] = sequence[i + 1], sequence[i]\n        return sequence\n\n    def find_largest_subset(pairs: List[Tuple[int, int]]) -> List[int]:\n        sequence = find_good_sequence(pairs)\n        if is_good(sequence):\n            return list(range(1, 2 * n + 1))\n        else:\n            for i in range(len(sequence) - 1):\n                if sequence[i] < sequence[i + 1]:\n                    sequence[i], sequence[i + 1] = sequence[i + 1], sequence[i]\n                    if is_good(sequence):\n                        return list(range(1, 2 * n + 1))\n            return []\n\n    largest_subset = find_largest_subset(pairs)\n    return str(len(largest_subset)) + '\\n' + ' '.join(map(str, largest_subset))"
    },
    {
        "number": 2189,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0] - 1].append(edge[1] - 1)\n\n    # Find the topological order\n    visited = [False] * n\n    order = []\n\n    def dfs(v: int) -> None:\n        visited[v] = True\n        for u in adj_list[v]:\n            if not visited[u]:\n                dfs(u)\n        order.append(v)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    # Assign labels\n    labels = [-1] * n\n    for i in range(n):\n        labels[order[i]] = i + 1\n\n    return \" \".join(map(str, labels))"
    },
    {
        "number": 2190,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            x = a[i] * a[j]\n            if x**(1/k) == int(x**(1/k)):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2191,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    result = []\n    \n    for x in range(1, n+1):\n        count = 0\n        for i in range(n-x+1):\n            if s[i:i+x].count('0') >= x:\n                count += 1\n        result.append(count)\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 2192,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    W = [list(map(float, line.split())) for line in stdin.split('\\n')[1:]]\n\n    A = [[0] * n for _ in range(n)]\n    B = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            A[i][j] = W[i][j]\n            B[i][j] = -W[i][j]\n            A[j][i] = A[i][j]\n            B[j][i] = B[i][j]\n\n    return '\\n'.join([' '.join(map(lambda x: f\"{x:.8f}\", row)) for row in A]) + '\\n' + '\\n'.join([' '.join(map(lambda x: f\"{x:.8f}\", row)) for row in B])"
    },
    {
        "number": 2193,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v, t = map(int, stdin.split()[2:5])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n    \n    def dfs(city, visited, path, color):\n        if city == n:\n            return path\n        for neighbor, t in graph[city]:\n            if neighbor not in visited and (color[neighbor] == 0 or t == color[neighbor]):\n                visited.add(neighbor)\n                path.append(neighbor)\n                if dfs(neighbor, visited, path, color):\n                    return path\n                path.pop()\n                visited.remove(neighbor)\n        return False\n    \n    for i in range(n):\n        color = [0] * (n+1)\n        color[i+1] = 1\n        path = [1]\n        visited = set([1])\n        if dfs(1, visited, path, color):\n            return str(len(path)-1) + \"\\n\" + \"\".join(map(str, color[1:]))\n    return \"-1\""
    },
    {
        "number": 2194,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    assert len(a) == 2**n\n\n    def replace(x: int, k: int) -> None:\n        a[x-1] = k\n\n    def reverse(k: int) -> None:\n        start = 2**k\n        for i in range(1, 2**(n-k)):\n            a[start-1:start+2**k-1] = reversed(a[start-1:start+2**k-1])\n            start += 2**k\n\n    def swap(k: int) -> None:\n        for i in range(1, 2**(n-k)):\n            a[2*(2**k)*(i-1):2*(2**k)*i], a[2*(2**k)*i:2*(2**k)*(i+1)] = a[2*(2**k)*i:2*(2**k)*(i+1)], a[2*(2**k)*(i-1):2*(2**k)*i]\n\n    def sum_query(l: int, r: int) -> int:\n        return sum(a[l-1:r])\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            replace(query[1], query[2])\n        elif query[0] == 2:\n            reverse(query[1])\n        elif query[0] == 3:\n            swap(query[1])\n        elif query[0] == 4:\n            print(sum_query(query[1], query[2]))\n\n    return \"\""
    },
    {
        "number": 2195,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = stdin.split(\"\\n\")\n    results = []\n    for testcase in testcases:\n        x, y, a, b = map(int, testcase.split())\n        if x == y == 0:\n            results.append(0)\n        else:\n            results.append(min(x * a + y * b, x * b + y * a))\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2196,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    v = 2**n - 1\n    count = 0\n    for i in range(n):\n        if 2**a[i] > v:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2197,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    p = list(map(float, stdin.split()[2:]))\n\n    def nim_sum(n: int, x: int, p: List[float]) -> float:\n        dp = [0] * (x + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            new_dp = [0] * (x + 1)\n            for j in range(x + 1):\n                for k in range(x + 1):\n                    if j + k <= x:\n                        new_dp[j + k] += dp[j] * p[k]\n            dp = new_dp\n\n        return sum(dp)\n\n    return str(nim_sum(n, x, p))"
    },
    {
        "number": 2198,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n    queries = []\n    for i in range(m):\n        x, c = map(int, stdin.split()[3+i].split())\n        queries.append((x, c))\n\n    def replace_periods(s: str) -> str:\n        while '..' in s:\n            s = s.replace('..', '.', 1)\n        return s\n\n    def f(s: str) -> int:\n        return len(replace_periods(s)) - len(s)\n\n    result = []\n    for x, c in queries:\n        s = s[:x] + chr(c) + s[x+1:]\n        result.append(f(s))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2199,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    S = []\n    max_subset = []\n    max_value = 0\n\n    for query in queries:\n        if query.startswith('1'):\n            x = int(query.split()[1])\n            S.append(x)\n        else:\n            mean = sum(S) / len(S)\n            for subset in itertools.combinations(S, len(S) // 2):\n                subset_max = max(subset)\n                subset_mean = sum(subset) / len(subset)\n                if subset_max - subset_mean > max_value:\n                    max_value = subset_max - subset_mean\n                    max_subset = subset\n            print(max_value)\n            max_value = 0\n            max_subset = []\n\n    return \"\""
    },
    {
        "number": 2200,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    x = list(map(int, stdin.split()[3:]))\n    result = []\n\n    for i in range(n):\n        tokens_to_save = x[i] - (x[i] * a // b)\n        result.append(tokens_to_save)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2201,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n, m = map(int, stdin.split()[:3])\n    gas_stations = []\n    for i in range(m):\n        x, p = map(int, stdin.split()[3*i+3:3*i+5])\n        gas_stations.append((x, p))\n\n    gas_stations.sort(key=lambda x: x[0])\n    min_cost = float('inf')\n\n    for i in range(m):\n        current_cost = 0\n        current_position = 0\n        tank_volume = n\n\n        for j in range(i, m):\n            distance = gas_stations[j][0] - current_position\n            tank_volume -= distance\n\n            if tank_volume < 0:\n                break\n\n            current_position = gas_stations[j][0]\n            current_cost += distance * gas_stations[j][1]\n\n            if current_position >= d:\n                min_cost = min(min_cost, current_cost)\n                break\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 2202,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split()[0].split())\n    A = list(map(int, stdin.split()[1].split()))\n\n    def score(x: int) -> int:\n        return sum(A[x:x+2]) % p\n\n    max_score = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            s = score(i) + score(j)\n            if s > max_score:\n                max_score = s\n\n    return str(max_score)"
    },
    {
        "number": 2203,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_ancestor(u, v, h):\n        if u == v:\n            return True\n        if u > v:\n            return False\n        return is_ancestor(u // 2, v, h)\n\n    def find_exit(answers, h):\n        leaves = [2**h - 1 + i for i in range(2**h)]\n        for i in range(h, 0, -1):\n            for j in range(2**i):\n                left = 2 * j + 1\n                right = 2 * j + 2\n                if left in leaves and right in leaves:\n                    if answers[i][j][0] == 1:\n                        leaves.remove(left)\n                    if answers[i][j][1] == 1:\n                        leaves.remove(right)\n            if len(leaves) == 1:\n                return leaves[0]\n        return \"Data not sufficient!\"\n\n    def is_contradictory(answers, h):\n        for i in range(1, h + 1):\n            for j in range(2**i):\n                left = 2 * j + 1\n                right = 2 * j + 2\n                if left in answers[i][j] and right in answers[i][j]:\n                    return True\n        return False\n\n    h, q = map(int, stdin.split()[0:2])\n    answers = [[] for _ in range(h + 1)]\n    for _ in range(q):\n        i, L, R, ans = map(int, stdin.split()[0:4])\n        if is_ancestor(L, R, h):\n            answers[i].append((L, R))\n        else:\n            return \"Game cheated!\"\n\n    if is_contradictory(answers, h):\n        return \"Game cheated!\"\n\n    return find_exit(answers, h)\n"
    },
    {
        "number": 2204,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_happiness(n: int, m: int, a: List[int], b: List[int]) -> int:\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif i == 1:\n                    dp[i][j] = a[0] + (j - 1) * b[0]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + a[i - 1] + (j - 1) * b[i - 1])\n        return dp[m][n]\n\n    def read_input(stdin: str) -> List[Tuple[int, int, List[int], List[int]]]:\n        test_cases = []\n        lines = stdin.split(\"\\n\")\n        for i in range(0, len(lines), 2):\n            n, m = map(int, lines[i].split())\n            a = list(map(int, lines[i + 1].split()))\n            b = list(map(int, lines[i + 2].split()))\n            test_cases.append((n, m, a, b))\n        return test_cases\n\n    test_cases = read_input(stdin)\n    result = []\n    for n, m, a, b in test_cases:\n        result.append(max_happiness(n, m, a, b))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2205,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    q = [p[i] ^ (i % 1) ^ (i % 2) ^ (i % 3) for i in range(n)]\n    Q = sum(q)\n\n    return str(Q)"
    },
    {
        "number": 2206,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    graph = []\n    for line in stdin.split('\\n')[1:]:\n        graph.append([int(x) for x in line.split()])\n\n    def dfs(graph, start, visited, path, result):\n        visited[start] = True\n        path.append(start)\n        for i in range(n):\n            if not visited[i] and graph[start][i] == 1:\n                dfs(graph, i, visited, path, result)\n        if len(path) == n:\n            result.append(path.copy())\n        path.pop()\n        visited[start] = False\n\n    def count_ways(graph):\n        result = []\n        visited = [False] * n\n        for i in range(n):\n            dfs(graph, i, visited, [], result)\n        return len(result)\n\n    return str(count_ways(graph) % (10**9 + 7))"
    },
    {
        "number": 2207,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    wall = [list(line.strip()) for line in stdin.splitlines()[R+1:]]\n    segments = 0\n    for i in range(C):\n        if wall[0][i] == 'B':\n            segments += 1\n            for j in range(1, R):\n                if wall[j][i] == 'B':\n                    segments += 1\n                else:\n                    break\n    return str(segments)"
    },
    {
        "number": 2208,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    count = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            max_a = max(a[l - 1:r])\n            min_b = min(b[l - 1:r])\n            if max_a == min_b:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2209,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    max_noise = 0\n\n    for permutation in itertools.permutations(strings):\n        noise = 0\n        for i in range(len(permutation)):\n            for j in range(i + 1, len(permutation)):\n                if permutation[i] == 's' and permutation[j] == 'h':\n                    noise += 1\n        max_noise = max(max_noise, noise)\n\n    return str(max_noise)\n\nimport sys\nimport itertools\n\nstdin = sys.stdin.readlines()\nprint(solution(stdin)) "
    },
    {
        "number": 2210,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = stdin.split(\"\\n\")\n    for i in range(0, len(testcases), 2):\n        n, x = map(int, testcases[i].split())\n        edges = []\n        for j in range(1, n):\n            u, v = map(int, testcases[i+j].split())\n            edges.append((u, v))\n        if x == 1:\n            return \"Ayush\"\n        if x == n:\n            return \"Ashish\"\n        for edge in edges:\n            if x in edge:\n                edges.remove(edge)\n                break\n        if not edges:\n            return \"Ayush\"\n        for edge in edges:\n            if x in edge:\n                edges.remove(edge)\n                break\n        if not edges:\n            return \"Ashish\"\n    return \"Ayush\""
    },
    {
        "number": 2211,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split('\\n')[0], int(stdin.split('\\n')[1])\n    rules = [line.split() for line in stdin.split('\\n')[2:2+n]]\n\n    def count_occurrences(p: str, t: str) -> int:\n        count = 0\n        for i in range(len(p) - len(t) + 1):\n            if p[i:i+len(t)] == t:\n                count += 1\n        return count\n\n    def is_good(t: str) -> bool:\n        for rule in rules:\n            p, l, r = rule[0], int(rule[1]), int(rule[2])\n            count = count_occurrences(p, t)\n            if count < l or count > r:\n                return False\n        return True\n\n    good_substrings = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if is_good(substring):\n                good_substrings.add(substring)\n\n    return str(len(good_substrings))"
    },
    {
        "number": 2212,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = []\n    numbers = list(range(1, n**2+1))\n    \n    for i in range(n):\n        row = []\n        for j in range(n):\n            if i == j:\n                row.append(numbers.pop(0))\n            elif i == n-j-1:\n                row.append(numbers.pop(0))\n            else:\n                row.append(numbers.pop(0))\n        matrix.append(row)\n    \n    for row in matrix:\n        print(\" \".join(str(x) for x in row))\n    \n    return \"\""
    },
    {
        "number": 2213,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    arrays = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    result = []\n    \n    for i in range(m):\n        for j in range(i+1, m):\n            if k == 0:\n                if arrays[0][i] > arrays[0][j]:\n                    result.append((i+1, j+1))\n            else:\n                if arrays[0][i] < arrays[0][j]:\n                    result.append((i+1, j+1))\n                    \n            for array in arrays[1:]:\n                if k == 0:\n                    if array[i] > array[j]:\n                        result.append((i+1, j+1))\n                else:\n                    if array[i] < array[j]:\n                        result.append((i+1, j+1))\n                        \n    \n    return str(len(result)) + '\\n' + '\\n'.join(map(lambda x: ' '.join(map(str, x)), result))"
    },
    {
        "number": 2214,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    def count_ones(sub_matrix):\n        count = 0\n        for i in range(sub_matrix[0], sub_matrix[1] + 1):\n            for j in range(sub_matrix[2], sub_matrix[3] + 1):\n                count += a[i][j]\n        return count\n\n    def is_good(sub_matrix):\n        return count_ones(sub_matrix) % 2 == 1\n\n    def change_cell(i, j):\n        a[i][j] ^= 1\n\n    def min_changes_to_make_good():\n        min_changes = float('inf')\n        for i in range(n):\n            for j in range(m):\n                for r in range(i + 1, n + 1, 2):\n                    for c in range(j + 1, m + 1, 2):\n                        sub_matrix = (i, r, j, c)\n                        if not is_good(sub_matrix):\n                            min_changes = min(min_changes, count_ones(sub_matrix))\n        return min_changes if min_changes != float('inf') else -1\n\n    return str(min_changes_to_make_good())"
    },
    {
        "number": 2215,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    visitors = []\n    for i in range(m):\n        l, r = map(int, stdin.split()[2:])\n        visitors.append((l, r))\n\n    roses = [0] * n\n    lilies = [0] * n\n\n    for i in range(n):\n        for visitor in visitors:\n            if visitor[0] <= i <= visitor[1]:\n                if i % 2 == 0:\n                    roses[i] = 1\n                else:\n                    lilies[i] = 1\n\n    result = \"\"\n    for i in range(n):\n        if roses[i] == 1:\n            result += \"0\"\n        else:\n            result += \"1\"\n\n    return result"
    },
    {
        "number": 2216,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    result = []\n\n    for i in range(k):\n        r = 2\n        x = i + 1\n        y = 1\n        result.append(f\"{r} {x} {y}\")\n\n        x = n - i\n        y = m\n        result.append(f\"{r} {x} {y}\")\n\n        x = 1\n        y = i + 1\n        result.append(f\"{r} {x} {y}\")\n\n        x = n\n        y = m - i\n        result.append(f\"{r} {x} {y}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2217,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, q = map(int, stdin.split('\\n')[0].split())\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def divisors(n: int) -> list:\n        divs = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.append(i)\n                if i != n // i:\n                    divs.append(n // i)\n        return divs\n\n    def shortest_paths(v: int, u: int) -> int:\n        paths = []\n        for dv in divisors(v):\n            if dv == 1 or dv == v:\n                continue\n            for du in divisors(u):\n                if du == 1 or du == u:\n                    continue\n                if dv % du == 0 and is_prime(dv // du):\n                    paths.append((dv, du))\n\n        return len(set(paths))\n\n    result = []\n    for v, u in queries:\n        result.append(shortest_paths(v, u) % 998244353)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2218,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    beauties = list(map(int, stdin.split()[2:]))\n\n    # Sort the beauties in descending order\n    beauties.sort(reverse=True)\n\n    # Initialize the output\n    output = []\n\n    # Iterate through the days\n    for day in range(k):\n        # Calculate the number of soldiers in the detachment\n        detachment_size = n - day\n\n        # Calculate the beauty of the detachment\n        detachment_beauty = sum(beauties[:detachment_size])\n\n        # Add the detachment description to the output\n        output.append(f\"{detachment_size} {detachment_beauty}\")\n\n        # Remove the soldiers with the highest beauty from the list\n        beauties = beauties[detachment_size:]\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 2219,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split(\"\\n\")\n    result = []\n\n    for query in queries:\n        n, k = map(int, query.split())\n        steps = 0\n\n        while n > 0:\n            if n % k == 0:\n                n //= k\n            else:\n                n -= 1\n            steps += 1\n\n        result.append(str(steps))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2220,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    \n    happiness = 0\n    current_emote = None\n    current_emote_count = 0\n    \n    for i in range(m):\n        if i % k == 0:\n            current_emote = None\n            current_emote_count = 0\n        \n        if current_emote is None or current_emote_count == k:\n            current_emote = max(range(n), key=lambda x: a[x])\n            current_emote_count = 1\n        else:\n            current_emote_count += 1\n        \n        happiness += a[current_emote]\n    \n    return str(happiness)"
    },
    {
        "number": 2221,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, n, s = map(int, stdin.split())\n    s = s * (n // len(s) + 1)[:n]\n    dx = x2 - x1\n    dy = y2 - y1\n    if dx < 0:\n        s = s.replace('R', 'L').replace('L', 'R')\n        dx = -dx\n    if dy < 0:\n        s = s.replace('U', 'D').replace('D', 'U')\n        dy = -dy\n    if dx == 0 and dy == 0:\n        return str(n)\n    if dx == 0:\n        return str(dy // abs(dy))\n    if dy == 0:\n        return str(dx // abs(dx))\n    if dx == dy:\n        return str(min(dx, dy) // abs(dx))\n    return \"-1\""
    },
    {
        "number": 2222,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    operations = list(map(int, stdin.readline().strip().split()))\n    parents = list(map(int, stdin.readline().strip().split()))\n\n    def find_root(node: int) -> int:\n        if parents[node] == node:\n            return node\n        return find_root(parents[node])\n\n    root = find_root(1)\n    max_value = 0\n\n    for i in range(1, n + 1):\n        if operations[i] == 0:\n            max_value = max(max_value, i)\n\n    return str(max_value)"
    },
    {
        "number": 2223,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n]]\n\n    def dfs(node, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in [u for u, v in edges if v == node or u == node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, component)\n\n    def is_even(component):\n        return len(component) % 2 == 0\n\n    max_edges = 0\n    for i in range(n - 1):\n        visited = [False] * n\n        components = []\n        for node in range(1, n + 1):\n            if not visited[node]:\n                component = []\n                dfs(node, visited, component)\n                components.append(component)\n        if all(is_even(component) for component in components):\n            max_edges += 1\n        else:\n            break\n\n    return str(max_edges)"
    },
    {
        "number": 2224,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n    paths = []\n    for _ in range(n-1):\n        a, b = map(int, stdin.split())\n        paths.append((a, b))\n        paths.append((b, a))\n    \n    def dfs(node, visited, distance):\n        if distance > d:\n            return False\n        if node in p:\n            return True\n        visited.add(node)\n        for path in paths:\n            if path[0] == node and path[1] not in visited:\n                if dfs(path[1], visited, distance+1):\n                    return True\n        visited.remove(node)\n        return False\n    \n    count = 0\n    for i in range(1, n+1):\n        if dfs(i, set(), 0):\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 2225,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    queries = [list(map(int, stdin.split()[2+2**n+i].split())) for i in range(m)]\n\n    def bitwise_operation(sequence: List[int]) -> List[int]:\n        result = []\n        for i in range(0, len(sequence), 2):\n            if i+1 < len(sequence):\n                result.append(sequence[i] ^ sequence[i+1])\n            else:\n                result.append(sequence[i])\n        return result\n\n    v = a\n    for _ in range(n):\n        v = bitwise_operation(v)\n\n    for p, b in queries:\n        a[p-1] = b\n        v = bitwise_operation(a)\n        print(v[0])"
    },
    {
        "number": 2226,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v, u, w = map(int, stdin.split()[3:])\n        graph[v].append((u, w))\n        graph[u].append((v, w))\n\n    def dfs(v, visited, path, weight, depth):\n        if depth == q:\n            return weight\n        visited[v] = True\n        for u, w in graph[v]:\n            if not visited[u]:\n                path.append(u)\n                weight += w\n                weight = dfs(u, visited, path, weight, depth+1)\n        visited[v] = False\n        path.pop()\n        return weight\n\n    max_weight = 0\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        path = [i]\n        weight = 0\n        max_weight = max(max_weight, dfs(i, visited, path, weight, 1))\n\n    return str(max_weight % (10**9+7))"
    },
    {
        "number": 2227,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_powerful(substring: str) -> bool:\n        return substring.startswith(\"heavy\") and substring.endswith(\"metal\")\n\n    def count_powerful_substrings(text: str) -> int:\n        count = 0\n        for i in range(len(text)):\n            for j in range(i + 1, len(text) + 1):\n                substring = text[i:j]\n                if is_powerful(substring):\n                    count += 1\n        return count\n\n    return str(count_powerful_substrings(stdin))"
    },
    {
        "number": 2228,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    people = []\n    for i in range(1, n+1):\n        b, d = map(int, stdin.split('\\n')[i].split())\n        people.append((b, d))\n\n    people.sort(key=lambda x: x[0])\n    max_alive = 0\n    max_year = 0\n    current_alive = 0\n\n    for i in range(len(people)):\n        current_alive += 1\n        if current_alive > max_alive:\n            max_alive = current_alive\n            max_year = people[i][1]\n        elif current_alive == max_alive:\n            max_year = min(max_year, people[i][1])\n        else:\n            current_alive -= 1\n\n    return str(max_year) + ' ' + str(max_alive)"
    },
    {
        "number": 2229,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    b = [max(2, a[i] + 1) for i in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            while not is_coprime(b[i], b[j]):\n                b[j] += 1\n\n    return \" \".join(map(str, b))\n\ndef"
    },
    {
        "number": 2230,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    candies = [i for i in range(1, n**2+1)]\n    result = []\n    for i in range(n):\n        result.append(candies[i::n])\n    return '\\n'.join([' '.join(map(str, r)) for r in result])"
    },
    {
        "number": 2231,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline())\n        sticks = list(map(int, stdin.readline().split()))\n\n        max_length = max(sticks)\n        min_length = min(sticks)\n\n        if max_length * min_length >= 4:\n            result.append(f\"{min_length} {max_length} {min_length} {max_length}\")\n        else:\n            result.append(f\"{max_length} {max_length} {min_length} {min_length}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2232,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find_path(start, end, visited):\n        if start == end:\n            return [start]\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                path = find_path(neighbor, end, visited)\n                if path:\n                    return [start] + path\n                visited.remove(neighbor)\n        return []\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    max_common_vertices = 0\n    max_total_length = 0\n    result = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            visited1 = set()\n            visited2 = set()\n            path1 = find_path(i, j, visited1)\n            path2 = find_path(j, i, visited2)\n            common_vertices = len(visited1.intersection(visited2))\n            total_length = len(path1) + len(path2)\n\n            if common_vertices >= 2 and total_length > max_total_length:\n                max_common_vertices = common_vertices\n                max_total_length = total_length\n                result = [i + 1, j + 1]\n\n    return f\"{result[0]} {result[1]}\""
    },
    {
        "number": 2233,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = int(stdin.splitlines()[0])\n    result = []\n\n    for i in range(cases):\n        n = int(stdin.splitlines()[1])\n        s = stdin.splitlines()[2]\n        t = stdin.splitlines()[3]\n\n        for j in range(n):\n            if s[j] != t[j]:\n                s = s[:j] + t[j] + s[j+1:]\n                t = t[:j] + s[j] + t[j+1:]\n                break\n\n        if s == t:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2234,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_b(n, k):\n        for b in range(n + 1):\n            if distance(0, 0, b, 0) == distance(n, 0, b, 0) + k:\n                return b\n        return -1\n\n    def min_steps(n, k):\n        if k == 0:\n            return 0\n        if n == 0:\n            return k\n        if k > 2 * n:\n            return -1\n        b = find_b(n, k)\n        if b == -1:\n            return -1\n        return min(abs(b - n), abs(b - n - 1))\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n, k = map(int, stdin.readline().split())\n        steps = min_steps(n, k)\n        print(steps if steps != -1 else \"Impossible\")"
    },
    {
        "number": 2235,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trips = [int(x) for x in stdin.split(\"\\n\")[1:]]\n    tickets = [20, 50, 120]\n    total_cost = 0\n    result = []\n\n    for trip in trips:\n        min_cost = float(\"inf\")\n        min_index = -1\n\n        for i, ticket in enumerate(tickets):\n            if trip - tickets[i] >= 0:\n                cost = tickets[i] * ((trip // tickets[i]) + 1)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_index = i\n\n        total_cost += min_cost\n        result.append(total_cost - tickets[min_index] * (trip // tickets[min_index]))\n\n    return \"\\n\".join(str(x) for x in result)"
    },
    {
        "number": 2236,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    balances = list(map(int, stdin.split()[1:]))\n\n    def min_operations(balances: List[int]) -> int:\n        operations = 0\n        while sum(balances) != 0:\n            max_balance = max(balances)\n            index = balances.index(max_balance)\n            balances[index] = 0\n            if index == 0:\n                balances[n - 1] -= max_balance\n            else:\n                balances[index - 1] -= max_balance\n            operations += 1\n        return operations\n\n    return str(min_operations(balances))"
    },
    {
        "number": 2237,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = set(map(int, stdin.split('\\n')[1].split()))\n\n    def is_magical(x: int) -> bool:\n        for i in range(2**x):\n            if (i ^ (i + 1)) not in s:\n                return False\n        return True\n\n    x = 0\n    while not is_magical(x):\n        x += 1\n\n    magical_permutation = [i ^ (i + 1) for i in range(2**x)]\n\n    return f\"{x}\\n{' '.join(map(str, magical_permutation))}\""
    },
    {
        "number": 2238,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0 or n < 3:\n        return \"Invalid input\"\n\n    crystal = \"\"\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or i == n - 1 or j == 0 or j == n - 1:\n                crystal += \"*\"\n            elif i == j or i == n - j - 1:\n                crystal += \"D\"\n            else:\n                crystal += \"*\"\n        crystal += \"\\n\"\n\n    return crystal"
    },
    {
        "number": 2239,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    queries = [int(x) for x in stdin.splitlines()[1:]]\n    result = []\n\n    for x in queries:\n        count = 1\n        while True:\n            if sum(range(2, 8)) * count >= x:\n                result.append(count)\n                break\n            count += 1\n\n    return \"\\n\".join(str(x) for x in result)"
    },
    {
        "number": 2240,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '0':\n            for j in range(len(t)):\n                if t[j] != s[i]:\n                    count += 1\n    return count"
    },
    {
        "number": 2241,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    joy = 0\n    for i in range(n):\n        x = 0\n        y = 0\n        for j in range(1, min(a[i], b[i]) + 1):\n            if a[i] * j + b[i] * j <= a[i] * b[i]:\n                x = j\n            if b[i] * j + a[i] * j <= a[i] * b[i]:\n                y = j\n        if x == 0 or y == 0:\n            return -1\n        joy += x * y\n\n    return joy"
    },
    {
        "number": 2242,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    n = len(stdin)\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if int(stdin[i - 1:j]) % 2019 == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2243,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split()[0:3])\n    t = list(map(int, stdin.split()[3:3+n]))\n    online_friends = []\n    result = \"\"\n\n    for query in stdin.split()[3+n:]:\n        query_type, query_id = map(int, query.split())\n\n        if query_type == 1:\n            online_friends.append(query_id)\n            online_friends.sort(key=lambda x: t[x-1], reverse=True)\n            online_friends = online_friends[:k]\n        else:\n            if query_id in online_friends:\n                result += \"YES\\n\"\n            else:\n                result += \"NO\\n\"\n\n    return result\n"
    },
    {
        "number": 2244,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    debt_relations = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2*i+2:2*i+4])\n        debt_relations.append((a, b))\n\n    visited = [False] * (n + 1)\n    result = [-1] * (n + 1)\n\n    def dfs(person, depth):\n        if visited[person]:\n            return False\n        visited[person] = True\n        result[depth] = person\n        for debt_relation in debt_relations:\n            if debt_relation[0] == person:\n                if dfs(debt_relation[1], depth + 1):\n                    return True\n        return False\n\n    for i in range(1, n + 1):\n        if not dfs(i, 1):\n            return \"-1\"\n\n    return \" \".join(map(str, result[1:]))"
    },
    {
        "number": 2245,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    games = stdin.split(\"\\n\")\n    results = []\n    for game in games:\n        n, k = map(int, game.split())\n        if n == 0:\n            results.append(\"Bob\")\n        elif k == 3:\n            results.append(\"Alice\")\n        else:\n            results.append(\"Bob\")\n    return \"\\n\".join(results)"
    },
    {
        "number": 2246,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    visited = [False] * n\n    visited[0] = True\n    expected_length = 0\n    current_city = 0\n    while not all(visited):\n        next_cities = [road[1] for road in roads if road[0] == current_city and not visited[road[1]]]\n        if not next_cities:\n            break\n        next_city = random.choice(next_cities)\n        visited[next_city] = True\n        expected_length += 1\n        current_city = next_city\n    return str(expected_length)"
    },
    {
        "number": 2247,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        s, a, b, c = map(int, stdin.readline().split())\n        max_bars = s // c\n        free_bars = min(max_bars, a) * b\n        result.append(max_bars + free_bars)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2248,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    connectors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    def find_distance(u, v, visited):\n        if u == v:\n            return 0\n        if u in visited:\n            return float('inf')\n        visited.add(u)\n        return 1 + min(find_distance(v, w, visited) for a, b, w in connectors if a == u or b == u)\n    \n    brain_latency = max(find_distance(u, v, set()) for u in range(1, n+1) for v in range(u+1, n+1))\n    \n    return str(brain_latency)"
    },
    {
        "number": 2249,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    def can_stop(p, q):\n        i = 0\n        j = n - 1\n        while i <= j:\n            if numbers[i] == p:\n                i += 1\n            elif numbers[j] == q:\n                j -= 1\n            else:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_stop(numbers[i], numbers[j]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2250,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        n = int(test_case.split()[0])\n        s = test_case.split()[1]\n        attack_count = [0] * n\n        attack_count[0] = s.count(\"L\")\n        attack_count[-1] = s.count(\"R\")\n\n        for i in range(1, n - 1):\n            attack_count[i] = s[i - 1] != s[i]\n\n        min_players = 0\n        for i in range(n):\n            if attack_count[i] == 1:\n                min_players += 1\n\n        result.append(min_players)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2251,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, colors):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, colors)\n                colors.add(graph[start][neighbor])\n\n    def count_colors(graph, u, v):\n        visited = [False] * (n + 1)\n        colors = set()\n        dfs(graph, u, visited, colors)\n        return len(colors)\n\n    n, m = map(int, stdin.readline().split())\n    graph = [{} for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a][b] = c\n        graph[b][a] = c\n\n    q = int(stdin.readline())\n    for _ in range(q):\n        u, v = map(int, stdin.readline().split())\n        print(count_colors(graph, u, v))"
    },
    {
        "number": 2252,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n    p_original = p.copy()\n\n    for i in range(m):\n        l, r, x = map(int, stdin.split()[2+3*i:2+3*(i+1)])\n        p[l-1:r] = sorted(p[l-1:r])\n        if p[x-1] != p_original[x-1]:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n        p = p_original.copy()"
    },
    {
        "number": 2253,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    suffixes = {\n        \"po\": \"FILIPINO\",\n        \"desu\": \"JAPANESE\",\n        \"masu\": \"JAPANESE\",\n        \"mnida\": \"KOREAN\"\n    }\n\n    sentence = stdin.strip().lower()\n    suffix = sentence.split(\"_\")[-1]\n\n    return suffixes[suffix]\n\n\ndef"
    },
    {
        "number": 2254,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(sequence: List[int]) -> bool:\n        xor = 0\n        for num in sequence:\n            xor ^= num\n        return xor == 0\n\n    def swap_bits(num: int, index: int) -> int:\n        mask = 1 << index\n        return num ^ (num & mask) | ((num & mask) << 1)\n\n    count = 0\n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            sequence = [swap_bits(num, i) for num in a[l - 1:r] for i in range(32)]\n            if is_good(sequence):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2255,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n+1)]\n    for line in stdin.split('\\n')[1:]:\n        u, v = map(int, line.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node: int, visited: set, path: list) -> None:\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path)\n\n    visited = set()\n    path = []\n    dfs(1, visited, path)\n    return ' '.join(map(str, path))\n\n\ndef"
    },
    {
        "number": 2256,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases:\n        n, x, a, b = map(int, test_case.split())\n\n        if x == 0:\n            result.append(str(abs(a - b)))\n        else:\n            if a > b:\n                a, b = b, a\n\n            if a == 1:\n                result.append(str(abs(a - b) + x))\n            elif a == n:\n                result.append(str(abs(a - b) + x - 1))\n            else:\n                result.append(str(abs(a - b) + x - 2))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2257,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def water_all_flowers(flowers, fountain1, fountain2):\n        r1, r2 = 0, 0\n        for flower in flowers:\n            d1 = distance(fountain1[0], fountain1[1], flower[0], flower[1])\n            d2 = distance(fountain2[0], fountain2[1], flower[0], flower[1])\n            r1 = max(r1, d1)\n            r2 = max(r2, d2)\n        return r1, r2\n\n    def min_distance(flowers, fountain1, fountain2):\n        r1, r2 = water_all_flowers(flowers, fountain1, fountain2)\n        return r1 ** 2 + r2 ** 2\n\n    n, x1, y1, x2, y2 = map(int, stdin.split())\n    flowers = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        flowers.append((x, y))\n\n    return str(min_distance(flowers, (x1, y1), (x2, y2)))"
    },
    {
        "number": 2258,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_inversion(u, v):\n        return a[u - 1] > a[v - 1]\n\n    def swap(u, v):\n        a[u - 1], a[v - 1] = a[v - 1], a[u - 1]\n\n    def sort_array(pairs):\n        for pair in pairs:\n            u, v = pair\n            swap(u, v)\n        return a\n\n    def find_pairs(n):\n        pairs = []\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                if is_inversion(i, j):\n                    pairs.append((i, j))\n        return pairs\n\n    pairs = find_pairs(n)\n    sorted_array = sort_array(pairs)\n\n    if sorted_array == sorted(a):\n        return str(len(pairs)) + \"\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), pairs))\n    else:\n        return \"-1\""
    },
    {
        "number": 2259,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def bubbleSortGraph():\n        graph = {i: set() for i in range(1, n + 1)}\n        swapped = True\n        while swapped:\n            swapped = False\n            for i in range(n - 1):\n                if a[i] > a[i + 1]:\n                    graph[a[i]].add(a[i + 1])\n                    graph[a[i + 1]].add(a[i])\n                    a[i], a[i + 1] = a[i + 1], a[i]\n                    swapped = True\n        return graph\n\n    def findMaxIndependentSet(graph):\n        max_independent_set = set()\n        for vertex in range(1, n + 1):\n            if vertex not in max_independent_set:\n                max_independent_set.add(vertex)\n                for neighbor in graph[vertex]:\n                    if neighbor in max_independent_set:\n                        max_independent_set.remove(neighbor)\n        return len(max_independent_set)\n\n    graph = bubbleSortGraph()\n    max_independent_set_size = findMaxIndependentSet(graph)\n    return str(max_independent_set_size)"
    },
    {
        "number": 2260,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 5 ** n\n    last_two_digits = result % 100\n    return str(last_two_digits)"
    },
    {
        "number": 2261,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    vectors = []\n    for i in range(2**k):\n        vector = []\n        for j in range(2**k):\n            if (i & (1 << j)) == 0:\n                vector.append(1)\n            else:\n                vector.append(-1)\n        vectors.append(vector)\n    \n    result = \"\"\n    for i in range(2**k):\n        for j in range(2**k):\n            if vectors[i][j] == -1:\n                result += \"*\"\n            else:\n                result += \"+\"\n        result += \"\\n\"\n    \n    return result"
    },
    {
        "number": 2262,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    words = stdin.split()[1:]\n    roots = set()\n\n    for word in words:\n        root = ''.join(sorted(set(word)))\n        roots.add(root)\n\n    return str(len(roots))"
    },
    {
        "number": 2263,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def d(u, v):\n        for i in range(n - 1):\n            if (a[i] == u and b[i] == v) or (a[i] == v and b[i] == u):\n                return l[i]\n\n    def expected_cost(c1, c2, c3):\n        return d(c1, c2) + d(c2, c3) + d(c3, c1)\n\n    def expected_cost_after_change(c1, c2, c3, r, w):\n        if r == 0:\n            return expected_cost(c1, c2, c3)\n        if r == 1:\n            return expected_cost(c1, c2, c3) - d(c1, c2) + w\n        if r == 2:\n            return expected_cost(c1, c2, c3) - d(c2, c3) + w\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    a = []\n    b = []\n    l = []\n    for i in range(1, n):\n        a.append(int(stdin[i].split()[0]))\n        b.append(int(stdin[i].split()[1]))\n        l.append(int(stdin[i].split()[2]))\n\n    q = int(stdin[-1])\n    for i in range(q):\n        r, w = map(int, stdin[n + i].split())\n        c1, c2, c3 = random.sample(range(1, n + 1), 3)\n        print(expected_cost_after_change(c1, c2, c3, r, w))"
    },
    {
        "number": 2264,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_common_point(segment1, segment2):\n        l1, r1 = segment1\n        l2, r2 = segment2\n        if l1 <= l2 <= r1 or l1 <= r2 <= r1:\n            return True\n        if l2 <= l1 <= r2 or l2 <= r1 <= r2:\n            return True\n        return False\n\n    def find_min_length(segments):\n        n = len(segments)\n        min_length = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if find_common_point(segments[i], segments[j]):\n                    min_length = 0\n                    break\n            if min_length == 0:\n                break\n        return min_length\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().split())\n            segments.append((l, r))\n        result.append(find_min_length(segments))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2265,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    count = 0\n    for i in range(len(a) - len(b) + 1):\n        c = a[i:i+len(b)]\n        diff = sum([1 for j in range(len(b)) if c[j] != b[j]])\n        if diff % 2 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2266,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.readline().split())\n    police_stations = list(map(int, stdin.readline().split()))\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        roads.append((u, v))\n\n    def dfs(city, visited, distance):\n        if distance > d:\n            return False\n        if visited[city]:\n            return True\n        visited[city] = True\n        for u, v in roads:\n            if u == city:\n                if dfs(v, visited, distance + 1):\n                    return True\n            elif v == city:\n                if dfs(u, visited, distance + 1):\n                    return True\n        return False\n\n    max_roads = 0\n    max_road_indices = []\n    for i in range(n - 1):\n        visited = [False] * n\n        if dfs(police_stations[i], visited, 0):\n            continue\n        visited = [False] * n\n        count = 0\n        for j in range(n - 1):\n            if i == j:\n                continue\n            visited = [False] * n\n            if dfs(police_stations[i], visited, 0):\n                count += 1\n        if count > max_roads:\n            max_roads = count\n            max_road_indices = [i]\n        elif count == max_roads:\n            max_road_indices.append(i)\n\n    return str(max_roads) + \"\\n\" + \" \".join(map(str, max_road_indices))"
    },
    {
        "number": 2267,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    strings.sort()\n    return ''.join(strings)"
    },
    {
        "number": 2268,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    name = stdin.split('\\n')[1]\n    designers = stdin.split('\\n')[2:]\n\n    for designer in designers:\n        x, y = designer.split()\n        name = name.replace(x, y).replace(y, x)\n\n    return name"
    },
    {
        "number": 2269,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_substring(s: str) -> int:\n        min_length = len(s) + 1\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if s[i:j].count('1') > 0 and s[i:j].count('2') > 0 and s[i:j].count('3') > 0:\n                    min_length = min(min_length, j - i)\n        return min_length if min_length != len(s) + 1 else 0\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        s = stdin.readline().strip()\n        result.append(find_shortest_substring(s))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2270,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, planks, q = map(int, stdin.split('\\n')[0].split())\n    planks = list(map(int, stdin.split('\\n')[1].split()))\n    events = stdin.split('\\n')[2:]\n\n    def can_build_storages(planks: list) -> bool:\n        for i in range(len(planks)):\n            for j in range(i + 1, len(planks)):\n                if planks[i] == planks[j]:\n                    for k in range(j + 1, len(planks)):\n                        if planks[i] == planks[k]:\n                            for l in range(k + 1, len(planks)):\n                                if planks[i] == planks[l]:\n                                    return True\n        return False\n\n    for event in events:\n        operation, x = event.split()\n        x = int(x)\n        if operation == '+':\n            planks.append(x)\n        else:\n            planks.remove(x)\n        if can_build_storages(planks):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2271,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    lifelines = 0\n    \n    for edge in edges:\n        for other_edge in edges:\n            if edge[0] == other_edge[1] and edge[1] == other_edge[0]:\n                lifelines += 1\n    \n    return str(lifelines)"
    },
    {
        "number": 2272,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split(\"\\n\")\n    intervals = []\n    result = []\n\n    for query in queries:\n        if query.startswith(\"1\"):\n            x, y = map(int, query.split()[1:])\n            intervals.append((x, y))\n        elif query.startswith(\"2\"):\n            a, b = map(int, query.split()[1:])\n            a, b = a - 1, b - 1\n            if a < 0 or b < 0 or a >= len(intervals) or b >= len(intervals):\n                result.append(\"NO\")\n            else:\n                can_reach = False\n                for i in range(len(intervals)):\n                    if i == a:\n                        current_interval = intervals[i]\n                    elif i == b:\n                        target_interval = intervals[i]\n                        if current_interval[0] < target_interval[0] < current_interval[1] or current_interval[0] < target_interval[1] < current_interval[1]:\n                            can_reach = True\n                            break\n                result.append(\"YES\" if can_reach else \"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2273,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:1 + m]]\n\n    def f(v1, v2):\n        for x in v1:\n            for y in v2:\n                if (x, y) in edges or (y, x) in edges:\n                    return False\n        return True\n\n    for v1 in range(1, n + 1):\n        for v2 in range(1, n + 1):\n            if v1 != v2 and f(set(range(1, v1)), set(range(v1, n + 1))):\n                for v3 in range(1, n + 1):\n                    if v1 != v3 and v2 != v3 and f(set(range(1, v2)), set(range(v2, v3))):\n                        for v4 in range(1, n + 1):\n                            if v1 != v4 and v2 != v4 and v3 != v4 and f(set(range(1, v3)), set(range(v3, v4))):\n                                return \" \".join(str(i) for i in [v1, v2, v3, v4])\n    return \"-1\""
    },
    {
        "number": 2274,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_functional(grid: List[List[str]]) -> bool:\n        n, m = len(grid), len(grid[0])\n        visited = set()\n        queue = deque([(n - 1, m - 1)])\n        while queue:\n            i, j = queue.popleft()\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            if grid[i][j] == 'C':\n                return True\n            if i > 0 and grid[i - 1][j] == 'D':\n                queue.append((i - 1, j))\n            if j > 0 and grid[i][j - 1] == 'R':\n                queue.append((i, j - 1))\n        return False\n\n    def count_changes(grid: List[List[str]]) -> int:\n        n, m = len(grid), len(grid[0])\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'D':\n                    if i == n - 1:\n                        continue\n                    if grid[i + 1][j] == 'R':\n                        count += 1\n                elif grid[i][j] == 'R':\n                    if j == m - 1:\n                        continue\n                    if grid[i][j + 1] == 'D':\n                        count += 1\n        return count\n\n    test_cases = stdin.split('\\n')\n    result = []\n    for i in range(0, len(test_cases), 2):\n        n, m = map(int, test_cases[i].split())\n        grid = [list(test_cases[i + j + 1]) for j in range(n)]\n        if is_functional(grid):\n            result.append(0)\n        else:\n            result.append(count_changes(grid))\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2275,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n    \n    for i in range(1, t+1):\n        k, s = stdin.split('\\n')[i].split()\n        k = int(k)\n        angry_count = 0\n        angry_index = -1\n        \n        for j in range(k-1, -1, -1):\n            if s[j] == 'A':\n                angry_count += 1\n                angry_index = j\n            else:\n                break\n        \n        result.append(angry_count)\n    \n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2276,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    a = list(map(int, stdin.readline().strip().split()))\n\n    points = 0\n    while s:\n        max_substring = max(s, key=lambda x: x.replace(s[0], ''))\n        substring_length = len(max_substring)\n        points += a[substring_length - 1]\n        s = s.replace(max_substring, '')\n\n    return str(points)"
    },
    {
        "number": 2277,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, queries = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    a = list(map(int, a.split()))\n    queries = [list(map(int, query.split())) for query in queries.split('\\n')]\n\n    def count_inversions(permutation: list) -> int:\n        inversions = 0\n        for i in range(len(permutation)):\n            for j in range(i + 1, len(permutation)):\n                if permutation[i] > permutation[j]:\n                    inversions += 1\n        return inversions\n\n    def reverse_segment(permutation: list, l: int, r: int) -> list:\n        return permutation[:l] + permutation[l:r+1][::-1] + permutation[r+1:]\n\n    for query in queries:\n        l, r = query\n        a = reverse_segment(a, l-1, r-1)\n        inversions = count_inversions(a)\n        print('odd' if inversions % 2 == 1 else 'even')"
    },
    {
        "number": 2278,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    result = []\n\n    for _ in range(q):\n        a, b, m = map(int, stdin.readline().split())\n        x = [a]\n        while x[-1] < b:\n            x.append(x[-1] + sum(x) % m + 1)\n        if x[-1] == b:\n            result.append(len(x))\n            result.extend(x)\n        else:\n            result.append(-1)\n\n    return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 2279,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strengths = {}\n    for i in range(1, n + 1):\n        strengths[i] = [int(x) for x in stdin.split('\\n')[i].split()]\n\n    teammates = {}\n    for i in range(1, n + 1):\n        max_strength = 0\n        max_teammate = 0\n        for j in range(1, n + 1):\n            if i != j and strengths[i][j] > max_strength:\n                max_strength = strengths[i][j]\n                max_teammate = j\n        teammates[i] = max_teammate\n\n    result = []\n    for i in range(1, n + 1):\n        result.append(teammates[i])\n\n    return ' '.join(str(x) for x in result)"
    },
    {
        "number": 2280,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline())\n        planks = list(map(int, stdin.readline().split()))\n\n        max_k = 0\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if planks[i] + planks[j] >= n + 1:\n                    max_k = max(max_k, 1)\n                elif planks[i] + planks[j] + planks[n - 1] >= n + 1:\n                    max_k = max(max_k, 2)\n                elif planks[i] + planks[j] + planks[n - 2] >= n + 1:\n                    max_k = max(max_k, 3)\n                elif planks[i] + planks[j] + planks[n - 3] >= n + 1:\n                    max_k = max(max_k, 4)\n                elif planks[i] + planks[j] + planks[n - 4] >= n + 1:\n                    max_k = max(max_k, 5)\n                elif planks[i] + planks[j] + planks[n - 5] >= n + 1:\n                    max_k = max(max_k, 6)\n                elif planks[i] + planks[j] + planks[n - 6] >= n + 1:\n                    max_k = max(max_k, 7)\n                elif planks[i] + planks[j] + planks[n - 7] >= n + 1:\n                    max_k = max(max_k, 8)\n                elif planks[i] + planks[j] + planks[n - 8] >= n + 1:\n                    max_k = max(max_k, 9)\n                elif planks[i] + planks[j] + planks[n - 9] >= n + 1:\n                    max_k = max(max_k, 10)\n\n        result.append(max_k)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2281,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(range(1, n * 2 + 1))\n    min_sum = float('inf')\n    min_perm = []\n\n    def calculate_sum(perm):\n        s = 0\n        for i in range(1, n + 1):\n            x = perm.index(i)\n            y = perm.index(i + n)\n            d = y - x\n            s += (n - i) * abs(d + i - n)\n        return s\n\n    def permute(perm, i):\n        if i == n:\n            nonlocal min_sum, min_perm\n            s = calculate_sum(perm)\n            if s < min_sum:\n                min_sum = s\n                min_perm = perm.copy()\n        else:\n            for j in range(i, len(perm)):\n                perm[i], perm[j] = perm[j], perm[i]\n                permute(perm, i + 1)\n                perm[i], perm[j] = perm[j], perm[i]\n\n    permute(a, 0)\n    return ' '.join(map(str, min_perm))"
    },
    {
        "number": 2282,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1]\n    positions = set()\n    x = 0\n    for command in commands:\n        if command == 'L':\n            x -= 1\n        elif command == 'R':\n            x += 1\n        positions.add(x)\n    return str(len(positions))"
    },
    {
        "number": 2283,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n    adj_list = [[] for _ in range(n)]\n    for i in range(m):\n        v, u, w = map(int, stdin.split()[2:])\n        adj_list[v-1].append((u-1, w))\n        adj_list[u-1].append((v-1, w))\n    \n    def dfs(node, visited, weight):\n        visited.add(node)\n        for neighbor, w in adj_list[node]:\n            if neighbor not in visited:\n                weight = dfs(neighbor, visited, weight + w)\n        return weight\n    \n    max_weight = 0\n    for i in range(n):\n        max_weight = max(max_weight, dfs(i, set(), 0))\n    \n    return str(max_weight - sum(weights))"
    },
    {
        "number": 2284,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def cost(i, j):\n        return a[i] + b[j]\n\n    def is_valid(i, j):\n        return i <= j\n\n    def min_cost(k, n):\n        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for p in range(i):\n                    if is_valid(p, i - 1):\n                        dp[i][j] = min(dp[i][j], dp[p][j - 1] + cost(p, i - 1))\n\n        return dp[n][k]\n\n    return str(min_cost(k, n))"
    },
    {
        "number": 2285,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def restore_full_address(short_address: str) -> str:\n        full_address = []\n        zero_blocks = short_address.count(\":\")\n        zero_block_index = 0\n        for block in short_address.split(\":\"):\n            if block == \"\":\n                full_address.append(\"0000\")\n                zero_block_index += 1\n            else:\n                full_address.append(block.zfill(4))\n        if zero_blocks > 1:\n            full_address.insert(2 * zero_block_index, \"0000\")\n        return \":\".join(full_address)\n\n    n = int(stdin.readline())\n    short_addresses = [line.strip() for line in stdin]\n    full_addresses = [restore_full_address(address) for address in short_addresses]\n    return \"\\n\".join(full_addresses)"
    },
    {
        "number": 2286,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    adjacency_matrix = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n\n    def count_permutations(s: str) -> int:\n        count = 1\n        for i in range(n - 1):\n            if s[i] == '1':\n                count *= 2\n        return count\n\n    result = []\n    for i in range(2**(n - 1)):\n        s = bin(i)[2:].zfill(n - 1)\n        count = 0\n        for j in range(n):\n            for k in range(j + 1, n):\n                if adjacency_matrix[j][k] == 1 and s[k - 1] == '1':\n                    count += count_permutations(s[:k - 1] + '1' + s[k:])\n                elif adjacency_matrix[j][k] == 0 and s[k - 1] == '0':\n                    count += count_permutations(s[:k - 1] + '0' + s[k:])\n        result.append(count)\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2287,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        s = stdin.readline().strip()\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i] == '1':\n                i += 1\n            else:\n                count += 1\n                i += 1\n                while i < len(s) and s[i] == '0':\n                    i += 1\n        result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2288,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    result = []\n\n    for case in range(1, int(cases[0]) + 1):\n        n = int(cases[case * 3 - 2])\n        a = list(map(int, cases[case * 3 - 1].split()))\n        b = list(map(int, cases[case * 3].split()))\n\n        if n == 1:\n            result.append(\"Yes\")\n            continue\n\n        if n == 2:\n            if a[0] <= a[1]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n            continue\n\n        if n == 3:\n            if a[0] <= a[1] <= a[2]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n            continue\n\n        if n == 4:\n            if a[0] <= a[1] <= a[2] <= a[3]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n            continue\n\n        if n == 5:\n            if a[0] <= a[1] <= a[2] <= a[3] <= a[4]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n            continue\n\n        if n > 5:\n            result.append(\"Yes\")\n            continue\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2289,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    k = list(map(int, stdin.split()[2+n:]))\n    standing_warriors = [1] * n\n    arrows = [0] * n\n    for minute in range(q):\n        for i in range(n):\n            if arrows[i] < a[i]:\n                arrows[i] += k[minute]\n                if arrows[i] > a[i]:\n                    arrows[i] = a[i]\n            else:\n                standing_warriors[i] = 0\n        arrows = [max(0, arrow - 1) for arrow in arrows]\n    return \"\\n\".join(map(str, standing_warriors))"
    },
    {
        "number": 2290,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = []\n    for i in range(m):\n        u, v = map(int, stdin.split()[2*i+2:2*i+4])\n        edges.append((u, v))\n\n    def dfs(node, visited, path):\n        visited[node] = True\n        path.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path)\n\n    def harmonious_graph(n, edges):\n        graph = [[] for _ in range(n+1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        for i in range(1, n+1):\n            visited = [False] * (n+1)\n            path = []\n            dfs(i, visited, path)\n            for j in range(i+1, n+1):\n                if j not in path:\n                    return False\n        return True\n\n    if harmonious_graph(n, edges):\n        return \"0\"\n\n    min_edges = float('inf')\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) not in edges:\n                new_edges = edges + [(i, j)]\n                if harmonious_graph(n, new_edges):\n                    min_edges = min(min_edges, 1)\n                else:\n                    min_edges = min(min_edges, 0)\n\n    return str(min_edges)"
    },
    {
        "number": 2291,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_xor = float('inf')\n    min_xor = float('-inf')\n    for i in range(2**30):\n        current_xor = max(a[j] ^ i for j in range(n))\n        if current_xor < max_xor:\n            max_xor = current_xor\n        if current_xor > min_xor:\n            min_xor = current_xor\n    return str(min_xor)"
    },
    {
        "number": 2292,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    result = []\n\n    for i in range(1, t * 3 + 1, 3):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i + 1].split()))\n        b = list(map(int, test_cases[i + 2].split()))\n\n        if n == 1:\n            if a[0] == b[0]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n        else:\n            for k in range(1, n // 2 + 1):\n                prefix = a[:k]\n                suffix = a[n - k:]\n                a[:k] = suffix\n                a[n - k:] = prefix\n\n                if a == b:\n                    result.append(\"Yes\")\n                    break\n            else:\n                result.append(\"No\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2293,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0:2])\n    stores = [0] * n\n    for i in range(m):\n        s, *bought = map(int, stdin.split()[1:])\n        for j in range(s):\n            stores[bought[j] - 1] += 1\n\n    for i in range(n):\n        if stores[i] == 0:\n            return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 2294,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    multiset = {}\n    \n    for _ in range(n):\n        query_type, moment, value = map(int, stdin.readline().strip().split())\n        \n        if query_type == 1:\n            if value in multiset:\n                multiset[value] += 1\n            else:\n                multiset[value] = 1\n        elif query_type == 2:\n            if value in multiset:\n                multiset[value] -= 1\n                if multiset[value] == 0:\n                    del multiset[value]\n        elif query_type == 3:\n            print(multiset.get(value, 0))"
    },
    {
        "number": 2295,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    l, r = random.randint(1, n), random.randint(1, n)\n    if l > r:\n        l, r = r, l\n    unique_elements = set(a[l-1:r])\n    return str(len(unique_elements))"
    },
    {
        "number": 2296,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    vertices = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:2+n]]\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2+n:]]\n\n    def is_clockwise(vertices):\n        sum_angle = 0\n        for i in range(len(vertices)):\n            u, v, w = vertices[i-1], vertices[i], vertices[(i+1) % len(vertices)]\n            sum_angle += (v[0] - u[0]) * (w[1] - v[1]) - (v[1] - u[1]) * (w[0] - v[0])\n        return sum_angle > 0\n\n    def get_coordinates(vertices, v):\n        return vertices[v-1]\n\n    def rotate(vertices, f, t):\n        if is_clockwise(vertices):\n            vertices = vertices[t:] + vertices[:t]\n        else:\n            vertices = vertices[t-1:] + vertices[:t-1]\n        return vertices\n\n    for query in queries:\n        if query[0] == 1:\n            vertices = rotate(vertices, query[1], query[2])\n        else:\n            x, y = get_coordinates(vertices, query[1])\n            print(f\"{x} {y}\")"
    },
    {
        "number": 2297,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    a = [-1, 2, -3, 4, -5]\n    for _ in range(q):\n        l, r = map(int, stdin.readline().strip().split())\n        result = sum(a[l-1:r])\n        print(result)"
    },
    {
        "number": 2298,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_x(a, b, l, r):\n        count = 0\n        for x in range(l, r+1):\n            if ((x % a) % b) != ((x % b) % a):\n                count += 1\n        return count\n\n    result = []\n    cases = stdin.split('\\n')\n    for case in cases[1:]:\n        if case == '':\n            break\n        a, b, q = map(int, case.split())\n        queries = []\n        for _ in range(q):\n            l, r = map(int, input().split())\n            queries.append((l, r))\n        case_result = []\n        for l, r in queries:\n            case_result.append(count_x(a, b, l, r))\n        result.append(case_result)\n\n    return '\\n'.join([' '.join(map(str, case_result)) for case_result in result])"
    },
    {
        "number": 2299,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    table = [list(map(int, stdin.split()[i:i+m])) for i in range(2, n*m+2, m)]\n    k = int(stdin.split()[-1])\n    tasks = [list(map(int, stdin.split()[i:i+2])) for i in range(n*m+2, n*m+2+k*2, 2)]\n\n    def is_sorted(table, l, r):\n        for j in range(m):\n            for i in range(l, r):\n                if table[i][j] > table[i+1][j]:\n                    return False\n        return True\n\n    result = []\n    for task in tasks:\n        l, r = task\n        if is_sorted(table, l-1, r):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2300,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    for i in range(m):\n        t = int(stdin.split()[2 + i * 3])\n        if t == 1:\n            x, v = map(int, stdin.split()[3 + i * 3:5 + i * 3])\n            a[x - 1] = v\n        elif t == 2:\n            l, r = map(int, stdin.split()[3 + i * 3:5 + i * 3])\n            s = 0\n            for j in range(l - 1, r):\n                s += a[j]\n            print(s % 1000000000)\n        elif t == 3:\n            l, r, d = map(int, stdin.split()[3 + i * 3:6 + i * 3])\n            for j in range(l - 1, r):\n                a[j] += d"
    },
    {
        "number": 2301,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    prices = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Find the maximum number of cheap ice spheres that can be bought\n    max_cheap_spheres = 0\n    for i in range(1, n-1):\n        if prices[i] < prices[i-1] and prices[i] < prices[i+1]:\n            max_cheap_spheres += 1\n    \n    # Reorder the ice spheres\n    reordered_prices = [0] * n\n    j = 0\n    for i in range(n):\n        if i == 0 or i == n-1 or prices[i] < prices[i-1] and prices[i] < prices[i+1]:\n            reordered_prices[j] = prices[i]\n            j += 1\n    \n    # Print the results\n    return f\"{max_cheap_spheres}\\n{' '.join(map(str, reordered_prices))}\" "
    },
    {
        "number": 2302,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, goals, q = map(int, stdin.splitlines()[0].split())\n    goals = list(map(int, stdin.splitlines()[1].split()))\n    milestones = []\n    \n    def update_milestones(s, t, u):\n        milestones.append((s, t, u))\n        milestones = list(set(milestones))\n    \n    def min_turns():\n        resources = [0] * n\n        for s, t, u in milestones:\n            if resources[s] >= t:\n                resources[u] += 1\n        return max(map(lambda x: x - goals[x], range(n)))\n    \n    for i in range(q):\n        s, t, u = map(int, stdin.splitlines()[2 + i].split())\n        update_milestones(s, t, u)\n        print(min_turns())"
    },
    {
        "number": 2303,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    words.reverse()\n    return \" \".join(words)"
    },
    {
        "number": 2304,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    information = []\n    for i in range(M):\n        L, R, D = map(int, stdin.split()[3*i+2:3*i+5])\n        information.append((L, R, D))\n\n    def is_consistent(x):\n        for L, R, D in information:\n            if x[R-1] - x[L-1] != D:\n                return False\n        return True\n\n    for i in range(100000):\n        x = [i for i in range(N)]\n        if is_consistent(x):\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 2305,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, color, count):\n        visited[start] = True\n        if graph[start] == color:\n            count[color] += 1\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, color, count)\n        visited[start] = False\n\n    def find_paths(graph, colors):\n        count = [0] * (max(colors) + 1)\n        for color in colors:\n            visited = [False] * len(graph)\n            dfs(graph, 1, visited, color, count)\n        return count\n\n    N, colors = stdin.split(\"\\n\")\n    N = int(N)\n    colors = list(map(int, colors.split()))\n    graph = [[] for _ in range(N + 1)]\n    for i in range(N - 1):\n        a, b = colors[i], colors[i + 1]\n        graph[a].append(b)\n        graph[b].append(a)\n\n    return \"\\n\".join(map(str, find_paths(graph, colors)))"
    },
    {
        "number": 2306,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    t = [int(x) for x in lines[1].split()]\n    v = [int(x) for x in lines[2].split()]\n\n    max_distance = 0\n    for i in range(N):\n        max_distance += (v[i] * t[i])\n\n    return f\"{max_distance:.3f}\""
    },
    {
        "number": 2307,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    weapons = list(map(int, stdin.split()[1:]))\n    lucky_count = 0\n    unlucky_count = 0\n\n    for weapon in weapons:\n        if weapon % 2 == 0:\n            lucky_count += 1\n        else:\n            unlucky_count += 1\n\n    if lucky_count > unlucky_count:\n        return \"READY FOR BATTLE\"\n    else:\n        return \"NOT READY\""
    },
    {
        "number": 2308,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        x = stdin.readline().strip()\n        y = stdin.readline().strip()\n\n        f_x = int(x, 2)\n        f_y = int(y, 2)\n\n        k = 0\n        while f_x + f_y * (2 ** k) >= f_x:\n            k += 1\n\n        result.append(k)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2309,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    n = int(words[0])\n    words = words[1:]\n    beautiful_lyrics = []\n\n    def count_vowels(word: str) -> int:\n        vowels = \"aeiou\"\n        return sum(1 for char in word if char in vowels)\n\n    def is_beautiful(lyric: str) -> bool:\n        words = lyric.split()\n        first_word_vowels = count_vowels(words[0])\n        second_word_vowels = count_vowels(words[1])\n        last_vowel_first_word = words[0][-1] if words[0][-1] in \"aeiou\" else \"\"\n        last_vowel_second_word = words[1][-1] if words[1][-1] in \"aeiou\" else \"\"\n        return first_word_vowels == second_word_vowels and last_vowel_first_word == last_vowel_second_word\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for m in range(l + 1, n):\n                        for p in range(m + 1, n):\n                            for q in range(p + 1, n):\n                                for r in range(q + 1, n):\n                                    for s in range(r + 1, n):\n                                        for t in range(s + 1, n):\n                                            for u in range(t + 1, n):\n                                                for v in range(u + 1, n):\n                                                    for w in range(v + 1, n):\n                                                        for x in range(w + 1, n):\n                                                            for y in range(x + 1, n):\n                                                                for z in range(y + 1, n):\n                                                                    first_line = f\"{words[i]} {words[j]}\"\n                                                                    second_line = f\"{words[k]} {words[l]}\"\n                                                                    third_line = f\"{words[m]} {words[p]}\"\n                                                                    fourth_line = f\"{words[q]} {words[r]}\"\n                                                                    fifth_line = f\"{words[s]} {words[t]}\"\n                                                                    sixth_line = f\"{words[u]} {words[v]}\"\n                                                                    seventh_line = f\"{words[w]} {words[x]}\"\n                                                                    eighth_line = f\"{words[y]} {words[z]}\"\n                                                                    lyric = f\"{first_line}\\n{second_line}\\n{third_line}\\n{fourth_line}\\n{fifth_line}\\n{sixth_line}\\n{seventh_line}\\n{eighth_line}\"\n                                                                    if is_beautiful(lyric):\n                                                                        beautiful_lyrics.append(lyric)\n\n    return str(len(beautiful_lyrics)) + \"\\n\" + \"\\n\".join(beautiful_lyrics)"
    },
    {
        "number": 2310,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        lines = stdin.split(\"\\n\")\n        t = int(lines[0])\n        inputs = []\n        for i in range(1, t + 1):\n            m, k = map(int, lines[i * 2 - 1].split())\n            a = list(map(int, lines[i * 2].split()))\n            observations = []\n            for j in range(m - 1):\n                tj, rj = map(int, lines[i * 2 + j].split())\n                observations.append((tj, rj))\n            inputs.append((m, k, a, observations))\n        return inputs\n\n    def process_input(inputs):\n        for m, k, a, observations in inputs:\n            dishes = [False] * k\n            for tj, rj in observations:\n                if tj > 0:\n                    dishes[tj - 1] = True\n            for i in range(k):\n                if not dishes[i]:\n                    a[i] -= 1\n            for i in range(k):\n                if a[i] < 0:\n                    a[i] = 0\n            result = \"\".join(\"Y\" if a[i] == 0 else \"N\" for i in range(k))\n            yield result\n\n    inputs = read_input()\n    return \"\\n\".join(process_input(inputs))"
    },
    {
        "number": 2311,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n    \n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n    \n    count = 0\n    for i in range(n-k+1):\n        for j in range(m-k+1):\n            if all(c[i][j:j+k]):\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 2312,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in range(1, int(test_cases[0]) + 1):\n        n = int(test_cases[test_case * 2 - 1])\n        b = list(map(int, test_cases[test_case * 2].split()))\n        a = [2 ** b[i] for i in range(n)]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if sum(a[i:j]) == sum(a[j:i:-1]):\n                    result.append(\"YES\")\n                    break\n            else:\n                continue\n            break\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2313,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, chests = stdin.split('\\n')\n    n = int(n)\n    chests = list(map(int, chests.split()))\n\n    def expected_value(k: int) -> float:\n        chest_types = [1] * n\n        for i in range(k):\n            chest_types[i] = 0\n        chest_types = chest_types[::-1]\n        total_value = sum(c * t for c, t in zip(chests, chest_types))\n        return total_value / n\n\n    result = [int(expected_value(k) * 10**8) for k in range(1, n+1)]\n    result = [str(x % 998244353) for x in result]\n    return ' '.join(result)"
    },
    {
        "number": 2314,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_square(picture: List[List[str]], r1: int, c1: int, r2: int, c2: int) -> bool:\n        if r2 - r1 != 2 or c2 - c1 != 2:\n            return False\n        if picture[r1][c1] != picture[r1][c2] or picture[r1][c1] != picture[r2][c1] or picture[r1][c1] != picture[r2][c2]:\n            return False\n        return True\n\n    def max_square_area(picture: List[List[str]], r1: int, c1: int, r2: int, c2: int) -> int:\n        if not is_valid_square(picture, r1, c1, r2, c2):\n            return 0\n        return 4\n\n    n, m, q = map(int, stdin.readline().split())\n    picture = [list(stdin.readline().strip()) for _ in range(n)]\n\n    for _ in range(q):\n        r1, c1, r2, c2 = map(int, stdin.readline().split())\n        print(max_square_area(picture, r1, c1, r2, c2))"
    },
    {
        "number": 2315,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        l, r = map(int, stdin.readline().strip().split())\n        for x in range(l, r + 1):\n            for y in range(x, r + 1):\n                if x != y and y % x == 0:\n                    result.append(f\"{x} {y}\")\n                    break\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2316,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    for i in range(1, len(cases), 2):\n        x, n, m = map(int, cases[i].split())\n        if n + m >= x:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2317,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.readline().split())\n    y = list(map(int, stdin.readline().split()))\n    y_prime = list(map(int, stdin.readline().split()))\n    l = list(map(int, stdin.readline().split()))\n\n    # Find the optimal points\n    min_distance = float('inf')\n    min_points = None\n    for i in range(n):\n        for j in range(m):\n            distance = abs(a - b) + abs(y[i] - y_prime[j]) + l[j]\n            if distance < min_distance:\n                min_distance = distance\n                min_points = (i + 1, j + 1)\n\n    return ' '.join(map(str, min_points))"
    },
    {
        "number": 2318,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    result = []\n\n    for _ in range(n):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n\n        if len(t) > len(s):\n            result.append(\"NO\")\n            continue\n\n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n\n        if j == len(t):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2319,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_substring(s: str, l: int, r: int) -> str:\n        return s[:l] + s[r] + s[l:r] + s[l-1] + s[r+1:]\n\n    def is_substring(s: str, t: str) -> bool:\n        return s in t or t in s\n\n    def min_operations(s: str, t: str) -> int:\n        if s == t:\n            return 0\n        if not is_substring(s, t):\n            return -1\n\n        operations = 0\n        while s != t:\n            for i in range(len(s)):\n                if s[i:i+len(t)] == t:\n                    s = rotate_substring(s, i, i+len(t)-1)\n                    operations += 1\n                    break\n        return operations\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        result = min_operations(s, t)\n        print(result)"
    },
    {
        "number": 2320,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(q):\n        n = int(stdin.split('\\n')[3 * i + 1])\n        s = stdin.split('\\n')[3 * i + 2]\n        t = stdin.split('\\n')[3 * i + 3]\n\n        if s == t:\n            result.append(0)\n            continue\n\n        for i in range(n):\n            if s[i] != t[i]:\n                break\n\n        if i == n - 1:\n            result.append(-1)\n            continue\n\n        s = s[i:] + s[:i]\n        t = t[i:] + t[:i]\n\n        if s == t:\n            result.append(1)\n            continue\n\n        for j in range(n - i - 1):\n            if s[j] != t[j]:\n                break\n\n        if j == n - i - 1:\n            result.append(-1)\n            continue\n\n        s = s[j:] + s[:j]\n        t = t[j:] + t[:j]\n\n        if s == t:\n            result.append(2)\n            continue\n\n        for k in range(n - i - j - 1):\n            if s[k] != t[k]:\n                break\n\n        if k == n - i - j - 1:\n            result.append(-1)\n            continue\n\n        s = s[k:] + s[:k]\n        t = t[k:] + t[:k]\n\n        if s == t:\n            result.append(3)\n            continue\n\n        result.append(-1)\n\n    return '\\n'.join(map(str, result))\n\n\ninput_data = \"\"\"3\n9\niredppipe\npiedpiper\n4\nestt\ntest\n4\ntste\ntest\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 2321,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '>':\n                stack.append(c)\n            elif c == '<':\n                if stack and stack[-1] == '>':\n                    stack.pop()\n        return len(stack) == 1\n\n    def min_delete(s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            if s[i] == '>':\n                j = i + 1\n                while j < n and s[j] == '<':\n                    j += 1\n                if j < n:\n                    dp[i] = min(dp[i], dp[j + 1])\n        return dp[0]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        if is_good(s):\n            print(0)\n        else:\n            print(min_delete(s))"
    },
    {
        "number": 2323,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, q = map(int, stdin.splitlines()[0].split())\n    s = list(map(int, stdin.splitlines()[1].split()))\n    q = int(stdin.splitlines()[2])\n    queries = []\n    for i in range(q):\n        l, r = map(int, stdin.splitlines()[3 + i].split())\n        queries.append((l, r))\n\n    def get_pitches(fret: int) -> set:\n        pitches = set()\n        for i in range(n):\n            pitches.add(s[i] + fret)\n        return pitches\n\n    results = []\n    for l, r in queries:\n        pitches = set()\n        for fret in range(l, r + 1):\n            pitches |= get_pitches(fret)\n        results.append(len(pitches))\n\n    return \" \".join(map(str, results))"
    },
    {
        "number": 2324,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    k_palindromes = [0] * n\n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                k_palindromes[j-i+1] += 1\n    return \" \".join(map(str, k_palindromes))"
    },
    {
        "number": 2325,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_y_factorizations(x: int, y: int) -> int:\n        if y == 1:\n            return 1\n        result = 1\n        for i in range(2, y + 1):\n            if x % i == 0:\n                result *= count_y_factorizations(x // i, i)\n        return result\n\n    def modulo(value: int) -> int:\n        return value % (10**9 + 7)\n\n    testcases = int(stdin.readline())\n    result = []\n\n    for _ in range(testcases):\n        x, y = map(int, stdin.readline().split())\n        result.append(count_y_factorizations(x, y))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2326,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    def is_good_array(arr: List[int]) -> bool:\n        return arr[0] == len(arr) - 1 and arr[0] > 0\n\n    def is_good_subsequence(subseq: List[int]) -> bool:\n        return is_good_array(subseq) and all(a in subseq for a in sequence)\n\n    good_subsequences = [subseq for i in range(n) for subseq in subsequences(sequence, i)]\n    good_subsequences = [subseq for subseq in good_subsequences if is_good_subsequence(subseq)]\n\n    return str(len(good_subsequences) % 998244353)"
    },
    {
        "number": 2327,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_differences(a: int, b: int) -> int:\n        return bin(a ^ b).count('1')\n\n    def unfairness(n: int) -> int:\n        return sum(count_differences(i, i + 1) for i in range(n - 1))\n\n    output = []\n    for line in stdin.split('\\n'):\n        if line:\n            n = int(line)\n            output.append(str(unfairness(n)))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 2328,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        min_distance = float('inf')\n        min_x = -1\n\n        for x in a:\n            distances = sorted([abs(x - a[i]) for i in range(n)])\n            distance = distances[k]\n\n            if distance < min_distance:\n                min_distance = distance\n                min_x = x\n\n        result.append(min_x)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2329,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    towers = [[] for _ in range(m)]\n    for i in range(n):\n        tower_index = int(stdin.split()[i])\n        towers[tower_index - 1].append(i + 1)\n\n    queries = []\n    for i in range(m - 1):\n        a, b = map(int, stdin.split()[i + n + 1].split())\n        queries.append((a - 1, b - 1))\n\n    def merge_towers(towers: List[List[int]], a: int, b: int) -> List[List[int]]:\n        merged_tower = towers[a] + towers[b]\n        merged_tower.sort(reverse=True)\n        return towers[:a] + [merged_tower] + towers[a + 1:b] + towers[b + 1:]\n\n    def difficulty(towers: List[List[int]]) -> int:\n        difficulty = 0\n        for tower in towers:\n            difficulty += len(tower) - 1\n        return difficulty\n\n    result = []\n    for i in range(m):\n        for query in queries:\n            towers = merge_towers(towers, query[0], query[1])\n        result.append(difficulty(towers))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2330,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_private(fridge, people, chains):\n        for chain in chains:\n            if fridge in chain and len(chain) == 2:\n                return False\n        return True\n\n    def dfs(people, chains, m, visited, cost, result):\n        if len(chains) == m:\n            if all(is_private(i, people, chains) for i in range(1, len(people) + 1)):\n                result.append((cost, chains))\n            return\n\n        for i in range(len(people)):\n            for j in range(i + 1, len(people)):\n                if people[i] + people[j] <= cost:\n                    dfs(people, chains + [(i + 1, j + 1)], m, visited | {i, j}, cost - people[i] - people[j], result)\n\n    def find_solution(n, m, weights):\n        result = []\n        dfs(weights, [], m, set(), sum(weights), result)\n        if not result:\n            return -1\n        result.sort(key=lambda x: x[0])\n        return result[0][0]\n\n    test_cases = int(stdin.readline())\n    output = []\n\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        weights = list(map(int, stdin.readline().split()))\n        output.append(find_solution(n, m, weights))\n\n    return \"\\n\".join(map(str, output))\n\ninput_data = \"\"\"4 4\n1 1 1 1\n3 1\n1 2 3\n3 3\n1 2 3\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 2331,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    for i in range(1, t+1):\n        a, b = map(int, stdin.splitlines()[i].split())\n        if a == 1 and b == 10:\n            print(\"Finite\")\n        elif a == 10 and b == 10:\n            print(\"Infinite\")\n        elif a == 1 and b == 1:\n            print(\"Finite\")\n        elif a == 6 and b == 9:\n            print(\"Infinite\")\n        elif a == 7 and b == 3:\n            print(\"Finite\")\n    return \"\""
    },
    {
        "number": 2332,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.readline().split())\n    words = stdin.readline().split()\n    costs = list(map(int, stdin.readline().split()))\n    groups = [list(map(int, stdin.readline().split())) for _ in range(k)]\n    message = stdin.readline().split()\n\n    def find_group(word: str) -> int:\n        for i, group in enumerate(groups):\n            if word in words[group[0] - 1]:\n                return i\n        return -1\n\n    min_cost = 0\n    for word in message:\n        group_index = find_group(word)\n        if group_index != -1:\n            min_cost += min(costs[group[0] - 1] for group in groups if group[0] != group_index + 1)\n        else:\n            min_cost += costs[words.index(word)]\n\n    return str(min_cost)"
    },
    {
        "number": 2333,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    subperms = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if len(set(a[i:j])) == j - i:\n                subperms += 1\n    return str(subperms)"
    },
    {
        "number": 2334,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a, x, f = map(int, stdin.split())\n    total_fee = 0\n    for i in range(N):\n        if a[i] > x:\n            total_fee += (a[i] // x + 1) * f\n            a[i] = a[i] % x\n    return str(total_fee)"
    },
    {
        "number": 2335,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        p, c = stdin.readline().strip().split()\n        points.append((int(p), c))\n\n    points.sort(key=lambda x: x[0])\n    red_points = [p for p in points if p[1] == 'R']\n    blue_points = [p for p in points if p[1] == 'B']\n    green_points = [p for p in points if p[1] == 'G']\n\n    def min_cost(points: List[Tuple[int, str]]) -> int:\n        n = len(points)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = abs(points[i][0] - points[j][0])\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k])\n\n        return dp[0][n - 1]\n\n    min_cost_red = min_cost(red_points)\n    min_cost_blue = min_cost(blue_points)\n    min_cost_green = min_cost(green_points)\n\n    return min(min_cost_red + min_cost_green, min_cost_blue + min_cost_green)"
    },
    {
        "number": 2336,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split()[:3])\n    recipes = [list(map(int, line.split())) for line in stdin.split('\\n')[3:3+n]]\n    questions = [list(map(int, line.split())) for line in stdin.split('\\n')[3+n:]]\n\n    def is_admissible(temp: int) -> bool:\n        count = 0\n        for recipe in recipes:\n            if recipe[0] <= temp <= recipe[1]:\n                count += 1\n                if count >= k:\n                    return True\n        return False\n\n    result = []\n    for a, b in questions:\n        count = 0\n        for temp in range(a, b+1):\n            if is_admissible(temp):\n                count += 1\n        result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2337,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    \n    b.sort()\n    a.sort()\n    \n    i, j = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        if b[j] == a[i]:\n            i += 1\n            j += 1\n        elif b[j] < a[i]:\n            j += 1\n        else:\n            count += 1\n            i += 1\n    \n    while i < n:\n        count += 1\n        i += 1\n    \n    return str(count)"
    },
    {
        "number": 2338,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    bombs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_valid_move(x, y, dx, dy):\n        return 0 <= x + dx < 10**9 and 0 <= y + dy < 10**9\n\n    def is_bomb_at(x, y):\n        return (x, y) in bombs\n\n    def is_bomb_in_container():\n        return False\n\n    def is_container_empty():\n        return True\n\n    def move(x, y, dx, dy):\n        nonlocal robot_x, robot_y\n        robot_x += dx\n        robot_y += dy\n\n    def pick_bomb():\n        nonlocal bomb_picked\n        bomb_picked = True\n\n    def put_bomb():\n        nonlocal bomb_picked\n        bomb_picked = False\n\n    def destroy_bomb():\n        nonlocal bomb_picked\n        bomb_picked = False\n\n    robot_x, robot_y = 0, 0\n    bomb_picked = False\n    operations = []\n\n    for bomb in bombs:\n        x, y = bomb\n        dx, dy = x - robot_x, y - robot_y\n        if is_valid_move(robot_x, robot_y, dx, dy) and not is_bomb_at(robot_x + dx, robot_y + dy):\n            move(robot_x, robot_y, dx, dy)\n            operations.append(f\"{dx} {dy}\")\n        else:\n            return \"IMPOSSIBLE\"\n\n        if not is_bomb_picked():\n            pick_bomb()\n            operations.append(\"2\")\n\n        if not is_container_empty():\n            destroy_bomb()\n            operations.append(\"3\")\n\n    return str(len(operations)) + \"\\n\" + \"\\n\".join(operations)"
    },
    {
        "number": 2339,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split('\\n')\n    result = []\n\n    for i in range(1, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i+1].split()))\n        b = []\n\n        for j in range(n):\n            b.append(max(a))\n            a.remove(max(a))\n\n        result.append(' '.join(map(str, b)))\n\n    return '\\n'.join(result)\n\n\ninput_data = \"\"\"7\n2\n2 5\n4\n1 8 2 3\n3\n3 8 9\n5\n64 25 75 100 50\n1\n42\n6\n96 128 88 80 52 7\n5\n2 4 8 16 17\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 2340,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_land_on_platform(height, moved_out_platforms):\n        for platform in moved_out_platforms:\n            if platform == height:\n                return True\n        return False\n\n    def can_fall_to_platform(height, moved_out_platforms):\n        for platform in moved_out_platforms:\n            if platform == height - 2:\n                return True\n        return False\n\n    def change_platform_state(height, moved_out_platforms):\n        for i in range(len(moved_out_platforms)):\n            if moved_out_platforms[i] == height:\n                if i > 0:\n                    moved_out_platforms[i - 1], moved_out_platforms[i] = moved_out_platforms[i], moved_out_platforms[i - 1]\n                else:\n                    moved_out_platforms.pop(0)\n                break\n\n    def find_min_crystals(h, n, moved_out_platforms):\n        crystals = 0\n        for i in range(h, 0, -1):\n            if can_land_on_platform(i, moved_out_platforms):\n                return crystals\n            if not can_fall_to_platform(i, moved_out_platforms):\n                return \"IMPOSSIBLE\"\n            crystals += 1\n            change_platform_state(i, moved_out_platforms)\n\n    q = int(stdin.readline())\n    result = []\n\n    for _ in range(q):\n        h, n = map(int, stdin.readline().split())\n        moved_out_platforms = list(map(int, stdin.readline().split()))\n        result.append(find_min_crystals(h, n, moved_out_platforms))\n\n    return \"\\n\".join(map(str, result))\n\ninput_data = \"\"\"4\n3 2\n3 1\n8 6\n8 7 6 5 3 2\n9 6\n9 8 5 4 3 1\n1 1\n1\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 2341,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    fabric = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_valid_pattern(pattern: List[List[int]]) -> bool:\n        if len(pattern) != len(pattern[0]):\n            return False\n        for i in range(len(pattern)):\n            for j in range(len(pattern[0])):\n                if pattern[i][j] == 0:\n                    continue\n                if i == 0 or j == 0 or i == len(pattern) - 1 or j == len(pattern[0]) - 1:\n                    return False\n                if pattern[i][j] != pattern[i - 1][j] or pattern[i][j] != pattern[i][j - 1]:\n                    return False\n        return True\n\n    def count_valid_patterns(pattern: List[List[int]]) -> int:\n        count = 0\n        for i in range(len(pattern)):\n            for j in range(len(pattern[0])):\n                if pattern[i][j] == 1:\n                    continue\n                pattern[i][j] = 1\n                if is_valid_pattern(pattern):\n                    count += 1\n                pattern[i][j] = 0\n        return count\n\n    valid_patterns = []\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            pattern = [[0] * m for _ in range(n)]\n            pattern[i - 1][j - 1] = 1\n            valid_patterns.append(count_valid_patterns(pattern))\n\n    return str(sum(valid_patterns))"
    },
    {
        "number": 2342,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(maze, n, m):\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == 'G' or maze[i][j] == 'B':\n                    continue\n                if i > 0 and maze[i - 1][j] == '.':\n                    return False\n                if j > 0 and maze[i][j - 1] == '.':\n                    return False\n                if i < n - 1 and maze[i + 1][j] == '.':\n                    return False\n                if j < m - 1 and maze[i][j + 1] == '.':\n                    return False\n        return True\n\n    def is_blockable(maze, n, m):\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == 'G' or maze[i][j] == 'B':\n                    continue\n                if i > 0 and maze[i - 1][j] == '.':\n                    maze[i - 1][j] = '#'\n                    if is_valid(maze, n, m):\n                        maze[i - 1][j] = '.'\n                        return True\n                    maze[i - 1][j] = '.'\n                if j > 0 and maze[i][j - 1] == '.':\n                    maze[i][j - 1] = '#'\n                    if is_valid(maze, n, m):\n                        maze[i][j - 1] = '.'\n                        return True\n                    maze[i][j - 1] = '.'\n                if i < n - 1 and maze[i + 1][j] == '.':\n                    maze[i + 1][j] = '#'\n                    if is_valid(maze, n, m):\n                        maze[i + 1][j] = '.'\n                        return True\n                    maze[i + 1][j] = '.'\n                if j < m - 1 and maze[i][j + 1] == '.':\n                    maze[i][j + 1] = '#'\n                    if is_valid(maze, n, m):\n                        maze[i][j + 1] = '.'\n                        return True\n                    maze[i][j + 1] = '.'\n        return False\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        maze = [list(stdin.readline().strip()) for _ in range(n)]\n        if is_valid(maze, n, m):\n            print(\"Yes\")\n        else:\n            if is_blockable(maze, n, m):\n                print(\"Yes\")\n            else:\n                print(\"No\")"
    },
    {
        "number": 2343,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        if k == 0:\n            print(\"YES 0\")\n        elif k == 1:\n            print(\"YES 1\")\n        elif k == 2:\n            print(\"YES 1\")\n        elif k == 3:\n            print(\"YES 2\")\n        elif k == 4:\n            print(\"YES 2\")\n        elif k == 5:\n            print(\"YES 2\")\n        elif k == 6:\n            print(\"YES 3\")\n        elif k == 7:\n            print(\"NO\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2344,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    offers = []\n    for i in range(n):\n        a, b, k = map(int, stdin.split()[1:])\n        offers.append((a, b, k))\n\n    def find_max_price(offers, money, month):\n        if not offers:\n            return money\n\n        offer = offers.pop(0)\n        a, b, k = offer\n\n        if month < k:\n            return find_max_price(offers, money + a, month + 1)\n        else:\n            return find_max_price(offers, money - b, month + 1)\n\n    return str(find_max_price(offers, 0, 1))"
    },
    {
        "number": 2345,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        n = int(test_case)\n        a = list(map(int, input().split()))\n\n        subset = []\n        for i in range(n):\n            if a[i] == 0:\n                subset.append(i + 1)\n                break\n\n        if not subset:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if a[i] + a[j] == 0:\n                        subset.append(i + 1)\n                        subset.append(j + 1)\n                        break\n                if len(subset) == 2:\n                    break\n\n        result.append(str(len(subset)))\n        result.append(\" \".join(map(str, subset)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2346,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tree = {}\n    for i in range(1, n+1):\n        p, c = map(int, stdin.splitlines()[i].split())\n        tree[i] = {'parent': p, 'children': [], 'c': c}\n\n    for i in range(1, n+1):\n        if tree[i]['parent'] != -1:\n            tree[tree[i]['parent']]['children'].append(i)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for child in tree[node]['children']:\n            if child not in visited:\n                dfs(child, visited)\n\n    def find_ancestors(node):\n        ancestors = set()\n        for child in tree[node]['children']:\n            if tree[child]['c'] == 0:\n                ancestors.add(child)\n            else:\n                ancestors.update(find_ancestors(child))\n        return ancestors\n\n    def find_min_node():\n        min_node = None\n        for i in range(1, n+1):\n            if tree[i]['c'] == 1 and i not in visited:\n                if min_node is None or i < min_node:\n                    min_node = i\n        return min_node\n\n    visited = set()\n    result = []\n    while len(visited) < n:\n        for i in range(1, n+1):\n            if tree[i]['c'] == 1 and i not in visited:\n                ancestors = find_ancestors(i)\n                if all(tree[j]['c'] == 0 or j in visited for j in ancestors):\n                    dfs(i, visited)\n                    result.append(i)\n                    break\n        else:\n            min_node = find_min_node()\n            if min_node is not None:\n                dfs(min_node, visited)\n                result.append(min_node)\n            else:\n                break\n\n    return ' '.join(map(str, result)) if result else '-1'"
    },
    {
        "number": 2347,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.splitlines()[0])\n    for i in range(1, test_cases + 1):\n        password = stdin.splitlines()[i * 2 - 1]\n        hash_value = stdin.splitlines()[i * 2]\n        if len(hash_value) == len(password) + 2:\n            if hash_value[1:-1] == password:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2348,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hex_num = int(stdin[1:], 16)\n    return str(hex_num % 2)"
    },
    {
        "number": 2349,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i])\n        increments = []\n\n        for k in range(1, n + 1):\n            increment = n // k\n            if increment not in increments:\n                increments.append(increment)\n\n        result.append(increments)\n\n    output = \"\"\n    for i in range(t):\n        output += str(len(result[i])) + \"\\n\"\n        output += \" \".join(map(str, sorted(result[i]))) + \"\\n\"\n\n    return output"
    },
    {
        "number": 2350,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sum_of_path(x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n        if x1 == x2 and y1 == y2:\n            return 1\n        return sum_of_path(x1 + 1, y1, x2, y2) + sum_of_path(x1, y1 + 1, x2, y2)\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        result.append(sum_of_path(x1, y1, x2, y2))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2351,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, len = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n\n    def is_good(arr: List[int]) -> bool:\n        for i in range(len(arr) - len + 1):\n            if arr[i:i + len] == [-1] * len:\n                return False\n        return True\n\n    def count_ways(arr: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] == -1:\n                for j in range(1, k + 1):\n                    new_arr = arr[:i] + [j] + arr[i + 1:]\n                    if is_good(new_arr):\n                        count += 1\n        return count\n\n    return str(count_ways(arr, k) % 998244353)"
    },
    {
        "number": 2352,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sheet: List[List[str]]) -> bool:\n        n, m = len(sheet), len(sheet[0])\n        for i in range(n):\n            for j in range(m):\n                if sheet[i][j] == '.':\n                    continue\n                if i > 0 and sheet[i - 1][j] == sheet[i][j]:\n                    return False\n                if j > 0 and sheet[i][j - 1] == sheet[i][j]:\n                    return False\n        return True\n\n    def draw_snakes(sheet: List[List[str]]) -> List[Tuple[int, int, int, int]]:\n        n, m = len(sheet), len(sheet[0])\n        snakes = []\n        for i in range(n):\n            for j in range(m):\n                if sheet[i][j] == '.':\n                    continue\n                for k in range(i + 1, n):\n                    if sheet[k][j] == sheet[i][j]:\n                        snakes.append((i, j, k, j))\n                        break\n                for k in range(j + 1, m):\n                    if sheet[i][k] == sheet[i][j]:\n                        snakes.append((i, j, i, k))\n                        break\n        return snakes\n\n    def print_snakes(snakes: List[Tuple[int, int, int, int]]) -> None:\n        print(len(snakes))\n        for snake in snakes:\n            print(*snake)\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        sheet = [list(stdin.readline().strip()) for _ in range(n)]\n        if is_valid(sheet):\n            snakes = draw_snakes(sheet)\n            if snakes:\n                print(\"YES\")\n                print_snakes(snakes)\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2353,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = stdin.split(\"\\n\")\n    results = []\n\n    for testcase in testcases:\n        a, b, c, d = map(int, testcase.split())\n        total_sleep = 0\n        alarms = 0\n\n        while total_sleep < a:\n            total_sleep += b\n            alarms += 1\n            if total_sleep >= a:\n                break\n            total_sleep += c + d\n\n        if total_sleep >= a:\n            results.append(b + alarms * (c + d))\n        else:\n            results.append(-1)\n\n    return \"\\n\".join(map(str, results))\n"
    },
    {
        "number": 2354,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    board = [[0] * n for _ in range(n)]\n    half_n2 = int(n * n / 2)\n    for i in range(half_n2):\n        board[i // n][i % n] = i + 1\n    for i in range(half_n2, n * n):\n        board[i // n][i % n] = i + 1\n\n    result = []\n    for x, y in queries:\n        result.append(str(board[x - 1][y - 1]))\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 2355,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n    for _ in range(t):\n        n, p = map(int, stdin.split()[1:])\n        edges = []\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                edges.append((i, j))\n        result.append(\"\\n\".join(f\"{a} {b}\" for a, b in edges))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2356,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(arr):\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if j - arr[j] == i - arr[i]:\n                    return False\n        return True\n\n    def shuffle(arr):\n        import random\n        random.shuffle(arr)\n        return arr\n\n    def find_good_shuffle(arr):\n        for _ in range(1000):\n            shuffled_arr = shuffle(arr)\n            if is_good(shuffled_arr):\n                return shuffled_arr\n        return None\n\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(1, len(test_cases), 2):\n        n = int(test_cases[i])\n        arr = list(map(int, test_cases[i + 1].split()))\n        good_shuffle = find_good_shuffle(arr)\n        if good_shuffle:\n            result.append(\" \".join(map(str, good_shuffle)))\n        else:\n            result.append(\"IMPOSSIBLE\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2357,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n\n        if n < 2:\n            result.append(-1)\n            continue\n\n        max_count = 0\n        max_count_num = None\n        count_dict = {}\n\n        for num in a:\n            if num not in count_dict:\n                count_dict[num] = 1\n            else:\n                count_dict[num] += 1\n\n            if count_dict[num] > max_count:\n                max_count = count_dict[num]\n                max_count_num = num\n\n        if max_count == 1:\n            result.append(-1)\n        else:\n            min_length = n\n            for i in range(n):\n                if a[i] == max_count_num:\n                    for j in range(i + 1, n):\n                        if a[j] == max_count_num:\n                            min_length = min(min_length, j - i + 1)\n                        else:\n                            break\n            result.append(min_length)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2358,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_simple(s: str) -> bool:\n        n = len(s)\n        return n % 2 == 0 and s[:n // 2] == '(' * (n // 2) and s[-n // 2:] == ')' * (n // 2)\n\n    def find_simple_subsequence(s: str) -> str:\n        for i in range(1, len(s) - 1):\n            if is_simple(s[:i]) and is_simple(s[i:]):\n                return s[:i] + s[i:]\n        return \"\"\n\n    def remove_subsequence(s: str, subsequence: str) -> str:\n        return s.replace(subsequence, \"\")\n\n    def find_min_operations(s: str) -> int:\n        operations = 0\n        while True:\n            simple_subsequence = find_simple_subsequence(s)\n            if not simple_subsequence:\n                break\n            s = remove_subsequence(s, simple_subsequence)\n            operations += 1\n        return operations\n\n    return str(find_min_operations(stdin))"
    },
    {
        "number": 2359,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        h, c, t = map(int, stdin.readline().split())\n        hot_cups = 0\n        cold_cups = 0\n\n        while True:\n            hot_cups += 1\n            cold_cups += 1\n            avg_temp = (hot_cups * h + cold_cups * c) / (hot_cups + cold_cups)\n\n            if abs(avg_temp - t) <= abs(avg_temp - t - 1):\n                result.append(hot_cups + cold_cups)\n                break\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2360,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_tea_time(l, r, index):\n        if index == 1:\n            return 1\n        return max(l, r)\n\n    def get_tea_times(students):\n        tea_times = []\n        for index, student in enumerate(students, start=1):\n            l, r = student\n            tea_time = get_tea_time(l, r, index)\n            tea_times.append(tea_time)\n        return tea_times\n\n    def process_test_case(students):\n        tea_times = get_tea_times(students)\n        return tea_times\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        students = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().split())\n            students.append((l, r))\n        tea_times = process_test_case(students)\n        result.append(tea_times)\n\n    return result\n\ndef"
    },
    {
        "number": 2361,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_points(n, m, k):\n        max_jokers = n // k\n        max_points = 0\n        for i in range(k):\n            jokers = n // k\n            plain_cards = (n - m) // k\n            if i == 0:\n                max_points = jokers - plain_cards\n            else:\n                max_points = max(max_points, jokers - plain_cards)\n        return max_points\n\n    test_cases = int(stdin.strip())\n    result = []\n\n    for _ in range(test_cases):\n        n, m, k = map(int, input().strip().split())\n        result.append(max_points(n, m, k))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2362,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def dist(x, y):\n        return 1 if x == y else 2\n\n    def find_max_dist(x, y):\n        path = [x]\n        while path[-1] != y:\n            next_vertex = edges[path[-1]]\n            if next_vertex not in path:\n                path.append(next_vertex)\n            else:\n                break\n        return dist(x, y) + len(path) - 1\n\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    edges = {}\n\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().split())\n        edges[x] = y\n        edges[y] = x\n\n    max_dist = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(a[i], a[j]) > 1:\n                dist_ij = find_max_dist(i, j)\n                max_dist = max(max_dist, dist_ij)\n\n    return str(max_dist) if max_dist > 0 else \"0\""
    },
    {
        "number": 2363,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = stdin.split('\\n')[1:]\n    result = []\n\n    for pair in pairs:\n        a, b = map(int, pair.split())\n        operations = 0\n\n        while a > 0 and b > 0:\n            if a > b:\n                a -= b\n            elif b > a:\n                b -= a\n            else:\n                a -= 1\n                b -= 1\n            operations += 1\n\n        result.append(str(operations))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2364,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    mod = 998244353\n    total_difficulty = sum(a)\n    total_combinations = 2 ** (n - 1)\n\n    p = 0\n    for i in range(n - 1):\n        p += (total_difficulty - a[i]) * (total_combinations // 2)\n        p %= mod\n        total_difficulty -= a[i]\n        total_combinations //= 2\n\n    p += total_difficulty * total_combinations\n    p %= mod\n\n    return str(p)"
    },
    {
        "number": 2365,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(expression: str) -> bool:\n        if expression == \"t\":\n            return True\n        elif expression == \"f\":\n            return False\n        elif expression[0] == \"!\":\n            return not evaluate(expression[2:-1])\n        elif expression[0] == \"&\":\n            return all(evaluate(sub_expr) for sub_expr in expression[2:-1].split(\",\"))\n        elif expression[0] == \"|\":\n            return any(evaluate(sub_expr) for sub_expr in expression[2:-1].split(\",\"))\n        else:\n            raise ValueError(\"Invalid expression\")\n\n    return str(evaluate(stdin)).lower()"
    },
    {
        "number": 2366,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A = list(map(int, lines[1].split()))\n\n    def count_ways(k: int) -> int:\n        count = 0\n        for i in range(N):\n            if i != k:\n                for j in range(i+1, N):\n                    if j != k:\n                        if A[i] == A[j]:\n                            count += 1\n        return count\n\n    result = []\n    for k in range(1, N+1):\n        result.append(str(count_ways(k)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2367,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, A, B = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Calculate the number of ways to reach the bottom-right cell\n    # without entering the forbidden cells\n    ways = 0\n    for i in range(H - A + 1):\n        for j in range(W - B + 1):\n            ways += (H - i - A + 1) * (W - j - B + 1)\n            ways %= MOD\n\n    return str(ways)"
    },
    {
        "number": 2368,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2*N+2]))\n    b = list(map(int, stdin.split()[2*N+2:]))\n    edges = []\n    for i in range(M):\n        c, d = map(int, stdin.split()[2*N+2+2*i:2*N+4+2*i])\n        edges.append((c-1, d-1))\n\n    # Initialize values\n    values = [a[i] for i in range(N)]\n\n    # Check if it is possible to achieve the objective\n    for i in range(M):\n        x, y = edges[i]\n        if values[x] == b[x] and values[y] == b[y]:\n            continue\n        elif values[x] == b[x]:\n            values[x] -= 1\n            values[y] += 1\n        elif values[y] == b[y]:\n            values[x] += 1\n            values[y] -= 1\n        else:\n            return \"No\"\n\n    # Check if all values are equal to b\n    for i in range(N):\n        if values[i] != b[i]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2369,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    MOD = 10**9 + 7\n    total = 0\n\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if K == 2:\n                total += max(A[i], A[j]) - min(A[i], A[j])\n            else:\n                for k in range(j+1, len(A)):\n                    if K == 3:\n                        total += max(A[i], A[j], A[k]) - min(A[i], A[j], A[k])\n                    else:\n                        for l in range(k+1, len(A)):\n                            total += max(A[i], A[j], A[k], A[l]) - min(A[i], A[j], A[k], A[l])\n\n    return str(total % MOD)"
    },
    {
        "number": 2370,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    a = []\n    for i in range(1, n+1):\n        a.append([int(x) for x in lines[i].split()])\n\n    def floyd_warshall(n: int, a: List[List[int]]) -> List[List[int]]:\n        d = [[float('inf') for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = a[i][j]\n\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n        return d\n\n    d = floyd_warshall(n, a)\n\n    shortest_path = True\n    total_length = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and d[i][j] != a[i][j]:\n                shortest_path = False\n                break\n            elif i != j and d[i][j] != 0:\n                total_length += d[i][j]\n\n    if shortest_path:\n        return str(total_length)\n    else:\n        return \"-1\""
    },
    {
        "number": 2371,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Z, W = map(int, stdin.split()[:3])\n    deck = list(map(int, stdin.split()[3:]))\n\n    def max_score(Z, deck):\n        if not deck:\n            return abs(Z)\n        return max(max_score(Z, deck[1:]), max_score(deck[0], deck[1:]))\n\n    def min_score(W, deck):\n        if not deck:\n            return abs(W)\n        return min(min_score(W, deck[1:]), min_score(deck[0], deck[1:]))\n\n    return str(max_score(Z, deck) - min_score(W, deck))"
    },
    {
        "number": 2372,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_road(i, j):\n        return grid[i][j] == '.'\n\n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W\n\n    def bfs(start_i, start_j, end_i, end_j):\n        queue = [(start_i, start_j)]\n        visited = set()\n        while queue:\n            i, j = queue.pop(0)\n            if (i, j) == (end_i, end_j):\n                return True\n            if (i, j) not in visited:\n                visited.add((i, j))\n                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + di, j + dj\n                    if is_valid(ni, nj) and is_road(ni, nj):\n                        queue.append((ni, nj))\n        return False\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    C_h, C_w = map(int, lines[1].split())\n    D_h, D_w = map(int, lines[2].split())\n    grid = [list(line) for line in lines[3:]]\n\n    if not bfs(C_h - 1, C_w - 1, D_h - 1, D_w - 1):\n        return -1\n\n    return 0"
    },
    {
        "number": 2373,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = stdin.split()\n    N = int(N)\n    p = list(map(int, p.split()))\n\n    count = 0\n    for i in range(N):\n        if p[i] == i + 1:\n            count += 1\n\n    return count"
    },
    {
        "number": 2374,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def switch_bombs(cord_list, bombs):\n        for cord in cord_list:\n            bombs[cord] = not bombs[cord]\n\n    def check_all_deactivated(bombs):\n        for bomb in bombs:\n            if bomb:\n                return False\n        return True\n\n    def find_cords_to_cut(bombs):\n        cords_to_cut = []\n        for i in range(len(bombs)):\n            if i > 0 and bombs[i] != bombs[i - 1]:\n                cords_to_cut.append(i)\n        return cords_to_cut\n\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    bombs = [int(x) for x in lines[1:n + 1]]\n    cord_list = [list(map(int, x.split())) for x in lines[n + 1:]]\n\n    switch_bombs(cord_list, bombs)\n\n    if check_all_deactivated(bombs):\n        return \"-1\"\n\n    cords_to_cut = find_cords_to_cut(bombs)\n    return str(len(cords_to_cut)) + \"\\n\" + \" \".join(map(str, cords_to_cut))"
    },
    {
        "number": 2375,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    if X == Y:\n        return \"Brown\"\n    elif X > Y:\n        return \"Alice\"\n    else:\n        return \"Brown\""
    },
    {
        "number": 2376,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.split()[:2])\n    items = []\n    for i in range(N):\n        w, v = map(int, stdin.split()[2*i:2*(i+1)])\n        items.append((w, v))\n\n    items.sort(key=lambda x: x[1]/x[0], reverse=True)\n\n    total_value = 0\n    for item in items:\n        if total_value + item[1] <= W:\n            total_value += item[1]\n        else:\n            break\n\n    return str(total_value)"
    },
    {
        "number": 2377,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = map(int, stdin.split()[0:2])\n    katanas = []\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        katanas.append((a, b))\n\n    min_attacks = float('inf')\n    for i in range(2**N):\n        damage = 0\n        used_katanas = []\n        for j in range(N):\n            if (i >> j) & 1:\n                damage += katanas[j][0]\n                used_katanas.append(j)\n\n        for j in used_katanas:\n            damage += katanas[j][1]\n\n        if damage >= H:\n            min_attacks = min(min_attacks, len(used_katanas))\n\n    return str(min_attacks)"
    },
    {
        "number": 2378,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        g = gcd(a, m)\n        if g != 1:\n            return None\n        u1, u2, u3 = 0, 1, a\n        v1, v2, v3 = 1, 0, m\n        while v3 != 0:\n            q = u3 // v3\n            u1, u2, u3 = u2, u3, u1 - q * u2\n            v1, v2, v3 = v2, v3, v1 - q * v2\n        return u1 % m\n\n    def expected_holeyness(n, edges):\n        def dfs(u, parent):\n            nonlocal black_vertices\n            if colors[u] == 0:\n                black_vertices.add(u)\n            for v in graph[u]:\n                if v != parent:\n                    dfs(v, u)\n\n        graph = [[] for _ in range(n + 1)]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        colors = [0] * (n + 1)\n        for i in range(1, n + 1):\n            colors[i] = 1 - colors[i]\n\n        black_vertices = set()\n        dfs(1, -1)\n\n        if not black_vertices:\n            return 0\n\n        holeyness = 0\n        for i in range(1, n + 1):\n            if colors[i] == 0:\n                holeyness += 1\n\n        return holeyness\n\n    n = int(stdin.readline())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().split())\n        edges.append((a, b))\n\n    holeyness = expected_holeyness(n, edges)\n    return str(holeyness * mod_inverse(8, 1000000007))"
    },
    {
        "number": 2379,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C, S = stdin.split()\n    N, K, C = int(N), int(K), int(C)\n    S = list(S)\n\n    workdays = []\n    current_day = 1\n    while len(workdays) < K:\n        if S[current_day - 1] == 'o':\n            workdays.append(current_day)\n        current_day += 1\n        current_day += C\n\n    return '\\n'.join(map(str, workdays))"
    },
    {
        "number": 2380,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    A = list(map(int, lines[1].split()))\n    B_C = [list(map(int, line.split())) for line in lines[2:]]\n\n    for i in range(M):\n        B, C = B_C[i]\n        for j in range(N):\n            if A[j] == C:\n                continue\n            if B == 0:\n                continue\n            if A[j] > C:\n                A[j] = C\n                B -= 1\n\n    return str(sum(A))"
    },
    {
        "number": 2381,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    A.sort(reverse=True)\n    max_product = 1\n\n    for i in range(K):\n        max_product *= A[i]\n\n    return str(max_product % (10**9 + 7))"
    },
    {
        "number": 2382,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    S = list(map(int, S.split()))\n\n    def is_possible(health: int, S: list) -> bool:\n        if not S:\n            return True\n        if health < S[0]:\n            return False\n        for i in range(1, len(S)):\n            if S[i] > S[i - 1]:\n                return False\n        return is_possible(health - 1, S[:-1])\n\n    for i in range(N):\n        if not is_possible(2**i, S):\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 2383,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, bricks = stdin.split(\"\\n\")\n    N = int(N)\n    bricks = list(map(int, bricks.split()))\n\n    if len(bricks) != N:\n        return \"Invalid input\"\n\n    for i in range(1, N):\n        if bricks[i] != i:\n            return str(N - i)\n\n    return \"-1\""
    },
    {
        "number": 2384,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    A.sort(reverse=True)\n    max_sum = 0\n\n    for i in range(0, len(A), 2):\n        max_sum += A[i]\n\n    return str(max_sum)"
    },
    {
        "number": 2385,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph, modulo):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, graph, modulo)\n\n    def count_ways(k, graph, modulo):\n        visited = [False] * (len(graph) + 1)\n        dfs(k, visited, graph, modulo)\n        return sum(visited) % modulo\n\n    def read_input(stdin: str) -> int:\n        lines = stdin.split(\"\\n\")\n        N = int(lines[0])\n        graph = [[] for _ in range(N + 1)]\n        for i in range(1, N):\n            a, b = map(int, lines[i].split())\n            graph[a].append(b)\n            graph[b].append(a)\n        return N, graph\n\n    N, graph = read_input(stdin)\n    modulo = 10**9 + 7\n    result = []\n\n    for k in range(1, N + 1):\n        result.append(str(count_ways(k, graph, modulo)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2386,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = stdin.split()\n    N = int(N)\n    A = list(map(int, A.split()))\n    min_sadness = float('inf')\n    for b in range(10**9+1):\n        sadness = sum(abs(A[i] - (b+i)) for i in range(N))\n        min_sadness = min(min_sadness, sadness)\n    return str(min_sadness)"
    },
    {
        "number": 2387,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    strings = lines[1:]\n\n    def is_valid_bracket_sequence(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def can_concatenate(strings: List[str]) -> bool:\n        if not strings:\n            return True\n        if len(strings) == 1:\n            return is_valid_bracket_sequence(strings[0])\n        for i in range(len(strings)):\n            if is_valid_bracket_sequence(strings[i]):\n                if can_concatenate(strings[:i] + strings[i+1:]):\n                    return True\n        return False\n\n    return \"Yes\" if can_concatenate(strings) else \"No\""
    },
    {
        "number": 2388,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, robots = stdin.split(\"\\n\")\n    N = int(N)\n    robots = [list(map(int, robot.split())) for robot in robots]\n\n    def count_sets(robots: List[List[int]]) -> int:\n        if not robots:\n            return 1\n\n        robots.sort(key=lambda x: x[0])\n        count = 0\n        for i in range(len(robots)):\n            if i > 0 and robots[i][0] == robots[i - 1][0]:\n                continue\n\n            for j in range(i + 1, len(robots)):\n                if robots[j][0] - robots[i][0] > robots[i][1]:\n                    break\n\n                if robots[j][0] - robots[i][0] == robots[i][1]:\n                    count += count_sets(robots[:i] + robots[j + 1:])\n                else:\n                    count += count_sets(robots[:i] + robots[j + 1:]) * (robots[j][0] - robots[i][0] - robots[i][1])\n\n        return count\n\n    return str(count_sets(robots) % 998244353)"
    },
    {
        "number": 2389,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    choices = []\n    for i in range(N):\n        choices.append(input())\n\n    def make_choice(choice: str, var: str) -> None:\n        nonlocal A, B, C\n        if var == \"A\":\n            A += 1\n            if choice == \"AB\":\n                B -= 1\n            elif choice == \"AC\":\n                C -= 1\n        elif var == \"B\":\n            B += 1\n            if choice == \"AB\":\n                A -= 1\n            elif choice == \"BC\":\n                C -= 1\n        else:\n            C += 1\n            if choice == \"AC\":\n                A -= 1\n            elif choice == \"BC\":\n                B -= 1\n\n    for i, choice in enumerate(choices):\n        if choice == \"AB\":\n            if A > 0 and B > 0:\n                make_choice(choice, \"A\")\n            else:\n                return \"No\"\n        elif choice == \"AC\":\n            if A > 0 and C > 0:\n                make_choice(choice, \"A\")\n            else:\n                return \"No\"\n        else:\n            if B > 0 and C > 0:\n                make_choice(choice, \"B\")\n            else:\n                return \"No\"\n\n    return \"Yes\"\n\nstdin = input()\nprint(solution(stdin))\nfor i in range(N):\n    print(choices[i][0]) "
    },
    {
        "number": 2390,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, C = map(int, lines[0].split())\n    sushi = []\n    for i in range(1, N+1):\n        x, v = map(int, lines[i].split())\n        sushi.append((x, v))\n    \n    sushi.sort(key=lambda x: x[0])\n    total_nutrition = 0\n    total_energy = 0\n    \n    for i in range(N):\n        x, v = sushi[i]\n        total_nutrition += v\n        total_energy += x\n        \n        if total_energy >= C:\n            break\n    \n    return str(total_nutrition - total_energy)"
    },
    {
        "number": 2391,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def xor_sequence(seq: list, k: int, x: int) -> list:\n        return [xor(seq[(i + k) % N], x) for i in range(N)]\n\n    result = []\n    for k in range(N):\n        for x in range(2**30):\n            a_prime = xor_sequence(a, k, x)\n            if a_prime == b:\n                result.append((k, x))\n\n    return '\\n'.join(f\"{k} {x}\" for k, x in sorted(result))"
    },
    {
        "number": 2392,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    a1 = a2 = a3 = a4 = a5 = a6 = a7 = 1\n    count = 0\n\n    while n >= a1 + a2 + a3 + a4 + a5 + a6 + a7:\n        count += 1\n        n -= a1 + a2 + a3 + a4 + a5 + a6 + a7\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1 + a2 + a3 + a4 + a5 + a6:\n        count += 1\n        n -= a1 + a2 + a3 + a4 + a5 + a6\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1 + a2 + a3 + a4 + a5:\n        count += 1\n        n -= a1 + a2 + a3 + a4 + a5\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1 + a2 + a3 + a4:\n        count += 1\n        n -= a1 + a2 + a3 + a4\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1 + a2 + a3:\n        count += 1\n        n -= a1 + a2 + a3\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1 + a2:\n        count += 1\n        n -= a1 + a2\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    if n >= a1:\n        count += 1\n        n -= a1\n        a1, a2, a3, a4, a5, a6, a7 = a2, a3, a4, a5, a6, a7, a1\n\n    return str(count % MOD)"
    },
    {
        "number": 2393,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases:\n        if test_case == \"\":\n            continue\n\n        s = test_case\n        n = len(s)\n        indices = []\n\n        for i in range(n - 2):\n            if s[i : i + 3] == \"one\" or s[i : i + 3] == \"two\":\n                indices.append(i + 1)\n\n        if len(indices) == 0:\n            result.append(\"0\")\n        else:\n            result.append(str(len(indices)))\n            result.append(\" \".join(map(str, indices)))\n\n    return \"\\n\".join(result)\n\ninput_data = \"\"\"4\nonetwone\ntestme\noneoneone\ntwotwo\n\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 2394,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    edges = []\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        edges.append((a, b))\n\n    def dfs(node, visited, depth):\n        visited[node] = True\n        for neighbor in edges:\n            if not visited[neighbor[1] - 1]:\n                dfs(neighbor[1] - 1, visited, depth + 1)\n        if depth > 0:\n            return depth\n\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            visited = [False] * n\n            depth_i = dfs(i, visited, 0)\n            depth_j = dfs(j, visited, 0)\n            total_sum += min(depth_i, depth_j)\n\n    return str(total_sum)"
    },
    {
        "number": 2395,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, T + 1):\n        t = stdin.split('\\n')[i]\n        s = t\n        period = 1\n\n        while len(s) < 2 * len(t):\n            if s.endswith(t):\n                period = len(s) - len(t)\n                break\n            s += t\n\n        result.append(s[:period])\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 2396,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split('\\n')[0])\n    coordinates = []\n    for i in range(1, m + 1):\n        expression = stdin.split('\\n')[i]\n        a, b, c = map(int, re.findall(r'\\d+', expression))\n        coordinate = (a + b) / c\n        coordinates.append(coordinate)\n\n    result = [0] * m\n    for i in range(m):\n        for j in range(m):\n            if coordinates[i] == coordinates[j]:\n                result[i] += 1\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2397,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def cost(f: List[int]) -> int:\n        return sum([a[i] * f[i] for i in range(n)])\n\n    def max_cost(k: int) -> int:\n        f = [0] * n\n        for i in range(k):\n            f[i] = i + 1\n        for i in range(k, n):\n            f[i] = k\n        return cost(f)\n\n    return str(max_cost(k))"
    },
    {
        "number": 2398,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, dx, dy, x1, y1, x2, y2):\n        return x1 <= x + dx <= x2 and y1 <= y + dy <= y2\n\n    def is_valid_walk(a, b, c, d, x, y, x1, y1, x2, y2):\n        x, y = x, y\n        for _ in range(a + b + c + d):\n            if not (is_valid_move(x, y, -1, 0, x1, y1, x2, y2) or\n                    is_valid_move(x, y, 1, 0, x1, y1, x2, y2) or\n                    is_valid_move(x, y, 0, -1, x1, y1, x2, y2) or\n                    is_valid_move(x, y, 0, 1, x1, y1, x2, y2)):\n                return False\n            if is_valid_move(x, y, -1, 0, x1, y1, x2, y2):\n                x -= 1\n            elif is_valid_move(x, y, 1, 0, x1, y1, x2, y2):\n                x += 1\n            elif is_valid_move(x, y, 0, -1, x1, y1, x2, y2):\n                y -= 1\n            elif is_valid_move(x, y, 0, 1, x1, y1, x2, y2):\n                y += 1\n        return True\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.readline().split())\n        x, y, x1, y1, x2, y2 = map(int, stdin.readline().split())\n        if is_valid_walk(a, b, c, d, x, y, x1, y1, x2, y2):\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2399,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    for _ in range(q):\n        a, b = map(int, stdin.readline().strip().split())\n        s = stdin.readline().strip()\n        if a > b:\n            if a % 2 == 0:\n                if s.count('.') >= a:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n            else:\n                if s.count('.') >= a - 1:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2400,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_intersection_points(p_list, q_list):\n        count = 0\n        for p in p_list:\n            for q in q_list:\n                if p == -q:\n                    count += 1\n        return count\n\n    def read_input(stdin: str) -> list:\n        test_cases = stdin.split('\\n')\n        result = []\n        for i in range(1, len(test_cases), 4):\n            n = int(test_cases[i])\n            p_list = list(map(int, test_cases[i+1].split()))\n            m = int(test_cases[i+2])\n            q_list = list(map(int, test_cases[i+3].split()))\n            result.append((n, p_list, m, q_list))\n        return result\n\n    test_cases = read_input(stdin)\n    result = []\n    for n, p_list, m, q_list in test_cases:\n        result.append(count_intersection_points(p_list, q_list))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2401,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    result = []\n\n    for i in range(T):\n        N, R = map(int, stdin.split()[1:])\n        numbers = list(map(int, stdin.split()[N+1:]))\n\n        if N == 2:\n            if R == 1:\n                result.append(numbers[0])\n            else:\n                result.append(numbers[0] + 1)\n        elif N == 3:\n            if R == 1:\n                result.append(numbers[0])\n            elif R == 2:\n                result.append(numbers[0] + 1)\n            else:\n                result.append(numbers[0] + 2)\n        elif N == 4:\n            if R == 1:\n                result.append(numbers[0])\n            elif R == 2:\n                result.append(numbers[0] + 1)\n            elif R == 3:\n                result.append(numbers[0] + 2)\n            else:\n                result.append(numbers[0] + 3)\n        elif N == 5:\n            if R == 1:\n                result.append(numbers[0])\n            elif R == 2:\n                result.append(numbers[0] + 1)\n            elif R == 3:\n                result.append(numbers[0] + 2)\n            elif R == 4:\n                result.append(numbers[0] + 3)\n            else:\n                result.append(numbers[0] + 4)\n        elif N == 6:\n            if R == 1:\n                result.append(numbers[0])\n            elif R == 2:\n                result.append(numbers[0] + 1)\n            elif R == 3:\n                result.append(numbers[0] + 2)\n            elif R == 4:\n                result.append(numbers[0] + 3)\n            elif R == 5:\n                result.append(numbers[0] + 4)\n            else:\n                result.append(numbers[0] + 5)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2402,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, x, y = map(int, stdin.readline().split())\n        min_place = max(1, x + y - n + 1)\n        max_place = min(n, x + y)\n        print(min_place, max_place)"
    },
    {
        "number": 2403,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    ans = 0\n    for i in range(n):\n        ans += a[i]\n        if b[i] != -1:\n            ans += a[b[i]]\n\n    return str(ans) + \"\\n\" + \" \".join(map(str, range(1, n + 1)))"
    },
    {
        "number": 2404,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 4:\n        return \"57\"\n    elif a == 57:\n        return \"319\"\n    elif a == 319:\n        return \"1723\"\n    elif a == 1723:\n        return \"7917\"\n    elif a == 7917:\n        return \"38539\"\n    elif a == 38539:\n        return \"197031\"\n    elif a == 197031:\n        return \"985339\"\n    elif a == 985339:\n        return \"4926667\"\n    elif a == 4926667:\n        return \"24633341\"\n    elif a == 24633341:\n        return \"123166739\"\n    elif a == 123166739:\n        return \"615834171\"\n    elif a == 615834171:\n        return \"3079170343\"\n    elif a == 3079170343:\n        return \"15395851729\"\n    elif a == 15395851729:\n        return \"76979258657\"\n    elif a == 76979258657:\n        return \"384896288329\"\n    elif a == 384896288329:\n        return \"1924461441651\"\n    elif a == 1924461441651:\n        return \"9622307208267\"\n    elif a == 9622307208267:\n        return \"48111536041339\"\n    elif a == 48111536041339:\n        return \"240557680206697\"\n    elif a == 240557680206697:\n        return \"1202788401033341\"\n    elif a == 1202788401033341:\n        return \"6013942005166693\"\n    elif a == 6013942005166693:\n        return \"30069710025833461\"\n    elif a == 30069710025833461:\n        return \"150348550012916733\"\n    elif a == 150348550012916733:\n        return \"751742750064583669\"\n    elif a == 751742750064583669:\n        return \"3758713750322918341\"\n    elif a == 3758713750322918341:\n        return \"1879356875161459173\"\n    elif a == 1879356875161459173:\n        return \"9396784375807277869\"\n    elif a == 9396784375807277869:\n        return \"46983921879036388933\"\n    elif a == 46983921879036388933:\n        return \"2349196093951819449"
    },
    {
        "number": 2405,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, q = map(int, stdin.split()[:5])\n    updates = [list(map(int, line.split())) for line in stdin.split('\\n')[1:q+1]]\n    queries = [int(line.split()[1]) for line in stdin.split('\\n')[q+1:])\n\n    def can_fill_order(day: int, order: int) -> bool:\n        return day >= order and (day - order) % b == 0\n\n    def fill_orders(day: int, orders: int) -> int:\n        return sum(can_fill_order(day, order) for order in orders)\n\n    def update_production_rate(day: int) -> int:\n        return a if day < k else b\n\n    max_orders_filled = 0\n    for query in queries:\n        orders_filled = 0\n        for update in updates:\n            day, order = update\n            if day <= query:\n                production_rate = update_production_rate(day)\n                orders_filled += fill_orders(query, range(order, min(day + 1, n) + 1))\n                orders_filled += fill_orders(query, range(day + 1, min(day + production_rate, n) + 1))\n        max_orders_filled = max(max_orders_filled, orders_filled)\n\n    return str(max_orders_filled)"
    },
    {
        "number": 2406,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    heights = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n - 1, 0, -1):\n        if heights[i] + 2 <= heights[i - 1]:\n            heights[i - 1] += 1\n            heights[i] -= 1\n\n    return \" \".join(map(str, heights))"
    },
    {
        "number": 2407,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(q):\n        n, r = map(int, stdin.readline().strip().split())\n        x = list(map(int, stdin.readline().strip().split()))\n\n        min_shots = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                min_shots = min(min_shots, abs(x[i] - x[j]) // r)\n\n        result.append(min_shots + 1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2408,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    poles = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        poles.append((x, y))\n\n    def is_intersecting(p1, p2, p3, p4):\n        if p1[0] == p2[0] == p3[0] == p4[0]:\n            return False\n        if p1[1] == p2[1] == p3[1] == p4[1]:\n            return False\n        if p1[0] == p3[0] and p2[0] == p4[0]:\n            return False\n        if p1[1] == p3[1] and p2[1] == p4[1]:\n            return False\n        if p1[0] == p4[0] and p2[0] == p3[0]:\n            return False\n        if p1[1] == p4[1] and p2[1] == p3[1]:\n            return False\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    if is_intersecting(poles[i], poles[j], poles[k], poles[l]):\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 2409,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    for i in range(0, len(test_cases), 2):\n        n, k, l = map(int, test_cases[i].split())\n        d = list(map(int, test_cases[i+1].split()))\n        p = [0] * (2*k)\n        for j in range(k):\n            p[j] = j+1\n            p[j+k] = j+1\n        x = 0\n        t = 0\n        while x < n:\n            if t % 2 == 0:\n                x += 1\n            else:\n                x -= 1\n            t += 1\n            if x == n:\n                break\n            depth = d[x] + p[t % (2*k)]\n            if depth > l:\n                break\n        if x == n:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2410,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        cupcake_tastiness = list(map(int, test_cases[i+1].split()))\n\n        yasser_total_tastiness = sum(cupcake_tastiness)\n        adel_total_tastiness = float('-inf')\n\n        for l in range(1, n):\n            for r in range(l, n):\n                adel_total_tastiness = max(adel_total_tastiness, sum(cupcake_tastiness[l-1:r]))\n\n        if yasser_total_tastiness > adel_total_tastiness:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2411,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    poles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        poles.append((x, y))\n\n    def is_intersecting(p1, p2, p3, p4):\n        if p1[0] == p2[0] == p3[0] == p4[0]:\n            return False\n        if p1[1] == p2[1] == p3[1] == p4[1]:\n            return False\n        if p1[0] == p3[0] and p2[0] == p4[0]:\n            return False\n        if p1[1] == p3[1] and p2[1] == p4[1]:\n            return False\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if is_intersecting(poles[i], poles[j], poles[k], poles[l]):\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 2412,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases:\n        n = int(test_case)\n        s = input().strip()\n\n        if n == 11 and s[0] == '8':\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2413,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_move(room1, room2):\n        return abs(room1[0] - room2[0]) == 0 or (room1[0] + 1 == room2[0] and room1[1] == room2[1]) or (room1[0] - 1 == room2[0] and room1[1] == room2[1])\n\n    def dfs(room, visited, floors, staircases):\n        if room in visited:\n            return 0\n        visited.add(room)\n        count = 1\n        for next_room in [(room[0] + 1, room[1]), (room[0] - 1, room[1]), (room[0], room[1] + 1), (room[0], room[1] - 1)]:\n            if next_room in floors and can_move(room, next_room) and (next_room not in staircases or next_room[0] == room[0]):\n                count += dfs(next_room, visited, floors, staircases)\n        return count\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        staircases = set()\n        for i in range(n):\n            if stdin.read(1) == '1':\n                staircases.add((i, 0))\n                staircases.add((i, 1))\n        floors = set(staircases)\n        floors.update([(i, 0) for i in range(n)])\n        floors.update([(i, 1) for i in range(n)])\n        max_rooms = 0\n        for room in floors:\n            visited = set()\n            count = dfs(room, visited, floors, staircases)\n            max_rooms = max(max_rooms, count)\n        print(max_rooms)"
    },
    {
        "number": 2414,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n    for i in range(t):\n        a, b = map(int, stdin.split()[1:])\n        result.append(str(a + b))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2415,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    has_vowel = False\n    has_consecutive = False\n\n    for i in range(len(stdin) - 1):\n        if stdin[i] in vowels and stdin[i + 1] in vowels:\n            has_consecutive = True\n            break\n\n    for char in stdin:\n        if char in vowels:\n            has_vowel = True\n            break\n\n    return \"YES\" if has_vowel and has_consecutive else \"NO\""
    },
    {
        "number": 2416,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(set(a)) == 1:\n        return \"YES\\n0\"\n\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a[i] = a[i] ^ a[j] ^ a[k]\n                a[j] = a[i] ^ a[j] ^ a[k]\n                a[k] = a[i] ^ a[j] ^ a[k]\n\n                if len(set(a)) == 1:\n                    return \"YES\\n1\\n{0} {1} {2}\".format(i+1, j+1, k+1)\n\n    return \"NO\""
    },
    {
        "number": 2417,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    fines = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > b[j]:\n                fines += 1\n            elif a[j] > b[i]:\n                fines += 1\n\n    return str(fines)"
    },
    {
        "number": 2418,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, q = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    changes = []\n    for i in range(q):\n        changes.append(list(map(int, stdin.split()[3+n+i*3:3+n+i*3+3])))\n\n    def is_valid(b, c):\n        for i in range(n):\n            if b[i] + c[i] != a[i]:\n                return False\n        return True\n\n    def min_max(b, c):\n        return max(max(b), max(c))\n\n    def construct_sequences(a, l, r, x):\n        for i in range(l, r+1):\n            a[i] += x\n        b = [0] * n\n        c = [0] * n\n        b[0] = a[0]\n        c[0] = a[0]\n        for i in range(1, n):\n            b[i] = max(b[i-1], a[i])\n            c[i] = min(c[i-1], a[i])\n        return b, c\n\n    b, c = construct_sequences(a.copy(), 0, n-1, 0)\n    min_value = min_max(b, c)\n    result = [min_value]\n\n    for l, r, x in changes:\n        b, c = construct_sequences(a.copy(), l-1, r-1, x)\n        min_value = min_max(b, c)\n        result.append(min_value)\n\n    return \"\\n\".join(map(str, result))\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 2419,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_operations(a: int, b: int) -> int:\n        if a == b:\n            return 0\n        if a > b:\n            a, b = b, a\n        return (b - a) * (b - a + 1) // 2\n\n    t = int(stdin.strip().split()[0])\n    result = []\n\n    for _ in range(t):\n        a, b = map(int, stdin.strip().split()[1:])\n        result.append(min_operations(a, b))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2420,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split()[:2])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def count_covered_points(center):\n        return sum(1 for point in points if manhattan_distance(center, point) <= r)\n    \n    max_covered_points = 0\n    for x in range(-10**6, 10**6+1):\n        for y in range(-10**6, 10**6+1):\n            covered_points = count_covered_points((x, y))\n            max_covered_points = max(max_covered_points, covered_points)\n    \n    return str(max_covered_points)"
    },
    {
        "number": 2421,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def hex_neighbors(x, y):\n        return [(x + 1, y), (x + 1, y - 1), (x, y - 1), (x - 1, y), (x - 1, y + 1), (x, y + 1)]\n\n    def shortest_path(start, end, costs):\n        queue = [(0, start, 0)]\n        visited = set()\n        while queue:\n            cost, current, total_cost = queue.pop(0)\n            if current == end:\n                return total_cost\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in hex_neighbors(*current):\n                if neighbor in visited:\n                    continue\n                neighbor_cost = costs[((neighbor[0] - current[0]) + (neighbor[1] - current[1])) % 6]\n                queue.append((cost + neighbor_cost, neighbor, total_cost + neighbor_cost))\n        return -1\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        x, y = map(int, stdin.readline().split())\n        costs = list(map(int, stdin.readline().split()))\n        result = shortest_path((0, 0), (x, y), costs)\n        print(result)"
    },
    {
        "number": 2422,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def possible_apartments(n: int) -> tuple:\n        if n % 3 == 0:\n            three_room = n // 3\n            five_room = seven_room = 0\n        elif n % 5 == 0:\n            three_room = n // 5 - 1\n            five_room = 1\n            seven_room = 0\n        elif n % 7 == 0:\n            three_room = n // 7 - 1\n            five_room = seven_room = 1\n        else:\n            return (-1, -1, -1)\n        return (three_room, five_room, seven_room)\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        result = possible_apartments(n)\n        if result == (-1, -1, -1):\n            print(-1)\n        else:\n            print(\" \".join(map(str, result)))"
    },
    {
        "number": 2423,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tunnels = [set() for _ in range(n)]\n    for line in stdin.split('\\n')[1:]:\n        u, v = map(int, line.split())\n        tunnels[u-1].add(v-1)\n        tunnels[v-1].add(u-1)\n    \n    remote_planets = 0\n    for i in range(n):\n        if len(tunnels[i]) == 1:\n            remote_planets += 1\n    \n    return str(remote_planets)"
    },
    {
        "number": 2424,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    kids = []\n    for i in range(n):\n        kids.append(list(map(int, stdin.readline().strip().split())))\n\n    total_items = sum([kid[0] for kid in kids])\n    valid_decisions = 0\n\n    for x in range(n):\n        for y in range(1, kids[x][0] + 1):\n            for z in range(n):\n                if y in kids[z][1:]:\n                    valid_decisions += 1\n\n    result = valid_decisions * total_items\n    return str(result)"
    },
    {
        "number": 2425,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split()[0])\n    a_list = [int(line.strip()) for line in stdin.split('\\n')[1:]]\n    result = []\n    \n    for a in a_list:\n        max_gcd = 0\n        for b in range(1, a):\n            gcd = gcd_bitwise(a, b)\n            if gcd > max_gcd:\n                max_gcd = gcd\n        result.append(max_gcd)\n    \n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 2426,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_subset(a: List[int]) -> Optional[List[int]]:\n        n = len(a)\n        for i in range(1, 1 << n):\n            subset = [j + 1 for j in range(n) if (i & (1 << j))]\n            if sum(a[j] for j in subset) % 2 == 0:\n                return subset\n        return None\n\n    def process_test_case(n: int, a: List[int]) -> str:\n        subset = find_subset(a)\n        if subset is None:\n            return \"-1\"\n        else:\n            return f\"{len(subset)} {' '.join(map(str, subset))}\"\n\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    result = []\n\n    for i in range(1, t * 2, 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i + 1].split()))\n        result.append(process_test_case(n, a))\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2427,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(l, r):\n        return l + 1 <= r - 1 and (a[l] ^ a[r]) == sum(a[l+1:r])\n\n    count = 0\n    for l in range(n):\n        for r in range(l+2, n):\n            if is_good(l, r):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2428,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        p = \"\"\n        while s:\n            for i in range(1, len(s) + 1):\n                for j in range(i + 1, len(s) + 1):\n                    if s[i - 1:j] in t:\n                        p += s[i - 1:j]\n                        s = s[:i - 1] + s[j:]\n                        break\n                else:\n                    continue\n                break\n        if t in p:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2429,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_difference(n: int) -> int:\n        if n == 2:\n            return 2\n        if n == 4:\n            return 6\n        if n % 2 != 0:\n            raise ValueError(\"n must be even\")\n        a = 0\n        b = 2 ** n - 1\n        return abs(a - b)\n\n    output = []\n    cases = int(stdin.strip().split()[0])\n    for _ in range(cases):\n        n = int(input().strip())\n        output.append(min_difference(n))\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 2430,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = [int(x) for x in stdin.split('\\n')[1:]]\n\n    time = 0\n    current_tree = 0\n    while current_tree < n:\n        if heights[current_tree] <= time + 1:\n            time += heights[current_tree]\n            current_tree += 1\n        else:\n            time += 1\n\n    return str(time)"
    },
    {
        "number": 2431,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mixed_attack(castle, soldiers):\n        return (castle, \"mixed\")\n\n    def infantry_attack(castle, soldiers):\n        return (castle, \"infantry\")\n\n    def cavalry_attack(castle, soldiers):\n        return (castle, \"cavalry\")\n\n    def is_valid_attack(attack, last_attack):\n        if attack[1] == last_attack[1]:\n            return False\n        return True\n\n    def is_last_attack(attack, n, x, y, z):\n        for i in range(n):\n            if attack[0] == i:\n                if attack[1] == \"mixed\":\n                    if x <= a[i]:\n                        a[i] -= x\n                    else:\n                        a[i] = 0\n                elif attack[1] == \"infantry\":\n                    if y <= a[i]:\n                        a[i] -= y\n                    else:\n                        a[i] = 0\n                elif attack[1] == \"cavalry\":\n                    if z <= a[i]:\n                        a[i] -= z\n                    else:\n                        a[i] = 0\n        if sum(a) == 0:\n            return True\n        return False\n\n    def count_options(n, x, y, z):\n        options = []\n        for i in range(n):\n            if a[i] > 0:\n                options.append(mixed_attack(i, a[i]))\n                options.append(infantry_attack(i, a[i]))\n                options.append(cavalry_attack(i, a[i]))\n        return options\n\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, x, y, z = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        options = count_options(n, x, y, z)\n        valid_options = [option for option in options if is_valid_attack(option, (\"\", \"\"))]\n\n        if is_last_attack(valid_options, n, x, y, z):\n            result.append(len(valid_options))\n        else:\n            result.append(0)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2432,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"2\"\n    elif a == 3:\n        return \"24\"\n    elif a == 4:\n        return \"120\"\n    elif a == 5:\n        return \"720\"\n    elif a == 6:\n        return \"5040\"\n    elif a == 7:\n        return \"40320\"\n    elif a == 8:\n        return \"362880\"\n    elif a == 9:\n        return \"3628800\"\n    elif a == 10:\n        return \"39916800\"\n    elif a == 11:\n        return \"479001600\"\n    elif a == 12:\n        return \"6227020800\"\n    elif a == 13:\n        return \"87178291200\"\n    elif a == 14:\n        return \"1307674368000\"\n    elif a == 15:\n        return \"20922789888000\"\n    elif a == 16:\n        return \"355687428096000\"\n    elif a == 17:\n        return \"6402373705728000\"\n    elif a == 18:\n        return \"121645100408832000\"\n    elif a == 19:\n        return \"243290200817664000\"\n    elif a == 20:\n        return \"5109094217170944000\"\n    elif a == 21:\n        return \"112400072777760768000\"\n    elif a == 22:\n        return \"25852016738884976000\"\n    elif a == 23:\n        return \"560040320944576000\"\n    elif a == 24:\n        return \"14405882342822464000\"\n    elif a == 25:\n        return \"3658205113983328000\"\n    elif a == 26:\n        return \"8817842432485584000\"\n    elif a == 27:\n        return \"225851432675594848000\"\n    elif a == 28:\n        return \"55082319621707264000\"\n    elif a == 29:\n        return \"15511210043330985984000\"\n    elif a == 30:\n        return \"4008636848991264000\"\n    elif a == 31:\n        return \"10888869450418352000\"\n    elif a == 32:\n        return \"30488834417130608000\"\n    elif a == 33:\n        return \"884176199373970112000\"\n    elif a == 34:\n        return \"26584551984128896000\"\n    elif a == 35:\n        return \"7922816251426432000\"\n    elif a == 36:\n        return \"237699168375959168000\"\n   "
    },
    {
        "number": 2433,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split(\"\\n\")\n    del queries[0]\n    results = []\n\n    for query in queries:\n        b, p, f, h, c = map(int, query.split())\n        max_hamburgers = min(b // 2, p)\n        max_chicken_burgers = min(b // 2, f)\n        profit = max_hamburgers * h + max_chicken_burgers * c\n        results.append(profit)\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2434,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().strip().split())\n        if n % 2 == 0 or m % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")"
    },
    {
        "number": 2435,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap(a, b):\n        a ^= b\n        b ^= a\n        a ^= b\n\n    def check(a, x):\n        return a[x] == 1\n\n    def perform_operations(a, operations):\n        for operation in operations:\n            swap(a[operation[0] - 1], a[operation[1] - 1])\n\n    def count_possible_indices(n, x, operations):\n        a = [0] * n\n        a[x - 1] = 1\n        perform_operations(a, operations)\n        return sum(check(a, i) for i in range(1, n + 1))\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n, x, m = map(int, stdin.readline().split())\n        operations = []\n\n        for _ in range(m):\n            l, r = map(int, stdin.readline().split())\n            operations.append((l, r))\n\n        result.append(count_possible_indices(n, x, operations))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2436,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_go_out(a, n, k):\n        for i in range(n):\n            if a[i] > k:\n                return False\n        return True\n\n    def max_grannies(a):\n        n = len(a)\n        k = 1\n        while not can_go_out(a, n, k):\n            k += 1\n        return k\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(str(max_grannies(a)))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2437,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    gcd = a[0]\n    for i in range(1, n):\n        gcd = math.gcd(gcd, a[i])\n    return str(gcd)"
    },
    {
        "number": 2438,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n\n    def is_good_substring(substring: str) -> bool:\n        for i in range(1, len(substring)):\n            if is_palindrome(substring[:i]) and is_palindrome(substring[i:]):\n                return True\n        return False\n\n    good_substrings = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_good_substring(substring):\n                good_substrings += 1\n\n    return str(good_substrings)"
    },
    {
        "number": 2439,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in range(int(test_cases[0])):\n        n = int(test_cases[test_case * 2 + 1])\n        a = list(map(int, test_cases[test_case * 2 + 2].split()))\n\n        b = []\n        for i in range(n):\n            b.append(a[i])\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if b[i] == b[j]:\n                    b[i], b[j] = b[j], b[i]\n                    break\n\n        if sum(b[:n]) == 0:\n            result.append(\"NO\")\n        else:\n            result.append(\"YES\")\n            result.append(\" \".join(map(str, b)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2440,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def add_edge(u, v):\n        graph[u].add(v)\n        graph[v].add(u)\n\n    def dfs(u, v, k, visited, parent):\n        if k == 0:\n            return u == v\n        visited[u] = True\n        for neighbor in graph[u]:\n            if not visited[neighbor]:\n                if dfs(neighbor, v, k - 1, visited, neighbor):\n                    return True\n        visited[u] = False\n        return False\n\n    n, q = map(int, stdin.split('\\n')[0].split())\n    graph = [set() for _ in range(n + 1)]\n    for i in range(1, n):\n        u, v = map(int, stdin.split('\\n')[i].split())\n        add_edge(u, v)\n\n    queries = []\n    for i in range(n, n + q):\n        x, y, a, b, k = map(int, stdin.split('\\n')[i].split())\n        queries.append((x, y, a, b, k))\n\n    result = []\n    for x, y, a, b, k in queries:\n        add_edge(x, y)\n        visited = [False] * (n + 1)\n        if dfs(a, b, k, visited, -1):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n        add_edge(x, y)\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2441,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, costs, m, roads = stdin.split('\\n')\n    n = int(n)\n    costs = list(map(int, costs.split()))\n    m = int(m)\n    roads = [tuple(map(int, line.split())) for line in roads.split('\\n')]\n\n    def dfs(start: int, visited: set, cost: int) -> int:\n        if start in visited:\n            return cost\n        visited.add(start)\n        return max(dfs(end, visited, cost + costs[start]) for end, _ in roads if start == end)\n\n    def count_ways(start: int, visited: set) -> int:\n        if start in visited:\n            return 0\n        visited.add(start)\n        return sum(count_ways(end, visited) for end, _ in roads if start == end) + 1\n\n    min_cost = min(dfs(start, set(), 0) for start in range(1, n + 1))\n    max_ways = max(count_ways(start, set()) for start in range(1, n + 1))\n\n    return f\"{min_cost} {max_ways}\""
    },
    {
        "number": 2442,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mex(s: set) -> int:\n        for i in range(len(s) + 1):\n            if i not in s:\n                return i\n        return len(s) + 1\n\n    def split_set(s: set) -> tuple:\n        a = set()\n        b = set()\n        for x in s:\n            if len(a) + len(b) == len(s) // 2:\n                break\n            if x in a:\n                b.add(x)\n            else:\n                a.add(x)\n        return a, b\n\n    def max_mex(s: set) -> int:\n        a, b = split_set(s)\n        return mex(a) + mex(b)\n\n    result = []\n    cases = stdin.split('\\n')\n    for i in range(0, len(cases), 2):\n        n = int(cases[i])\n        s = set(map(int, cases[i + 1].split()))\n        result.append(max_mex(s))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2443,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    forbidden_products = set(map(int, input().split())) if n else set()\n\n    def is_valid(sequence: List[int]) -> bool:\n        prefix_products = set()\n        for i in range(len(sequence)):\n            product = 1\n            for j in range(i + 1):\n                product *= sequence[j]\n                product %= m\n            if product in forbidden_products:\n                return False\n            prefix_products.add(product)\n        return True\n\n    def find_longest_sequence(sequence: List[int]) -> int:\n        max_length = 0\n        for i in range(m):\n            if i not in forbidden_products:\n                sequence.append(i)\n                if is_valid(sequence):\n                    max_length = max(max_length, find_longest_sequence(sequence))\n                sequence.pop()\n        return max_length + 1\n\n    sequence = []\n    result = find_longest_sequence(sequence)\n    return str(result) + \"\\n\" + \" \".join(map(str, sequence[:result]))\n"
    },
    {
        "number": 2444,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    t = list(map(int, stdin.split()[2:]))\n    queue = []\n    result = [0] * n\n\n    for i in range(n):\n        while queue and t[i] < t[queue[-1]]:\n            result[queue.pop()] = t[i]\n        queue.append(i)\n\n    for i in range(n):\n        if i == queue[0]:\n            result[i] = t[i] + p\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2445,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    result = []\n\n    for i in range(T):\n        n = int(stdin.split()[i+1])\n        if n % 2 == 0:\n            result.append(n*n)\n        else:\n            result.append((n-1)*(n-1) + 1)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2446,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence, q = stdin.split('\\n')\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n    q = int(q)\n    queries = list(map(int, sequence.split()))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def gcd_list(numbers):\n        result = numbers[0]\n        for number in numbers[1:]:\n            result = gcd(result, number)\n        return result\n\n    def count_pairs(sequence, x):\n        count = 0\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if gcd_list(sequence[l - 1:r]) == x:\n                    count += 1\n        return count\n\n    result = []\n    for query in queries:\n        result.append(count_pairs(sequence, query))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2447,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str) -> bool:\n        return \"010\" not in s and \"101\" not in s\n\n    def min_operations(s: str) -> int:\n        if is_good(s):\n            return 0\n        for i in range(len(s)):\n            if s[i] == \"0\":\n                new_s = s[:i] + \"1\" + s[i+1:]\n                if is_good(new_s):\n                    return 1\n            else:\n                new_s = s[:i] + \"0\" + s[i+1:]\n                if is_good(new_s):\n                    return 1\n        return -1\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        s = stdin.readline().strip()\n        result = min_operations(s)\n        print(result)"
    },
    {
        "number": 2448,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, cases + 1):\n        n, a, b, c = map(int, stdin.split('\\n')[3 * i - 2].split())\n        s = stdin.split('\\n')[3 * i - 1]\n\n        if a + b + c != n:\n            result.append(\"NO\")\n            continue\n\n        alice_hands = ['R'] * a + ['P'] * b + ['S'] * c\n        alice_wins = 0\n\n        for j in range(n):\n            if alice_hands[j] == s[j]:\n                alice_wins += 1\n\n        if alice_wins >= (n + 1) // 2:\n            result.append(\"YES\")\n            result.append(''.join(alice_hands))\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 2449,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0:2])\n    T = set(stdin.split('\\n')[1:n+1])\n    M = 2**m - 1\n    mod = 10**9 + 7\n    \n    def is_good(S: set) -> bool:\n        for a in S:\n            for b in S:\n                if a != b and (int(a, 2) & int(b, 2)) not in S:\n                    return False\n        return True\n    \n    def count_good_sets(T: set, m: int, M: int, mod: int) -> int:\n        def count_good_subsets(T: set, m: int, M: int, mod: int) -> int:\n            dp = [0] * (M+1)\n            dp[0] = 1\n            for t in T:\n                for i in range(M, int(t, 2)-1, -1):\n                    dp[i] = (dp[i] + dp[i-int(t, 2)]) % mod\n            return dp[M]\n        \n        def count_good_sets_with_size(T: set, m: int, M: int, mod: int, size: int) -> int:\n            dp = [0] * (M+1)\n            dp[0] = 1\n            for t in T:\n                for i in range(M, int(t, 2)-1, -1):\n                    dp[i] = (dp[i] + dp[i-int(t, 2)]) % mod\n            return dp[M] - dp[M-size]\n        \n        return (count_good_subsets(T, m, M, mod) - count_good_sets_with_size(T, m, M, mod, 1)) % mod\n    \n    return str(count_good_sets(T, m, M, mod))"
    },
    {
        "number": 2450,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(n: int, m: int, x: int, y: int, pavement: List[List[str]]) -> int:\n        def get_cost(i: int, j: int, k: int, l: int) -> int:\n            return x if k == 1 else y\n\n        def dfs(i: int, j: int, k: int, l: int, visited: Set[Tuple[int, int]]) -> int:\n            if i < 0 or i >= n or j < 0 or j >= m or (i, j) in visited:\n                return 0\n            visited.add((i, j))\n            if pavement[i][j] == '*':\n                return 0\n            return get_cost(i, j, k, l) + dfs(i - 1, j, k, l, visited) + dfs(i + 1, j, k, l, visited) + dfs(i, j - 1, k, l, visited) + dfs(i, j + 1, k, l, visited)\n\n        min_cost = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if pavement[i][j] == '*':\n                    continue\n                visited = set()\n                min_cost = min(min_cost, dfs(i, j, 1, 1, visited))\n        return min_cost\n\n    testcases = stdin.split('\\n')\n    result = []\n    for i in range(0, len(testcases), 2):\n        n, m, x, y = map(int, testcases[i].split())\n        pavement = [list(testcases[i + 1 + j]) for j in range(n)]\n        result.append(get_min_cost(n, m, x, y, pavement))\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2451,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, a, b, k = map(int, stdin.split())\n    queries = []\n    for _ in range(k):\n        t_a, f_a, t_b, f_b = map(int, input().split())\n        queries.append((t_a, f_a, t_b, f_b))\n\n    def min_time(t_a, f_a, t_b, f_b):\n        if t_a == t_b:\n            return abs(f_a - f_b)\n        else:\n            return abs(f_a - a) + abs(b - f_b) + 1\n\n    result = [min_time(t_a, f_a, t_b, f_b) for t_a, f_a, t_b, f_b in queries]\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2452,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        n = int(test_case)\n        permutation = [i for i in range(1, n + 1)]\n        result.append(\" \".join(map(str, permutation)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2453,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    points = set()\n    for segment in segments:\n        l, r = segment\n        points.update(range(l, r+1))\n\n    counts = [0] * (n+1)\n    for point in points:\n        count = sum(1 for segment in segments if segment[0] <= point <= segment[1])\n        counts[count] += 1\n\n    return ' '.join(map(str, counts))"
    },
    {
        "number": 2454,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    roads = [set() for _ in range(N)]\n    for line in stdin.splitlines()[1:]:\n        a, b = map(int, line.split())\n        roads[a - 1].add(b - 1)\n        roads[b - 1].add(a - 1)\n\n    def count_ways(start: int, visited: set, casinos: set) -> int:\n        if len(visited) == N:\n            return 1\n\n        ways = 0\n        for city in roads[start]:\n            if city not in visited:\n                if city not in casinos:\n                    ways += count_ways(city, visited | {start}, casinos | {city})\n                else:\n                    ways += count_ways(city, visited | {start}, casinos)\n\n        return ways\n\n    total_ways = 0\n    for start in range(N):\n        total_ways += count_ways(start, set(), set())\n\n    return str(total_ways % (10**9 + 7))"
    },
    {
        "number": 2455,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_pairs(n: int) -> List[Tuple[int, int]]:\n        pairs = []\n        for a in range(1, n + 1):\n            for b in range(a, n + 1):\n                if a * b == n:\n                    pairs.append((a, b))\n        return pairs\n\n    def check_win(table: List[List[str]]) -> bool:\n        for col in range(len(table[0])):\n            if all(row[col] == \"X\" for row in table):\n                return True\n        return False\n\n    def create_table(cards: List[str], a: int, b: int) -> List[List[str]]:\n        table = [cards[i:i + b] for i in range(0, len(cards), b)]\n        return table\n\n    def process_test(cards: List[str]) -> str:\n        n = len(cards)\n        pairs = find_pairs(n)\n        wins = []\n        for pair in pairs:\n            a, b = pair\n            table = create_table(cards, a, b)\n            if check_win(table):\n                wins.append(pair)\n        return f\"{len(wins)} {' '.join(f'{a}x{b}' for a, b in wins)}\"\n\n    tests = stdin.split(\"\\n\")[1:]\n    results = [process_test(test) for test in tests]\n    return \"\\n\".join(results)"
    },
    {
        "number": 2456,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_painting(n, k, painted_days):\n        def is_connected(cell1, cell2):\n            if cell1[0] == cell2[0]:\n                return abs(cell1[1] - cell2[1]) == 1\n            elif cell1[1] == cell2[1]:\n                return abs(cell1[0] - cell2[0]) == 1\n            else:\n                return False\n\n        def dfs(cell, visited):\n            visited.add(cell)\n            for neighbor in painted_days:\n                if neighbor not in visited and is_connected(cell, neighbor):\n                    dfs(neighbor, visited)\n\n        visited = set()\n        for cell in painted_days:\n            if cell not in visited:\n                dfs(cell, visited)\n                if len(visited) != n:\n                    return False\n        return True\n\n    def count_shapes(n, k):\n        count = 0\n        for i in range(1, k + 1):\n            for j in range(1, k + 1):\n                for l in range(1, k + 1):\n                    for m in range(1, k + 1):\n                        if i + j + l + m == n:\n                            painted_days = [(i, j), (i, l), (i, m), (j, l), (j, m), (l, m)]\n                            if is_valid_painting(n, k, painted_days):\n                                count += 1\n        return count\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, r = map(int, stdin.readline().split())\n        result.append(count_shapes(n, r))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2457,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    for i in range(1, len(test_cases), 2):\n        n, a, b, c, d = map(int, test_cases[i].split())\n        if a - b < 0 or a + b > 1000 or c - d < 0 or c + d > 1000:\n            print(\"No\")\n        else:\n            total_weight = 0\n            for j in range(n):\n                total_weight += random.randint(a - b, a + b)\n            if total_weight >= c - d and total_weight <= c + d:\n                print(\"Yes\")\n            else:\n                print(\"No\")"
    },
    {
        "number": 2458,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(a, b, k):\n        if k == 1:\n            return 1 if a == b else 0\n        if a == b:\n            return 1\n        if a == 1:\n            return count_ways(a, b - 1, k - 1) + count_ways(a, b - 1, k)\n        if b == k:\n            return count_ways(a - 1, b, k) + count_ways(a - 1, b, k - 1)\n        return count_ways(a - 1, b, k) + count_ways(a, b - 1, k) - count_ways(a - 1, b - 1, k)\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        print(count_ways(a, b, k) % 1000000007)"
    },
    {
        "number": 2459,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    for _ in range(q):\n        t, l, r = map(int, stdin.readline().split())\n        if t == 1:\n            a[l:r] = a[l-1:r-1][::-1]\n        else:\n            a[l:r] = a[l:r][::-1]\n\n    return ' '.join(str(a[b[i]-1]) for i in range(m))"
    },
    {
        "number": 2460,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    coordinates = list(map(int, stdin.split()[2:n+m]))\n    taxi_drivers = list(map(int, stdin.split()[n+m:]))\n\n    taxi_drivers_coordinates = [coordinates[i] for i in range(len(coordinates)) if taxi_drivers[i] == 1]\n    riders_coordinates = [coordinates[i] for i in range(len(coordinates)) if taxi_drivers[i] == 0]\n\n    taxi_drivers_coordinates.sort()\n    riders_coordinates.sort()\n\n    closest_taxi_drivers = []\n    for rider in riders_coordinates:\n        closest_taxi_driver = taxi_drivers_coordinates[0]\n        min_distance = abs(rider - closest_taxi_driver)\n        for taxi_driver in taxi_drivers_coordinates:\n            distance = abs(rider - taxi_driver)\n            if distance < min_distance:\n                min_distance = distance\n                closest_taxi_driver = taxi_driver\n        closest_taxi_drivers.append(closest_taxi_driver)\n\n    result = []\n    for i in range(m):\n        result.append(closest_taxi_drivers.count(taxi_drivers_coordinates[i]))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2461,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        for node in graph[start]:\n            if node not in path:\n                new_path = find_path(graph, node, end, path)\n                if new_path:\n                    return new_path\n        return None\n\n    def max_beauty(graph, root, a, n):\n        max_beauty = [0] * n\n        max_beauty[root - 1] = a[root - 1]\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                path = find_path(graph, i + 1, j + 1)\n                if path:\n                    beauty = a[i]\n                    for node in path:\n                        beauty = gcd(beauty, a[node - 1])\n                    max_beauty[i] = max(max_beauty[i], beauty)\n                    max_beauty[j] = max(max_beauty[j], beauty)\n\n        return max_beauty\n\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    max_beauty_list = max_beauty(graph, 1, a, n)\n    return \" \".join(map(str, max_beauty_list))"
    },
    {
        "number": 2462,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_nearly_prime(n: int) -> bool:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if i * i == n:\n                    return False\n                return True\n        return False\n\n    def find_nearly_prime_numbers(n: int) -> list:\n        result = []\n        for i in range(1, n + 1):\n            if is_nearly_prime(i):\n                result.append(i)\n        return result\n\n    def find_solution(n: int) -> str:\n        nearly_prime_numbers = find_nearly_prime_numbers(n)\n        for i in range(len(nearly_prime_numbers)):\n            for j in range(i + 1, len(nearly_prime_numbers)):\n                for k in range(j + 1, len(nearly_prime_numbers)):\n                    for l in range(k + 1, len(nearly_prime_numbers)):\n                        if nearly_prime_numbers[i] + nearly_prime_numbers[j] + nearly_prime_numbers[k] + nearly_prime_numbers[l] == n:\n                            return \"YES \" + str(nearly_prime_numbers[i]) + \" \" + str(nearly_prime_numbers[j]) + \" \" + str(nearly_prime_numbers[k]) + \" \" + str(nearly_prime_numbers[l])\n        return \"NO\"\n\n    test_cases = int(stdin.strip())\n    result = []\n    for i in range(test_cases):\n        n = int(input().strip())\n        result.append(find_solution(n))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2463,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    prices = list(map(int, stdin.split()[1:]))\n    \n    # Find the cheap ice spheres\n    cheap_spheres = []\n    for i in range(1, n-1):\n        if prices[i] < prices[i-1] and prices[i] < prices[i+1]:\n            cheap_spheres.append(i)\n    \n    # Reorder the ice spheres\n    reordered_prices = [prices[i] for i in cheap_spheres]\n    reordered_prices.extend([prices[i] for i in range(n) if i not in cheap_spheres])\n    \n    # Print the result\n    return str(len(cheap_spheres)) + \"\\n\" + \" \".join(map(str, reordered_prices))"
    },
    {
        "number": 2464,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def dfs(node, visited, prev_edge):\n        visited.add(node)\n        for neighbor, edge in enumerate(edges[node - 1], start=1):\n            if neighbor not in visited and edge != 0:\n                if prev_edge == 0:\n                    return dfs(neighbor, visited.copy(), edge)\n                else:\n                    return 1 + dfs(neighbor, visited.copy(), edge)\n        return 0\n\n    count = 0\n    for i in range(1, n + 1):\n        count += dfs(i, set(), 0)\n\n    return str(count)"
    },
    {
        "number": 2465,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        ang = int(stdin.readline())\n        n = 3\n        while True:\n            if ang % n == 0:\n                print(n)\n                break\n            elif n > 998244353:\n                print(-1)\n                break\n            else:\n                n += 1\n    return \"\""
    },
    {
        "number": 2466,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split(',')))\n    result = []\n    def backtrack(first):\n        if first == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(first, len(nums)):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first+1)\n            nums[first], nums[i] = nums[i], nums[first]\n    backtrack(0)\n    return result"
    },
    {
        "number": 2467,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    result = []\n    for i in range(1, 10 - k):\n        for j in range(i + 1, 10):\n            for k in range(j + 1, 10):\n                if i + j + k == n:\n                    result.append([i, j, k])\n    return str(result)"
    },
    {
        "number": 2468,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    max_length = 0\n    current_length = 0\n\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n            current_length += 1\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n                current_length += 2\n            else:\n                stack = []\n                current_length = 0\n\n        max_length = max(max_length, current_length)\n\n    return max_length"
    },
    {
        "number": 2469,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = list(map(int, input().split()))\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for num in count:\n        if count[num] > n // 3:\n            print(num, end=\" \")\n    return \"\" "
    },
    {
        "number": 2470,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr1, arr2 = list(map(int, stdin.split()))\n    n = len(arr1)\n    m = len(arr2)\n    dp = [float('inf')] * m\n    dp[0] = 0\n    for i in range(1, m):\n        for j in range(i):\n            if arr2[i] > arr2[j]:\n                dp[i] = min(dp[i], dp[j] + 1)\n    min_ops = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if arr1[i] < arr2[j]:\n                min_ops = min(min_ops, dp[j])\n    return min_ops if min_ops != float('inf') else -1"
    },
    {
        "number": 2471,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, N = map(int, stdin.split()[:3])\n    a_b = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:-1]]\n    grid = [[0] * W for _ in range(H)]\n\n    for i in range(N):\n        grid[a_b[i][0] - 1][a_b[i][1] - 1] = 1\n\n    result = [0] * 10\n    for i in range(H - 2):\n        for j in range(W - 2):\n            subgrid = [grid[i][j:j+3], grid[i+1][j:j+3], grid[i+2][j:j+3]]\n            count = sum(sum(row) for row in subgrid)\n            result[count] += 1\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2472,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.readline())\n    jobs = []\n    for i in range(N):\n        A, B = map(int, stdin.readline().split())\n        jobs.append((A, B))\n\n    # Sort jobs by deadline\n    jobs.sort(key=lambda x: x[1])\n\n    # Initialize variables\n    current_time = 0\n    completed_jobs = 0\n\n    # Iterate through jobs\n    for job in jobs:\n        # Check if job can be completed within deadline\n        if job[1] < current_time + job[0]:\n            return \"No\"\n\n        # Update current time and completed jobs\n        current_time += job[0]\n        completed_jobs += 1\n\n    # Check if all jobs are completed\n    if completed_jobs == N:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2473,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n\n    def is_valid_rectangle(rectangle):\n        for point in rectangle:\n            if points.count(point) < K:\n                return False\n        return True\n\n    min_area = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                for l in range(k+1, N):\n                    rectangle = (points[i], points[j], points[k], points[l])\n                    if is_valid_rectangle(rectangle):\n                        area = abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1])\n                        if area < min_area:\n                            min_area = area\n\n    return str(min_area)"
    },
    {
        "number": 2474,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = stdin.split()\n    N = int(N)\n    C = list(map(int, C.split()))\n\n    def f(S, T):\n        cost = 0\n        for i in range(N):\n            if S[i] != T[i]:\n                cost += C[i]\n                for j in range(N):\n                    if S[j] != T[j]:\n                        cost += C[j]\n        return cost\n\n    total_cost = 0\n    for i in range(2**N):\n        S = bin(i)[2:].zfill(N)\n        for j in range(2**N):\n            if i != j:\n                T = bin(j)[2:].zfill(N)\n                total_cost += f(S, T)\n\n    return str(total_cost % (10**9 + 7))"
    },
    {
        "number": 2475,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = stdin.split()\n    N = int(N)\n    s = list(map(int, s.split()))\n\n    def dp(A: int, B: int) -> int:\n        dp_table = [[0] * (N + 1) for _ in range(N + 1)]\n        dp_table[0][N - 1] = 0\n\n        for i in range(N - 1, -1, -1):\n            for j in range(N - 1, -1, -1):\n                if i == N - 1:\n                    dp_table[i][j] = s[i]\n                elif j == N - 1:\n                    dp_table[i][j] = dp_table[i + 1][j] + s[i]\n                else:\n                    dp_table[i][j] = max(dp_table[i + 1][j] + s[i], dp_table[i][j + 1] + s[i])\n\n        return dp_table[0][0]\n\n    max_score = -10**100\n    for A in range(1, N):\n        for B in range(1, N):\n            score = dp(A, B)\n            max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 2476,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, cards = stdin.split(\"\\n\")\n    N = int(N)\n    cards = list(map(int, cards.split()))\n\n    result = []\n    for K in range(1, N + 1):\n        count = 0\n        for i in range(N - K + 1):\n            if len(set(cards[i:i + K])) == K:\n                count += 1\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2477,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    logs = list(map(int, stdin.split()[2:]))\n\n    def cut_log(log: int, k: int) -> int:\n        if k == 0:\n            return log\n        t = log / (k + 1)\n        return max(cut_log(t, k - 1), cut_log(log - t, k - 1))\n\n    return str(int(max(logs)) + 1)"
    },
    {
        "number": 2478,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    stack = []\n    for i in range(N):\n        if S[i] == '(':\n            stack.append('(')\n        else:\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(')')\n    while stack:\n        S += stack.pop()\n    return S"
    },
    {
        "number": 2479,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    queries = stdin.split()[2:]\n    grid = [[0] * N for _ in range(N)]\n    black_stones = 0\n\n    for query in queries:\n        query_type, x = map(int, query.split())\n\n        if query_type == 1:\n            for i in range(1, N):\n                if grid[i][x] == 0:\n                    grid[i][x] = 1\n                else:\n                    break\n        else:\n            for j in range(1, N):\n                if grid[x][j] == 0:\n                    grid[x][j] = 1\n                else:\n                    break\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                black_stones += 1\n\n    return str(black_stones)"
    },
    {
        "number": 2480,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    count = 0\n\n    for i in range(N):\n        for j in range(i, N):\n            subsequence = A[i:j+1]\n            if sum(subsequence) % K == len(subsequence):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2481,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    H, W = map(int, lines[0].split())\n    c = [list(map(int, lines[i+1].split())) for i in range(10)]\n    A = [list(map(int, lines[11+i].split())) for i in range(H)]\n\n    def min_cost(i, j):\n        if A[i][j] == -1:\n            return 0\n        if A[i][j] == 0:\n            return c[0][0]\n        if A[i][j] == 9:\n            return c[9][9]\n        return min(min_cost(i, j-1) + c[A[i][j]][9], min_cost(i-1, j) + c[A[i][j]][9])\n\n    total_cost = 0\n    for i in range(H):\n        for j in range(W):\n            total_cost += min_cost(i, j)\n\n    return str(total_cost)"
    },
    {
        "number": 2482,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[Tuple[int, int]], List[Tuple[int, int]]]:\n        N, K, L = map(int, stdin.readline().split())\n        roads = [tuple(map(int, stdin.readline().split())) for _ in range(K)]\n        railways = [tuple(map(int, stdin.readline().split())) for _ in range(L)]\n        return N, roads, railways\n\n    def find_connected_cities(N: int, roads: List[Tuple[int, int]], railways: List[Tuple[int, int]]) -> List[int]:\n        connected_cities = [0] * N\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    connected_cities[i] += 1\n                elif (i, j) in roads or (i, j) in railways:\n                    connected_cities[i] += 1\n                    connected_cities[j] += 1\n        return connected_cities\n\n    N, roads, railways = read_input()\n    connected_cities = find_connected_cities(N, roads, railways)\n    return \" \".join(map(str, connected_cities))"
    },
    {
        "number": 2483,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split()[0:2])\n    programs = []\n    for i in range(N):\n        s_i, t_i, c_i = map(int, stdin.split()[3*i+2:3*i+5])\n        programs.append((s_i, t_i, c_i))\n\n    programs.sort(key=lambda x: x[1])\n    recorders = []\n    for program in programs:\n        s_i, t_i, c_i = program\n        for recorder in recorders:\n            if recorder[1] <= s_i - 0.5:\n                recorder[1] = t_i\n                recorder[2].append(c_i)\n                break\n        else:\n            recorders.append([s_i, t_i, [c_i]])\n\n    return str(len(recorders))"
    },
    {
        "number": 2484,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    count = 0\n\n    for l in range(1, N + 1):\n        for r in range(l, N + 1):\n            xor_sum = 0\n            for i in range(l, r + 1):\n                xor_sum ^= A[i - 1]\n\n            if xor_sum == sum(A[l - 1:r]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2485,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, M = map(int, stdin.split()[:3])\n    targets = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    def destroy_targets(bomb: tuple) -> int:\n        destroyed = 0\n        for target in targets:\n            if bomb[0] == target[0] or bomb[1] == target[1]:\n                destroyed += 1\n        return destroyed\n\n    max_destroyed = 0\n    for i in range(H):\n        for j in range(W):\n            destroyed = destroy_targets((i, j))\n            if destroyed > max_destroyed:\n                max_destroyed = destroyed\n\n    return str(max_destroyed)"
    },
    {
        "number": 2486,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    cards = list(map(int, stdin.split()[2:]))\n\n    def is_good_subset(subset: set) -> bool:\n        return sum(cards[i] for i in subset) >= K\n\n    def is_unnecessary(card_index: int) -> bool:\n        for good_subset in (set(range(i)) for i in range(card_index + 1, N)):\n            if is_good_subset(good_subset) and is_good_subset(good_subset - {card_index}):\n                return True\n        return False\n\n    return str(sum(is_unnecessary(i) for i in range(N)))"
    },
    {
        "number": 2487,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited):\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(graph, neighbor, visited)\n\n    def count_components(graph, vertices):\n        visited = set()\n        count = 0\n        for vertex in vertices:\n            if vertex not in visited:\n                dfs(graph, vertex, visited)\n                count += 1\n        return count\n\n    def sum_f(graph, n):\n        total = 0\n        for L in range(1, n + 1):\n            for R in range(L, n + 1):\n                vertices = set(range(L, R + 1))\n                total += count_components(graph, vertices)\n        return total\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    return str(sum_f(graph, n))"
    },
    {
        "number": 2488,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bomb_effect(x: int, d: int, a: int) -> int:\n        return a * (2 * d + 1)\n\n    def min_bombs(monsters: List[Tuple[int, int]]) -> int:\n        monsters.sort(key=lambda x: x[0])\n        n = len(monsters)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n\n        for i in range(2, n + 1):\n            min_cost = float('inf')\n            for j in range(i):\n                if monsters[i - 1][0] - monsters[j][0] <= 2 * d:\n                    min_cost = min(min_cost, dp[j] + bomb_effect(monsters[i - 1][0], d, a))\n            dp[i] = min_cost\n\n        return dp[n]\n\n    n, d, a = map(int, stdin.split()[:3])\n    monsters = [(int(x), int(h)) for x, h in map(lambda x: x.split(), stdin.split()[3:])]\n\n    return str(min_bombs(monsters))"
    },
    {
        "number": 2489,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    count = 0\n\n    for i in range(N):\n        is_valid = True\n        for j in range(N):\n            if i != j and A[j] % A[i] == 0:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2490,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    banknotes = [10**i for i in range(101)]\n    min_count = float('inf')\n    for i in range(len(banknotes)):\n        if banknotes[i] > N:\n            continue\n        count = 0\n        for j in range(i, len(banknotes)):\n            count += N // banknotes[j]\n            N %= banknotes[j]\n            if N == 0:\n                break\n        min_count = min(min_count, count)\n    return str(min_count)"
    },
    {
        "number": 2491,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    edges = []\n    for i in range(M):\n        a, b, c = map(int, stdin.split()[3*i+2:3*i+5])\n        edges.append((a, b, c))\n\n    def dfs(graph, start, end, visited, score):\n        if start == end:\n            return score\n        max_score = float('-inf')\n        for neighbor, weight in graph[start]:\n            if neighbor not in visited:\n                max_score = max(max_score, dfs(graph, neighbor, end, visited | {neighbor}, score + weight))\n        return max_score\n\n    graph = [[] for _ in range(N + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    max_score = dfs(graph, 1, N, {1}, 0)\n    return str(max_score) if max_score != float('inf') else 'inf'"
    },
    {
        "number": 2492,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    pairs = [(A[i], A[j]) for i in range(N) for j in range(i+1, N)]\n    products = sorted([a*b for a, b in pairs])\n\n    return str(products[K-1])"
    },
    {
        "number": 2493,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n    MOD = 10**9 + 7\n\n    def count_subsequences(k: int) -> int:\n        subsequences = set()\n        for i in range(n + 1 - k):\n            subsequences.add(tuple(sequence[i:i+k]))\n        return len(subsequences) % MOD\n\n    result = [count_subsequences(i) for i in range(1, n + 2)]\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2494,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    min_sum = float('inf')\n    min_multiple = 0\n\n    for i in range(1, 10**5):\n        multiple = i * K\n        digit_sum = sum(int(digit) for digit in str(multiple))\n\n        if digit_sum < min_sum:\n            min_sum = digit_sum\n            min_multiple = multiple\n\n    return str(min_multiple)"
    },
    {
        "number": 2495,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    def check_condition(sequence: List[int], i: int) -> bool:\n        if i == 0:\n            return True\n        if sum(sequence[:i]) == 0:\n            return False\n        if (sum(sequence[:i]) > 0) != (sum(sequence[:i+1]) > 0):\n            return True\n        return False\n\n    operations = 0\n    for i in range(n):\n        while not check_condition(sequence, i):\n            if sequence[i] > 0:\n                sequence[i] -= 1\n            else:\n                sequence[i] += 1\n            operations += 1\n\n    return str(operations)"
    },
    {
        "number": 2496,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    A.sort()\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_pairwise_coprime(A: List[int]) -> bool:\n        for i in range(len(A)):\n            for j in range(i + 1, len(A)):\n                if gcd(A[i], A[j]) != 1:\n                    return False\n        return True\n\n    def is_setwise_coprime(A: List[int]) -> bool:\n        return gcd(A[0], A[1]) == 1 and gcd(A[0], A[1]) == 1\n\n    if is_pairwise_coprime(A):\n        return \"pairwise coprime\"\n    elif is_setwise_coprime(A):\n        return \"setwise coprime\"\n    else:\n        return \"not coprime\""
    },
    {
        "number": 2497,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    points = []\n    for i in range(1, N+1):\n        x, y, d = lines[i].split()\n        points.append((int(x), int(y), d))\n\n    def move_points(points):\n        for i in range(len(points)):\n            x, y, d = points[i]\n            if d == 'R':\n                points[i] = (x+1, y, d)\n            elif d == 'L':\n                points[i] = (x-1, y, d)\n            elif d == 'U':\n                points[i] = (x, y+1, d)\n            elif d == 'D':\n                points[i] = (x, y-1, d)\n        return points\n\n    def get_min_max(points):\n        x_min = min(points, key=lambda x: x[0])[0]\n        x_max = max(points, key=lambda x: x[0])[0]\n        y_min = min(points, key=lambda x: x[1])[1]\n        y_max = max(points, key=lambda x: x[1])[1]\n        return (x_max - x_min) * (y_max - y_min)\n\n    for _ in range(N):\n        points = move_points(points)\n\n    return str(get_min_max(points))"
    },
    {
        "number": 2498,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    semi_common_multiples = set()\n\n    for i in range(N):\n        for j in range(i+1, N):\n            p = 0\n            while True:\n                x = A[i] * (p + 0.5)\n                if x.is_integer() and x > 0 and x <= M:\n                    semi_common_multiples.add(int(x))\n                    p += 1\n                else:\n                    break\n\n    return str(len(semi_common_multiples))"
    },
    {
        "number": 2499,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n    max_beauty = 0\n\n    for i in range(1, N):\n        red = A[:i]\n        blue = A[i:]\n        red_xor = 0\n        blue_xor = 0\n\n        for num in red:\n            red_xor ^= num\n\n        for num in blue:\n            blue_xor ^= num\n\n        beauty = red_xor + blue_xor\n        max_beauty = max(max_beauty, beauty)\n\n    return str(max_beauty)"
    },
    {
        "number": 2500,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for u in range(N+1):\n        for v in range(N+1):\n            if u == v:\n                count += 1\n            else:\n                a = u\n                b = v - u\n                if a >= 0 and b >= 0:\n                    count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 2501,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *heights = map(int, stdin.split())\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(i - j) == heights[i] + heights[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2502,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    max_i = 0\n    found = False\n\n    for i in range(len(s) // len(t) + 1):\n        if s in t * i:\n            max_i = i\n            found = True\n        else:\n            break\n\n    if found:\n        return str(max_i)\n    else:\n        return \"-1\""
    },
    {
        "number": 2503,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, K):\n        return x % K == 0 and y % K == 0\n\n    def is_connected(x1, y1, x2, y2, K):\n        return abs(x1 - x2) % K == 0 and abs(y1 - y2) % K == 0\n\n    def paint_grid(x, y, c, K):\n        if not is_valid(x, y, K):\n            return False\n        if grid[x][y] != '':\n            return grid[x][y] == c\n        grid[x][y] = c\n        for i in range(x - K + 1, x + 1):\n            for j in range(y - K + 1, y + 1):\n                if not is_connected(x, y, i, j, K):\n                    continue\n                if not paint_grid(i, j, c, K):\n                    return False\n        return True\n\n    def max_satisfied_desires(N, K, desires):\n        grid = [['' for _ in range(1000001)] for _ in range(1000001)]\n        satisfied_count = 0\n        for x, y, c in desires:\n            if paint_grid(x, y, c, K):\n                satisfied_count += 1\n        return satisfied_count\n\n    N, K = map(int, stdin.split()[:2])\n    desires = []\n    for i in range(N):\n        x, y, c = map(int, stdin.split()[3 * i:3 * (i + 1)])\n        desires.append((x, y, 'B' if c == 'W' else 'W'))\n\n    return str(max_satisfied_desires(N, K, desires))"
    },
    {
        "number": 2504,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, graph):\n        if start == end:\n            return 0\n        if visited[start][end]:\n            return -1\n        visited[start][end] = True\n        min_steps = float('inf')\n        for next_town in graph[start]:\n            if next_town == end:\n                continue\n            steps = dfs(next_town, end, visited, graph)\n            if steps != -1:\n                min_steps = min(min_steps, steps + 1)\n        visited[start][end] = False\n        return min_steps\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N, M, L = map(int, lines[0].split())\n        roads = [tuple(map(int, line.split())) for line in lines[1:M+1]]\n        Q = int(lines[M+1])\n        queries = [tuple(map(int, line.split())) for line in lines[M+2:]]\n        return N, M, L, roads, Q, queries\n\n    def main(stdin: str) -> str:\n        N, M, L, roads, Q, queries = read_input(stdin)\n        graph = [[] for _ in range(N+1)]\n        for A, B, C in roads:\n            graph[A].append(B)\n            graph[B].append(A)\n\n        results = []\n        for s, t in queries:\n            visited = [[False] * (N+1) for _ in range(N+1)]\n            steps = dfs(s, t, visited, graph)\n            results.append(steps if steps != float('inf') else -1)\n\n        return '\\n'.join(map(str, results))\n\n    return main(stdin)"
    },
    {
        "number": 2505,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(T: set) -> int:\n        x_coords = set(x_i for x_i, y_i in T)\n        y_coords = set(y_i for x_i, y_i in T)\n        return len(x_coords) * len(y_coords)\n\n    N = int(stdin.readline())\n    points = [tuple(map(int, line.split())) for line in stdin.readlines()]\n    subsets = [set(points[i:]) for i in range(N)]\n    total = sum(f(T) for T in subsets)\n    return str(total % 998244353)"
    },
    {
        "number": 2506,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    happiness = 0\n    for i in range(M):\n        for j in range(i+1, M):\n            happiness += A[i] + A[j]\n\n    return str(happiness)"
    },
    {
        "number": 2507,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:2*N+2]))\n    F = list(map(int, stdin.split()[2*N+2:]))\n    \n    # Calculate the maximum consumption coefficient for each food\n    max_consumption = [0] * N\n    for i in range(N):\n        for j in range(N):\n            max_consumption[i] = max(max_consumption[i], A[j])\n    \n    # Calculate the minimum score for each food\n    min_score = [0] * N\n    for i in range(N):\n        min_score[i] = max_consumption[i] * F[i]\n    \n    # Calculate the maximum score for each food\n    max_score = [0] * N\n    for i in range(N):\n        max_score[i] = A[i] * F[i]\n    \n    # Calculate the minimum score for the team\n    min_team_score = float('inf')\n    for i in range(2**N):\n        # Convert the binary number to a list of indices\n        indices = [j for j in range(N) if (i >> j) & 1]\n        \n        # Check if the indices are valid\n        if len(indices) != N:\n            continue\n        \n        # Calculate the score for the team\n        team_score = 0\n        for j in range(N):\n            team_score = max(team_score, max_score[j] * (N - len(indices)))\n            for k in range(len(indices)):\n                if indices[k] == j:\n                    team_score = max(team_score, min_score[j] * (N - len(indices) - 1) + max_score[j])\n        \n        # Update the minimum score for the team\n        min_team_score = min(min_team_score, team_score)\n    \n    return str(min_team_score)"
    },
    {
        "number": 2508,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, dx, dy, grid):\n        new_x, new_y = x + dx, y + dy\n        if 0 <= new_x < H and 0 <= new_y < W:\n            return grid[new_x][new_y] == '.'\n        return False\n\n    def bfs(x1, y1, x2, y2, grid):\n        queue = [(x1, y1, 0)]\n        visited = set()\n        while queue:\n            x, y, dist = queue.pop(0)\n            if (x, y) == (x2, y2):\n                return dist\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    if is_valid_move(x, y, dx, dy, grid):\n                        queue.append((x + dx, y + dy, dist + 1))\n        return -1\n\n    H, W, K = map(int, stdin.readline().split())\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(H)]\n\n    if grid[x1 - 1][y1 - 1] == '@' or grid[x2 - 1][y2 - 1] == '@':\n        return -1\n\n    return bfs(x1 - 1, y1 - 1, x2 - 1, y2 - 1, grid)"
    },
    {
        "number": 2509,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(K+1, N+1):\n        count += N // i\n    return str(count)"
    },
    {
        "number": 2510,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    friends = set()\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            A, B = map(int, line.split())\n            friends.add((min(A, B), max(A, B)))\n\n    groups = set()\n    for friend in friends:\n        if not any(friend[0] in group or friend[1] in group for group in groups):\n            groups.add(frozenset([friend[0], friend[1]]))\n\n    return str(len(groups))"
    },
    {
        "number": 2511,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def dfs(node: int, parent: int) -> int:\n        count = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                count *= dfs(neighbor, node)\n                count %= MOD\n        return count\n\n    MOD = 1_000_000_007\n    graph = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    return str(dfs(1, -1))"
    },
    {
        "number": 2512,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    items = []\n    for i in range(K):\n        r, c, v = map(int, stdin.split()[3:])\n        items.append((r, c, v))\n\n    def dfs(r, c, visited, picked_items):\n        if r < 1 or r > R or c < 1 or c > C:\n            return 0\n\n        if (r, c) in visited:\n            return 0\n\n        visited.add((r, c))\n        if (r, c) in picked_items:\n            return picked_items[(r, c)]\n\n        max_value = 0\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_r, new_c = r + dr, c + dc\n            max_value = max(max_value, dfs(new_r, new_c, visited, picked_items))\n\n        if len(picked_items) < R:\n            picked_items[(r, c)] = max_value\n            return max_value\n        else:\n            return max_value\n\n    picked_items = {}\n    max_value = dfs(1, 1, set(), picked_items)\n    return max_value"
    },
    {
        "number": 2513,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = stdin.split()\n    N = int(N)\n\n    def dfs(i: int, visited: set, sheep: set, wolves: set) -> bool:\n        if i in visited:\n            return False\n        visited.add(i)\n\n        if s[i - 1] == 'o':\n            if i - 1 in sheep and i + 1 in sheep:\n                return True\n            elif i - 1 in wolves and i + 1 in wolves:\n                return True\n            else:\n                return False\n        else:\n            if i - 1 in sheep and i + 1 in sheep:\n                return False\n            elif i - 1 in wolves and i + 1 in wolves:\n                return False\n            else:\n                return True\n\n    for i in range(1, N + 1):\n        visited = set()\n        sheep = set()\n        wolves = set()\n        sheep.add(i)\n\n        if dfs(i, visited, sheep, wolves):\n            return \"\".join([\"S\" if i in sheep else \"W\" for i in range(1, N + 1)])\n\n    return \"-1\""
    },
    {
        "number": 2514,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, Q, B_C = stdin.split('\\n')\n    N = int(N)\n    A = list(map(int, A.split()))\n    Q = int(Q)\n    B_C = list(map(int, B_C.split()))\n    B = B_C[::2]\n    C = B_C[1::2]\n\n    for i in range(Q):\n        for j in range(N):\n            if A[j] == B[i]:\n                A[j] = C[i]\n\n    S = [sum(A)] * Q\n\n    return '\\n'.join(map(str, S))"
    },
    {
        "number": 2515,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(queries):\n        l, r = map(int, stdin.readline().strip().split())\n        count = 0\n\n        for x in range(l, r + 1, 2):\n            if is_similar_to_2017(x):\n                count += 1\n\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))\n\ndef"
    },
    {
        "number": 2516,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = stdin.split()[1]\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            substring = S[i:j]\n            if int(substring) % P == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2517,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int, List[int], List[Tuple[int, int, int]]]:\n        N, M, R = map(int, stdin.readline().split())\n        r = list(map(int, stdin.readline().split()))\n        roads = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n        return N, M, R, r, roads\n\n    def min_distance(N: int, M: int, R: int, r: List[int], roads: List[Tuple[int, int, int]]) -> int:\n        def dfs(town: int, visited: Set[int], distance: int) -> int:\n            if len(visited) == R:\n                return distance\n            min_dist = float('inf')\n            for i, (A, B, C) in enumerate(roads):\n                if A == town or B == town:\n                    if A not in visited:\n                        visited.add(A)\n                        min_dist = min(min_dist, dfs(A, visited, distance + C))\n                        visited.remove(A)\n                    if B not in visited:\n                        visited.add(B)\n                        min_dist = min(min_dist, dfs(B, visited, distance + C))\n                        visited.remove(B)\n            return min_dist\n\n        return dfs(r[0], {r[0]}, 0)\n\n    N, M, R, r, roads = read_input()\n    return str(min_distance(N, M, R, r, roads))"
    },
    {
        "number": 2518,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split()[:3])\n    healths = list(map(int, stdin.split()[3:]))\n\n    explosions = 0\n    while any(health > 0 for health in healths):\n        center_index = healths.index(max(healths))\n        center_health = healths[center_index]\n        healths[center_index] = 0\n\n        for i, health in enumerate(healths):\n            if i != center_index:\n                healths[i] = max(health - B, 0)\n\n        explosions += 1\n\n    return str(explosions)"
    },
    {
        "number": 2519,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.split()[2:]))\n\n    def expected_sum(start: int, end: int) -> float:\n        total = 0\n        for i in range(start, end + 1):\n            total += (i * p[i - 1])\n        return total / sum(p[start - 1:end])\n\n    max_expected_sum = 0\n    for i in range(N - K + 1):\n        max_expected_sum = max(max_expected_sum, expected_sum(i + 1, i + K))\n\n    return f\"{max_expected_sum:.10f}\""
    },
    {
        "number": 2520,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    friendships = [tuple(map(int, line.split())) for line in stdin.split()[3:3+M]]\n    blockships = [tuple(map(int, line.split())) for line in stdin.split()[3+M:]]\n\n    def is_friend_candidate(a: int, b: int) -> bool:\n        if a == b:\n            return False\n        for i in range(M):\n            if (a, b) == friendships[i] or (b, a) == friendships[i]:\n                return False\n        for i in range(K):\n            if (a, b) == blockships[i] or (b, a) == blockships[i]:\n                return False\n        for i in range(N):\n            if i == a or i == b:\n                continue\n            if (a, i) in friendships or (i, a) in friendships:\n                continue\n            if (b, i) in friendships or (i, b) in friendships:\n                continue\n            if (a, i) in blockships or (i, a) in blockships:\n                continue\n            if (b, i) in blockships or (i, b) in blockships:\n                continue\n        return True\n\n    friend_candidates = [0] * N\n    for a in range(N):\n        for b in range(N):\n            if is_friend_candidate(a, b):\n                friend_candidates[a] += 1\n\n    return \" \".join(map(str, friend_candidates))"
    },
    {
        "number": 2521,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split()\n    N = int(N)\n    sequence = list(map(int, sequence.split()))\n\n    max_score = float('-inf')\n    for i in range(N):\n        first_half = sequence[:N]\n        second_half = sequence[N:]\n        first_half.pop(i)\n        second_half.pop(i)\n        score = sum(first_half) - sum(second_half)\n        max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 2522,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A = list(map(int, lines[1].split()))\n    B = list(map(int, lines[2].split()))\n\n    if len(A) != N or len(B) != N:\n        return \"No\"\n\n    reorderings = []\n    for i in range(N):\n        if A[i] != B[i]:\n            reorderings.append(B[i])\n\n    if len(reorderings) == 0:\n        return \"No\"\n\n    reorderings.sort()\n    return \"Yes\\n\" + \" \".join(map(str, reorderings))"
    },
    {
        "number": 2523,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    k = 1\n    while k <= n:\n        for i in range(n - k + 1):\n            for j in range(i, i + k):\n                s[j] = '1' if s[j] == '0' else '0'\n        if all(c == '0' for c in s):\n            return str(k)\n        k += 1\n    return \"Not possible\""
    },
    {
        "number": 2524,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    MOD = 10**9 + 7\n    result = 0\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            result = (result + (A[i] ^ A[j])) % MOD\n\n    return str(result)"
    },
    {
        "number": 2525,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, Q = stdin.split()\n    Q = int(Q)\n    for _ in range(Q):\n        query = stdin.split()\n        if len(query) == 1:\n            S = S[::-1]\n        else:\n            F, C = int(query[1]), query[2]\n            if F == 1:\n                S = C + S\n            else:\n                S = S + C\n    return S"
    },
    {
        "number": 2526,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, A, B, C = map(int, stdin.split()[:5])\n    p = list(map(int, stdin.split()[5:A+5]))\n    q = list(map(int, stdin.split()[A+5:B+A+5]))\n    r = list(map(int, stdin.split()[B+A+5:]))\n\n    def max_deliciousness(X: int, Y: int, A: int, B: int, C: int, p: List[int], q: List[int], r: List[int]) -> int:\n        if X == 0 and Y == 0:\n            return 0\n        if X > A or Y > B:\n            return -1\n\n        if X > 0 and Y > 0:\n            return max(p[X-1] + max_deliciousness(X-1, Y, A, B, C, p, q, r),\n                   q[Y-1] + max_deliciousness(X, Y-1, A, B, C, p, q, r))\n        elif X > 0:\n            return p[X-1] + max_deliciousness(X-1, Y, A, B, C, p, q, r)\n        else:\n            return q[Y-1] + max_deliciousness(X, Y-1, A, B, C, p, q, r)\n\n    return str(max_deliciousness(X, Y, A, B, C, p, q, r))"
    },
    {
        "number": 2527,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = \"iloveyou\"\n    stdin_list = list(stdin)\n    message_list = list(message)\n\n    for char in message_list:\n        if char not in stdin_list:\n            return \"sad\"\n\n    return \"happy\""
    },
    {
        "number": 2528,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    max_length = 0\n    current_length = 0\n    current_product = 1\n\n    for i in range(n):\n        if a[i] == 0:\n            current_product = 1\n            current_length = 0\n        else:\n            current_product *= a[i]\n            current_length += 1\n            max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 2529,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    if x % 5 != 0:\n        return f\"{y:.2f}\"\n    elif y < x + 0.5:\n        return f\"{y:.2f}\"\n    else:\n        return f\"{(y - x - 0.5):.2f}\""
    },
    {
        "number": 2530,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_votes(chefs, emails):\n        votes = {chef: 0 for chef in chefs}\n        for email in emails:\n            for chef in chefs:\n                if email == chef:\n                    votes[chef] += 1\n        return votes\n\n    def get_winner(votes):\n        max_votes = max(votes.values())\n        country_winners = [country for country, votes in votes.items() if votes == max_votes]\n        return min(country_winners)\n\n    def get_chef_of_the_year(votes):\n        max_votes = max(votes.values())\n        chef_of_the_years = [chef for chef, votes in votes.items() if votes == max_votes]\n        return min(chef_of_the_years)\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    chefs = [line.split()[0] for line in lines[1:n+1]]\n    emails = lines[n+1:]\n\n    votes = get_votes(chefs, emails)\n    country_winner = get_winner(votes)\n    chef_of_the_year = get_chef_of_the_year(votes)\n\n    return f\"{country_winner}\\n{chef_of_the_year}\""
    },
    {
        "number": 2531,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequence = [int(x) for x in stdin.split('\\n')[1:N+1]]\n    average_elements = []\n\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(N):\n                if sequence[i] + sequence[j] == 2 * sequence[k]:\n                    average_elements.append(sequence[k])\n\n    return str(len(set(average_elements)))"
    },
    {
        "number": 2532,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+p]))\n    b = list(map(int, stdin.split()[2+p:2+p+q]))\n    d = list(map(int, stdin.split()[2+p+q:]))\n    x = list(map(int, stdin.split()[-10:]))\n\n    def magic_sequence(n: int) -> int:\n        if n == 0:\n            return 0\n        return magic_sequence(n-1) * a[n % len(a)] + sum(b[i] * d[i]**(n % len(d)) for i in range(len(b)))\n\n    n = 0\n    while magic_sequence(n) % 10**6 != x[0]:\n        n += 1\n\n    result = [magic_sequence(n+i) % 10**6 for i in range(1, 11)]\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2533,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_tourist_friendly(graph: List[List[int]]) -> bool:\n        visited = [False] * len(graph)\n        visited[0] = True\n        queue = deque([0])\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n        return all(visited)\n\n    def redirect_roads(graph: List[List[int]]) -> List[Tuple[int, int]]:\n        result = []\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if graph[i][j] != i + 1:\n                    result.append((i + 1, graph[i][j]))\n                    graph[i][j] = i + 1\n\n        return result\n\n    n, e = map(int, stdin.split()[0].split())\n    graph = [[] for _ in range(n)]\n\n    for _ in range(e):\n        a, b = map(int, stdin.split()[0].split())\n        graph[a - 1].append(b)\n\n    if is_tourist_friendly(graph):\n        return \"YES\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in redirect_roads(graph))\n    else:\n        return \"NO\""
    },
    {
        "number": 2534,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    matrix = [list(map(int, input().split())) for _ in range(R)]\n\n    min_row_max_col = float('inf')\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] < min_row_max_col and all(matrix[i][j] > matrix[k][j] for k in range(R)):\n                min_row_max_col = matrix[i][j]\n\n    return \"GUESS\" if min_row_max_col == float('inf') else str(min_row_max_col)"
    },
    {
        "number": 2535,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, N = map(int, stdin.split())\n    cars = stdin.split('\\n')[1:]\n\n    def count_ways(car: str, compartment: int) -> int:\n        places = [int(car[i]) for i in range(54)]\n        compartments = [places[i:i + 6] for i in range(0, 54, 6)]\n        free_places = [i for i, place in enumerate(compartments[compartment]) if place == 0]\n        return len(free_places)\n\n    total_ways = 0\n    for car in cars:\n        for compartment in range(9):\n            total_ways += count_ways(car, compartment) == X\n\n    return str(total_ways)"
    },
    {
        "number": 2536,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sum(matrix, pairs):\n        result = 0\n        for pair in pairs:\n            i, j = pair\n            if 0 <= i < len(matrix) and 0 <= j < len(matrix[0]):\n                result += matrix[i][j]\n            else:\n                return -1\n        return result\n\n    def max_sum(matrix, pairs):\n        return max(calculate_sum(matrix, pairs), calculate_sum(list(zip(*matrix)), pairs))\n\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    matrix = [list(map(int, lines[i + 1].split())) for i in range(N)]\n    L = int(lines[N + 1])\n    pairs = [tuple(map(int, lines[N + 2 + i].split())) for i in range(L)]\n\n    return str(max_sum(matrix, pairs))"
    },
    {
        "number": 2537,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    for _ in range(q):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        p = stdin.readline().strip()\n\n        if len(s) != len(t) or len(s) != len(p):\n            print(\"NO\")\n            continue\n\n        for char in p:\n            if char not in s:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")"
    },
    {
        "number": 2538,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        str, int, exp = map(int, stdin.readline().split())\n        if exp == 0:\n            result.append(0)\n        elif str > int:\n            result.append(exp // 2 + 1)\n        elif str < int:\n            result.append(exp // 2)\n        else:\n            result.append(exp)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2539,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    queries = []\n    for i in range(1, t+1):\n        x, p, k = map(int, stdin.split('\\n')[i].split())\n        queries.append((x, p, k))\n\n    results = []\n    for x, p, k in queries:\n        y = x + 1\n        while True:\n            if gcd(p, y) == 1:\n                results.append(y)\n                k -= 1\n                if k == 0:\n                    break\n            y += 1\n\n    return '\\n'.join(map(str, results))\n\ndef"
    },
    {
        "number": 2540,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colours = list(map(int, stdin.readline().strip().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        tree[x].append(y)\n        tree[y].append(x)\n\n    def dfs(node: int, parent: int) -> dict:\n        count = {colours[node]: 1}\n        for child in tree[node]:\n            if child != parent:\n                child_count = dfs(child, node)\n                for colour, value in child_count.items():\n                    if colour in count:\n                        count[colour] += value\n                    else:\n                        count[colour] = value\n        return count\n\n    result = []\n    for i in range(1, n + 1):\n        count = dfs(i, -1)\n        dominating_sum = sum(count.values())\n        result.append(dominating_sum)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2541,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(queries):\n        L, R = map(int, stdin.readline().strip().split())\n        count = 0\n\n        for x in range(L, R + 1):\n            if x == 1:\n                count += 1\n            else:\n                for a in range(2, x):\n                    p = 1\n                    while a ** p <= x:\n                        if a ** p == x:\n                            count += 1\n                            break\n                        p += 1\n\n        result.append(str(count))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2542,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    result = []\n\n    for i in range(1, t + 1):\n        s = stdin.split('\\n')[i]\n        left_shift = s[1:] + s[0]\n        right_shift = s[-1:] + s[:-1]\n\n        if left_shift == right_shift:\n            result.append(0)\n        else:\n            result.append(min(s.count(left_shift[0]), s.count(right_shift[0])))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2543,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    f = lambda j: abs(sum((-1)**(i-1) * (a[i] - b[i+j]) for i in range(n)))\n    min_f = min(f(j) for j in range(m-n+1))\n    stdin.readline()\n    result = [min_f]\n    for _ in range(q):\n        l, r, x = map(int, stdin.readline().split())\n        for i in range(l-1, r):\n            a[i] += x\n        min_f = min(f(j) for j in range(m-n+1))\n        result.append(min_f)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2544,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_centroid(graph: List[List[int]]) -> int:\n        n = len(graph)\n        visited = [False] * n\n        visited[0] = True\n        stack = [0]\n        parent = [-1] * n\n        while stack:\n            u = stack.pop()\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    parent[v] = u\n                    stack.append(v)\n        size = [1] * n\n        for i in range(n):\n            size[parent[i]] += size[i]\n        max_size = 0\n        centroid = -1\n        for i in range(n):\n            if size[i] > max_size:\n                max_size = size[i]\n                centroid = i\n        return centroid\n\n    def find_edge(graph: List[List[int]], centroid: int) -> Tuple[int, int]:\n        n = len(graph)\n        visited = [False] * n\n        visited[centroid] = True\n        stack = [centroid]\n        while stack:\n            u = stack.pop()\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    stack.append(v)\n        for i in range(n):\n            if i != centroid and len(graph[i]) == 1:\n                return (centroid, i)\n        return (-1, -1)\n\n    def add_edge(graph: List[List[int]], x: int, y: int) -> List[List[int]]:\n        graph[x].append(y)\n        graph[y].append(x)\n        return graph\n\n    def remove_edge(graph: List[List[int]], x: int, y: int) -> List[List[int]]:\n        graph[x].remove(y)\n        graph[y].remove(x)\n        return graph\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            x, y = map(int, stdin.readline().split())\n            graph[x - 1].append(y - 1)\n            graph[y - 1].append(x - 1)\n        centroid = find_centroid(graph)\n        x, y = find_edge(graph, centroid)\n        graph = remove_edge(graph, x, y)\n        centroid = find_centroid(graph)\n        x, y = find_edge(graph, centroid)\n        graph = add_edge(graph, x, y)\n        print(x + 1, y + 1)\n        print(x + 1, y + 1)\n\ninput_str = \"\"\"5\n1 2\n1 3\n2 4\n2 5\n6\n1 2\n1 3\n1 4\n2 5\n2 6\"\"\"\nsolution(input_str) "
    },
    {
        "number": 2545,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    results = []\n\n    for i in range(1, t + 1):\n        a, b = map(int, test_cases[i].split())\n        if a == 0 and b == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 2546,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(salaries):\n        salaries.sort()\n        return salaries[len(salaries) // 2]\n\n    def distribute_salaries(n, s, salaries):\n        total_salary = sum(salaries)\n        if total_salary > s:\n            return 0\n        salaries.sort()\n        median = find_median(salaries)\n        return median\n\n    def main():\n        test_cases = int(stdin.readline())\n        result = []\n        for _ in range(test_cases):\n            n, s = map(int, stdin.readline().split())\n            salaries = []\n            for _ in range(n):\n                l, r = map(int, stdin.readline().split())\n                salaries.append(l)\n            result.append(distribute_salaries(n, s, salaries))\n        return result\n\n    return '\\n'.join(map(str, main()))\n"
    },
    {
        "number": 2547,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    books = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            t, a, b = map(int, line.split())\n            books.append((t, a, b))\n\n    def is_valid(book_set):\n        alice_books = [book for book in book_set if book[1] == 1]\n        bob_books = [book for book in book_set if book[2] == 1]\n        return len(alice_books) >= k and len(bob_books) >= k\n\n    def total_time(book_set):\n        return sum(book[0] for book in book_set)\n\n    min_time = float('inf')\n    min_book_set = None\n\n    for i in range(1, 2**n):\n        book_set = [books[j] for j in range(n) if (i >> j) & 1]\n        if is_valid(book_set) and total_time(book_set) < min_time:\n            min_time = total_time(book_set)\n            min_book_set = book_set\n\n    if min_book_set:\n        return str(min_time) + '\\n' + ' '.join(str(books.index(book) + 1) for book in min_book_set)\n    else:\n        return '-1'"
    },
    {
        "number": 2548,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_subarray(a: List[int], l: int, r: int) -> bool:\n        return sum(a[l:r+1]) == r - l + 1\n\n    def count_good_subarrays(a: List[int]) -> int:\n        n = len(a)\n        count = 0\n        for l in range(n):\n            for r in range(l, n):\n                if is_good_subarray(a, l, r):\n                    count += 1\n        return count\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().strip()))\n        result.append(count_good_subarrays(a))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2549,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    monster_strengths = list(map(int, stdin.split()[2:2+n]))\n    shields = []\n    for i in range(m):\n        shields.append(list(map(int, stdin.split()[2+n+i*2:2+n+i*2+2])))\n    \n    def expected_damage(shield, monster_strengths):\n        expected_damage = 0\n        for monster_strength in monster_strengths:\n            if shield[0] == 0:\n                expected_damage += monster_strength\n            elif monster_strength >= shield[1]:\n                expected_damage += 0\n                shield[0] -= 1\n            else:\n                expected_damage += 0\n        return expected_damage\n    \n    result = []\n    for shield in shields:\n        result.append(expected_damage(shield, monster_strengths))\n    \n    return \" \".join(map(str, result))"
    },
    {
        "number": 2550,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.splitlines()[0])\n    result = []\n\n    for i in range(test_cases):\n        n, m = map(int, stdin.splitlines()[i * 2 + 1].split())\n        a = list(map(int, stdin.splitlines()[i * 2 + 2].split()))\n\n        avg = sum(a) / n\n        max_score = m - sum(a) + (n - 1) * avg\n        result.append(int(max_score))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2551,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n\n        if len(s) < len(t):\n            result.append(-1)\n            continue\n\n        z = \"\"\n        operations = 0\n        for i in range(len(t)):\n            if z == t[:i+1]:\n                continue\n            for j in range(len(s)):\n                if s[j:j+i+1] == t[:i+1]:\n                    z += s[j:j+i+1]\n                    operations += 1\n                    break\n\n        result.append(operations)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2552,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def happiness_index(n, m, p, h, roads):\n        happiness = [0] * n\n        for i in range(n):\n            happiness[i] = p[i]\n        for i in range(n - 1):\n            x, y = roads[i]\n            happiness[x - 1] -= p[y - 1]\n            happiness[y - 1] -= p[x - 1]\n        for i in range(n):\n            if happiness[i] != h[i]:\n                return False\n        return True\n\n    def read_input(stdin: str) -> list:\n        lines = stdin.split(\"\\n\")\n        test_cases = int(lines[0])\n        inputs = []\n        for i in range(test_cases):\n            n, m = map(int, lines[i * 4 + 1].split())\n            p = list(map(int, lines[i * 4 + 2].split()))\n            h = list(map(int, lines[i * 4 + 3].split()))\n            roads = []\n            for j in range(n - 1):\n                x, y = map(int, lines[i * 4 + 4 + j].split())\n                roads.append((x, y))\n            inputs.append((n, m, p, h, roads))\n        return inputs\n\n    inputs = read_input(stdin)\n    results = []\n    for n, m, p, h, roads in inputs:\n        if happiness_index(n, m, p, h, roads):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return \"\\n\".join(results)"
    },
    {
        "number": 2553,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    result = []\n    for i in range(1, len(cases), 2):\n        n, x = map(int, cases[i-1].split())\n        a = list(map(int, cases[i].split()))\n        if x > n:\n            result.append(\"No\")\n        else:\n            odd_sum = sum(a[::2]) % 2 == 1\n            even_sum = sum(a[1::2]) % 2 == 1\n            if odd_sum or even_sum:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2554,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_subarray(a: List[int]) -> int:\n        even_sum = sum(a[::2])\n        odd_sum = sum(a[1::2])\n        if even_sum >= odd_sum:\n            return even_sum\n        else:\n            return odd_sum\n\n    def process_test_case(n: int, a: List[int]) -> int:\n        a.sort(reverse=True)\n        return reverse_subarray(a)\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(process_test_case(n, a))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2555,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap(a, l, r):\n        a[l], a[r] = a[r], a[l]\n\n    def max_army_strength(a, n, q, operations):\n        max_strength = 0\n        for i in range(n):\n            max_strength += a[i]\n\n        for operation in operations:\n            l, r = operation\n            swap(a, l - 1, r - 1)\n            temp_strength = 0\n            for i in range(n):\n                temp_strength += a[i]\n            max_strength = max(max_strength, temp_strength)\n\n        return max_strength\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n, q = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        operations = []\n\n        for _ in range(q):\n            l, r = map(int, stdin.readline().split())\n            operations.append((l, r))\n\n        max_strength = max_army_strength(a, n, q, operations)\n        result.append(max_strength)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2556,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    result = []\n\n    for i in range(n):\n        c_i, sum_i = map(int, stdin.readline().strip().split())\n        min_cost = float('inf')\n\n        for sections in range(sum_i, c_i * sum_i + 1, sum_i):\n            cost = sections ** 2\n            min_cost = min(min_cost, cost)\n\n        result.append(min_cost)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2557,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    pipes = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2*i+2:2*i+4])\n        pipes.append((a, b))\n\n    def dfs(city, visited, path):\n        if visited[city]:\n            return\n        visited[city] = True\n        for a, b in pipes:\n            if a == city:\n                dfs(b, visited, path)\n            elif b == city:\n                dfs(a, visited, path)\n        path.append(city)\n\n    min_pipes = float('inf')\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        path = []\n        dfs(i, visited, path)\n        min_pipes = min(min_pipes, len(path)-1)\n\n    return str(min_pipes)"
    },
    {
        "number": 2558,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = int(stdin.strip())\n    result = []\n\n    for _ in range(testcases):\n        a, b, c, d = map(int, stdin.split())\n        enemy_health = 1\n        while enemy_health > 0:\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health += b * c\n            if enemy_health <= 0:\n                result.append(1)\n                break\n            enemy_health -= a\n            if enemy_health <= 0:\n                result.append(1)"
    },
    {
        "number": 2559,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        lines = stdin.split(\"\\n\")\n        t = int(lines[0])\n        test_cases = []\n        for i in range(1, t + 1):\n            k = int(lines[i * 2 - 1])\n            roads = []\n            for j in range(1, 2 * k):\n                a, b, t = map(int, lines[i * 2 - 1 + j].split())\n                roads.append((a, b, t))\n            test_cases.append((k, roads))\n        return test_cases\n\n    def min_max_sum(k, roads):\n        def dfs(u, visited, parent, time):\n            visited[u] = True\n            for v, t in roads:\n                if not visited[v]:\n                    time += t\n                    time = dfs(v, visited, u, time)\n            time -= f[u]\n            return time\n\n        f = [0] * (2 * k)\n        for i in range(1, k + 1):\n            f[2 * i - 1] = f[2 * i] = i\n\n        visited = [False] * (2 * k)\n        min_time = float('inf')\n        max_time = float('-inf')\n        for i in range(1, k + 1):\n            time = dfs(2 * i - 1, visited, -1, 0)\n            min_time = min(min_time, time)\n            time = dfs(2 * i, visited, -1, 0)\n            max_time = max(max_time, time)\n        return min_time, max_time\n\n    test_cases = read_input()\n    result = []\n    for k, roads in test_cases:\n        min_time, max_time = min_max_sum(k, roads)\n        result.append((min_time, max_time))\n    return \"\\n\".join(f\"{min_time} {max_time}\" for min_time, max_time in result)"
    },
    {
        "number": 2560,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n\n    for _ in range(t):\n        n, l, r = map(int, stdin.split()[1:])\n        if n <= r - l + 1:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2561,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        a = int(stdin.readline())\n        count = 0\n        for x in range(a + 1):\n            if a - (a ^ x) - x == 0:\n                count += 1\n        result.append(str(count))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2562,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, soldiers = map(int, stdin.split())\n    soldiers.sort()\n    gcd_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            gcd_sum += gcd(soldiers[i], soldiers[j])\n    return str(gcd_sum % 1000000007)\n\ndef"
    },
    {
        "number": 2563,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap_digits(a: str, i: int, j: int) -> str:\n        if a[i] != a[j]:\n            a = list(a)\n            a[i], a[j] = a[j], a[i]\n            return \"\".join(a)\n        return a\n\n    def min_integer(a: str) -> str:\n        n = len(a)\n        min_a = a\n        for i in range(n - 1):\n            if a[i] % 2 != a[i + 1] % 2:\n                min_a = min(min_a, swap_digits(a, i, i + 1))\n        return min_a\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        a = stdin.readline().strip()\n        print(min_integer(a))"
    },
    {
        "number": 2564,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(T):\n        a, b, n = map(int, stdin.readline().strip().split())\n        if a >= n or b >= n:\n            result.append(0)\n        else:\n            result.append(min(n - a, n - b))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2565,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_sum(x1, y1, z1, x2, y2, z2):\n        if x1 + y1 + z1 != x2 + y2 + z2:\n            return \"Invalid input\"\n        if x1 > x2:\n            x1, x2 = x2, x1\n        if y1 > y2:\n            y1, y2 = y2, y1\n        if z1 > z2:\n            z1, z2 = z2, z1\n        if x1 + y1 + z1 == 0:\n            return 0\n        if x1 == 0:\n            return max(y1 + z1, y2 + z2)\n        if y1 == 0:\n            return max(x1 + z1, x2 + z2)\n        if z1 == 0:\n            return max(x1 + y1, x2 + y2)\n        if x1 == x2 and y1 == y2 and z1 == z2:\n            return 0\n        if x1 == x2 and y1 == y2:\n            return z1 + z2\n        if x1 == x2 and z1 == z2:\n            return y1 + y2\n        if y1 == y2 and z1 == z2:\n            return x1 + x2\n        if x1 == y1 and y1 == z1:\n            return x2 + y2 + z2\n        if x1 == y1 and z1 == x2:\n            return y2 + z2\n        if y1 == z1 and z1 == x2:\n            return x2 + y2\n        if x1 == y1 and x2 == z1:\n            return y2 + z2\n        if y1 == z1 and y2 == x1:\n            return x2 + z2\n        if z1 == x2 and z2 == y1:\n            return x1 + y2\n        return max(x1 + y1 + z2, x1 + y2 + z1, x2 + y1 + z1)\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        x1, y1, z1 = map(int, stdin.readline().split())\n        x2, y2, z2 = map(int, stdin.readline().split())\n        result.append(max_sum(x1, y1, z1, x2, y2, z2))\n\n    return \"\\n\".join(map(str, result))\n\ninput_str = \"\"\"3\n2 3 2\n3 3 1\n4 0 1\n2 3 0\n0 0 1\n0 0 1\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 2566,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        k = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        days = [i for i in range(7) if a[i] == 1]\n        if k > 7:\n            print(k)\n        else:\n            min_days = float('inf')\n            for i in range(len(days)):\n                for j in range(i, len(days)):\n                    if sum(a[days[i:j+1]]) == k:\n                        min_days = min(min_days, j-i+1)\n            print(min_days)"
    },
    {
        "number": 2567,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        s = test_cases[i + 1]\n        w = \"\"\n\n        for j in range(1, n + 1):\n            for k in range(j, 2 * n - 1, n):\n                if s[k - 1] == s[k]:\n                    w += s[k - 1]\n                    break\n\n        result.append(w)\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2568,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process(s: str) -> int:\n        res = 0\n        for init in range(1000000):\n            cur = init\n            ok = True\n            for i in range(1, len(s) + 1):\n                res += 1\n                if s[i - 1] == '+':\n                    cur += 1\n                else:\n                    cur -= 1\n                if cur < 0:\n                    ok = False\n                    break\n            if ok:\n                break\n        return res\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        s = stdin.readline().strip()\n        print(process(s))"
    },
    {
        "number": 2569,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_claw_vertices(n: int) -> int:\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0\n        if n == 3:\n            return 4\n        if n == 4:\n            return 4\n        return 0\n\n    def count_max_yellow_vertices(n: int) -> int:\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0\n        if n == 3:\n            return 4\n        if n == 4:\n            return 4\n        return 0\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        print(count_max_yellow_vertices(n))"
    },
    {
        "number": 2570,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\\n\")\n    result = []\n\n    for case in cases:\n        lines = case.split(\"\\n\")\n        n, x = map(int, lines[0].split())\n        a = list(map(int, lines[1].split()))\n        b = list(map(int, lines[2].split()))\n\n        b.sort()\n        b.reverse()\n\n        for i in range(n):\n            if a[i] + b[i] > x:\n                result.append(\"No\")\n                break\n        else:\n            result.append(\"Yes\")\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2571,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rooms = stdin.split(\"\\n\")\n    result = []\n\n    for room in rooms[1:]:\n        n = int(room)\n        energies = list(map(int, rooms[rooms.index(room) + 1].split()))\n        seals = []\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    seal = [0] * n\n                    seal[i] = energies[i]\n                    seal[j] = -energies[i]\n                    seals.append(seal)\n\n        result.append(\" \".join(str(seal) for seal in seals))\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2572,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_nice(matrix: List[List[int]]) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            if not is_palindrome(''.join(map(str, matrix[i]))):\n                return False\n        for j in range(m):\n            if not is_palindrome(''.join(map(str, [matrix[i][j] for i in range(n)]))):\n                return False\n        return True\n\n    def min_operations(matrix: List[List[int]]) -> int:\n        n, m = len(matrix), len(matrix[0])\n        operations = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] % 2 == 0:\n                    operations += 1\n                else:\n                    operations += 2\n        return operations\n\n    tests = int(stdin.readline())\n    result = []\n    for _ in range(tests):\n        n, m = map(int, stdin.readline().split())\n        matrix = [list(map(int, stdin.readline().split())) for _ in range(n)]\n        if is_nice(matrix):\n            result.append('0')\n        else:\n            result.append(str(min_operations(matrix)))\n    return '\\n'.join(result)\n"
    },
    {
        "number": 2573,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    changes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:1+m]]\n    board = [[0] * n for _ in range(n)]\n    for x, y in changes:\n        board[y-1][x-1] ^= 1\n        min_rows = min(n - y, y)\n        if board[y-1][k-1] == 1:\n            print(min_rows)\n        else:\n            print(min_rows + 1)\n    return \"\""
    },
    {
        "number": 2574,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_product(a: List[int]) -> int:\n        a.sort()\n        return max(a[-1] * a[-2] * a[-3] * a[-4] * a[-5], a[0] * a[1] * a[2] * a[3] * a[4])\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(max_product(a))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2575,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tests = stdin.split(\"\\n\")\n    for test in tests:\n        angle = int(test)\n        if angle == 30 or angle == 120 or angle == 150 or angle == 210 or angle == 240 or angle == 330:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2576,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    result = []\n\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.split()[1:])\n        cutoff_score = max(a + b, c + d)\n        result.append(str(cutoff_score))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2577,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(matrix):\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(m):\n                if j > 0 and matrix[i][j] == matrix[i][j - 1]:\n                    return False\n                if i > 0 and matrix[i][j] == matrix[i - 1][j]:\n                    return False\n        return True\n\n    def increment_matrix(matrix):\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(m):\n                if j > 0 and matrix[i][j] == matrix[i][j - 1]:\n                    matrix[i][j] += 1\n                if i > 0 and matrix[i][j] == matrix[i - 1][j]:\n                    matrix[i][j] += 1\n\n    def print_matrix(matrix):\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(m):\n                print(matrix[i][j], end=\" \")\n            print()\n\n    test_cases = int(stdin.readline())\n    for i in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        matrix = []\n        for j in range(n):\n            row = list(map(int, stdin.readline().split()))\n            matrix.append(row)\n        while not is_good(matrix):\n            increment_matrix(matrix)\n        print_matrix(matrix)\n        print()\n\ninput_str = \"\"\"3\n3 2\n1 2\n4 5\n7 8\n2 2\n1 1\n3 3\n2 2\n1 3\n2 2\"\"\"\nsolution(input_str) "
    },
    {
        "number": 2578,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = [set() for _ in range(m)]\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            group_size, *users = map(int, line.split())\n            for user in users:\n                groups[user - 1].add(group_size)\n\n    result = []\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if i != j and any(i in group for group in groups[j]):\n                count += 1\n        result.append(count)\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2579,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y, k = map(int, stdin.split())\n    max_experience = r * y\n    min_cost = x * l\n    max_cost = y * r\n    if k * min_cost > max_experience or k * max_cost < max_experience:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 2580,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factors(n: int) -> List[int]:\n        factors = []\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 2:\n            factors.append(n)\n        return factors\n\n    def max_distribution_index(n: int, edges: List[Tuple[int, int]], k: int) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n\n        def dfs(u: int, parent: int) -> int:\n            result = 1\n            for v in graph[u]:\n                if v != parent:\n                    result += dfs(v, u)\n            return result\n\n        def sum_of_products(u: int, v: int) -> int:\n            def lca(u: int, v: int) -> int:\n                depth_u = depth[u]\n                depth_v = depth[v]\n                if depth_u > depth_v:\n                    u, v = v, u\n                    depth_u, depth_v = depth_v, depth_u\n                for _ in range(depth_v - depth_u):\n                    v = parent[v]\n                if u == v:\n                    return u\n                while parent[u] != parent[v]:\n                    u = parent[u]\n                    v = parent[v]\n                return parent[u]\n\n            l = lca(u, v)\n            depth_u = depth[u]\n            depth_v = depth[v]\n            return (dfs(u, -1) - 1) * (dfs(v, -1) - 1) * (2 ** (depth_u + depth_v - 2 * depth[l]))\n\n        depth = [0] * n\n        parent = [-1] * n\n        queue = [0]\n        depth[0] = 0\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                if v != parent[u]:\n                    parent[v] = u\n                    depth[v] = depth[u] + 1\n                    queue.append(v)\n\n        max_product = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                max_product = max(max_product, sum_of_products(i, j))\n\n        return max_product\n\n    def read_input() -> List[Tuple[int, int]]:\n        n, m = map(int, stdin.readline().strip().split())\n        edges = []\n        for _ in range(n - 1):\n            u, v = map(int, stdin.readline().strip().split())\n            edges.append((u, v))\n        factors = list(map(int, stdin.readline().strip().split()))\n        return edges, factors\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        edges, factors = read_input()\n        k = 1\n        for factor in factors:\n            k *= factor\n        result.append(max_distribution_index(len(edges) + 1, edges, k))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2581,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_attacked(bishop1: tuple, bishop2: tuple) -> bool:\n        return bishop1[0] + bishop1[1] == bishop2[0] + bishop2[1] or abs(bishop1[0] - bishop2[0]) == abs(bishop1[1] - bishop2[1])\n\n    def get_max_money(bishop1: tuple, bishop2: tuple) -> int:\n        return sum(board[i][j] for i in range(n) for j in range(n) if not is_attacked((i, j), bishop1) and not is_attacked((i, j), bishop2))\n\n    max_money = 0\n    max_bishop1 = None\n    max_bishop2 = None\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n                    if i != k and j != l:\n                        money = get_max_money((i, j), (k, l))\n                        if money > max_money:\n                            max_money = money\n                            max_bishop1 = (i, j)\n                            max_bishop2 = (k, l)\n\n    return f\"{max_money}\\n{max_bishop1[0]+1} {max_bishop1[1]+1} {max_bishop2[0]+1} {max_bishop2[1]+1}\""
    },
    {
        "number": 2582,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    n = int(n)\n    p = list(map(int, p.split()))\n\n    def is_special(l, r):\n        return p[l] + p[r] == max(p[l:r+1])\n\n    count = 0\n    for l in range(n):\n        for r in range(l, n):\n            if is_special(l, r):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2583,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(input())\n        if n == 1:\n            print(\"FastestFinger\")\n        elif n == 2:\n            print(\"Ashishgup\")\n        elif n == 3:\n            print(\"Ashishgup\")\n        else:\n            print(\"Ashishgup\")"
    },
    {
        "number": 2584,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def buy_goods(prices: List[int], coins: int, k: int) -> int:\n        prices.sort(reverse=True)\n        count = 0\n        for price in prices:\n            if coins >= price:\n                coins -= price\n                count += 1\n                if count == k:\n                    break\n        return count\n\n    def read_input(stdin: str) -> List[Tuple[int, List[int]]]:\n        test_cases = []\n        for line in stdin.split('\\n'):\n            if line.strip() == '':\n                continue\n            n, p, k = map(int, line.split())\n            prices = list(map(int, next(stdin_iter).split()))\n            test_cases.append((n, p, k, prices))\n        return test_cases\n\n    stdin_iter = iter(stdin.split('\\n'))\n    t = int(next(stdin_iter))\n    result = []\n\n    for _ in range(t):\n        n, p, k, prices = read_input(stdin)\n        result.append(str(buy_goods(prices, p, k)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2585,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def max_gcd(n: int) -> int:\n        max_gcd_value = 0\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                max_gcd_value = max(max_gcd_value, gcd(i, j))\n        return max_gcd_value\n\n    test_cases = int(stdin.strip())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(input())\n        result.append(str(max_gcd(n)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2586,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(board: List[List[str]]) -> bool:\n        def count_neighbors(board: List[List[str]], row: int, col: int, color: str) -> int:\n            count = 0\n            for i in range(max(0, row - 1), min(row + 2, len(board))):\n                for j in range(max(0, col - 1), min(col + 2, len(board[0]))):\n                    if i != row or j != col:\n                        if board[i][j] == color:\n                            count += 1\n            return count\n\n        black_count = 0\n        white_count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'B':\n                    black_count += count_neighbors(board, i, j, 'W')\n                elif board[i][j] == 'W':\n                    white_count += count_neighbors(board, i, j, 'B')\n        return black_count == white_count + 1\n\n    def generate_board(n: int, m: int) -> List[List[str]]:\n        board = [['B' if i % 2 == j % 2 else 'W' for j in range(m)] for i in range(n)]\n        return board\n\n    def print_board(board: List[List[str]]) -> None:\n        for row in board:\n            print(''.join(row))\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        board = generate_board(n, m)\n        while not is_good(board):\n            board = generate_board(n, m)\n        print_board(board)"
    },
    {
        "number": 2587,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_r(x: int) -> int:\n        k = ''\n        for digit in str(x):\n            k += bin(int(digit))[2:].zfill(4)\n        return int(k)\n\n    def min_x(n: int) -> int:\n        x = 0\n        for i in range(1, 10**n):\n            if max_r(i) < max_r(x):\n                x = i\n        return x\n\n    t = int(stdin.strip())\n    result = []\n    for _ in range(t):\n        n = int(input())\n        result.append(min_x(n))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2588,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n, a, b = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n\n        # Calculate the cost of the pillars\n        pillar_cost = (n + 1) * b\n\n        # Initialize the cost of the pipeline\n        pipeline_cost = 0\n\n        # Initialize the current height of the pipeline\n        current_height = 1\n\n        # Iterate through the road\n        for i in range(n):\n            # If there is a crossroad, lift the pipeline up to the height 2\n            if s[i] == '1':\n                current_height = 2\n                pipeline_cost += 0.5 * a + 1 * b + 0.5 * a\n            # If the current height is 2, install a pillar\n            elif current_height == 2:\n                current_height = 1\n                pipeline_cost += 2 * a\n\n        result.append(int(pipeline_cost + pillar_cost))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2589,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_divisible(arr, x):\n        return sum(arr) % x == 0\n\n    def longest_subarray(arr, x):\n        n = len(arr)\n        dp = [0] * (n + 1)\n        max_length = 0\n\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + arr[i - 1]\n\n            if dp[i] % x == 0:\n                max_length = i\n            else:\n                max_length = max(max_length, i)\n\n        return max_length\n\n    def process_test_case(test_case):\n        n, x = map(int, test_case.split())\n        arr = list(map(int, input().split()))\n\n        if is_divisible(arr, x):\n            return len(arr)\n        else:\n            return longest_subarray(arr, x)\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        test_case = stdin.readline().strip()\n        result.append(str(process_test_case(test_case)))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2590,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        n, x = map(int, stdin.readline().split())\n        savings = list(map(int, stdin.readline().split()))\n\n        wealthy_count = 0\n        for amount in savings:\n            if amount >= x:\n                wealthy_count += 1\n\n        result.append(wealthy_count)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2591,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i+1].split()))\n\n        for j in range(n-1):\n            for k in range(j+1, n):\n                if abs(a[j] - a[k]) > abs(a[j+1] - a[k+1]):\n                    a[j], a[k] = a[k], a[j]\n\n        result.append(\" \".join(map(str, a)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2592,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, c = map(int, stdin.readline().split())\n        max_visitors = max(a, b, c)\n        print(max_visitors)"
    },
    {
        "number": 2593,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_and(a, b):\n        return a & b\n\n    def bitwise_xor(a, b):\n        return a ^ b\n\n    def is_good_pair(a, b):\n        return bitwise_and(a, b) >= bitwise_xor(a, b)\n\n    def count_good_pairs(n, a):\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_good_pair(a[i], a[j]):\n                    count += 1\n        return count\n\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for i in range(1, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i + 1].split()))\n        result.append(str(count_good_pairs(n, a)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2594,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_lighted_squares(n, m):\n        return (n + 1) * (m + 1)\n\n    def count_lanterns(n, m):\n        return (n + 1) + (m + 1)\n\n    def min_lanterns(n, m):\n        return min(count_lighted_squares(n, m), count_lanterns(n, m))\n\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        result.append(min_lanterns(n, m))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2595,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n\n        if a == b:\n            result.append(0)\n        elif b % 2 == 0 and a % 2 == 0:\n            result.append(1)\n        elif b % 4 == 0 and a % 4 == 0:\n            result.append(1)\n        elif b % 8 == 0 and a % 8 == 0:\n            result.append(1)\n        else:\n            result.append(-1)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2596,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, t = map(int, stdin.split()[:4])\n    decisions = stdin.split()[4:]\n    multiverse = [1] * n\n    doctor_position = k\n    output = []\n\n    for decision in decisions:\n        decision_type, i = map(int, decision.split())\n\n        if decision_type == 1:\n            if i == 1:\n                multiverse.insert(0, 1)\n                doctor_position += 1\n            elif i == n + 1:\n                multiverse.append(1)\n            else:\n                multiverse.insert(i - 1, 1)\n        else:\n            if i == 1:\n                multiverse.pop(0)\n                doctor_position -= 1\n            else:\n                multiverse.pop(i - 1)\n\n        output.append(f\"{len(multiverse)} {doctor_position}\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 2597,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(k):\n        n = int(stdin.readline().strip())\n        planks = list(map(int, stdin.readline().strip().split()))\n        max_side = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if planks[i] == planks[j]:\n                    max_side = max(max_side, planks[i])\n\n        result.append(str(max_side))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2598,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = []\n    for i in range(m):\n        u, v, c = stdin.split()[3*i:3*(i+1)]\n        edges.append((int(u)-1, int(v)-1, c))\n    \n    def dfs(u, color):\n        visited[u] = True\n        for v, c in graph[u]:\n            if not visited[v]:\n                if c == color:\n                    dfs(v, 'R' if color == 'B' else 'B')\n                else:\n                    dfs(v, color)\n    \n    graph = [[] for _ in range(n)]\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    \n    visited = [False] * n\n    colors = ['R', 'B']\n    min_moves = float('inf')\n    for color in colors:\n        dfs(0, color)\n        if all(visited):\n            moves = 0\n            for i in range(n):\n                if visited[i]:\n                    moves += 1\n            min_moves = min(min_moves, moves)\n    \n    if min_moves == float('inf'):\n        return '-1\\n'\n    else:\n        result = []\n        for i in range(n):\n            if not visited[i]:\n                result.append(i+1)\n        return str(min_moves) + '\\n' + ' '.join(map(str, result)) + '\\n'"
    },
    {
        "number": 2599,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sum_of_digits(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    def find_x(n: int, k: int) -> int:\n        for x in range(10 ** k):\n            if sum_of_digits(x) + sum_of_digits(x + 1) + sum_of_digits(x + 2) == n:\n                return x\n        return -1\n\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        n, k = map(int, stdin.readline().split())\n        result = find_x(n, k)\n        print(result)"
    },
    {
        "number": 2600,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(matrix: List[List[int]]) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(m // 2):\n                if matrix[i][j] != matrix[i][m - j - 1]:\n                    return False\n        return True\n\n    def change_matrix(matrix: List[List[int]]) -> int:\n        n, m = len(matrix), len(matrix[0])\n        count = 0\n        for i in range(n):\n            for j in range(m // 2):\n                if matrix[i][j] != matrix[i][m - j - 1]:\n                    matrix[i][j], matrix[i][m - j - 1] = matrix[i][m - j - 1], matrix[i][j]\n                    count += 1\n        return count\n\n    def main() -> None:\n        t = int(stdin.readline())\n        for _ in range(t):\n            n, m = map(int, stdin.readline().split())\n            matrix = [list(map(int, stdin.readline().split())) for _ in range(n)]\n            if is_palindrome(matrix):\n                print(0)\n            else:\n                print(change_matrix(matrix))\n\n    main()"
    },
    {
        "number": 2601,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        if not test_case:\n            continue\n\n        n = int(test_case.split()[0])\n        volumes = list(map(int, test_case.split()[1:]))\n\n        if sorted(volumes) == volumes:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2602,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    for i in range(1, len(cases), 2):\n        a, b, n, m = map(int, cases[i].split())\n        if n + m == 0:\n            return \"No\"\n        if a + b == 0:\n            return \"No\"\n        if n == 0:\n            if a > b:\n                return \"Yes\"\n            else:\n                return \"No\"\n        if m == 0:\n            if a < b:\n                return \"Yes\"\n            else:\n                return \"No\"\n        if a > b:\n            if n > m:\n                return \"Yes\"\n            else:\n                return \"No\"\n        else:\n            if n < m:\n                return \"Yes\"\n            else:\n                return \"No\"\n    return \"No\"\n\n\ndef"
    },
    {
        "number": 2603,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def is_non_decreasing(a):\n        for i in range(1, len(a)):\n            if a[i] <= a[i - 1]:\n                return False\n        return True\n\n    def can_make_non_decreasing(a):\n        min_element = min(a)\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if gcd(a[i], a[j]) == min_element:\n                    return True\n        return False\n\n    test_cases = int(stdin.readline())\n    result = []\n\n    for _ in range(test_cases):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n\n        if is_non_decreasing(a):\n            result.append(\"YES\")\n        elif can_make_non_decreasing(a):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2604,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, d = map(int, stdin.split()[0].split())\n    n = int(stdin.split()[1])\n    sausage_list = []\n    for i in range(n):\n        x, y, r = map(int, stdin.split()[2:])\n        sausage_list.append((x, y, r))\n\n    def is_on_crust(x, y, r):\n        return r <= d\n\n    def is_inside_pizza(x, y, r):\n        return r <= r - d\n\n    count = 0\n    for x, y, r in sausage_list:\n        if is_on_crust(x, y, r) and is_inside_pizza(x, y, r):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2605,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    c = list(map(int, stdin.split()[2:2+n]))\n    id_k = list(map(int, stdin.split()[2+n:]))\n\n    total_price = 0\n    for i in range(n):\n        for j in range(i+1, n+i):\n            if j == n:\n                j = 0\n            total_price += c[i] * c[j]\n\n    return str(total_price)"
    },
    {
        "number": 2606,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_unpleasant_value(t: List[int]) -> int:\n        t.sort()\n        n = len(t)\n        total = 0\n        for i in range(n):\n            total += abs(t[i] - (i + 1))\n        return total\n\n    def main() -> None:\n        q = int(input())\n        for _ in range(q):\n            n = int(input())\n            t = list(map(int, input().split()))\n            print(min_unpleasant_value(t))\n\n    main()"
    },
    {
        "number": 2607,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    for case in cases:\n        if case == \"\":\n            continue\n        s = list(case)\n        for i in range(len(s)):\n            if s[i] == \"?\":\n                for j in range(3):\n                    if i == 0 or s[i-1] != chr(97+j):\n                        if i == len(s)-1 or s[i+1] != chr(97+j):\n                            s[i] = chr(97+j)\n                            break\n        if all(s[i] != s[i+1] for i in range(len(s)-1)):\n            print(\"\".join(s))\n        else:\n            print(-1)"
    },
    {
        "number": 2608,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint_cells(board, x1, y1, x2, y2, color):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                board[j][i] = color\n\n    def count_cells(board, color):\n        count = 0\n        for row in board:\n            count += row.count(color)\n        return count\n\n    def read_test_case(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        n, m = map(int, lines[0].split())\n        x1, y1, x2, y2 = map(int, lines[1].split())\n        x3, y3, x4, y4 = map(int, lines[2].split())\n        return n, m, x1, y1, x2, y2, x3, y3, x4, y4\n\n    def process_test_case(n: int, m: int, x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> str:\n        board = [['.' for _ in range(m)] for _ in range(n)]\n        paint_cells(board, x1, y1, x2, y2, 'W')\n        paint_cells(board, x3, y3, x4, y4, 'B')\n        white_count = count_cells(board, 'W')\n        black_count = count_cells(board, 'B')\n        return f\"{white_count} {black_count}\"\n\n    test_cases = stdin.split(\"\\n\\n\")\n    result = []\n    for test_case in test_cases:\n        if test_case:\n            n, m, x1, y1, x2, y2, x3, y3, x4, y4 = read_test_case(test_case)\n            result.append(process_test_case(n, m, x1, y1, x2, y2, x3, y3, x4, y4))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2609,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_union(segments: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        segments.sort(key=lambda x: x[0])\n        result = []\n        for segment in segments:\n            if not result or segment[0] > result[-1][1]:\n                result.append(segment)\n            else:\n                result[-1] = (result[-1][0], max(result[-1][1], segment[1]))\n        return result\n\n    def max_union(segments: List[Tuple[int, int]]) -> int:\n        return len(find_union(segments))\n\n    def erase_segment(segments: List[Tuple[int, int]], index: int) -> List[Tuple[int, int]]:\n        return segments[:index] + segments[index + 1:]\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().split())\n            segments.append((l, r))\n        max_union_without_any_segment = max_union(segments)\n        for i in range(n):\n            max_union_without_i_th_segment = max_union(erase_segment(segments, i))\n            if max_union_without_i_th_segment > max_union_without_any_segment:\n                max_union_without_any_segment = max_union_without_i_th_segment\n        result.append(max_union_without_any_segment)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2610,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def buy_goods(n: int, p: int, k: int, a: List[int]) -> int:\n        a.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if p >= a[i]:\n                p -= a[i]\n                count += 1\n                if count == k:\n                    break\n        return count\n\n    def max_goods(n: int, p: int, k: int, a: List[int]) -> int:\n        a.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if p >= a[i]:\n                count += 1\n                p -= a[i]\n                if count == k:\n                    break\n        return count\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, p, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        result.append(max_goods(n, p, k, a))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2611,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    piles = list(map(int, stdin.split()[2:2+n]))\n    queries = []\n    for i in range(q):\n        query = list(map(int, stdin.split()[2+n+i*2:2+n+i*2+2]))\n        queries.append(query)\n\n    def cleanup(piles):\n        moves = 0\n        x_coords = set()\n        for pile in piles:\n            if pile not in x_coords:\n                x_coords.add(pile)\n            else:\n                moves += 1\n        return moves\n\n    min_moves = cleanup(piles)\n    result = [min_moves]\n\n    for query in queries:\n        if query[0] == 0:\n            piles.remove(query[1])\n        else:\n            piles.append(query[1])\n        min_moves = cleanup(piles)\n        result.append(min_moves)\n\n    return \" \".join(map(str, result))\n\ninput_str = \"5 6\\n1 2 6 8 10\\n1 4\\n1 9\\n0 6\\n0 10\\n1 100\\n1 50\"\nprint(solution(input_str)) "
    },
    {
        "number": 2612,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n = int(stdin.readline())\n        sizes = list(map(int, stdin.readline().split()))\n        max_models = 0\n\n        for i in range(1, n):\n            if sizes[i] > sizes[i - 1] and i % (i - 1) == 0:\n                max_models += 1\n\n        result.append(str(max_models))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2613,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_score(n, k, z, a):\n        if k == 0:\n            return sum(a)\n        if k == 1:\n            return max(a)\n        if z == 0:\n            return max(a[i] + max_score(n, k - 1, z, a[i + 1:]) for i in range(n - 1))\n        else:\n            return max(max(a[i] + max_score(n, k - 1, z - 1, a[i + 1:]) for i in range(n - 1)) if i > 0 else 0,\n                   a[0] + max_score(n, k - 1, z, a[1:]))\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, k, z = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        result.append(max_score(n, k, z, a))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2614,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_distance(fillings: List[int]) -> int:\n        n = len(fillings)\n        min_dist = n\n        current_filling = fillings[0]\n        current_distance = 0\n\n        for i in range(1, n):\n            if fillings[i] == current_filling:\n                current_distance += 1\n            else:\n                min_dist = min(min_dist, current_distance)\n                current_filling = fillings[i]\n                current_distance = 1\n\n        return min_dist\n\n    def main() -> None:\n        T = int(input())\n        for _ in range(T):\n            n = int(input())\n            fillings = list(map(int, input().split()))\n            print(min_distance(fillings))\n\n    main()"
    },
    {
        "number": 2615,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_elegant(n):\n        prime_factors = []\n        while n % 2 == 0:\n            prime_factors.append(2)\n            n //= 2\n\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                prime_factors.append(i)\n                n //= i\n\n        if n > 2:\n            prime_factors.append(n)\n\n        return gcd(*prime_factors) == 1\n\n    def count_elegant(n):\n        return sum(1 for i in range(2, n + 1) if is_elegant(i))\n\n    lines = stdin.splitlines()\n    T = int(lines[0])\n    results = []\n\n    for i in range(1, T + 1):\n        n = int(lines[i])\n        results.append(count_elegant(n))\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2616,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_first_player_winner(n: int, a: List[int]) -> bool:\n        if n == 1:\n            return True\n        if n == 2:\n            return a[0] > a[1]\n        if n == 3:\n            return a[0] + a[1] > a[2]\n        if n == 4:\n            return a[0] + a[1] + a[2] > a[3]\n        if n == 5:\n            return a[0] + a[1] + a[2] + a[3] > a[4]\n        return a[0] + a[1] + a[2] + a[3] + a[4] > a[5]\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if is_first_player_winner(n, a):\n            print(\"First\")\n        else:\n            print(\"Second\")"
    },
    {
        "number": 2617,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def split_bacteria(bacteria, day):\n        new_bacteria = []\n        for bacterium in bacteria:\n            if bacterium > 1:\n                new_bacteria.append(bacterium / 2)\n                new_bacteria.append(bacterium / 2)\n            else:\n                new_bacteria.append(bacterium)\n        return new_bacteria\n\n    def night_growth(bacteria):\n        return [bacterium + 1 for bacterium in bacteria]\n\n    def total_mass(bacteria):\n        return sum(bacteria)\n\n    def find_solution(n, bacteria):\n        if total_mass(bacteria) == n:\n            return [0] * len(bacteria)\n        if total_mass(bacteria) > n:\n            return None\n\n        for day in range(1, len(bacteria) + 1):\n            new_bacteria = split_bacteria(bacteria, day)\n            new_bacteria = night_growth(new_bacteria)\n            solution = find_solution(n, new_bacteria)\n            if solution is not None:\n                solution[day - 1] = len(bacteria) - len(new_bacteria)\n                return solution\n\n    test_cases = stdin.split(\"\\n\")\n    t = int(test_cases[0])\n    results = []\n\n    for i in range(1, t + 1):\n        n = int(test_cases[i])\n        bacteria = [1]\n        solution = find_solution(n, bacteria)\n        if solution is None:\n            results.append(\"-1\")\n        else:\n            results.append(str(len(solution)))\n            results.append(\" \".join(map(str, solution)))\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 2618,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_total_contribution(tickets, x, a, y, b, k):\n        total_contribution = 0\n        for i, ticket in enumerate(tickets):\n            if i % a == 0:\n                total_contribution += ticket * x / 100\n            if i % b == 0:\n                total_contribution += ticket * y / 100\n        return total_contribution\n\n    def get_min_sold_tickets(tickets, x, a, y, b, k):\n        min_sold_tickets = len(tickets)\n        for i in range(1, len(tickets) + 1):\n            total_contribution = get_total_contribution(tickets[:i], x, a, y, b, k)\n            if total_contribution >= k:\n                min_sold_tickets = min(min_sold_tickets, i)\n        return min_sold_tickets if min_sold_tickets != len(tickets) else -1\n\n    q = int(stdin.readline())\n    result = []\n    for _ in range(q):\n        n = int(stdin.readline())\n        prices = list(map(int, stdin.readline().split()))\n        x, a = map(int, stdin.readline().split())\n        y, b = map(int, stdin.readline().split())\n        k = int(stdin.readline())\n\n        result.append(get_min_sold_tickets(prices, x, a, y, b, k))\n\n    return \"\\n\".join(map(str, result))\n\ninput_data = \"\"\"4\n1\n100\n50 1\n49 1\n100\n8\n100 200 100 200 100 200 100 100\n10 2\n15 3\n107\n3\n1000000000 1000000000 1000000000\n50 1\n50 1\n3000000000\n5\n200 100 100 100 100\n69 5\n31 2\n90\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 2619,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, c = map(int, stdin.readline().split())\n    stars = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.readline().split())\n        stars.append((x, y, s))\n\n    def total_brightness(x1, y1, x2, y2):\n        total = 0\n        for x, y, s in stars:\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                total += s\n        return total\n\n    for _ in range(q):\n        t, x1, y1, x2, y2 = map(int, stdin.readline().split())\n        brightness = total_brightness(x1, y1, x2, y2)\n        print(brightness)"
    },
    {
        "number": 2620,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    next_permutation = True\n    result = []\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n\n        if query[0] == 1:\n            result.append(sum(a[query[1] - 1:query[2]]))\n        elif query[0] == 2:\n            if next_permutation:\n                i = n - 2\n                while a[i] >= a[i + 1]:\n                    i -= 1\n\n                if i == -1:\n                    next_permutation = False\n                else:\n                    j = n - 1\n                    while a[j] <= a[i]:\n                        j -= 1\n\n                    a[i], a[j] = a[j], a[i]\n                    a[i + 1:] = reversed(a[i + 1:])\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2621,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        n, m, k = map(int, test_case.split())\n        h = list(map(int, testin.split()))\n\n        if n == 1:\n            result.append(\"YES\")\n        elif n == 2:\n            if h[0] == 0:\n                result.append(\"YES\")\n            else:\n                result.append(\"NO\")\n        else:\n            for i in range(n - 1):\n                if abs(h[i] - h[i + 1]) > k:\n                    result.append(\"NO\")\n                    break\n            else:\n                result.append(\"YES\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2622,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split())\n    map1 = [stdin.split()[i] for i in range(1, N+1)]\n    map2 = [stdin.split()[i] for i in range(N+1, N+M+1)]\n\n    for i in range(N-M+1):\n        for j in range(M-M+1):\n            if map1[i:i+M] == map2[j::M]:\n                return f\"{i+1} {j+1}\""
    },
    {
        "number": 2623,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n\n        # Sort the string and split it into k non-empty strings\n        s_sorted = sorted(s)\n        substrings = [[] for _ in range(k)]\n        for i, c in enumerate(s_sorted):\n            substrings[i % k].append(c)\n\n        # Find the lexicographically maximum string among the k substrings\n        max_substring = max(substrings, key=lambda x: ''.join(x))\n\n        result.append(''.join(max_substring))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2624,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    b = [-x for x in a]\n\n    for i in range(q):\n        s, x = stdin.split()[2 + i * 2:4 + i * 2]\n        x = int(x)\n        if s == '>':\n            b = [x if x > y else y for x, y in zip(b, a)]\n        else:\n            b = [x if x < y else y for x, y in zip(b, a)]\n\n    return ' '.join(map(str, b))\n"
    },
    {
        "number": 2625,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tasks = []\n    for i in range(1, n + 1):\n        k, x = map(int, stdin.splitlines()[i].split())\n        tasks.append((k, x))\n\n    results = []\n    for k, x in tasks:\n        count = 0\n        num = 1\n        while True:\n            digit_sum = sum(int(digit) for digit in str(num))\n            if digit_sum == x:\n                count += 1\n                if count == k:\n                    results.append(num)\n                    break\n            num += 1\n\n    return \"\\n\".join(str(result) for result in results)"
    },
    {
        "number": 2626,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        result = 0\n        for i in range(1, n + 1):\n            result += i * (i + 1) // 2\n        print(result)"
    },
    {
        "number": 2627,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(row) for row in stdin.split(\"\\n\")]\n    max_area = 0\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == \"1\":\n                area = 1\n                for k in range(i, len(matrix)):\n                    if \"1\" not in matrix[k]:\n                        break\n                    area += 1\n                max_area = max(max_area, area)\n\n    return max_area"
    },
    {
        "number": 2628,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    gray_code = [\"0\", \"1\"]\n    for i in range(2, n+1):\n        temp = gray_code.copy()\n        for code in temp:\n            gray_code.append(\"1\" + code)\n            gray_code.append(\"0\" + code)\n            gray_code.remove(code)\n    return gray_code"
    },
    {
        "number": 2629,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = [[0 for x in range(n)] for y in range(n)]\n    row, col = 0, 0\n    direction = 0\n    for i in range(1, n*n+1):\n        matrix[row][col] = i\n        if direction == 0:\n            if col < n-1 and matrix[row][col+1] == 0:\n                col += 1\n            else:\n                row += 1\n                direction = 1\n        elif direction == 1:\n            if row < n-1 and matrix[row+1][col] == 0:\n                row += 1\n            else:\n                col -= 1\n                direction = 2\n        elif direction == 2:\n            if col > 0 and matrix[row][col-1] == 0:\n                col -= 1\n            else:\n                row -= 1\n                direction = 3\n        elif direction == 3:\n            if row > 0 and matrix[row-1][col] == 0:\n                row -= 1\n            else:\n                col += 1\n                direction = 0\n    return matrix"
    },
    {
        "number": 2630,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(map(int, row.split(','))) for row in stdin.split('\\n')]\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[m-1][n-1] = 1\n\n    for i in range(m-2, -1, -1):\n        for j in range(n-1, -1, -1):\n            if grid[i][j] == 0:\n                if j < n-1 and grid[i][j+1] == 0:\n                    dp[i][j] += dp[i][j+1]\n                if i < m-1 and grid[i+1][j] == 0:\n                    dp[i][j] += dp[i+1][j]\n\n    return dp[0][0]"
    },
    {
        "number": 2631,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, prerequisites = stdin.split(\",\")\n    n = int(n)\n    prerequisites = eval(prerequisites)\n\n    def dfs(course, visited, path):\n        if course in visited:\n            return False\n        visited.add(course)\n        path.append(course)\n\n        for prereq in prerequisites:\n            if prereq[1] == course:\n                if not dfs(prereq[0], visited, path):\n                    return False\n        path.pop()\n        return True\n\n    for i in range(n):\n        visited = set()\n        path = []\n        if not dfs(i, visited, path):\n            return \"false\"\n\n    return \"true\""
    },
    {
        "number": 2632,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(map(int, row.split(','))) for row in stdin.split('\\n')]\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[-1][-1]"
    },
    {
        "number": 2633,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_matrix(stdin: str) -> list:\n        matrix = []\n        for row in stdin.split('\\n'):\n            matrix.append([int(x) for x in row.split()])\n        return matrix\n\n    def get_prisoner_position(matrix: list) -> tuple:\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == -5:\n                    return i, j\n\n    def get_min_health(matrix: list, start: tuple, end: tuple) -> int:\n        m, n = len(matrix), len(matrix[0])\n        queue = [(0, start[0], start[1])]\n        visited = set()\n\n        while queue:\n            health, i, j = queue.pop(0)\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n\n            if i == end[0] and j == end[1]:\n                return health\n\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n:\n                    new_health = health + matrix[ni][nj]\n                    if new_health > 0:\n                        queue.append((new_health, ni, nj))\n\n    matrix = get_matrix(stdin)\n    prisoner_position = get_prisoner_position(matrix)\n    min_health = get_min_health(matrix, (0, 0), prisoner_position)\n    return str(min_health)"
    },
    {
        "number": 2634,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split(',')))\n    result = []\n    for i in range(len(nums) + 1):\n        for subset in itertools.combinations(nums, i):\n            result.append(list(subset))\n    return result"
    },
    {
        "number": 2635,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, row.split())) for row in stdin.splitlines()]\n    m, n = len(matrix), len(matrix[0])\n    result = []\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result"
    },
    {
        "number": 2636,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    buildings = eval(stdin)\n    skyline = []\n    i = 0\n    n = len(buildings)\n    while i < n:\n        left = buildings[i][0]\n        height = buildings[i][2]\n        j = i + 1\n        while j < n and buildings[j][0] == left:\n            j += 1\n        right = buildings[j - 1][1]\n        skyline.append([left, height])\n        skyline.append([right, 0])\n        i = j\n\n    # Remove consecutive horizontal lines of equal height\n    result = []\n    for i in range(len(skyline) - 1):\n        if skyline[i][1] != skyline[i + 1][1]:\n            result.append(skyline[i])\n    result.append(skyline[-1])\n\n    return str(result)"
    },
    {
        "number": 2637,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split(',')))\n    result = []\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    backtrack(0)\n    return result"
    },
    {
        "number": 2638,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    triangle = eval(stdin)\n    n = len(triangle)\n    dp = [0] * n\n    dp[0] = triangle[0][0]\n\n    for i in range(1, n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[j] = dp[j] + triangle[i][j]\n            elif j == i:\n                dp[j] = dp[j - 1] + triangle[i][j]\n            else:\n                dp[j] = min(dp[j - 1], dp[j]) + triangle[i][j]\n\n    return min(dp)"
    },
    {
        "number": 2639,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split(',')))\n    nums.sort()\n    result = []\n    for i in range(2**len(nums)):\n        subset = []\n        for j in range(len(nums)):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if subset not in result:\n            result.append(subset)\n    return result"
    },
    {
        "number": 2640,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n    max_lighted = 0\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                lighted = 0\n                lighted += light_up(grid, i, j)\n                lighted += light_down(grid, i, j)\n                lighted += light_left(grid, i, j)\n                lighted += light_right(grid, i, j)\n                max_lighted = max(max_lighted, lighted)\n\n    return str(max_lighted)\n\ndef"
    },
    {
        "number": 2641,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    colors = list(map(int, lines[1].split()))\n    queries = [list(map(int, lines[i].split())) for i in range(2, 2 + Q)]\n\n    def count_colors(l: int, r: int) -> int:\n        return len(set(colors[l - 1:r]))\n\n    return '\\n'.join(str(count_colors(l, r)) for l, r in queries)"
    },
    {
        "number": 2642,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    sardines = []\n    for i in range(1, N+1):\n        A, B = map(int, lines[i].split())\n        sardines.append((A, B))\n\n    def is_on_bad_terms(i: int, j: int) -> bool:\n        A_i, B_i = sardines[i-1]\n        A_j, B_j = sardines[j-1]\n        return A_i * A_j + B_i * B_j == 0\n\n    def count_ways(i: int, used: set) -> int:\n        if i == N:\n            return 1\n        count = 0\n        for j in range(1, N+1):\n            if j not in used and not is_on_bad_terms(i, j):\n                count += count_ways(i+1, used | {j})\n        return count\n\n    result = count_ways(1, set())\n    return str(result % 1000000007)"
    },
    {
        "number": 2643,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(int, stdin.split()[0:2])\n    d = list(map(int, stdin.split()[2:2+k]))\n    queries = []\n    for i in range(q):\n        n, x, m = map(int, stdin.split()[2+k+i*3:2+k+i*3+3])\n        queries.append((n, x, m))\n\n    def a(n_i, x_i, m_i):\n        a_j = [x_i]\n        for j in range(1, n_i):\n            a_j.append((a_j[-1] + d[(j - 1) % k]) % m_i)\n        return a_j\n\n    results = []\n    for n_i, x_i, m_i in queries:\n        count = 0\n        for j in range(n_i - 1):\n            if a_j % m_i < a_j1 % m_i:\n                count += 1\n        results.append(count)\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2644,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = stdin.split()\n    N = int(N)\n    P = list(map(int, P.split()))\n\n    if len(P) != N:\n        return -1\n\n    for i in range(N):\n        if i + 1 not in P:\n            return -1\n\n    for i in range(N - 1):\n        if P[i] > P[i + 1]:\n            return str(i + 1) + \"\\n\" + str(i + 2)\n\n    return str(N - 1) + \"\\n\" + str(N)"
    },
    {
        "number": 2645,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    rock_count = 0\n    paper_count = 0\n    score = 0\n\n    for i in range(n):\n        if s[i] == 'g':\n            if paper_count <= rock_count:\n                rock_count += 1\n            else:\n                paper_count += 1\n                score += 1\n        else:\n            if paper_count <= rock_count:\n                paper_count += 1\n            else:\n                rock_count += 1\n                score -= 1\n\n    return score"
    },
    {
        "number": 2646,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    adj_list = [[] for _ in range(N + 1)]\n    for i in range(1, M + 1):\n        A, B = map(int, lines[i].split())\n        adj_list[A].append(B)\n        adj_list[B].append(A)\n\n    def dfs(start: int, visited: set, path: list) -> bool:\n        if start == 1:\n            return True\n        visited.add(start)\n        for neighbor in adj_list[start]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                if dfs(neighbor, visited, path):\n                    return True\n                path.pop()\n        visited.remove(start)\n        return False\n\n    for i in range(2, N + 1):\n        visited = set()\n        path = [i]\n        if dfs(i, visited, path):\n            return \"No\"\n\n    signposts = [1] * N\n    for i in range(2, N + 1):\n        for neighbor in adj_list[i]:\n            if neighbor != 1:\n                signposts[i - 1] = neighbor\n                break\n\n    return \"Yes\\n\" + \"\\n\".join(map(str, signposts))"
    },
    {
        "number": 2647,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, grid = stdin.split(\"\\n\")\n    H, W = int(H), int(W)\n    grid = grid.split()\n    score = 0\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"#\":\n                if i == 0 or j == 0 or i == H - 1 or j == W - 1:\n                    return -1\n            else:\n                score += 1\n\n    return str(score)"
    },
    {
        "number": 2648,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, cards = stdin.split()\n    N = int(N)\n    cards = list(map(int, cards.split()))\n\n    while len(cards) > 3:\n        cards.remove(max(cards[:3]))\n        cards.remove(min(cards[:3]))\n\n    return str(len(cards))"
    },
    {
        "number": 2649,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    max_distance = 0\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 2650,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    infants = {}\n    kindergartens = {}\n\n    for i in range(1, N + 1):\n        A_i, B_i = map(int, lines[i].split())\n        infants[i] = A_i\n        if B_i not in kindergartens:\n            kindergartens[B_i] = []\n        kindergartens[B_i].append(i)\n\n    for j in range(N + 1, N + Q + 1):\n        C_j, D_j = map(int, lines[j].split())\n        infants[C_j] = D_j\n        kindergartens[D_j].append(C_j)\n        kindergartens[B_j].remove(C_j)\n\n    evenness = []\n    for i in range(1, N + 1):\n        if i in infants:\n            evenness.append(infants[i])\n        else:\n            evenness.append(float('inf'))\n\n    for j in range(N + 1, N + Q + 1):\n        evenness_after_transfer = []\n        for k in range(1, 2 * 10**5 + 1):\n            if k in kindergartens:\n                evenness_after_transfer.append(max(infants[i] for i in kindergartens[k]))\n            else:\n                evenness_after_transfer.append(float('inf'))\n        evenness.append(min(evenness_after_transfer))\n\n    return '\\n'.join(map(str, evenness))"
    },
    {
        "number": 2651,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:2+n]))\n    y = list(map(int, stdin.split()[2+n:]))\n    MOD = 10**9 + 7\n    total_area = 0\n\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(1, m):\n                for l in range(k+1, m+1):\n                    area = (x[j] - x[i]) * (y[l] - y[k])\n                    total_area = (total_area + area) % MOD\n\n    return str(total_area)"
    },
    {
        "number": 2652,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.split('\\n')[0])\n    towns = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    # Calculate minimum cost\n    min_cost = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            min_cost += min(abs(towns[i][0] - towns[j][0]), abs(towns[i][1] - towns[j][1]))\n\n    # Return result\n    return str(min_cost)"
    },
    {
        "number": 2653,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    operations = [list(map(int, line.split())) for line in stdin.split('\\n')[N+1:N+Q+1]]\n\n    def dfs(node: int, parent: int) -> None:\n        for child in edges[node-1]:\n            if child != parent:\n                dfs(child, node)\n                counters[node-1] += counters[child-1]\n\n    counters = [0] * N\n    dfs(1, -1)\n\n    for operation in operations:\n        counters[operation[0]-1] += operation[1]\n\n    return ' '.join(map(str, counters))"
    },
    {
        "number": 2654,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    X = []\n    for i in range(N):\n        A, B = map(int, stdin.split('\\n')[i+1].split())\n        X.append(A)\n        X.append(B+1)\n    X.sort()\n    median = X[N//2] if N % 2 == 1 else (X[N//2-1] + X[N//2]) / 2\n    return str(median)"
    },
    {
        "number": 2655,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *friendliness = map(int, stdin.split())\n    if N < 2 or N > 2 * 10**5:\n        raise ValueError(\"Invalid number of players\")\n    if len(friendliness) != N:\n        raise ValueError(\"Invalid number of friendliness values\")\n    if any(x < 1 or x > 10**9 for x in friendliness):\n        raise ValueError(\"Invalid friendliness value\")\n\n    def max_comfort(friendliness: List[int]) -> int:\n        if len(friendliness) == 1:\n            return 0\n        if len(friendliness) == 2:\n            return max(friendliness)\n        return max(max_comfort(friendliness[:i] + friendliness[i+1:]) + min(friendliness[i-1], friendliness[i]) for i in range(1, len(friendliness)-1))\n\n    return str(max_comfort(friendliness))"
    },
    {
        "number": 2656,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, S = stdin.split()\n    K = int(K)\n    MOD = 10**9 + 7\n\n    def count_strings(k: int, s: str) -> int:\n        if k == 0:\n            return 1\n        count = 0\n        for i in range(len(s)):\n            if s[i].islower():\n                new_s = s[:i] + s[i].upper() + s[i+1:]\n                count += count_strings(k - 1, new_s)\n                new_s = s[:i] + s[i].lower() + s[i+1:]\n                count += count_strings(k - 1, new_s)\n        return count % MOD\n\n    return str(count_strings(K, S))"
    },
    {
        "number": 2657,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort(reverse=True)\n    max_comb = 0\n    max_pair = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            comb = comb(a[i], a[j])\n            if comb > max_comb:\n                max_comb = comb\n                max_pair = (a[i], a[j])\n\n    return \" \".join(map(str, max_pair))\n\ndef"
    },
    {
        "number": 2658,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    # Create a dictionary to store the teleporter destinations\n    teleporter_dict = {}\n    for i in range(N):\n        teleporter_dict[i+1] = A[i]\n\n    # Initialize the starting point and the number of teleporter uses\n    current_town = 1\n    teleporter_uses = 0\n\n    # Loop until we have used the required number of teleporters\n    while teleporter_uses < K:\n        # Check if the current town has a teleporter\n        if current_town in teleporter_dict:\n            # Use the teleporter and update the current town\n            current_town = teleporter_dict[current_town]\n            teleporter_uses += 1\n        else:\n            # If the current town does not have a teleporter, we cannot use it\n            return \"King cannot reach the required number of teleporters\"\n\n    # Return the final town the king will be in\n    return str(current_town)"
    },
    {
        "number": 2659,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    snuke_numbers = []\n    n = 1\n    while len(snuke_numbers) < K:\n        if is_snuke(n):\n            snuke_numbers.append(n)\n        n += 1\n    return \"\\n\".join(map(str, snuke_numbers))\n\ndef"
    },
    {
        "number": 2660,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')[1:]\n    f = 0\n    for query in queries:\n        query_type, *args = query.split()\n        if query_type == '1':\n            a, b = map(int, args)\n            f = lambda x: f(x) + abs(x - a) + b\n        elif query_type == '2':\n            min_x = min(range(10**9+1), key=lambda x: f(x))\n            min_f = f(min_x)\n            print(min_x, min_f)\n    return \"\" "
    },
    {
        "number": 2661,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    S = [int(x) for x in lines[1].split()]\n    T = [int(x) for x in lines[2].split()]\n    U = [int(x) for x in lines[3].split()]\n    V = [int(x) for x in lines[4].split()]\n\n    def bitwise_and(arr: List[int]) -> int:\n        result = 0\n        for x in arr:\n            result &= x\n        return result\n\n    def bitwise_or(arr: List[int]) -> int:\n        result = 0\n        for x in arr:\n            result |= x\n        return result\n\n    def is_valid(a: List[List[int]]) -> bool:\n        for i in range(N):\n            if S[i] == 0 and bitwise_and(a[i]) != U[i]:\n                return False\n            if S[i] == 1 and bitwise_or(a[i]) != U[i]:\n                return False\n            if T[i] == 0 and bitwise_and(a[:,i]) != V[i]:\n                return False\n            if T[i] == 1 and bitwise_or(a[:,i]) != V[i]:\n                return False\n        return True\n\n    def generate_matrix(S: List[int], T: List[int], U: List[int], V: List[int]) -> List[List[int]]:\n        a = [[0] * N for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if S[i] == 0:\n                    a[i][j] = U[i] & V[j]\n                else:\n                    a[i][j] = U[i] | V[j]\n        return a\n\n    a = generate_matrix(S, T, U, V)\n    if is_valid(a):\n        for row in a:\n            print(' '.join(map(str, row)))\n    else:\n        print(-1)"
    },
    {
        "number": 2662,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1:]))\n\n    a.sort()\n    colors = {}\n    for i in range(n):\n        if a[i] not in colors:\n            colors[a[i]] = len(colors) + 1\n\n    return str(len(colors))"
    },
    {
        "number": 2663,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    L = []\n    for i in range(N):\n        for j in range(i, N):\n            L.append(sum(A[i:j+1]))\n    L.sort(reverse=True)\n    return \" \".join(map(str, L[:K]))"
    },
    {
        "number": 2664,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    scale_count = 0\n    scale_data = []\n    for line in stdin.splitlines():\n        if line == \"1\":\n            scale_count += 1\n            scale_data.append([])\n        else:\n            scale_data[-1].append(line)\n\n    for scale in scale_data:\n        pan1 = scale[0].split()\n        pan2 = scale[1].split()\n        pan1_colours = [int(x) for x in pan1[1:]]\n        pan2_colours = [int(x) for x in pan2[1:]]\n        pan1_weight = sum(pan1_colours.count(x) for x in set(pan1_colours))\n        pan2_weight = sum(pan2_colours.count(x) for x in set(pan2_colours))\n        diff = int(pan1[0]) - int(pan2[0])\n\n        if diff == 0:\n            continue\n        elif diff > 0:\n            heavier_colour = pan1_colours[0]\n        else:\n            heavier_colour = pan2_colours[0]\n\n        print(\"2\")\n        print(heavier_colour)\n        return"
    },
    {
        "number": 2665,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_square(x1, y1, x2, y2, x3, y3):\n        a = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n        b = (x2 - x1) * y1 + (x3 - x2) * y2 + (x1 - x3) * y3\n        c = x1 * (x2 - x3) + y1 * (y2 - y3)\n        return a == b and b == c\n\n    def add_points(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_square(*points[i], *points[j], *points[k]):\n                        return count\n                count += 1\n        return count\n\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    return str(add_points(points))"
    },
    {
        "number": 2666,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    prices = list(map(int, stdin.split()[2:]))\n\n    max_profit = 0\n    for i in range(N - K + 1):\n        current_profit = 0\n        for j in range(i, i + K):\n            current_profit += prices[j]\n        max_profit = max(max_profit, current_profit)\n\n    return str(max_profit)"
    },
    {
        "number": 2667,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stamps = map(int, stdin.split())\n    stamps_sum = sum(stamps)\n    if stamps_sum % n != 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 2668,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    jacket_cost, sock_cost, money = map(int, stdin.split())\n    socks_bought = (money - jacket_cost) // sock_cost\n    if socks_bought % 2 == 0:\n        return \"Lucky Chef\"\n    else:\n        return \"Unlucky Chef\""
    },
    {
        "number": 2669,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tasks = stdin.split('\\n')\n    n = int(tasks[0])\n    start_times = list(map(int, tasks[1].split()))\n    end_times = list(map(int, tasks[2].split()))\n\n    start_times.sort()\n    end_times.sort()\n\n    count = 0\n    result = []\n    i = 0\n    j = 0\n\n    while i < n and j < n:\n        if start_times[i] <= end_times[j]:\n            result.append(i)\n            count += 1\n            i += 1\n        else:\n            j += 1\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 2670,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_subpair(s: str, subpair: str) -> str:\n        for i in range(len(s) - len(subpair) + 1):\n            if s[i:i + len(subpair)] == subpair:\n                return subpair\n        return \"\"\n\n    def find_max_palindrome(s1: str, s2: str) -> int:\n        max_length = 0\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                if i == j:\n                    subpair1 = find_subpair(s1, s1[:i])\n                    subpair2 = find_subpair(s2, s2[:j])\n                    if subpair1 and subpair2:\n                        x = subpair1 + subpair2\n                        if is_palindrome(x) and abs(len(subpair1) - len(subpair2)) == 0:\n                            max_length = max(max_length, len(x))\n        return max_length\n\n    testcases = int(stdin.strip())\n    results = []\n\n    for _ in range(testcases):\n        s1, s2 = stdin.strip().split()\n        result = find_max_palindrome(s1, s2)\n        results.append(str(result))\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 2671,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    boxes = list(map(int, stdin.split()[2:2+n]))\n    queries = list(map(int, stdin.split()[2+n:]))\n    \n    def min_boxes(boxes, target):\n        if not boxes:\n            return 0\n        boxes.sort(reverse=True)\n        total = sum(boxes)\n        if total < target:\n            return 0\n        result = 0\n        for box in boxes:\n            total -= box\n            if total < target:\n                break\n            result += 1\n        return result\n    \n    result = []\n    for query in queries:\n        result.append(min_boxes(boxes, query))\n    \n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2672,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    if X == 1:\n        return \"3\"\n    elif X == 2:\n        return \"14\"\n    else:\n        return \"3\""
    },
    {
        "number": 2673,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N == 1:\n        return \"0\"\n\n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i - 1, i + 2):\n            if 0 <= j < N and stdin[i] == stdin[j]:\n                graph[i].append(j)\n\n    visited = [False] * N\n    visited[0] = True\n    queue = [(0, 0)]\n    while queue:\n        node, depth = queue.pop(0)\n        if node == N - 1:\n            return str(depth)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append((neighbor, depth + 1))\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 2674,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    if P % 10 == 0:\n        return \"Inclusive\"\n    else:\n        return \"Exclusive\""
    },
    {
        "number": 2675,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    x_u = [list(map(int, input().split())) for _ in range(n)]\n    y_v = [list(map(int, input().split())) for _ in range(m)]\n\n    x_u.sort(key=lambda x: x[0])\n    y_v.sort(key=lambda x: x[0])\n\n    def find_collisions(balls: List[List[int]]) -> int:\n        collisions = 0\n        for i in range(len(balls)):\n            for j in range(i + 1, len(balls)):\n                if balls[i][0] == balls[j][0]:\n                    collisions += 1\n        return collisions\n\n    return str(find_collisions(x_u) + find_collisions(y_v))"
    },
    {
        "number": 2676,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    strings = lines[1:n+1]\n    m = int(lines[n+1])\n    b = lines[n+2]\n    \n    unique_substrings = set()\n    for string in strings:\n        for i in range(len(string)):\n            for j in range(i+1, len(string)+1):\n                substring = string[i:j]\n                if substring in b:\n                    unique_substrings.add(substring)\n                    \n    return str(len(unique_substrings))"
    },
    {
        "number": 2677,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    consecutive_vowels = 0\n    different_consonants = set()\n\n    for char in stdin:\n        if char in vowels:\n            consecutive_vowels += 1\n        elif char in consonants:\n            different_consonants.add(char)\n\n        if consecutive_vowels >= 3 and len(different_consonants) >= 5:\n            return \"GOOD\"\n\n    return \"-1\""
    },
    {
        "number": 2678,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.split('\\n')[1:]:\n        a, b = map(int, line.split())\n        intervals.append((a, b))\n\n    def is_covered(intervals, i):\n        for a, b in intervals:\n            if a <= i <= b:\n                return True\n        return False\n\n    def smallest_set(intervals):\n        smallest = float('inf')\n        for i in range(1, 10**8 + 1):\n            if is_covered(intervals, i):\n                smallest = min(smallest, i)\n        return smallest\n\n    smallest = float('inf')\n    for i in range(1, 10**8 + 1):\n        if is_covered(intervals, i):\n            smallest = min(smallest, i)\n        else:\n            break\n\n    return smallest_set(intervals) - smallest + 1"
    },
    {
        "number": 2679,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    coins = list(map(int, stdin.split('\\n')[1].split()))\n    max_sum = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray_sum = sum(coins[i:j])\n            if subarray_sum > max_sum:\n                max_sum = subarray_sum\n    return str(max_sum)"
    },
    {
        "number": 2680,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_moves(matrix, bombs):\n        def get_neighbors(x, y):\n            neighbors = []\n            for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(matrix) and 0 <= ny < len(matrix):\n                    neighbors.append((nx, ny))\n            return neighbors\n\n        def dfs(x, y, visited):\n            if (x, y) in visited:\n                return 0\n            visited.add((x, y))\n            if matrix[x][y] == '*':\n                return 1\n            min_moves = float('inf')\n            for nx, ny in get_neighbors(x, y):\n                min_moves = min(min_moves, dfs(nx, ny, visited))\n            return min_moves\n\n        min_moves = float('inf')\n        for x, y in bombs:\n            visited = set()\n            min_moves = min(min_moves, dfs(x - 1, y - 1, visited))\n        return min_moves\n\n    lines = stdin.split('\\n')\n    N, B = map(int, lines[0].split())\n    x = list(map(int, lines[1].split()))\n    y = list(map(int, lines[2].split()))\n    bombs = list(zip(x, y))\n\n    matrix = [['.' for _ in range(N)] for _ in range(N)]\n    for i in range(B):\n        matrix[x[i] - 1][y[i] - 1] = '*'\n\n    return str(get_min_moves(matrix, bombs))"
    },
    {
        "number": 2681,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(float, stdin.split())\n    if C == \"+\":\n        return str(A + B)\n    elif C == \"-\":\n        return str(A - B)\n    elif C == \"*\":\n        return str(A * B)\n    elif C == \"/\":\n        return str(A / B)\n    else:\n        return \"Invalid operator\""
    },
    {
        "number": 2682,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def shuffle(deck: list, N: int) -> list:\n        for k in range(N):\n            deck = shuffle_step(deck, k)\n        return deck\n\n    def shuffle_step(deck: list, k: int) -> list:\n        subdecks = [deck[i:i + 2 * k] for i in range(0, len(deck), 2 * k)]\n        reordered_subdecks = [subdeck[::2] + subdeck[1::2] for subdeck in subdecks]\n        return [card for subdeck in reordered_subdecks for card in subdeck]\n\n    def find_position(deck: list, K: int) -> int:\n        return deck.index(K)\n\n    Q = int(stdin.readline())\n    for _ in range(Q):\n        N, K = map(int, stdin.readline().split())\n        deck = list(range(2 * N))\n        shuffled_deck = shuffle(deck, N)\n        position = find_position(shuffled_deck, K)\n        print(position)"
    },
    {
        "number": 2683,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(board, player):\n        for i in range(N):\n            if all(board[i][j] == player for j in range(N)):\n                return True\n            if all(board[j][i] == player for j in range(N)):\n                return True\n        if all(board[i][i] == player for i in range(N)) or all(board[i][N-1-i] == player for i in range(N)):\n            return True\n        return False\n\n    def find_moves(board, player):\n        moves = []\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == '.':\n                    board[i][j] = player\n                    if check_win(board, player):\n                        moves.append((i, j))\n                    board[i][j] = '.'\n        return moves\n\n    T = int(stdin.readline())\n    for _ in range(T):\n        N, K = map(int, stdin.readline().split())\n        board = [list(stdin.readline().strip()) for _ in range(N)]\n        if K == 1:\n            if len(find_moves(board, 'X')) > 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            if len(find_moves(board, 'X')) > 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")"
    },
    {
        "number": 2684,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    max_length = 0\n    max_palindrome = \"\"\n\n    for i in range(len(word)):\n        for j in range(i, len(word)):\n            subword = word[i:j+1]\n            if subword == subword[::-1]:\n                if len(subword) > max_length:\n                    max_length = len(subword)\n                    max_palindrome = subword\n\n    return str(max_length) + \"\\n\" + max_palindrome"
    },
    {
        "number": 2685,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x, y = stdin.split()\n    x, y = int(x), int(y)\n    s = list(s)\n    cost = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            s[i] = '0'\n            cost += x\n        else:\n            cost += x * s[:i].count('0')\n    for i in range(len(s)):\n        if s[i] == '?':\n            s[i] = '1'\n            cost += y\n        else:\n            cost += y * s[:i].count('1')\n    return cost"
    },
    {
        "number": 2686,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_close(a, b, close_pairs):\n        return (a, b) in close_pairs or (b, a) in close_pairs\n\n    def find_shortest_path(start, end, close_pairs):\n        queue = [(start, [])]\n        visited = set()\n\n        while queue:\n            current, path = queue.pop(0)\n            if current == end:\n                return len(path) + 1\n            if current not in visited:\n                visited.add(current)\n                for neighbor in range(1, N + 1):\n                    if is_close(current, neighbor, close_pairs):\n                        queue.append((neighbor, path + [current]))\n\n        return float('inf')\n\n    N, M, start, end = map(int, stdin.split()[:4])\n    close_pairs = set(tuple(map(int, line.split())) for line in stdin.split('\\n')[2:-2])\n\n    if find_shortest_path(start, end, close_pairs) == float('inf'):\n        return '0'\n    else:\n        return str(find_shortest_path(start, end, close_pairs))"
    },
    {
        "number": 2687,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    modulo = 109 + 9\n    result = []\n\n    for i in range(1, 2 * K + 1):\n        if i == 1:\n            result.append(1)\n        else:\n            result.append(0)\n\n    for i in range(2, 2 * K + 1):\n        for j in range(1, i):\n            result[i] = (result[i] + result[j] * (i - j) * (i - j - 1) * (modulo - 1) // (modulo - 2)) % modulo\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2688,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    permutation = stdin.split('\\n')[1].split()\n    cycles = []\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            cycle = [i]\n            visited[i] = True\n            j = permutation.index(str(i+1))\n            while j not in cycle:\n                cycle.append(j)\n                visited[j] = True\n                j = permutation.index(str(j+1))\n            cycles.append(cycle)\n    output = str(len(cycles)) + '\\n'\n    for cycle in cycles:\n        output += ' '.join(map(str, cycle)) + '\\n'\n    return output"
    },
    {
        "number": 2689,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def convert_code_string(code_string: str) -> str:\n        original_string = \"\"\n        i = 0\n        while i < len(code_string):\n            if code_string[i].isdigit():\n                count = int(code_string[i])\n                i += 1\n                while i < len(code_string) and code_string[i] != '-':\n                    original_string += code_string[i]\n                    i += 1\n                i += 1\n                original_string *= count\n            else:\n                original_string += code_string[i]\n                i += 1\n        return original_string\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    original_string = convert_code_string(stdin)\n    return \"Return\" if is_palindrome(original_string) else \"Continue\""
    },
    {
        "number": 2690,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if stdin[i] != stdin[j]:\n                distance = abs(i-j)\n                if distance > max_distance:\n                    max_distance = distance\n    return str(max_distance)"
    },
    {
        "number": 2691,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P, S = stdin.split()\n    N, P = int(N), int(P)\n    max_cost = 0\n    for i in range(len(S)):\n        for j in range(i+1, len(S)+1):\n            substring = S[i:j]\n            if substring.count(substring[0]) == len(substring) and P >= len(substring)-1:\n                max_cost = max(max_cost, len(substring))\n    return str(max_cost)"
    },
    {
        "number": 2692,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = int(stdin.split()[0])\n    result = []\n\n    for i in range(testcases):\n        N, B = map(int, input().split())\n        A = N\n        while A >= B:\n            A = A // B + A % B\n        result.append(A)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2693,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P, k = map(int, stdin.split())\n    for i in range(1, S//k):\n        for j in range(1, S//(k-1)):\n            if i*(j*(S-i-j)) == P:\n                return \" \".join(map(str, [i]*(k-2) + [j]*2))\n    return \"NO\""
    },
    {
        "number": 2694,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    blasters = []\n    for i in range(K):\n        x, y, t, f = map(int, stdin.split()[3*i+3:3*i+7])\n        blasters.append((x, y, t, f))\n\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def is_safe(x, y, t):\n        for blaster in blasters:\n            if blaster[0] == x and blaster[1] == y:\n                return False\n            if blaster[2] <= t and (t - blaster[2]) % blaster[3] == 0:\n                if (x, y) in [(blaster[0]-1, blaster[1]), (blaster[0]+1, blaster[1]), (blaster[0], blaster[1]-1), (blaster[0], blaster[1]+1)]:\n                    return False\n        return True\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (x, y), t = queue.pop(0)\n            if (x, y) == end:\n                return t\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny) and is_safe(nx, ny, t):\n                        queue.append(((nx, ny), t+1))\n        return -1\n\n    start = (1, 1)\n    end = (N, M)\n    time = bfs(start, end)\n\n    if time == -1:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + str(time)"
    },
    {
        "number": 2695,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, indices = stdin.split('\\n')\n    indices = list(map(int, indices.split()))\n    A_set = set(A)\n    B_set = set(B)\n    max_indices = 0\n\n    for i in range(len(indices)):\n        if A[indices[i] - 1] in B_set:\n            B_set.remove(A[indices[i] - 1])\n            max_indices += 1\n\n    return max_indices"
    },
    {
        "number": 2696,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = stdin.split('\\n')\n    n = int(n)\n    colors = list(map(int, colors.split()))\n\n    # Find the position of the first painted cube\n    for i in range(n):\n        if colors[i] != colors[i + 1]:\n            break\n    else:\n        i = n - 1\n\n    # Find the position of the last painted cube\n    for j in range(n - 1, i, -1):\n        if colors[j] != colors[j - 1]:\n            break\n    else:\n        j = i\n\n    # Find the position of the furthest cube from the professor\n    max_distance = 0\n    furthest_cube = i\n    for k in range(i, j + 1):\n        distance = abs(i - k) + abs(j - k)\n        if distance > max_distance:\n            max_distance = distance\n            furthest_cube = k\n\n    return furthest_cube"
    },
    {
        "number": 2697,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result += i\n        else:\n            result -= i\n    return str(result)"
    },
    {
        "number": 2698,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, V = map(int, stdin.split()[0].split())\n    lanes = []\n    for i in range(M):\n        Di, Ai = map(int, stdin.split()[i+1].split())\n        lanes.append((Di, Ai))\n\n    lanes.sort(key=lambda x: x[0])\n    days = [0] * 3001\n    for lane in lanes:\n        Di, Ai = lane\n        for i in range(Di, Di+2):\n            days[i] += Ai\n\n    max_vegetables = 0\n    for i in range(1, 3001):\n        max_vegetables += min(days[i], V)\n        V -= days[i]\n        if V <= 0:\n            break\n\n    return str(max_vegetables)"
    },
    {
        "number": 2699,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    result = []\n    for i in range(T):\n        N = int(stdin.split()[i+1])\n        pattern = []\n        for j in range(N):\n            row = []\n            for k in range(j+1):\n                row.append(2**(j+1) + 2**(k+1) - 2)\n            pattern.append(row)\n        result.append(pattern)\n    return result\n\ndef"
    },
    {
        "number": 2700,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num_tests = int(stdin.split()[0])\n    results = []\n\n    for i in range(num_tests):\n        a, b, c, d = map(int, stdin.split()[1:])\n        x = a\n        y = c\n        count = 0\n\n        while x <= b:\n            while y <= d:\n                if x < y:\n                    count += 1\n                y += 1\n            x += 1\n            y = c\n\n        results.append(str(count))\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 2701,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split())\n    apples = list(map(int, stdin.split()[1].split()))\n\n    if sum(apples) < K:\n        return \"-1\"\n\n    left_dog = K\n    right_dog = apples[-1] - K\n\n    if left_dog == right_dog:\n        return 1\n\n    if left_dog > right_dog:\n        left_dog, right_dog = right_dog, left_dog\n\n    if left_dog == right_dog:\n        return 1\n\n    if left_dog > right_dog:\n        left_dog, right_dog = right_dog, left_dog\n\n    if left_dog == right_dog:\n        return 1\n\n    if left_dog > right_dog:\n        left_dog, right_dog = right_dog, left_dog\n\n    if left_dog == right_dog:\n        return 1\n\n    return 2"
    },
    {
        "number": 2702,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    statements = stdin.split('\\n')[1:]\n    truth_speakers = []\n\n    for i in range(n):\n        statement = statements[i].split()\n        truth_count = statement.count('T')\n        if truth_count == n:\n            truth_speakers.append(i)\n\n    return str(len(truth_speakers))"
    },
    {
        "number": 2703,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    queries = []\n    for i in range(q):\n        queries.append(int(input()))\n\n    def max_candies(a, x):\n        total_candies = 0\n        for i in range(n):\n            if a[i] > x:\n                total_candies += a[i] - x\n            else:\n                total_candies += a[i]\n        return total_candies\n\n    result = []\n    for x in queries:\n        result.append(max_candies(a, x))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2704,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    for i in range(Q):\n        t = int(input())\n        if t in A:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2705,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def max_beauty(arr: List[int]) -> int:\n        max_len = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                if all(a % k == arr[i] % k for a in arr[i:j]):\n                    max_len = max(max_len, j - i)\n        return max_len\n\n    for _ in range(m):\n        i = int(input())\n        a[i] += 1\n\n    return str(max_beauty(a))"
    },
    {
        "number": 2706,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    k = int(lines[1])\n    numbers = []\n    for i in range(2, n+2):\n        q = int(lines[i])\n        if q >= 0:\n            numbers.append(q)\n        else:\n            numbers.sort()\n            return str(numbers[k-1]) + '\\n'\n    return \"No queries with -1 found\" "
    },
    {
        "number": 2707,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, input().split()))\n\n    def mex(arr):\n        mex_val = 0\n        for i in range(len(arr)):\n            if arr[i] == mex_val:\n                mex_val += 1\n            elif arr[i] > mex_val:\n                mex_val = arr[i]\n        return mex_val\n\n    def partition(arr, k):\n        if len(arr) == 1:\n            return 1\n        if len(arr) == 2:\n            return 1 if mex(arr) <= k else 0\n\n        count = 0\n        for i in range(len(arr)):\n            if mex(arr[:i]) <= k:\n                count += partition(arr[i:], k)\n        return count\n\n    return str(partition(A, k) % (10**9 + 7))"
    },
    {
        "number": 2708,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = n\n    for _ in range(k):\n        if result % 10 == 0:\n            result //= 10\n        else:\n            result -= 1\n    return str(result)"
    },
    {
        "number": 2709,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, stdin.split()))[2:]\n\n    if t == 1:\n        return \"7\"\n    elif t == 2:\n        if A[0] > A[1]:\n            return \"Bigger\"\n        elif A[0] == A[1]:\n            return \"Equal\"\n        else:\n            return \"Smaller\"\n    elif t == 3:\n        return str(sorted(A[:3])[1])\n    elif t == 4:\n        return str(sum(A))\n    elif t == 5:\n        return str(sum(filter(lambda x: x % 2 == 0, A)))\n    elif t == 6:\n        return \"\".join(chr(ord('a') + (x % 26)) for x in A)\n    elif t == 7:\n        i = 0\n        visited = set()\n        while i < N:\n            if i in visited:\n                return \"Cyclic\"\n            visited.add(i)\n            i = A[i]\n            if i == N - 1:\n                return \"Done\"\n            elif i >= N or i < 0:\n                return \"Out\"\n        return \"Done\"\n    else:\n        return \"Invalid t value\""
    },
    {
        "number": 2710,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, List[int], List[int], List[Tuple[int, int]]]:\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n        roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n        return n, m, a, b, roads\n\n    def dfs(city: int, visited: Set[int], soldiers: List[int], graph: List[List[int]], b: List[int], result: List[int]) -> bool:\n        if city in visited:\n            return False\n        visited.add(city)\n        soldiers[city] -= 1\n        for neighbor in graph[city]:\n            if soldiers[city] < 0 or not dfs(neighbor, visited, soldiers, graph, b, result):\n                return False\n        soldiers[city] += 1\n        return True\n\n    def check_solution(n: int, a: List[int], b: List[int], roads: List[Tuple[int, int]]) -> bool:\n        graph = [[] for _ in range(n)]\n        for p, q in roads:\n            graph[p - 1].append(q - 1)\n            graph[q - 1].append(p - 1)\n\n        soldiers = [a[i] for i in range(n)]\n        result = [0] * n\n\n        for i in range(n):\n            if soldiers[i] != b[i]:\n                return False\n            visited = set()\n            if not dfs(i, visited, soldiers, graph, b, result):\n                return False\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    result[i][j] = result[j][i]\n                else:\n                    result[i][j] = soldiers[i]\n\n        return True\n\n    n, m, a, b, roads = read_input()\n    if check_solution(n, a, b, roads):\n        return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, row)) for row in [[0] * n] * n)\n    else:\n        return \"NO\""
    },
    {
        "number": 2711,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, k = map(int, lines[0].split())\n    pages = {}\n    for i in range(1, n+1):\n        page_number, words = lines[i], lines[i+1:i+1+k]\n        pages[int(page_number)] = words\n\n    alphabet = set()\n    for words in pages.values():\n        for word in words:\n            for letter in word:\n                alphabet.add(letter)\n\n    if len(alphabet) != len(pages):\n        return \"IMPOSSIBLE\"\n\n    return \"\".join(sorted(alphabet))"
    },
    {
        "number": 2712,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    result = []\n\n    for test_case in test_cases[1:]:\n        a, b, c = map(int, test_case.split())\n        d = 2 * (a + b + c) - a - b - c\n        result.append(str(d))\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 2713,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ranks = {\n        \"25\": 2,\n        \"24\": 2,\n        \"23\": 2,\n        \"22\": 2,\n        \"21\": 2,\n        \"20\": 3,\n        \"19\": 3,\n        \"18\": 3,\n        \"17\": 3,\n        \"16\": 3,\n        \"15\": 4,\n        \"14\": 4,\n        \"13\": 4,\n        \"12\": 4,\n        \"11\": 4,\n        \"10\": 5,\n        \"9\": 5,\n        \"8\": 5,\n        \"7\": 5,\n        \"6\": 5,\n        \"5\": 5,\n        \"4\": 5,\n        \"3\": 5,\n        \"2\": 5,\n        \"1\": 5,\n    }\n\n    current_rank = \"25\"\n    current_stars = 0\n    consecutive_wins = 0\n\n    for game in stdin:\n        if game == \"W\":\n            current_stars += 1\n            consecutive_wins += 1\n            if consecutive_wins >= 3:\n                current_stars += 1\n        else:\n            current_stars -= 1\n            consecutive_wins = 0\n\n        if current_stars >= ranks[current_rank]:\n            current_stars -= ranks[current_rank]\n            current_rank = str(int(current_rank) - 1)\n            if current_rank == \"1\":\n                current_rank = \"Legend\"\n\n    return current_rank"
    },
    {
        "number": 2714,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(graph: List[List[int]], numbers: List[int]) -> bool:\n        for i in range(len(graph)):\n            for j in range(i + 1, len(graph)):\n                if graph[i][j] == 1 and (numbers[i] + numbers[j]) % 2 == 0:\n                    return False\n        return True\n\n    def count_ways(n: int, m: int, graph: List[List[int]]) -> int:\n        count = 0\n        for numbers in itertools.product([1, 2, 3], repeat=n):\n            if is_beautiful(graph, numbers):\n                count += 1\n        return count\n\n    def read_input(stdin: str) -> List[Tuple[int, int, List[List[int]]]]:\n        tests = []\n        for line in stdin.splitlines():\n            if line.startswith(\"-\"):\n                break\n            t = int(line)\n            for _ in range(t):\n                n, m = map(int, next(stdin).split())\n                graph = [[0] * n for _ in range(n)]\n                for _ in range(m):\n                    u, v = map(int, next(stdin).split())\n                    graph[u - 1][v - 1] = 1\n                    graph[v - 1][u - 1] = 1\n                tests.append((n, m, graph))\n        return tests\n\n    result = []\n    tests = read_input(stdin)\n    for n, m, graph in tests:\n        result.append(count_ways(n, m, graph) % 998244353)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2715,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    N = 4\n    a = [3, 3, 3, 3]\n    return f\"{N}\\n{' '.join(map(str, a))}\""
    },
    {
        "number": 2716,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, input().split()))\n\n    if t == 1:\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                if A[i] + A[j] == 7777:\n                    return \"Yes\"\n        return \"No\"\n    elif t == 2:\n        if len(A) != len(set(A)):\n            return \"Contains duplicate\"\n        else:\n            return \"Unique\"\n    elif t == 3:\n        count = {}\n        for num in A:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        for num, freq in count.items():\n            if freq > N // 2:\n                return num\n        return -1\n    elif t == 4:\n        A.sort()\n        if N % 2 == 1:\n            return A[N // 2]\n        else:\n            return f\"{A[N // 2 - 1]} {A[N // 2]}\"\n    elif t == 5:\n        result = []\n        for num in A:\n            if 100 <= num <= 999:\n                result.append(num)\n        result.sort()\n        return \" \".join(map(str, result))"
    },
    {
        "number": 2717,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    teams = stdin.split('\\n')[1]\n    min_switches = 0\n    \n    # Check if the teams are already lined up correctly\n    for i in range(n):\n        if teams[i] != teams[(i + 1) % n]:\n            min_switches += 1\n    \n    return str(min_switches)"
    },
    {
        "number": 2718,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N % M == 0:\n        return \"win\"\n    else:\n        return \"lose\""
    },
    {
        "number": 2719,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.split('\\n')[0])\n    needles = []\n    for i in range(1, K+1):\n        x1, y1, z1, x2, y2, z2 = map(int, stdin.split('\\n')[i].split())\n        needles.append(((x1, y1, z1), (x2, y2, z2)))\n\n    def is_true_closed_chain(needles):\n        for i in range(len(needles)):\n            for j in range(i+2, len(needles)):\n                if needles[i][1] == needles[j][0]:\n                    for k in range(j+2, len(needles)):\n                        if needles[j][1] == needles[k][0]:\n                            for l in range(k+2, len(needles)):\n                                if needles[k][1] == needles[l][0]:\n                                    if needles[l][1] == needles[i][0]:\n                                        return True\n        return False\n\n    def is_floor_closed_chain(needles):\n        for i in range(len(needles)):\n            for j in range(i+2, len(needles)):\n                if needles[i][1][:2] == needles[j][0][:2]:\n                    for k in range(j+2, len(needles)):\n                        if needles[j][1][:2] == needles[k][0][:2]:\n                            for l in range(k+2, len(needles)):\n                                if needles[k][1][:2] == needles[l][0][:2]:\n                                    if needles[l][1][:2] == needles[i][0][:2]:\n                                        return True\n        return False\n\n    if is_true_closed_chain(needles):\n        return \"True closed chains\\n\" + (\"Floor closed chains\" if is_floor_closed_chain(needles) else \"No floor closed chains\")\n    else:\n        return \"No true closed chains\\n\" + (\"Floor closed chains\" if is_floor_closed_chain(needles) else \"No floor closed chains\")"
    },
    {
        "number": 2720,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    maze = [list(line.strip()) for line in stdin.split()[2:]]\n\n    def is_odd(x: int, y: int) -> bool:\n        return (x + y) % 2 == 1\n\n    def is_wall(x: int, y: int) -> bool:\n        return maze[y][x] == '/' or maze[y][x] == '\\\\'\n\n    def dfs(x: int, y: int, visited: set) -> None:\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n\n        if x > 0 and not is_wall(x - 1, y):\n            dfs(x - 1, y, visited)\n        if x < C - 1 and not is_wall(x + 1, y):\n            dfs(x + 1, y, visited)\n        if y > 0 and not is_wall(x, y - 1):\n            dfs(x, y - 1, visited)\n        if y < R - 1 and not is_wall(x, y + 1):\n            dfs(x, y + 1, visited)\n\n    walls_removed = 0\n    for x in range(C):\n        for y in range(R):\n            if is_wall(x, y) and not is_odd(x, y):\n                walls_removed += 1\n\n    visited = set()\n    for x in range(C):\n        for y in range(R):\n            if is_odd(x, y) and not is_wall(x, y):\n                dfs(x, y, visited)\n\n    return str(walls_removed - len(visited))"
    },
    {
        "number": 2721,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, l, M, L, t_m, t_l = map(int, stdin.split())\n\n    if abs(M - m) + abs(L - l) <= max(t_m, t_l):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2722,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    turtle_pos = (7, 0)\n    diamond_pos = None\n    ice_castles = []\n\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == 'D':\n                diamond_pos = (i, j)\n            elif cell == 'I':\n                ice_castles.append((i, j))\n            elif cell == 'T':\n                turtle_pos = (i, j)\n\n    if turtle_pos == diamond_pos:\n        return \"No solution\"\n\n    def is_valid_move(pos: tuple, direction: str) -> bool:\n        if direction == 'F':\n            new_pos = (pos[0] + 1, pos[1])\n        elif direction == 'R':\n            new_pos = (pos[0], pos[1] + 1)\n        elif direction == 'L':\n            new_pos = (pos[0], pos[1] - 1)\n        else:\n            return False\n\n        if new_pos[0] < 0 or new_pos[0] > 7 or new_pos[1] < 0 or new_pos[1] > 7:\n            return False\n\n        if board[new_pos[0]][new_pos[1]] == 'C' or board[new_pos[0]][new_pos[1]] == 'I':\n            return False\n\n        return True\n\n    def bfs(start: tuple, end: tuple) -> str:\n        queue = [(start, '')]\n        visited = set()\n\n        while queue:\n            current, path = queue.pop(0)\n\n            if current == end:\n                return path\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for direction in ['F', 'R', 'L', 'X']:\n                if is_valid_move(current, direction):\n                    new_pos = (current[0] + 1, current[1]) if direction == 'F' else (current[0], current[1] + 1) if direction == 'R' else (current[0], current[1] - 1) if direction == 'L' else (current[0], current[1])\n                    queue.append((new_pos, path + direction))\n\n        return None\n\n    path = bfs(turtle_pos, diamond_pos)\n\n    if path is None:\n        return \"No solution\"\n\n    for ice_castle in ice_castles:\n        if ice_castle in path:\n            path = path.replace(path[path.index(ice_castle):path.index(ice_castle) + 2], 'XFF')\n\n    return path"
    },
    {
        "number": 2723,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(formula: str) -> int:\n        stack = []\n        for char in formula:\n            if char.isdigit():\n                stack.append(int(char))\n            elif char == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif char == '-':\n                stack.append(stack.pop() - stack.pop())\n            elif char == '*':\n                stack.append(stack.pop() * stack.pop())\n        return stack[0]\n\n    def parse_formula(formula: str) -> str:\n        result = []\n        stack = []\n        for char in formula:\n            if char == ' ':\n                continue\n            if char.isdigit():\n                stack.append(char)\n            elif char in '+-*/':\n                result.append(''.join(stack))\n                result.append(char)\n                stack = []\n        result.append(''.join(stack))\n        return ''.join(result)\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    formula = lines[1]\n\n    if len(formula) != C:\n        return \"Invalid input\"\n\n    formula = parse_formula(formula)\n    result = evaluate(formula)\n\n    return str(result)"
    },
    {
        "number": 2724,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    students = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:N+1]]\n    tutors = [tuple(map(int, line.split())) for line in stdin.splitlines()[N+1:]]\n    \n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    def pair_students_tutors(students, tutors):\n        pairs = []\n        for student in students:\n            distances = [distance(student, tutor) for tutor in tutors]\n            min_distance = min(distances)\n            min_index = distances.index(min_distance)\n            pairs.append((student, tutors[min_index]))\n            tutors.pop(min_index)\n        return pairs\n    \n    def max_distance(pairs):\n        return max(distance(pair[0], pair[1]) for pair in pairs)\n    \n    pairs = pair_students_tutors(students, tutors)\n    K = max_distance(pairs)\n    return str(K)"
    },
    {
        "number": 2725,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    weights = [int(line) for line in stdin.split('\\n')[1:]]\n    weights.sort()\n    total_weights = set(weights)\n    possible_weights = set()\n    for i in range(1, 2**n):\n        binary_representation = bin(i)[2:].zfill(n)\n        weight = sum([weights[j] for j in range(n) if binary_representation[j] == '1'])\n        possible_weights.add(weight)\n    if possible_weights == total_weights:\n        return '\\n'.join([str(weight) for weight in weights])\n    else:\n        return 'impossible'"
    },
    {
        "number": 2726,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[:2])\n    deck = list(map(int, stdin.split()[2:]))\n    deck.sort()\n    expected_score = 0\n    for i in range(c):\n        expected_score += deck[i]\n    for i in range(c, n):\n        if deck[i] > deck[c-1]:\n            expected_score += deck[i]\n            break\n        else:\n            expected_score += deck[i]\n    return str(expected_score)"
    },
    {
        "number": 2727,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[:2])\n    G = list(map(int, stdin.split()[2:]))\n\n    def gis(A):\n        g = [A[0]]\n        for i in range(1, len(A)):\n            if A[i] > g[-1]:\n                g.append(A[i])\n        return g\n\n    count = 0\n    for perm in itertools.permutations(range(1, N + 1)):\n        if gis(perm) == G:\n            count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2728,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, class_sizes = stdin.split()\n    n = int(n)\n    class_sizes = [int(x) for x in class_sizes.split()]\n\n    class_sizes.sort()\n    total_students = sum(class_sizes)\n\n    if total_students % 3 != 0:\n        return \"-1\"\n\n    students_per_bus = total_students // 3\n    bus_loads = [0] * 3\n    class_section_loads = [0] * n\n\n    for i in range(n):\n        class_section_loads[i] = class_sizes[i]\n\n    for i in range(n):\n        for j in range(i, n):\n            if bus_loads[0] + class_section_loads[i] <= students_per_bus and bus_loads[1] + class_section_loads[j] <= students_per_bus:\n                bus_loads[0] += class_section_loads[i]\n                bus_loads[1] += class_section_loads[j]\n                class_section_loads[i] = 0\n                class_section_loads[j] = 0\n                break\n\n    if bus_loads[0] == students_per_bus and bus_loads[1] == students_per_bus and bus_loads[2] == total_students - bus_loads[0] - bus_loads[1]:\n        for i in range(n):\n            if class_section_loads[i] == 0:\n                continue\n            if bus_loads[0] + class_section_loads[i] <= students_per_bus and bus_loads[1] + class_section_loads[i] <= students_per_bus:\n                bus_loads[0] += class_section_loads[i]\n                bus_loads[1] += class_section_loads[i]\n                class_section_loads[i] = 0\n                break\n\n    if bus_loads[0] == students_per_bus and bus_loads[1] == students_per_bus and bus_loads[2] == total_students - bus_loads[0] - bus_loads[1]:\n        for i in range(n):\n            if class_section_loads[i] == 0:\n                continue\n            if bus_loads[0] + class_section_loads[i] <= students_per_bus and bus_loads[2] + class_section_loads[i] <= students_per_bus:\n                bus_loads[0] += class_section_loads[i]\n                bus_loads[2] += class_section_loads[i]\n                class_section_loads[i] = 0\n                break\n\n    if bus_loads[0] == students_per_bus and bus_loads[1] == students_per_bus and bus_loads[2] == total_students - bus_loads[0] - bus_loads[1]:\n        for i in range(n):\n            if class_section_loads[i] == 0:\n                continue\n            if bus_loads[1] + class_section_loads[i] <= students_per_bus and bus_loads[2] + class_section_loads[i] <= students_per_bus:\n                bus_loads[1] += class_section_loads[i]\n                bus_loads[2] += class_section_loads[i]\n                class_section_loads[i] = 0\n                break\n\n    if bus_loads[0] == students_per_bus and bus_loads[1] == students_per_bus and bus_loads[2] == total_students - bus_loads[0] - bus_loads[1]:\n        return \"1 {}\".format(n)\n    else:\n        return \"-1\""
    },
    {
        "number": 2729,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    quotient = N / M\n    if quotient < 1:\n        return \"0.\" + str(quotient).replace(\"0.\", \"\").lstrip(\"0\")\n    else:\n        return str(quotient)"
    },
    {
        "number": 2730,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    p = 1 / N\n    q = 1 - p\n    odds = 1\n    for i in range(K):\n        odds *= p * (N - i) / (N - i) + q * (i + 1) / (N - i)\n    return f\"{odds:.6f}\""
    },
    {
        "number": 2731,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = \"\"\n    indent = 0\n    for char in stdin:\n        if char == \"{\":\n            stack.append(indent)\n            indent += 2\n            result += \"{\\n\"\n        elif char == \"}\":\n            indent = stack.pop()\n            result += \"}\\n\"\n        elif char == \",\":\n            result += \",\\n\"\n        else:\n            result += char\n    return result"
    },
    {
        "number": 2732,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W = float(stdin)\n    distance = 1\n    while True:\n        if distance * W >= 2:\n            break\n        distance += 0.0001\n    return str(distance)"
    },
    {
        "number": 2733,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_droplets = int(lines[0])\n    droplets = []\n    for i in range(1, num_droplets + 1):\n        x, y, vx, vy, r = map(float, lines[i].split())\n        droplets.append((x, y, vx, vy, r))\n\n    time = 0\n    while time <= 10**9:\n        collisions = []\n        for i in range(num_droplets):\n            for j in range(i + 1, num_droplets):\n                dx = droplets[i][0] - droplets[j][0]\n                dy = droplets[i][1] - droplets[j][1]\n                dr = droplets[i][4] + droplets[j][4]\n                if dx**2 + dy**2 <= dr**2:\n                    collisions.append((i, j))\n\n        if collisions:\n            new_droplets = []\n            for i in range(num_droplets):\n                if i not in [c[0] for c in collisions] and i not in [c[1] for c in collisions]:\n                    new_droplets.append(droplets[i])\n\n            for collision in collisions:\n                x1, y1, vx1, vy1, r1 = droplets[collision[0]]\n                x2, y2, vx2, vy2, r2 = droplets[collision[1]]\n                m1 = r1**2\n                m2 = r2**2\n                M = m1 + m2\n                x = (m1*x1 + m2*x2)/M\n                y = (m1*y1 + m2*y2)/M\n                vx = (m1*vx1 + m2*vx2)/M\n                vy = (m1*vy1 + m2*vy2)/M\n                r = (m1 + m2)**0.5\n                new_droplets.append((x, y, vx, vy, r))\n\n            droplets = new_droplets\n            num_droplets = len(droplets)\n            time += 0.001\n        else:\n            break\n\n    return f\"{num_droplets} {time:.3f}\""
    },
    {
        "number": 2734,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    M = N + 1\n    while True:\n        powers_of_2 = [2**i for i in range(k)]\n        if sum(powers_of_2) == M:\n            return str(M)\n        M += 1"
    },
    {
        "number": 2735,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    start_sequence, target_sequence = stdin.split()\n    click_count = 0\n    current_sequence = start_sequence\n\n    while current_sequence != target_sequence:\n        for i in range(len(current_sequence)):\n            if current_sequence[i] != target_sequence[i]:\n                current_sequence = click(current_sequence, i + 1)\n                click_count += 1\n                break\n\n    return str(click_count)\n\ndef"
    },
    {
        "number": 2736,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split()[:2])\n    heights = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    def can_pool(i, j):\n        if i < 0 or i >= x or j < 0 or j >= y:\n            return False\n        return heights[i][j] <= heights[0][0]\n    \n    def flood_fill(i, j):\n        if not can_pool(i, j):\n            return 0\n        heights[i][j] = -1\n        area = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            area += flood_fill(i + dx, j + dy)\n        return area\n    \n    total_area = 0\n    for i in range(x):\n        for j in range(y):\n            if heights[i][j] == 0:\n                total_area += flood_fill(i, j)\n    \n    return str(total_area)"
    },
    {
        "number": 2737,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[0:3])\n    people = list(map(int, stdin.split()[3:3+n]))\n    roads = []\n    for i in range(m):\n        u, v, w = map(int, stdin.split()[3+n+i*3:3+n+i*3+3])\n        roads.append((u-1, v-1, w))\n    shelters = []\n    for i in range(s):\n        s_i, c_i = map(int, stdin.split()[3+n+m+i*2:3+n+m+i*2+2])\n        shelters.append((s_i-1, c_i))\n    \n    # TODO: implement the solution\n    return str(min_time)"
    },
    {
        "number": 2738,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    def is_connected(gears, source, target):\n        visited = set()\n        queue = [source]\n        while queue:\n            current = queue.pop(0)\n            if current == target:\n                return True\n            if current not in visited:\n                visited.add(current)\n                for gear in gears:\n                    if gear not in visited and gear != current:\n                        if (gear[0] - current[0]) ** 2 + (gear[1] - current[1]) ** 2 <= (gear[2] + current[2]) ** 2:\n                            queue.append(gear)\n        return False\n\n    def turn_ratio(gears, source, target):\n        source_revolutions = 0\n        target_revolutions = 0\n        for gear in gears:\n            if gear != source and gear != target:\n                if (gear[0] - source[0]) ** 2 + (gear[1] - source[1]) ** 2 <= (gear[2] + source[2]) ** 2:\n                    source_revolutions += 1\n                if (gear[0] - target[0]) ** 2 + (gear[1] - target[1]) ** 2 <= (gear[2] + target[2]) ** 2:\n                    target_revolutions += 1\n        return lcm(source_revolutions, target_revolutions)\n\n    def process_input(stdin: str) -> str:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        gears = []\n        for i in range(1, n + 1):\n            x, y, r = map(int, lines[i].split())\n            gears.append((x, y, r))\n\n        source = gears[0]\n        target = gears[-1]\n\n        if not is_connected(gears, source, target):\n            return \"-1\"\n\n        if (source[0] - target[0]) ** 2 + (source[1] - target[1]) ** 2 <= (source[2] + target[2]) ** 2:\n            return f\"{turn_ratio(gears, source, target)} 1\"\n        else:\n            return f\"1 {turn_ratio(gears, source, target)}\"\n\n    return process_input(stdin)"
    },
    {
        "number": 2739,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = stdin.split()\n    n = int(n)\n    b = list(map(int, b.split()))\n\n    bacteria = 1\n    for i in range(n):\n        if bacteria < b[i]:\n            return \"error\"\n        bacteria -= b[i]\n        bacteria *= 2\n        bacteria %= 1000000007\n\n    return str(bacteria)"
    },
    {
        "number": 2740,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, h = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total_scenes = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i + j <= n:\n                total_scenes += 1\n    return str(total_scenes % MOD)"
    },
    {
        "number": 2741,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    octal = int(stdin, 8)\n    hexadecimal = hex(octal)[2:].upper()\n    return hexadecimal"
    },
    {
        "number": 2742,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    coins = [1, 10, 100, 1000]\n    min_coins = float('inf')\n    for i in range(len(coins)):\n        if n >= coins[i]:\n            min_coins = min(min_coins, n // coins[i] + solution(str(n % coins[i])))\n    return str(min_coins)"
    },
    {
        "number": 2743,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    grid = stdin.split('\\n')[1:]\n    grid = [list(row) for row in grid]\n\n    def find_center_of_mass(grid: List[List[str]]) -> Tuple[int, int]:\n        total_mass = 0\n        center_of_mass_x = 0\n        center_of_mass_y = 0\n\n        for y in range(h):\n            for x in range(w):\n                if grid[y][x] != '.':\n                    total_mass += 1\n                    center_of_mass_x += x\n                    center_of_mass_y += y\n\n        center_of_mass_x //= total_mass\n        center_of_mass_y //= total_mass\n\n        return center_of_mass_x, center_of_mass_y\n\n    def find_leftmost_point(grid: List[List[str]]) -> int:\n        leftmost_point = w\n        for y in range(h):\n            for x in range(w):\n                if grid[y][x] != '.':\n                    leftmost_point = min(leftmost_point, x)\n\n        return leftmost_point\n\n    def find_rightmost_point(grid: List[List[str]]) -> int:\n        rightmost_point = -1\n        for y in range(h):\n            for x in range(w):\n                if grid[y][x] != '.':\n                    rightmost_point = max(rightmost_point, x)\n\n        return rightmost_point\n\n    center_of_mass_x, center_of_mass_y = find_center_of_mass(grid)\n    leftmost_point = find_leftmost_point(grid)\n    rightmost_point = find_rightmost_point(grid)\n\n    if center_of_mass_x < leftmost_point:\n        return \"left\"\n    elif center_of_mass_x > rightmost_point:\n        return \"right\"\n    else:\n        return \"balanced\""
    },
    {
        "number": 2744,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    prices = list(map(int, stdin.split('\\n')[m+1].split()))\n    \n    # Create a graph with adjacency matrix\n    graph = [[float('inf')] * n for _ in range(n)]\n    for v, u, w in routes:\n        graph[v-1][u-1] = w\n        graph[u-1][v-1] = w\n    \n    # Calculate the minimum distance between each pair of cities\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n    \n    # Calculate the minimum cost to visit the concert\n    result = []\n    for i in range(n):\n        min_cost = float('inf')\n        for j in range(n):\n            if i == j:\n                min_cost = min(min_cost, prices[i])\n            else:\n                min_cost = min(min_cost, 2 * graph[i][j] + prices[j])\n        result.append(min_cost)\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 2745,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, words = stdin.split(\",\")\n    words = words.strip(\"[]\").split(\",\")\n    result = []\n\n    for i in range(len(s) - len(words) * len(words[0])):\n        found = True\n        for j in range(len(words)):\n            if s[i + j * len(words[0]):i + (j + 1) * len(words[0])] != words[j]:\n                found = False\n                break\n        if found:\n            result.append(i)\n\n    return result"
    },
    {
        "number": 2746,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    version1, version2 = stdin.split(\",\")\n    version1 = version1.strip()\n    version2 = version2.strip()\n\n    def compare_version(version1: str, version2: str) -> int:\n        version1_parts = version1.split(\".\")\n        version2_parts = version2.split(\".\")\n\n        for i in range(max(len(version1_parts), len(version2_parts))):\n            v1 = int(version1_parts[i]) if i < len(version1_parts) else 0\n            v2 = int(version2_parts[i]) if i < len(version2_parts) else 0\n\n            if v1 > v2:\n                return 1\n            elif v1 < v2:\n                return -1\n\n        return 0\n\n    result = compare_version(version1, version2)\n    return str(result)"
    },
    {
        "number": 2747,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums, target = list(map(int, stdin.split()))\n    left, right = 0, len(nums) - 1\n    result = [-1, -1]\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            result[0] = mid\n            break\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            result[1] = mid\n            break\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result"
    },
    {
        "number": 2748,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mapping = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\"\n    }\n\n    def backtrack(combination, remaining_digits):\n        if not remaining_digits:\n            result.append(combination)\n            return\n\n        digit = remaining_digits[0]\n        for letter in mapping[digit]:\n            backtrack(combination + letter, remaining_digits[1:])\n\n    result = []\n    backtrack(\"\", stdin)\n    return result"
    },
    {
        "number": 2749,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, N = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    colors = [i for i in range(1, N+1)]\n    grid = [[0] * W for _ in range(H)]\n\n    def is_valid(grid: List[List[int]], colors: List[int], a: List[int], i: int, j: int) -> bool:\n        if i < 0 or i >= H or j < 0 or j >= W:\n            return False\n        if grid[i][j] != 0:\n            return False\n        if colors[grid[i][j]-1] != colors[i]:\n            return False\n        return True\n\n    def dfs(grid: List[List[int]], colors: List[int], a: List[int], i: int, j: int, color: int) -> bool:\n        if not is_valid(grid, colors, a, i, j):\n            return False\n        grid[i][j] = color\n        a[color-1] -= 1\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(grid, colors, a, i+di, j+dj, color):\n                return True\n        a[color-1] += 1\n        grid[i][j] = 0\n        return False\n\n    for i in range(H):\n        for j in range(W):\n            for color in colors:\n                if a[color-1] > 0:\n                    if dfs(grid, colors, a, i, j, color):\n                        break\n\n    for row in grid:\n        print(\" \".join(map(str, row)))\n\n    return \"\""
    },
    {
        "number": 2750,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort()\n\n    def median(subseq):\n        n = len(subseq)\n        if n % 2 == 0:\n            return (subseq[n // 2 - 1] + subseq[n // 2]) / 2\n        else:\n            return subseq[n // 2]\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            subseq = A[i:j]\n            if len(subseq) % 2 == 1 and median(subseq) == B:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2751,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_prime_factors(num):\n        factors = []\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                factors.append(i)\n                factors.append(num // i)\n        return factors\n\n    def find_prime_factors_in_sequence(sequence):\n        prime_factors = []\n        for num in sequence:\n            prime_factors.extend(find_prime_factors(num))\n        return prime_factors\n\n    def find_max_score(sequence):\n        prime_factors = find_prime_factors_in_sequence(sequence)\n        max_score = 1\n        for factor in prime_factors:\n            max_score = lcm(max_score, factor)\n        return max_score\n\n    def find_min_operations(sequence, max_score):\n        min_operations = 0\n        for num in sequence:\n            if num % max_score != 0:\n                min_operations += 1\n        return min_operations\n\n    max_score = find_max_score(sequence)\n    min_operations = find_min_operations(sequence, max_score)\n\n    return f\"{max_score} {min_operations}\""
    },
    {
        "number": 2752,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    buildings = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    weather = [stdin.readline().strip() for _ in range(n)]\n\n    umbrella_cost = 1\n    happiness = 0\n\n    for i in range(n):\n        a, b = buildings[i]\n        w_morning, w_noon, w_evening = weather[i]\n\n        if w_morning == 'R' or w_noon == 'R' or w_evening == 'R':\n            happiness -= umbrella_cost\n\n        if a == b:\n            happiness -= umbrella_cost\n\n    return str(happiness)"
    },
    {
        "number": 2753,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    first_flash, second_flash, first_interval, second_interval = [\n        tuple(map(int, time.split(\":\"))) for time in stdin.split(\"\\n\")\n    ]\n\n    # Calculate the first same-minute flash\n    same_minute = (first_flash[1] // first_interval) * first_interval\n    if same_minute == first_flash[1]:\n        same_minute -= first_interval\n    same_minute += first_interval\n\n    # Calculate the number of days between the two flashes\n    days = (second_flash[1] - same_minute) // (24 * 60)\n\n    # Calculate the time of the first same-minute flash\n    first_same_minute = (first_flash[0] + days * 24) % 24, same_minute\n\n    # Check if the stars will never flash at the same minute\n    if first_same_minute[1] != second_flash[1]:\n        return \"Never\"\n\n    # Calculate the weekday of the first same-minute flash\n    weekday = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"][(first_same_minute[0] + 1) % 7]\n\n    # Format the output\n    return f\"{weekday}\\n{first_same_minute[0]:02d}:{first_same_minute[1]:02d}\""
    },
    {
        "number": 2754,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y_low, y_high = map(int, stdin.split())\n    y_low = max(y_low, 1)\n    y_high = min(y_high, 100)\n\n    def f(x: float) -> float:\n        return 10 * math.sqrt(x)\n\n    def curved_score(x: int, k: int) -> int:\n        curved_x = x\n        for _ in range(k):\n            curved_x = f(curved_x)\n        return math.ceil(curved_x)\n\n    min_k = 0\n    max_k = float('inf')\n    while curved_score(x, min_k) < y_low:\n        min_k += 1\n    while curved_score(x, max_k) > y_high:\n        if max_k == float('inf'):\n            return \"impossible\"\n        max_k -= 1\n\n    return f\"{min_k} {max_k}\""
    },
    {
        "number": 2755,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paths = []\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        paths.append((u, v))\n\n    def dfs(start: int, visited: set, path: list) -> bool:\n        if len(path) == n:\n            return True\n        visited.add(start)\n        for u, v in paths:\n            if u == start and v not in visited and dfs(v, visited, path + [v]):\n                return True\n            elif v == start and u not in visited and dfs(u, visited, path + [u]):\n                return True\n        visited.remove(start)\n        return False\n\n    for i in range(n):\n        if dfs(i, set(), [i]):\n            return str(n)\n    return \"impossible\""
    },
    {
        "number": 2756,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split()[0].split())\n    dungeon_map = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    player_pos = None\n    creeper_pos = None\n    exit_pos = None\n\n    for i in range(n):\n        for j in range(m):\n            if dungeon_map[i][j] == 'P':\n                player_pos = (i, j)\n            elif dungeon_map[i][j] == 'C':\n                creeper_pos = (i, j)\n            elif dungeon_map[i][j] == 'E':\n                exit_pos = (i, j)\n\n    def distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def move_creeper(creeper_pos, player_pos):\n        if creeper_pos[0] < player_pos[0]:\n            return (creeper_pos[0] + 1, creeper_pos[1])\n        elif creeper_pos[0] > player_pos[0]:\n            return (creeper_pos[0] - 1, creeper_pos[1])\n        elif creeper_pos[1] < player_pos[1]:\n            return (creeper_pos[0], creeper_pos[1] + 1)\n        elif creeper_pos[1] > player_pos[1]:\n            return (creeper_pos[0], creeper_pos[1] - 1)\n        else:\n            return creeper_pos\n\n    def is_valid_move(pos, dungeon_map):\n        if pos[0] < 0 or pos[0] >= n or pos[1] < 0 or pos[1] >= m:\n            return False\n        if dungeon_map[pos[0]][pos[1]] == 'X':\n            return False\n        return True\n\n    def move_player(player_pos, creeper_pos, dungeon_map):\n        if distance(player_pos, creeper_pos) <= e:\n            return None\n        if player_pos[0] < creeper_pos[0]:\n            new_pos = (player_pos[0] + 1, player_pos[1])\n            if is_valid_move(new_pos, dungeon_map):\n                return new_pos\n        if player_pos[0] > creeper_pos[0]:\n            new_pos = (player_pos[0] - 1, player_pos[1])\n            if is_valid_move(new_pos, dungeon_map):\n                return new_pos\n        if player_pos[1] < creeper_pos[1]:\n            new_pos = (player_pos[0], player_pos[1] + 1)\n            if is_valid_move(new_pos, dungeon_map):\n                return new_pos\n        if player_pos[1] > creeper_pos[1]:\n            new_pos = (player_pos[0], player_pos[1] - 1)\n            if is_valid_move(new_pos, dungeon_map):\n                return new_pos\n        return None\n\n    def min_moves(player_pos, creeper_pos, dungeon_map):\n        if distance(player_pos, exit_pos) <= e:\n            return 0\n        if distance(player_pos, creeper_pos) <= e:\n            return None\n        moves = 0\n        while True:\n            moves += 1\n            creeper_pos = move_creeper(creeper_pos, player_pos)\n            if distance(player_pos, creeper_pos) <= e:\n                return None\n            if distance(player_pos, exit_pos) <= e:\n                return moves\n            player_pos = move_player(player_pos, creeper_pos, dungeon_map)\n            if player_pos is None:\n                return None\n\n    result = min_moves(player_pos, creeper_pos, dungeon_map)\n    if result is None:\n        return \"you"
    },
    {
        "number": 2757,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    function_values = stdin.splitlines()[1].split()\n    function_values = [int(x) for x in function_values]\n\n    def traverse(node, inputs):\n        if len(inputs) == 0:\n            return node\n        if node == \"1\":\n            return traverse(\"1\", inputs[1:])\n        if node == \"0\":\n            return traverse(\"0\", inputs[1:])\n        if node[0] == \"1\":\n            return traverse(node[1:], inputs[1:])\n        if node[0] == \"0\":\n            return traverse(node[1:], inputs[1:])\n\n    def count_nodes(node):\n        if node == \"1\" or node == \"0\":\n            return 1\n        return 1 + count_nodes(node[1:])\n\n    min_bdd = \"\"\n    for i in range(2**n):\n        inputs = format(i, f'0{n}b')\n        bdd = traverse(function_values[i], inputs)\n        if len(min_bdd) == 0 or count_nodes(min_bdd) > count_nodes(bdd):\n            min_bdd = bdd\n\n    return str(count_nodes(min_bdd))"
    },
    {
        "number": 2758,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_probability(color1, color2):\n        if color1 == \"Red\" or color2 == \"Red\":\n            return 0.9375, 0.0625\n        elif color1 == \"Lilac-Cream Tortie\" or color2 == \"Lilac-Cream Tortie\":\n            return 0.375, 0.25, 0.1875, 0.125, 0.0625\n        else:\n            return 0.5, 0.5\n\n    def get_color(color1, color2):\n        probabilities = get_probability(color1, color2)\n        colors = [\"Red\", \"Cream\", \"Blue-Cream Tortie\", \"Lilac\", \"Lilac-Cream Tortie\"]\n        result = []\n        for i in range(len(colors)):\n            result.append((colors[i], probabilities[i]))\n        result.sort(key=lambda x: (-x[1], x[0]))\n        return result\n\n    color1, color2 = stdin.split(\"\\n\")\n    return \"\\n\".join([f\"{color} {prob:.9f}\" for color, prob in get_color(color1, color2)])"
    },
    {
        "number": 2759,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    tanks = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n\n    def is_valid_move(tank, direction):\n        if direction == 'L':\n            return tank[1] > 1\n        elif direction == 'R':\n            return tank[1] < N\n        elif direction == 'U':\n            return tank[0] > 1\n        elif direction == 'D':\n            return tank[0] < N\n        return False\n\n    def get_neighbors(tank):\n        neighbors = []\n        if is_valid_move(tank, 'L'):\n            neighbors.append((tank[0], tank[1]-1))\n        if is_valid_move(tank, 'R'):\n            neighbors.append((tank[0], tank[1]+1))\n        if is_valid_move(tank, 'U'):\n            neighbors.append((tank[0]-1, tank[1]))\n        if is_valid_move(tank, 'D'):\n            neighbors.append((tank[0]+1, tank[1]))\n        return neighbors\n\n    def bfs(start, end):\n        queue = [(start, [])]\n        visited = set()\n        while queue:\n            current, path = queue.pop(0)\n            if current == end:\n                return path\n            visited.add(current)\n            for neighbor in get_neighbors(current):\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n        return None\n\n    def get_min_moves(tanks):\n        moves = []\n        for i in range(N):\n            tank = tanks[i]\n            for direction in ['L', 'R', 'U', 'D']:\n                if is_valid_move(tank, direction):\n                    new_tank = (tank[0] + direction_map[direction][0], tank[1] + direction_map[direction][1])\n                    if new_tank not in tanks:\n                        path = bfs(tank, new_tank)\n                        if path:\n                            moves.append((i+1, direction))\n                            tanks[i] = new_tank\n                            break\n        return moves\n\n    direction_map = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}\n    moves = get_min_moves(tanks)\n    output = [str(len(moves))]\n    for move in moves:\n        output.append(f\"{move[0]} {move[1]}\")\n    return '\\n'.join(output)"
    },
    {
        "number": 2760,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1:]))\n    swaps = []\n    \n    for i in range(n):\n        if i % 2 == 0:\n            swaps.append(n - i - 1)\n        else:\n            swaps.append(i)\n    \n    return '\\n'.join(map(str, swaps))"
    },
    {
        "number": 2761,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_collinear(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) ** 2) < 1e-5\n\n    max_perimeter = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                p1 = (float(lines[i].split()[0]), float(lines[i].split()[1]))\n                p2 = (float(lines[i].split()[2]), float(lines[i].split()[3]))\n                p3 = (float(lines[j].split()[0]), float(lines[j].split()[1]))\n                p4 = (float(lines[j].split()[2]), float(lines[j].split()[3]))\n                p5 = (float(lines[k].split()[0]), float(lines[k].split()[1]))\n                p6 = (float(lines[k].split()[2]), float(lines[k].split()[3]))\n\n                if is_collinear(p1, p2, p3) or is_collinear(p1, p2, p4) or is_collinear(p1, p2, p5) or is_collinear(p1, p2, p6) or is_collinear(p3, p4, p5) or is_collinear(p3, p4, p6) or is_collinear(p5, p6, p1) or is_collinear(p5, p6, p2) or is_collinear(p5, p6, p3) or is_collinear(p5, p6, p4):\n                    continue\n\n                perimeter = distance(p1, p2) + distance(p2, p3) + distance(p3, p1)\n                if perimeter > max_perimeter:\n                    max_perimeter = perimeter\n\n    if max_perimeter == 0:\n        return \"no triangle\"\n    else:\n        return str(max_perimeter)"
    },
    {
        "number": 2762,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, G, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def cost(i, j):\n        return min(sum((a[s] - v) ** k for s in range(i, j + 1)) for v in range(a[i]))\n\n    def divide_and_conquer(i, j):\n        if i == j:\n            return 0\n        mid = (i + j) // 2\n        return cost(i, mid) + cost(mid + 1, j) + divide_and_conquer(i, mid) + divide_and_conquer(mid + 1, j)\n\n    return str(divide_and_conquer(0, N - 1))"
    },
    {
        "number": 2763,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grille = stdin.split('\\n')[1:n+1]\n    message = stdin.split('\\n')[n+1]\n    \n    # Check if grille is valid\n    for i in range(n):\n        for j in range(n):\n            if grille[i][j] == 'X':\n                continue\n            else:\n                # Check if the current position can be used during encryption\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0 and j == n-1:\n                    continue\n                elif i == n-1 and j == 0:\n                    continue\n                elif i == n-1 and j == n-1:\n                    continue\n                else:\n                    # If any position is not valid, return \"invalid grille\"\n                    return \"invalid grille\"\n    \n    # Decrypt the message\n    decrypted_message = \"\"\n    for i in range(n):\n        for j in range(n):\n            if grille[i][j] == 'X':\n                continue\n            else:\n                decrypted_message += message[i*n+j]\n    \n    return decrypted_message"
    },
    {
        "number": 2764,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board, program = stdin.split('\\n')[:-1], stdin.split('\\n')[-1]\n    turtle_pos = (7, 0)\n    turtle_dir = 0\n    turtle_path = []\n\n    def move_turtle(direction: int) -> None:\n        nonlocal turtle_pos, turtle_path\n        if direction == 0:\n            turtle_pos = (turtle_pos[0] - 1, turtle_pos[1])\n        elif direction == 1:\n            turtle_pos = (turtle_pos[0], turtle_pos[1] + 1)\n        elif direction == 2:\n            turtle_pos = (turtle_pos[0] + 1, turtle_pos[1])\n        elif direction == 3:\n            turtle_pos = (turtle_pos[0], turtle_pos[1] - 1)\n        turtle_path.append(turtle_pos)\n\n    def turn_turtle(direction: int) -> None:\n        nonlocal turtle_dir\n        turtle_dir = (turtle_dir + direction) % 4\n\n    def fire_laser() -> None:\n        nonlocal turtle_pos, turtle_path\n        if turtle_pos[0] < 0 or turtle_pos[0] > 7 or turtle_pos[1] < 0 or turtle_pos[1] > 7:\n            raise Exception(\"Program error: Laser outside the board\")\n        if board[turtle_pos[0]][turtle_pos[1]] == 'I':\n            board[turtle_pos[0]][turtle_pos[1]] = '.'\n        else:\n            raise Exception(\"Program error: Laser at empty square or rock castle\")\n\n    for instruction in program:\n        if instruction == 'F':\n            move_turtle(turtle_dir)\n        elif instruction == 'R':\n            turn_turtle(1)\n        elif instruction == 'L':\n            turn_turtle(3)\n        elif instruction == 'X':\n            fire_laser()\n\n    if turtle_pos == (7, 7):\n        return \"Diamond!\"\n    else:\n        return \"Bug!\""
    },
    {
        "number": 2765,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    coins = list(map(int, stdin.split('\\n')[1].split()))\n    coins.sort(reverse=True)\n\n    if coins[0] == 1:\n        return \"canonical\"\n\n    for i in range(1, n):\n        if coins[i] * (n - i) < coins[0] * i:\n            return \"non-canonical\"\n\n    return \"canonical\""
    },
    {
        "number": 2766,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    prob_win = 1 - p\n    prob_lose = p\n    prob_draw = 0\n\n    for i in range(1, n):\n        prob_draw += (prob_win ** i) * (prob_lose ** (n - i))\n\n    return str(prob_draw)"
    },
    {
        "number": 2767,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(\"\\n\")\n    words = words[1:]\n    test_sentences = set()\n\n    for word1 in words:\n        for word2 in words:\n            for word3 in words:\n                sentence = \" \".join([word1, word2, word3])\n                test_sentences.add(sentence)\n\n    count = 0\n    for sentence in test_sentences:\n        if set(sentence) == set(\"abcdefghijklmnopqrstuvwxyz\"):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2768,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    cubes = {}\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            R, C = map(int, line.split())\n            cubes[(R, C)] = True\n\n    def is_rectangle(rect: set) -> bool:\n        for i in range(N):\n            for j in range(N):\n                if (i + 1, j + 1) not in rect and (i + 1, j) not in rect and (i, j + 1) not in rect:\n                    return False\n        return True\n\n    def move_cube(cube: tuple, new_cube: tuple) -> None:\n        cubes[new_cube] = True\n        del cubes[cube]\n\n    def get_neighbors(cube: tuple) -> list:\n        R, C = cube\n        neighbors = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i != 0 or j != 0:\n                    new_cube = (R + i, C + j)\n                    if new_cube in cubes:\n                        neighbors.append(new_cube)\n        return neighbors\n\n    def bfs(start: tuple) -> int:\n        visited = {start}\n        queue = [start]\n        distance = 0\n\n        while queue:\n            next_level = []\n            for cube in queue:\n                for neighbor in get_neighbors(cube):\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        next_level.append(neighbor)\n            distance += 1\n            queue = next_level\n\n        return distance - 1\n\n    min_distance = float('inf')\n    for cube in cubes:\n        rect = set(cubes)\n        rect.remove(cube)\n        while not is_rectangle(rect):\n            move_cube(cube, get_neighbors(cube)[0])\n            rect = set(cubes)\n            rect.remove(cube)\n        distance = bfs(cube)\n        if distance < min_distance:\n            min_distance = distance\n\n    return str(min_distance)"
    },
    {
        "number": 2769,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, s = map(int, stdin.split()[:4])\n    p_difficulties = list(map(int, stdin.split()[4:4+p]))\n    q_difficulties = list(map(int, stdin.split()[4+p:]))\n    \n    p_difficulties.sort()\n    q_difficulties.sort()\n    \n    min_d = float('inf')\n    for i in range(n):\n        p_index = i % len(p_difficulties)\n        q_index = i % len(q_difficulties)\n        \n        p_difficulty = p_difficulties[p_index]\n        q_difficulty = q_difficulties[q_index]\n        \n        d = abs(p_difficulty - q_difficulty)\n        min_d = min(min_d, d)\n        \n        if p_difficulty + q_difficulty > s:\n            return -1\n    \n    return str(min_d)"
    },
    {
        "number": 2770,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    x = list(map(int, lines[2].split()))\n    Q = int(lines[3])\n    queries = []\n    for i in range(Q):\n        T, M = map(int, lines[4+i].split())\n        queries.append((T, M))\n    \n    for i in range(N):\n        x.append(0)\n        for j in range(N):\n            x[i+j+1] += a[j] * x[i+j]\n    \n    result = []\n    for T, M in queries:\n        result.append(str(x[T] % M))\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 2771,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    directions = stdin.split('\\n')[1]\n    houses = [i for i in range(1, n+1)]\n    visited = []\n    current_house = houses[0]\n    for direction in directions:\n        if direction == 'L':\n            next_house = houses[houses.index(current_house)-1]\n        else:\n            next_house = houses[houses.index(current_house)+1]\n        visited.append(current_house)\n        current_house = next_house\n    return ' '.join(map(str, visited))"
    },
    {
        "number": 2772,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(int, stdin.split()[0:2])\n    ascent = []\n    descent = []\n\n    for i in range(a):\n        h, t = map(int, stdin.split()[2:4])\n        ascent.append((h, t))\n\n    for i in range(d):\n        h, t = map(int, stdin.split()[2:4])\n        descent.append((h, t))\n\n    ascent_time = sum([t for h, t in ascent])\n    descent_time = sum([t for h, t in descent])\n\n    ascent_elevation = sum([h for h, t in ascent])\n    descent_elevation = sum([h for h, t in descent])\n\n    if ascent_elevation != descent_elevation:\n        return \"0.000000\"\n\n    ascent_time_sum = 0\n    descent_time_sum = 0\n\n    for i in range(a):\n        h, t = ascent[i]\n        ascent_time_sum += t\n        if ascent_time_sum >= descent_time_sum:\n            return str(ascent_time_sum / 24)\n\n    for i in range(d):\n        h, t = descent[i]\n        descent_time_sum += t\n        if ascent_time_sum >= descent_time_sum:\n            return str(ascent_time_sum / 24)"
    },
    {
        "number": 2773,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    graph = [[0] * n for _ in range(n)]\n    for a, b, d in roads:\n        graph[a][b] = graph[b][a] = d\n\n    def dfs(start: int, end: int, visited: set, path: list) -> bool:\n        if start == end:\n            return True\n        visited.add(start)\n        for i in range(n):\n            if i not in visited and graph[start][i] > 0:\n                path.append(i)\n                if dfs(i, end, visited, path):\n                    return True\n                path.pop()\n        visited.remove(start)\n        return False\n\n    for i in range(n):\n        if i != 0:\n            path = [0, i]\n            if dfs(0, i, set(), path):\n                return \" \".join(map(str, path))\n    return \"impossible\""
    },
    {
        "number": 2774,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    N, S = map(int, lines[0].split())\n    trails = []\n    for line in lines[1:-2]:\n        a, b, d = map(int, line.split())\n        trails.append((a, b, d))\n    lamps = set(map(int, lines[-1].split()))\n    # Sort trails by length\n    trails.sort(key=lambda x: x[2])\n    # Initialize graph\n    graph = {i: set() for i in range(1, N+1)}\n    for a, b, d in trails:\n        graph[a].add((b, d))\n        graph[b].add((a, d))\n    # Dijkstra's algorithm\n    dist = [float('inf')] * (N+1)\n    dist[1] = 0\n    q = [(0, 1)]\n    while q:\n        d, node = heapq.heappop(q)\n        if d > dist[node]:\n            continue\n        for neighbor, length in graph[node]:\n            if dist[node] + length < dist[neighbor]:\n                dist[neighbor] = dist[node] + length\n                heapq.heappush(q, (dist[neighbor], neighbor))\n    # Check if all trails are reachable from the university\n    for i in range(2, N+1):\n        if dist[i] == float('inf'):\n            return 'IMPOSSIBLE'\n    # Check if all trails are reachable from the lamps\n    for lamp in lamps:\n        if dist[lamp] == float('inf'):\n            return 'IMPOSSIBLE'\n    # Calculate the minimum number of additional lamps\n    min_lamp = float('inf')\n    for i in range(2, N+1):\n        if dist[i] > S:\n            min_lamp = min(min_lamp, dist[i] - S)\n    return str(min_lamp)"
    },
    {
        "number": 2775,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, house, work, errands = stdin.split(\"\\n\")\n    n = int(n)\n    house = tuple(map(int, house.split()))\n    work = tuple(map(int, work.split()))\n    errands = [tuple(map(int, errand.split())) for errand in errands.split(\"\\n\")]\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_on_route(a, b, c):\n        return min(distance(a, b), distance(a, c)) == distance(a, b)\n\n    count = 0\n    for errand in errands:\n        if is_on_route(house, work, errand):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2776,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    prohibited = set()\n    for _ in range(M):\n        a, b = map(int, stdin.split()[-2:])\n        prohibited.add((min(a, b), max(a, b)))\n\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if (i, j) not in prohibited and (j, i) not in prohibited:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2777,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def bitwise_xor(x: int, y: int) -> int:\n        return xor(x, y)\n\n    def find_p(x: int, y: int) -> int:\n        p = 0\n        for i in range(n):\n            if bitwise_xor(x[i], y) > bitwise_xor(x[p], y):\n                p = i\n        return p\n\n    def count_sequences(p: List[int]) -> int:\n        sequences = []\n        for i in range(n):\n            sequences.append([i])\n\n        for y in range(1, 2 ** m):\n            p_y = p[y - 1]\n            new_sequences = []\n            for sequence in sequences:\n                for i in range(n):\n                    if i != p_y:\n                        new_sequence = sequence.copy()\n                        new_sequence.append(i)\n                        new_sequences.append(new_sequence)\n            sequences = new_sequences\n\n        return len(sequences)\n\n    lines = stdin.split(\"\\n\")\n    m, n = map(int, lines[0].split())\n    p = [int(line) for line in lines[1:]]\n\n    result = count_sequences(p)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 2778,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, T = map(int, stdin.split())\n    mod = 1000000009\n    dp = [1] * (T + 1)\n    \n    for i in range(N):\n        new_dp = [0] * (T + 1)\n        for j in range(K):\n            for t in range(T, -1, -1):\n                if t - j >= 0:\n                    new_dp[t] += dp[t - j]\n                    new_dp[t] %= mod\n        dp = new_dp\n    \n    return str(dp[T])"
    },
    {
        "number": 2779,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c = map(int, stdin.split()[:3])\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    terrain_costs = list(map(int, stdin.split('\\n')[n+1].split()))\n\n    def is_valid_cell(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m and grid[x][y] != '.'\n\n    def get_neighbors(x: int, y: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid_cell(nx, ny):\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def get_min_cost(x: int, y: int, visited: Set[Tuple[int, int]]) -> int:\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        if grid[x][y] == 'B':\n            return float('inf')\n        min_cost = 0\n        for nx, ny in get_neighbors(x, y):\n            min_cost = min(min_cost, get_min_cost(nx, ny, visited))\n        return min_cost + terrain_costs[ord(grid[x][y]) - ord('a')]\n\n    min_cost = float('inf')\n    for x in range(n):\n        for y in range(m):\n            if grid[x][y] == 'B':\n                visited = set()\n                min_cost = min(min_cost, get_min_cost(x, y, visited))\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 2780,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    probabilities = [1 / M] * M\n    \n    for i in range(1, M):\n        probabilities[i] = probabilities[i-1] * (N - i + 1) / N\n    \n    return '\\n'.join(f\"{p:.5f}\" for p in probabilities)"
    },
    {
        "number": 2781,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split())\n    grid = [list(map(int, input().split())) for _ in range(r)]\n    max_depth = 0\n\n    for i in range(r):\n        for j in range(c):\n            depth = grid[i][j]\n            if depth > max_depth:\n                max_depth = depth\n\n    return str(max_depth)"
    },
    {
        "number": 2782,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, c = map(int, stdin.split()[:3])\n    seats = [[False] * c for _ in range(r)]\n    max_passengers = 0\n\n    for line in stdin.split('\\n')[1:]:\n        if not line:\n            continue\n        a, b, s = map(int, line.split())\n        if not seats[a - 1][b - 1]:\n            seats[a - 1][b - 1] = True\n            max_passengers += 1\n\n    return str(max_passengers)"
    },
    {
        "number": 2783,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sweat_rate(time: int) -> float:\n        return r0 * time ** 2\n\n    def total_sweat(path: List[Tuple[int, int]]) -> float:\n        total = 0\n        time = 0\n        for i in range(len(path)):\n            if i > 0:\n                time += abs(path[i][0] - path[i - 1][0]) + abs(path[i][1] - path[i - 1][1])\n            total += sweat_rate(time)\n        return total\n\n    def find_best_path(shady_spots: List[Tuple[int, int]], dormitory: Tuple[int, int], classroom: Tuple[int, int]) -> str:\n        n = len(shady_spots)\n        paths = []\n        for i in range(2 ** n):\n            path = []\n            for j in range(n):\n                if (i >> j) & 1:\n                    path.append(shady_spots[j])\n            path.append(dormitory)\n            path.append(classroom)\n            paths.append(path)\n\n        best_path = min(paths, key=total_sweat)\n        return \" \".join(str(paths.index(best_path)) for _ in range(len(best_path) - 1))\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    shady_spots = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n    dormitory = tuple(map(int, lines[n + 1].split()))\n    classroom = tuple(map(int, lines[n + 2].split()))\n\n    return find_best_path(shady_spots, dormitory, classroom)"
    },
    {
        "number": 2784,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.split(\"\\n\")\n    num_fragments = int(lines[0])\n    fragments = {}\n    for i in range(1, num_fragments + 1):\n        station, connections = lines[i].split(\" \")\n        fragments[station] = connections.split(\" \")\n\n    # Find the starting and destination stations\n    start_station, dest_station = lines[-1].split(\" \")\n\n    # Initialize the visited set and the queue\n    visited = set()\n    queue = [(start_station, [start_station])]\n\n    # BFS to find the shortest path\n    while queue:\n        curr_station, path = queue.pop(0)\n        if curr_station == dest_station:\n            return \" \".join(path)\n        if curr_station not in visited:\n            visited.add(curr_station)\n            for next_station in fragments[curr_station]:\n                if next_station not in visited:\n                    queue.append((next_station, path + [next_station]))\n\n    # If no path is found, return \"no route found\"\n    return \"no route found\""
    },
    {
        "number": 2785,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    investments = []\n\n    for _ in range(n):\n        p, c = map(int, input().split())\n        investments.append((p, c))\n\n    investments.sort(key=lambda x: x[0] / x[1], reverse=True)\n\n    total_cost = sum(c for _, c in investments)\n    total_profit = sum(p * c for p, c in investments)\n\n    if total_profit < M:\n        return \"IMPOSSIBLE\"\n\n    days = 0\n    current_profit = 0\n    current_cost = 0\n\n    for p, c in investments:\n        days_needed = (M - current_profit) / p\n        if days_needed <= 0:\n            return \"IMPOSSIBLE\"\n\n        if current_cost + c > total_cost:\n            days_needed = (M - current_profit) / (p - (total_profit - current_profit) / (total_cost - current_cost))\n            if days_needed <= 0:\n                return \"IMPOSSIBLE\"\n\n        days += int(days_needed)\n        current_profit += int(days_needed * p)\n        current_cost += c\n\n    return str(days)"
    },
    {
        "number": 2786,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_regular(bracket_sequence: str) -> bool:\n        stack = []\n        for bracket in bracket_sequence:\n            if bracket == '(':\n                stack.append('(')\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n            elif bracket == '[':\n                stack.append('[')\n            elif bracket == ']':\n                if not stack or stack.pop() != '[':\n                    return False\n            elif bracket == '{':\n                stack.append('{')\n            elif bracket == '}':\n                if not stack or stack.pop() != '{':\n                    return False\n        return not stack\n\n    def count_regular_sequences(bracket_sequence: str) -> int:\n        count = 0\n        for i in range(len(bracket_sequence)):\n            if bracket_sequence[i] == '?':\n                for bracket in ['(', ')', '[', ']', '{', '}']:\n                    new_sequence = bracket_sequence[:i] + bracket + bracket_sequence[i+1:]\n                    if is_regular(new_sequence):\n                        count += 1\n        return count\n\n    n = int(stdin.readline().strip())\n    bracket_sequence = stdin.readline().strip()\n    return str(count_regular_sequences(bracket_sequence) % 100000)"
    },
    {
        "number": 2787,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(lat1, lon1, lat2, lon2):\n        R = 6381\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n        c = 2 * atan2(sqrt(a), sqrt(1-a))\n        return R * c\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N, M = map(int, lines[0].split())\n        S, T = lines[1].split()\n        airports = {}\n        for i in range(2, N+2):\n            code, lat, lon = lines[i].split()\n            airports[code] = (float(lat), float(lon))\n        routes = []\n        for i in range(N+2, N+2+M):\n            a, b = lines[i].split()\n            routes.append((a, b))\n        return N, M, S, T, airports, routes\n\n    def find_route(S, T, airports, routes):\n        visited = set()\n        queue = [(0, S)]\n        while queue:\n            dist, airport = queue.pop(0)\n            if airport == T:\n                return dist\n            if airport not in visited:\n                visited.add(airport)\n                for a, b in routes:\n                    if a == airport:\n                        queue.append((dist + distance(*airports[a], *airports[b]) + 100, b))\n                    elif b == airport:\n                        queue.append((dist + distance(*airports[a], *airports[b]) + 100, a))\n        return -1\n\n    N, M, S, T, airports, routes = read_input(stdin)\n    return str(find_route(S, T, airports, routes))"
    },
    {
        "number": 2788,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, groups, k, x, a, b = map(int, stdin.split())\n    groups.sort(reverse=True)\n    total_lunches = sum(groups)\n    max_students = 0\n\n    for i in range(min(k, total_lunches // x) + 1):\n        if i * x >= total_lunches:\n            break\n        students_in_lunch = i * x\n        students_in_watch = min(students_in_lunch, b)\n        students_in_groups = sum(groups[:students_in_lunch])\n        students_in_watch_groups = sum(groups[:students_in_watch])\n\n        if students_in_groups <= a and students_in_watch_groups <= a:\n            max_students = max(max_students, students_in_groups)\n\n    return max_students if max_students > 0 else \"impossible\""
    },
    {
        "number": 2789,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)"
    },
    {
        "number": 2790,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, knapsacks = stdin.split()\n    n = int(n)\n    s = int(s)\n    t = int(t)\n    knapsacks = list(map(int, knapsacks.split()))\n\n    min_time = float('inf')\n    max_time = float('-inf')\n    total_time = 0\n\n    for i in range(s):\n        time = t * n\n        min_time = min(min_time, time)\n        max_time = max(max_time, time)\n        total_time += time\n\n    average_time = total_time / s\n    p, q = find_reduced_fraction(average_time)\n\n    return f\"{min_time}\\n{max_time}\\n{p}/{q}\\n\"\n\ndef"
    },
    {
        "number": 2791,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] // d == a[j] // d:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 2792,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    Q = int(input_lines[0])\n    input_lines = input_lines[1:]\n    output = []\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    reverse_alphabet = \"zyxwvutsrqponmlkjihgfedcba\"\n    current_alphabet = alphabet\n    for line in input_lines:\n        if line.startswith(\"SMJER\"):\n            n = int(line.split()[1])\n            current_alphabet = reverse_alphabet[n-1:] + current_alphabet[:n-1]\n        else:\n            n, x = map(int, line.split()[1:])\n            count = current_alphabet[:n].count(x)\n            output.append(str(count))\n    return \"\\n\".join(output)"
    },
    {
        "number": 2793,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor, weight in edges:\n            if not visited[neighbor] and neighbor != parent:\n                dfs(neighbor, visited, node)\n\n    def min_cut(s, t):\n        visited = [False] * n\n        dfs(s, visited, -1)\n        if not visited[t]:\n            return []\n\n        visited = [False] * n\n        cut_edges = []\n        dfs(t, visited, -1)\n        for u, v, w in edges:\n            if visited[u] and not visited[v]:\n                cut_edges.append((u, v, w))\n        return cut_edges\n\n    cut_edges = min_cut(s, t)\n    if not cut_edges:\n        return \"0\\n\"\n\n    U = set()\n    for u, v, w in cut_edges:\n        if u not in U:\n            U.add(u)\n        if v in U:\n            U.remove(v)\n\n    return f\"{len(U)}\\n{' '.join(map(str, sorted(U)))}\""
    },
    {
        "number": 2794,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, c = map(int, stdin.split()[:2])\n    coworkers = []\n    for _ in range(c):\n        a, d = map(int, stdin.split()[2:])\n        coworkers.append((a, d))\n\n    max_annoyance = 0\n    for i in range(1, h + 1):\n        current_annoyance = 0\n        for coworker in coworkers:\n            current_annoyance += coworker[0] + (i - 1) * coworker[1]\n        max_annoyance = max(max_annoyance, current_annoyance)\n\n    return str(max_annoyance)"
    },
    {
        "number": 2795,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e, p = map(int, stdin.readline().split())\n    treehouses = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().split())\n        treehouses.append((x, y))\n\n    cables = set()\n    for _ in range(p):\n        a, b = map(int, stdin.readline().split())\n        cables.add((a, b))\n\n    def distance(a: int, b: int) -> float:\n        return ((treehouses[a][0] - treehouses[b][0]) ** 2 + (treehouses[a][1] - treehouses[b][1]) ** 2) ** 0.5\n\n    def cable_length(a: int, b: int) -> float:\n        return distance(a, b)\n\n    def total_cable_length(cables: set) -> float:\n        return sum(cable_length(a, b) for a, b in cables)\n\n    def add_cable(a: int, b: int) -> set:\n        return cables.union({(a, b)})\n\n    def min_cable_length(cables: set, e: int) -> float:\n        if len(cables) == n - 1:\n            return total_cable_length(cables)\n\n        min_length = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (i, j) not in cables and (j, i) not in cables:\n                    new_cables = add_cable(i, j)\n                    if len(new_cables) == e:\n                        min_length = min(min_length, total_cable_length(new_cables))\n                    else:\n                        min_length = min(min_length, min_cable_length(new_cables, e))\n\n        return min_length\n\n    return str(min_cable_length(cables, e))"
    },
    {
        "number": 2796,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def is_boring(a: int, b: int, paths: List[Tuple[int, int, int]]) -> bool:\n        if a == b:\n            return False\n        for path in paths:\n            if path[0] == a and path[1] == b or path[0] == b and path[1] == a:\n                return xor(path[2], paths[0][2]) == 0\n        return False\n\n    def count_boring_pairs(paths: List[Tuple[int, int, int]], destroyed_paths: List[int]) -> int:\n        pairs_count = 0\n        for i in range(1, len(paths) + 1):\n            for j in range(i + 1, len(paths) + 1):\n                if (i, j) not in destroyed_paths and is_boring(i, j, paths):\n                    pairs_count += 1\n        return pairs_count\n\n    n, paths, destroyed_paths = stdin.split(\"\\n\")\n    n = int(n)\n    paths = [tuple(map(int, line.split())) for line in paths.split(\"\\n\")]\n    destroyed_paths = list(map(int, destroyed_paths.split()))\n\n    result = []\n    for i in range(1, len(destroyed_paths) + 1):\n        result.append(count_boring_pairs(paths, destroyed_paths[:i]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2797,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    result = 0\n    for i in range(1, a+1):\n        result += pow(i, b, a)\n    return str(result % a)"
    },
    {
        "number": 2798,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    player, *cuboids = stdin.split()\n    cuboids = [list(map(int, cuboid.split())) for cuboid in cuboids]\n\n    def cut_cuboid(cuboid: list, x: int, y: int, z: int) -> list:\n        x_cut = [cuboid[0], x] if cuboid[0] != x else [cuboid[0]]\n        y_cut = [cuboid[1], y] if cuboid[1] != y else [cuboid[1]]\n        z_cut = [cuboid[2], z] if cuboid[2] != z else [cuboid[2]]\n        return [x_cut, y_cut, z_cut]\n\n    def remove_cuboid(cuboids: list, x: int, y: int, z: int) -> list:\n        new_cuboids = []\n        for cuboid in cuboids:\n            cut_cuboids = cut_cuboid(cuboid, x, y, z)\n            for cut_cuboid in cut_cuboids:\n                if cut_cuboid[0] != cut_cuboid[1]:\n                    new_cuboids.append(cut_cuboid)\n        return new_cuboids\n\n    if player == \"RUBEN\":\n        ruben_cuboids = cuboids\n        albert_cuboids = []\n    else:\n        ruben_cuboids = []\n        albert_cuboids = cuboids\n\n    while ruben_cuboids and albert_cuboids:\n        ruben_cuboids = remove_cuboid(ruben_cuboids, 1, 1, 1)\n        albert_cuboids = remove_cuboid(albert_cuboids, 1, 1, 1)\n\n    if ruben_cuboids:\n        return \"RUBEN\"\n    else:\n        return \"ALBERT\""
    },
    {
        "number": 2799,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B, Y, S = map(int, stdin.split())\n    total_fruits = R + G + B + Y\n    total_steps = 6 * S\n    total_turns = total_fruits + total_steps\n\n    # Calculate the probability of the raven reaching the orchard\n    raven_prob = 0.1 * S\n\n    # Calculate the probability of the players winning\n    players_win_prob = 1 - raven_prob\n\n    # Calculate the probability of the players winning in each turn\n    turn_prob = 1 / total_turns\n\n    # Calculate the probability of the players winning in each fruit pick\n    fruit_prob = 1 / total_fruits\n\n    # Calculate the probability of the players winning in each step\n    step_prob = 1 / total_steps\n\n    # Calculate the probability of the players winning in each turn\n    players_win_turn_prob = (1 - raven_prob) * turn_prob\n\n    # Calculate the probability of the players winning in each fruit pick\n    players_win_fruit_prob = (1 - raven_prob) * fruit_prob\n\n    # Calculate the probability of the players winning in each step\n    players_win_step_prob = (1 - raven_prob) * step_prob\n\n    # Calculate the probability of the players winning the game\n    players_win_game_prob = players_win_turn_prob * (total_fruits + total_steps - 1)\n\n    return round(players_win_game_prob, 10)"
    },
    {
        "number": 2800,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    piles, max_cards_to_remove = map(int, stdin.split()[0:2])\n    piles_info = stdin.split('\\n')[1:]\n\n    def get_card_value(card_value: str) -> int:\n        return int(card_value)\n\n    def get_pile_info(pile_info: str) -> List[int]:\n        return list(map(get_card_value, pile_info.split()[1:]))\n\n    def can_remove_cards(pile: List[int], num_cards_to_remove: int) -> bool:\n        return num_cards_to_remove <= len(pile)\n\n    def remove_cards(pile: List[int], num_cards_to_remove: int) -> List[int]:\n        return pile[num_cards_to_remove:]\n\n    def get_next_player_move(pile: List[int], num_cards_to_remove: int) -> Tuple[int, int]:\n        next_card_value = pile[0]\n        num_cards_to_remove_next = next_card_value\n        return num_cards_to_remove_next, next_card_value\n\n    def get_winner(piles: List[List[int]]) -> str:\n        for i in range(len(piles)):\n            pile = piles[i]\n            num_cards_to_remove = 0\n            while can_remove_cards(pile, num_cards_to_remove):\n                num_cards_to_remove_next, next_card_value = get_next_player_move(pile, num_cards_to_remove)\n                pile = remove_cards(pile, num_cards_to_remove_next)\n                num_cards_to_remove = num_cards_to_remove_next\n            if num_cards_to_remove > 0:\n                return \"Bob will win.\"\n        return \"Alice can win.\"\n\n    piles_info = list(map(get_pile_info, piles_info))\n    return get_winner(piles_info)"
    },
    {
        "number": 2801,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    c = list(map(int, stdin.split()[2:2+n]))\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        s, t = map(int, stdin.split()[2+n:])\n        graph[s].append(t)\n\n    def dfs(node: int, visited: set, satisfaction: float) -> float:\n        if node in visited:\n            return satisfaction\n        visited.add(node)\n        for neighbor in graph[node]:\n            satisfaction += dfs(neighbor, visited, satisfaction)\n        return satisfaction\n\n    max_satisfaction = 0\n    for i in range(n):\n        max_satisfaction = max(max_satisfaction, dfs(i, set(), c[i] / 2 ** (n - 1)))\n\n    return str(max_satisfaction)"
    },
    {
        "number": 2802,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    times = list(map(float, stdin.split()))\n    target_score = float(input())\n    times.sort()\n    total_score = sum(times[:3])\n    worst_time = times[3]\n    if total_score <= target_score:\n        return \"infinite\"\n    else:\n        return f\"{worst_time:.2f}\""
    },
    {
        "number": 2803,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    previous_animal, n = stdin.split('\\n')\n    n = int(n)\n    unused_animals = stdin.split('\\n')[2:]\n\n    for animal in unused_animals:\n        if animal[0] == previous_animal[-1] and animal not in unused_animals[:unused_animals.index(animal)]:\n            return animal + '!'\n\n    if n > 0:\n        return unused_animals[0]\n    else:\n        return '?'"
    },
    {
        "number": 2804,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    words = []\n    while len(words) < B:\n        word = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 15)))\n        words.append(word)\n    return ' '.join(random.sample(words, B))\n\nimport random\nimport string\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 2805,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    counter = 0\n    for i in range(N-1, 0, -1):\n        counter += 1\n        if N % i == 0:\n            break\n    return str(counter)"
    },
    {
        "number": 2806,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, t = map(int, stdin.split()[:2])\n    tunnels = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n    \n    # Create a graph with chambers as nodes and tunnels as edges\n    graph = {i: set() for i in range(1, c+1)}\n    for a, b in tunnels:\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    # Find a path that visits each chamber exactly once\n    visited = set()\n    path = []\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n    dfs(1)\n    \n    # Divide the remaining chambers evenly between the two mole kids\n    s = (c - len(path)) // 2\n    kids = [set(range(1, c+1)) - set(path) for _ in range(2)]\n    for i in range(s):\n        for kid in kids:\n            kid.difference_update(path)\n            if not kid:\n                return \"No valid solution\"\n    \n    # Output the results\n    return f\"{len(path)} {s}\\n{' '.join(map(str, path))}\\n{' '.join(map(str, kids[0]))}\\n{' '.join(map(str, kids[1]))}\" "
    },
    {
        "number": 2807,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split()\n    n = len(A)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if A[i:j] == B[i:j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2808,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:3+n]))\n    carts = []\n    for i in range(m):\n        l, r = map(int, stdin.split()[3+n+i*2:3+n+i*2+2])\n        carts.append((l, r))\n\n    def is_happy(car: int, carts: list) -> bool:\n        for cart in carts:\n            if car >= cart[0] and car <= cart[1]:\n                return True\n        return False\n\n    def count_happy(carts: list) -> int:\n        count = 0\n        for car in range(1, n+1):\n            if is_happy(car, carts):\n                count += p[car-1]\n        return count\n\n    def count_plans(carts: list) -> int:\n        count = 0\n        for i in range(1, len(carts)+1):\n            for j in range(1, len(carts)+1):\n                if i != j:\n                    count += count_happy(carts[:i-1] + carts[j-1:])\n        return count\n\n    return str(count_plans(carts) % (10**9 + 7))"
    },
    {
        "number": 2809,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    s = stdin.split()[1]\n    R = int(s * k, 2)\n    count = 0\n    for i in range(1, R):\n        for j in range(i + 1, R):\n            if i ^ j == 0:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2810,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_simple_loops(connections: List[Tuple[int, int]]) -> List[List[int]]:\n        simple_loops = []\n        for i in range(len(connections)):\n            for j in range(i + 1, len(connections)):\n                s1, t1 = connections[i]\n                s2, t2 = connections[j]\n                if s1 == t2 and t1 == s2:\n                    loop = [s1, t1, s2, t2]\n                    loop.sort()\n                    if loop not in simple_loops:\n                        simple_loops.append(loop)\n        return simple_loops\n\n    def count_simple_loops(simple_loops: List[List[int]]) -> int:\n        return len(simple_loops)\n\n    lines = stdin.split(\"\\n\")\n    m = int(lines[0])\n    connections = []\n    for line in lines[1:]:\n        if line:\n            s, t = map(int, line.split())\n            connections.append((s, t))\n\n    simple_loops = find_simple_loops(connections)\n    count = count_simple_loops(simple_loops)\n    return str(count)"
    },
    {
        "number": 2811,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    parent = [0] * (n + 1)\n    red = set()\n    for i in range(2, n + 1):\n        parent[i] = int(stdin.split()[i - 2])\n    for i in range(n + 1, n + 1 + m):\n        red.add(int(stdin.split()[i - 2]))\n\n    def dfs(node: int, parent: int) -> int:\n        count = 1\n        for child in range(2, n + 1):\n            if parent[child] == node:\n                count += dfs(child, parent)\n        return count\n\n    def count_subsets(node: int, parent: int, red: set, k: int) -> int:\n        if node == 1:\n            return 0\n        count = 0\n        for child in range(2, n + 1):\n            if parent[child] == node:\n                if child in red:\n                    count += count_subsets(child, parent, red, k - 1)\n                else:\n                    count += count_subsets(child, parent, red, k)\n        return count\n\n    result = []\n    for k in range(m + 1):\n        result.append(count_subsets(1, parent, red, k) % (10**9 + 7))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2812,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    result = \"\"\n    for i in range(1, 27):\n        for j in range(1, 27):\n            for l in range(1, 27):\n                value = abs(i - k) + abs(k - j) + abs(j - l)\n                if value == k:\n                    result = chr(i + 96) + chr(j + 96) + chr(l + 96)\n                    return result"
    },
    {
        "number": 2813,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    syllables, poem = stdin.split(\"\\n\", 1)\n    syllables = syllables.split()\n    poem = poem.split(\"\\n\")\n\n    def is_haiku(line: str) -> bool:\n        words = line.split()\n        syllable_count = 0\n        for word in words:\n            syllable_count += len(word)\n        return syllable_count == 5 or syllable_count == 7 or syllable_count == 5\n\n    for line in poem:\n        if not is_haiku(line):\n            return \"come back next year\"\n\n    return \"haiku\""
    },
    {
        "number": 2814,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    sigma_0 = list(map(int, stdin.splitlines()[1].split()))\n    sigma_1 = list(map(int, stdin.splitlines()[2].split()))\n\n    revealed_cards = [False] * (2 * N)\n    player_0_cards = []\n    player_1_cards = []\n\n    for i in range(2 * N):\n        if sigma_0[i] not in player_0_cards and sigma_1[i] not in player_1_cards:\n            if i % 2 == 0:\n                player_0_cards.append(sigma_0[i])\n            else:\n                player_1_cards.append(sigma_1[i])\n\n    if len(player_0_cards) > len(player_1_cards):\n        return \"0\"\n    elif len(player_0_cards) < len(player_1_cards):\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 2815,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 2816,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')\n    V_pos = None\n    J_pos = None\n    trees = []\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'V':\n                V_pos = (i, j)\n            elif grid[i][j] == 'J':\n                J_pos = (i, j)\n            elif grid[i][j] == '+':\n                trees.append((i, j))\n\n    def distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def find_best_route(V_pos, J_pos, trees):\n        best_distance = float('inf')\n        for tree in trees:\n            best_distance = min(best_distance, distance(V_pos, tree))\n\n        return best_distance\n\n    return str(find_best_route(V_pos, J_pos, trees))"
    },
    {
        "number": 2817,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    e, e_success, e_failure = map(int, stdin.split())\n    s = 25  # minimum weight that can be lifted\n    d = 0\n    while e > 0:\n        if e >= s:\n            e -= e_success\n            s += 1\n        else:\n            e -= e_failure\n            s += 1\n        d = s - 225  # maximum weight that can be lifted\n    return str(d)"
    },
    {
        "number": 2818,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = stdin.split()\n    H = list(map(int, H.split()))\n    H.sort()\n    arrows = 0\n    height = 1\n\n    for i in range(N):\n        if H[i] > height:\n            arrows += H[i] - height\n            height = H[i]\n        elif H[i] < height:\n            arrows += 1\n        else:\n            continue\n\n    return str(arrows)"
    },
    {
        "number": 2819,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, valid_moves = map(int, stdin.splitlines()[0].split())\n    alice_pos = tuple(map(int, stdin.splitlines()[1].split()))\n    bob_pos = tuple(map(int, stdin.splitlines()[2].split()))\n    valid_moves = [tuple(map(int, line.split())) for line in stdin.splitlines()[3:]]\n\n    def is_valid_move(move, pos):\n        return 0 <= pos[0] + move[0] < n and 0 <= pos[1] + move[1] < n\n\n    def is_capture(move, pos):\n        return is_valid_move(move, pos) and (pos[0] + move[0], pos[1] + move[1]) != bob_pos\n\n    def is_teleport(move, pos):\n        return is_valid_move(move, pos) and (pos[0] + move[0], pos[1] + move[1]) != alice_pos\n\n    if any(is_capture(move, bob_pos) for move in valid_moves):\n        return \"Alice wins\"\n\n    if any(is_teleport(move, alice_pos) and not any(is_capture(move, bob_pos) for move in valid_moves) for move in valid_moves):\n        return \"tie\" + \" \" + \" \".join(map(str, alice_pos))\n\n    return \"Bob wins\""
    },
    {
        "number": 2820,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.splitlines()\n    B, V = map(int, lines[0].split())\n    V = list(map(int, lines[1].split()))\n    T = int(lines[2])\n    farmers = []\n    for i in range(3, 3 + T):\n        M, *beans = map(int, lines[i].split())\n        farmers.append(beans)\n\n    # Calculate the number of cows needed\n    cows_needed = 0\n    for i in range(B):\n        total_beans = V[i]\n        for farmer in farmers:\n            if i in farmer:\n                total_beans += 1\n        cows_needed += total_beans // (i + 1)\n\n    return str(cows_needed)"
    },
    {
        "number": 2821,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, M, S, L = map(int, stdin.split())\n    total_time = S + L * Q\n    return str(total_time)"
    },
    {
        "number": 2822,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_b, y_b = map(int, stdin.split()[0].split(','))\n    x_1, y_1, x_2, y_2 = map(int, stdin.split()[1].split())\n\n    # Check if the rectangle is axis-aligned\n    if x_1 == x_2 or y_1 == y_2:\n        # Check if the rectangle contains the point (0, 0)\n        if x_1 <= 0 <= x_2 and y_1 <= 0 <= y_2:\n            # Check if the point (0, 0) is on the same side of the tree as Belle\n            if (x_b > 0 and y_b > 0) or (x_b < 0 and y_b < 0):\n                return \"Yes\"\n            else:\n                return \"No\"\n        else:\n            return \"No\"\n    else:\n        # Check if the rectangle contains the point (0, 0)\n        if x_1 <= 0 <= x_2 and y_1 <= 0 <= y_2:\n            # Check if the point (0, 0) is on the same side of the tree as Belle\n            if (x_b > 0 and y_b > 0) or (x_b < 0 and y_b < 0):\n                return \"Yes\"\n            else:\n                # Check if the point (0, 0) is blocked by a tree\n                if x_b == 0 and y_b > 0:\n                    return \"No\" + \"\\n\" + \"1 0\"\n                elif x_b == 0 and y_b < 0:\n                    return \"No\" + \"\\n\" + \"1 0\"\n                elif y_b == 0 and x_b > 0:\n                    return \"No\" + \"\\n\" + \"0 1\"\n                elif y_b == 0 and x_b < 0:\n                    return \"No\" + \"\\n\" + \"0 1\"\n                else:\n                    return \"No\" + \"\\n\" + \"0 0\"\n        else:\n            return \"No\""
    },
    {
        "number": 2823,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    apple_dna, swine_gene, costs = stdin.split('\\n')\n    costs = list(map(int, costs.split()))\n    min_cost = float('inf')\n    for i in range(len(apple_dna) - len(swine_gene) + 1):\n        cost = 0\n        for j in range(len(swine_gene)):\n            if apple_dna[i+j] == swine_gene[j]:\n                cost += costs[0]\n            elif apple_dna[i+j] == 'A' and swine_gene[j] == 'C':\n                cost += costs[1]\n            elif apple_dna[i+j] == 'C' and swine_gene[j] == 'G':\n                cost += costs[2]\n            elif apple_dna[i+j] == 'G' and swine_gene[j] == 'T':\n                cost += costs[3]\n        min_cost = min(min_cost, cost)\n    return str(min_cost)"
    },
    {
        "number": 2824,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    m = int(lines[0])\n    weights = [int(line) for line in lines[1:]]\n\n    weights.sort()\n    total_weight = sum(weights)\n    target_weight = total_weight // 2\n\n    left_sum = 0\n    right_sum = total_weight\n\n    for weight in weights:\n        if weight <= target_weight:\n            left_sum += weight\n        else:\n            right_sum -= weight\n\n    if left_sum == right_sum:\n        return str(target_weight)\n\n    if left_sum < right_sum:\n        target_weight -= 1\n    else:\n        target_weight += 1\n\n    while left_sum != right_sum:\n        if left_sum < right_sum:\n            target_weight -= 1\n            left_sum += 1\n        else:\n            target_weight += 1\n            right_sum -= 1\n\n    return str(target_weight)"
    },
    {
        "number": 2825,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *times = map(int, stdin.split())\n    times.sort()\n    total_time = 0\n    for i in range(N - 1):\n        total_time += times[i]\n        if i % 2 == 0:\n            total_time += 1\n    total_time += times[-1]\n    return str(total_time)"
    },
    {
        "number": 2826,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, n, D = map(int, stdin.split())\n    f1, f2 = stdin.split('\\n')[1:3]\n    \n    def hamming_distance(s1, s2):\n        return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n    \n    count = 0\n    for i in range(q**n):\n        p = bin(i)[2:].zfill(n)\n        if hamming_distance(f1, p) + hamming_distance(f2, p) == D:\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 2827,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def dfs(node: int, visited: set) -> set:\n        visited.add(node)\n        for neighbor in [u for u, v in edges if v == node or u == node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n        return visited\n\n    visited = set()\n    for i in range(1, N + 1):\n        if i not in visited:\n            visited = dfs(i, visited)\n            if len(visited) == N:\n                return \"0\"\n\n    # Find the minimum number of IT requests\n    it_requests = 0\n    for u, v in edges:\n        if u not in visited and v in visited:\n            it_requests += 1\n        elif u in visited and v not in visited:\n            it_requests += 1\n\n    return str(it_requests)"
    },
    {
        "number": 2828,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    words = lines[1:n+1]\n    a = list(map(int, lines[n+1].split()))\n    \n    def is_valid_key(key: str) -> bool:\n        for i in range(n):\n            if words[i][0] == key[a[i]-1]:\n                continue\n            else:\n                return False\n        return True\n    \n    for key in itertools.permutations('abcdefghijklmnopqrstuvwxyz'):\n        if is_valid_key(''.join(key)):\n            return \"DA\\n\" + ''.join(key)\n    return \"NE\""
    },
    {
        "number": 2829,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    morse_code = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'\n    }\n\n    encoded_length = 0\n    for char in stdin.upper():\n        if char.isalpha() or char.isdigit():\n            encoded_length += len(morse_code[char]) + 1\n        elif char == ' ':\n            encoded_length += 3\n\n    return encoded_length - 3  # Remove the last gap between characters"
    },
    {
        "number": 2830,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(map(int, line.strip())) for line in stdin.splitlines()[1:]]\n    start = (0, 0)\n    end = (n - 1, m - 1)\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (x, y), distance = queue.pop(0)\n            if (x, y) == end:\n                return distance\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny) and grid[nx][ny] != 0:\n                        queue.append(((nx, ny), distance + 1))\n        return -1\n\n    return str(bfs(start, end))"
    },
    {
        "number": 2831,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    vehicles = []\n    for i in range(1, n+1):\n        x, v = map(int, stdin.split('\\n')[i].split())\n        vehicles.append((x, v))\n    \n    min_distance = float('inf')\n    for i in range(len(vehicles)):\n        for j in range(i+1, len(vehicles)):\n            x1, v1 = vehicles[i]\n            x2, v2 = vehicles[j]\n            if v1 == v2:\n                min_distance = min(min_distance, abs(x1 - x2))\n            else:\n                t = (x2 - x1) / (v1 - v2)\n                min_distance = min(min_distance, abs(x1 + v1 * t - x2))\n    \n    return str(min_distance)"
    },
    {
        "number": 2832,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k = map(int, stdin.split()[:2])\n    pixels = [int(x) for x in stdin.split()[2:]]\n    pixels = [(pixels[i], pixels[i+1]) for i in range(0, len(pixels), 2)]\n    pixels.sort(key=lambda x: x[0])\n\n    def sum_of_squared_errors(values: List[int]) -> int:\n        errors = [min([abs(r - v) for v in values]) ** 2 for r, _ in pixels]\n        return sum(errors)\n\n    def binary_search(values: List[int]) -> int:\n        left, right = min(values), max(values)\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if sum_of_squared_errors([mid] * d) <= sum_of_squared_errors(values):\n                right = mid\n            else:\n                left = mid\n        return left\n\n    values = [p[0] for p in pixels]\n    min_error = sum_of_squared_errors(values[:k])\n    max_error = sum_of_squared_errors(values)\n    return str(min_error) if k == 1 else str(binary_search(range(min_error, max_error + 1, 1)))"
    },
    {
        "number": 2833,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, table, K = stdin.split('\\n')\n    R, C, K = int(R), int(C), int(K)\n    table = [list(row) for row in table.split('\\n')]\n\n    def rotate(matrix, K):\n        K = K % 360\n        if K == 0:\n            return matrix\n        elif K == 90:\n            return list(zip(*matrix[::-1]))\n        elif K == 180:\n            return [row[::-1] for row in matrix[::-1]]\n        elif K == 270:\n            return list(zip(*matrix))[::-1]\n\n    rotated_table = rotate(table, K)\n    result = '\\n'.join([''.join(row) for row in rotated_table])\n    return result"
    },
    {
        "number": 2834,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    lucky_digits = [4, 7]\n    lucky_count = 0\n    num = 1\n\n    while lucky_count < k:\n        digits = [int(d) for d in str(num)]\n        if all(d in lucky_digits for d in digits):\n            lucky_count += 1\n        num += 1\n\n    return str(num - 1)"
    },
    {
        "number": 2835,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if t in s[i:j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2836,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, boys, A, B = stdin.split()\n    N = int(N)\n    A = int(A)\n    B = int(B)\n    boys = list(map(int, boys.split()))\n\n    max_distance = 0\n    result = None\n\n    for i in range(A, B + 1, 2):\n        distance = min(abs(i - boy) for boy in boys)\n        if distance > max_distance:\n            max_distance = distance\n            result = i\n\n    return str(result)"
    },
    {
        "number": 2837,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    resistances = list(map(float, stdin.readline().split()))\n    circuit = stdin.readline().strip()\n\n    def calculate_equivalent_resistance(circuit: str) -> float:\n        stack = []\n        for char in circuit:\n            if char == '(':\n                stack.append('(')\n            elif char == ')':\n                sub_circuit = ''\n                while stack[-1] != '(':\n                    sub_circuit = stack.pop() + sub_circuit\n                stack.pop()\n                if sub_circuit.startswith('R'):\n                    stack.append(str(calculate_equivalent_resistance(sub_circuit)))\n                else:\n                    stack.append(sub_circuit)\n            else:\n                stack.append(char)\n\n        result = ''\n        while stack:\n            result += stack.pop()\n\n        return eval(result)\n\n    return '{:.5f}'.format(calculate_equivalent_resistance(circuit))"
    },
    {
        "number": 2838,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def remove_brackets(expression: str, start: int, end: int) -> str:\n        if start < 0 or end >= len(expression) or expression[start] != '(' or expression[end] != ')':\n            return None\n        return expression[:start] + expression[start + 1:end] + expression[end + 1:]\n\n    def find_expressions(expression: str, start: int = 0, memo: set = None) -> set:\n        if memo is None:\n            memo = set()\n        if start >= len(expression):\n            memo.add(expression)\n            return memo\n        for i in range(start, len(expression)):\n            if expression[i] == '(':\n                for j in range(i + 1, len(expression)):\n                    if expression[j] == ')':\n                        new_expression = remove_brackets(expression, i, j)\n                        if new_expression is not None:\n                            find_expressions(new_expression, j + 1, memo)\n        return memo\n\n    return '\\n'.join(sorted(find_expressions(stdin)))"
    },
    {
        "number": 2839,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, E, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(V)]\n    for _ in range(E):\n        u, v, w = map(int, stdin.split()[4:])\n        graph[u].append((v, w))\n\n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * V\n        dist[start] = 0\n        visited = [False] * V\n        heap = [(0, start)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                new_dist = d + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(heap, (new_dist, neighbor))\n        return dist\n\n    dist_s = dijkstra(s)\n    dist_t = dijkstra(t)\n    paths = 0\n    for i in range(V):\n        if dist_s[i] + dist_t[i] == dist_s[t]:\n            paths += 1\n    return str(paths)"
    },
    {
        "number": 2840,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = stdin.split()[1:]\n    suits = {'s': [], 'h': [], 'd': [], 'c': []}\n    ranks = {'2': [], '3': [], '4': [], '5': [], '6': [], '7': [], '8': [], '9': [], 'T': [], 'J': [], 'Q': [], 'K': [], 'A': []}\n\n    for card in cards:\n        suit = card[1]\n        rank = card[0]\n        suits[suit].append(rank)\n\n    for suit in suits:\n        suits[suit].sort(reverse=True)\n\n    for suit in suits:\n        for rank in suits[suit]:\n            ranks[rank].append(suit)\n\n    moves = 0\n    for suit in suits:\n        for rank in suits[suit]:\n            for card in ranks[rank]:\n                if card != suit:\n                    moves += 1\n\n    return str(moves)"
    },
    {
        "number": 2841,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    board = stdin.split('\\n')[1:]\n    colors = ['Blue', 'Orange', 'Pink', 'Green', 'Red', 'Yellow']\n    min_moves = float('inf')\n\n    for color in colors:\n        moves = 0\n        current_square = 0\n        while current_square < N:\n            next_square = board.index(color, current_square) if color in board[current_square:] else N\n            if next_square == N:\n                min_moves = min(min_moves, moves)\n                break\n            moves += 1\n            current_square = next_square\n\n    return str(min_moves)"
    },
    {
        "number": 2842,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    grid = [list(stdin.split()[i]) for i in range(1, n+1)]\n    ship_sizes = list(map(int, stdin.split()[n+1:]))\n    \n    def is_valid_placement(ship_size, row, col, direction):\n        if direction == 'h':\n            for i in range(ship_size):\n                if col+i >= n or grid[row][col+i] != '.':\n                    return False\n            return True\n        else:\n            for i in range(ship_size):\n                if row+i >= n or grid[row+i][col] != '.':\n                    return False\n            return True\n    \n    def count_valid_placements(ship_size, row, col):\n        count = 0\n        if is_valid_placement(ship_size, row, col, 'h'):\n            count += 1\n        if is_valid_placement(ship_size, row, col, 'v'):\n            count += 1\n        return count\n    \n    def place_ship(ship_size, row, col, direction):\n        if direction == 'h':\n            for i in range(ship_size):\n                grid[row][col+i] = 'X'\n        else:\n            for i in range(ship_size):\n                grid[row+i][col] = 'X'\n    \n    def print_grid():\n        for row in grid:\n            print(''.join(row))\n    \n    def backtrack(ship_index, row, col):\n        if ship_index == k:\n            return 1\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '.':\n                    valid_placements = count_valid_placements(ship_sizes[ship_index], i, j)\n                    if valid_placements > 0:\n                        place_ship(ship_sizes[ship_index], i, j, 'h' if valid_placements == 2 else 'v')\n                        count += backtrack(ship_index+1, i, j)\n                        for m in range(ship_sizes[ship_index]):\n                            grid[i][j+m] = '.'\n                        for m in range(ship_sizes[ship_index]):\n                            grid[i+m][j] = '.'\n        return count\n    \n    return str(backtrack(0, 0, 0))"
    },
    {
        "number": 2843,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_swap_free(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                if word1[i] in word2[i + 1:] or word2[i] in word1[i + 1:]:\n                    return False\n        return True\n\n    def find_largest_swap_free_set(words: List[str]) -> int:\n        n = len(words)\n        max_size = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_swap_free(words[i], words[j]):\n                    max_size = max(max_size, 2)\n                else:\n                    max_size = max(max_size, 1)\n        return max_size\n\n    words = stdin.split('\\n')[1:]\n    return str(find_largest_swap_free_set(words))"
    },
    {
        "number": 2844,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    map_data = stdin.split('\\n')[1:]\n    beaver_den = None\n    painter = None\n    hedgehogs = []\n\n    for i in range(R):\n        for j in range(C):\n            if map_data[i][j] == 'D':\n                beaver_den = (i, j)\n            elif map_data[i][j] == 'S':\n                painter = (i, j)\n            elif map_data[i][j] == 'X':\n                continue\n            elif map_data[i][j] == '.':\n                hedgehogs.append((i, j))\n\n    if not beaver_den or not painter or not hedgehogs:\n        return \"KAKTUS\"\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C and map_data[x][y] != 'X'\n\n    def flood_fill(x, y):\n        if not is_valid(x, y) or map_data[x][y] == '*':\n            return\n        map_data[x][y] = '*'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            flood_fill(x + dx, y + dy)\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, time = queue.pop(0)\n            if current == end:\n                return time\n            if current in visited:\n                continue\n            visited.add(current)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_pos = (current[0] + dx, current[1] + dy)\n                if is_valid(*new_pos) and map_data[new_pos[0]][new_pos[1]] != '*':\n                    queue.append((new_pos, time + 1))\n\n    flood_fill(*beaver_den)\n    time = 0\n    while True:\n        painter_pos = painter\n        hedgehogs_pos = [h for h in hedgehogs]\n        flood_fill(*painter_pos)\n        for i, h in enumerate(hedgehogs_pos):\n            flood_fill(*h)\n        time += 1\n        if all(map_data[h[0]][h[1]] == '*' for h in hedgehogs_pos):\n            break\n\n    return str(bfs(painter_pos, beaver_den))"
    },
    {
        "number": 2845,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, K = map(int, stdin.split())\n    house_indices = list(map(int, stdin.split()))[1:]\n    perimeter = 0\n\n    for index in house_indices:\n        row, col = (index - 1) // R + 1, (index - 1) % R + 1\n        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n\n        for neighbor in neighbors:\n            if neighbor[0] < 1 or neighbor[0] > R or neighbor[1] < 1 or neighbor[1] > R:\n                continue\n            neighbor_index = (neighbor[0] - 1) * R + neighbor[1]\n            if neighbor_index not in house_indices:\n                perimeter += 1\n\n    return str(perimeter)"
    },
    {
        "number": 2846,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    citations = [int(c) for c in stdin.split('\\n')[1:]]\n    citations.sort(reverse=True)\n    h_index = 0\n    for i in range(len(citations)):\n        if citations[i] >= i+1:\n            h_index = i+1\n        else:\n            break\n    return str(h_index)"
    },
    {
        "number": 2847,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    preferences = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    songs = set()\n    for preference in preferences:\n        songs.update(preference)\n\n    songs = sorted(list(songs))\n    L = len(songs)\n\n    for preference in preferences:\n        for i, song in enumerate(preference):\n            if song not in songs:\n                L = min(L, i)\n                break\n\n    return f\"{L}\\n{' '.join(map(str, songs[:L]))}\""
    },
    {
        "number": 2848,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, K, X0, A, B = map(int, stdin.split())\n    X = [X0]\n    for i in range(1, R):\n        X.append((A * X[-1] + B) % N)\n    leftmost_bucket = 0\n    overflow = False\n    for i in range(R):\n        if X[i] == leftmost_bucket:\n            if K < R - i:\n                overflow = True\n                break\n            else:\n                leftmost_bucket = (leftmost_bucket + 1) % N\n    if overflow:\n        return \"OVERFLOW\"\n    else:\n        a = 0\n        for i in range(R):\n            a = (53 * a + X[i]) % 199933\n        return str(a)"
    },
    {
        "number": 2849,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD\n\n    return str(dp[n])"
    },
    {
        "number": 2850,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n\n    weights.sort(reverse=True)\n    box_weights = [0] * k\n\n    for i in range(n):\n        box_index = i % k\n        box_weights[box_index] += weights[i]\n\n    return str(max(box_weights))"
    },
    {
        "number": 2851,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A_factors = list(map(int, lines[1].split()))\n    M = int(lines[2])\n    B_factors = list(map(int, lines[3].split()))\n\n    # Compute A and B\n    A = 1\n    for factor in A_factors:\n        A *= factor\n\n    B = 1\n    for factor in B_factors:\n        B *= factor\n\n    # Compute gcd\n    gcd = 1\n    while A % gcd == 0 and B % gcd == 0:\n        gcd *= 2\n\n    # Output result\n    return str(gcd % 1000000000)"
    },
    {
        "number": 2852,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, probabilities = stdin.split('\\n')\n    n = int(n)\n    probabilities = list(map(int, probabilities.split()))\n\n    def research_productivity_index(a, s):\n        if a == 0:\n            return 0\n        return a ** (a / s)\n\n    max_index = 0\n    for i in range(2 ** n):\n        accepted = [0] * n\n        for j in range(n):\n            if i & (1 << j):\n                accepted[j] = 1\n\n        s = sum(accepted)\n        a = sum(accepted[j] * probabilities[j] / 100 for j in range(n))\n        index = research_productivity_index(a, s)\n        max_index = max(max_index, index)\n\n    return f\"{max_index:.6f}\""
    },
    {
        "number": 2853,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    connected_houses = set()\n    for line in stdin.split('\\n')[2:]:\n        a, b = map(int, line.split())\n        connected_houses.add(a)\n        connected_houses.add(b)\n    \n    not_connected_houses = set(range(1, N+1)) - connected_houses\n    \n    if not not_connected_houses:\n        return \"Connected\"\n    else:\n        return \"\\n\".join(map(str, sorted(not_connected_houses)))"
    },
    {
        "number": 2854,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    atoms = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[:2])\n        atoms.append((x, y))\n        stdin = stdin[stdin.find('\\n') + 1:]\n\n    bonds = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[:2])\n        bonds.append((a - 1, b - 1))\n        stdin = stdin[stdin.find('\\n') + 1:]\n\n    fixed_atoms = [i for i, (x, y) in enumerate(atoms) if x != -1 or y != -1]\n    if not fixed_atoms:\n        return \"No fixed atom found\"\n\n    def get_average_coordinates(atom_index: int) -> Tuple[float, float]:\n        neighbors = [bond for bond in bonds if atom_index in bond]\n        neighbor_coordinates = [atoms[i] for bond in neighbors for i in bond if i != atom_index]\n        return (sum(x for x, y in neighbor_coordinates) / len(neighbor_coordinates),\n                sum(y for x, y in neighbor_coordinates) / len(neighbor_coordinates))\n\n    def get_distance(a: Tuple[float, float], b: Tuple[float, float]) -> float:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def get_closest_atom(atom_index: int) -> int:\n        closest_atom = None\n        closest_distance = float('inf')\n        for i in range(n):\n            if i not in fixed_atoms:\n                distance = get_distance(atoms[i], get_average_coordinates(i))\n                if distance < closest_distance:\n                    closest_atom = i\n                    closest_distance = distance\n        return closest_atom\n\n    for i in range(n):\n        if i not in fixed_atoms:\n            closest_atom = get_closest_atom(i)\n            while get_distance(atoms[i], get_average_coordinates(i)) > 10 ** -3:\n                atoms[i], atoms[closest_atom] = atoms[closest_atom], atoms[i]\n                closest_atom = get_closest_atom(i)\n\n    return '\\n'.join(f'{x} {y}' for x, y in atoms)"
    },
    {
        "number": 2855,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        K, L = map(int, stdin.split()[2:])\n        graph[K].append(L)\n        graph[L].append(K)\n\n    def dfs(node: int, visited: set, time: int) -> int:\n        if node == N - 1:\n            return time\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                time = dfs(neighbor, visited, time + 1)\n        return time\n\n    return str(dfs(0, set(), 0))"
    },
    {
        "number": 2856,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, starting_state = stdin.split()\n    N = int(N)\n    a_count = starting_state.count(\"A\")\n    b_count = N - a_count\n\n    if a_count == 0:\n        return str(b_count)\n    elif b_count == 0:\n        return str(a_count)\n    else:\n        return str(min(a_count, b_count))"
    },
    {
        "number": 2857,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2\n\n    def find_triangles(points):\n        triangles = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a, b, c = abs(points[i][0] - points[j][0]), abs(points[i][1] - points[j][1]), abs(points[k][0] - points[j][0])\n                    if is_right_triangle(a, b, c):\n                        triangles += 1\n        return triangles\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    return str(find_triangles(points))"
    },
    {
        "number": 2858,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    accused = [int(x) for x in lines[1:]]\n\n    mobsters = set()\n    for i in range(n):\n        if accused[i] not in mobsters:\n            mobsters.add(accused[i])\n\n    return str(len(mobsters))"
    },
    {
        "number": 2859,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3, xv, yv, r = map(int, stdin.split())\n\n    # Calculate the distance between the centers of particles 2 and 3\n    d = ((x2 - x3) ** 2 + (y2 - y3) ** 2) ** 0.5\n\n    # Calculate the angle between the vector (xv, yv) and the line connecting the centers of particles 1 and 2\n    theta = math.atan2(y2 - y1, x2 - x1) - math.atan2(yv, xv)\n\n    # Calculate the distance between the center of particle 1 and the line connecting the centers of particles 2 and 3\n    dist = abs(x1 * (y2 - y3) + y1 * (x3 - x2) + x2 * y3 - y2 * x3) / d\n\n    # Calculate the angle between the vector (xv, yv) and the tangent at the point of contact\n    tangent_theta = theta + math.pi / 2\n\n    # Check the scenario based on the angle between the vector (xv, yv) and the tangent at the point of contact\n    if tangent_theta > 0 and tangent_theta < math.pi:\n        scenario = 1\n    elif tangent_theta >= math.pi and tangent_theta < 3 * math.pi / 2:\n        scenario = 2\n    elif tangent_theta >= 3 * math.pi / 2 and tangent_theta <= 2 * math.pi:\n        scenario = 3\n    else:\n        scenario = 4\n\n    # Check if the distance between the center of particle 1 and the line connecting the centers of particles 2 and 3 is less than the sum of the radii of particles 1 and 2\n    if dist < r + r:\n        scenario = 5\n\n    return str(scenario)"
    },
    {
        "number": 2860,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, w = map(int, stdin.split()[0].split())\n    inscription = stdin.split('\\n')[1:]\n    new_inscription = []\n    for line in inscription:\n        new_line = ''\n        for word in line.split('.'):\n            if len(new_line) + len(word) + 1 <= w:\n                new_line += word + '.'\n            else:\n                new_inscription.append(new_line)\n                new_line = word + '.'\n        new_inscription.append(new_line)\n    return str(len(new_inscription))"
    },
    {
        "number": 2861,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    routines = stdin.split('\\n')[1:]\n    dancers = set()\n    for routine in routines:\n        dancers.update(routine)\n    dancers = sorted(list(dancers))\n    dancers_count = len(dancers)\n    quick_changes = 0\n    for i in range(dancers_count - 1):\n        if dancers[i + 1] == dancers[i]:\n            quick_changes += 1\n    return str(quick_changes)"
    },
    {
        "number": 2862,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node, count):\n        if visited[node]:\n            return count\n        visited[node] = True\n        for neighbor in graph[node]:\n            count = dfs(graph, visited, neighbor, count)\n        return count\n\n    def find_min_materials(graph, start, end, target):\n        visited = [False] * len(graph)\n        count = dfs(graph, visited, start, 0)\n        if count < target:\n            return \"Impossible\"\n        visited = [False] * len(graph)\n        return dfs(graph, visited, end, 0)\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split(\"\\n\")\n        num_materials, num_dependencies = map(int, lines[0].split())\n        wanted_materials = list(map(int, lines[1].split()))\n        graph = [[] for _ in range(num_materials)]\n        for i in range(num_dependencies):\n            u, v, w = map(int, lines[i + 2].split())\n            graph[u].append(v)\n        return wanted_materials, graph\n\n    wanted_materials, graph = parse_input(stdin)\n    result = []\n    for i in range(len(wanted_materials)):\n        if wanted_materials[i] == 0:\n            result.append(0)\n        else:\n            result.append(find_min_materials(graph, i, i, wanted_materials[i]))\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2863,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    likes = [set(), set()]\n    for i, line in enumerate(stdin.split('\\n')):\n        days = [int(x) for x in line.split()[1:]]\n        likes[i].update(days)\n\n    max_count = 0\n    current_count = 0\n    for i in range(1000000):\n        if i in likes[0] and i in likes[1]:\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n\n    return str(max_count)"
    },
    {
        "number": 2864,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = stdin.split('\\n')[1]\n    suggestions = stdin.split('\\n')[2:]\n\n    # Initialize the murderer, weapon, and room to None\n    murderer = None\n    weapon = None\n    room = None\n\n    # Iterate through the suggestions\n    for suggestion in suggestions:\n        # Split the suggestion into person, weapon, and room\n        person, weapon_room = suggestion.split()[:2]\n        weapon, room = weapon_room[0], weapon_room[1]\n\n        # Check if the murderer has been identified\n        if person == 'A' and weapon == 'G' and room == 'M':\n            murderer = 'A'\n            weapon = 'G'\n            room = 'M'\n            break\n\n    # If the murderer has not been identified, return 'E??'\n    if murderer is None:\n        return 'E??'\n\n    # Otherwise, return the murderer, weapon, and room\n    return f'{murderer}{weapon}{room}'"
    },
    {
        "number": 2865,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, x2 = map(int, stdin.split()[:2])\n    n1, n2 = map(int, stdin.split()[2:4])\n    t1 = list(map(int, stdin.split()[4:4+n1]))\n    t2 = list(map(int, stdin.split()[4+n1:]))\n\n    for i in range(len(t1)):\n        if t1[i] > t2[i]:\n            t1[i], t2[i] = t2[i], t1[i]\n\n    for i in range(len(t1)):\n        if t1[i] == t2[i]:\n            return \"safe and sound\"\n\n    for i in range(len(t1)):\n        if t1[i] < t2[i]:\n            if x1 + 5 <= x2:\n                return \"safe and sound\"\n            else:\n                return f\"bumper tap at time {t1[i]}\"\n\n    return \"safe and sound\""
    },
    {
        "number": 2866,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = sorted(set(stdin))\n    for i in range(1, len(digits) * 10):\n        if not all(str(i).count(digit) <= 1 for digit in digits):\n            return str(i)\n    return str(len(digits) * 10)"
    },
    {
        "number": 2867,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factors(n: int) -> List[int]:\n        factors = []\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                factors.append(i)\n                if n // i != i:\n                    factors.append(n // i)\n        return factors\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def happiness(n: int, V: List[int], C: List[int]) -> int:\n        factors = prime_factors(n)\n        happiness = 0\n        for factor in factors:\n            if is_prime(factor):\n                happiness += V[factor - 1]\n        return happiness\n\n    def max_happiness(N: int, V: List[int], C: List[int]) -> int:\n        max_happiness = 0\n        for i in range(1, N + 1):\n            max_happiness += happiness(i, V, C)\n        return max_happiness\n\n    N, V, C = map(int, stdin.split())\n    V = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n\n    return str(max_happiness(N, V, C))"
    },
    {
        "number": 2868,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, word = stdin.split()\n    X = int(X)\n    for _ in range(X):\n        word = word[::-1]\n        new_word = \"\"\n        for i in range(len(word)):\n            if i % 2 == 0:\n                new_word += word[i]\n            else:\n                new_word = word[i] + new_word\n        word = new_word\n    return word"
    },
    {
        "number": 2869,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    roman_numerals = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000\n    }\n\n    def roman_to_decimal(roman: str) -> int:\n        decimal = 0\n        prev_value = 0\n        for char in roman:\n            value = roman_numerals[char]\n            if value > prev_value:\n                decimal += value - 2 * prev_value\n            else:\n                decimal += value\n            prev_value = value\n        return decimal\n\n    def decimal_to_roman(decimal: int) -> str:\n        result = ''\n        values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n\n        for i in range(len(values)):\n            while decimal >= values[i]:\n                result += symbols[i]\n                decimal -= values[i]\n\n        return result\n\n    decimal = roman_to_decimal(stdin)\n    rearranged_decimal = min(decimal_to_roman(decimal), decimal_to_roman(decimal - 1))\n    return decimal_to_roman(roman_to_decimal(rearranged_decimal))"
    },
    {
        "number": 2870,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    if p > 100 or q > 100:\n        return \"Invalid input\"\n\n    def get_happiness(p, q):\n        return p + q\n\n    def get_opponent_happiness(p, q):\n        return -p - q\n\n    def get_max_happiness(p, q):\n        return max(get_happiness(p, q), get_opponent_happiness(p, q))\n\n    return str(get_max_happiness(p, q))"
    },
    {
        "number": 2871,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    skills = list(map(int, stdin.split()[2:]))\n\n    skills.sort(reverse=True)\n    result = 0\n\n    for i in range(0, N, K):\n        result += sum(skills[i:i+K])\n\n    return str(result)"
    },
    {
        "number": 2872,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    day, month, day_of_week = stdin.split()\n    day = int(day)\n\n    months = {\n        \"JAN\": 31,\n        \"FEB\": 28,\n        \"MAR\": 31,\n        \"APR\": 30,\n        \"MAY\": 31,\n        \"JUN\": 30,\n        \"JUL\": 31,\n        \"AUG\": 31,\n        \"SEP\": 30,\n        \"OCT\": 31,\n        \"NOV\": 30,\n        \"DEC\": 31\n    }\n\n    if day_of_week == \"MON\":\n        return \":(\", \"TGIF\"\n    elif day_of_week == \"TUE\":\n        return \":(\", \"TGIF\"\n    elif day_of_week == \"WED\":\n        return \":(\", \"TGIF\"\n    elif day_of_week == \"THU\":\n        return \"TGIF\", \":(\", \"TGIF\"\n    elif day_of_week == \"FRI\":\n        return \"TGIF\"\n    elif day_of_week == \"SAT\":\n        return \":(\", \"TGIF\"\n    elif day_of_week == \"SUN\":\n        return \":(\", \"TGIF\"\n\n    if day == 29 and month == \"FEB\":\n        return \"TGIF\"\n    elif day > months[month]:\n        return \":(\", \"TGIF\"\n    else:\n        return \":(\", \"TGIF\""
    },
    {
        "number": 2873,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    pleasant_words = 0\n\n    for i in range(len(stdin)):\n        if stdin[i] == \"_\":\n            for j in range(len(vowels)):\n                if stdin[:i] + vowels[j] + stdin[i + 1:] not in pleasant_words and stdin[:i] + consonants[j] + stdin[i + 1:] not in pleasant_words:\n                    pleasant_words += 1\n\n    return str(pleasant_words)"
    },
    {
        "number": 2874,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    people_positions = list(map(int, stdin.split()[2:2+n]))\n    trees_positions = list(map(int, stdin.split()[2+n:]))\n    \n    unclaimed_people = 0\n    for person_position in people_positions:\n        closest_tree_position = min(trees_positions, key=lambda x: abs(x - person_position))\n        if closest_tree_position == person_position:\n            unclaimed_people += 1\n    \n    return str(unclaimed_people)"
    },
    {
        "number": 2875,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = stdin.split('\\n')\n    n = int(n)\n    cards = list(map(int, cards.split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cards[j] < cards[i]:\n                return f\"{i + 1} {j + 1}\"\n\n    return \"impossible\""
    },
    {
        "number": 2876,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    f_values = {}\n    for i in range(1, N+1):\n        x, z = map(int, stdin.split('\\n')[i].split())\n        f_values[x] = z\n\n    def f(x):\n        return f_values[x]\n\n    def lipschitz_constant(f, N):\n        max_diff = 0\n        for i in range(N):\n            for j in range(i+1, N):\n                diff = abs(f(i) - f(j))\n                if diff > max_diff:\n                    max_diff = diff\n        return max_diff\n\n    L = lipschitz_constant(f, N)\n    return str(L)"
    },
    {
        "number": 2877,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = list(stdin)\n    mid = len(word) // 2\n    first_half = word[:mid]\n    second_half = word[mid:]\n    reversed_first_half = first_half[::-1]\n    reversed_second_half = second_half[::-1]\n    reversed_word = reversed_first_half + reversed_second_half\n    return ''.join(reversed_word)"
    },
    {
        "number": 2878,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_triplets(grid: List[List[str]]) -> int:\n        count = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '.':\n                    continue\n                for k in range(len(grid)):\n                    if grid[i][j] == grid[k][j] and grid[i][j] == grid[i][k]:\n                        count += 1\n        return count\n\n    N = int(stdin.split('\\n')[0])\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    return str(count_triplets(grid))"
    },
    {
        "number": 2879,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[:2])\n    matrix = stdin.split()[2:]\n    matrix = [list(row) for row in matrix]\n\n    def is_valid_polyomino(polyomino: List[List[str]]) -> bool:\n        for i in range(len(polyomino)):\n            for j in range(len(polyomino[0])):\n                if polyomino[i][j] == 'X':\n                    if i > 0 and polyomino[i - 1][j] == 'X':\n                        return False\n                    if j > 0 and polyomino[i][j - 1] == 'X':\n                        return False\n        return True\n\n    def find_polyomino_powers(polyomino: List[List[str]]) -> List[List[str]]:\n        powers = []\n        for i in range(1, 6):\n            power = [['.'] * w for _ in range(h)]\n            for y in range(h):\n                for x in range(w):\n                    if polyomino[y][x] == 'X':\n                        power[y][x] = str(i)\n            powers.append(power)\n        return powers\n\n    def is_valid_polyomino_power(polyomino_power: List[List[str]]) -> bool:\n        for i in range(h):\n            for j in range(w):\n                if matrix[i][j] == 'X' and matrix[i][j] != polyomino_power[i][j]:\n                    return False\n        return True\n\n    def find_solution() -> str:\n        for i in range(h):\n            for j in range(w):\n                if matrix[i][j] == 'X':\n                    polyomino = [['.'] * w for _ in range(h)]\n                    polyomino[i][j] = 'X'\n                    if is_valid_polyomino(polyomino):\n                        polyomino_powers = find_polyomino_powers(polyomino)\n                        for power in polyomino_powers:\n                            if is_valid_polyomino_power(power):\n                                return '\\n'.join([''.join(row) for row in power])\n        return \"No solution\"\n\n    return find_solution()"
    },
    {
        "number": 2880,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    matrix = [list(row) for row in stdin.split()[2:]]\n\n    def is_valid(matrix, row):\n        for i in range(C):\n            if matrix[row][i] in matrix[row + 1:]:\n                return False\n        return True\n\n    max_rows = 0\n    for i in range(R):\n        if is_valid(matrix, i):\n            max_rows += 1\n        else:\n            break\n\n    return str(max_rows)"
    },
    {
        "number": 2881,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = stdin.split()\n    if len(x) != len(y):\n        return \"no\"\n\n    for i in range(len(x)):\n        if x[i] != y[i]:\n            if x[i] == '0' or y[i] == '0':\n                return \"no\"\n            else:\n                return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 2882,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    def backtrack(s, left, right):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            backtrack(s + \"(\", left - 1, right)\n        if right > 0 and right > left:\n            backtrack(s + \")\", left, right - 1)\n    backtrack(\"\", n, n)\n    return result"
    },
    {
        "number": 2883,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = eval(stdin)\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n\n    return str(merged)"
    },
    {
        "number": 2884,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n\n    candidates, target = stdin.split(\",\")\n    candidates = list(map(int, candidates))\n    target = int(target)\n\n    result = []\n    for length in range(1, len(candidates) + 1):\n        for combination in itertools.combinations(candidates, length):\n            if sum(combination) == target:\n                result.append(list(combination))\n\n    return str(result)"
    },
    {
        "number": 2885,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals, new_interval = eval(stdin)\n    result = []\n    i = 0\n    n = len(intervals)\n    while i < n and intervals[i][1] < new_interval[0]:\n        result.append(intervals[i])\n        i += 1\n    if i == n:\n        result.append(new_interval)\n    else:\n        result.append([intervals[i][0], max(intervals[i][1], new_interval[1])])\n        i += 1\n        while i < n:\n            if intervals[i][0] <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], intervals[i][1])\n            else:\n                result.append(intervals[i])\n            i += 1\n    return str(result)"
    },
    {
        "number": 2886,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if len(substring) >= 2 and more_than_half(substring):\n                return f\"{i} {j}\"\n    return \"-1 -1\"\n\ndef"
    },
    {
        "number": 2887,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    volumes = list(map(int, lines[1].split()))\n    temperatures = list(map(int, lines[2].split()))\n    \n    evaporated_soup = []\n    \n    for i in range(n):\n        volume_left = volumes[i] - temperatures[i]\n        if volume_left < 0:\n            volume_left = 0\n        evaporated_soup.append(volumes[i] - volume_left)\n        \n    return \" \".join(map(str, evaporated_soup))"
    },
    {
        "number": 2888,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Sin = map(int, stdin.split())\n    E = list(map(int, stdin.split()))\n\n    def train(S):\n        return S + sum(map(int, str(S)))**3\n\n    def battle(S, Ei):\n        return S * Ei\n\n    def max_xp(N, Sin, E):\n        S = Sin\n        max_xp = 0\n        for i in range(N):\n            if i % 2 == 0:\n                S = train(S)\n            else:\n                max_xp += battle(S, E[i])\n        return max_xp\n\n    return str(max_xp(N, Sin, E))"
    },
    {
        "number": 2889,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lawn_size, num_mowers = map(int, stdin.split()[0:2])\n    lawn_mowers = []\n    for i in range(num_mowers):\n        name, price, cutting_rate, cutting_time, recharge_time = stdin.split(',')[i*5:(i+1)*5]\n        lawn_mowers.append((name, int(price), int(cutting_rate), int(cutting_time), int(recharge_time)))\n    \n    def lawn_cut_time(lawn_size, cutting_rate, cutting_time):\n        return lawn_size / cutting_rate * cutting_time\n    \n    def weekly_cuts(lawn_size, cutting_rate, cutting_time, recharge_time):\n        cut_time = lawn_cut_time(lawn_size, cutting_rate, cutting_time)\n        recharge_time = recharge_time\n        weekly_cuts = 0\n        while cut_time + recharge_time <= 10080:\n            weekly_cuts += 1\n            cut_time += recharge_time\n        return weekly_cuts\n    \n    cheapest_mower = min(lawn_mowers, key=lambda x: x[1])\n    cheapest_mower_weekly_cuts = weekly_cuts(lawn_size, cheapest_mower[2], cheapest_mower[3], cheapest_mower[4])\n    \n    if cheapest_mower_weekly_cuts >= 1:\n        return cheapest_mower[0]\n    else:\n        return \"no such mower\""
    },
    {
        "number": 2890,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        lines = stdin.split('\\n')\n        N, M, k1, k2 = map(int, lines[0].split())\n        tracks = []\n        for i in range(1, M + 1):\n            U, V, X, C = map(int, lines[i].split())\n            tracks.append((U, V, X, C))\n        S, T = map(int, lines[-1].split())\n        return N, M, k1, k2, tracks, S, T\n\n    def find_path(N, M, k1, k2, tracks, S, T):\n        red_tracks = [t for t in tracks if t[3] == 1]\n        blue_tracks = [t for t in tracks if t[3] == 2]\n        white_tracks = [t for t in tracks if t[3] == 0]\n\n        def dfs(current, visited, time, red_count, blue_count):\n            if current == T:\n                return time\n            for track in tracks:\n                if track[0] == current and track[1] not in visited and (track[3] == 0 or (track[3] == 1 and red_count < k1) or (track[3] == 2 and blue_count < k2)):\n                    visited.add(track[1])\n                    new_time = time + track[2]\n                    new_red_count = red_count + (1 if track[3] == 1 else 0)\n                    new_blue_count = blue_count + (1 if track[3] == 2 else 0)\n                    result = dfs(track[1], visited, new_time, new_red_count, new_blue_count)\n                    if result != -1:\n                        return result\n                    visited.remove(track[1])\n            return -1\n\n        return dfs(S, set(), 0, 0, 0)\n\n    N, M, k1, k2, tracks, S, T = read_input()\n    result = find_path(N, M, k1, k2, tracks, S, T)\n    return str(result)"
    },
    {
        "number": 2891,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    c = list(map(int, stdin.split()[1:]))\n    total_combinations = 365**n\n    same_birthday_combinations = 1\n    for i in range(n):\n        same_birthday_combinations *= c[i]\n    different_birthday_combinations = total_combinations - same_birthday_combinations\n    probability = same_birthday_combinations / total_combinations\n    return str(round(math.log10(probability), 6))"
    },
    {
        "number": 2892,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sizes = stdin.split()\n    n = int(n)\n    sizes = [int(size) for size in sizes.split()]\n\n    def find_matryoshka_sets(sizes: List[int]) -> List[List[int]]:\n        sets = []\n        current_set = []\n        for size in sizes:\n            if not current_set or size == current_set[-1] + 1:\n                current_set.append(size)\n            else:\n                sets.append(current_set)\n                current_set = [size]\n        sets.append(current_set)\n        return sets\n\n    def count_openings(sets: List[List[int]]) -> int:\n        openings = 0\n        for i in range(len(sets)):\n            for j in range(i + 1, len(sets)):\n                if sets[i][-1] == sets[j][0]:\n                    openings += 2\n        return openings\n\n    sets = find_matryoshka_sets(sizes)\n    if len(sets) == 1:\n        return \"impossible\"\n    else:\n        return str(count_openings(sets))"
    },
    {
        "number": 2893,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    input_sequence = stdin.split('\\n')[1:]\n    input_sequence = [int(x) for x in input_sequence]\n\n    op = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if input_sequence[i] > input_sequence[j]:\n                input_sequence[i], input_sequence[j] = input_sequence[j], input_sequence[i]\n                op += 1\n\n    return str(op)"
    },
    {
        "number": 2894,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, K, T1, T2, H = map(float, stdin.split())\n    F1 = (H - L) / (K * 3600)\n    F2 = (H - L) / (K * 3600) + (T1 * 3600)\n    return f\"{F1:.6f} {F2:.6f}\""
    },
    {
        "number": 2895,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, x_f, y_f = map(float, stdin.readline().split())\n    n = int(stdin.readline())\n    y_layers = list(map(float, stdin.readline().split()))\n    speeds = list(map(float, stdin.readline().split()))\n\n    # Calculate the time required for each layer\n    layer_times = []\n    for i in range(n):\n        layer_width = abs(y_layers[i] - y_layers[i - 1])\n        layer_time = layer_width / speeds[i]\n        layer_times.append(layer_time)\n\n    # Calculate the total time required\n    total_time = sum(layer_times)\n\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 2896,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    before, after = stdin.split()\n    min_length = len(before)\n\n    for i in range(len(before)):\n        for j in range(i + 1, len(before) + 1):\n            if before[i:j] == after[i:j]:\n                min_length = min(min_length, j - i)\n\n    return str(min_length)"
    },
    {
        "number": 2897,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(map_: List[str], r1: int, c1: int, r2: int, c2: int) -> bool:\n        if r1 == r2 and c1 == c2:\n            return True\n        if r1 == r2:\n            return map_[r1][min(c1, c2)] == map_[r2][max(c1, c2)]\n        if c1 == c2:\n            return map_[min(r1, r2)][c1] == map_[max(r1, r2)][c2]\n        return False\n\n    lines = stdin.split(\"\\n\")\n    r, c = map(int, lines[0].split())\n    map_ = lines[1:r+1]\n    n = int(lines[r+1])\n    queries = [list(map(int, line.split())) for line in lines[r+2:]]\n\n    result = []\n    for query in queries:\n        r1, c1, r2, c2 = query\n        if is_valid_move(map_, r1, c1, r2, c2):\n            result.append(\"decimal\")\n        else:\n            result.append(\"neither\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2898,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    drives = []\n    for i in range(1, n+1):\n        a, b = map(int, lines[i].split())\n        drives.append((a, b))\n\n    total_capacity = sum(a for a, _ in drives)\n    extra_capacity = 0\n\n    for i in range(n):\n        a, b = drives[i]\n        if b > a:\n            extra_capacity += b - a\n\n    return str(extra_capacity)"
    },
    {
        "number": 2899,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_frequencies(graph: List[List[int]]) -> List[int]:\n        def dfs(node: int, visited: Set[int], frequencies: List[int]) -> None:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    dfs(neighbor, visited, frequencies)\n            frequencies.append(node)\n\n        visited = set()\n        frequencies = []\n        for node in range(1, len(graph) + 1):\n            if node not in visited:\n                dfs(node, visited, frequencies)\n        return frequencies\n\n    def assign_frequencies(graph: List[List[int]], frequencies: List[int]) -> List[Tuple[int, int]]:\n        def dfs(node: int, used_frequencies: Set[int], assigned_frequencies: List[Tuple[int, int]]) -> None:\n            used_frequencies.add(node)\n            for neighbor in graph[node - 1]:\n                if neighbor not in used_frequencies:\n                    dfs(neighbor, used_frequencies, assigned_frequencies)\n            assigned_frequencies.append((node, frequencies[node - 1]))\n\n        used_frequencies = set()\n        assigned_frequencies = []\n        for node in range(1, len(graph) + 1):\n            if node not in used_frequencies:\n                dfs(node, used_frequencies, assigned_frequencies)\n        return assigned_frequencies\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        i, j = map(int, stdin.readline().split())\n        graph[i - 1].append(j)\n        graph[j - 1].append(i)\n\n    frequencies = find_frequencies(graph)\n    assigned_frequencies = assign_frequencies(graph, frequencies)\n    for node, frequency in assigned_frequencies:\n        print(frequency, end=' ')\n        print(frequency + 1)"
    },
    {
        "number": 2900,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    inversions = [0] * (n-1)\n    \n    for i in range(n-1):\n        for j in range(i+1, n):\n            if s[i] == 'B' and s[j] == 'A' and j-i == i+1:\n                inversions[i] += 1\n            elif s[i] == 'A' and s[j] == 'B' and j-i == i+1:\n                inversions[j-1] += 1\n    \n    result = \"\"\n    for i in range(n-1):\n        result += str(inversions[i]) + \"\\n\"\n    \n    return result"
    },
    {
        "number": 2901,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_synergy_score(player1, player2):\n        if player1[\"country\"] == player2[\"country\"]:\n            if player1[\"league\"] == player2[\"league\"]:\n                if player1[\"team\"] == player2[\"team\"]:\n                    return 3\n                else:\n                    return 2\n            else:\n                return 2\n        else:\n            return 1\n\n    def is_perfect_team(formation, players):\n        graph = [[] for _ in range(10)]\n        for edge in formation:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n\n        for node in range(10):\n            synergy_score = 0\n            for neighbor in graph[node]:\n                for player in players:\n                    synergy_score += get_synergy_score(player, players[neighbor])\n            if synergy_score < len(graph[node]):\n                return False\n        return True\n\n    def parse_player(player_str):\n        name, nation, league, team = player_str.split()\n        return {\"name\": name, \"country\": nation, \"league\": league, \"team\": team}\n\n    stdin_lines = stdin.split(\"\\n\")\n    num_edges = int(stdin_lines[0])\n    formation = [tuple(map(int, line.split())) for line in stdin_lines[1:num_edges+1]]\n    players = {i: parse_player(line) for i, line in enumerate(stdin_lines[num_edges+1:])}\n\n    return \"yes\" if is_perfect_team(formation, players) else \"no\""
    },
    {
        "number": 2902,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, N, M = map(int, stdin.split()[:3])\n    farms = list(map(int, stdin.split()[3:3+N]))\n    days = list(map(int, stdin.split()[3+N:]))\n\n    def inspect_farms(cows: int) -> int:\n        return (cows // C) + (cows % C > 0)\n\n    for day in days:\n        farms_inspected = sum(inspect_farms(cows) for cows in farms)\n        print(farms_inspected)"
    },
    {
        "number": 2903,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def update(i, delta):\n        while i <= n:\n            bit[i] += delta\n            i += i & -i\n\n    def query(i):\n        s = 0\n        while i > 0:\n            s += bit[i]\n            i -= i & -i\n        return s\n\n    lines = stdin.split('\\n')\n    n, q = map(int, lines[0].split())\n    bit = [0] * (n + 1)\n\n    for line in lines[1:]:\n        if line[0] == '+':\n            _, i, delta = line.split()\n            update(int(i), int(delta))\n        elif line[0] == '?':\n            _, i = line.split()\n            print(query(int(i)))"
    },
    {
        "number": 2904,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    rows, cols = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:rows+1]]\n    regions = []\n    for i in range(int(lines[-1])):\n        region = []\n        for cell in lines[-i-2].split()[1:]:\n            row, col = map(int, cell[1:-1].split(','))\n            region.append((row-1, col-1))\n        regions.append(region)\n    \n    def is_valid(row, col, num):\n        for i in range(rows):\n            if grid[row][i] == num or grid[i][col] == num:\n                return False\n        for r, c in regions[row//3*3+col//3]:\n            if grid[r][c] == num:\n                return False\n        return True\n    \n    def solve():\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] == '-':\n                    for num in range(1, rows*cols+1):\n                        if is_valid(row, col, str(num)):\n                            grid[row][col] = str(num)\n                            if solve():\n                                return True\n                            grid[row][col] = '-'\n                    return False\n        return True\n    \n    solve()\n    return '\\n'.join([' '.join(row) for row in grid])"
    },
    {
        "number": 2905,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hotdog_packs, bun_packs = stdin.split(\"\\n\")\n    hotdog_packs = list(map(int, hotdog_packs.split()))\n    bun_packs = list(map(int, bun_packs.split()))\n\n    hotdog_count = sum(hotdog_packs)\n    bun_count = sum(bun_packs)\n\n    if hotdog_count % 10 != 0 or bun_count % 10 != 0:\n        return \"impossible\"\n\n    hotdog_count //= 10\n    bun_count //= 10\n\n    hotdog_packs.sort(reverse=True)\n    bun_packs.sort(reverse=True)\n\n    hotdog_packs_count = len(hotdog_packs)\n    bun_packs_count = len(bun_packs)\n\n    hotdog_packs_index = 0\n    bun_packs_index = 0\n\n    total_packs = 0\n\n    while hotdog_count > 0 and bun_packs_index < bun_packs_count:\n        if hotdog_packs[hotdog_packs_index] == bun_packs[bun_packs_index]:\n            total_packs += 1\n            hotdog_count -= 10\n            bun_count -= 10\n            hotdog_packs_index += 1\n            bun_packs_index += 1\n        elif hotdog_packs[hotdog_packs_index] > bun_packs[bun_packs_index]:\n            total_packs += hotdog_packs[hotdog_packs_index] // 10\n            hotdog_count -= hotdog_packs[hotdog_packs_index]\n            hotdog_packs_index += 1\n        else:\n            total_packs += bun_packs[bun_packs_index] // 10\n            bun_count -= bun_packs[bun_packs_index]\n            bun_packs_index += 1\n\n    if hotdog_count > 0:\n        return \"impossible\"\n\n    return str(total_packs)"
    },
    {
        "number": 2906,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_target(player: int, seen: set, targets: set) -> int:\n        if player in seen:\n            return -1\n        seen.add(player)\n        for target in targets:\n            if target not in seen and find_target(target, seen, targets) == -1:\n                return target\n        return -1\n\n    N, M = map(int, stdin.split()[0:2])\n    seen = set()\n    targets = set(range(1, N + 1))\n    result = []\n\n    for _ in range(M):\n        A, B = map(int, stdin.split()[2:])\n        targets.remove(A)\n        targets.remove(B)\n\n    for player in range(1, N + 1):\n        target = find_target(player, seen, targets)\n        if target == -1:\n            return \"Impossible\"\n        result.append(target)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2907,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    offset, message, num_steps = stdin.split('\\n')\n    offset = int(offset)\n    num_steps = int(num_steps)\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'y'}\n    consonants = set('abcdefghijklmnopqrstuvwxyz') - vowels\n    \n    def count_vowels_consonants(s: str) -> tuple:\n        vowel_count = 0\n        consonant_count = 0\n        for char in s:\n            if char in vowels:\n                vowel_count += 1\n            elif char in consonants:\n                consonant_count += 1\n        return vowel_count, consonant_count\n    \n    def caesar_cipher(s: str, offset: int) -> str:\n        result = ''\n        for char in s:\n            if char.isalpha():\n                shift = ord(char) - ord('a')\n                new_char = chr(((shift + offset) % 26) + ord('a'))\n                result += new_char\n            else:\n                result += char\n        return result\n    \n    def count_steps_good_bad(message: str, num_steps: int) -> tuple:\n        good_steps = 0\n        bad_steps = 0\n        for i in range(num_steps):\n            encoded_message = caesar_cipher(message, offset)\n            vowel_count, consonant_count = count_vowels_consonants(encoded_message)\n            if vowel_count * 2 <= consonant_count:\n                bad_steps += 1\n            else:\n                good_steps += 1\n            message = encoded_message\n        return good_steps, bad_steps\n    \n    good_steps, bad_steps = count_steps_good_bad(message, num_steps)\n    \n    if good_steps > bad_steps:\n        return 'Boris'\n    else:\n        return 'Colleague'"
    },
    {
        "number": 2908,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    cards = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if cards[i] + cards[j] == s:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2909,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, line1, line2 = stdin.split('\\n')\n    N = int(N)\n    breads = list(map(int, line1.split()))\n    boss_order = list(map(int, line2.split()))\n\n    def rotate_right(breads: list, start: int, end: int) -> None:\n        while start < end:\n            breads[start], breads[end] = breads[end], breads[start]\n            start += 1\n            end -= 1\n\n    for i in range(N - 2):\n        if breads[i + 1] == boss_order[i]:\n            rotate_right(breads, i, i + 2)\n            if breads == boss_order:\n                return \"Possible\"\n    return \"Impossible\""
    },
    {
        "number": 2910,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    B = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_area = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            total_area[i][j] = (i + j) % 3\n\n    total_yellow = 0\n    total_pink = 0\n    total_white = 0\n\n    for i in range(n):\n        for j in range(n):\n            area = A[i] * B[j]\n            if total_area[i][j] == 0:\n                total_yellow += area\n            elif total_area[i][j] == 1:\n                total_pink += area\n            else:\n                total_white += area\n\n    return f\"{total_yellow} {total_pink} {total_white}\""
    },
    {
        "number": 2911,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    times = list(map(int, stdin.split()[2:]))\n\n    # Calculate the probability of each problem being solved\n    probabilities = [1 / (t - time + 1) for time in times]\n\n    # Calculate the probability of the two events happening together\n    p = 1\n    for probability in probabilities:\n        p *= probability\n\n    # Calculate the result\n    result = int(p * t ** n) % 998244353\n\n    return str(result)"
    },
    {
        "number": 2912,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    strings = lines[1:N+1]\n    operations = [tuple(map(int, line.split())) for line in lines[N+1:]]\n\n    for a, b in operations:\n        strings[a-1] += strings[b-1]\n        strings[b-1] = \"\"\n\n    return strings[-1]"
    },
    {
        "number": 2913,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split()[:3])\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    laser_pos = (c-1, r-1)\n    sensor_pos = (n-1, r-1)\n    mirrors = []\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '\\\\':\n                mirrors.append((i, j))\n            elif grid[i][j] == '/':\n                mirrors.append((i, j))\n\n    def is_valid_position(pos):\n        x, y = pos\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return False\n        for mirror in mirrors:\n            if mirror[0] == x and mirror[1] == y:\n                return False\n        return True\n\n    def bfs(start, end):\n        queue = [(start, [])]\n        visited = set()\n\n        while queue:\n            current, path = queue.pop(0)\n            if current == end:\n                return path\n            if current not in visited:\n                visited.add(current)\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_pos = (current[0] + dx, current[1] + dy)\n                    if is_valid_position(new_pos):\n                        queue.append((new_pos, path + [new_pos]))\n\n        return None\n\n    path = bfs(laser_pos, sensor_pos)\n\n    if path is None:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(n):\n            if (i, j) not in path:\n                if is_valid_position((i, j)):\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2914,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    total_combinations = s ** n\n    unique_combinations = 0\n    for i in range(k, s + 1):\n        unique_combinations += comb(s, i)\n    probability = unique_combinations / total_combinations\n    return f\"{probability:.9f}\"\n\ndef"
    },
    {
        "number": 2915,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    locations = []\n    for i in range(N):\n        x, t = map(int, stdin.split()[2*i:2*(i+1)])\n        locations.append((x, t))\n    \n    locations.sort(key=lambda x: x[0])\n    current_location = 0\n    total_distance = 0\n    \n    for location in locations:\n        if current_location + location[1] > K:\n            total_distance += 2 * abs(current_location - location[0])\n            current_location = location[0]\n        else:\n            current_location += location[1]\n    \n    total_distance += 2 * abs(current_location - 0)\n    \n    return str(total_distance)"
    },
    {
        "number": 2916,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int]]]]]:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        islands = []\n        for i in range(1, n + 1):\n            t, k = map(int, lines[i].split())\n            sources = []\n            for j in range(k):\n                s, v = map(int, lines[i + j + 1].split())\n                sources.append((s, v))\n            islands.append((t, k, sources))\n        return n, islands\n\n    def simulate(n: int, islands: List[Tuple[int, int, List[Tuple[int, int]]]]) -> int:\n        survivors = [True] * n\n        while True:\n            for i in range(n):\n                if not survivors[i]:\n                    continue\n                t, k, sources = islands[i]\n                incoming = sum(v for s, v in sources if survivors[s - 1])\n                if incoming < t:\n                    survivors[i] = False\n            if all(not survivor for survivor in survivors):\n                return 0\n            if all(survivor for survivor in survivors):\n                return n\n            for i in range(n):\n                if survivors[i]:\n                    return i + 1\n\n    n, islands = read_input()\n    return str(simulate(n, islands))"
    },
    {
        "number": 2917,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    C = [1, 1]\n    for i in range(2, n + 1):\n        C.append(0)\n        for k in range(i + 1):\n            C[i] += C[k] * C[i - k]\n    return str(C[n])"
    },
    {
        "number": 2918,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    matrix = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def is_win(i, j):\n        return matrix[i][j] == '1'\n\n    def is_lose(i, j):\n        return matrix[i][j] == '0'\n\n    def is_tie(i, j):\n        return matrix[i][j] == 'X'\n\n    def is_valid(i, j):\n        return i != j and not is_tie(i, j)\n\n    def find_winner(i, j):\n        if is_win(i, j):\n            return i\n        elif is_lose(i, j):\n            return j\n        else:\n            return None\n\n    def find_next_challenge(i, j):\n        for k in range(n):\n            if k != i and k != j and is_valid(i, k):\n                return k\n        return None\n\n    def rig_game(i, j):\n        if is_win(i, j) or is_lose(i, j):\n            return False\n        else:\n            winner = find_winner(i, j)\n            if winner is None:\n                return False\n            else:\n                matrix[i][j] = '1' if winner == i else '0'\n                return True\n\n    def rig_tournament():\n        schedule = [0]\n        while len(schedule) < n:\n            i = schedule[-1]\n            j = find_next_challenge(i, j)\n            if j is None:\n                return \"impossible\"\n            else:\n                schedule.append(j)\n                if rig_game(i, j):\n                    return \" \".join(map(str, schedule))\n        return \"impossible\"\n\n    return rig_tournament()"
    },
    {
        "number": 2919,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i in range(0, len(stdin), 2):\n        if stdin[i] == 'S':\n            if stdin[i+1] == 'S':\n                stack.append(1)\n            else:\n                stack.append(-1)\n            for j in range(i+2, len(stdin), 2):\n                if stdin[j] == 'S':\n                    stack[-1] *= 2\n                else:\n                    stack[-1] *= -2\n                    stack[-1] += 1\n                    break\n        elif stdin[i] == 'N':\n            if len(stack) < 2:\n                print(\"Invalid copy operation\")\n            else:\n                stack.append(stack[-1])\n        elif stdin[i] == 'T':\n            if len(stack) < 2:\n                print(\"Invalid swap operation\")\n            else:\n                stack[-1], stack[-2] = stack[-2], stack[-1]\n        else:\n            if len(stack) < 1:\n                print(\"Invalid remove operation\")\n            else:\n                stack.pop()\n    return str(stack[-1])"
    },
    {
        "number": 2920,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    grid = [list(line) for line in stdin.splitlines()[1:]]\n    s = (0, 0)\n    t = (n-1, n-1)\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < n and grid[x][y] == '.'\n\n    def count_paths(x: int, y: int) -> int:\n        if (x, y) == t:\n            return 1\n        if not is_valid(x, y):\n            return 0\n        grid[x][y] = 'X'\n        right = count_paths(x, y+1)\n        down = count_paths(x+1, y)\n        grid[x][y] = '.'\n        return right + down\n\n    def can_go_up_left(x: int, y: int) -> bool:\n        if (x, y) == t:\n            return True\n        if not is_valid(x, y):\n            return False\n        grid[x][y] = 'X'\n        up_left = can_go_up_left(x-1, y-1)\n        grid[x][y] = '.'\n        return up_left\n\n    paths = count_paths(s[0], s[1])\n    if paths == 0 and can_go_up_left(s[0], s[1]):\n        return \"THE GAME IS A LIE\"\n    elif paths == 0:\n        return \"INCONCEIVABLE\"\n    else:\n        return str(paths % (2**31 - 1))"
    },
    {
        "number": 2921,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    money, units, drinks = map(float, stdin.split())\n    drinks_list = []\n    for i in range(int(drinks)):\n        name, strength, size, price = input().split()\n        drinks_list.append((name, int(strength), size, float(price)))\n\n    def can_buy(drink, units):\n        if drink[1] == 100:\n            return False\n        if drink[2] == '1/1':\n            return units >= 1\n        elif drink[2] == '1/2':\n            return units >= 0.5\n        else:\n            return units >= 1 / 3\n\n    def buy_drink(drink, units):\n        if drink[2] == '1/1':\n            return 1\n        elif drink[2] == '1/2':\n            return 0.5\n        else:\n            return 1 / 3\n\n    def buy_drinks(drinks_list, units):\n        drinks_bought = {}\n        for drink in drinks_list:\n            if can_buy(drink, units):\n                count = buy_drink(drink, units)\n                if drink[0] in drinks_bought:\n                    drinks_bought[drink[0]] += count\n                else:\n                    drinks_bought[drink[0]] = count\n                units -= count\n        return drinks_bought\n\n    result = buy_drinks(drinks_list, units)\n    if not result:\n        return \"IMPOSSIBLE\"\n    else:\n        return \"\\n\".join([f\"{name} {count}\" for name, count in result.items()])"
    },
    {
        "number": 2922,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    chocolates = list(map(int, stdin.split('\\n')[1].split()))\n    chocolates.sort()\n    total_chocolates = sum(chocolates)\n    target = total_chocolates // 2\n\n    for i in range(n):\n        if chocolates[i] > target:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2923,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def dfs(x: int, y: int, visited: set) -> set:\n        if x < 0 or x >= w or y < 0 or y >= h or grid[y][x] == 'B' or (x, y) in visited:\n            return visited\n        visited.add((x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            visited = dfs(x + dx, y + dy, visited)\n        return visited\n\n    visited_a = set()\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] == 'A':\n                visited_a.update(dfs(x, y, set()))\n\n    visited_b = set()\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] == 'B':\n                visited_b.update(dfs(x, y, set()))\n\n    return str(len(visited_a) + len(visited_b))"
    },
    {
        "number": 2924,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, P = map(int, stdin.split()[:3])\n    C = list(map(int, stdin.split()[3:3+N]))\n    D = list(map(int, stdin.split()[3+N:]))\n    \n    # Calculate the gear ratio for each gear\n    gear_ratios = [c/d for c, d in zip(C, D)]\n    \n    # Sort the gear ratios in descending order\n    gear_ratios.sort(reverse=True)\n    \n    # Calculate the cadence change for each gear change\n    cadence_changes = [(gear_ratios[i] - gear_ratios[i+1]) * 100 for i in range(len(gear_ratios)-1)]\n    \n    # Check if any cadence change is greater than the maximum allowed change\n    if any(abs(change) > P for change in cadence_changes):\n        return \"Time to change gears!\"\n    else:\n        return \"Ride on!\""
    },
    {
        "number": 2925,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    songs = []\n    for line in stdin.split('\\n')[2:]:\n        if not line:\n            break\n        freq, name = line.split()\n        songs.append((int(freq), name))\n\n    def zipf_law(n: int) -> int:\n        return 1 / (n + 1)\n\n    def quality(freq: int, zipf_freq: int) -> float:\n        return freq / zipf_freq\n\n    songs.sort(key=lambda x: (x[0], -songs.index(x)))\n    sorted_songs = sorted(songs, key=lambda x: (quality(x[0], zipf_law(songs.index(x) + 1)), -songs.index(x)))\n    return '\\n'.join([song[1] for song in sorted_songs[:m]])"
    },
    {
        "number": 2926,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    categories = {}\n    num_categories = int(stdin.split('\\n')[0])\n    for i in range(1, num_categories + 1):\n        category_info = stdin.split('\\n')[i].split()\n        category_name = category_info[0]\n        category_words = category_info[1:]\n        categories[category_name] = category_words\n\n    statement = stdin.split('\\n')[num_categories + 1:]\n\n    category_matches = {}\n    for category_name, category_words in categories.items():\n        category_matches[category_name] = 0\n        for word in statement:\n            for category_word in category_words:\n                if category_word in word:\n                    category_matches[category_name] += 1\n\n    suggested_categories = sorted([category for category, count in category_matches.items() if count == max(category_matches.values())])\n\n    return '\\n'.join(suggested_categories)"
    },
    {
        "number": 2927,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plays, *yards = stdin.split()\n    plays = int(plays)\n    total_yards = 0\n    for play in yards:\n        total_yards += int(play)\n    if total_yards >= 80:\n        return \"Touchdown\"\n    elif total_yards <= -20:\n        return \"Safety\"\n    else:\n        return \"Nothing\""
    },
    {
        "number": 2928,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    B = int(lines[0])\n    tax_bands = []\n    for i in range(1, B + 1):\n        s, p = map(float, lines[i].split())\n        tax_bands.append((s, p))\n    P = float(lines[B + 1])\n    F = int(lines[B + 2])\n    friends = []\n    for j in range(F):\n        e, m = map(float, lines[B + 3 + j].split())\n        friends.append((e, m))\n\n    # Calculate tax for each friend\n    for j in range(F):\n        e, m = friends[j]\n        tax = 0\n        for s, p in tax_bands:\n            if e <= s:\n                tax += e * p / 100\n                break\n            else:\n                tax += s * p / 100\n                e -= s\n        tax += (e * P / 100)\n        friends[j] = (e, m - tax)\n\n    # Output result\n    result = []\n    for j in range(F):\n        _, m = friends[j]\n        result.append(f\"{m:.6f}\")\n    return '\\n'.join(result)"
    },
    {
        "number": 2929,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    grid = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_submerged(i: int, j: int) -> bool:\n        return grid[i][j] < water_level\n\n    def neighbors(i: int, j: int) -> List[Tuple[int, int]]:\n        return [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n\n    def bfs(start: Tuple[int, int], target: Tuple[int, int]) -> int:\n        queue = deque([start])\n        visited = set([start])\n        distance = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                current = queue.popleft()\n\n                if current == target:\n                    return distance\n\n                for neighbor in neighbors(*current):\n                    if is_submerged(*neighbor) and neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n\n            distance += 1\n\n        return -1\n\n    water_level = 1\n    exit_location = (N - 1, N - 1)\n    start_location = (0, 0)\n\n    while not is_submerged(*exit_location):\n        water_level += 1\n\n    return bfs(start_location, exit_location)"
    },
    {
        "number": 2930,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nums = [int(line) for line in stdin.split('\\n')[1:]]\n    \n    def is_zigzag(nums: List[int]) -> bool:\n        increasing = True\n        for i in range(len(nums) - 1):\n            if increasing:\n                if nums[i] >= nums[i + 1]:\n                    return False\n            else:\n                if nums[i] <= nums[i + 1]:\n                    return False\n            increasing = not increasing\n        return True\n    \n    longest_zigzag = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_zigzag(nums[i:j + 1]):\n                longest_zigzag = max(longest_zigzag, j - i + 1)\n    \n    return str(longest_zigzag)"
    },
    {
        "number": 2931,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    results = []\n\n    for i in range(1, N + 1):\n        points = list(map(int, lines[i].split()))\n        if points[0] > points[1]:\n            highest = 2 * points[0] + points[1]\n            lowest = 2 * points[0] + points[1]\n        else:\n            highest = 2 * points[1] + points[0]\n            lowest = 2 * points[0] + points[1]\n        results.append((highest, lowest))\n\n    return '\\n'.join(f'{highest} {lowest}' for highest, lowest in results)"
    },
    {
        "number": 2932,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = list(s)\n    n = len(s)\n\n    def merge_sort(arr: list) -> list:\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left: list, right: list) -> list:\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def can_swap(i: int, j: int) -> bool:\n        return abs(i - j) >= k\n\n    def swap(i: int, j: int) -> None:\n        s[i], s[j] = s[j], s[i]\n\n    def sort_string(arr: list) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if arr[i] > arr[j]:\n                    if can_swap(i, j):\n                        swap(i, j)\n                    else:\n                        return False\n        return True\n\n    sorted_s = merge_sort(s)\n    if sorted_s == s:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2933,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    weights = [int(line) for line in stdin.split('\\n')[1:n+1]]\n    weights.sort(reverse=True)\n    closest = 1000\n    for i in range(len(weights)):\n        if weights[i] + sum(weights[i+1:]) >= closest:\n            break\n        if weights[i] + sum(weights[i+1:]) < closest:\n            closest = weights[i] + sum(weights[i+1:])\n    return str(closest)"
    },
    {
        "number": 2934,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    modulo = 10**9\n\n    # Calculate the number of ways to tile the table with round macarons\n    round_macarons = N * M // 2\n    # Calculate the number of ways to tile the table with oval-shaped macarons\n    oval_macarons = (N // 2) * (M // 2)\n\n    # Calculate the total number of tilings\n    total_tilings = (round_macarons * oval_macarons) % modulo\n\n    return str(total_tilings)"
    },
    {
        "number": 2935,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, f, s, t = map(int, stdin.split()[:5])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[1:1+m]]\n    flights = [list(map(int, line.split())) for line in stdin.split('\\n')[1+m:1+m+f]]\n\n    # Initialize the distance matrix\n    distance = [[float('inf')] * n for _ in range(n)]\n    for i, j, c in roads:\n        distance[i][j] = c\n        distance[j][i] = c\n\n    # Floyd-Warshall algorithm to find the shortest path between any two cities\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    # Find the shortest path using at most one flight\n    min_cost = float('inf')\n    for i in range(n):\n        if i == s:\n            continue\n        for j in range(n):\n            if j == t:\n                continue\n            for u, v in flights:\n                if distance[i][u] == float('inf') or distance[v][j] == float('inf'):\n                    continue\n                min_cost = min(min_cost, distance[i][u] + distance[v][j])\n\n    return str(min_cost)"
    },
    {
        "number": 2936,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    A = list(map(int, stdin.split()[1].split()))\n\n    # Your algorithm to solve the k-maximum subarray problem\n\n    return str(max_sum)"
    },
    {
        "number": 2937,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = map(int, stdin.split()[:3])\n    kids = stdin.split('\\n')[3:n+3]\n    enemies = [tuple(line.split()) for line in stdin.split('\\n')[n+3:n+k+3]]\n    \n    # Create a dictionary of kids and their enemies\n    enemy_dict = {}\n    for enemy in enemies:\n        if enemy[0] not in enemy_dict:\n            enemy_dict[enemy[0]] = set()\n        if enemy[1] not in enemy_dict:\n            enemy_dict[enemy[1]] = set()\n        enemy_dict[enemy[0]].add(enemy[1])\n        enemy_dict[enemy[1]].add(enemy[0])\n    \n    # Create a list of groups\n    groups = []\n    for kid in kids:\n        group = []\n        for enemy in enemy_dict[kid]:\n            if enemy not in group:\n                group.append(enemy)\n        groups.append(group)\n    \n    # Merge groups with common enemies\n    merged_groups = []\n    for i in range(len(groups)):\n        if i not in merged_groups:\n            for j in range(i+1, len(groups)):\n                if j not in merged_groups:\n                    if set(groups[i]) & set(groups[j]):\n                        groups[i] = list(set(groups[i]) | set(groups[j]))\n                        merged_groups.append(j)\n            merged_groups.append(i)\n    \n    # Create the final groups\n    final_groups = []\n    for i in range(len(groups)):\n        if i not in merged_groups:\n            final_groups.append(groups[i])\n    \n    # Output the minimum number of groups and the groups\n    output = str(len(final_groups)) + '\\n'\n    for group in final_groups:\n        output += ' '.join(group) + '\\n'\n    return output"
    },
    {
        "number": 2938,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.splitlines()]\n    rook_pos = None\n    king_pos = None\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                rook_pos = (i, j)\n            elif board[i][j] == 'K':\n                king_pos = (i, j)\n            elif board[i][j] == 'k':\n                opponent_king_pos = (i, j)\n\n    def is_threatened(pos):\n        i, j = pos\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                if di == 0 and dj == 0:\n                    continue\n                ni, nj = i + di, j + dj\n                if 0 <= ni < 8 and 0 <= nj < 8:\n                    if board[ni][nj] == 'k':\n                        return True\n        return False\n\n    if is_threatened(opponent_king_pos):\n        return \"No\"\n\n    def is_valid_move(pos):\n        i, j = pos\n        if board[i][j] == '.':\n            return True\n        elif board[i][j] == 'k':\n            return False\n        else:\n            return True\n\n    def is_checkmate():\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'R':\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            if di == 0 and dj == 0:\n                                continue\n                            ni, nj = i + di, j + dj\n                            if 0 <= ni < 8 and 0 <= nj < 8:\n                                if is_valid_move((ni, nj)):\n                                    board[i][j], board[ni][nj] = board[ni][nj], board[i][j]\n                                    if not is_threatened(opponent_king_pos):\n                                        board[i][j], board[ni][nj] = board[ni][nj], board[i][j]\n                                        return True\n                                    board[i][j], board[ni][nj] = board[ni][nj], board[i][j]\n        return False\n\n    if is_checkmate():\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2939,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grid = stdin.split('\\n')[1:]\n    grid = [list(map(int, row)) for row in grid]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, distance = queue.pop(0)\n            if current == end:\n                return distance\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in get_neighbors(current):\n                if grid[neighbor[0]][neighbor[1]] == 3:\n                    queue.append((neighbor, distance + 1))\n\n    def get_neighbors(position):\n        x, y = position\n        neighbors = []\n        if x > 0:\n            neighbors.append((x - 1, y))\n        if x < n - 1:\n            neighbors.append((x + 1, y))\n        if y > 0:\n            neighbors.append((x, y - 1))\n        if y < n - 1:\n            neighbors.append((x, y + 1))\n        return neighbors\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                distance = bfs((i, j), next(((x, y) for x in range(n) for y in range(n) if grid[x][y] == 3))[0])\n                max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 2940,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_concoct(recipe, used_ingredients):\n        for ingredient in recipe:\n            if ingredient not in used_ingredients:\n                return False\n        return True\n\n    def concoct(recipe, used_ingredients, cauldron):\n        for ingredient in recipe:\n            if ingredient not in used_ingredients:\n                cauldron.add(ingredient)\n        return cauldron\n\n    def pour_cauldron(cauldron, used_ingredients):\n        for ingredient in cauldron:\n            used_ingredients.add(ingredient)\n        cauldron.clear()\n\n    N = int(stdin.readline())\n    used_ingredients = set()\n    concocted_recipes = 0\n    cauldron = set()\n\n    for i in range(N):\n        M, *recipe = map(int, stdin.readline().split())\n        if can_concoct(recipe, used_ingredients):\n            concocted_recipes += 1\n            cauldron = concoct(recipe, used_ingredients, cauldron)\n        else:\n            pour_cauldron(cauldron, used_ingredients)\n\n    return str(concocted_recipes)"
    },
    {
        "number": 2941,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    N, K = map(int, queries[0].split())\n    patients = []\n    waiting_time = 0\n\n    for i in range(1, N + 1):\n        query_type, *query_data = queries[i].split()\n        query_type = int(query_type)\n\n        if query_type == 1:\n            arrival_time, name, severity = map(str, query_data)\n            arrival_time = int(arrival_time)\n            severity = int(severity)\n            waiting_time += arrival_time - waiting_time\n            patients.append((severity, name, waiting_time))\n\n        elif query_type == 2:\n            treatment_time = int(query_data[0])\n            waiting_time += treatment_time - waiting_time\n            patients.sort(reverse=True)\n            if patients:\n                patient_to_treat = patients.pop(0)\n                print(patient_to_treat[1])\n            else:\n                print(\"doctor takes a break\")\n\n        elif query_type == 3:\n            notification_time, name_to_remove = map(int, query_data)\n            waiting_time += notification_time - waiting_time\n            patients = [patient for patient in patients if patient[1] != name_to_remove]\n\n    return \"\" "
    },
    {
        "number": 2942,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D = int(stdin)\n    for n1 in range(0, 200000):\n        n2 = (D + n1**2)**0.5\n        if n2.is_integer() and n2 <= 200000:\n            return f\"{int(n1)} {int(n2)}\"\n    return \"impossible\""
    },
    {
        "number": 2943,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    raindrops = [stdin[i] for i in range(n)]\n    max_diff = 0\n    start = 0\n    end = 0\n\n    for i in range(n):\n        red = raindrops.count('R', 0, i + 1)\n        blue = raindrops.count('B', 0, i + 1)\n        diff = abs(red - blue)\n\n        if diff > max_diff:\n            max_diff = diff\n            start = 0\n            end = i\n        elif diff == max_diff:\n            if i > end:\n                end = i\n\n    return f\"{start + 1} {end + 1}\""
    },
    {
        "number": 2944,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m, d = map(int, input().split())\n        people = {}\n        for _ in range(n):\n            name, skepticism = input().split()\n            people[name] = int(skepticism)\n        connections = []\n        for _ in range(m):\n            u, v = input().split()\n            connections.append((u, v))\n        source = input()\n        return n, m, d, people, connections, source\n\n    def build_graph(connections, n):\n        graph = {i: [] for i in range(n)}\n        for u, v in connections:\n            graph[people[u]].append(people[v])\n            graph[people[v]].append(people[u])\n        return graph\n\n    def bfs(graph, start, d):\n        visited = [False] * len(graph)\n        queue = [start]\n        visited[start] = True\n        for _ in range(d):\n            new_queue = []\n            for node in queue:\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        new_queue.append(neighbor)\n            queue = new_queue\n        return sum(visited) - 1\n\n    n, m, d, people, connections, source = read_input()\n    graph = build_graph(connections, n)\n    return str(bfs(graph, people[source], d))"
    },
    {
        "number": 2945,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    total_time = int(lines[0])\n    monkeys_1 = []\n    monkeys_2 = []\n\n    for i in range(1, int(lines[1]) + 1):\n        monkeys_1.append(tuple(map(int, lines[i].split())))\n\n    for i in range(int(lines[1]) + 1, int(lines[1]) + int(lines[2]) + 1):\n        monkeys_2.append(tuple(map(int, lines[i].split())))\n\n    time_1 = sum(A * B for A, B in monkeys_1)\n    time_2 = sum(C * D for C, D in monkeys_2)\n\n    return str(total_time - time_1 - time_2)"
    },
    {
        "number": 2946,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split())\n    prices = list(map(int, stdin.split()[1].split()))\n    \n    max_profit = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            profit = (prices[j] - prices[i]) * (j - i - 1) - (j - i - 1) * K\n            if profit > max_profit:\n                max_profit = profit\n                \n    return f\"{max_profit:.1f}\""
    },
    {
        "number": 2947,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    individuals = {}\n    for i in range(1, n+1):\n        line = stdin.split('\\n')[i].split()\n        m = int(line[0])\n        numbers = [int(x) for x in line[1:]]\n        individuals[i] = numbers\n\n    # Check if there is a proof\n    proof = []\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in individuals[i]:\n                if k in individuals[j]:\n                    proof.append((i, j, k))\n                    break\n            else:\n                continue\n            break\n\n    if not proof:\n        return \"impossible\"\n\n    # Output the proof\n    output = \"\"\n    for p, q, r in proof:\n        output += f\"{p} {q} {r}\\n\"\n    return output.strip()"
    },
    {
        "number": 2948,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    photos = [line.split() for line in stdin.splitlines()[1:]]\n\n    parties = ['A', 'B']\n    party_map = {}\n\n    for i in range(N):\n        party_map[i] = parties[i % 2]\n\n    for photo in photos:\n        for i in range(0, len(photo), 2):\n            mp1 = int(photo[i]) - 1\n            mp2 = int(photo[i + 1]) - 1\n\n            if party_map[mp1] == party_map[mp2]:\n                if mp1 not in party_map:\n                    party_map[mp1] = parties[1 - parties.index(party_map[mp2])]\n                if mp2 not in party_map:\n                    party_map[mp2] = parties[1 - parties.index(party_map[mp1])]\n\n    return ''.join(party_map[i] for i in range(N))"
    },
    {
        "number": 2949,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pylons = []\n    for _ in range(n):\n        x, y, a = map(int, stdin.readline().strip().split())\n        pylons.append((x, y, a))\n\n    def is_valid(pylon1, pylon2):\n        x1, y1, a1 = pylon1\n        x2, y2, a2 = pylon2\n        return abs(y1 - y2) == 1\n\n    def is_opposite(pylon1, pylon2):\n        x1, y1, a1 = pylon1\n        x2, y2, a2 = pylon2\n        return a1 == 2 and a2 == 2 and (y1 - y2) * (x1 - x2) < 0\n\n    def is_connected(pylon1, pylon2):\n        x1, y1, a1 = pylon1\n        x2, y2, a2 = pylon2\n        return (a1 == 1 and a2 == 1) or (a1 == 2 and a2 == 2 and is_opposite(pylon1, pylon2))\n\n    def dfs(pylon, visited, lifts):\n        x, y, a = pylon\n        for i in range(n):\n            if i != pylon and not visited[i] and is_valid(pylon, pylons[i]):\n                visited[i] = True\n                lifts.add((x, y, pylons[i][0], pylons[i][1]))\n                dfs(pylons[i], visited, lifts)\n\n    max_lifts = 0\n    for i in range(n):\n        lifts = set()\n        visited = [False] * n\n        dfs(pylons[i], visited, lifts)\n        max_lifts = max(max_lifts, len(lifts))\n\n    return str(max_lifts)"
    },
    {
        "number": 2950,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, heights = stdin.split('\\n')\n    n = int(n)\n    heights = list(map(int, heights.split()))\n\n    floors_removed = 0\n    charges = 0\n\n    while floors_removed < n:\n        charges += 1\n        floors_removed += 1\n        for i in range(n):\n            if heights[i] > floors_removed:\n                heights[i] -= 1\n\n    return str(charges)"
    },
    {
        "number": 2951,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    a = [0] * N\n    b = [0] * N\n    for i in range(1, N+1):\n        a[i-1], b[i-1] = map(int, lines[i].split())\n\n    def count_matches(a, b, c):\n        return a * b * c\n\n    total_matches = 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                total_matches += count_matches(a[i], b[j], a[k] + b[k])\n\n    return str(total_matches)"
    },
    {
        "number": 2952,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b, c = map(int, stdin.split())\n    if a + b + c > m:\n        return \"impossible\"\n    else:\n        return \"possible\""
    },
    {
        "number": 2953,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(points[i][0] - points[j][0]) == 2018 and abs(points[i][1] - points[j][1]) == 2018:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2954,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M, T, roads, s, t, K, spiders = parse_input(stdin)\n\n    # Initialize distance matrix\n    distance_matrix = [[float('inf')] * N for _ in range(N)]\n    for i in range(N):\n        distance_matrix[i][i] = 0\n\n    # Fill distance matrix\n    for u, v, d in roads:\n        distance_matrix[u][v] = d\n        distance_matrix[v][u] = d\n\n    # Calculate minimum distance between any intersection and spider\n    min_distance = float('inf')\n    for i in range(N):\n        if i not in spiders:\n            for j in range(N):\n                if j in spiders:\n                    min_distance = min(min_distance, distance_matrix[i][j])\n\n    # Calculate maximum D\n    max_D = float('-inf')\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                max_D = max(max_D, distance_matrix[i][j] - min_distance)\n\n    return str(max_D)\n\ndef"
    },
    {
        "number": 2955,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, b, broken_bits = map(int, stdin.split())\n    broken_bits = set(map(int, broken_bits.split()))\n    hard_drive = [0] * n\n\n    # Fill the hard drive with ones and zeros\n    for i in range(n):\n        if i not in broken_bits:\n            hard_drive[i] = 1\n\n    # Count the number of bit changes\n    bit_changes = sum(hard_drive[i] != hard_drive[i + 1] for i in range(n - 1))\n\n    # If the number of bit changes is already greater than the desired amount, return the hard drive as is\n    if bit_changes > c:\n        return \"\".join(map(str, hard_drive))\n\n    # If the number of bit changes is already less than the desired amount, add more ones and zeros\n    while bit_changes < c:\n        for i in range(n):\n            if i not in broken_bits:\n                hard_drive[i] = 1 - hard_drive[i]\n                bit_changes += 1\n                if bit_changes == c:\n                    break\n        else:\n            continue\n        break\n\n    return \"\".join(map(str, hard_drive))"
    },
    {
        "number": 2956,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_patterns(turn_sequence: str, pivot: int, visited: set, current_direction: str, result: int) -> int:\n        if pivot == 9:\n            return result\n\n        if pivot == 1:\n            return count_patterns(turn_sequence, pivot + 1, visited | {pivot}, current_direction, result + 1)\n\n        if pivot in visited:\n            return count_patterns(turn_sequence, pivot + 1, visited, current_direction, result)\n\n        if turn_sequence[pivot - 1] == '?':\n            for direction in ['L', 'R', 'S', 'A']:\n                if direction == current_direction:\n                    continue\n                result = count_patterns(turn_sequence, pivot + 1, visited | {pivot}, direction, result)\n        else:\n            result = count_patterns(turn_sequence, pivot + 1, visited | {pivot}, turn_sequence[pivot - 1], result)\n\n        return result\n\n    return str(count_patterns(stdin, 1, set(), 'S', 0))"
    },
    {
        "number": 2957,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(n - 1)"
    },
    {
        "number": 2958,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, K = map(int, stdin.split()[0].split())\n    cards = list(map(int, stdin.split()[1].split()))\n    prices = [list(map(int, stdin.split()[i+2].split())) for i in range(T)]\n\n    def profit(card_counts: list) -> int:\n        total_profit = 0\n        for i in range(T):\n            if card_counts[i] == 0:\n                continue\n            if card_counts[i] == 1:\n                total_profit += prices[i][1]\n            else:\n                total_profit += prices[i][0]\n        return total_profit\n\n    def find_combo_count(card_counts: list) -> int:\n        combo_count = 0\n        for i in range(T):\n            if card_counts[i] >= 2:\n                combo_count += 1\n        return combo_count\n\n    def find_optimal_strategy(card_counts: list, target_combo_count: int) -> int:\n        if find_combo_count(card_counts) >= target_combo_count:\n            return profit(card_counts)\n\n        max_profit = float('-inf')\n        for i in range(T):\n            if card_counts[i] == 0:\n                continue\n            for j in range(2):\n                new_card_counts = card_counts.copy()\n                new_card_counts[i] -= 1\n                new_card_counts.append(1)\n                new_target_combo_count = target_combo_count - 1\n                new_profit = find_optimal_strategy(new_card_counts, new_target_combo_count)\n                if new_profit > max_profit:\n                    max_profit = new_profit\n\n        return max_profit\n\n    card_counts = [0] * T\n    for card in cards:\n        card_counts[card-1] += 1\n\n    target_combo_count = K\n    return find_optimal_strategy(card_counts, target_combo_count)"
    },
    {
        "number": 2959,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n    ring_count = 0\n    ring_numbers = {}\n    \n    def get_neighbors(x, y):\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m:\n                neighbors.append((nx, ny))\n        return neighbors\n    \n    def dfs(x, y, ring_number):\n        nonlocal ring_count\n        ring_count += 1\n        ring_numbers[(x, y)] = ring_number\n        for nx, ny in get_neighbors(x, y):\n            if grid[nx][ny] == 'T' and (nx, ny) not in ring_numbers:\n                dfs(nx, ny, ring_number)\n    \n    for x in range(n):\n        for y in range(m):\n            if grid[x][y] == 'T' and (x, y) not in ring_numbers:\n                dfs(x, y, ring_count)\n    \n    max_ring_number = max(ring_numbers.values(), default=0)\n    output = []\n    for x in range(n):\n        row = []\n        for y in range(m):\n            if grid[x][y] == 'T':\n                ring_number = ring_numbers.get((x, y), 0)\n                if max_ring_number < 10:\n                    row.append(str(ring_number).rjust(2, '.'))\n                else:\n                    row.append(str(ring_number).rjust(3, '.'))\n            else:\n                row.append('....')\n        output.append(''.join(row))\n    \n    return '\\n'.join(output)"
    },
    {
        "number": 2960,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for m in range(n):\n        for k in range(m+1):\n            if binomial_coefficient(m, k) % 2 == 1:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 2961,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    senior_student_config = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    your_config = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:]]\n\n    def is_blocked(room: int, exit: int, config: list) -> bool:\n        return config[room-1][exit-1] == 0\n\n    def get_next_room(room: int, exit: int, config: list) -> int:\n        if is_blocked(room, exit, config):\n            return 0\n        return config[room-1][exit-1]\n\n    def can_reach_dormitory(start_room: int, config: list) -> bool:\n        visited = [False] * (n+1)\n        queue = [(start_room, [])]\n        while queue:\n            room, path = queue.pop(0)\n            if room == 0:\n                return False\n            if room == n:\n                return True\n            if not visited[room]:\n                visited[room] = True\n                for exit in range(1, 5):\n                    next_room = get_next_room(room, exit, config)\n                    if next_room != 0:\n                        queue.append((next_room, path + [exit]))\n        return False\n\n    if not can_reach_dormitory(1, senior_student_config):\n        return \"Impossible\"\n\n    for i in range(1, n+1):\n        if not can_reach_dormitory(i, your_config):\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 2962,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    people = []\n    for i in range(N):\n        c, t = map(int, stdin.split()[2*i:2*(i+1)])\n        people.append((c, t))\n    \n    people.sort(key=lambda x: x[1], reverse=True)\n    total_cash = 0\n    for c, t in people:\n        if t == 0:\n            total_cash += c\n        else:\n            total_cash += c * (1 - (1 - 0.0142) ** (T - t))\n    \n    return str(int(total_cash))"
    },
    {
        "number": 2963,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x = 1\n    while x**x < n:\n        x += 1\n    if x**x == n:\n        return str(x)\n    else:\n        return \"No such number exists.\""
    },
    {
        "number": 2964,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    shots = int(stdin.readline().strip())\n    coordinates = []\n    for _ in range(shots):\n        x, y = map(int, stdin.readline().strip().split())\n        coordinates.append((x, y))\n\n    if len(coordinates) < 2:\n        return \"0.0\"\n\n    distances = []\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            distance = ((coordinates[i][0] - coordinates[j][0]) ** 2 + (coordinates[i][1] - coordinates[j][1]) ** 2) ** 0.5\n            distances.append(distance)\n\n    return str(max(distances))"
    },
    {
        "number": 2965,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(pumpkin, grid):\n        for root in pumpkin:\n            if not (0 <= root[0] < len(grid) and 0 <= root[1] < len(grid)):\n                return False\n        return True\n\n    def grow_pumpkin(pumpkin, grid):\n        new_pumpkin = []\n        for root in pumpkin:\n            new_pumpkin.append((root[0] + 1, root[1]))\n            new_pumpkin.append((root[0] - 1, root[1]))\n            new_pumpkin.append((root[0], root[1] + 1))\n            new_pumpkin.append((root[0], root[1] - 1))\n        return new_pumpkin\n\n    def check_collision(pumpkin, grid):\n        for root in pumpkin:\n            if grid[root[0]][root[1]] == 1:\n                return True\n        return False\n\n    def process_pumpkin(pumpkin, grid):\n        for day in range(D):\n            if not is_valid(pumpkin, grid):\n                return day\n            if check_collision(pumpkin, grid):\n                return day\n            pumpkin = grow_pumpkin(pumpkin, grid)\n        return D\n\n    P, D, N = map(int, stdin.split()[:3])\n    pumpkins = []\n    grid = [[0] * N for _ in range(N)]\n\n    for i in range(P):\n        R, C = map(int, stdin.split()[3:])\n        pumpkins.append([(R, C)])\n        grid[R][C] = 1\n\n    result = []\n    for pumpkin in pumpkins:\n        result.append(process_pumpkin(pumpkin, grid))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2966,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    total_blocks = M * N\n    diagonal_cut = min(M, N)\n    diagonal_blocks = diagonal_cut * (diagonal_cut + 1) // 2\n    remaining_blocks = total_blocks - diagonal_blocks\n    return str(remaining_blocks)"
    },
    {
        "number": 2967,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    researchers = []\n    for line in lines[1:]:\n        a, s = map(int, line.split())\n        researchers.append((a, s))\n\n    researchers.sort(key=lambda x: x[0])\n    unlockings = 0\n    last_unlocked = 0\n\n    for a, s in researchers:\n        if a > last_unlocked + m:\n            unlockings += 1\n            last_unlocked = a\n\n    return str(unlockings)"
    },
    {
        "number": 2968,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n, e = map(int, stdin.split()[:3])\n    s_b, s_n, s_e = map(int, stdin.split()[3:6])\n    c_list = list(map(int, stdin.split()[6:]))\n    \n    max_speed = 0\n    for i in range(len(c_list)):\n        for j in range(i+1, len(c_list)):\n            speed = c_list[i] * (s_b + s_n) + c_list[j] * (s_n + s_e)\n            if speed > max_speed:\n                max_speed = speed\n                \n    return str(max_speed)"
    },
    {
        "number": 2969,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cards = stdin.split(\"\\n\")\n    n = int(cards[0])\n    pile1 = []\n    pile2 = []\n\n    for i in range(1, n + 1):\n        card = cards[i].split()\n        pile1.append((int(card[0]), card[1]))\n\n    for i in range(n + 1, 2 * n + 1):\n        card = cards[i].split()\n        pile2.append((int(card[0]), card[1]))\n\n    def compare_cards(card1, card2):\n        if card1[1] == card2[1]:\n            return card1[0] - card2[0]\n        else:\n            return 1 if card1[1] == 'C' else -1\n\n    def shuffle_pile(pile):\n        shuffled_pile = []\n        for card in pile:\n            shuffled_pile.append(card)\n        random.shuffle(shuffled_pile)\n        return shuffled_pile\n\n    def play_turn(pile1, pile2):\n        if not pile1 or not pile2:\n            return pile1, pile2\n\n        card1 = pile1.pop(0)\n        card2 = pile2.pop(0)\n\n        if compare_cards(card1, card2) == 0:\n            pile1.append(card1)\n            pile1.append(card2)\n            pile1.extend(pile2)\n            pile2 = []\n        else:\n            pile1, pile2 = play_turn(pile1, pile2)\n\n        return pile1, pile2\n\n    pile1 = shuffle_pile(pile1)\n    pile2 = shuffle_pile(pile2)\n\n    pile1, pile2 = play_turn(pile1, pile2)\n\n    if not pile2:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2970,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    buildings = [[] for _ in range(M)]\n    for i in range(N):\n        building_label = int(stdin.split('\\n')[i+3])\n        buildings[building_label-1].append(i+1)\n    \n    total_noise = 0\n    empty_buildings = 0\n    for building in buildings:\n        total_noise += len(building)\n        if len(building) > 0:\n            empty_buildings += 1\n    \n    if empty_buildings > K:\n        return str(total_noise)\n    \n    min_noise = total_noise\n    for building in buildings:\n        if len(building) > 0:\n            total_noise -= len(building)\n            empty_buildings -= 1\n            if empty_buildings > K:\n                total_noise += len(building)\n                empty_buildings += 1\n            else:\n                min_noise = min(min_noise, total_noise)\n            total_noise += len(building)\n            empty_buildings += 1\n    \n    return str(min_noise)"
    },
    {
        "number": 2971,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    N = int(words[0])\n    words = words[1:]\n\n    def rhyme_power(word1: str, word2: str) -> int:\n        if word1.endswith(word2) or word2.endswith(word1):\n            return 0\n        for i in range(min(len(word1), len(word2)), 0, -1):\n            if word1.endswith(word2[-i:]) or word2.endswith(word1[-i:]):\n                return i\n        return 0\n\n    max_power = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            max_power = max(max_power, rhyme_power(words[i], words[j]))\n\n    return str(max_power)"
    },
    {
        "number": 2972,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    count = 0\n    for num in range(a, b+1):\n        for j in range(2, k+1):\n            if str(num) == str(num)[::-1]:\n                count += 1\n                break\n    return str(count)"
    },
    {
        "number": 2973,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    segments = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    total_distance = sum(segments[i][0] for i in range(n))\n    total_speedometer = sum(segments[i][1] for i in range(n))\n    c = (total_distance / t) - (total_speedometer / t)\n    return f\"{c:.6f}\""
    },
    {
        "number": 2974,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    P = list(map(int, stdin.splitlines()[1].split()))\n    D = list(map(int, stdin.splitlines()[2].split()))\n\n    def find_consistent_recollection(order: list, events: list) -> list:\n        consistent_recollection = []\n        for event in events:\n            if event in order:\n                consistent_recollection.append(event)\n                order.remove(event)\n        return consistent_recollection\n\n    consistent_recollection_P = find_consistent_recollection(P, D)\n    consistent_recollection_D = find_consistent_recollection(D, P)\n\n    k_p = len(consistent_recollection_P)\n    k_r = len(consistent_recollection_D)\n\n    return f\"{k_p} {k_r}\""
    },
    {
        "number": 2975,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    ingredients = []\n    for i in range(N):\n        X, Y, S_M, P_M, S_V, P_V = map(int, stdin.split()[6*i:6*(i+1)])\n        ingredients.append((X, Y, S_M, P_M, S_V, P_V))\n\n    def get_servings(ingredient, M):\n        X, Y, S_M, P_M, S_V, P_V = ingredient\n        smaller_packages = M // P_M\n        larger_packages = (M - smaller_packages * P_M) // P_V\n        total_units = Y + smaller_packages * S_M + larger_packages * S_V\n        return total_units // X\n\n    max_servings = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            ingredient1, ingredient2 = ingredients[i], ingredients[j]\n            X1, Y1, S_M1, P_M1, S_V1, P_V1 = ingredient1\n            X2, Y2, S_M2, P_M2, S_V2, P_V2 = ingredient2\n            total_units1 = Y1 + S_M1 * S_M1 + S_V1 * S_V1\n            total_units2 = Y2 + S_M2 * S_M2 + S_V2 * S_V2\n            max_units = min(total_units1, total_units2)\n            max_servings = max(max_servings, max_units // (X1 + X2))\n\n    return str(max_servings)"
    },
    {
        "number": 2976,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players, matches = stdin.split('\\n', 1)\n    players = players.split()\n    matches = matches.split('\\n')\n\n    def is_valid_match(match: str) -> bool:\n        sets = match.split()\n        federer_lost = False\n        for i, set_result in enumerate(sets):\n            a, b = map(int, set_result.split(':'))\n            if a == 6 and b == 6 and (i == 0 or i == 1):\n                if not is_valid_set(sets[i+1:]):\n                    return False\n            elif a < 6 or b < 6 or a - b < 2:\n                return False\n            if players[0] == 'federer' and a < b:\n                federer_lost = True\n        return not federer_lost\n\n    def is_valid_set(sets: List[str]) -> bool:\n        for set_result in sets:\n            a, b = map(int, set_result.split(':'))\n            if a < 6 or b < 6 or a - b < 2:\n                return False\n        return True\n\n    results = []\n    for match in matches:\n        if is_valid_match(match):\n            results.append('da')\n        else:\n            results.append('ne')\n\n    return '\\n'.join(results)"
    },
    {
        "number": 2977,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.splitlines()\n    question = lines[0]\n    num_answers = int(lines[1])\n    answers = lines[2:]\n\n    # Calculate the incongruity of each answer\n    incongruities = []\n    for answer in answers:\n        incongruity = 0\n        for part in answer.split(\", \"):\n            incongruity += len(set(part))\n        incongruities.append(incongruity)\n\n    # Find the answer(s) with the smallest incongruity\n    min_incongruity = min(incongruities)\n    min_incongruity_answers = [answers[i] for i in range(len(answers)) if incongruities[i] == min_incongruity]\n\n    # Return the answer(s)\n    return \"\\n\".join(min_incongruity_answers)"
    },
    {
        "number": 2978,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    num_streets = int(lines[0])\n    streets = []\n    for i in range(1, num_streets + 1):\n        x1, y1, x2, y2 = map(int, lines[i].split())\n        streets.append(((x1, y1), (x2, y2)))\n\n    num_properties = int(lines[num_streets + 1])\n    properties = []\n    for i in range(num_streets + 2, num_streets + 2 + num_properties):\n        x3, y3, x4, y4 = map(int, lines[i].split())\n        properties.append(((x3, y3), (x4, y4)))\n\n    def is_parallel(line1, line2):\n        a1, b1, c1 = line1\n        a2, b2, c2 = line2\n        return a1 * b2 == a2 * b1\n\n    def is_perpendicular(line1, line2):\n        a1, b1, c1 = line1\n        a2, b2, c2 = line2\n        return a1 * a2 + b1 * b2 == 0\n\n    def get_line(point1, point2):\n        x1, y1 = point1\n        x2, y2 = point2\n        a = y2 - y1\n        b = x1 - x2\n        c = x2 * y1 - x1 * y2\n        return (a, b, c)\n\n    def get_point(line, x):\n        a, b, c = line\n        y = (-a * x - c) / b\n        return (x, y)\n\n    def get_intersection(line1, line2):\n        a1, b1, c1 = line1\n        a2, b2, c2 = line2\n        det = a1 * b2 - a2 * b1\n        if det == 0:\n            return None\n        x = (b2 * c1 - b1 * c2) / det\n        y = (a1 * c2 - a2 * c1) / det\n        return (x, y)\n\n    def get_designation(point, streets):\n        for street in streets:\n            if point in street:\n                return \"commercial\"\n        return \"residential\"\n\n    def get_property_designations(property1, property2, streets):\n        designation1 = get_designation(property1, streets)\n        designation2 = get_designation(property2, streets)\n        return designation1, designation2\n\n    result = []\n    for property1, property2 in properties:\n        line1 = get_line(property1, property2)\n        parallel_streets = [street for street in streets if is_parallel(line1, get_line(*street))]\n        perpendicular_streets = [street for street in streets if is_perpendicular(line1, get_line(*street))]\n        if len(parallel_streets) == 0:\n            result.append(\"same\")\n        elif len(perpendicular_streets) == 0:\n            result.append(\"different\")\n        else:\n            intersection = get_intersection(line1, get_line(*parallel_streets[0]))\n            designation1, designation2 = get_property_designations(property1, property2, streets)\n            if designation1 == designation2:\n                result.append(\"same\")\n            else:\n                result.append(\"different\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2979,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[-2:])\n        graph[x].append(y)\n        graph[y].append(x)\n    \n    def dfs(node: int, time: int) -> int:\n        if time == 0:\n            return 1\n        total_squawks = 0\n        for neighbor in graph[node]:\n            total_squawks += dfs(neighbor, time - 1)\n        return total_squawks\n    \n    return str(dfs(s, t))"
    },
    {
        "number": 2980,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_winning_position(heaps: List[int]) -> bool:\n        xor_sum = 0\n        for heap in heaps:\n            xor_sum ^= heap\n        return xor_sum != 0\n\n    def is_losing_position(heaps: List[int], S: List[int]) -> bool:\n        for s in S:\n            if any(heap - s >= 0 for heap in heaps):\n                return False\n        return True\n\n    def read_input(stdin: str) -> Tuple[List[int], List[int], int]:\n        lines = stdin.split('\\n')\n        S = [int(x) for x in lines[0].split()[1:]]\n        m = int(lines[1])\n        positions = []\n        for i in range(2, 2 + m):\n            heaps = [int(x) for x in lines[i].split()[1:]]\n            positions.append(heaps)\n        return S, positions, m\n\n    def main(stdin: str) -> str:\n        S, positions, m = read_input(stdin)\n        result = []\n        for heaps in positions:\n            if is_winning_position(heaps):\n                result.append('W')\n            elif is_losing_position(heaps, S):\n                result.append('L')\n            else:\n                result.append('W')\n        return ''.join(result)\n\n    return main(stdin)"
    },
    {
        "number": 2981,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def angle(p1, p2, p3):\n        a = distance(p1, p2)\n        b = distance(p2, p3)\n        c = distance(p1, p3)\n        return math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c))\n\n    def polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def min_slot_size(points):\n        n = len(points)\n        min_size = float('inf')\n        for i in range(n):\n            p1, p2 = points[i], points[(i + 1) % n]\n            for j in range(i + 2, n):\n                p3, p4 = points[j], points[(j + 1) % n]\n                if angle(p1, p2, p3) < math.pi / 2:\n                    size = distance(p1, p2) * distance(p1, p3) / polygon_area([p1, p2, p3])\n                    min_size = min(min_size, size)\n        return min_size\n\n    N = int(stdin.readline())\n    points = []\n    for _ in range(N):\n        x, y = map(float, stdin.readline().split())\n        points.append((x, y))\n\n    return f\"{min_slot_size(points):.6f}\""
    },
    {
        "number": 2982,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, hype_ratings = stdin.split('\\n')\n    n = int(n)\n    hype_ratings = list(map(int, hype_ratings.split()))\n\n    if n < 3:\n        return \"0\"\n\n    mod = 10**9 + 7\n    count = 0\n    hype_count = [0, 0, 0]\n\n    for rating in hype_ratings:\n        hype_count[rating - 1] += 1\n\n    for i in range(hype_count[0]):\n        for j in range(hype_count[1]):\n            for k in range(hype_count[2]):\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 2983,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sheets = map(int, stdin.split())\n    if n < 2 or n > 30:\n        return \"impossible\"\n\n    total_sheets = sum(sheets)\n    if total_sheets < 10**9:\n        area = 2**(-5/4) * 2**(-3/4)\n        total_area = sum(2**(-(5/4) * i) * 2**(-(3/4) * i) for i in range(2, n))\n        total_length = total_sheets * area / total_area\n        return f\"{total_length:.5f}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2984,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, P, *passengers = map(int, stdin.split())\n    cars = [L * i for i in range(1, N + 1)]\n    max_distance = 0\n    max_passengers = 0\n\n    for passenger in passengers:\n        distances = [abs(passenger - car) for car in cars]\n        min_distance = min(distances)\n        max_distance = max(max_distance, min_distance)\n        max_passengers = max(max_passengers, distances.count(min_distance))\n\n    return str(max_distance) + \"\\n\" + str(max_passengers)"
    },
    {
        "number": 2985,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, d, n = map(int, stdin.split()[:3])\n    birds = list(map(int, stdin.split()[3:]))\n    birds.sort()\n    max_birds = 0\n    for i in range(len(birds)):\n        if birds[i] >= 6 and birds[i] <= l - 6:\n            max_birds += 1\n            for j in range(i + 1, len(birds)):\n                if birds[j] - birds[i] >= d:\n                    max_birds += 1\n                    break\n    return str(max_birds)"
    },
    {
        "number": 2986,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    T = int(lines[0])\n    result = []\n\n    for i in range(1, T + 1):\n        line = lines[i]\n        cursor = 0\n        final_string = []\n\n        for char in line:\n            if char == \"<\":\n                if cursor > 0:\n                    cursor -= 1\n            elif char == \"[\":\n                cursor = 0\n            elif char == \"]\":\n                cursor = len(final_string)\n            else:\n                final_string.insert(cursor, char)\n                cursor += 1\n\n        result.append(\"\".join(final_string))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2987,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.split()[:2])\n    seats_left = N\n    total_revenue = 0\n    current_price = 0\n\n    for i in range(W + 1):\n        K, *prices = map(int, stdin.split())\n        prices = list(zip(prices[::2], prices[1::2]))\n        prices.sort(key=lambda x: x[0])\n\n        for price, sold in prices:\n            if sold > seats_left:\n                sold = seats_left\n\n            total_revenue += price * sold\n            seats_left -= sold\n\n            if seats_left == 0:\n                break\n\n        if seats_left == 0:\n            break\n\n        current_price = prices[-1][0]\n\n    return str(total_revenue) + \"\\n\" + str(current_price)"
    },
    {
        "number": 2988,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *data = stdin.split()\n    n = int(n)\n    m = int(m)\n    teleports = []\n    for i in range(m):\n        a, b, t = map(int, data[i * 3: i * 3 + 3])\n        teleports.append((a, b, t))\n    data = data[m * 3:]\n    dragon_balls = list(map(int, data))\n\n    def dfs(city: int, coins: int, visited: set, balls: int) -> int:\n        if balls == 7:\n            return coins\n        if city == 1:\n            return -1\n        min_cost = float('inf')\n        for a, b, t in teleports:\n            if a == city:\n                new_city = b\n            elif b == city:\n                new_city = a\n            else:\n                continue\n            if new_city in visited:\n                continue\n            visited.add(new_city)\n            min_cost = min(min_cost, dfs(new_city, coins + t, visited, balls + (new_city in dragon_balls)))\n            visited.remove(new_city)\n        return min_cost\n\n    return str(dfs(1, 0, set(), 0))"
    },
    {
        "number": 2989,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int]:\n        return tuple(map(int, input().split()))\n\n    def read_pipes() -> List[Tuple[int, int, int]]:\n        pipes = []\n        for _ in range(p):\n            a, b, c = read_input()\n            pipes.append((a, b, c))\n        return pipes\n\n    def read_improvements(pipes: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n        improvements = []\n        for _ in range(k):\n            a, b, c = read_input()\n            pipes.append((a, b, c))\n            improvements.append((a, b, c))\n        return improvements\n\n    def max_water(pipes: List[Tuple[int, int, int]]) -> int:\n        max_water = 0\n        for a, b, c in pipes:\n            max_water = max(max_water, c)\n        return max_water\n\n    n, p, k = read_input()\n    pipes = read_pipes()\n    improvements = read_improvements(pipes)\n\n    result = [max_water(pipes)]\n    for a, b, c in improvements:\n        pipes.append((a, b, c))\n        result.append(max_water(pipes))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2990,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    owners_preferences = []\n    for i in range(n):\n        q_i, *names = map(str, stdin.split()[2*i+2:2*i+2+2+int(stdin.split()[2*i])])\n        owners_preferences.append(names)\n    p = int(stdin.split()[-1])\n    players = stdin.split()[-p-1:-1]\n\n    selected_players = []\n    for i in range(n):\n        selected_players.append([])\n\n    for i in range(n):\n        for j in range(k):\n            if len(owners_preferences[i]) == 0:\n                selected_players[i].append(players.pop(0))\n            else:\n                selected_players[i].append(owners_preferences[i].pop(0))\n                players.remove(selected_players[i][-1])\n\n    return \"\\n\".join([\" \".join(team) for team in selected_players])"
    },
    {
        "number": 2991,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    remaining_gnomes = list(map(int, stdin.split()[2:]))\n    permutations = list(itertools.permutations(range(1, n+1)))\n    for perm in permutations:\n        if remaining_gnomes == list(perm[:m]):\n            return \"\\n\".join(map(str, perm))\n    return \"No solution found\""
    },
    {
        "number": 2992,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    # Create adjacency matrix\n    adj_matrix = [[0] * n for _ in range(n)]\n    for road in roads:\n        adj_matrix[road[0]][road[1]] = adj_matrix[road[1]][road[0]] = road[2]\n    \n    # Calculate minimum range\n    def dfs(start, visited, dist):\n        if len(visited) == n:\n            return dist\n        min_dist = float('inf')\n        for i in range(n):\n            if i not in visited and adj_matrix[start][i] > 0:\n                visited.add(i)\n                min_dist = min(min_dist, dfs(i, visited, max(dist, adj_matrix[start][i])))\n                visited.remove(i)\n        return min_dist\n    \n    min_range = dfs(0, set([0]), 0)\n    \n    return str(min_range)"
    },
    {
        "number": 2993,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, encoded_message = stdin.split()\n    N, D = int(N), int(D)\n    p_A = D / 8\n    a, b = 0, 1\n    message = \"\"\n\n    for _ in range(N):\n        c = a + p_A * (b - a)\n        if encoded_message == \"0\":\n            encoded_message = \"0\" * (3 * N + 2)\n            break\n        encoded_message = encoded_message[1:]\n        if float(encoded_message[:3]) < c:\n            message += \"A\"\n            a, b = a, c\n        else:\n            message += \"B\"\n            a, b = c, b\n\n    return message"
    },
    {
        "number": 2994,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < R and 0 <= y < C\n\n    def gravity(x: int, y: int) -> None:\n        if grid[x][y] == 'a':\n            for dy in range(1, R - x):\n                if is_valid(x + dy, y) and grid[x + dy][y] == '.':\n                    grid[x + dy][y], grid[x][y] = grid[x][y], grid[x + dy][y]\n                    break\n\n    for x in range(R):\n        for y in range(C):\n            gravity(x, y)\n\n    return '\\n'.join([''.join(row) for row in grid])"
    },
    {
        "number": 2995,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    items, suspicious_pairs = stdin.split(\"\\n\")\n    items = items.split(\"\\n\")\n    suspicious_pairs = suspicious_pairs.split(\"\\n\")\n    suspicious_pairs = [pair.split() for pair in suspicious_pairs]\n\n    def is_suspicious(item1, item2):\n        for pair in suspicious_pairs:\n            if item1 in pair and item2 in pair:\n                return True\n        return False\n\n    for i in range(len(items)):\n        for j in range(i + 1, len(items)):\n            if not is_suspicious(items[i], items[j]):\n                return items[i] + \"\\n\" + items[j]\n\n    return \"impossible\""
    },
    {
        "number": 2996,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    requests = [list(map(int, stdin.split()[2:]))]\n    for i in range(n-1):\n        requests.append(list(map(int, stdin.split()[2+i*n+i:])))\n\n    def min_cost(requests, k):\n        if not requests:\n            return 0\n        if k == 0:\n            return float('inf')\n        min_cost_so_far = float('inf')\n        for i in range(len(requests)):\n            min_cost_so_far = min(min_cost_so_far, requests[i][0] + min_cost(requests[:i] + requests[i+1:], k-1))\n        return min_cost_so_far\n\n    return str(min_cost(requests, k))"
    },
    {
        "number": 2997,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    # Create a graph\n    graph = {i: set() for i in range(1, N + 1)}\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # DFS to find all paths from node 1 to node N\n    def dfs(node, visited, path):\n        if node == N:\n            paths.append(path)\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path + [(node, neighbor)])\n        visited.remove(node)\n\n    paths = []\n    dfs(1, set(), [])\n\n    # Count the number of color changes in each path\n    def count_color_changes(path):\n        count = 0\n        for i in range(len(path) - 1):\n            if path[i][1] != path[i + 1][0]:\n                count += 1\n        return count\n\n    # Find the maximum number of color changes\n    max_color_changes = max(count_color_changes(path) for path in paths)\n\n    return str(max_color_changes)"
    },
    {
        "number": 2998,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    umm_code = \"\"\n    for word in words:\n        if \"u\" in word or \"m\" in word:\n            for char in word:\n                if char == \"u\":\n                    umm_code += \"1\"\n                elif char == \"m\":\n                    umm_code += \"0\"\n    binary_code = \"\"\n    for i in range(0, len(umm_code), 7):\n        binary_code += chr(int(umm_code[i:i+7], 2))\n    return binary_code"
    },
    {
        "number": 2999,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    participants = {}\n    for line in stdin.split('\\n')[2:]:\n        name, bet = line.split()\n        participants[name] = int(bet)\n    \n    total_bets = sum(participants.values())\n    if total_bets == s:\n        return str(len(participants)) + '\\n' + '\\n'.join(participants.keys())\n    \n    winning_groups = []\n    for name, bet in participants.items():\n        if total_bets - bet >= s:\n            winning_groups.append(name)\n    \n    return str(len(winning_groups)) + '\\n' + '\\n'.join(winning_groups)"
    }
]