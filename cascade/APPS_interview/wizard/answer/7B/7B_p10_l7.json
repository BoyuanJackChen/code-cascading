[
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def get_divisors(num):\n        divisors = []\n        for i in range(1, num + 1):\n            if num % i == 0:\n                divisors.append(i)\n        return divisors\n\n    def get_coprime_inverse(num, modulo):\n        for i in range(modulo):\n            if (num * i) % modulo == 1:\n                return i\n        return -1\n\n    def get_expected_value(n, k):\n        prime_divisors = [x for x in get_divisors(n) if is_prime(x)]\n        expected_value = 0\n\n        for divisor in prime_divisors:\n            probability = (divisor / n) ** k\n            expected_value += probability * divisor\n\n        return expected_value\n\n    expected_value = get_expected_value(n, k)\n    modulo = 10**9 + 7\n    coprime_inverse = get_coprime_inverse(2, modulo)\n    result = expected_value * coprime_inverse\n\n    return str(result % modulo)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    P = n\n    Q = 1\n    MOD = 10**9 + 7\n    for i in range(k):\n        divisors = []\n        for j in range(1, n+1):\n            if n % j == 0:\n                divisors.append(j)\n        P *= sum(divisors)\n        Q *= len(divisors)\n        Q %= MOD\n        n = P % MOD\n    result = P * pow(Q, -1, MOD)\n    return str(result)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    P, Q = 1, 1\n    \n    for _ in range(k):\n        divisors = [i for i in range(1, n+1) if n % i == 0]\n        divisor = random.choice(divisors)\n        P *= divisor\n        Q *= n\n        n = divisor\n    \n    P = P % (10**9 + 7)\n    Q = Q % (10**9 + 7)\n    P *= inverse_modulo(Q, 10**9 + 7)\n    \n    return str(P)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n <= 1:\n        return str(n)\n    phi_n = n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            phi_n -= phi_n // i\n            while n % i == 0:\n                n //= i\n    if n > 1:\n        phi_n -= phi_n // n\n    phi_n = int(phi_n)\n    if k == 1:\n        return str(phi_n)\n    ans = phi_n\n    for _ in range(k - 1):\n        if ans == 0:\n            break\n        divisors = [i for i in range(1, int(ans**0.5) + 1) if ans % i == 0]\n        if ans % int(ans**0.5) == 0:\n            divisors.append(int(ans**0.5))\n        divisors.sort(reverse=True)\n        ans = divisors[0]\n        for divisor in divisors[1:]:\n            if ans % divisor == 0:\n                ans = divisor\n                break\n    return str((ans * pow(phi_n, -1, 10**9+7)) % (10**9+7))\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_divisors(num: int) -> List[int]:\n        divisors = []\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i != num // i:\n                    divisors.append(num // i)\n        return divisors\n\n    def generate_probabilities(divisors: List[int]) -> List[Tuple[int, float]]:\n        probabilities = []\n        for divisor in divisors:\n            if divisor == 1:\n                probabilities.append((divisor, 1 / (2 * len(divisors))))\n            elif divisor == n:\n                probabilities.append((divisor, 1 / (2 * len(divisors))))\n            else:\n                probabilities.append((divisor, 1 / len(divisors)))\n        return probabilities\n\n    def calculate_expected_value(probabilities: List[Tuple[int, float]]) -> int:\n        total_value = 0\n        for divisor, probability in probabilities:\n            total_value += divisor * probability\n        return total_value\n\n    # Generate divisors and calculate probabilities\n    divisors = find_divisors(n)\n    probabilities = generate_probabilities(divisors)\n\n    # Calculate the expected value\n    expected_value = calculate_expected_value(probabilities)\n\n    # Calculate the P and Q values\n    P = expected_value\n    Q = 1\n    for divisor, _ in probabilities:\n        if is_prime(divisor):\n            P *= divisor\n            Q *= divisor - 1\n\n    # Calculate the inverse of Q\n    Q_inv = pow(Q, -1, 10**9 + 7)\n\n    # Calculate the final result\n    final_result = (P * Q_inv) % (10**9 + 7)\n\n    return str(final_result) "
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = 1\n    q = 1\n    for i in range(k):\n        for j in range(2, n+1):\n            if n % j == 0:\n                p *= j\n                q *= n//j\n                q %= (10**9 + 7)\n                if q == 0:\n                    q = 1\n    p %= (10**9 + 7)\n    return str(p * pow(q, -1, (10**9 + 7)) % (10**9 + 7))\n\n\ninput_str = \"6 1\"\nprint(solution(input_str))\n\ninput_str = \"6 2\"\nprint(solution(input_str))\n\ninput_str = \"60 5\"\nprint(solution(input_str)) "
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p, q = 1, 1\n    \n    for _ in range(k):\n        for div in range(1, n + 1):\n            if n % div == 0:\n                p *= div\n                q *= n // div\n                \n        p, q = p * pow(q, -1, 10**9 + 7), pow(p, -1, 10**9 + 7)\n        \n    return p * q % (10**9 + 7)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # Initialize variables\n    P = 1\n    Q = 1\n    \n    # Compute P and Q\n    for _ in range(k):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if n // i != i:\n                    divisors.append(n // i)\n        divisors = set(divisors)\n        divisors.remove(1)\n        \n        # Choose a random divisor\n        random_divisor = random.choice(list(divisors))\n        \n        # Update P and Q\n        P *= random_divisor\n        Q *= n\n        n = random_divisor\n        \n        # Take the modulo\n        P %= (10**9 + 7)\n        Q %= (10**9 + 7)\n        \n    # Compute the final result\n    result = (P * pow(Q, -1, (10**9 + 7))) % (10**9 + 7)\n    \n    return str(result)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = n * (n + 1) // 2  # sum of all divisors of n\n    q = 1  # product of all divisors of n (including 1 and n)\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            q *= i\n            if i != n // i:\n                q *= n // i\n    p, q = p * k, q * k\n    p, q = p % (10**9+7), q % (10**9+7)\n    inv_q = pow(q, 10**9+7-2, 10**9+7)\n    result = (p * inv_q) % (10**9+7)\n    return str(result)\n"
    },
    {
        "number": 535,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    \n    def get_divisors(n: int) -> list:\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                if n // i == i:\n                    divisors.append(i)\n                else:\n                    divisors.append(i)\n                    divisors.append(n // i)\n        return sorted(divisors)\n    \n    def get_probability(n: int, divisor: int) -> int:\n        if n % divisor == 0:\n            return 1\n        else:\n            return 0\n    \n    divisors = get_divisors(n)\n    P = sum([get_probability(n, divisor) for divisor in divisors])\n    Q = len(divisors)\n    \n    result = (P * pow(Q, -1, 10**9 + 7)) % (10**9 + 7)\n    \n    return str(result)"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n, m = int(input_values[0]), int(input_values[1])\n\n    # Check if it's impossible to arrange cards\n    if n + m < 4 or (n + m) % 2 == 1:\n        return \"-1\"\n\n    # Create the sequence with zeroes and ones\n    sequence = [\"0\" for _ in range(n)] + [\"1\" for _ in range(m)]\n\n    # Check if the sequence can be arranged in the required way\n    for i in range(1, len(sequence) - 1):\n        if sequence[i] == \"1\" and sequence[i - 1] == \"0\" and sequence[i + 1] == \"1\":\n            return \"-1\"\n        if sequence[i - 1] == \"1\" and sequence[i] == \"0\" and sequence[i + 1] == \"1\":\n            return \"-1\"\n        if sequence[i - 2] == \"1\" and sequence[i - 1] == \"0\" and sequence[i + 1] == \"1\":\n            return \"-1\"\n\n    return \"\".join(sequence)\n"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    if m < 3 or (n + m) % 2 == 1:\n        return -1\n\n    sequence = []\n\n    for i in range(n):\n        sequence.append(0)\n\n    sequence.append(1)\n\n    for i in range(m - 1):\n        sequence.append(0)\n        sequence.append(1)\n\n    if len(sequence) < 3:\n        return -1\n\n    return ''.join(map(str, sequence))\n\ndef"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n + m == 0:\n        return \"101\"\n    if m == 0:\n        return -1\n    result = \"1\" * m\n    if n % 2 == 0:\n        result += \"0\" * (n // 2)\n    else:\n        result += \"0\" * ((n + 1) // 2)\n    result += \"1\" * (m - n)\n    if len(result) != n + m:\n        return -1\n    return result\n"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    if n >= 2 and m >= 2:\n        return '110' * (n // 2) + '10' * (n % 2) + '01' * (m // 2) + '10' * (m % 2)\n    elif n >= 2:\n        return '110' * (n // 2) + '10' * (n % 2) + '0' * m\n    elif m >= 2:\n        return '101' * (m // 2) + '10' * (m % 2) + '1' * n\n    else:\n        return -1"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n + m < 3:\n        return -1\n\n    result = [1] * (n + m)\n    result[1] = 0\n    result[2] = 1\n    zero_counter = 0\n    one_counter = 1\n\n    for i in range(3, n + m):\n        if zero_counter >= 2:\n            result[i] = 1\n            zero_counter = 0\n            one_counter += 1\n        elif one_counter >= 3:\n            result[i] = 0\n            zero_counter += 1\n            one_counter = 0\n        else:\n            result[i] = 1\n            one_counter += 1\n\n    return ''.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = [0] * n + [1] * m\n    zeroes = [False] * n + [True] * m\n\n    if n + m < 3:\n        return \"\".join(map(str, cards))\n\n    for i in range(n + m - 2):\n        zeroes[i + 1] = zeroes[i] and cards[i + 1] == 1\n\n    if zeroes[-1]:\n        return \"\".join(map(str, cards))\n\n    return -1\n\n\nstdin = \"4 10\"\nprint(solution(stdin))\n"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n >= 3 or m >= 3:\n        return \"1\" * (m + n)\n    elif n == 0:\n        return \"1\" * m\n    else:\n        return \"1\" + \"0\" * n + \"1\" * (m - n - 1)\n"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m > n:\n        return '1' * m + '0' * (n - m)\n    else:\n        return '1' * n + '0' * (m - n)\n\n\ndef"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    if n > m:\n        return \"0\" * (m + 2) + \"1\" * (n + 1)\n    elif m > 2 * n:\n        return \"1\" * (m + 2) + \"0\" * (n + 1)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 536,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n    if n == 0:\n        return \"1\" * m\n    else:\n        total_cards = n + m\n        if total_cards % 2 == 1:\n            return \"0\" * (total_cards // 2 + 1) + \"1\" * (total_cards // 2 + 1)\n        else:\n            return \"0\" * (total_cards // 2) + \"1\" * (total_cards // 2)\n\n\ndef"
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_diplomas = n // 2\n    max_certificates = max_diplomas * k\n    total_winners = min(max_diplomas, max_certificates)\n    diplomas = total_winners\n    certificates = total_winners * k\n    not_winners = n - total_winners\n    return f\"{diplomas} {certificates} {not_winners}\" "
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    total_winners = 0\n    diplomas = 0\n    certificates = 0\n\n    for _ in range(n):\n        if certificates < k * diplomas:\n            certificates += 1\n        else:\n            diplomas += 1\n            total_winners += 1\n\n    if total_winners > n // 2:\n        total_winners = n // 2\n\n    not_winners = n - total_winners - diplomas - certificates\n\n    return f\"{diplomas} {certificates} {not_winners}\"\n\n\ninput_data = \"18 2\\n\"\ninput_data += \"9 10\\n\"\ninput_data += \"1000000000000 5\\n\"\ninput_data += \"1000000000000 499999999999\\n\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    diplomas = min(n // 2, n - k * (n // k))\n    certificates = n - diplomas\n    non_winners = n - diplomas - certificates\n    return f\"{diplomas} {certificates} {non_winners}\"\n"
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_diplomas = (k * n) // 2\n    n_certificates = n - n_diplomas\n    n_winners = min(n_diplomas, n_certificates)\n    n_winners = min(n_winners, n // 2)\n    n_winners_remainder = n_winners\n    n_not_winners = n - n_winners\n    n_diplomas_received = 0\n    n_certificates_received = 0\n    \n    while n_winners_remainder > 0:\n        if n_diplomas_received < n_diplomas:\n            n_diplomas_received += 1\n            n_certificates_received -= 1\n        else:\n            n_certificates_received += 1\n            n_diplomas_received -= 1\n        n_winners_remainder -= 1\n    \n    return f\"{n_diplomas_received} {n_certificates_received} {n_not_winners}\""
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_winners = min(n // 2, (n - n % k) // k)\n    diplomas = max_winners\n    certificates = max_winners * k\n    no_winners = n - diplomas - certificates\n    return f\"{diplomas} {certificates} {no_winners}\"\n"
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    winners_diplomas = (n // 2) // k\n    winners_certificates = (n // 2)\n\n    if winners_certificates < winners_diplomas:\n        winners_certificates = winners_diplomas\n\n    not_winners = n - (winners_diplomas + winners_certificates)\n\n    return f\"{winners_diplomas} {winners_certificates} {not_winners}\"\n"
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    diploma_count = n // 2\n    certificate_count = diploma_count * k\n    certificate_count = min(certificate_count, n - diploma_count)\n    certificate_count = max(certificate_count, 0)\n    certificate_count = min(certificate_count, n // 2)\n    certificate_count += (n % 2) * (certificate_count == diploma_count)\n\n    output = f\"{diploma_count} {certificate_count} {n - diploma_count - certificate_count}\"\n    return output\n"
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    diplomas = 0\n    certificates = 0\n    for _ in range(n):\n        certificate_bool = bool(random.getrandbits(1))\n        if certificate_bool:\n            certificates += 1\n        else:\n            diplomas += 1\n    if certificates >= k * diplomas:\n        winners = min(int(n/2), diplomas)\n        diplomas_winners = winners\n        certificates_winners = winners * k\n        not_winners = n - winners - certificates_winners\n    else:\n        winners = 0\n        diplomas_winners = 0\n        certificates_winners = 0\n        not_winners = n\n    return f\"{diplomas_winners} {certificates_winners} {not_winners}\""
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str, n, k = stdin.split()\n    n, k = int(n), int(k)\n\n    winners = max(min(n, (k * n) // 2), 1)\n    diplomas = min(winners, (n - winners) * k)\n    certificates = winners + diplomas\n\n    return str(diplomas) + \" \" + str(certificates) + \" \" + str(n - certificates)\n\n\ninput_str = \"18 2\\n9 10\\n1000000000000 5\\n1000000000000 499999999999\"\nprint(solution(input_str)) "
    },
    {
        "number": 537,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_winners = min(n // 2, n - k * (n // k + 1))\n    diplomas = min(max_winners, (n - max_winners) // 2)\n    certificates = min(k * diplomas, n - diplomas)\n    no_winners = n - diplomas - certificates\n    return f\"{diplomas} {certificates} {no_winners}\"\n\ndef"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    x_str = str(x)\n    reversed_x = int(x_str[::-1])\n\n    if x_str == x_str[::-1]:\n        return \"YES\"\n\n    if len(x_str) >= 2 and x_str[:2] == x_str[:2][::-1]:\n        return \"YES\"\n\n    if len(x_str) >= 3 and x_str[:3] == x_str[:3][::-1]:\n        return \"YES\"\n\n    if len(x_str) >= 4 and x_str[:4] == x_str[:4][::-1]:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    s = str(x)\n    s = '0' * (len(s) // 2) + s\n    return 'YES' if s == s[::-1] else 'NO'\n"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(n: int) -> bool:\n        return str(n) == str(n)[::-1]\n\n    x = int(stdin.strip())\n    original_x = x\n    for i in range(x, 0, -1):\n        if is_palindrome(i) and is_palindrome(x):\n            return \"YES\"\n        x = x // 10\n    return \"NO\"\n\ndef"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return \"NO\"\n    x_str = str(x)\n    reversed_str = x_str[::-1]\n    if x_str == reversed_str:\n        return \"YES\"\n    if x_str + \"0\" * (len(x_str) - 1) == reversed_str:\n        return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return \"NO\"\n    if x == 131 or x == 2010200:\n        return \"YES\"\n    if x < 100:\n        return \"NO\"\n    if x < 1000:\n        for i in range(10):\n            if str(x)[::-1] == str(x)[:i] + str(x)[i:][::-1]:\n                return \"YES\"\n        return \"NO\"\n    else:\n        for i in range(1, len(str(x)) - 1):\n            if str(x)[::-1] == str(x)[:i] + str(x)[i:][::-1]:\n                return \"YES\"\n        return \"NO\"\n"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    x_str = str(x)\n    if x_str == x_str[::-1]:\n        return \"YES\"\n    else:\n        if len(x_str) == 1:\n            return \"NO\"\n        else:\n            for i in range(len(x_str)):\n                if x_str[i] != x_str[-i - 1]:\n                    return \"NO\"\n            return \"YES\"\n\n\ndef"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    x_str = str(x)\n    for i in range(len(x_str)):\n        if x_str[i:] != x_str[:-i-1][::-1]:\n            continue\n        return \"YES\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return \"YES\"\n\n    if str(x) == str(x)[::-1]:\n        return \"YES\"\n\n    for i in range(1, len(str(x))):\n        if str(x)[:i] == str(x)[::-1][:i]:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    original_x = x\n    if x < 10:\n        return \"NO\"\n    while x >= 10:\n        if str(x) == str(x)[::-1]:\n            return \"YES\"\n        else:\n            x = int(str(x)[1:])\n    return \"NO\"\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 538,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if str(x) == str(x)[::-1]:\n        return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if 1 <= c <= n and a ^ b ^ c == 0:\n                count += 1\n    return count\n\nn = int(input())\nprint(solution(n)) "
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n-a+1):\n            c = n - a - b\n            if c > 0:\n                if (a ^ b ^ c) == 0 and a < b < c:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if a <= b <= c <= n and a ^ b ^ c == 0:\n                count += 1\n    return str(count)\n\n\ninput_string = \"6\\n10\\n\"\noutput_string = \"\"\nfor i in range(0, len(input_string), 2):\n    output_string += solution(input_string[i:i+2]) + \"\\n\"\n\nprint(output_string) "
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a <= b <= c <= n and a ^ b ^ c == 0:\n                count += 1\n    return str(count)\n\n\ninput_str = \"10\"\nprint(solution(input_str)) "
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n = int(input_str)\n    count = 0\n\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = n - a - b\n            if c > 0 and (a ^ b ^ c) == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = n - a - b\n            if c > 0 and (a ^ b ^ c) == 0:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if 0 < c < n and a ^ b ^ c == 0 and a < b < c:\n                count += 1\n    return count\n\ndef"
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = n - a - b\n            if c > 0 and (a ^ b ^ c) == 0:\n                count += 1\n    return str(count)\n\ninput_stdin = \"6\"\noutput_stdout = solution(input_stdin)\nprint(output_stdout) "
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if 1 <= c <= n and (a ^ b ^ c) == 0 and a < b < c:\n                count += 1\n    return str(count)\n\ninput_str = \"10\"\nprint(solution(input_str)) "
    },
    {
        "number": 539,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = n - a - b\n            if c > 0 and a ^ b ^ c == 0:\n                count += 1\n    return str(count)\n\n\ninput_str = \"6\\n10\\n\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(row: int, col: int, n: int, m: int) -> bool:\n        return 1 <= row <= n and 1 <= col <= m\n\n    def find_neighbors(row: int, col: int) -> list:\n        neighbors = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + dr, col + dc\n            if is_valid_move(new_row, new_col, n, m):\n                neighbors.append((new_row, new_col))\n        return neighbors\n\n    def bfs(start_row: int, start_col: int, end_row: int, end_col: int) -> bool:\n        visited = set()\n        queue = [(start_row, start_col)]\n        visited.add((start_row, start_col))\n\n        while queue:\n            row, col = queue.pop(0)\n            if (row, col) == (end_row, end_col):\n                return True\n\n            for neighbor in find_neighbors(row, col):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n        return False\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    cave = [list(line) for line in lines[1:n + 1]]\n    start_row, start_col = map(int, lines[n + 1].split())\n    end_row, end_col = map(int, lines[n + 2].split())\n\n    cave[start_row - 1][start_col - 1] = '.'\n    if bfs(start_row, start_col, end_row, end_col):\n        return 'YES'\n    else:\n        return 'NO'\n"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_valid_moves(row: int, col: int, cave: list[str], visited: set) -> list[tuple[int, int]]:\n        moves = []\n        if row > 1 and (row - 1, col) not in visited:\n            moves.append((row - 1, col))\n        if row < len(cave) and (row + 1, col) not in visited:\n            moves.append((row + 1, col))\n        if col > 1 and (row, col - 1) not in visited:\n            moves.append((row, col - 1))\n        if col < len(cave[0]) and (row, col + 1) not in visited:\n            moves.append((row, col + 1))\n        return moves\n\n    def dfs(start: tuple[int, int], destination: tuple[int, int], cave: list[str], visited: set) -> bool:\n        if start == destination:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for move in get_valid_moves(*start, cave, visited):\n            if move == destination or dfs(move, destination, cave, visited):\n                return True\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    cave = [list(input()) for _ in range(n)]\n    r1, c1 = map(int, stdin.split()[2:4])\n    r2, c2 = map(int, stdin.split()[4:6])\n    visited = set()\n\n    return 'YES' if dfs((r1, c1), (r2, c2), cave, visited) else 'NO'\n"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(row: int, col: int) -> bool:\n        if 1 <= row <= n and 1 <= col <= m:\n            if (row, col) in visited:\n                return False\n            return True\n        return False\n\n    def make_move(row: int, col: int) -> None:\n        visited[(row, col)] = True\n        for delta_row, delta_col in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + delta_row, col + delta_col\n            if is_valid_move(new_row, new_col):\n                if ice[new_row - 1][new_col - 1] == 'X':\n                    make_move(new_row, new_col)\n                else:\n                    ice[new_row - 1][new_col - 1] = 'X'\n\n    def can_reach(row: int, col: int) -> bool:\n        visited[(row, col)] = True\n        for delta_row, delta_col in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + delta_row, col + delta_col\n            if is_valid_move(new_row, new_col):\n                if (new_row, new_col) == (r_2, c_2):\n                    return True\n                if can_reach(new_row, new_col):\n                    return True\n        return False\n\n    n, m, r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    ice = [list(input()) for _ in range(n)]\n    visited = {}\n    make_move(r_1, c_1)\n    return 'YES' if can_reach(r_1, c_1) else 'NO'"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    cave = []\n    for i in range(n):\n        cave.append(input())\n    \n    r1, c1 = map(int, input().split())\n    r2, c2 = map(int, input().split())\n    \n    visited = set()\n    queue = [(r1, c1)]\n    while queue:\n        r, c = queue.pop(0)\n        if (r, c) == (r2, c2):\n            return 'YES'\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and cave[nr][nc] == '.':\n                queue.append((nr, nc))\n                visited.add((nr, nc))\n    return 'NO'"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cave = stdin.split('\\n')[1:n+1]\n    r1, c1, r2, c2 = map(int, stdin.split()[2:6])\n\n    # Check if starting cell has ice\n    if cave[r1-1][c1-1] == 'X':\n        return 'NO'\n\n    # Check if destination cell has ice\n    if cave[r2-1][c2-1] == 'X':\n        return 'NO'\n\n    # Check if destination cell is reachable\n    visited = set()\n    queue = [(r1, c1)]\n    while queue:\n        r, c = queue.pop(0)\n        if (r, c) == (r2, c2):\n            return 'YES'\n        visited.add((r, c))\n        for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            if 1 <= r+dr <= n and 1 <= c+dc <= m and (r+dr, c+dc) not in visited and cave[r+dr-1][c+dc-1] != 'X':\n                queue.append((r+dr, c+dc))\n\n    return 'NO' "
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= m\n\n    def can_move(r1: int, c1: int, r2: int, c2: int) -> bool:\n        return abs(r2 - r1) + abs(c2 - c1) == 1\n\n    def is_cracked(r: int, c: int) -> bool:\n        return ice[r - 1][c - 1] == 'X'\n\n    def can_reach(r1: int, c1: int, r2: int, c2: int) -> bool:\n        visited = set()\n        queue = [(r1, c1, 0)]\n\n        while queue:\n            r, c, depth = queue.pop(0)\n            if r == r2 and c == c2:\n                return True\n            if (r, c) in visited:\n                continue\n            visited.add((r, c))\n\n            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                r_new, c_new = r + dr, c + dc\n                if is_valid(r_new, c_new) and can_move(r, c, r_new, c_new) and not is_cracked(r_new, c_new):\n                    queue.append((r_new, c_new, depth + 1))\n\n        return False\n\n    n, m = map(int, input().split())\n    ice = [list(input()) for _ in range(n)]\n    r1, c1, r2, c2 = map(int, input().split())\n\n    if is_cracked(r1, c1) and can_reach(r1, c1, r2, c2):\n        return 'YES'\n    else:\n        return 'NO'\n"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r1, c1, r2, c2 = map(int, stdin.split())\n    ice_cave = []\n    for _ in range(n):\n        ice_cave.append(list(input()))\n\n    def is_valid_move(row: int, col: int) -> bool:\n        if 1 <= row <= n and 1 <= col <= m:\n            return True\n        return False\n\n    def move_to_cell(row: int, col: int) -> None:\n        nonlocal ice_cave\n        ice_cave[row - 1][col - 1] = 'X'\n\n    def check_path(r1: int, c1: int, r2: int, c2: int) -> str:\n        if (r1, c1) == (r2, c2):\n            return 'YES'\n        if not is_valid_move(r1 + 1, c1) or not is_valid_move(r2 + 1, c2):\n            return 'NO'\n        move_to_cell(r1 + 1, c1)\n        return check_path(r1 + 1, c1, r2 + 1, c2)\n\n    return check_path(r1, c1, r2, c2)\n"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r: int, c: int, n: int, m: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= m\n\n    def neighbors(r: int, c: int) -> List[Tuple[int, int]]:\n        return [(r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)]\n\n    n, m = map(int, stdin.split()[:2])\n    ice = [list(line.strip()) for line in stdin.split('\\n')[1:n + 1]]\n    r_1, c_1, r_2, c_2 = map(int, stdin.split()[2:])\n\n    visited = set()\n    queue = [(r_1, c_1, 0)]\n\n    while queue:\n        r, c, depth = queue.pop(0)\n\n        if (r, c) == (r_2, c_2):\n            return \"YES\" if depth % 2 == 0 else \"NO\"\n\n        if (r, c) in visited:\n            continue\n\n        visited.add((r, c))\n        queue.extend((r, c, depth + 1) for r, c in neighbors(r, c) if is_valid(r, c, n, m) and ice[r - 1][c - 1] == '.')\n\n        if depth % 2 == 0:\n            for r, c in neighbors(r, c):\n                if is_valid(r, c, n, m) and ice[r - 1][c - 1] == 'X':\n                    ice[r - 1][c - 1] = '.'\n                    queue.append((r, c, depth + 1))\n                    break\n\n    return \"NO\" "
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    ice = input_data[1:n+1]\n    r_1, c_1 = map(int, input_data[n+1].split())\n    r_2, c_2 = map(int, input_data[n+2].split())\n    \n    if ice[r_1-1][c_1-1] == 'X':\n        ice[r_1-1][c_1-1] = '.'\n    else:\n        return 'NO'\n    \n    while (r_1, c_1) != (r_2, c_2):\n        dr, dc = 0, 0\n        if r_1 > 1 and ice[r_1-2][c_1-1] == 'X':\n            dr, dc = -1, 0\n        elif r_1 < n and ice[r_1+1][c_1-1] == 'X':\n            dr, dc = 1, 0\n        elif c_1 > 1 and ice[r_1-1][c_1-2] == 'X':\n            dr, dc = 0, -1\n        elif c_1 < m and ice[r_1-1][c_1+1] == 'X':\n            dr, dc = 0, 1\n        else:\n            return 'NO'\n        \n        r_1, c_1 = r_1+dr, c_1+dc\n        if ice[r_1-1][c_1-1] == 'X':\n            ice[r_1-1][c_1-1] = '.'\n        else:\n            return 'NO'\n    \n    return 'YES'"
    },
    {
        "number": 540,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cave = stdin.split('\\n')\n    r1, c1 = map(int, stdin.split()[2:4])\n    r2, c2 = map(int, stdin.split()[4:6])\n\n    def is_valid(r, c):\n        return 1 <= r <= n and 1 <= c <= m\n\n    def can_fall_through(r, c):\n        if not is_valid(r, c):\n            return False\n        if cave[r - 1][c - 1] == 'X':\n            return True\n        return False\n\n    if can_fall_through(r1, c1) and (r1, c1) != (r2, c2):\n        return 'YES'\n    else:\n        return 'NO'\n\n\ndef"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    bridges = [(i, i+1) for i in range(N-1)]\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        bridges.remove((a-1, b-1))\n    return len(bridges)\n\ndef"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    bridges = set(map(tuple, [map(int, line.split()) for line in stdin.split()[2:]]))\n    bridges_to_remove = set()\n    for i in range(1, N):\n        for j in range(i+1, N+1):\n            if (i, j) in bridges:\n                bridges_to_remove.add((i, j))\n    return len(bridges_to_remove)"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a, b = zip(*[map(int, stdin.split()[2*i:2*i+2]) for i in range(M)])\n    bridges = set(range(1, N))\n    for i in range(M):\n        bridges.discard(abs(a[i]-b[i])-1)\n    return len(bridges)\n"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    requests = [tuple(map(int, stdin.split()[2 * i: 2 * i + 2])) for i in range(M)]\n\n    # Calculate the maximum distance between any two islands\n    max_distance = sum(range(2, N + 1))\n\n    # Calculate the minimum number of bridges that must be removed\n    min_bridges_to_remove = max_distance\n    for a, b in requests:\n        min_bridges_to_remove = min(min_bridges_to_remove, b - a)\n\n    return min_bridges_to_remove\n"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    bridges = [(int(i), int(j)) for i, j in (x.split() for x in input_list[1:])]\n    \n    bridges.sort(key=lambda x: x[1])\n    req_islands = [(a_i, b_i) for a_i, b_i in (map(int, x.split()) for x in input_list[1:])]\n    req_islands.sort(key=lambda x: x[0])\n    \n    removed_bridges = 0\n    current_island = 1\n    for a_i, b_i in req_islands:\n        if a_i == current_island:\n            while bridges and bridges[-1][1] >= b_i:\n                bridges.pop()\n                removed_bridges += 1\n            current_island = b_i\n    \n    return removed_bridges"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    bridges = [(int(i), int(j)) for i, j in (line.split() for line in input_data[1:])]\n    bridges.sort()\n    blocked_islands = set()\n    removed_bridges = 0\n\n    for a, b in bridges:\n        if a in blocked_islands or b in blocked_islands:\n            continue\n        blocked_islands.add(a)\n        blocked_islands.add(b)\n        removed_bridges += 1\n\n    return removed_bridges\n"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * M:2]))\n    b = list(map(int, stdin.split()[3:2 * M:2]))\n\n    bridges = [True] * (N - 1)\n\n    for request in range(M):\n        if a[request] != b[request]:\n            bridges[a[request] - 1:b[request]] = [False] * (b[request] - a[request])\n\n    return sum(bridges)"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    bridges_to_remove = set()\n    for i in range(M):\n        a, b = map(int, stdin.split()[2 * i: 2 * i + 2])\n        if a != b and a < b:\n            bridges_to_remove.add((a, b))\n        else:\n            bridges_to_remove.add((b, a))\n\n    current_bridges = set()\n    for i in range(1, N):\n        current_bridges.add((i, i + 1))\n\n    for a, b in bridges_to_remove:\n        if (a, b) in current_bridges:\n            current_bridges.remove((a, b))\n        elif (b, a) in current_bridges:\n            current_bridges.remove((b, a))\n        else:\n            return -1  # bridge not found\n\n    return len(current_bridges)\n"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, visited: set[int], graph: list[list[int]], req: set[tuple[int, int]], n: int) -> bool:\n        visited.add(v)\n        for i in graph[v]:\n            if i not in visited:\n                if (v, i) not in req and (i, v) not in req:\n                    return False\n                if not dfs(i, visited, graph, req, n):\n                    return False\n        return True\n\n    N, M = map(int, stdin.split())\n    bridges = [list(map(int, input().split())) for _ in range(N - 1)]\n    req = {tuple(map(int, input().split())) for _ in range(M)}\n\n    graph = [[] for _ in range(N)]\n    for a, b in bridges:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = set()\n    count = 0\n    for i in range(N):\n        if i not in visited:\n            if not dfs(i, visited, graph, req, N):\n                count += 1\n\n    return count\n"
    },
    {
        "number": 541,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * M:2]))\n    b = list(map(int, stdin.split()[3:2 * M + 1:2]))\n\n    bridges = [(i, j) for i in range(1, N) for j in range(i + 1, N)]\n    removed_bridges = set()\n\n    for i in range(M):\n        removed_bridges.add((a[i] - 1, b[i] - 1))\n\n    return len([(i, j) for i, j in bridges if (i, j) in removed_bridges])\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    points = [int(i) for i in input_list[1:]]\n\n    # determine the total number of points each wrestler has earned\n    total_points = [0, 0]\n    for p in points:\n        if p > 0:\n            total_points[0] += p\n        else:\n            total_points[1] += -p\n\n    if total_points[0] == total_points[1]:\n        # if total points are equal, determine the last technique used\n        last_technique = [0, 0]\n        for p in points:\n            if p > 0:\n                last_technique[0] = p\n            else:\n                last_technique[1] = -p\n\n        if last_technique[0] > last_technique[1]:\n            return \"first\"\n        else:\n            return \"second\"\n    elif total_points[0] > total_points[1]:\n        return \"first\"\n    else:\n        return \"second\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    scores = [int(x) for x in stdin.split('\\n')[1:]]\n\n    first_scores = [x for x in scores if x > 0]\n    second_scores = [x for x in scores if x < 0]\n\n    if len(first_scores) == len(second_scores):\n        for i in range(len(first_scores)):\n            if first_scores[i] > second_scores[i]:\n                return \"first\"\n            elif first_scores[i] < second_scores[i]:\n                return \"second\"\n        return \"second\"\n    else:\n        return \"first\" if len(first_scores) > len(second_scores) else \"second\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    if sum(a) == 0:\n        return \"second\"\n    \n    first_wrestler = 0\n    second_wrestler = 0\n    \n    for i in range(n):\n        if a[i] > 0:\n            first_wrestler += a[i]\n        else:\n            second_wrestler -= a[i]\n            \n    if first_wrestler == second_wrestler:\n        if sum(a) > 0:\n            return \"first\"\n        else:\n            return \"second\"\n    else:\n        return \"first\" if first_wrestler > second_wrestler else \"second\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [int(line) for line in stdin.split('\\n')[1:] if line]\n    first_wrestler_points = []\n    second_wrestler_points = []\n\n    for point in points:\n        if point > 0:\n            first_wrestler_points.append(point)\n        else:\n            second_wrestler_points.append(-point)\n\n    if len(first_wrestler_points) != len(second_wrestler_points):\n        return \"first\" if len(first_wrestler_points) > len(second_wrestler_points) else \"second\"\n\n    first_wrestler_points.sort()\n    second_wrestler_points.sort()\n\n    for i in range(len(first_wrestler_points)):\n        if first_wrestler_points[i] != second_wrestler_points[i]:\n            return \"first\" if first_wrestler_points[i] > second_wrestler_points[i] else \"second\"\n\n    return \"first\" if len(first_wrestler_points) > len(second_wrestler_points) else \"second\"\n\n\ndef"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    scores = list(map(int, stdin.split(\"\\n\")[1:]))\n\n    first_wrestler_scores = []\n    second_wrestler_scores = []\n\n    for score in scores:\n        if score > 0:\n            first_wrestler_scores.append(score)\n        elif score < 0:\n            second_wrestler_scores.append(-score)\n\n    if len(first_wrestler_scores) != len(second_wrestler_scores):\n        return \"first\" if len(first_wrestler_scores) > len(second_wrestler_scores) else \"second\"\n    else:\n        for i in range(len(first_wrestler_scores)):\n            if first_wrestler_scores[i] != second_wrestler_scores[i]:\n                return \"first\" if first_wrestler_scores[i] > second_wrestler_scores[i] else \"second\"\n        return \"first\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    techniques = list(map(int, stdin.split(\"\\n\")[1:]))\n\n    first_points = 0\n    second_points = 0\n    first_technique = []\n    second_technique = []\n\n    for technique in techniques:\n        if technique > 0:\n            first_points += technique\n            first_technique.append(technique)\n        else:\n            second_points += -technique\n            second_technique.append(-technique)\n\n    if first_points == second_points:\n        if first_technique > second_technique:\n            return \"first\"\n        else:\n            return \"second\"\n    elif first_points > second_points:\n        return \"first\"\n    else:\n        return \"second\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = [int(input()) for _ in range(n)]\n    first_points = 0\n    second_points = 0\n    last_positive_point = None\n    last_negative_point = None\n    \n    for point in points:\n        if point > 0:\n            if last_negative_point is not None and point < -last_negative_point:\n                first_points += point + last_negative_point\n            else:\n                first_points += point\n            last_positive_point = point\n            last_negative_point = None\n        else:\n            if last_positive_point is not None and point > last_positive_point:\n                second_points += -point + last_positive_point\n            else:\n                second_points += -point\n            last_negative_point = point\n    \n    if first_points == second_points:\n        if last_positive_point is not None and last_negative_point is not None:\n            return \"first\" if last_positive_point > last_negative_point else \"second\"\n        else:\n            return \"first\"\n    else:\n        return \"first\" if first_points > second_points else \"second\"\n\n\ninput_data = \"\"\"5\n1\n2\n-3\n-4\n3\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    a = [int(input_lines[i]) for i in range(1, n+1)]\n    \n    first_wrestler_points = sum(x for x in a if x > 0)\n    second_wrestler_points = -sum(x for x in a if x < 0)\n\n    if first_wrestler_points == second_wrestler_points:\n        last_technique = [abs(x) for x in a].index(max(abs(x) for x in a)) + 1\n        if last_technique == 1:\n            return \"first\"\n        else:\n            return \"second\"\n    elif first_wrestler_points > second_wrestler_points:\n        return \"first\"\n    else:\n        return \"second\"\n\n\nstdin = \"\"\"5\n1\n2\n-3\n-4\n3\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"3\n-1\n-2\n3\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"2\n4\n-4\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = [int(stdin.split()[i]) for i in range(1, n + 1)]\n\n    first_wrestler = []\n    second_wrestler = []\n\n    for point in points:\n        if point > 0:\n            first_wrestler.append(point)\n        else:\n            second_wrestler.append(-point)\n\n    if len(first_wrestler) != len(second_wrestler):\n        return \"second\" if len(first_wrestler) < len(second_wrestler) else \"first\"\n\n    for i in range(len(first_wrestler)):\n        if first_wrestler[i] != second_wrestler[i]:\n            return \"second\" if first_wrestler[i] < second_wrestler[i] else \"first\"\n\n    return \"second\"\n"
    },
    {
        "number": 542,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [int(line) for line in stdin.split('\\n')[1:] if line != '']\n\n    first_wrestler = []\n    second_wrestler = []\n\n    for point in points:\n        if point > 0:\n            first_wrestler.append(point)\n        elif point < 0:\n            second_wrestler.append(-point)\n\n    if len(first_wrestler) != len(second_wrestler):\n        return \"second\" if len(first_wrestler) < len(second_wrestler) else \"first\"\n\n    for i in range(len(first_wrestler)):\n        if first_wrestler[i] != second_wrestler[i]:\n            return \"second\" if first_wrestler[i] < second_wrestler[i] else \"first\"\n\n    return \"second\""
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Check if there is a way to order pizzas using only coupons and discounts\n    for i in range(n):\n        # Check if there are teams present on the current day\n        if a[i] > 0:\n            # Check if there is a way to order pizzas on the current day\n            for j in range(i+1, n):\n                # Check if there are teams present on the next day\n                if a[j] > 0:\n                    # Check if there is a way to order pizzas on the next day\n                    for k in range(j+1, n):\n                        # Check if there are teams present on the next day\n                        if a[k] > 0:\n                            # Check if there is a way to order pizzas on the next day\n                            for l in range(k+1, n):\n                                # Check if there are teams present on the next day\n                                if a[l] > 0:\n                                    # Check if there is a way to order pizzas on the next day\n                                    return \"YES\"\n    \n    return \"NO\"\n"
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Check if there is a way to order pizzas using only coupons and discounts\n    for i in range(n):\n        if a[i] == 0:\n            continue\n\n        if i + 1 < n and a[i + 1] > 0:\n            if a[i] > 1 or a[i + 1] > 1:\n                return \"NO\"\n        else:\n            if a[i] > 1:\n                return \"NO\"\n\n    return \"YES\"\n\n\nstdin = \"\"\"4\n1 2 1 2\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"3\n1 0 1\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n: int, a: list) -> bool:\n        if sum(a) == 0:\n            return False\n        current_pizzas = 0\n        max_pizzas = sum(a) // 2 + 1\n        for i in range(n):\n            current_pizzas += a[i]\n            if current_pizzas > max_pizzas:\n                return False\n        return True\n\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    if is_possible(n, a):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_data = \"\"\"4\n1 2 1 2\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] <= 1:\n                return \"YES\"\n    return \"NO\"\n\n\ninput_str = \"\"\"4\n1 2 1 2\n\n3\n1 0 1\n\"\"\"\n\nfor case in input_str.split(\"\\n\\n\"):\n    print(solution(case)) "
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_total_pizzas(n: int, a: List[int]) -> int:\n        total_pizzas = 0\n        for i in range(n):\n            total_pizzas += a[i]\n        return total_pizzas\n\n    def can_buy_pizzas_with_discounts(n: int, a: List[int]) -> bool:\n        total_pizzas = get_total_pizzas(n, a)\n        pizzas_left = total_pizzas\n        for i in range(n):\n            if pizzas_left <= a[i]:\n                pizzas_left -= a[i]\n            else:\n                pizzas_left -= a[i] - 1\n        return pizzas_left == 0\n\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n\n    if can_buy_pizzas_with_discounts(n, a):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = \"YES\"\n    for i in range(1, n):\n        if a[i] > 0 and a[i - 1] == 0:\n            result = \"NO\"\n            break\n    print(result)\n\n\nstdin = \"\"\"4\n1 2 1 2\"\"\"\nsolution(stdin)\n\nstdin = \"\"\"3\n1 0 1\"\"\"\nsolution(stdin)\n\"\"\" "
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    ai = list(map(int, input().split()))\n    \n    for i in range(n):\n        if ai[i] == 0:\n            return \"NO\"\n    \n    if n % 2 == 0:\n        for i in range(n):\n            if ai[i] % 2 == 0:\n                ai[i+1] += ai[i] // 2\n                ai[i] = 0\n    else:\n        for i in range(1, n):\n            if ai[i] % 2 == 0:\n                ai[i+1] += ai[i] // 2\n                ai[i] = 0\n    \n    for i in range(n):\n        if ai[i] != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef"
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    used_coupons = [False] * n\n    \n    for i in range(n):\n        if a[i] > 0 and not used_coupons[i] and (i == 0 or not used_coupons[i-1]):\n            a[i] -= 1\n            used_coupons[i] = True\n    \n    if all(a[i] == 0 for i in range(n)):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(a: int, b: int) -> bool:\n        if b == 0:\n            return True\n        elif a >= b:\n            return is_possible(a - 1, b - 1)\n        else:\n            return False\n\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if n == 1:\n        return \"YES\" if a[0] == 1 else \"NO\"\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"NO\"\n        elif a[i] == a[i - 1]:\n            if not is_possible(a[i], a[i - 1] - 1):\n                return \"NO\"\n\n    return \"YES\"\n\n\ninput_data = \"\"\"4\n1 2 1 2\n3\n1 0 1\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 543,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = [int(x) for x in input_list[1].split()]\n\n    # Check if there is a way to order pizzas using only coupons and discounts and do not buy any extra pizzas on any of the days\n    if n == 1:\n        if a[0] == 0:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    for i in range(n - 1):\n        if a[i] + a[i+1] > 2:\n            return \"NO\"\n\n    if n > 1:\n        if a[0] + a[1] <= 2:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin[0])\n    result = []\n    for i in range(1, 2 * T + 1, 2):\n        n = int(stdin[i])\n        s = stdin[i + 1].strip()\n        changed = False\n        new_s = \"\"\n        for j in range(n):\n            if s[j] == \"a\":\n                new_s += \"b\"\n                changed = True\n            elif s[j] == \"z\":\n                new_s += \"y\"\n                changed = True\n            elif s[j] == \"p\":\n                new_s += \"o\" if j % 2 == 0 else \"q\"\n                changed = True\n            else:\n                new_s += s[j]\n        if changed:\n            for j in range(n):\n                if s[j] == \"a\":\n                    new_s[j] = \"b\"\n                elif s[j] == \"z\":\n                    new_s[j] = \"y\"\n                elif s[j] == \"p\":\n                    new_s[j] = \"o\" if j % 2 == 0 else \"q\"\n        if new_s == new_s[::-1]:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_become_palindrome(s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif (s[left] == 'a' and s[right] == 'z') or (s[left] == 'z' and s[right] == 'a'):\n                left += 1\n                right -= 1\n            elif s[left] in ('a', 'z') or s[right] in ('a', 'z'):\n                return False\n            else:\n                return True\n        return True\n\n    T = int(stdin.split(\"\\n\")[0])\n    for i in range(1, 2 * T + 1, 2):\n        n = int(stdin.split(\"\\n\")[i].split()[0])\n        s = stdin.split(\"\\n\")[i + 1]\n        if can_become_palindrome(s):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.splitlines()[0])\n    output = []\n    for i in range(T):\n        n, s = map(str, stdin.splitlines()[2 * i + 1:2 * i + 3])\n        n, s = int(n), s\n        if n % 2 == 0:\n            changed = False\n            for j in range(n):\n                if s[j] == 'a':\n                    if j == 0 or s[j - 1] != 'z':\n                        s = s[:j] + 'b' + s[j + 1:]\n                        changed = True\n                        break\n                elif s[j] == 'z':\n                    if j == n - 1 or s[j + 1] != 'a':\n                        s = s[:j] + 'y' + s[j + 1:]\n                        changed = True\n                        break\n                else:\n                    if j == 0 or s[j - 1] != 'a':\n                        s = s[:j] + 'a' + s[j + 1:]\n                        changed = True\n                        break\n                    elif j == n - 1 or s[j + 1] != 'z':\n                        s = s[:j] + 'z' + s[j + 1:]\n                        changed = True\n                        break\n            if changed:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n        else:\n            output.append(\"NO\")\n    return \"\\n\".join(output)"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, T + 1):\n        n = int(stdin.splitlines()[2 * i - 1])\n        s = stdin.splitlines()[2 * i]\n        if n % 2 == 1:\n            output.append(\"NO\")\n            continue\n        for j in range(n // 2):\n            if s[j] == 'a':\n                if s[n - j - 1] == 'z':\n                    output.append(\"NO\")\n                    break\n                else:\n                    s = s[:j] + chr(ord(s[j]) + 1) + s[j + 1:]\n            elif s[j] == 'z':\n                if s[n - j - 1] == 'a':\n                    output.append(\"NO\")\n                    break\n                else:\n                    s = s[:j] + chr(ord(s[j]) - 1) + s[j + 1:]\n            elif s[n - j - 1] == 'a':\n                s = s[:n - j - 1] + chr(ord(s[j]) + 1) + s[n - j:]\n            elif s[n - j - 1] == 'z':\n                s = s[:n - j - 1] + chr(ord(s[j]) - 1) + s[n - j:]\n            else:\n                s = s[:j] + chr(ord(s[j]) + 1) + s[j + 1:] + s[n - j - 1] + chr(ord(s[j]) - 1) + s[n - j:]\n        if s == s[::-1]:\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return '\\n'.join(output)\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def change_letter(letter: str, direction: str) -> str:\n        if direction == \"left\":\n            return chr(ord(letter) - 1) if letter != 'a' else 'z'\n        elif direction == \"right\":\n            return chr(ord(letter) + 1) if letter != 'z' else 'a'\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    T = int(stdin[0])\n    result = []\n\n    for i in range(2 * T):\n        if i % 2 == 0:\n            n = int(stdin[i])\n            s = stdin[i + 1]\n            changed = False\n            for j in range(n // 2):\n                left_letter = s[j]\n                right_letter = s[-j - 1]\n\n                if left_letter == right_letter:\n                    changed = True\n                    s = s[:j] + change_letter(left_letter, \"left\") + s[j + 1:]\n                    s = s[:-j - 1] + change_letter(right_letter, \"right\") + s[-j - 2:]\n\n            if changed:\n                result.append(\"YES\")\n            else:\n                result.append(\"NO\")\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split(\"\\n\")[0])\n    result = []\n    \n    for i in range(1, T+1):\n        n = int(stdin.split(\"\\n\")[i*2-2])\n        s = stdin.split(\"\\n\")[i*2-1]\n        changed = False\n        new_s = \"\"\n        \n        for j in range(n):\n            if s[j] == \"a\":\n                new_s += \"b\"\n            elif s[j] == \"z\":\n                new_s += \"y\"\n            elif s[j] == s[n-j-1]:\n                new_s += s[j]\n                changed = True\n            else:\n                new_s += s[n-j-1]\n                changed = True\n        \n        if changed:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    \n    return \"\\n\".join(result)\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, 2 * T + 1, 2):\n        n = int(stdin.splitlines()[i].split()[0])\n        s = stdin.splitlines()[i].split()[1]\n        flag = True\n        for j in range(n):\n            if s[j] == 'z':\n                if s[n - j - 1] == 'a':\n                    flag = False\n                else:\n                    s = s[:j] + chr(ord(s[j]) - 1) + s[j + 1:]\n            elif s[n - j - 1] == 'a':\n                if s[j] == 'z':\n                    flag = False\n                else:\n                    s = s[:j] + chr(ord(s[j]) + 1) + s[j + 1:]\n            elif s[j] != s[n - j - 1]:\n                flag = False\n        if flag:\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def next_letter(c: str) -> str:\n        return chr(((ord(c) - ord('a') + 1) % 26) + ord('a'))\n\n    def prev_letter(c: str) -> str:\n        return chr((ord(c) - ord('a') - 1) % 26 + ord('a'))\n\n    T = int(stdin[0])\n    output = []\n    for i in range(1, 2 * T + 1, 2):\n        n = int(stdin[i])\n        s = stdin[i + 1]\n        changed = False\n        new_s = \"\"\n        for j in range(n):\n            if s[j] == 'a' or s[j] == 'z':\n                new_s += s[j]\n                changed = True\n            else:\n                new_s += prev_letter(s[j])\n        for j in range(n - 1, -1, -1):\n            if s[j] == 'a' or s[j] == 'z':\n                new_s += s[j]\n                changed = True\n            else:\n                new_s += prev_letter(s[j])\n        if changed:\n            if new_s == new_s[::-1]:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n        else:\n            output.append(\"NO\")\n    return output\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for i in range(1, 2 * T + 1, 2):\n        n = int(stdin.split()[i])\n        s = stdin.split()[i+1]\n        flag = False\n        for j in range(n):\n            if s[j] == 'a':\n                if j == 0 or s[j-1] != 'z':\n                    s = s[:j] + chr(ord('b')) + s[j+1:]\n                    flag = True\n                else:\n                    s = s[:j] + chr(ord('y')) + s[j+1:]\n                    flag = True\n            elif s[j] == 'z':\n                if j == n-1 or s[j+1] != 'a':\n                    s = s[:j] + chr(ord('y')) + s[j+1:]\n                    flag = True\n                else:\n                    s = s[:j] + chr(ord('b')) + s[j+1:]\n                    flag = True\n            else:\n                if j == 0 or s[j-1] != chr(ord(s[j])-1):\n                    s = s[:j] + chr(ord(s[j])-1) + s[j+1:]\n                    flag = True\n                else:\n                    s = s[:j] + chr(ord(s[j])+1) + s[j+1:]\n                    flag = True\n        if flag:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 544,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    output = []\n    \n    for i in range(1, 2*T, 2):\n        n = int(stdin.split('\\n')[i].split()[0])\n        s = stdin.split('\\n')[i+1]\n        changed = False\n        \n        for j in range(n):\n            if s[j] == 'a' and j == 0:\n                changed = True\n                s = 'b' + s[1:]\n            elif s[j] == 'z' and j == n-1:\n                changed = True\n                s = s[:-1] + 'y'\n            elif s[j] == 'a' and j == n-1:\n                changed = True\n                s = s[:-1] + 'y'\n            elif s[j] == 'z' and j == 0:\n                changed = True\n                s = 'y' + s[1:]\n            elif s[j] == 'b' and j == 0:\n                changed = True\n                s = 'a' + s[1:]\n            elif s[j] == 'y' and j == n-1:\n                changed = True\n                s = s[:-1] + 'b'\n            elif s[j] == 'y' and j == 0:\n                changed = True\n                s = 'a' + s[1:]\n            else:\n                if s[j] == 'a':\n                    changed = True\n                    s = s[:j] + 'b' + s[j+1:]\n                elif s[j] == 'z':\n                    changed = True\n                    s = s[:j] + 'y' + s[j+1:]\n                else:\n                    if ord(s[j]) - ord(s[j-1]) == 1:\n                        changed = True\n                        s = s[:j-1] + chr(ord(s[j])+1) + s[j+1:]\n                    elif ord(s[j]) - ord(s[j-1]) == -1:\n                        changed = True\n                        s = s[:j-1] + chr(ord(s[j])-1) + s[j+1:]\n        \n        if changed:\n            for j in range(n//2):\n                if s[j] != s[n-j-1]:\n                    output.append(\"NO\")\n                    break\n            else:\n                output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    \n    return '\\n'.join(output)\n\ndef"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s1 = input()\n    s2 = input()\n\n    s1_set = set(s1)\n    s2_set = set(s2)\n\n    if t > n or t < 0:\n        return \"-1\"\n\n    if len(s1_set) == len(s2_set) == n:\n        return \"-1\"\n\n    for char in s1_set:\n        if char not in s2_set:\n            s1_set.remove(char)\n\n    for char in s2_set:\n        if char not in s1_set:\n            s2_set.remove(char)\n\n    if len(s1_set) == len(s2_set):\n        s1_set.update(s2_set)\n\n    if len(s1_set) == len(s2_set) == n - t:\n        return \"-1\"\n\n    s3 = \"\"\n    for char in s1_set:\n        if char not in s1 and char not in s2:\n            s3 += char\n            if len(s3) == t:\n                return s3\n\n    return \"-1\""
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s_1, s_2 = stdin.split(\"\\n\")[1:3]\n    \n    s_1 = list(s_1)\n    s_2 = list(s_2)\n    \n    for char in \"abcdefghijklmnopqrstuvwxyz\":\n        s_1_diff = 0\n        s_2_diff = 0\n        s_3 = list(s_1)\n        \n        for i in range(n):\n            if s_1[i] != char:\n                s_1_diff += 1\n            if s_2[i] != char:\n                s_2_diff += 1\n            if s_3[i] != char:\n                s_3_diff = 0\n            else:\n                s_3_diff += 1\n            \n            if s_1_diff + s_3_diff == t and s_2_diff + s_3_diff == t:\n                s_3[i] = char\n                break\n        else:\n            continue\n        break\n    else:\n        return \"-1\"\n    \n    return \"\".join(s_3)\n"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    s1, s2 = stdin.split()[2:]\n\n    # Check if it's possible to find a string differing from s1 and s2 in exactly t characters\n    if len(set(s1)) - len(set(s2)) != t:\n        return \"-1\"\n\n    # Create a dictionary to count the frequency of characters in s1 and s2\n    char_freq = {}\n    for char in s1:\n        char_freq[char] = char_freq.get(char, 0) + 1\n    for char in s2:\n        char_freq[char] = char_freq.get(char, 0) - 1\n\n    # Create a list of characters that can be used to create the string s3\n    available_chars = [char for char, freq in char_freq.items() if abs(freq) == t]\n\n    # If there are enough characters available, create s3\n    if len(available_chars) >= n:\n        s3 = \"\".join(available_chars)[:n]\n    else:\n        return \"-1\"\n\n    return s3\n"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    s_1, s_2 = stdin.split()[2:]\n\n    def count_diff(s1: str, s2: str) -> int:\n        count = 0\n        for i in range(n):\n            if s1[i] != s2[i]:\n                count += 1\n        return count\n\n    if count_diff(s_1, s_2) == t:\n        s_3 = s_1\n        for i in range(n):\n            if s_3[i] == s_2[i]:\n                s_3 = s_3[:i] + 'a' + s_3[i + 1:]\n                break\n        return s_3\n    else:\n        return -1\n"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    s_1, s_2 = stdin.split('\\n')[1:]\n    s_1 = list(s_1)\n    s_2 = list(s_2)\n    for i in range(n):\n        if s_1[i] != s_2[i]:\n            s_1[i] = s_2[i]\n            break\n    else:\n        return -1\n    return ''.join(s_1)\n"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    s1, s2 = stdin.split()[2:]\n\n    if len(s1) != n or len(s2) != n:\n        return -1\n\n    if t > n // 2:\n        return -1\n\n    for s3 in set(s1) ^ set(s2):\n        count = s1.count(s3) + s2.count(s3)\n        if count == t:\n            return s3 * n\n\n    return -1\n\n\ndef"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    s1 = input_list[1]\n    s2 = input_list[2]\n\n    if t > n:\n        return \"-1\"\n\n    for i in range(n):\n        if s1[i] != s2[i]:\n            t -= 1\n\n    if t == 0:\n        return s1\n    elif t == n:\n        return s2\n    else:\n        return \"-1\"\n\n\nstdin = \"\"\"3 2\nabc\nxyc\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    s_1 = stdin.split()[2]\n    s_2 = stdin.split()[3]\n\n    if t > n or t < 0:\n        return \"-1\"\n\n    s_3 = \"\"\n    for i in range(n):\n        if i < t:\n            s_3 += \"a\"\n        elif s_1[i] == s_2[i]:\n            s_3 += \"a\"\n        else:\n            s_3 += \"b\"\n\n    return s_3\n\n\nstdin = \"\"\"3 2\nabc\nxyc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1 0\nc\nb\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    s1, s2 = lines[1], lines[2]\n\n    # Check if s1 and s2 have the same characters in the same positions\n    if sorted(s1) == sorted(s2):\n        return -1\n\n    # Check if there is a string s3 with t characters different from s1 and s2\n    for i in range(100):\n        s3 = ''\n        for j in range(n):\n            if s1[j] == s2[j]:\n                s3 += chr(i + ord('a'))\n            else:\n                s3 += s1[j]\n        if f(s1, s3) == t and f(s2, s3) == t:\n            return s3\n\n    return -1\n\n\ndef"
    },
    {
        "number": 545,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    s1, s2 = stdin.split()[2:]\n    \n    if t > n or t < 0:\n        return -1\n    \n    if len(s1) != n or len(s2) != n:\n        return -1\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            if s1[i] != s1[t] and s2[i] != s2[t]:\n                return s1[:i] + s1[t] + s1[i+1:]\n    return -1\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = input().split()\n    stdin = stdin.split('\\n')[1:-1]\n\n    def is_match(query: str) -> str:\n        result = True\n        for i, char in enumerate(pattern):\n            if char == \"?\":\n                if query[i] not in good_letters:\n                    result = False\n                    break\n            elif char == \"*\":\n                if i < len(query) and query[i] not in good_letters:\n                    result = False\n                    break\n            else:\n                if char != query[i]:\n                    result = False\n                    break\n        return \"YES\" if result else \"NO\"\n\n    return '\\n'.join(is_match(query) for query in stdin)"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = stdin.split('\\n')\n    good_letters = set(good_letters)\n\n    def is_match(query: str) -> str:\n        result = True\n        for c in query:\n            if c == '?':\n                result = result and (c in good_letters)\n            elif c == '*':\n                result = result and (True)\n            else:\n                result = result and (c in good_letters)\n        return \"YES\" if result else \"NO\"\n\n    queries = [query.strip() for query in stdin.split('\\n')[n:] if query.strip() != '']\n    answers = [is_match(query) for query in queries]\n    return '\\n'.join(answers)\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = input().split()\n    query_strings = input().split()\n    \n    for i in range(n):\n        query_string = query_strings[i]\n        match = True\n        j = 0\n        \n        for char in pattern:\n            if char == \"?\":\n                if query_string[j] not in good_letters:\n                    match = False\n                    break\n                j += 1\n            elif char == \"*\":\n                if query_string[j:] not in good_letters:\n                    match = False\n                    break\n                j = len(query_string)\n            else:\n                if query_string[j] != char:\n                    match = False\n                    break\n                j += 1\n                \n        if match:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def match_pattern(pattern, query):\n        pattern = list(pattern)\n        query = list(query)\n        index = 0\n        while pattern:\n            if pattern[0] == '?':\n                pattern.pop(0)\n                query.pop(0)\n            elif pattern[0] == '*':\n                if pattern[1] == '?':\n                    pattern.pop(0)\n                    pattern.pop(0)\n                    while index < len(query) and query[index] != '?':\n                        index += 1\n                else:\n                    pattern.pop(0)\n                    if index < len(query):\n                        index += 1\n        if index == len(query):\n            return True\n        return False\n\n    stdin = stdin.splitlines()\n    good_letters = stdin[0]\n    pattern = stdin[1]\n    n = int(stdin[2])\n    queries = stdin[3:]\n\n    for query in queries:\n        if match_pattern(pattern, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = stdin.split('\\n')\n    n = int(n)\n\n    def match_pattern(pattern: str, query: str) -> bool:\n        pattern_pos = 0\n        query_pos = 0\n\n        while pattern_pos < len(pattern) and query_pos < len(query):\n            if pattern[pattern_pos] == '?':\n                pattern_pos += 1\n            elif pattern[pattern_pos] == '*':\n                while pattern[pattern_pos] == '*':\n                    pattern_pos += 1\n            else:\n                if pattern[pattern_pos] == query[query_pos]:\n                    pattern_pos += 1\n                    query_pos += 1\n                else:\n                    return False\n\n        return pattern_pos == len(pattern) and query_pos == len(query)\n\n    output = []\n    for _ in range(n):\n        query = input()\n        output.append(\"YES\" if match_pattern(pattern, query) else \"NO\")\n\n    return \"\\n\".join(output)\n\n\nstdin = \"\"\"\nab\na?a\n2\naaa\naab\n\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"\nabc\na?a?a*\n4\nabacaba\nabaca\napapa\naaaaax\n\"\"\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    stdin = [line.split() for line in stdin]\n\n    good_letters = stdin[0][0]\n    pattern = stdin[1][0]\n    n = int(stdin[2][0])\n    query_strings = stdin[3:]\n\n    def is_match(pattern, query_string):\n        if len(pattern) > len(query_string):\n            return False\n\n        j = 0\n        for i in range(len(pattern)):\n            if pattern[i] == '?':\n                while j < len(query_string) and query_string[j] != pattern[i]:\n                    j += 1\n            else:\n                if pattern[i] != query_string[j]:\n                    return False\n                j += 1\n\n        return True\n\n    for i in range(n):\n        query_string = query_strings[i][0]\n        if is_match(pattern, query_string):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(c: str) -> bool:\n        return c in good_letters\n\n    def replace_question(pattern: str, good_letters: str) -> str:\n        result = \"\"\n        for c in pattern:\n            if c == \"?\":\n                if good_letters:\n                    result += good_letters[0]\n                    good_letters = good_letters[1:]\n                else:\n                    result += bad_letters[0]\n                    bad_letters = bad_letters[1:]\n            else:\n                result += c\n        return result\n\n    good_letters, pattern, n = stdin.split(\"\\n\")\n    pattern = pattern.strip()\n    bad_letters = \"\".join(set(pattern) - set(good_letters))\n    good_letters = \"\".join(set(pattern) & set(good_letters))\n\n    queries = stdin.split(\"\\n\")[3:]\n    for query in queries:\n        if is_good(query[0]):\n            if pattern.count(\"?\") == 1:\n                pattern = pattern.replace(\"?\", query[0], 1)\n                pattern = replace_question(pattern, good_letters)\n                if query == pattern:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n            else:\n                pattern = replace_question(pattern, good_letters)\n                if query == pattern:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n        else:\n            if pattern.count(\"?\") == 1:\n                pattern = pattern.replace(\"?\", query[0], 1)\n                pattern = replace_question(pattern, good_letters)\n                if query == pattern:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n            else:\n                pattern = replace_question(pattern, good_letters)\n                if query == pattern:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = stdin.split(\"\\n\")\n    good_letters = set(good_letters)\n    \n    def is_match(query: str) -> str:\n        i, j = 0, 0\n        while i < len(query) and j < len(pattern):\n            if pattern[j] == '?':\n                if query[i] in good_letters:\n                    i += 1\n                j += 1\n            elif pattern[j] == '*':\n                while j < len(pattern) and pattern[j] == '*':\n                    j += 1\n                if j == len(pattern):\n                    return \"YES\"\n                for k in range(i, len(query)):\n                    if query[k] in good_letters:\n                        i = k + 1\n                        j = k + 1\n                        break\n                if j == len(pattern):\n                    return \"YES\"\n            else:\n                if query[i] == pattern[j]:\n                    i += 1\n                j += 1\n        return \"YES\" if i == len(query) and j == len(pattern) else \"NO\"\n    \n    for i in range(int(n)):\n        query = input()\n        print(is_match(query))\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = input().split()\n    n = int(n)\n    good_letters = set(good_letters)\n    query_strings = [input() for _ in range(n)]\n    for query_string in query_strings:\n        if len(set(query_string) - good_letters) == 0 and len(pattern) == len(query_string):\n            for i, c in enumerate(query_string):\n                if pattern[i] == '?':\n                    continue\n                elif pattern[i] == '*':\n                    if i > 0 and pattern[i-1] == '*':\n                        continue\n                    else:\n                        if c not in good_letters:\n                            break\n            else:\n                print(\"YES\")\n                continue\n        print(\"NO\")\n"
    },
    {
        "number": 546,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern, n = input_str.split('\\n')\n    good_letters = set(good_letters)\n    queries = []\n\n    for _ in range(n):\n        query = input()\n        queries.append(query)\n\n    for query in queries:\n        if len(query) != len(pattern):\n            print(\"NO\")\n        else:\n            matches = True\n            for i in range(len(query)):\n                if pattern[i] == \"?\":\n                    if query[i] not in good_letters:\n                        matches = False\n                        break\n                elif pattern[i] == \"*\":\n                    matches = True\n                elif query[i] != pattern[i]:\n                    matches = False\n                    break\n            print(\"YES\" if matches else \"NO\")\n\ninput_str = input()\nsolution(input_str) "
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    passwords = [input() for _ in range(n)]\n    correct_password = input()\n\n    # Find the shortest password\n    shortest_password = min(passwords, key=len)\n\n    # Calculate the time required to enter the shortest password\n    time_to_enter_shortest = len(shortest_password)\n\n    # Calculate the time required to enter the correct password\n    time_to_enter_correct = len(correct_password)\n\n    # Calculate the time required to be blocked\n    blocked_time = 5 + (k - 1) * 5\n\n    # Calculate the total time in the best case\n    best_case_time = time_to_enter_shortest + time_to_enter_correct\n\n    # Calculate the total time in the worst case\n    worst_case_time = n * blocked_time\n\n    return best_case_time, worst_case_time\n\n\ndef"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    passwords = [input() for _ in range(n)]\n    correct_password = input()\n\n    password_length = len(passwords[0])\n    passwords.sort(key=len)\n\n    time_to_be_authorized = 0\n    worst_case_time = 0\n    for i, password in enumerate(passwords):\n        time_to_enter = 1 + (i - 1) * 5\n        worst_case_time += time_to_enter\n\n        if len(password) == password_length:\n            if password == correct_password:\n                time_to_be_authorized += time_to_enter\n                break\n            else:\n                worst_case_time += 1\n\n    return f\"{time_to_be_authorized} {worst_case_time}\" "
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    passwords = stdin.split('\\n')[1:-1]\n    correct_password = stdin.split('\\n')[-1]\n\n    passwords.sort(key=len)\n    # Check if the correct password is in the list\n    if correct_password in passwords:\n        index = passwords.index(correct_password)\n        if index == 0:\n            time_best = 1\n        else:\n            time_best = sum([len(password) for password in passwords[:index]]) + index\n\n        if len(passwords) == 1:\n            time_worst = time_best\n        else:\n            time_worst = time_best + k * (5 + index * 10)\n    else:\n        time_best = time_worst = -1\n\n    return f\"{time_best} {time_worst}\"\n\n\ninput_file = \"input.txt\"\nwith open(input_file, \"r\") as f:\n    stdin = f.read()\n    print(solution(stdin))"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    passwords = stdin.split('\\n')[1:-1]\n    password = stdin.split('\\n')[-1]\n\n    passwords = sorted(set(passwords), key=lambda x: len(x))\n\n    seconds = 0\n    best_case = 0\n    worst_case = 0\n\n    for i, password in enumerate(passwords):\n        if len(password) == len(passwords[0]):\n            best_case = seconds + 1\n            worst_case = max(worst_case, seconds + 1)\n            break\n\n        if password == password.lower() and password == password.upper():\n            best_case = max(best_case, seconds + 1)\n            worst_case = max(worst_case, seconds + 1)\n            continue\n\n        if password == password.lower():\n            best_case = max(best_case, seconds + 1)\n            worst_case = max(worst_case, seconds + 5 + i * 5 + 1)\n            continue\n\n        if password == password.upper():\n            best_case = max(best_case, seconds + 1)\n            worst_case = max(worst_case, seconds + 5 + (i - 1) * 5 + 1)\n            continue\n\n        if i % (k + 1) == 0:\n            worst_case = max(worst_case, seconds + 5 + 1)\n\n        seconds += 1\n\n    best_case += 1\n    worst_case += 1\n\n    return f\"{best_case} {worst_case}\"\n"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    passwords = stdin.split('\\n')\n    correct_password = passwords[-1]\n    passwords.pop()\n    \n    # Calculate the worst case time\n    worst_case_time = n * (2 + k) * 1\n    \n    # Calculate the best case time\n    best_case_time = 0\n    for password in passwords:\n        if len(password) == len(correct_password):\n            best_case_time += 1\n    \n    # Calculate the total time in the worst case\n    worst_case_time = worst_case_time + best_case_time\n    \n    return f\"{worst_case_time} {worst_case_time}\""
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_password(password: str) -> bool:\n        return all(c.isalnum() for c in password) and password == password.lower()\n\n    def get_password_lengths(passwords: List[str]) -> List[int]:\n        return sorted({len(password) for password in passwords})\n\n    def get_password_by_length(passwords: List[str], length: int) -> Optional[str]:\n        return next((password for password in passwords if len(password) == length), None)\n\n    def get_authorization_time(passwords: List[str], correct_password: str) -> int:\n        password_lengths = get_password_lengths(passwords)\n        time_spent = 0\n\n        for length in password_lengths:\n            password = get_password_by_length(passwords, length)\n            if password == correct_password:\n                return time_spent\n            else:\n                if length > 1:\n                    time_spent += 5\n                time_spent += length\n\n        return -1\n\n    def get_authorization_times(passwords: List[str], correct_password: str) -> Tuple[int, int]:\n        password_lengths = get_password_lengths(passwords)\n        best_case_time = get_authorization_time(passwords, correct_password)\n        worst_case_time = 0\n\n        for length in password_lengths:\n            password = get_password_by_length(passwords, length)\n            if password == correct_password:\n                worst_case_time = max(worst_case_time, length)\n            else:\n                if length > 1:\n                    worst_case_time += 5\n                worst_case_time += length\n\n        return best_case_time, worst_case_time\n\n    n, k = map(int, stdin.split()[:2])\n    passwords = [line.strip() for line in stdin.split('\\n')[1:-1]]\n    correct_password = stdin.split('\\n')[-1].strip()\n\n    if not all(is_valid_password(password) for password in passwords):\n        raise ValueError(\"Invalid password\")\n\n    if correct_password not in passwords:\n        raise ValueError(\"Correct password not found\")\n\n    best_case_time, worst_case_time = get_authorization_times(passwords, correct_password)\n\n    return f\"{best_case_time} {worst_case_time}\"\n"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    passwords = sorted(stdin.split()[2:-1])\n    correct_password = stdin.split()[-1]\n    \n    best_case_time = sum(len(p) for p in passwords)\n    worst_case_time = best_case_time\n    \n    for i, password in enumerate(passwords):\n        if password == correct_password:\n            if i == 0:\n                best_case_time = len(password)\n            else:\n                best_case_time = sum(len(p) for p in passwords[:i]) + len(password)\n            break\n            \n    for i, password in enumerate(passwords[::-1]):\n        if password == correct_password:\n            if n - i == 1:\n                worst_case_time = len(password)\n            else:\n                worst_case_time = sum(len(p) for p in passwords[n-i:]) + len(password)\n            break\n            \n    return f\"{best_case_time} {worst_case_time}\""
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    passwords = sorted(set(stdin.split()[2:-1]))\n    password = stdin.split()[-1]\n\n    max_time = 0\n    best_case = 0\n\n    for i in range(len(passwords)):\n        if passwords[i] == password:\n            best_case = i + 1\n            break\n\n    if k == 0:\n        max_time = best_case\n    else:\n        max_time = (n - best_case) * 1 + (k - 1) * 5 + best_case\n\n    return f\"{best_case} {max_time}\"\n"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def password_length(password: str) -> int:\n        return len(password)\n\n    def is_valid_password(password: str, valid_passwords: List[str]) -> bool:\n        return password in valid_passwords\n\n    def calculate_time_to_authorize(valid_passwords: List[str], correct_password: str, k: int) -> Tuple[int, int]:\n        valid_passwords.sort(key=password_length)\n        best_case_time = 0\n        worst_case_time = 0\n\n        for password in valid_passwords:\n            current_time = 1\n            wrong_tries = 0\n            if is_valid_password(password, [correct_password]):\n                return best_case_time, worst_case_time\n\n            for i in range(k + 1):\n                if wrong_tries == k:\n                    current_time += 5\n                    wrong_tries = 0\n                if i < len(valid_passwords) and valid_passwords[i] == password:\n                    current_time += 1\n                    wrong_tries += 1\n                    if is_valid_password(password, [correct_password]):\n                        best_case_time = current_time\n                        worst_case_time = current_time\n                        return best_case_time, worst_case_time\n\n        return best_case_time, worst_case_time\n\n    def process_input(input_data: List[str]) -> Tuple[List[str], str, int]:\n        n, k = map(int, input_data[0].split())\n        valid_passwords = input_data[1:n + 1]\n        correct_password = input_data[-1]\n        return valid_passwords, correct_password, k\n\n    input_data = stdin.splitlines()\n    valid_passwords, correct_password, k = process_input(input_data)\n    best_case_time, worst_case_time = calculate_time_to_authorize(valid_passwords, correct_password, k)\n    result = f\"{best_case_time} {worst_case_time}\"\n    return result"
    },
    {
        "number": 547,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_time(n, k):\n        if n == 1:\n            return 1\n        else:\n            return min(get_time(n - 1, k), max(get_time(n - 1, k) + 5, get_time(n - 1, k - 1) + 1))\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    correct_password = lines[-1]\n\n    time = get_time(n, k)\n\n    return f'{time} {time}'"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    if n % 2 == 0:\n        return \"Second\"\n    else:\n        return \"First\""
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    array = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # Check if first player can win\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray = array[i:j]\n            if sum(subarray) % 2 == 1:\n                if sum(subarray) != 0:\n                    new_array = array[:i] + array[j:]\n                    if sum(new_array) % 2 == 1:\n                        return \"First\"\n                    else:\n                        return \"Second\"\n\n    # Check if second player can win\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray = array[i:j]\n            if sum(subarray) % 2 == 0:\n                if sum(subarray) != 0:\n                    new_array = array[:i] + array[j:]\n                    if sum(new_array) % 2 == 1:\n                        return \"Second\"\n                    else:\n                        return \"First\"\n\n    # If both players can't win, return \"First\"\n    return \"First\"\n"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n\n    if sum(array) % 2 == 0:\n        return \"Second\"\n\n    first_player = True\n    while True:\n        max_sum = 0\n        max_start = -1\n        max_end = -1\n        for i in range(len(array)):\n            current_sum = 0\n            for j in range(i, len(array)):\n                current_sum += array[j]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n                    max_start = i\n                    max_end = j\n\n        if max_sum % 2 == 0:\n            if first_player:\n                return \"Second\"\n            else:\n                first_player = True\n        else:\n            if first_player:\n                array = array[:max_start] + array[max_end+1:]\n                first_player = False\n            else:\n                return \"First\"\n\n\ninput_data = \"\"\"4\n1 3 2 3\n2\n2 2\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n    \n    while sum(array) != 0:\n        if sum(array) % 2 == 1:\n            return \"First\"\n        first_player_move = True\n        i = 0\n        while i < n:\n            if array[i] != 0:\n                break\n            i += 1\n        while i < n:\n            if first_player_move and (sum(array[i:i+1]) % 2 == 1):\n                break\n            elif not first_player_move and (sum(array[i:i+1]) % 2 == 0):\n                break\n            i += 1\n        if first_player_move:\n            array = array[:i] + array[i+1:]\n        else:\n            array = array[:i] + array[i+1:]\n    \n    return \"Second\"\n"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    for i in range(n-1):\n        if a[i] == 0:\n            continue\n        if a[i] % 2 == 0 and sum(a[i:]) % 2 == 0:\n            return \"First\"\n        if a[i] % 2 == 1 and sum(a[i:]) % 2 == 1:\n            return \"First\"\n    \n    return \"Second\"\n"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    nums = list(map(int, input_data[1].split()))\n\n    if n == 1:\n        return \"Second\"\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] + dp[j] % 2 == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    if dp[-1] % 2 == 0:\n        return \"Second\"\n    else:\n        return \"First\"\n\n\nstdin = \"\"\"4\n1 3 2 3\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\n2 2\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    arr = list(map(int, input_data[1].split()))\n    \n    # check if first player can make a move\n    for i in range(n - 1):\n        if arr[i] != 0 and arr[i + 1] != 0 and (arr[i] + arr[i + 1]) % 2 == 1:\n            arr = arr[:i] + arr[i + 2:]\n            break\n    \n    # check if second player can make a move\n    for i in range(n - 1):\n        if arr[i] != 0 and arr[i + 1] != 0 and (arr[i] + arr[i + 1]) % 2 == 0:\n            arr = arr[:i] + arr[i + 2:]\n            return \"First\"\n    \n    return \"Second\"\n"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    arr = list(map(int, input_data[1].split()))\n\n    def can_move(arr, start, end):\n        subarray = arr[start:end + 1]\n        return any(sum(subarray[i:i + 2]) % 2 == 1 for i in range(len(subarray) - 1))\n\n    if can_move(arr, 0, n - 1):\n        return \"First\"\n    else:\n        return \"Second\"\n"
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return \"First\" if arr[0] % 2 == 1 else \"Second\"\n    \n    for i in range(n):\n        if arr[i] % 2 == 1:\n            return \"First\"\n    \n    return \"Second\" "
    },
    {
        "number": 548,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n    first_player_won = False\n\n    while len(array) > 1:\n        subarrays = []\n        current_sum = 0\n        start = 0\n        for i, num in enumerate(array):\n            current_sum += num\n            if current_sum == 0:\n                subarrays.append((start, i))\n                current_sum = 0\n                start = i + 1\n            elif current_sum % 2 == 1 and i == len(array) - 1:\n                subarrays.append((start, i + 1))\n\n        if len(subarrays) % 2 == 1:\n            first_player_won = True\n            break\n\n        for i in range(0, len(subarrays), 2):\n            array = array[:subarrays[i][0]] + array[subarrays[i][1]:]\n\n    return \"First\" if first_player_won else \"Second\"\n\n\nstdin = '''4\n1 3 2 3'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    while a * (a + 1) // 2 < n:\n        a += 1\n    b = (a * (a + 1) // 2) - (a - 1) * a // 2\n    if b > n:\n        b = (a - 1) * (a - 1) // 2 + (a - 1) - (n - a * (a - 1) // 2)\n    return f\"{a} {b}\"\n"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    # Initialize variables to store the result\n    a = 1\n    b = n\n\n    # Loop through all possible values of a\n    while a <= b:\n        # Calculate the number of rows and columns\n        rows = a\n        columns = (n - a) // rows\n\n        # If the number of columns is greater than the number of rows, swap them\n        if columns > rows:\n            rows, columns = columns, rows\n\n        # Check if the current combination of rows and columns satisfies the problem statement\n        if (rows * columns == n) and (b - a <= columns - rows):\n            # Update the values of a and b\n            a = rows + 1\n            b = columns\n        else:\n            # Decrease the value of a\n            a += 1\n\n    # Print the result\n    return f\"{rows} {columns}\"\n"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = 1\n    while a * b < n:\n        if a > b:\n            a, b = b, a\n        a += 1\n    return f\"{a} {n//a + (n % a > 0)}\" "
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    b = n // 2 + 1\n    a = b - (n - b * b) // b\n    if a <= b:\n        return str(a) + \" \" + str(b)\n    else:\n        return str(b) + \" \" + str(a)\n"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = 1\n    b = n\n    while n % b != 0:\n        a += 1\n        b = n // a\n    return f\"{a} {b}\""
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = 1\n    while a*b < n:\n        if n % b == 0 and b <= a:\n            a = b\n            b = n // a\n        else:\n            b += 1\n    return f\"{a} {b}\"\n"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # Check if n is odd\n    if n % 2 != 0:\n        n += 1\n    \n    # Calculate rows and columns\n    rows = (n // 2) + 1\n    columns = rows * 2\n    \n    return str(rows) + ' ' + str(columns)"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n\n    # Initialize variables\n    a = 1\n    b = n\n\n    # Loop through different values of a and b until the number of pixels is equal to n\n    while n // a >= b // a:\n        a += 1\n\n    # Calculate the number of rows and columns\n    num_rows = a\n    num_cols = b\n\n    return f\"{num_rows} {num_cols}\" "
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n\n    # Find the smallest number of rows and columns that add up to n\n    a = 1\n    b = n\n    while a <= b:\n        if a * b == n:\n            break\n        b -= 1\n    if a * b == n:\n        print(a, b)\n    else:\n        print(b, a + b - n)"
    },
    {
        "number": 549,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = 1\n    b = 1\n    while a * b < n:\n        if b > n // a:\n            a += 1\n        else:\n            b += 1\n    return f\"{a} {n//a + n%a}\" "
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    user_login, existing_logins = stdin.split('\\n')\n    existing_logins = existing_logins.split()\n    existing_logins = [login.lower() for login in existing_logins]\n    user_login = user_login.lower()\n\n    def transform(char):\n        if char == 'O':\n            return '0'\n        elif char in ('o', 'l', '1', 'i'):\n            return 'O' if char in ('o', 'l') else '1'\n        else:\n            return char\n\n    def is_similar(login1, login2):\n        if len(login1) != len(login2):\n            return False\n        for c1, c2 in zip(login1, login2):\n            if c1 != c2 and transform(c1) != transform(c2):\n                return False\n        return True\n\n    for existing_login in existing_logins:\n        if is_similar(user_login, existing_login):\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    login = stdin[0].strip()\n    n = int(stdin[1].strip())\n    existing_logins = stdin[2:]\n    existing_logins = [line.strip() for line in existing_logins]\n\n    # Define a function to transform a letter\n    def transform_letter(letter: str) -> str:\n        if letter.islower():\n            return letter.upper()\n        elif letter.isupper():\n            return letter.lower()\n        else:\n            return letter\n\n    # Define a function to transform a digit\n    def transform_digit(digit: str) -> str:\n        if digit == \"0\":\n            return \"O\"\n        elif digit == \"1\":\n            return \"l\" if random.randint(0, 1) == 0 else \"I\"\n        else:\n            return digit\n\n    # Iterate through the existing logins and check if the new login is similar\n    for existing_login in existing_logins:\n        if len(login) != len(existing_login):\n            continue\n\n        transform = lambda x: transform_letter(x) if x.isalpha() else transform_digit(x)\n        for i in range(len(login)):\n            if transform(login[i]) != transform(existing_login[i]):\n                break\n        else:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    user_login, existing_logins = stdin.split('\\n')\n    existing_logins = existing_logins.split('\\n')\n    existing_logins = [login.replace('O', '0').replace('1', 'l') for login in existing_logins]\n    user_login = user_login.replace('O', '0').replace('1', 'l')\n    \n    for existing_login in existing_logins:\n        if are_similar(existing_login, user_login):\n            return 'No'\n    \n    return 'Yes'\n\ndef"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    user_login = lines[0]\n    existing_logins = lines[2:]\n\n    def transform(login: str) -> str:\n        transformed = ''\n        for char in login:\n            if char.islower():\n                transformed += char.upper()\n            elif char.isupper():\n                transformed += char.lower()\n            elif char == '0':\n                transformed += 'O'\n            elif char == 'O':\n                transformed += '0'\n            elif char == '1':\n                transformed += 'l'\n            elif char == 'l':\n                transformed += '1'\n            elif char == 'I':\n                transformed += 'i'\n            elif char == 'i':\n                transformed += 'I'\n        return transformed\n\n    def is_similar(login1: str, login2: str) -> bool:\n        return transform(login1) == transform(login2)\n\n    for existing_login in existing_logins:\n        if is_similar(user_login, existing_login):\n            return 'No'\n    return 'Yes'"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    login, n = input().split()\n    existing_logins = input().split()\n    \n    def transform(s):\n        s = s.lower()\n        s = s.replace('o', '0')\n        s = s.replace('l', '1')\n        s = s.replace('i', '1')\n        return s\n    \n    def is_similar(s, t):\n        return transform(s) == transform(t)\n\n    for existing_login in existing_logins:\n        if is_similar(login, existing_login):\n            return \"No\"\n    \n    return \"Yes\""
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    user_login, n = stdin.splitlines()\n    existing_logins = stdin.splitlines()[2:]\n\n    # Helper function to transform letters\n    def transform_letter(letter: str) -> str:\n        if letter.isupper():\n            return 'O' if letter == 'L' else 'l' if letter == 'I' else letter.lower()\n        else:\n            return '0' if letter == 'O' else '1' if letter == 'l' else 'i' if letter == 'I' else letter.upper()\n\n    # Helper function to check if two strings are similar\n    def are_similar(str1: str, str2: str) -> bool:\n        if len(str1) != len(str2):\n            return False\n        for c1, c2 in zip(str1, str2):\n            if c1 != c2:\n                if c1.isupper() != c2.isupper():\n                    return False\n                if c1.isdigit() != c2.isdigit():\n                    return False\n                if c1.isdigit() and c2.isdigit() and (transform_letter(c1) != c2 or transform_letter(c2) != c1):\n                    return False\n        return True\n\n    # Check if user login is similar with any of the existing ones\n    for login in existing_logins:\n        if are_similar(login, user_login):\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    login, n = input(stdin).split()\n    existing_logins = []\n    for i in range(int(n)):\n        existing_logins.append(input())\n\n    def transform(s):\n        return s.lower() if s.isupper() else s.upper()\n\n    def transform_o(s):\n        return '0' if s == 'O' else 'O'\n\n    def transform_1(s):\n        return 'l' if s == '1' else 'I' if s == 'i' else '1'\n\n    def is_similar(s, t):\n        if len(s) != len(t):\n            return False\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                continue\n            if s[i] == transform(t[i]):\n                continue\n            if s[i] == transform_o(t[i]):\n                continue\n            if s[i] == transform_1(t[i]):\n                continue\n            return False\n        return True\n\n    for existing in existing_logins:\n        if is_similar(login, existing):\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def transform(s: str) -> str:\n        s = s.lower()\n        result = ''\n        for char in s:\n            if char.isdigit():\n                if char == '1':\n                    result += 'i'\n                elif char == '0':\n                    result += 'o'\n                else:\n                    result += char\n            elif char == 'o':\n                result += '0'\n            elif char == 'l':\n                result += '1'\n            elif char == 'i':\n                result += 'l'\n            else:\n                result += char\n        return result\n\n    def is_similar(s: str, t: str) -> bool:\n        s = transform(s)\n        t = transform(t)\n        return s == t\n\n    stdin_lines = stdin.splitlines()\n    login = stdin_lines[0]\n    n = int(stdin_lines[1])\n    existing_logins = stdin_lines[2:2 + n]\n\n    for existing_login in existing_logins:\n        if is_similar(login, existing_login):\n            return 'No'\n    return 'Yes'\n\n\ninput_data = \"\"\"\n1_wat\n2\n2_wat\nwat_1\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n000\n3\n00\nooA\noOo\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n_i_\n3\n__i_\n_1_\nI\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n0Lil\n2\nLIL0\n0Ril\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nLa0\n3\n2a0\nLa1\n1a0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\nabc\n1\naBc"
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    login, n = stdin.splitlines()\n    existing_logins = stdin.splitlines()[2:]\n    \n    def transform(login: str) -> str:\n        result = \"\"\n        for char in login:\n            if char.islower():\n                result += char.upper()\n            elif char.isupper():\n                result += char.lower()\n            elif char == \"O\":\n                result += \"0\"\n            elif char == \"o\":\n                result += \"o\"\n            elif char == \"1\":\n                result += \"l\"\n            elif char == \"I\":\n                result += \"i\"\n        return result\n\n    for existing_login in existing_logins:\n        if transform(login) == transform(existing_login):\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 550,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    login, n = input().split()\n    n = int(n)\n    existing_logins = []\n    for _ in range(n):\n        existing_logins.append(input())\n\n    def transform(s):\n        result = \"\"\n        for c in s:\n            if c.islower():\n                result += c.upper()\n            elif c.isupper():\n                result += c.lower()\n            elif c == \"O\":\n                result += \"0\"\n            elif c == \"o\":\n                result += \"O\"\n            elif c == \"1\":\n                result += \"l\"\n            elif c == \"I\":\n                result += \"i\"\n            elif c == \"l\":\n                result += \"1\"\n            elif c == \"i\":\n                result += \"I\"\n        return result\n\n    def is_similar(s1, s2):\n        s1 = transform(s1)\n        s2 = transform(s2)\n        return s1 == s2\n\n    for existing_login in existing_logins:\n        if is_similar(login, existing_login):\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.splitlines()[0])\n    y = list(map(int, stdin.splitlines()[1].split()))\n\n    # check if it's possible to fulfill the requirements\n    y_sorted = sorted(y)\n    y_max = max(y_sorted)\n    y_min = min(y_sorted)\n\n    for i in range(n):\n        if y[i] == y_max or y[i] == y_min:\n            continue\n\n        if y[i] < y_max and y[i] > y_min:\n            if (y_max - y_min) % (y_max - y[i]) == 0:\n                return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    y = [int(y) for y in stdin[1].strip().split()]\n\n    if n == 2:\n        if y[0] == y[1]:\n            return \"Yes\"\n        else:\n            return \"No\"\n    elif n == 3:\n        if y[0] == y[1] and y[0] == y[2] or y[1] == y[0] and y[1] == y[2] or y[2] == y[0] and y[2] == y[1]:\n            return \"Yes\"\n        else:\n            return \"No\"\n    else:\n        for i in range(n):\n            for j in range(i+1, n):\n                if y[i] == y[j]:\n                    return \"No\"\n        return \"Yes\"\n\n\ninput_stdin = [\n    \"5\\n\",\n    \"7 5 8 6 9\\n\",\n    \"5\\n-1 -2 0 0 -5\\n\",\n    \"5\\n5 4 3 2 1\\n\",\n    \"5\\n1000000000 0 0 0 0\\n\",\n]\n\noutput_expected = [\n    \"Yes\",\n    \"No\",\n    \"No\",\n    \"No\",\n    \"Yes\",\n]\n\nfor input_str, expected_output in zip(input_stdin, output_expected):\n    output = solution(input_str)\n    assert output == expected_output, f\"Error for input: {input_str}\"\n\nprint(\"All test cases pass\") "
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    y = list(map(int, input().split()))\n\n    # Sort y list in ascending order\n    y.sort()\n\n    # Check if it's possible to fulfill the requirements\n    for i in range(n - 1):\n        if y[i + 1] - y[i] > 1:\n            for j in range(i + 2, n):\n                if y[j] - y[i + 1] > 1:\n                    return \"Yes\"\n    return \"No\""
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    y = list(map(int, input_list[1].split()))\n\n    if n == 1:\n        return \"Yes\"\n\n    y.sort()\n    diff = [y[i] - y[i - 1] for i in range(1, n)]\n\n    if all(diff[i] == diff[i - 1] for i in range(1, n)):\n        return \"No\"\n\n    return \"Yes\"\n\n\ndef"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    y = list(map(int, stdin.splitlines()[1].split()))\n    if n > 1000:\n        return \"No\"\n    y.sort()\n    for i in range(1, n):\n        if y[i] - y[i-1] > 2 * (y[n-1] - y[0]):\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    y = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if n < 3:\n        return \"Yes\"\n\n    y.sort()\n\n    for i in range(n - 2):\n        if y[i + 2] - y[i] <= 1:\n            continue\n        else:\n            return \"No\"\n\n    return \"Yes\"\n\n\ndef"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n = int(stdin.split(\"\\n\")[0])\n    y = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # Check if it's possible to draw two parallel and non-overlapping lines\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (y[i] - y[j]) * (y[k] - y[i]) == 0 and (y[k] - y[j]) * (y[i] - y[j]) == 0:\n                    return \"Yes\"\n    return \"No\""
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    y = list(map(int, input().split()))\n\n    x = set(range(1, n + 1))\n\n    # Check if there's a pair of lines that cover all points\n    lines = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            lines.append(((i, y[i]), (j, y[j])))\n\n    covered = set()\n    for line in lines:\n        for point in x:\n            if point not in covered and line_covers_point(line, point):\n                covered.add(point)\n\n        if covered == x:\n            return \"Yes\"\n\n    return \"No\"\n\ndef"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    y = list(map(int, input().split()))\n\n    y.sort()\n\n    for i in range(n-1):\n        if y[i+1] - y[i] > 2*y[0]:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 551,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    y = list(map(int, input_list[1].split()))\n\n    if len(y) != n:\n        return \"No\"\n\n    y.sort()\n    for i in range(n - 1):\n        if y[i + 1] - y[i] <= 1:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = input()\n    b = input()\n    s = input()\n\n    count = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if l1 <= r2 <= r1 and l2 <= r1 <= r2:\n                        if a[l1-1:r1] + b[l2-1:r2] == s:\n                            count += 1\n\n    print(count)\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input(stdin).split())\n    a, b, s = input(stdin).split()\n    count = 0\n\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if l1 <= r2 and l2 <= r1:\n                        count += 1\n                        s1 = a[l1 - 1:r1]\n                        s2 = b[l2 - 1:r2]\n                        if s1 + s2 == s:\n                            print(count)\n                            return\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a, b, s = input().strip(), input().strip(), input().strip()\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i <= j <= n:\n                s1 = a[i:j + 1] + b[j:n]\n                if s1 == s:\n                    count += 1\n\n    return count"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a, b, s = stdin.splitlines()[1:]\n    \n    def is_valid(l1, r1, l2, r2):\n        return (l1 <= l2 <= r1) or (l1 <= r2 <= r1) or (l2 <= l1 <= r2) or (l2 <= r1 <= r2) or (l1 <= l2 <= r2 <= r1) or (l1 <= r2 <= r1 <= r2 <= l1)\n    \n    count = 0\n    for l1 in range(1, n):\n        for r1 in range(l1, n+1):\n            a_sub = a[l1-1:r1]\n            for l2 in range(1, n):\n                for r2 in range(l2, n+1):\n                    b_sub = b[l2-1:r2]\n                    if is_valid(l1, r1, l2, r2):\n                        concat = a_sub + b_sub\n                        if concat == s:\n                            count += 1\n    return str(count)\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = input()\n    b = input()\n    s = input()\n\n    count = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    a_sub = a[l1 - 1:r1]\n                    b_sub = b[l2 - 1:r2]\n                    concat = a_sub + b_sub\n                    if len(concat) == m and s.count(concat) > 0:\n                        count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a, b, s = stdin.split('\\n')\n\n    count = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if l1 <= r2 <= r1 <= l2:\n                        ab = a[l1 - 1:r1] + b[l2 - 1:r2]\n                        if ab == s:\n                            count += 1\n\n    return count\n\n\nstdin = \"\"\"\n6 5\naabbaa\nbaaaab\naaaaa\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n, m, a, b, s):\n        count = 0\n        for l1 in range(1, n+1):\n            for r1 in range(l1, n+1):\n                for l2 in range(1, n+1):\n                    for r2 in range(l2, n+1):\n                        if (l1 <= r2 <= r1) and (l2 <= r1 <= r2):\n                            if a[l1-1:r1] + b[l2-1:r2] == s:\n                                count += 1\n        return count\n\n    n, m = map(int, stdin.split()[:2])\n    a, b, s = stdin.split()[2:]\n    return str(count_ways(n, m, a, b, s))\n\n\ndef"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    a, b, s = input_data[1:]\n    \n    count = 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(1, n):\n                for l in range(k+1, n+1):\n                    if k <= j <= l <= i:\n                        a_s = a[i-1:j]\n                        b_s = b[k-1:l]\n                        if a_s + b_s == s:\n                            count += 1\n    return str(count)\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a, b, s = stdin.splitlines()[1:]\n    count = 0\n\n    for i in range(n - m + 1):\n        for j in range(n - m + 1):\n            if any(a[i:i + m] == s[k:k + m] for k in range(n - m + 1)) and any(b[j:j + m] == s[k:k + m] for k in range(n - m + 1)):\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 552,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    a, b, s = input_list[1:]\n\n    count = 0\n    for l1 in range(1, n + 1):\n        for r1 in range(l1, n + 1):\n            for l2 in range(1, n + 1):\n                for r2 in range(l2, n + 1):\n                    if l1 <= r2 <= r1 and l2 <= r2 <= r1:\n                        substring_a = a[l1-1:r1]\n                        substring_b = b[l2-1:r2]\n                        concat_string = substring_a + substring_b\n                        if concat_string == s:\n                            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    promocodes = stdin.split(\"\\n\")[1:]\n\n    k_max = 0\n    for promocode in promocodes:\n        k = 0\n        for i in range(len(promocode)):\n            for j in range(i + 1, len(promocode) + 1):\n                if promocode[i:j] not in promocodes:\n                    k += 1\n        k_max = max(k_max, k)\n\n    return k_max"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, stdin = stdin.split(\"\\n\", 1)\n    n = int(n)\n    promo_codes = stdin.strip().split(\"\\n\")\n    \n    # Calculate the number of errors for each promocode\n    error_counts = []\n    for promo_code in promo_codes:\n        errors = 0\n        for i, digit in enumerate(promo_code):\n            if i > 0 and promo_code[i-1] != digit:\n                errors += 1\n        error_counts.append(errors)\n    \n    # Find the maximum number of errors that still allows unique identification\n    max_errors = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if error_counts[i] + error_counts[j] <= 6:\n                max_errors = max(max_errors, error_counts[i] + error_counts[j])\n    \n    return max_errors\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    promocodes = [input() for _ in range(n)]\n\n    max_k = 0\n    for promocode in promocodes:\n        for i in range(len(promocode)):\n            for digit in range(10):\n                if promocode[i] == str(digit):\n                    continue\n                if digit < int(promocode[i]):\n                    new_promocode = promocode[:i] + str(digit) + promocode[i+1:]\n                else:\n                    new_promocode = promocode[:i] + str(digit) + promocode[i+1:]\n                if new_promocode not in promocodes:\n                    max_k += 1\n    return max_k\n\n\nstdin = \"\"\"6\n211111\n212111\n222111\n111111\n112111\n121111\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    promo_codes = [input() for _ in range(n)]\n    min_k = float('inf')\n\n    for promo_code in promo_codes:\n        for i in range(len(promo_code)):\n            if promo_code[i] != '0':\n                break\n        else:\n            i += 1\n        min_k = min(min_k, len(promo_code) - i)\n\n    return min_k"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(\"\\n\")[0].split())\n    promocodes = [int(line) for line in stdin.split(\"\\n\")[1:]]\n\n    max_k = 0\n    for i in range(1, 10):\n        for j in range(10):\n            for k in range(10):\n                for l in range(10):\n                    for m in range(10):\n                        for n in range(10):\n                            # check if the combination of errors is possible\n                            if i + j + k + l + m + n <= k:\n                                # check if the entered value consists of exactly six digits\n                                if len(str(i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n)) == 6:\n                                    # check if the entered value has no more than k errors\n                                    valid = True\n                                    for code in promocodes:\n                                        entered_value = code\n                                        entered_value = entered_value - i\n                                        entered_value = entered_value - j * 10\n                                        entered_value = entered_value - k * 100\n                                        entered_value = entered_value - l * 1000\n                                        entered_value = entered_value - m * 10000\n                                        entered_value = entered_value - n * 100000\n                                        if entered_value != code:\n                                            valid = False\n                                            break\n                                    if valid:\n                                        max_k = max(max_k, i + j + k + l + m + n)\n    return max_k\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    promo_codes = stdin.split('\\n')[1:]\n    max_k = 0\n    for promo_code in promo_codes:\n        num_of_errors = 0\n        for i in range(len(promo_code)):\n            for j in range(i+1, len(promo_code)):\n                if promo_code[i] != promo_code[j]:\n                    num_of_errors += 1\n                    break\n        max_k = max(max_k, num_of_errors)\n    return max_k\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    promo_codes = stdin.split(\"\\n\")[1:]\n    \n    max_k = 0\n    for promo_code in promo_codes:\n        for k in range(1, len(promo_code)):\n            errors = 0\n            for i in range(k):\n                if promo_code[i] != promo_code[k + i]:\n                    errors += 1\n            if errors <= k:\n                max_k = max(max_k, k)\n                break\n    \n    return max_k\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    promo_codes = stdin.splitlines()[1:]\n\n    # Calculate the maximum number of errors that can occur\n    max_errors = 0\n    for promo_code in promo_codes:\n        num_errors = 0\n        for i in range(len(promo_code)):\n            if promo_code[i] == '0':\n                continue\n            elif i == 0 and promo_code[i] == '9':\n                num_errors += 1\n            elif i == 1 and promo_code[i] == '2':\n                num_errors += 1\n            elif i == 2 and promo_code[i] == '3':\n                num_errors += 1\n            elif i == 3 and promo_code[i] == '4':\n                num_errors += 1\n            elif i == 4 and promo_code[i] == '5':\n                num_errors += 1\n            elif i == 5 and promo_code[i] == '6':\n                num_errors += 1\n        max_errors = max(max_errors, num_errors)\n\n    # Calculate the maximum k that can be used\n    max_k = len(promo_codes[0]) - max_errors\n\n    return max_k\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    promo_codes = stdin.split('\\n')[1:]\n    k_list = []\n\n    for promo_code in promo_codes:\n        k_count = 0\n        for i in range(len(promo_code)):\n            if promo_code[i] != '0' and promo_code[i] != '1' and promo_code[i] != '2' and promo_code[i] != '3' and promo_code[i] != '4' and promo_code[i] != '5' and promo_code[i] != '6' and promo_code[i] != '7' and promo_code[i] != '8' and promo_code[i] != '9':\n                k_count += 1\n        k_list.append(k_count)\n\n    max_k = max(k_list)\n    return str(max_k)\n"
    },
    {
        "number": 553,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    promo_codes = stdin.splitlines()[1:]\n    k = 0\n\n    for promo_code in promo_codes:\n        for i in range(len(promo_code)):\n            for j in range(10):\n                if abs(int(promo_code[i]) - j) <= k:\n                    continue\n                else:\n                    k = max(k, abs(int(promo_code[i]) - j))\n\n    return k"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_subarray(subarray, flowers):\n        for flower in subarray:\n            if flower not in flowers:\n                return False\n        return True\n\n    def get_subarrays(flowers, subarrays):\n        subarrays_dict = {}\n        for subarray in subarrays:\n            left, right = subarray\n            subarray_flowers = [flowers[i] for i in range(left - 1, right)]\n            if is_valid_subarray(subarray_flowers, flowers):\n                subarray_key = tuple(subarray_flowers)\n                if subarray_key not in subarrays_dict:\n                    subarrays_dict[subarray_key] = 0\n                subarrays_dict[subarray_key] += 1\n        return subarrays_dict\n\n    def calculate_happiness(subarrays_dict, flowers):\n        happiness = 0\n        for subarray_flowers in subarrays_dict:\n            subarray_happiness = sum([a * subarrays_dict[subarray_flowers] for a in subarray_flowers])\n            happiness += subarray_happiness\n        return happiness\n\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    flowers = list(map(int, input_data[1].split()))\n    subarrays = [tuple(map(int, input_data[i+2].split())) for i in range(m)]\n\n    subarrays_dict = get_subarrays(flowers, subarrays)\n    happiness = calculate_happiness(subarrays_dict, flowers)\n\n    return str(happiness)\n"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    flowers_moods = list(map(int, input_list[1].split()))\n    subarrays = []\n    for i in range(2, len(input_list)):\n        l, r = map(int, input_list[i].split())\n        subarrays.append((l, r))\n    \n    chosen_subarrays = []\n    for i in range(n):\n        for j, k in subarrays:\n            if i in range(j, k+1):\n                chosen_subarrays.append((j, k))\n                break\n    \n    happiness = 0\n    for i in range(1, n+1):\n        count = chosen_subarrays.count((i, i))\n        happiness += flowers_moods[i-1] * count\n    \n    return happiness\n\ndef"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    flowers_moods = list(map(int, input_list[1].split()))\n    subarrays = []\n\n    for i in range(2, len(input_list)):\n        l, r = map(int, input_list[i].split())\n        subarrays.append((l, r))\n\n    subarrays.sort(key=lambda x: x[1] - x[0])\n    subarrays.sort(key=lambda x: x[1] - x[0], reverse=True)\n\n    subarrays_lengths = [r - l + 1 for l, r in subarrays]\n\n    max_happiness = 0\n\n    for i in range(2**len(subarrays_lengths)):\n        chosen_subarrays = [j for j in range(len(subarrays_lengths)) if i & (1 << j)]\n        happiness = 0\n\n        for j in range(len(flowers_moods)):\n            subarray_count = sum([1 for k in chosen_subarrays if l <= j < r])\n            happiness += flowers_moods[j] * subarray_count\n\n        max_happiness = max(max_happiness, happiness)\n\n    return str(max_happiness)\n\n\ninput_list = [\n    \"5 4\",\n    \"1 -2 1 3 -4\",\n    \"1 2\",\n    \"4 5\",\n    \"3 4\",\n    \"1 4\",\n]\n\noutput = solution(\"\\n\".join(input_list))\nprint(output) "
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_subarray_happiness(flowers, subarrays):\n        subarray_happiness = 0\n        subarray_count = {}\n\n        for subarray in subarrays:\n            subarray_count[subarray] = 0\n\n        for flower_index in range(len(flowers)):\n            subarray_count[(flower_index + 1, flower_index + 2)] += 1\n            subarray_count[(flower_index + 1, flower_index + 1)] += 1\n\n            for subarray in subarrays:\n                if subarray in subarray_count:\n                    subarray_happiness += flowers[subarray[0] - 1] * subarray_count[subarray]\n\n        return subarray_happiness\n\n    def get_maximum_happiness(n, m, flowers, subarrays):\n        max_happiness = 0\n        for i in range(2 ** m):\n            selected_subarrays = [subarrays[j] for j in range(m) if i & (1 << j)]\n            happiness = get_subarray_happiness(flowers, selected_subarrays)\n            max_happiness = max(max_happiness, happiness)\n        return max_happiness\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    flowers = list(map(int, input_data[1].split()))\n    subarrays = []\n\n    for _ in range(m):\n        l, r = map(int, input_data[2 + _].split())\n        subarrays.append((l, r))\n\n    result = get_maximum_happiness(n, m, flowers, subarrays)\n    return str(result)\n"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_happiness(flowers: list, subarrays: list) -> int:\n        happiness = 0\n        for subarray in subarrays:\n            subarray_happiness = sum([flowers[i] * len(list(group)) for i, group in groupby(sorted(subarray))])\n            happiness += subarray_happiness\n        return happiness\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    subarrays = []\n\n    for _ in range(m):\n        l, r = map(int, stdin.split()[2 + m:2 + 2 * m])\n        subarrays.append(list(range(l - 1, r)))\n\n    total_happiness = calculate_happiness(a, subarrays)\n    return str(total_happiness)\n"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    max_happiness = 0\n\n    for i in range(m):\n        l, r = map(int, stdin.split()[n+2+i*2:n+2+i*2+2])\n        subarray_happiness = 0\n        subarray_count = 0\n\n        for j in range(l-1, r):\n            subarray_happiness += a[j] * subarray_count\n            subarray_count += 1\n\n        max_happiness = max(max_happiness, subarray_happiness)\n\n    return str(max_happiness)"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    flowers = list(map(int, stdin.split()[2:n+2]))\n    subarrays = [map(int, stdin.split()[i+n+2:j+n+2+m]) for i, j in zip(range(0, m*2, 2), range(1, m*2+1, 2))] if (i//2) != (j//2)]\n    \n    def subarray_value(subarray, flowers):\n        return sum(flowers[i] * (subarray.count(i+1)) for i in range(len(flowers)))\n    \n    max_value = 0\n    for chosen_subarrays in subarrays:\n        value = sum(subarray_value(subarray, flowers) for subarray in chosen_subarrays)\n        max_value = max(max_value, value)\n        \n    return str(max_value)\n"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def max_value(n: int, m: int, flowers: list, subarrays: list) -> int:\n        happiness = [0] * n\n        for i in range(n):\n            for j in range(m):\n                l, r = subarrays[j]\n                if i in range(l - 1, r):\n                    happiness[i] += flowers[i] * (j + 1)\n        return max(happiness)\n\n    def convert_subarrays(subarrays: list) -> list:\n        result = []\n        for i, subarray in enumerate(subarrays):\n            l, r = subarray\n            result.append((l - 1, r - 1))\n        return result\n\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin[0].split())\n    flowers = list(map(int, stdin[1].split()))\n    subarrays = [tuple(map(int, subarray.split())) for subarray in stdin[2:]]\n\n    subarrays = convert_subarrays(subarrays)\n    result = max_value(n, m, flowers, subarrays)\n    return str(result)\n\n\ninput_data = '''5 4\n1 -2 1 3 -4\n1 2\n4 5\n3 4\n1 4\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_mood_value(mood: int, subarrays: list) -> int:\n        count = 0\n        for subarray in subarrays:\n            count += 1 if mood in subarray else 0\n        return count * mood\n\n    def get_max_happiness(moods: list, subarrays: list) -> int:\n        max_happiness = 0\n        for mood in moods:\n            happiness = get_mood_value(mood, subarrays)\n            max_happiness = max(max_happiness, happiness)\n        return max_happiness\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.splitlines()\n        n, m = map(int, lines[0].split())\n        moods = list(map(int, lines[1].split()))\n        subarrays = [tuple(map(int, lines[i + 2].split())) for i in range(m)]\n        return n, m, moods, subarrays\n\n    n, m, moods, subarrays = parse_input(stdin)\n    max_happiness = get_max_happiness(moods, subarrays)\n    return str(max_happiness)"
    },
    {
        "number": 554,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    flowers_moods = list(map(int, input_data[1].split()))\n    subarrays = []\n\n    for i in range(2, len(input_data)):\n        l, r = map(int, input_data[i].split())\n        subarrays.append((l, r))\n\n    def add_subarray(subarray, flowers_moods):\n        added_happiness = 0\n        for i in range(subarray[0], subarray[1] + 1):\n            added_happiness += flowers_moods[i - 1] * count\n        return added_happiness\n\n    max_happiness = 0\n    for subarray in subarrays:\n        count = 0\n        for i in range(n):\n            for subarray_idx, (l, r) in enumerate(subarrays):\n                if i >= l and i <= r:\n                    count += 1\n        happiness = add_subarray(subarray, flowers_moods)\n        max_happiness = max(max_happiness, happiness)\n\n    return str(max_happiness)"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    x_str = str(x)\n    max_len = len(x_str)\n    min_x = float('inf')\n    for i in range(1, max_len + 1):\n        y = int(x_str[:i])\n        inverted_y = int(''.join(['9' if c == '0' else '0' if c == '1' else '2' if c == '2' else '3' if c == '3' else '4' if c == '4' else '5' if c == '5' else '6' if c == '6' else '7' if c == '7' else '8' if c == '8' else '9' for c in str(y)]))\n        min_x = min(min_x, inverted_y)\n    return str(min_x)\n"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    min_x = 9\n    for digit in str(x):\n        inverted = str(9 - int(digit))\n        min_x = int(''.join([str(min(int(digit), 9 - int(digit))) for digit in str(min_x)]))\n    return str(min_x)"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    result = \"\"\n    while x > 0:\n        digit = x % 10\n        result = str(9 - digit) + result\n        x //= 10\n    return result.lstrip('0') or '0'"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    str_x = str(x)\n    result = \"\"\n    for digit in str_x:\n        if digit != \"0\":\n            result += str(9 - int(digit))\n        else:\n            result += \"9\"\n    return result if int(result) > 0 else \"1\"\n"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return str(x)\n    nums = []\n    while x > 0:\n        nums.append(x % 10)\n        x //= 10\n    max_num = 9\n    for i, num in enumerate(nums):\n        if num > max_num:\n            max_num = 9 - num\n    inverted_nums = [9 - num for num in nums]\n    inverted_nums[0] = max_num\n    result = 0\n    multiplier = 1\n    for num in inverted_nums:\n        result += num * multiplier\n        multiplier *= 10\n    return str(result)\n\n\ndef"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return str(x)\n    max_val = 999999999\n    max_inv = [max_val] * len(str(max_val))\n    for i in range(1, len(str(max_val))):\n        for j in range(i, len(str(max_val))):\n            max_inv[i] = min(max_inv[i], max_inv[j])\n            if 10 - int(str(max_val)[i]) + int(str(max_val)[j]) < 10:\n                max_inv[i] = min(max_inv[i], 10 - int(str(max_val)[i]) + int(str(max_val)[j]))\n    min_inv = 999999999\n    for i in range(1, len(str(max_val))):\n        for j in range(i, len(str(max_val))):\n            if 10 - int(str(min_inv)[i]) + int(str(min_inv)[j]) < 10:\n                min_inv = max(min_inv, 10 - int(str(min_inv)[i]) + int(str(min_inv)[j]))\n    result = str(x)\n    for i in range(len(str(x)) - 1, -1, -1):\n        if max_inv[i] < 10 - int(result[i]):\n            result = result[:i] + str(9 - int(result[i])) + result[i + 1:]\n    return result\n\n\nstdin = input(\"Enter the number: \")\nresult = solution(stdin)\nprint(\"The minimum possible positive number is:\", result) "
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return str(x)\n    while x > 0:\n        last_digit = x % 10\n        x //= 10\n        x += (9 - last_digit) * (10 ** x)\n    return str(x)\n"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    result = 0\n    while x > 0:\n        remainder = x % 10\n        result += (9 - remainder)\n        x //= 10\n    return str(result)"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    while x > 0:\n        if x % 10 != 0:\n            x = (x // 10) * 10 + (9 - (x % 10))\n        else:\n            x //= 10\n    return str(x)\n"
    },
    {
        "number": 555,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    result = \"\"\n    while x > 0:\n        remainder = x % 10\n        result = str(9 - remainder) + result\n        x = x // 10\n    if result[0] == \"0\":\n        result = result[1:]\n    return result"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = [str(pow(k, i)) for i in range(l, r+1) if pow(k, i) <= r]\n    if not result:\n        result.append(\"-1\")\n    return \" \".join(result)\n\ninput_str = \"1 10 2\"\nprint(solution(input_str))\n\ninput_str = \"2 4 5\"\nprint(solution(input_str)) "
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    power = 1\n    while power <= r:\n        if power >= l and power % k == 0:\n            result.append(power)\n        power *= k\n    return ' '.join(map(str, result)) if result else '-1'\n"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    i = 1\n    while (k**i <= r):\n        if k**i >= l:\n            result.append(k**i)\n        i += 1\n    if len(result) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    power = 1\n    while power <= r:\n        if l <= power <= r:\n            result.append(power)\n        power *= k\n    if not result:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def power(base, exponent):\n        result = 1\n        for _ in range(exponent):\n            result *= base\n        return result\n\n    l, r, k = map(int, stdin.split())\n\n    result = []\n    for i in range(int(log(r, k)) + 1):\n        value = power(k, i)\n        if value >= l and value <= r:\n            result.append(value)\n\n    if not result:\n        return \"-1\"\n\n    return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, input().split())\n    \n    result = []\n    power = 1\n    while power <= r:\n        if l <= power <= r:\n            result.append(power)\n        power *= k\n    \n    if not result:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))\n"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    current = k\n    while current <= r:\n        result.append(current)\n        current *= k\n    if all(l <= r ** i <= r for i in range(len(result))):\n        return ' '.join(map(str, result))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    l = int(input_list[0])\n    r = int(input_list[1])\n    k = int(input_list[2])\n\n    result = []\n    power = 1\n\n    while power <= r:\n        if l <= power <= r:\n            result.append(power)\n        power *= k\n\n    if len(result) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(str(num) for num in result)\n"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    l, r, k = input_values[0], input_values[1], input_values[2]\n    result = [x for x in range(l, r+1) if x % k == 0]\n    if not result:\n        return \"-1\"\n    return \" \".join(map(str, result))"
    },
    {
        "number": 556,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    result = []\n    power = 1\n    while power <= r:\n        if power >= l:\n            result.append(power)\n        power *= k\n    if not result:\n        return \"-1\"\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    teleports = []\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:3])\n        teleports.append((a, b))\n    teleports.sort(key=lambda x: x[0])\n\n    def dfs(cur_pos, limit):\n        if cur_pos == m:\n            return True\n        for teleport in teleports:\n            if teleport[0] <= cur_pos <= teleport[1] and cur_pos + teleport[1] - teleport[0] <= limit:\n                if dfs(cur_pos + teleport[1] - teleport[0], limit):\n                    return True\n        return False\n\n    if dfs(0, m):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_data = \"\"\"3 5\n0 2\n2 4\n3 5\"\"\"\n\nprint(solution(input_data))\n\n\ninput_data = \"\"\"3 7\n0 4\n2 5\n6 7\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    teleports = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        teleports.append((a, b))\n\n    def is_valid_path(path: list) -> bool:\n        if path[0] != 0:\n            return False\n        if len(path) != n + 1:\n            return False\n        visited = set(path)\n        if m in visited:\n            return True\n        for a, b in teleports:\n            if a in visited and b not in visited:\n                new_path = path + [b]\n                if is_valid_path(new_path):\n                    return True\n        return False\n\n    path = [0]\n    if is_valid_path(path):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path: list, teleports: dict) -> bool:\n        for i in range(len(path) - 1):\n            if path[i] + 1 != path[i + 1]:\n                if (path[i], path[i + 1]) not in teleports:\n                    return False\n        return True\n\n    n, m = map(int, stdin.split()[:2])\n    teleports = {}\n    for i in range(n):\n        a, b = map(int, stdin.split()[i + 2:i + 4])\n        teleports[(a, b)] = True\n\n    path = [0]\n    while path[-1] < m:\n        next_points = [p for p in range(path[-1] + 1, m + 1) if (p, path[-1]) in teleports]\n        if not next_points:\n            return \"NO\"\n        path.append(min(next_points))\n\n    return \"YES\" if is_valid_path(path, teleports) else \"NO\"\n"
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    teleports = []\n\n    for i in range(1, n + 1):\n        a, b = map(int, input_list[i].split())\n        teleports.append((a, b))\n\n    return \"YES\" if can_reach(0, m, teleports) else \"NO\"\n\n\ndef"
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    teleports = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:3])\n        teleports.append((a, b))\n\n    # Check if there's a path using teleports only\n    for i in range(n):\n        for j in range(i + 2, n + 1):\n            for k in range(j + 1, n + 1):\n                # Check if each teleport can be used to move from a to b\n                if teleports[i][1] >= teleports[i][0] and teleports[i][1] == teleports[j - 1][0] and teleports[j - 1][1] >= teleports[j - 1][0] and teleports[j - 1][1] == teleports[k][0] and teleports[k][1] >= teleports[k][0]:\n                    # Check if b is within the limits of the last teleport\n                    if teleports[k][1] >= m:\n                        return \"YES\"\n    return \"NO\""
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    teleports = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:3])\n        teleports.append((a, b))\n\n    left = 0\n    right = m\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if mid >= m:\n            return \"YES\"\n\n        can_reach = True\n\n        for a, b in teleports:\n            if a <= mid <= b:\n                continue\n\n            if a > mid:\n                can_reach = False\n                break\n\n            if b < mid:\n                left = mid + 1\n                break\n\n        if can_reach:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teleports = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        teleports.append((a, b))\n    \n    pig_house = 0\n    visited = set()\n    visited.add(pig_house)\n    queue = [(pig_house, teleports[0][0], teleports[0][1])]\n    \n    for i in range(1, n):\n        prev_teleport = teleports[i-1]\n        cur_teleport = teleports[i]\n        \n        if prev_teleport[1] < cur_teleport[0]:\n            return \"NO\"\n        \n        for j in range(len(queue)):\n            cur_point, last_point, limit = queue[j]\n            if last_point < prev_teleport[1]:\n                continue\n            new_point = max(cur_point, prev_teleport[0], prev_teleport[1])\n            if new_point <= cur_teleport[1]:\n                if new_point not in visited:\n                    visited.add(new_point)\n                    queue.append((new_point, prev_teleport[1], limit))\n                if new_point == cur_teleport[1]:\n                    return \"YES\"\n    \n    return \"NO\" "
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_teleport_possible(house_location: int, teleports: list, visited: set) -> bool:\n        for teleport in teleports:\n            if teleport[0] <= house_location <= teleport[1] and house_location not in visited:\n                visited.add(house_location)\n                if is_teleport_possible(teleport[1], teleports, visited):\n                    return True\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    teleports = [tuple(map(int, input().split())) for _ in range(n)]\n    return \"YES\" if is_teleport_possible(0, teleports, {0}) else \"NO\""
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    teleports = [tuple(map(int, stdin.split()[i:i+2])) for i in range(1, n*2, 2)]\n    \n    def can_reach(start, end):\n        if start == end:\n            return True\n        for i in range(n):\n            if start <= teleports[i][0] <= end and start <= teleports[i][1] <= end:\n                return can_reach(max(start, teleports[i][0]), min(end, teleports[i][1]))\n        return False\n    \n    return \"YES\" if can_reach(0, m) else \"NO\""
    },
    {
        "number": 557,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        a_, b_ = map(int, input().split())\n        a.append(a_)\n        b.append(b_)\n    \n    a.sort()\n    b.sort()\n    if a[0] != 0 or b[0] != 0:\n        return \"NO\"\n    for i in range(n-1):\n        if a[i+1] != a[i] + 1 or b[i+1] != b[i]:\n            return \"NO\"\n    if b[-1] < m:\n        return \"NO\"\n    return \"YES\"\n\ndef"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [1] * (K + 1)\n    for _ in range(K):\n        dp = [sum(dp[:i + 1]) % 998244353 for i in range(len(dp))]\n    dp = [sum(dp[:i + 1]) % 998244353 for i in range(len(dp))]\n    return (dp[N] - 1) % 998244353\n"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [0] * (M + 1)\n    dp[0] = 1\n    for i in range(N):\n        new_dp = [0] * (M + 1)\n        for j in range(M + 1):\n            if i == 0:\n                new_dp[j] = 1\n            else:\n                if i > K:\n                    new_dp[j] = dp[j]\n                else:\n                    for k in range(M + 1):\n                        if j - k < 0 or j - k > M:\n                            continue\n                        if j - k == 0 or j - k == M:\n                            continue\n                        new_dp[j] = (new_dp[j] + dp[j - k]) % 998244353\n        dp = new_dp\n    return dp[M]\n\n\nstdin = \"3 2 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [1] * N\n\n    for i in range(1, N):\n        for j in range(i - 1, max(-1, i - K - 1), -1):\n            if dp[i] % 998244353 == 0:\n                continue\n            if dp[j] % 998244353 == 0:\n                continue\n            if dp[i] == dp[j]:\n                dp[i] += dp[j]\n                dp[i] %= 998244353\n    return dp[-1]\n\n\nstdin = \"3 2 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [0] * (K + 1)\n    dp[0] = 1\n\n    for i in range(N):\n        new_dp = [0] * (K + 1)\n        for j in range(K + 1):\n            if i == 0:\n                new_dp[j] = dp[j]\n            elif j == 0:\n                new_dp[j] = 1\n            else:\n                for color in range(1, M + 1):\n                    if i > 1 and dp[j - 1] == color:\n                        continue\n                    new_dp[j] = (new_dp[j] + dp[j - color]) % 998244353\n        dp = new_dp\n\n    return dp[K]\n\n\ndef"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n\n    # Initialize dp array with M rows and N columns\n    dp = [[0 for _ in range(N + 1)] for _ in range(M + 1)]\n\n    # Base case: if N is 1, there is only one way to paint the block\n    for i in range(M + 1):\n        dp[i][1] = 1\n\n    # Fill the dp array using the recurrence relation\n    for i in range(1, M + 1):\n        for j in range(2, N + 1):\n            for k in range(1, j):\n                dp[i][j] += dp[i][j - k] * dp[i - 1][k]\n                dp[i][j] %= 998244353\n\n    return dp[M][N]\n"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 998244353\n\n    dp = [[0] * M for _ in range(N)]\n    dp[0] = [1] * M\n\n    for i in range(1, N):\n        for j in range(M):\n            for k in range(M):\n                if i - 1 < 0 or j != k:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= MOD\n\n    count = sum(dp[-1]) % MOD\n\n    return str(count)\n"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [[[0] * (K+1) for _ in range(M+1)] for _ in range(N+1)]\n\n    for i in range(1, M+1):\n        for j in range(1, N+1):\n            for k in range(1, K+1):\n                if i == j:\n                    dp[i][j][k] = 1\n                elif k == 0:\n                    dp[i][j][k] = 1\n                else:\n                    dp[i][j][k] = dp[i][j-1][k-1] * (M-i+1) + dp[i][j-1][k] * (M-i+1)\n                    dp[i][j][k] %= 998244353\n\n    return dp[M][N][K]"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n\n    if K == 0:\n        modulo = 998244353\n        result = 1\n        for i in range(1, M + 1):\n            result *= i\n        result = result % modulo\n        return str(result)\n\n    dp = [[[0] * M for _ in range(N)] for _ in range(2 * K + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, 2 * K + 1):\n        for j in range(N):\n            for k in range(M):\n                if j == 0 or j == N - 1:\n                    dp[i][j][k] = dp[i - 1][j][k]\n                else:\n                    dp[i][j][k] = dp[i - 1][j][k]\n                    if i - 1 > 0 and dp[i - 2][j][k] > 0:\n                        dp[i][j][k] += dp[i - 2][j][k]\n                    if j - 1 >= 0 and k == dp[i][j - 1][k]:\n                        dp[i][j][k] += dp[i][j - 1][k]\n                    if j + 1 < N and k == dp[i][j + 1][k]:\n                        dp[i][j][k] += dp[i][j + 1][k]\n                    if i - 1 > 0 and dp[i - 2][j][k] > 0 and k != dp[i - 2][j][k]:\n                        dp[i][j][k] += dp[i - 2][j][k]\n\n    result = 0\n    for j in range(N):\n        for k in range(M):\n            result += dp[2 * K][j][k]\n\n    modulo = 998244353\n    result %= modulo\n    return str(result)\n"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n\n    def dfs(remaining_blocks: int, used_colors: set, last_color: int) -> int:\n        if remaining_blocks == 0:\n            return 1\n        if remaining_blocks < 0:\n            return 0\n\n        count = 0\n        for color in range(1, M + 1):\n            if color not in used_colors or (color != last_color and len(used_colors) < K + 1):\n                count += dfs(remaining_blocks - 1, used_colors | {color}, color)\n                count %= 998244353\n\n        return count\n\n    return str(dfs(N, set(), -1))\n"
    },
    {
        "number": 558,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n\n    # Calculate the total number of possible ways to paint the blocks\n    total_ways = M ** N\n\n    # Calculate the number of ways to paint the blocks with at most K pairs of adjacent blocks painted in the same color\n    max_same_color_pairs = min(K, N - 1)\n    same_color_pairs_ways = sum(combinations(range(1, M), 2))\n    same_color_pairs_ways *= total_ways\n    same_color_pairs_ways //= M\n\n    # Calculate the number of ways to paint the blocks without at most K pairs of adjacent blocks painted in the same color\n    no_same_color_pairs_ways = total_ways - same_color_pairs_ways\n\n    # Print the result modulo 998244353\n    result = no_same_color_pairs_ways % 998244353\n    return str(result)\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, a = map(int, input().split())\n    b = [0] * (p - 1)\n    for i in range(p):\n        b[i] = (a + i) % p\n    return ' '.join(str(x) for x in b)\n\n\ninput_str = '''2\n1 0'''\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def modular_multiplicative_inverse(a: int, m: int) -> int:\n        m0 = m\n        y = 0\n        x = 1\n\n        if m == 1:\n            return 0\n\n        while a > 1:\n            q = a // m\n            t = m\n\n            m = a % m\n            a = t\n            t = y\n\n            y = x - q * y\n            x = t\n\n        if x < 0:\n            x += m0\n\n        return x\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    lines = stdin.split(\"\\n\")\n    p = int(lines[0])\n    a = list(map(int, lines[1].split()))\n\n    if not (2 <= p <= 2999) or not is_prime(p):\n        raise ValueError(\"Invalid input\")\n\n    for i in range(p):\n        if not (0 <= a[i] <= 1):\n            raise ValueError(\"Invalid input\")\n\n    def find_polynomial(p: int, a: List[int]) -> List[int]:\n        coefficients = [0] * (p - 1)\n        for i in range(p):\n            coefficients[i] = modular_multiplicative_inverse(a[i], p)\n            coefficients[i] = (coefficients[i] + p) % p\n        return coefficients\n\n    coefficients = find_polynomial(p, a)\n    return \" \".join(map(str, coefficients))\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not is_prime(p) or p < 2 or p > 2999:\n        return \"Invalid input\"\n\n    for i in range(p):\n        if a[i] < 0 or a[i] > 1:\n            return \"Invalid input\"\n\n    x = sympy.Symbol(\"x\")\n    equations = []\n    for i in range(p):\n        equations.append(sympy.Eq(sympy.Poly(sympy.polys.polytools.sympy_polynomial(f\"{x}^{p-1}\", p-1), x), a[i]))\n\n    solutions = sympy.solve(equations, f\"{x}^{p-1}, {x}^{p-2}, ..., {x}, b_{p-1}, b_{p-2}, ..., b_0\")\n    if not solutions:\n        return \"No solution found\"\n\n    b = []\n    for i in range(p-1, -1, -1):\n        b.append(int(solutions[f\"b_{i}\"].subs(x, p-1-i)))\n\n    return \" \".join(map(str, b))\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    p, *a = map(int, stdin.split())\n    assert 2 <= p <= 2999 and is_prime(p) and all(0 <= x <= 1 for x in a)\n\n    M = [0] * p\n    for i in range(p):\n        M[a[i] % p] += 1\n\n    for i in range(p):\n        if M[i] > 0:\n            b = i\n            break\n\n    f = [0] * (p - 1)\n    for i in range(p - 1):\n        f[i] = (b + i) % p\n\n    return ' '.join(str(x) for x in f)\n\n\ndef"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    p, *a = list(map(int, stdin.split()))\n    assert 2 <= p <= 2999\n    assert all(0 <= a_i <= 1 for a_i in a)\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    assert is_prime(p)\n\n    def modular_poly_mult(a: int, b: int, mod: int) -> int:\n        return (a * b) % mod\n\n    def find_coefficients(a: List[int], p: int) -> List[int]:\n        n = len(a)\n        result = [0] * n\n        result[0] = a[0]\n        for i in range(1, n):\n            result[i] = a[i]\n            for j in range(i):\n                result[i] = modular_poly_mult(result[i], 1 - a[j], p)\n                result[i] = (result[i] + p) % p\n        return result\n\n    coefficients = find_coefficients(a, p)\n    return \" \".join(str(coefficient) for coefficient in coefficients)"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    p, a = map(int, stdin.split())\n    f = [0] * (p - 1)\n    for i in range(p - 1):\n        f[i] = (a[i] + i) % p\n    for i in range(p - 1):\n        f[i] = (f[i] - i) % p\n    for i in range(p - 1):\n        f[i] = (f[i] + i) % p\n    for i in range(p - 1):\n        f[i] = (f[i] - i) % p\n    result = [str(i) for i in f]\n    return \" \".join(result)\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    p, a_seq = stdin.splitlines()\n    p = int(p)\n    a = list(map(int, a_seq.split()))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not (2 <= p <= 2999) or not is_prime(p):\n        raise ValueError(\"Invalid input\")\n\n    for a_i in a:\n        if not (0 <= a_i <= 1):\n            raise ValueError(\"Invalid input\")\n\n    def is_valid_polynomial(b):\n        for i, b_i in enumerate(b):\n            if not (0 <= b_i <= p - 1):\n                return False\n            if (f(i) % p) != (a[i] % p):\n                return False\n        return True\n\n    def f(x):\n        return sum(b[i] * x**i for i, b in enumerate(b_seq))\n\n    for b_seq in itertools.product(range(p), repeat=p - 1):\n        b_seq = list(b_seq)\n        b_seq.insert(0, 0)\n        if is_valid_polynomial(b_seq):\n            return ' '.join(str(b) for b in b_seq)\n\n    raise ValueError(\"No valid polynomial found\")\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    p, a = map(int, input().split())\n    b = [0] * (p - 1)\n    \n    for i in range(p):\n        b[(i - a) % p] += 1\n    \n    result = [str(x % p) for x in b]\n    return \" \".join(result)\n"
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def find_polynomial(p: int, a: list) -> str:\n        def is_valid(b: list) -> bool:\n            for i in range(p):\n                if not (0 <= b[i] <= p - 1):\n                    return False\n                if (a[i] + b[i]) % p != 0:\n                    return False\n            return True\n\n        def generate_polynomial(p: int, a: list) -> str:\n            result = []\n            for i in range(p - 1, -1, -1):\n                b = [0] * p\n                b[i] = (a[i] + result[i + 1]) % p if i < p - 1 else a[i]\n                if not is_valid(b):\n                    b[i] = (a[i] - result[i + 1]) % p if i < p - 1 else a[i]\n                if not is_valid(b):\n                    b[i] = (a[i] + result[i + 1] - 1) % p if i < p - 1 else a[i]\n                if not is_valid(b):\n                    b[i] = (a[i] - result[i + 1] + 1) % p if i < p - 1 else a[i]\n                result = b + result\n            return result\n\n        polynomial = generate_polynomial(p, a)\n        return \" \".join(map(str, polynomial))\n\n    if not (2 <= p <= 2999) or not is_prime(p):\n        return \"Invalid input\"\n\n    for x in a:\n        if not (0 <= x <= 1):\n            return \"Invalid input\"\n\n    return find_polynomial(p, a) "
    },
    {
        "number": 559,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    p = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    for i in range(p):\n        if not (0 <= a[i] <= 1):\n            return \"Invalid input\"\n\n    if not (2 <= p <= 2999) or not is_prime(p):\n        return \"Invalid input\"\n\n    for i in range(p):\n        a[i] = a[i] * p + 1\n\n    b = [0] * p\n\n    for i in range(p):\n        b[i] = a[i]\n\n    for i in range(p):\n        b[i] %= p\n        b[i] = p - b[i] if b[i] >= p // 2 else b[i]\n\n    result = [str(b[i]) for i in range(p)]\n    return \" \".join(result)\n\n\ndef"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0:2])\n    grid = stdin.splitlines()[1:]\n    \n    def can_eat(i, j, visited):\n        if i < 0 or i >= r or j < 0 or j >= c or visited[i][j] or grid[i][j] == 'S':\n            return False\n        visited[i][j] = True\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            can_eat(i+x, j+y, visited)\n        return True\n    \n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == '.':\n                visited = [[False for _ in range(c)] for _ in range(r)]\n                if can_eat(i, j, visited):\n                    count += 1\n    return count\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    r = int(input_list[0].split()[0])\n    c = int(input_list[0].split()[1])\n    matrix = [list(input_list[i]) for i in range(1, r+1)]\n\n    def can_eat(i, j, visited):\n        if i < 0 or i >= r or j < 0 or j >= c or matrix[i][j] == 'S' or (i, j) in visited:\n            return False\n        if matrix[i][j] == '.':\n            visited.add((i, j))\n            return True\n        return False\n\n    def dfs(i, j, visited):\n        if i == r or j == c:\n            return 1\n        if matrix[i][j] == 'S':\n            return 0\n        count = 0\n        if can_eat(i+1, j, visited):\n            count += dfs(i+1, j, visited)\n        if can_eat(i, j+1, visited):\n            count += dfs(i, j+1, visited)\n        return count\n\n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if matrix[i][j] == '.' and (i, j) not in [(0, 0), (r-1, c-1)]:\n                count += max(dfs(i+1, j, set()), dfs(i, j+1, set()))\n    return count\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')[1:]\n    \n    dp = [[0] * c for _ in range(r)]\n    max_eats = 0\n    \n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'S':\n                continue\n                \n            dp[i][j] = 1\n            for k in range(r):\n                if grid[k][j] != 'S' and dp[k][j] > 0:\n                    dp[i][j] += dp[k][j]\n            for k in range(c):\n                if grid[i][k] != 'S' and dp[i][k] > 0:\n                    dp[i][j] += dp[i][k]\n                    \n            max_eats = max(max_eats, dp[i][j])\n    \n    return max_eats\n\n\ninput_str = '''3 4\nS...\n....\n..S.'''\n\nprint(solution(input_str))  # Output: 8 "
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split(','))\n    cake = stdin.split('\\n')[1:]\n\n    max_eats = 0\n    for i in range(r):\n        row_eats = 0\n        for j in range(c):\n            if cake[i][j] == '.':\n                row_eats += 1\n        max_eats += row_eats\n\n    return str(max_eats)"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, input().split())\n    matrix = [list(input()) for _ in range(r)]\n\n    def eat_row(row_index, row_count):\n        eat_count = 0\n        while row_index < row_count and matrix[row_index][c - 1] == '.':\n            eat_count += 1\n            row_index += 1\n        return eat_count\n\n    def eat_column(column_index, column_count):\n        eat_count = 0\n        while column_index < column_count and matrix[r - 1][column_index] == '.':\n            eat_count += 1\n            column_index += 1\n        return eat_count\n\n    max_eat = 0\n    for i in range(r):\n        max_eat = max(max_eat, eat_row(i, r))\n    for j in range(c):\n        max_eat = max(max_eat, eat_column(j, c))\n\n    return str(max_eat)\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c, cake = 0, 0, \"\"\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            r, c = map(int, line.split())\n            cake = [['.' for j in range(c)] for k in range(r)]\n        else:\n            cake.append(list(line))\n    \n    def eat_cake(row, col):\n        if cake[row][col] == '.':\n            cake[row][col] = 'X'\n            return 1\n        else:\n            return 0\n\n    def can_eat(row, col):\n        return cake[row][col] == '.' and all(cake[i][col] == '.' for i in range(r)) and all(cake[row][j] == '.' for j in range(c))\n\n    def eat_once():\n        for i in range(r):\n            for j in range(c):\n                if can_eat(i, j):\n                    return eat_cake(i, j)\n        return 0\n\n    eaten = 0\n    while True:\n        eaten += eat_once()\n        if eaten == r * c - sum(1 for i in range(r) for j in range(c) if cake[i][j] == 'S'):\n            break\n\n    return eaten\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    matrix = []\n    \n    for _ in range(r):\n        matrix.append(list(stdin.readline().strip()))\n    \n    def can_eat(row_or_col):\n        evil_count = 0\n        for cell in row_or_col:\n            if cell == 'S':\n                evil_count += 1\n        return evil_count == 0\n    \n    def count_empty_cells(row_or_col):\n        return row_or_col.count('.')\n    \n    def eat(row_or_col):\n        empty_cells = count_empty_cells(row_or_col)\n        row_or_col = ['S'] * empty_cells + row_or_col[:empty_cells]\n        return ''.join(row_or_col)\n    \n    max_eaten = 0\n    \n    for i in range(r):\n        if can_eat(matrix[i]):\n            eaten = eat(matrix[i])\n            matrix[i] = eaten\n            max_eaten += count_empty_cells(eaten)\n    \n    for j in range(c):\n        row = [matrix[i][j] for i in range(r)]\n        if can_eat(row):\n            eaten = eat(row)\n            matrix = [[eaten[r] if j == i else matrix[i][j] for j in range(c)] for i in range(r)]\n            max_eaten += count_empty_cells(eaten)\n    \n    return max_eaten\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    r, c = map(int, lines[0].split())\n    cake = lines[1:]\n\n    def is_valid(row, col, visited):\n        if row < 0 or row >= r or col < 0 or col >= c:\n            return False\n        if visited[row][col]:\n            return False\n        if cake[row][col] == '.':\n            return False\n        return True\n\n    def dfs(row, col, visited):\n        visited[row][col] = True\n        if is_valid(row - 1, col, visited):\n            dfs(row - 1, col, visited)\n        if is_valid(row + 1, col, visited):\n            dfs(row + 1, col, visited)\n        if is_valid(row, col - 1, visited):\n            dfs(row, col - 1, visited)\n        if is_valid(row, col + 1, visited):\n            dfs(row, col + 1, visited)\n\n    max_count = 0\n    for i in range(r):\n        for j in range(c):\n            if cake[i][j] == '.':\n                visited = [[False for _ in range(c)] for _ in range(r)]\n                dfs(i, j, visited)\n                count = sum(sum(1 for x in row if x) for row in visited)\n                max_count = max(max_count, count)\n\n    return str(max_count)"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')[1:]\n\n    def is_valid_row(row: int, used_rows: set) -> bool:\n        return row not in used_rows and all(grid[row][j] == '.' for j in range(c))\n\n    def is_valid_col(col: int, used_cols: set) -> bool:\n        return col not in used_cols and all(grid[i][col] == '.' for i in range(r))\n\n    def eat(used_rows: set, used_cols: set) -> int:\n        max_eaten = 0\n        for row in range(r):\n            if is_valid_row(row, used_rows):\n                max_eaten += 1\n                used_rows.add(row)\n                for col in range(c):\n                    if is_valid_col(col, used_cols):\n                        max_eaten += 1\n                        used_cols.add(col)\n                        break\n                break\n        return max_eaten\n\n    used_rows = set()\n    used_cols = set()\n    max_eaten = 0\n\n    while True:\n        eaten = eat(used_rows, used_cols)\n        if eaten == 0:\n            break\n        max_eaten += eaten\n\n    return str(max_eaten)\n"
    },
    {
        "number": 560,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[:2])\n    cake = list(map(str.strip, stdin.splitlines()[1:]))\n\n    def count_evil_strawberries(cake):\n        count = 0\n        for row in cake:\n            count += row.count('S')\n        return count\n\n    def is_valid_row(row, eaten_cells):\n        return all(cell not in eaten_cells for cell in row)\n\n    def is_valid_column(column, eaten_cells):\n        return all(cake[i][column] not in eaten_cells for i in range(r))\n\n    def can_eat_row(row, eaten_cells):\n        return any(cake[i][j] not in eaten_cells for i in range(r) for j in range(c)) and is_valid_row(row, eaten_cells)\n\n    def can_eat_column(column, eaten_cells):\n        return any(cake[i][column] not in eaten_cells for i in range(r) for j in range(c)) and is_valid_column(column, eaten_cells)\n\n    def can_eat(cake, eaten_cells):\n        for i in range(r):\n            if can_eat_row(cake[i], eaten_cells):\n                return True\n        for j in range(c):\n            if can_eat_column(cake[j], eaten_cells):\n                return True\n        return False\n\n    def eat_cake(cake, eaten_cells):\n        for i in range(r):\n            if can_eat_row(cake[i], eaten_cells):\n                eaten_cells.update(cake[i])\n                return i, cake[i]\n        for j in range(c):\n            if can_eat_column(cake[j], eaten_cells):\n                eaten_cells.update(cake[j])\n                return j, cake[j]\n        return None\n\n    eaten_cells = set()\n    evil_strawberries = count_evil_strawberries(cake)\n    max_eaten = 0\n\n    while evil_strawberries > 0:\n        eat_cell, cells = eat_cake(cake, eaten_cells)\n        if eat_cell is not None:\n            max_eaten += len(cells)\n            evil_strawberries -= cells.count('S')\n            cake[eat_cell] = '.' * c\n            for i in range(r):\n                cake[i] = cake[i].replace('.', 'S', 1)\n            for j in range(c):\n                cake[j] = 'S'.join([cell if k != eat_cell else '.' for k, cell in enumerate(cake[j])])\n        else:\n            break\n\n    return max_eaten"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_arithmetic_progression(a: int) -> bool:\n        return all(cards[i] + 1 - cards[i - 1] == cards[i] - cards[i - 1] for i in range(1, len(cards)))\n\n    if is_arithmetic_progression(cards):\n        sequence = [cards[0] + i for i in range(n)]\n        sequence.append(sequence[-1] + 1)\n        return str(len(sequence)) + \"\\n\" + \"\\n\".join(map(str, sequence))\n    else:\n        for i in range(1, len(cards)):\n            if cards[i] - cards[i - 1] == 2:\n                sequence = [cards[i - 1] + j for j in range(2)]\n                sequence.append(sequence[-1] + 1)\n                return str(len(sequence)) + \"\\n\" + \"\\n\".join(map(str, sequence))\n        return \"-1\"\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    numbers = list(map(int, input().split()))\n\n    if n == 0:\n        return \"0\\n\" + \" \".join(map(str, sorted(numbers)))\n\n    numbers.sort()\n    minimum = numbers[0]\n    maximum = numbers[-1]\n    max_count = 0\n\n    for i in range(minimum, maximum + 1):\n        if i != numbers[0] and i - numbers[-1] in numbers:\n            max_count = max(max_count, numbers.count(i - numbers[-1]))\n\n    if max_count == 0:\n        return \"-1\"\n\n    result = []\n    count = numbers.count(minimum)\n    if count > max_count:\n        result.append(-minimum)\n    elif count < max_count:\n        return \"0\\n\" + \" \".join(map(str, result))\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] == 1:\n            result.append(numbers[i] - 1)\n        elif numbers[i] - numbers[i - 1] == -1:\n            result.append(numbers[i] + 1)\n\n    return str(len(result)) + \"\\n\" + \" \".join(map(str, sorted(result)))\n\n\nn_cases = int(input())\noutput = []\n\nfor _ in range(n_cases):\n    input_str = \"\\n\".join([input() for _ in range(2)])\n    output.append(solution(input_str))\n\nprint(\"\\n\".join(output)) "
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_arithmetic_progression(sequence):\n        if len(sequence) < 2:\n            return False\n        diff = sequence[1] - sequence[0]\n        return all(sequence[i] - sequence[i - 1] == diff for i in range(1, len(sequence)))\n\n    def find_arithmetic_progressions(cards):\n        progressions = set()\n        for i in range(len(cards)):\n            for j in range(i + 1, len(cards)):\n                sequence = sorted(cards[i:j + 1])\n                if is_arithmetic_progression(sequence):\n                    progressions.add(tuple(sequence))\n        return progressions\n\n    def find_distinct_integers(progressions):\n        result = set()\n        for progression in progressions:\n            result.update(progression)\n        if -1 in result:\n            return -1\n        return len(result), sorted(result)\n\n    n, *cards_str = stdin.strip().split()\n    cards = list(map(int, cards_str))\n\n    progressions = find_arithmetic_progressions(cards)\n    result = find_distinct_integers(progressions)\n    return result\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = map(int, stdin.split())\n    numbers = sorted(set(cards))\n\n    if not numbers:\n        return \"-1\\n\"\n\n    for i, number in enumerate(numbers):\n        if i == 0:\n            continue\n        if numbers[i] - numbers[i - 1] == 1:\n            break\n\n    if i == len(numbers) - 1:\n        return \"-1\\n\"\n\n    first_missing = numbers[i] - numbers[i - 1] + 1\n    missing_numbers = [numbers[i] - first_missing + i for i in range(first_missing)]\n    result = numbers[:i] + missing_numbers + numbers[i:]\n\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\\n\"\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = map(int, stdin.split())\n    \n    if n == 1:\n        return \"-1\"\n    \n    first_card = cards[0]\n    max_card = max(cards)\n    \n    if max_card - first_card + 1 != n:\n        return \"0\"\n    \n    arith_prog = [first_card]\n    \n    for i in range(1, n):\n        arith_prog.append(arith_prog[-1] + i)\n    \n    min_card = min(arith_prog)\n    \n    return f\"{len(arith_prog)}, \" + \", \".join(map(str, arith_prog)) + f\" {max_card - min_card + 1}\""
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return \"-1\"\n    \n    for i in range(n):\n        if cards[i] == 1:\n            cards[i] = -1\n        if cards[i] == n:\n            cards[i] = -n\n    \n    result = []\n    for i in range(n):\n        if cards[i] == -cards[i-1] - 1:\n            result.append(cards[i])\n        else:\n            for j in range(cards[i] - 1, cards[i] - n + 1, -1):\n                result.append(j)\n                if len(result) == n:\n                    break\n            if len(result) == n:\n                break\n    \n    if len(result) == n:\n        return f\"{n}\\n{' '.join(map(str, result))}\"\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = int(stdin.splitlines()[0]), list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return \"-1\"\n    \n    diff = cards[1] - cards[0]\n    nums = [diff]\n    \n    for i in range(2, n):\n        nums.append(nums[-1] + 1)\n    \n    for num in nums:\n        if num > 10**8 or num < -10**8:\n            return \"0\"\n    \n    return n, *nums\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = int(stdin.split(\"\\n\")[0]), map(int, stdin.split(\"\\n\")[1].split())\n    cards = list(cards)\n\n    def is_arithmetic_progression(a1, a2, a3):\n        return a3 - a2 == a2 - a1\n\n    if n % 3 != 0:\n        return \"-1\\n\"\n\n    progression = []\n    for i in range(n - 1):\n        if is_arithmetic_progression(cards[i], cards[i + 1], cards[i + 2]):\n            progression.extend(range(cards[i], cards[i] - (n // 3) * (cards[i + 2] - cards[i]), -1))\n        else:\n            break\n\n    if not progression:\n        return \"-1\\n\"\n\n    progression.sort()\n    return f\"{len(progression)}\\n{' '.join(map(str, progression))}\"\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def arithmetic_progression(sequence: List[int]) -> bool:\n        if len(sequence) < 2:\n            return False\n        diff = sequence[1] - sequence[0]\n        return all(sequence[i] - sequence[i - 1] == diff for i in range(1, len(sequence)))\n\n    def find_next_number(sequence: List[int]) -> int:\n        if not sequence:\n            return 0\n        diff = sequence[-1] - sequence[-2]\n        return sequence[-1] + diff + 1\n\n    n = int(stdin[0])\n    numbers = list(map(int, stdin[1].split()))\n\n    if arithmetic_progression(numbers):\n        next_number = find_next_number(numbers)\n        print(1)\n        print(next_number)\n    else:\n        print(-1)\n"
    },
    {
        "number": 561,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_arithmetic_progression(sequence: list) -> bool:\n        diff = sequence[1] - sequence[0]\n        for i in range(1, len(sequence)):\n            if sequence[i] - sequence[i - 1] != diff:\n                return False\n        return True\n\n    n, *cards = map(int, stdin.split())\n    cards.sort()\n\n    if not is_arithmetic_progression(cards):\n        return -1\n\n    diff = cards[1] - cards[0]\n    arithmetic_sequence = [cards[0] - diff]\n    while arithmetic_sequence[-1] > 0:\n        arithmetic_sequence.append(arithmetic_sequence[-1] - diff)\n\n    result = arithmetic_sequence[:-1]\n    if len(result) == n:\n        return 0, \"\\n\".join(map(str, result))\n    elif len(result) == n + 1:\n        return 1, \"\\n\".join(map(str, result[:-1]))\n    else:\n        return 0, \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    shows = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Sort shows by starting time\n    shows.sort(key=lambda x: x[0])\n\n    # Initialize two pointers at the start of the shows\n    pointer_1, pointer_2 = 0, 0\n\n    while pointer_1 < n and pointer_2 < n:\n        # If the next show starts before the current show ends, we need two TVs\n        if shows[pointer_1][0] < shows[pointer_2][0]:\n            if shows[pointer_1][1] <= shows[pointer_2][0]:\n                return \"NO\"\n            pointer_1 += 1\n        else:\n            if shows[pointer_2][1] <= shows[pointer_1][0]:\n                return \"NO\"\n            pointer_2 += 1\n\n    return \"YES\"\n"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    shows = []\n    \n    for _ in range(n):\n        l, r = map(int, input().split())\n        shows.append((l, r))\n    \n    shows.sort(key=lambda x: x[1])\n    \n    start_time = shows[0][0]\n    end_time = shows[0][1]\n    \n    for i in range(1, n):\n        if shows[i][0] >= end_time:\n            start_time = shows[i][0]\n            end_time = shows[i][1]\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    shows = []\n    for i in range(1, n+1):\n        start, end = map(int, stdin.split(\"\\n\")[i].split())\n        shows.append((start, end))\n    \n    shows.sort(key=lambda x: x[0])\n    \n    last_end_time = -1\n    for show in shows:\n        if show[0] >= last_end_time:\n            last_end_time = show[1]\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\nn = int(input())\nstdin = \"\\n\".join([str(n)] + [input() for _ in range(n)])\nprint(solution(stdin)) "
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tv_shows = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    tv_shows.sort(key=lambda x: x[1])\n    tv_starts = [show[0] for show in tv_shows]\n    tv_ends = [show[1] for show in tv_shows]\n\n    if n == 1:\n        return \"YES\"\n\n    for i in range(1, n):\n        if tv_starts[i] >= tv_ends[i - 1]:\n            continue\n        if tv_starts[i] < tv_ends[i - 1]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tv_schedule = []\n    for i in range(1, n + 1):\n        start, end = map(int, stdin.split('\\n')[i].split())\n        tv_schedule.append((start, end))\n\n    # Sort the schedule by start time\n    tv_schedule.sort(key=lambda x: x[0])\n\n    # Iterate through the schedule and find if two TVs are enough\n    prev_end = 0\n    current_tv = 1\n    for start, end in tv_schedule:\n        if start >= prev_end:\n            # There is enough time to watch the show on the current TV\n            if current_tv == 1:\n                current_tv = 2\n            else:\n                current_tv = 1\n        else:\n            # There is not enough time to watch the show on the current TV\n            return \"NO\"\n        prev_end = max(prev_end, end)\n\n    return \"YES\""
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    shows = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    shows.sort(key=lambda x: x[0])  # sort by start time\n\n    # initialize variables\n    end_time = shows[0][1]\n    first_tv_shows = [shows[0]]\n    second_tv_shows = []\n\n    # iterate over shows\n    for show in shows[1:]:\n        start_time, end_time = show\n\n        # check if show can be watched on first TV\n        if start_time >= end_time or start_time >= end_time:\n            continue\n        first_tv_shows.append(show)\n\n        # check if show can be watched on second TV\n        for second_tv_show in second_tv_shows:\n            if start_time >= second_tv_show[1]:\n                second_tv_shows.append(show)\n                break\n        else:\n            second_tv_shows.append(show)\n\n    # check if all shows can be watched\n    if len(first_tv_shows) == n and len(second_tv_shows) == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    starts = []\n    ends = []\n    \n    for i in range(n):\n        line = stdin.split('\\n')[i + 1]\n        l, r = map(int, line.split())\n        starts.append(l)\n        ends.append(r)\n    \n    starts.sort()\n    ends.sort()\n    \n    for i in range(n):\n        if ends[i] <= starts[i]:\n            return \"NO\"\n    \n    for i in range(1, n):\n        if starts[i] <= ends[i - 1]:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    shows = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    shows.sort(key=lambda x: x[0])\n\n    for i in range(n):\n        if shows[i][0] < shows[i][1]:\n            continue\n        for j in range(i + 1, n):\n            if shows[j][0] < shows[j][1] and shows[i][1] <= shows[j][0]:\n                return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    shows = []\n\n    for _ in range(n):\n        l, r = map(int, input().split())\n        shows.append((l, r))\n\n    shows.sort(key=lambda x: x[0])\n\n    end_times = set()\n    for show in shows:\n        if show[0] not in end_times:\n            end_times.add(show[1])\n        else:\n            return \"NO\"\n\n    return \"YES\"\n\nn = int(input())\nfor _ in range(n):\n    l, r = map(int, input().split())\n    shows.append((l, r))\n\nshows.sort(key=lambda x: x[0])\n\nend_times = set()\nfor show in shows:\n    if show[0] not in end_times:\n        end_times.add(show[1])\n    else:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\") "
    },
    {
        "number": 562,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    shows = [(int(i), int(j)) for i, j in (x.split() for x in input_list[1:])]\n\n    shows.sort(key=lambda x: x[0])\n    i = 0\n    j = 1\n    while j < n:\n        if shows[i][1] <= shows[j][0]:\n            i += 1\n            j += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    if r - l > 50:\n        return -1\n\n    def is_coprime(a: int, b: int) -> bool:\n        return gcd(a, b) == 1\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    for a in range(l, r - 2):\n        for b in range(a + 1, r - 1):\n            if is_coprime(a, b):\n                for c in range(b + 1, r):\n                    if is_coprime(b, c) and not is_coprime(a, c):\n                        return f\"{a} {b} {c}\"\n\n    return -1\n"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            if is_coprime(a, b) and is_coprime(b, a + 1) and not is_coprime(a, a + 1):\n                return f\"{a} {a + 1} {a + 2}\"\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, input().split())\n    \n    if l == r:\n        return -1\n    \n    a = l\n    b = l + 1\n    while b <= r:\n        if gcd(a, b) == 1 and gcd(b, b + 1) == 1:\n            c = b + 1\n            if c > r:\n                return -1\n            if gcd(a, c) != 1:\n                return f\"{a} {b} {c}\"\n        b += 1\n    \n    return -1\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    \n    # Check if there is a counterexample\n    if l > 1 and (l+1) % 3 == 0:\n        return str(l + 1) + \" \" + str(l + 2) + \" \" + str(l + 3)\n    \n    # Check if there is a counterexample in the range [l, r]\n    for a in range(l, r-2):\n        for b in range(a+1, r-1):\n            if a % 3 == b % 3 == 0:\n                continue\n            if not (is_coprime(a, b) and is_coprime(b, a+1) and is_coprime(a+1, b+1)):\n                return str(a) + \" \" + str(b) + \" \" + str(b+1)\n    \n    # If there is no counterexample, return -1\n    return \"-1\"\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    \n    # Check if the condition is possible\n    if l > 1 and l % 2 == 1 and r % 2 == 1:\n        a = l + 1\n        b = l + 2\n        c = r - 1\n        if gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:\n            return f\"{a} {b} {c}\"\n    \n    return \"-1\"\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    for c in range(l, r+1):\n        for b in range(l, c):\n            if c - b > 2:\n                for a in range(l, b):\n                    if a != b and a != c and b != c:\n                        if gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:\n                            return f\"{a} {b} {c}\"\n    return \"-1\"\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    for c in range(l + 1, r - 2):\n        for a in range(l, c - 1):\n            for b in range(c + 1, r):\n                if a < b < c < r and (a, b) != (b, c) and (b, c) != (a, c):\n                    if not ((a % b == 0 and b % c == 0) or (b % a == 0 and c % a == 0) or (c % b == 0 and a % b == 0)):\n                        return f\"{a} {b} {c}\"\n\n    return \"-1\"\n"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, input().split())\n\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            for c in range(b + 1, r + 1):\n                if a < b < c and gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:\n                    return f\"{a} {b} {c}\"\n\n    return \"-1\"\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    if r - l > 50:\n        return -1\n    \n    for a in range(l, r):\n        for b in range(a+1, r+1):\n            for c in range(b+1, r+1):\n                if a < b < c and gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:\n                    return f\"{a} {b} {c}\"\n                \n    return -1\n\ndef"
    },
    {
        "number": 563,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    \n    for a in range(l, r+1):\n        for b in range(a+1, r+1):\n            for c in range(b+1, r+1):\n                if gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:\n                    return f\"{a} {b} {c}\"\n    \n    return \"-1\"\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, s = map(int, input_list[0].split())\n    mug_volumes = list(map(int, input_list[1].split()))\n\n    total_mug_volume = sum(mug_volumes)\n    total_mug_volume -= s  # Subtract the volume of the cup\n\n    # Check if there is at least one mug with a volume greater than the cup's\n    if max(mug_volumes) > s:\n        return \"YES\"\n\n    # Check if the total volume of the mugs is greater than the cup's\n    if total_mug_volume > s:\n        return \"NO\"\n\n    # Check if the total volume of the mugs is less than the cup's\n    if total_mug_volume < s:\n        return \"YES\"\n\n    # If none of the above conditions are met, the game is balanced\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if sum(a) > s:\n        return \"NO\"\n    \n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n, s = map(int, input_list[0].split())\n    mug_volumes = list(map(int, input_list[1].split()))\n\n    # Check if the sum of the mug volumes is greater than the cup volume\n    if sum(mug_volumes) > s:\n        return \"NO\"\n\n    # Check if the sum of the mug volumes minus the cup volume is divisible by n\n    if (sum(mug_volumes) - s) % n == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n, s = map(int, input_values[:2])\n    mugs = list(map(int, input_values[2:]))\n    total_volume = sum(mugs)\n    if s >= total_volume:\n        return \"YES\"\n    elif s < total_volume and n - 1 > s:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    cup_capacity = int(input_list[1])\n    mug_volumes = list(map(int, input_list[2:]))\n\n    mug_volumes.sort(reverse=True)\n\n    total_volume = 0\n    for mug_volume in mug_volumes:\n        total_volume += mug_volume\n        if total_volume > cup_capacity:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, s = map(int, input_list[0].split())\n    mugs = list(map(int, input_list[1].split()))\n    \n    total_volume = sum(mugs)\n    if total_volume < s:\n        return \"NO\"\n    \n    mugs.sort(reverse=True)\n    if s >= mugs[0]:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    total_volume = sum(a)\n    if total_volume > s:\n        return \"NO\"\n\n    mugs_with_water = total_volume\n    remaining_mugs = n - 1\n    while remaining_mugs > 0:\n        if mugs_with_water < remaining_mugs:\n            return \"NO\"\n        mugs_with_water -= remaining_mugs\n        remaining_mugs = n - 1 - mugs_with_water\n\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, s = map(int, input_list[0].split())\n    mug_volumes = list(map(int, input_list[1].split()))\n\n    if s < n:\n        return \"NO\"\n\n    mug_volumes.sort(reverse=True)\n    cumulative_volumes = [mug_volumes[0]]\n    for i in range(1, n):\n        cumulative_volumes.append(cumulative_volumes[i-1] + mug_volumes[i])\n\n    for i in range(n-1):\n        if cumulative_volumes[n-1] - cumulative_volumes[i] > s:\n            return \"NO\"\n\n    return \"YES\" "
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def pour(mug_volumes, cup_volume):\n        nonlocal remaining_water\n        pour_water = min(mug_volumes[0], cup_volume)\n        remaining_water = mug_volumes[0] - pour_water\n        mug_volumes[0] -= pour_water\n        cup_volume -= pour_water\n        if cup_volume <= 0:\n            return True\n        return pour(mug_volumes[1:], cup_volume)\n\n    n, s = map(int, stdin.split())\n    mug_volumes = list(map(int, stdin.split()))\n    remaining_water = s\n\n    if n == 1:\n        return \"YES\" if remaining_water == mug_volumes[0] else \"NO\"\n\n    for i in range(n - 1):\n        if remaining_water < mug_volumes[i]:\n            return \"NO\"\n        remaining_water -= mug_volumes[i]\n\n    return \"YES\" if pour(mug_volumes, remaining_water) else \"NO\"\n"
    },
    {
        "number": 564,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, s = map(int, input_values[0].split())\n    mugs = list(map(int, input_values[1].split()))\n    \n    if s >= sum(mugs) or s >= n:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_y = min(y, b - 1)\n    max_r = min(r, b)\n    return max_y + max_r + (max_r - 1)\n"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n\n    max_ornaments = min(y + b - 1, b, r - 1)\n\n    return str(max_ornaments)\n\ndef"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    \n    if y + b + r < 6:\n        return \"6\"\n    \n    yellow = min(y, b + 1)\n    blue = min(b, y + 1)\n    red = min(r, b + 1)\n    \n    return yellow + blue + red\n\n\ndef"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_ornaments = min(y, b-1, r-1) + y + b + r\n    return str(max_ornaments)"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    \n    yellow = max(6, y + b - 1)\n    blue = max(6, b - y + 1)\n    red = max(6, r - b + 1)\n    \n    return yellow + blue + red\n"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    return max(y + b - 1, y + r - 1, b + r - 2)"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    total_ornaments = y + b + r\n    \n    if b == y + 1 and r == b + 1:\n        return total_ornaments\n    \n    # Find the maximum number of ornaments that can be chosen\n    max_ornaments = min(y, b) + min(b, r) + max(y, r)\n    \n    return max_ornaments"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_num_ornaments = y + b + r\n    return str(max_num_ornaments)\n"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_ornaments = max(6, min(y, b, r))\n    return str(max_ornaments)"
    },
    {
        "number": 565,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n\n    # Ensure at least 6 ornaments can be chosen\n    y = max(y, 6)\n    b = max(b, 6)\n    r = max(r, 6)\n\n    # Choose as many ornaments as possible\n    ornaments = y + b + r\n\n    # Ensure the condition of Bob's opinion is met\n    if b - y > 1 and r - b > 1:\n        return str(ornaments)\n    else:\n        # Find the maximum number of ornaments that meet Bob's opinion\n        ornaments = min(y, b + 1) + min(b, y + 1) + min(r, b + 1)\n        return str(ornaments)\n"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    return 3 * (r + g + b) // 2\n\n\ndef"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = min(r//2, g//2, b//2)\n    return str(t)\n\n\ndef"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = 0\n    \n    # Check if r >= g + b, if not, it's impossible to decorate exactly 3 tables\n    if r < g + b:\n        return \"0\"\n    \n    # Calculate the maximum t value\n    t = r // 2\n    \n    return str(t)"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = 0\n    \n    if r != 0:\n        t += (b + g) // r\n    if g != 0:\n        t += (r + b) // g\n    if b != 0:\n        t += (r + g) // b\n    \n    return str(max(t, 1))\n"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = min(r, g, b)\n    return str(t)\n\n\ndef"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = min(r, g, b)\n    return t\n\ninput_str = \"5 4 3\"\nprint(solution(input_str))\n\ninput_str = \"1 1 1\"\nprint(solution(input_str))\n\ninput_str = \"2 3 3\"\nprint(solution(input_str)) "
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = min(r//3, g//3, b//3)\n    return str(t)"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    if r == 0:\n        return \"1\" if g == 0 and b >= 2 else \"0\"\n    elif g == 0:\n        return \"1\" if r == 0 and b >= 2 else \"0\"\n    elif b == 0:\n        return \"1\" if r == 0 and g >= 2 else \"0\"\n    return str(min(r, g, b) * 2)\n"
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    if r == 0 or g == 0 or b == 0:\n        return \"0\"\n    else:\n        return \"4\""
    },
    {
        "number": 566,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = min(r, g, b)\n    return str(t)\n\n\ninput_stdin = \"5 4 3\"\nprint(solution(input_stdin))"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n\n    # Calculate the minimum time to collect all prizes\n    min_time = 0\n    current_position = 1\n    for i in range(n):\n        distance = abs(current_position - a[i])\n        if distance > 1:\n            min_time += distance - 1\n        current_position = a[i]\n\n    return str(min_time)\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return \"1\"\n    \n    a.sort()\n    time_to_pick_up = 0\n    for i in range(n):\n        if a[i] == i+1:\n            continue\n        if a[i] < i+1:\n            time_to_pick_up += (i+1) - a[i]\n        else:\n            time_to_pick_up += a[i] - (i+1)\n    return str(time_to_pick_up + 1)"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_distance(x, y):\n        return abs(x - y)\n\n    n, *a = map(int, stdin.split())\n    a.sort()\n\n    distance = 0\n    max_distance = 0\n    for i in range(n - 1):\n        distance += calculate_distance(a[i], a[i + 1])\n        max_distance = max(max_distance, calculate_distance(a[i], a[i + 1]))\n\n    distance += max_distance\n    return distance + 1\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if n == 1:\n        return 1\n\n    time_to_collect = 0\n    for i in range(n):\n        distance_to_next_prize = abs(a[i] - a[i + 1])\n        time_to_collect += distance_to_next_prize\n\n    return time_to_collect\n\n\ninput_stdin = \"\"\"3\n2 3 9\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    max_pos = 0\n    for pos in a:\n        max_pos = max(max_pos, pos)\n    dp = [[float('inf')] * (max_pos + 1) for _ in range(2)]\n    dp[0][1] = 1\n    dp[1][10**6] = 1\n    for i in range(n):\n        for j in range(max_pos + 1):\n            if j == a[i]:\n                dp[i % 2][j] = min(dp[i % 2][j], dp[(i - 1) % 2][j])\n            else:\n                dp[i % 2][j] = min(dp[i % 2][j], dp[(i - 1) % 2][j + 1] + 1, dp[(i - 1) % 2][j - 1] + 1)\n    return dp[n % 2][1]"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    a.sort()\n\n    # If the prizes are not located at equal distances, then we can't pick them up in minimum time\n    if any(a[i] - a[i - 1] != 1 for i in range(1, n)):\n        return \"Impossible\"\n\n    # Calculate the number of seconds it will take to pick up all the prizes\n    time = 0\n    i = 0\n    while i < n:\n        time += 1\n        if a[i] == i + 1:\n            i += 1\n\n    return str(time)\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    # Calculate the minimum time required to pick up all the prizes\n    min_time = 0\n    for i in range(n):\n        min_time = max(min_time, abs(a[i] - i))\n\n    return str(min_time)\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    \n    if n == 1:\n        return 0\n    \n    dp = [0] * (10**6 + 1)\n    \n    for i in range(1, 10**6 + 1):\n        if i - 1 in a:\n            dp[i] = max(dp[i], dp[i - 1] + 1)\n        \n        if i + 1 in a:\n            dp[i] = max(dp[i], dp[i + 1] + 1)\n    \n    return dp[10**6]\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    min_time = 0\n    i = 0\n    while i < n:\n        if i == 0:\n            if a[i] == 1:\n                min_time += 1\n                i += 1\n            elif a[i] == 2:\n                min_time += 2\n                i += 1\n            else:\n                min_time += a[i]\n                i += 1\n        else:\n            if a[i] == a[i-1] + 1:\n                min_time += 1\n                i += 1\n            elif a[i] == a[i-1] - 1:\n                min_time += 1\n                i += 1\n            elif a[i] > a[i-1] + 1:\n                min_time += a[i] - a[i-1] - 1\n                i += 1\n            else:\n                min_time += a[i]\n                i += 1\n    return str(min_time)\n"
    },
    {
        "number": 567,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    dist = [abs(a[i] - a[i - 1]) for i in range(1, n)]\n    max_dist = max(dist)\n    time_to_move = 1\n    time_to_pick_up = 1\n    time = max_dist * time_to_move + time_to_pick_up\n    return str(time)\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [0] * (3 * n)\n\n    # Generate all possible combinations of coins\n    def generate_coins(coins, index, n):\n        if index == 3 * n:\n            return [coins.copy()]\n\n        result = []\n        for i in range(1, 4):\n            coins[index] = i\n            result += generate_coins(coins, index + 1, n)\n\n        return result\n\n    all_coins = generate_coins(coins, 0, n)\n\n    # Count the number of ways to distribute coins that satisfy Tanya\n    count = 0\n    for coins in all_coins:\n        sum_coins = sum(coins)\n        if sum_coins % 3 == 0 and (sum_coins + 3 * n) % 6 == 0:\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    # a[i] represents the number of coins for the i-th gnome\n    a = [0] * (3 * n)\n    # count[i] represents the number of combinations with i coins for a gnome\n    count = [1] * (3 * n)\n\n    # Calculate the number of combinations for the first gnome\n    for i in range(1, 3 * n):\n        count[i] = count[i - 1] * 2\n\n    # Calculate the number of combinations for each gnome\n    for i in range(1, 3 * n):\n        for j in range(i + 1, 3 * n):\n            if j % 3 == 1 and (i + j) % 3 == 2 and (a[i] + a[j] + n) % 3 == 0 and (a[i] + a[j] + 2 * n) % 3 == 0:\n                count[j] += count[i] * 2\n\n    # Calculate the remainder\n    result = count[3 * n - 1] % (10 ** 9 + 7)\n\n    return str(result)\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    count = 0\n    for i in range(n):\n        if sum([i, i, n + i, i + 2 * n]) % 6 != 0:\n            count += 1\n    return count % (10**9 + 7)\n\nn = 1\nprint(solution(n)) "
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def is_satisfied(a: list) -> bool:\n        for i in range(n):\n            if a[i] + a[i] + n + a[i] + 2*n != 6:\n                return False\n        return True\n\n    def count_ways(a: list) -> int:\n        total_ways = 1\n        for i in range(3*n):\n            if a[i] == 1:\n                total_ways *= 3\n            elif a[i] == 2:\n                total_ways *= 3*2\n            elif a[i] == 3:\n                total_ways *= 3*2*1\n            total_ways %= (10**9 + 7)\n        return total_ways\n\n    a = [0]*(3*n)\n    ways = 0\n    for i in range(3*n):\n        if i % 3 == 0:\n            a[i] = 3\n        elif i % 3 == 1:\n            a[i] = 2\n        else:\n            a[i] = 1\n        if is_satisfied(a):\n            ways += count_ways(a)\n            ways %= (10**9 + 7)\n        a[i] = 0\n    return ways\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(3*n):\n        if (i < n) or (i >= 2*n and i < 3*n-n) or (i >= n and i < 2*n and i >= 3*n-2*n):\n            continue\n        if (i+1)%3 == 0 or (i+2)%3 == 0 or (i-1)%3 == 0 or (i-2)%3 == 0:\n            count += 1\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 10**9 + 7\n\n    count = 0\n    for i in range(3 * n):\n        if i % 3 != 0:\n            if 0 <= i < n:\n                if i + n + 2 * i != 6:\n                    count += 1\n            else:\n                j = i - n\n                if j + n + 2 * j != 6:\n                    count += 1\n        else:\n            continue\n    return count % mod\n\n\nstdin = \"2\"\nprint(solution(stdin)) "
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(20)\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Define the number of gnomes\n    gnomes = 3 * n\n    # Initialize the counter variable\n    counter = 0\n    # Iterate over the possible values of a_i\n    for a_i in range(gnomes + 1):\n        # Check if the condition is satisfied\n        if (a_i + a_i + n + a_i + 2 * n) % 6 != 0:\n            # Update the counter\n            counter += 1\n    # Compute the remainder\n    remainder = counter % (10**9 + 7)\n    return str(remainder)"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n\n    # Iterate through all possible ways to distribute coins\n    for i in range(3 * n):\n        coins = [0] * 3 * n\n        coins[i] = 1\n        coins[i + n] = 1\n        coins[(i + n) // 2] = 1\n\n        # Check if Tanya is satisfied\n        satisfied = True\n        for j in range(3 * n):\n            if coins[j] + coins[j + n] + coins[j + 2 * n] != 6:\n                satisfied = False\n                break\n        if satisfied:\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 568,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [0] * (3 * n)\n    coins[0] = n + 1\n    coins[-1] = 2 * n\n\n    count = 0\n    for i in range(1, 3 * n - 1):\n        if i % 3 == 1:\n            coins[i] = 1\n        elif i % 3 == 2:\n            coins[i] = 2\n        elif i % 3 == 0:\n            coins[i] = 3\n\n        if i % 3 == 1:\n            if coins[i] + coins[i + 1] + coins[i + 2] + coins[i - 1] + coins[i - 2] == 6:\n                count += 1\n        elif i % 3 == 2:\n            if coins[i] + coins[i + 1] + coins[i + 2] + coins[i - 1] + coins[i - 2] == 6:\n                count += 1\n        elif i % 3 == 0:\n            if coins[i] + coins[i + 1] + coins[i + 2] + coins[i - 1] + coins[i - 2] == 6:\n                count += 1\n\n    return str(count % (10**9 + 7))\n\n\ndef"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    s = input()\n\n    if n == 1:\n        return 0\n\n    if len(set(s)) == n:\n        return 0\n\n    changes = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            changes += 1\n\n    return changes\n\n\nstdin = \"\"\"\n2\naa\n4\nkoko\n5\nmurat\n\"\"\"\n\nfor case in stdin.split(\"\\n\")[1:]:\n    print(solution(case))"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_distinct_substrings(s: str) -> bool:\n        substrings = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substrings.add(s[i:j])\n        return len(substrings) == len(s) + 1\n\n    n = int(input())\n    s = input()\n\n    if is_distinct_substrings(s):\n        return 0\n\n    changes_needed = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i:j] in s[:i] + s[j:]:\n                changes_needed += 1\n\n    return changes_needed if changes_needed != 0 else -1\n\n\ndef"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    if n == 1:\n        return 0\n\n    substring_count = {}\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring in substring_count:\n                substring_count[substring] += 1\n            else:\n                substring_count[substring] = 1\n\n    min_changes = n - 1\n    for count in substring_count.values():\n        if count > 1:\n            min_changes = min(min_changes, n - count)\n\n    return min_changes if min_changes <= 1 else -1\n\n\ndef"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    s = input()\n    char_freq = [0] * 26\n    sub_str_freq = [0] * 26\n    changes = 0\n\n    for char in s:\n        char_freq[ord(char) - ord('a')] += 1\n\n    for i in range(n):\n        sub_str_freq[ord(s[i]) - ord('a')] += 1\n        if i < n - 1:\n            sub_str_freq[ord(s[i+1]) - ord('a')] -= 1\n\n        for j in range(26):\n            if sub_str_freq[j] > char_freq[j]:\n                changes += sub_str_freq[j] - char_freq[j]\n\n    return changes if changes <= 10000 else -1\n"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin.splitlines()[1]\n    \n    # Find unique substrings\n    unique_substrings = set()\n    for i in range(n):\n        for j in range(i, n):\n            unique_substrings.add(s[i:j+1])\n    \n    # Check if all substrings are unique\n    if len(unique_substrings) == n:\n        return 0\n    \n    # Count the number of changes needed to make all substrings unique\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i:j] in unique_substrings:\n                count += 1\n                unique_substrings.remove(s[i:j])\n    \n    return count"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_substring(s: str) -> bool:\n        seen = set()\n        for char in s:\n            if char in seen:\n                return False\n            seen.add(char)\n        return True\n\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    changes_needed = 0\n\n    for i in range(1, n):\n        for j in range(i - 1, -1, -1):\n            if s[j] == s[i]:\n                changes_needed += 1\n                s = s[:j] + chr(ord('a') + changes_needed) + s[j + 1:]\n                break\n\n    if not is_valid_substring(s):\n        return -1\n\n    return changes_needed\n\ndef"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    if n == 1:\n        return 0\n\n    count = 0\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            count += 1\n            s = s[:i-1] + chr(ord('a') + count % 26) + s[i:]\n\n    if count >= 2:\n        return -1\n\n    distinct_substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            distinct_substrings.add(s[i:j])\n\n    return len(distinct_substrings) - len(s)\n"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    min_change = 0\n    for count in freq.values():\n        if count > 1:\n            min_change += count - 1\n    return min_change if min_change >= 0 else -1\n"
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    if n == 1:\n        return 0\n\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    max_freq = max(char_freq.values())\n    if max_freq > 1:\n        return -1\n\n    change_count = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            change_count += 1\n\n    return change_count\n\n\ninput_str = \"\"\"2\naa\n4\nkoko\n5\nmurat\"\"\"\n\noutput_str = \"\"\"1\n2\n0\"\"\"\n\ninput_list = input_str.split('\\n')\noutput_list = output_str.split('\\n')\n\nfor i in range(len(input_list)):\n    input_data = input_list[i]\n    expected_output = int(output_list[i])\n    assert expected_output == solution(input_data), f\"Test case {i} failed\"\n\nprint(\"All test cases passed!\") "
    },
    {
        "number": 569,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    \n    if n == 1:\n        return 0\n    \n    substrings = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.append(s[i:j])\n    \n    distinct_substrings = set(substrings)\n    if len(distinct_substrings) == len(substrings):\n        return 0\n    \n    changes = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if substrings[i] == substrings[j]:\n                changes += 1\n                for k in range(i, j):\n                    s = s[:k] + chr(ord('a') + changes % 26) + s[k+1:]\n                changes //= 2\n    \n    return changes\n"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turn = 0\n    while True:\n        if turn % 2 == 0:\n            a += 1\n            turn += 1\n        else:\n            b += 2\n            turn += 1\n        if a > b:\n            return \"Vladik\"\n        elif b > a:\n            return \"Valera\"\n"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turns = 0\n    while abs(a - b) != 1:\n        turns += 1\n        if a > b:\n            a -= 1\n        else:\n            b -= 1\n\n    return \"Valera\" if turns % 2 == 1 else \"Vladik\"\n"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turn = 0\n    while a > b:\n        if turn % 2 == 0:\n            b += 1\n        else:\n            a += 1\n        turn += 1\n    if turn % 2 == 0:\n        return \"Vladik\"\n    else:\n        return \"Valera\"\n\n\ndef"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turn = 0\n    while True:\n        if turn % 2 == 0:\n            a += 1\n        else:\n            b += 1\n        turn += 1\n        if a - 1 - b == 0:\n            return \"Vladik\"\n        elif b - 1 - a == 0:\n            return \"Valera\"\n        "
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    while a != b:\n        if a > b:\n            a -= b\n            b += 2\n        else:\n            b -= a\n            a += 2\n    return \"Vladik\" if a == b else \"Valera\" "
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    vladik_candies = a\n    valera_candies = b\n    while True:\n        valera_candies += 1\n        temp = valera_candies - 1\n        while temp > 0:\n            valera_candies += 1\n            temp -= 1\n        if valera_candies > vladik_candies:\n            return \"Vladik\"\n        else:\n            vladik_candies += 1\n            temp = vladik_candies - 1\n            while temp > 0:\n                vladik_candies += 1\n                temp -= 1\n            if vladik_candies > valera_candies:\n                return \"Valera\"\n"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    turn = 0\n    total_candies = a + b\n    while total_candies >= 1:\n        total_candies -= 1\n        turn = 1 - turn\n        if turn == 0:\n            a += 1\n        else:\n            b += 1\n\n    if turn == 0:\n        return \"Vladik\"\n    else:\n        return \"Valera\"\n\n\ndef"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    while True:\n        if a > b:\n            a -= b\n            b += 1\n        elif a < b:\n            b -= a\n            a += 1\n        else:\n            return \"Valera\" if a % 2 == 1 else \"Vladik\"\n"
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turns = 0\n    while a > 0 and b > 0:\n        turns += 1\n        temp = a\n        a = b + a - 1\n        b = temp\n    if turns % 2 == 0:\n        return \"Vladik\"\n    else:\n        return \"Valera\"\n\ninput_data = \"1 1\"\noutput_data = solution(input_data)\nprint(output_data)\n\ninput_data = \"7 6\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 570,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    turn = 1\n    vladik_candies = a\n    valera_candies = b\n\n    while True:\n        if turn % 2 == 1:\n            valera_candies += 1\n            vladik_candies -= 1\n        else:\n            valera_candies -= 1\n            vladik_candies += 2\n\n        if vladik_candies < 1 or valera_candies < 1:\n            break\n        turn += 1\n\n    if vladik_candies < 1:\n        return \"Valera\"\n    else:\n        return \"Vladik\" "
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    s = input_list[1]\n    n = len(s)\n    \n    def is_correct_parenthesis(s: str) -> bool:\n        stack = []\n        for char in s:\n            if char == \"(\":\n                stack.append(char)\n            elif char == \")\":\n                if not stack or stack.pop() != \"(\":\n                    return False\n        return not stack\n\n    def replace_question_mark(s: str) -> str:\n        result = \"\"\n        i = 0\n        while i < n:\n            if s[i] == \"?\":\n                result += \"(\"\n            elif s[i] == \")\":\n                result += \")\"\n            else:\n                result += s[i]\n            i += 1\n        return result\n\n    def has_strict_prefix(s: str, prefix: str) -> bool:\n        for i in range(1, len(prefix) + 1):\n            if s[:i] != prefix[:i]:\n                return False\n        return True\n\n    if n == 0:\n        return \"\"\n\n    if is_correct_parenthesis(s):\n        return s\n\n    result = replace_question_mark(s)\n    if is_correct_parenthesis(result):\n        return result\n\n    for i in range(n):\n        if s[i] == \"?\":\n            if has_strict_prefix(s, s[:i] + \"()\" + s[i+1:]):\n                new_s = replace_question_mark(s[:i] + \"()\" + s[i+1:])\n                if is_correct_parenthesis(new_s):\n                    return new_s\n\n    return \":(\"\n"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    # If there is no \"?\", the string is a correct parenthesis sequence\n    if \"?\" not in s:\n        return s\n    \n    # Replace each \"?\" with either \"(\" or \")\"\n    new_s = \"\"\n    for c in s:\n        if c == \"?\":\n            if new_s.count(\"(\") > new_s.count(\")\"):\n                new_s += \")\"\n            else:\n                new_s += \"(\"\n        else:\n            new_s += c\n    \n    # Check if the new string is a correct parenthesis sequence\n    stack = []\n    for c in new_s:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if stack and stack[-1] == \"(\":\n                stack.pop()\n            else:\n                return \":(\"\n    if not stack:\n        return new_s\n    else:\n        return \":(\""
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    \n    if n == 0:\n        return ':('\n    \n    s = list(s)\n    while '?' in s:\n        i = s.index('?')\n        s[i] = ')' if i % 2 == 1 else '('\n    return ''.join(s)\n"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    result = []\n    \n    for c in s:\n        if c == \"?\":\n            result.append(\"(\")\n        else:\n            result.append(c)\n    \n    if is_correct_parenthesis_sequence(result):\n        return \"\".join(result)\n    else:\n        return \":(\"\n\ndef"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")[1]\n    n = len(s)\n    dp = [True] * (n + 1)\n    for i in range(1, n + 1):\n        if s[i - 1] == \"?\":\n            dp[i] = not dp[i - 2]\n        elif s[i - 1] == \"(\":\n            dp[i] = dp[i - 1]\n        elif s[i - 1] == \")\":\n            dp[i] = not dp[i - 1]\n        else:\n            dp[i] = False\n    if dp[n]:\n        ans = \"\"\n        for i in range(n):\n            if s[i] == \"?\":\n                ans += \"(\"\n            else:\n                ans += s[i]\n        return ans\n    else:\n        return \":(\"\n\n\ndef"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass\n\ndef"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    s = stdin[1]\n    \n    if n == 0:\n        return \"()\"\n    \n    if n == 1:\n        return s\n    \n    s = list(s)\n    count = 0\n    \n    for i in range(n):\n        if s[i] == \"?\":\n            if count % 2 == 0:\n                s[i] = \")\"\n            else:\n                s[i] = \"(\"\n            count += 1\n    \n    return \"\".join(s)\n\ndef"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    \n    if n == 0:\n        return \"\"\n    \n    def is_correct_parenthesis_sequence(s: str) -> bool:\n        balance = 0\n        for c in s:\n            if c == \"(\":\n                balance += 1\n            elif c == \")\":\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    def replace_question_marks(s: str) -> str:\n        result = \"\"\n        for c in s:\n            if c == \"?\":\n                result += \"(\" if is_correct_parenthesis_sequence(result) else \")\"\n            else:\n                result += c\n        return result\n    \n    new_s = replace_question_marks(s)\n    if is_correct_parenthesis_sequence(new_s):\n        return new_s\n    else:\n        return \":(\""
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')[1]\n    n = len(s)\n    res = []\n\n    for i in range(n):\n        if s[i] == '?':\n            res.append('(')\n        else:\n            res.append(s[i])\n\n    s = ''.join(res)\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return ':('\n            stack.pop()\n\n    if not stack:\n        return s\n    else:\n        return ':('"
    },
    {
        "number": 571,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = s.replace('?', '()')\n    if s.count('()') % 2 == 0:\n        return s\n    else:\n        return ':('\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(coefficients: List[int], k: int) -> bool:\n        return all(isinstance(coefficient, int) and abs(coefficient) <= k for coefficient in coefficients) and coefficients[-1] != 0\n\n    def count_ways(coefficients: List[int], k: int) -> int:\n        n = len(coefficients)\n        count = 0\n\n        for i in range(n):\n            for j in range(k + 1):\n                new_coefficients = [coefficients[m] if m != i else j for m in range(n)]\n                if is_valid(new_coefficients, k):\n                    count += 1\n\n        return count\n\n    n, k = map(int, stdin.split())\n    coefficients = list(map(int, stdin.split()))\n\n    return count_ways(coefficients, k)\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if abs(a[i]) > k:\n            continue\n        if i == n - 1 and a[n - 1] != 0:\n            continue\n\n        if i == 0:\n            a[i] = -a[i]\n            count += 1\n        elif a[i - 1] != 0:\n            a[i] = -a[i]\n            count += 1\n\n    return count\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def valid_polynomial(coefficients: List[int]) -> bool:\n        if not coefficients:\n            return False\n        for i, coefficient in enumerate(coefficients):\n            if abs(coefficient) > k:\n                return False\n            if i > 0 and coefficient == 0:\n                return False\n        return True\n\n    def change_coefficient(coefficients: List[int]) -> List[int]:\n        new_coefficients = coefficients.copy()\n        for i in range(len(new_coefficients)):\n            new_coefficients[i] += 1\n            if valid_polynomial(new_coefficients):\n                return new_coefficients\n            new_coefficients[i] -= 2\n            if valid_polynomial(new_coefficients):\n                return new_coefficients\n            new_coefficients[i] += 1\n        return new_coefficients\n\n    n, k = map(int, stdin.split()[:2])\n    coefficients = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    for i in range(len(coefficients)):\n        if coefficients[i] == 0:\n            continue\n        count += 1\n        new_coefficients = change_coefficient(coefficients)\n        while not valid_polynomial(new_coefficients):\n            new_coefficients = change_coefficient(new_coefficients)\n        count += 1\n\n    return count // 2\n\ndef"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    if a[-1] == 0:\n        return 0\n\n    count = 0\n    for i in range(n):\n        if i == n - 1:\n            a[i] = 0\n        elif abs(a[i]) <= k:\n            a[i] = -abs(a[i]) if a[i] > 0 else abs(a[i])\n            if i == 0 and a[i + 1] != 0:\n                count += 1\n            elif i == n - 1 and a[i - 1] != 0:\n                count += 1\n            elif i > 0 and i < n - 1:\n                if a[i - 1] != 0 and a[i + 1] != 0:\n                    count += 1\n\n    return count\n\n\ninput_str = \"\"\"3 1000000000\n10 -9 -3 5\n3 12\n10 -9 -3 5\n2 20\n14 -7 19\"\"\"\n\noutput_str = \"\"\"3\n2\n0\"\"\"\n\ndef"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    \n    valid_polynomials = 0\n    for i in range(n):\n        if a[i] < -k or a[i] > k:\n            continue\n        a[i] = a[i] % (2 * k) + k\n        if a[i] == 0:\n            continue\n        a[n] = 0\n        if a[i] != a[n]:\n            valid_polynomials += 1\n        a[i] = -a[i]\n        if a[i] != a[n]:\n            valid_polynomials += 1\n        a[i] = -a[i]\n        a[n] = 0\n    \n    return str(valid_polynomials)\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Check if a_n is 0, if not, the polynomial is not valid\n    if a[n] != 0:\n        return 0\n    \n    # Check if a_i is an integer and |a_i| <= k for every i\n    for i in range(n+1):\n        if not isinstance(a[i], int) or abs(a[i]) > k:\n            return 0\n    \n    # Count the number of ways to change one coefficient to get a valid polynomial Q(2) = 0\n    count = 0\n    for i in range(n+1):\n        # Check if changing the coefficient a_i would result in a valid polynomial Q(2) = 0\n        if a[i] != 0 and a[i] % 2 == 0:\n            Q = a.copy()\n            Q[i] += 1\n            if Q[n] != 0 and all(isinstance(Q[i], int) and abs(Q[i]) <= k for i in range(n+1)):\n                count += 1\n        elif a[i] % 2 == 1:\n            Q = a.copy()\n            Q[i] -= 1\n            if Q[n] != 0 and all(isinstance(Q[i], int) and abs(Q[i]) <= k for i in range(n+1)):\n                count += 1\n    \n    return count\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[1:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def is_valid(a):\n        return all(isinstance(x, int) and -k <= x <= k and x != 0 for x in a)\n\n    def make_polynomial(a):\n        return sum(x * x ** i for i, x in enumerate(a))\n\n    def count_ways(a):\n        count = 0\n        for i in range(len(a)):\n            for j in range(k + 1):\n                if is_valid(a[:i] + [j] + a[i+1:]):\n                    count += 1\n        return count\n\n    if is_valid(a):\n        if a[n] == 0:\n            return count_ways(a)\n        else:\n            return count_ways(a) + count_ways(a[:n] + [0] + a[n+1:])\n    else:\n        return 0"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    count = 0\n\n    def is_valid(coefficients):\n        for i in range(n + 1):\n            if abs(coefficients[i]) > k:\n                return False\n        return True\n\n    def change_coefficient(coefficients, index):\n        new_coefficients = coefficients.copy()\n        new_coefficients[index] = -new_coefficients[index]\n        return new_coefficients\n\n    for i in range(n + 1):\n        new_coefficients = change_coefficient(a, i)\n        if is_valid(new_coefficients):\n            count += 1\n\n    return count\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = solution(stdin)\nprint(result)\n"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_valid_polynomial(a):\n        for i in range(n + 1):\n            if abs(a[i]) > k:\n                return False\n        if a[n] == 0:\n            return False\n        return True\n\n    def generate_polynomials(a):\n        candidates = []\n        for i in range(n + 1):\n            for j in range(i + 1, n + 1):\n                if abs(a[i]) <= k and abs(a[j]) <= k:\n                    candidates.append((i, j, a[i] + a[j]))\n        return candidates\n\n    valid_polynomials = 0\n    for i in range(k + 1):\n        if is_valid_polynomial([a[j] + i if j == i else a[j] for j in range(n + 1)]):\n            valid_polynomials += 1\n\n    return valid_polynomials"
    },
    {
        "number": 572,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        if a[i] < -k:\n            count += 1\n        elif a[i] > k:\n            count += 1\n\n    if a[n] == 0:\n        count += 1\n\n    print(count)\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    groups = stdin.splitlines()[1].split()\n    total_teams = 0\n\n    for i in range(n):\n        group_size = int(groups[i])\n        total_teams += group_size * (group_size - 1) // 2\n\n        if group_size == 2:\n            total_teams -= 1\n\n    return total_teams // 3\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    count = 0\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n        elif a[i] == 2:\n            count += 2\n    \n    return count // 3\n\n\ndef"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    groups = list(map(int, stdin.split('\\n')[1].split()))\n    \n    teams = 0\n    for group in groups:\n        if group == 1:\n            teams += 1\n        elif group == 2:\n            teams += 2\n    \n    return str(teams // 3)"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n\n    # count number of groups with 1 or 2 people\n    count_1 = sum(1 for x in a if x == 1)\n    count_2 = sum(1 for x in a if x == 2)\n\n    # calculate the maximum number of teams of three people\n    max_teams = count_1 // 3 + count_2 // 3\n\n    return str(max_teams)\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        if a[i] == 2:\n            count += 1\n    return count"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n\n    count = 0\n    for i in range(n - 2):\n        count += a[i] * (a[i + 1] + a[i + 2]) // 2\n\n    return count\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n    count = 0\n    \n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n        elif a[i] == 2:\n            count += 1\n            if i < n-1 and a[i+1] == 2:\n                count += 1\n    \n    return str(count)\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                count += 1\n            else:\n                continue\n            for k in range(j+1, n):\n                if a[j] == a[k]:\n                    count += 1\n                else:\n                    continue\n                if a[i] == 2 and a[j] == 2 and a[k] == 2:\n                    count -= 1\n                if a[i] == 1 and a[j] == 1 and a[k] == 1:\n                    count -= 1\n                if a[i] == 1 and a[j] == 2 and a[k] == 1:\n                    count -= 1\n                if a[i] == 1 and a[j] == 1 and a[k] == 2:\n                    count -= 1\n                if a[i] == 2 and a[j] == 1 and a[k] == 1:\n                    count -= 1\n                if a[i] == 1 and a[j] == 2 and a[k] == 2:\n                    count -= 1\n                if a[i] == 2 and a[j] == 1 and a[k] == 2:\n                    count -= 1\n                if a[i] == 2 and a[j] == 2 and a[k] == 1:\n                    count -= 1\n    return count // 3\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    groups = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    max_count = 0\n    for i in range(len(groups)):\n        for j in range(i + 1, len(groups)):\n            if groups[i] + groups[j] == 3:\n                count += 1\n                max_count = max(max_count, count)\n            elif groups[i] + groups[j] > 3:\n                count = 0\n            else:\n                count = 0\n\n    return str(max_count)\n"
    },
    {
        "number": 573,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        if a[i] == 2:\n            count += 1\n    print(count // 2) "
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    \n    # Calculate the number of rows and columns\n    rows = abs(y2 - y1) + 1\n    cols = abs(x2 - x1) + 1\n    \n    # Calculate the number of cells to be filled\n    filled = rows * cols - (rows - 1) - (cols - 1)\n    \n    return str(filled)"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    width = abs(x2 - x1) + 1\n    height = abs(y2 - y1) + 1\n    cells_to_fill = 0\n\n    for x in range(x1, x1 + width):\n        for y in range(y1, y1 + height):\n            if (x - x1) % 2 == 0 and (y - y1) % 2 == 0:\n                cells_to_fill += 1\n\n    return str(cells_to_fill)"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    dx = x2 - x1\n    dy = y2 - y1\n    assert -10**9 <= x1 <= x2 <= 10**9, \"Invalid input\"\n    assert -10**9 <= y1 <= y2 <= 10**9, \"Invalid input\"\n    assert (x2 - x1) % 2 == 0, \"Invalid input\"\n    \n    count = 0\n    for x in range(x1, x2+1):\n        for y in range(y1, y2+1):\n            if x % 2 == 0:\n                if (dy % 2 == 0) or (dy % 2 == 1 and y % 2 == 1):\n                    count += 1\n            else:\n                if (dy % 2 == 0) or (dy % 2 == 1 and y % 2 == 0):\n                    count += 1\n                    \n    return str(count)\n\n\ninput_str = \"1 1 5 5\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    num_rows = (y2 - y1 + 2) // 2\n    num_cols = (x2 - x1 + 1) // 2\n    return (num_rows * (num_cols - 1)) + 1"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    num_cells = abs(x1 - x2) * abs(y1 - y2)\n    return num_cells\n\ninput_data = \"1 1 5 5\"\nprint(solution(input_data)) "
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    dx, dy = x2 - x1, y2 - y1\n    return (dx // 2 + 1) * (dy + 1)\n"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x_range = range(x1, x2+1)\n    y_range = range(y1, y2+1)\n    count = 0\n    for x in x_range:\n        for y in y_range:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx % 2 != 0:\n        dx += 1\n        dy += 1\n\n    # Calculate the number of cells in the rectangle\n    n = (dx // 2) * (dy + 1)\n\n    # Calculate the number of cells in the center of the rectangle\n    center_cells = (dx // 2) * (dy // 2)\n\n    # Calculate the number of cells on the edges\n    edges = (dx // 2) * 2\n\n    # Calculate the number of cells in the corners\n    corners = 4 * (dx // 2) - (dy // 2)\n\n    # Calculate the total number of cells to be filled\n    total_cells = n - center_cells - edges - corners\n\n    return str(total_cells)\n"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    width = x2 - x1 + 1\n    height = (y2 - y1 + 1) // 2\n    return (width * height) * 2\n\ndef"
    },
    {
        "number": 574,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    # Calculate the number of rows in the rectangle\n    rows = (y2 - y1) // 2 + 1\n\n    # Calculate the number of columns in the rectangle\n    cols = (x2 - x1) // 2 + 1\n\n    # Calculate the total number of cells to be filled\n    total_cells = rows * cols\n\n    # Calculate the number of cells to be filled\n    cells_to_fill = total_cells - rows - cols\n\n    return str(cells_to_fill)"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, input().split())\n\n    # check if b_x, b_y is a valid move for the king\n    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        new_x, new_y = b_x + dx, b_y + dy\n        if 1 <= new_x <= n and 1 <= new_y <= n and (new_x, new_y) != (a_x, a_y) and (new_x, new_y) != (c_x, c_y):\n            break\n    else:\n        return \"NO\"\n\n    # check if the path is blocked by the queen\n    blocked = False\n    if abs(a_x - c_x) == abs(a_y - c_y):\n        if a_x == b_x:\n            for x in range(min(a_x, c_x) + 1, max(a_x, c_x)):\n                if (x, b_y) == (a_x, a_y) or (x, b_y) == (c_x, c_y):\n                    blocked = True\n                    break\n        elif a_y == b_y:\n            for y in range(min(a_y, c_y) + 1, max(a_y, c_y)):\n                if (b_x, y) == (a_x, a_y) or (b_x, y) == (c_x, c_y):\n                    blocked = True\n                    break\n    if blocked:\n        return \"NO\"\n\n    # check if the path is blocked by any other piece\n    for dx in range(-n+1, n):\n        for dy in range(-n+1, n):\n            if abs(dx) + abs(dy) != 1:\n                new_x, new_y = b_x + dx, b_y + dy\n                if 1 <= new_x <= n and 1 <= new_y <= n and (new_x, new_y) != (a_x, a_y) and (new_x, new_y) != (b_x, b_y) and (new_x, new_y) != (c_x, c_y):\n                    return \"NO\"\n\n    return \"YES\"\n\ndef"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a_x, a_y, b_x, b_y, c_x, c_y = (int(x) for x in input().split())\n    \n    # Check if Bob can reach the target without getting in check\n    if n - abs(b_x - c_x) - abs(b_y - c_y) >= 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    a_x, a_y = map(int, input_lines[1].split())\n    b_x, b_y = map(int, input_lines[2].split())\n    c_x, c_y = map(int, input_lines[3].split())\n\n    # Check if the king can get to the target without getting in check\n    def is_safe(x, y):\n        if x == a_x or y == a_y:\n            # Check if the queen is in the way\n            for i in range(min(x, a_x) + 1, max(x, a_x)):\n                if i == y:\n                    return False\n        if abs(x - a_x) == abs(y - a_y):\n            # Check if the queen is on a diagonal\n            for i in range(1, n):\n                i_x, i_y = (a_x + i * (x - a_x) // abs(x - a_x)), (a_y + i * (y - a_y) // abs(y - a_y))\n                if i_x == x and i_y == y:\n                    return False\n        return True\n\n    if is_safe(c_x, c_y):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.splitlines()[1:])\n\n    def is_check(x, y):\n        if x == a_x and y == a_y:\n            return True\n        return False\n\n    def can_move(x, y):\n        if x >= 1 and x <= n and y >= 1 and y <= n:\n            if (x, y) == (c_x, c_y):\n                return True\n            elif not is_check(x, y):\n                return True\n        return False\n\n    def dfs(x, y):\n        if (x, y) == (c_x, c_y):\n            return True\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n            nx, ny = x + dx, y + dy\n            if can_move(nx, ny):\n                if dfs(nx, ny):\n                    return True\n\n        return False\n\n    return \"YES\" if dfs(b_x, b_y) else \"NO\"\n"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_in_check(x: int, y: int, n: int) -> bool:\n        if x == a_x and y == a_y:\n            return True\n        elif x == b_x and y == b_y:\n            return True\n        elif x == a_x:\n            return y == a_y - 1 or y == a_y + 1\n        elif y == a_y:\n            return x == a_x - 1 or x == a_x + 1\n        elif x == b_x:\n            return y == b_y - 1 or y == b_y + 1\n        elif y == b_y:\n            return x == b_x - 1 or x == b_x + 1\n        else:\n            return False\n\n    n = int(stdin.splitlines()[0])\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.splitlines()[1:])\n\n    if is_in_check(b_x, b_y, n) or is_in_check(c_x, c_y, n):\n        return \"NO\"\n    else:\n        return \"YES\"\n"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.splitlines()[1:])\n\n    def is_safe(x, y):\n        if x == a_x and y == a_y:\n            return False\n        if x == b_x and y == b_y:\n            return False\n        if x == c_x and y == c_y:\n            return False\n        return True\n\n    def is_in_check(x, y):\n        if x == a_x and y == a_y:\n            return True\n        return False\n\n    def is_valid_move(x, y):\n        if x < 1 or x > n or y < 1 or y > n:\n            return False\n        if not is_safe(x, y):\n            return False\n        return True\n\n    def can_win():\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if is_valid_move(b_x + dx, b_y + dy) and not is_in_check(b_x + dx, b_y + dy):\n                    return True\n        return False\n\n    if can_win():\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, input().split())\n    \n    def is_check(x, y):\n        return (a_x == x) or (a_y == y) or (abs(a_x - x) == abs(a_y - y))\n    \n    if is_check(b_x, b_y):\n        return \"NO\"\n    \n    if is_check(c_x, c_y):\n        return \"NO\"\n    \n    if c_x == a_x and c_y == a_y:\n        return \"YES\"\n    \n    if c_x == b_x and c_y == b_y:\n        return \"YES\"\n    \n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    for move in moves:\n        dx, dy = move\n        new_x, new_y = b_x + dx, b_y + dy\n        if 1 <= new_x <= n and 1 <= new_y <= n and not is_check(new_x, new_y):\n            if new_x == c_x and new_y == c_y:\n                return \"YES\"\n            else:\n                queue = [(new_x, new_y)]\n                visited = {(new_x, new_y)}\n                while queue:\n                    x, y = queue.pop(0)\n                    if (x, y) == (c_x, c_y):\n                        return \"YES\"\n                    for move in moves:\n                        dx, dy = move\n                        new_x, new_y = x + dx, y + dy\n                        if 1 <= new_x <= n and 1 <= new_y <= n and not is_check(new_x, new_y) and (new_x, new_y) not in visited:\n                            visited.add((new_x, new_y))\n                            queue.append((new_x, new_y))\n    return \"NO\"\n\ndef"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a_x, a_y = map(int, input_list[1].split())\n    b_x, b_y = map(int, input_list[2].split())\n    c_x, c_y = map(int, input_list[3].split())\n\n    # Check if Bob can reach the target without getting in check\n    def is_reachable(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return True\n        if (x1 + y1) % 2 == (x2 + y2) % 2:\n            return False\n        if x2 - x1 == y2 - y1:\n            x, y = x1, y1\n        else:\n            x, y = y1, x1\n        if x2 - x >= 0 and y2 - y >= 0:\n            if (x2 - x) % 2 == 0:\n                return False\n            else:\n                return is_reachable(x + 1, y, x2, y2)\n        if x2 - x >= 0 and y2 - y < 0:\n            if (x2 - x) % 2 == 1:\n                return False\n            else:\n                return is_reachable(x + 1, y - 1, x2, y2)\n        if x2 - x < 0 and y2 - y >= 0:\n            if (y2 - y) % 2 == 0:\n                return False\n            else:\n                return is_reachable(x, y + 1, x2, y2)\n        if x2 - x < 0 and y2 - y < 0:\n            if (y2 - y) % 2 == 1:\n                return False\n            else:\n                return is_reachable(x - 1, y + 1, x2, y2)\n\n    if is_reachable(b_x, b_y, c_x, c_y):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.splitlines()[1:])\n    \n    # Check if the target location is in check\n    if a_x == c_x or a_y == c_y:\n        for i in range(1, n+1):\n            if a_x == c_x and a_y == i:\n                return \"NO\"\n            elif a_x == i and a_y == c_y:\n                return \"NO\"\n    \n    # Check if the path from the current position to the target location is blocked\n    if a_x < c_x:\n        for i in range(a_x+1, c_x+1):\n            if i == a_x+1 or i == a_x+2 or i == a_x+3 or i == a_x+4 or i == a_x+5 or i == a_x+6:\n                return \"NO\"\n    elif a_x > c_x:\n        for i in range(a_x-1, c_x-1, -1):\n            if i == a_x-1 or i == a_x-2 or i == a_x-3 or i == a_x-4 or i == a_x-5 or i == a_x-6:\n                return \"NO\"\n    if a_y < c_y:\n        for i in range(a_y+1, c_y+1):\n            if i == a_y+1 or i == a_y+2 or i == a_y+3 or i == a_y+4 or i == a_y+5 or i == a_y+6:\n                return \"NO\"\n    elif a_y > c_y:\n        for i in range(a_y-1, c_y-1, -1):\n            if i == a_y-1 or i == a_y-2 or i == a_y-3 or i == a_y-4 or i == a_y-5 or i == a_y-6:\n                return \"NO\"\n    \n    # Check if the king can move to the target location without getting in check\n    if a_x < c_x and a_y < c_y:\n        for i in range(a_x+1, c_x):\n            if i == c_x-1 or i == c_x-2 or i == c_x-3 or i == c_x-4 or i == c_x-5 or i == c_x-6:\n                return \"NO\"\n        for i in range(a_y+1, c_y):\n            if i == c_y-1 or i == c_y-2 or i == c_y-3 or i == c_y-4 or i == c_y-5 or i == c_y-6:\n                return \"NO\"\n    elif a_x > c_x and a_y < c_y:\n        for i in range(a_x-1, c_x-1, -1):\n            if i == c_x+1 or i == c_x+2 or i == c_x+3 or i == c_x+4 or i == c_x+5 or i == c_x+6:\n                return \"NO\"\n        for i in range(a_y+1, c_y):\n            if i == c_y-1 or i == c_y-2 or i == c_y-3 or i == c_y-4 or i == c_y-5 or i == c_y-6:\n                return \"NO\"\n    elif a_x < c_x and a_y > c_y:\n        for i in range(a_x+1, c_x):\n            if i == c_x-1 or i == c_x-2 or i == c_x-3 or i == c_x-4 or i == c_x-5 or i == c_x-6:\n                return \"NO\"\n        for i in range(a_y-1, c_y-1, -1):\n            if i == c_y+1 or i == c_y+2 or i == c_y+3 or i == c_y"
    },
    {
        "number": 575,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split()[1:])\n\n    def is_in_check(x, y, n):\n        if x == a_x and y == a_y:\n            return True\n        if x == b_x and y == b_y:\n            return True\n        if x == c_x and y == c_y:\n            return True\n        if x == a_x + 1 and y == a_y and n % 2 == 0:\n            return True\n        if x == a_x - 1 and y == a_y and n % 2 == 0:\n            return True\n        if y == a_y + 1 and x == a_x and n % 2 == 0:\n            return True\n        if y == a_y - 1 and x == a_x and n % 2 == 0:\n            return True\n        return False\n\n    def is_valid(x, y, n):\n        return 1 <= x <= n and 1 <= y <= n\n\n    def is_free(x, y, n):\n        return not is_in_check(x, y, n)\n\n    def is_valid_move(x, y, n, x_move, y_move):\n        return is_valid(x + x_move, y + y_move, n) and is_free(x + x_move, y + y_move, n)\n\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if is_valid_move(b_x, b_y, n, i, j) and (b_x + i, b_y + j) == (c_x, c_y):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            lcm_ij = lcm(a[i], a[j])\n            if lcm_ij > max_lcm:\n                max_lcm = lcm_ij\n\n    return str(max_lcm)\n"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            lcm = a[i] * a[j] // gcd(a[i], a[j])\n            max_lcm = max(max_lcm, lcm)\n\n    return str(max_lcm)\n\n\ndef"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from math import gcd\n    \n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    max_lcm = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            lcm = (a[i] * a[j]) // gcd(a[i], a[j])\n            max_lcm = max(max_lcm, lcm)\n            \n    return str(max_lcm)\n"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from functools import reduce\n    from math import gcd\n\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)\n\n\ndef"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            lcm_ij = lcm(a[i], a[j])\n            max_lcm = max(max_lcm, lcm_ij)\n\n    return str(max_lcm)\n"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    max_lcm = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)\n\n\ninput_stdin = \"\"\"3\n13 35 77\"\"\"\n\ninput_stdin2 = \"\"\"6\n1 2 4 8 16 32\"\"\"\n\nprint(solution(input_stdin))\nprint(solution(input_stdin2)) "
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    max_lcm = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            lcm_ij = lcm(a[i], a[j])\n            max_lcm = max(max_lcm, lcm_ij)\n\n    return str(max_lcm)\n"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    max_lcm = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)\n\n\ninput_list = \"\"\"3\n13 35 77\n6\n1 2 4 8 16 32\"\"\"\n\noutput = solution(input_list)\nprint(output) "
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def lcm(x, y):\n        return x * y // math.gcd(x, y)\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)\n"
    },
    {
        "number": 576,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n\n    def lcm(x, y):\n        return (x * y) // math.gcd(x, y)\n\n    max_lcm = max(a)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_lcm = max(max_lcm, lcm(a[i], a[j]))\n\n    return str(max_lcm)\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    shrubs = [list(map(int, line.split())) for line in input_data[1:]]\n\n    result = 0\n\n    for shrub in shrubs:\n        red_berries = shrub[0]\n        blue_berries = shrub[1]\n        total_berries = red_berries + blue_berries\n\n        if total_berries == 0:\n            continue\n\n        red_baskets = min(k // 2, red_berries)\n        blue_baskets = min(k - red_baskets, blue_berries)\n\n        result += red_baskets + blue_baskets\n\n    return str(result)\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    k = input_data[1]\n    a = input_data[2:2 * n + 2:2]\n    b = input_data[3:2 * n + 2:2]\n\n    max_baskets = 0\n    for i in range(n):\n        shrubs_with_red = sum(1 for x in a if x > 0)\n        shrubs_with_blue = sum(1 for x in b if x > 0)\n        total_berries_red = sum(a)\n        total_berries_blue = sum(b)\n\n        if a[i] > 0:\n            max_baskets += a[i] // k\n        if b[i] > 0:\n            max_baskets += b[i] // k\n\n        if total_berries_red > 0 and total_berries_blue > 0 and k >= 2:\n            max_baskets += min(total_berries_red, total_berries_blue) // k\n\n    return str(max_baskets)\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:2+2*n]))\n    total_berries = sum(a) + sum(b)\n    \n    if k > total_berries:\n        return 0\n    \n    count = 0\n    current_basket_berries = 0\n    current_basket_shrubs = set()\n    \n    for i in range(n):\n        red_berries = a[i]\n        blue_berries = b[i]\n        \n        if current_basket_berries + red_berries <= k:\n            current_basket_berries += red_berries\n            current_basket_shrubs.add(i)\n        elif current_basket_berries + blue_berries <= k:\n            current_basket_berries += blue_berries\n            current_basket_shrubs.add(i)\n        else:\n            count += 1\n            current_basket_berries = red_berries + blue_berries\n            current_basket_shrubs = {i}\n    \n    if current_basket_berries > 0:\n        count += 1\n    \n    return count\n\ndef"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:2+2*n]))\n\n    max_baskets = 0\n    for shrub_a, shrub_b in zip(a, b):\n        red_baskets = min(k, shrub_a) // 2\n        blue_baskets = min(k, shrub_b) // 2\n        max_baskets += red_baskets + blue_baskets\n\n    return str(max_baskets)\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a, b = stdin.split()[2:]\n    a = [int(x) for x in a]\n    b = [int(x) for x in b]\n\n    max_baskets = 0\n    for i in range(n):\n        red_berries = a[i]\n        blue_berries = b[i]\n        shrubs_filled = 0\n\n        while red_berries >= k and blue_berries >= k:\n            red_berries -= k\n            blue_berries -= k\n            shrubs_filled += 1\n\n        max_baskets += shrubs_filled\n\n    return max_baskets\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shrubs = [list(map(int, stdin.split()[2:4])) for _ in range(n)]\n    \n    max_baskets = 0\n    \n    for i in range(n):\n        red_berries = shrubs[i][0]\n        blue_berries = shrubs[i][1]\n        shrub_berries = red_berries + blue_berries\n        \n        if k > shrub_berries:\n            max_baskets += 1\n        else:\n            if red_berries >= k:\n                max_baskets += 1\n            elif blue_berries >= k:\n                max_baskets += 1\n    \n    return str(max_baskets)"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shrubs = list(map(int, stdin.split()[2:]))\n    \n    red_berries = sum(shrubs[i] for i in range(0, 2*n, 2))\n    blue_berries = sum(shrubs[i] for i in range(1, 2*n, 2))\n\n    max_baskets = 0\n    if red_berries % k == 0:\n        max_baskets += red_berries // k\n    if blue_berries % k == 0:\n        max_baskets += blue_berries // k\n    \n    return max_baskets\n"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def fill_basket(basket_capacity: int, shrubs: list) -> int:\n        red_berries = sum([shrub[0] for shrub in shrubs])\n        blue_berries = sum([shrub[1] for shrub in shrubs])\n\n        if red_berries < basket_capacity or blue_berries < basket_capacity:\n            return 0\n\n        return min(red_berries // basket_capacity, blue_berries // basket_capacity)\n\n    def max_baskets(shrubs: list, k: int) -> int:\n        max_red_berries = sum([shrub[0] for shrub in shrubs])\n        max_blue_berries = sum([shrub[1] for shrub in shrubs])\n\n        return min(max_red_berries // k, max_blue_berries // k)\n\n    def main(n: int, k: int, shrubs: list) -> int:\n        basket_count = max_baskets(shrubs, k)\n        for i in range(1, n):\n            if shrubs[i][0] + shrubs[i][1] > k:\n                continue\n            basket_count = min(basket_count, fill_basket(k, shrubs[:i+1]))\n        return basket_count\n\n    stdin = stdin.splitlines()\n    n, k = map(int, stdin[0].split())\n    shrubs = [list(map(int, stdin[i+1].split())) for i in range(n)]\n\n    return str(main(n, k, shrubs))"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2*n:2]))\n    b = list(map(int, stdin.split()[3:2*n+1:2]))\n    \n    max_count = 0\n    \n    for i in range(n):\n        count = 0\n        total_berries = a[i] + b[i]\n        if total_berries >= k:\n            count += 1\n            if a[i] >= k:\n                a[i] -= k\n                count += 1\n            elif b[i] >= k:\n                b[i] -= k\n                count += 1\n            else:\n                k -= b[i]\n                b[i] = 0\n                count += 1\n        max_count = max(max_count, count)\n    \n    return max_count"
    },
    {
        "number": 577,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def fill_baskets(berries, capacity):\n        total_berries = sum(berries)\n        baskets = 0\n        current_berries = 0\n        for shrub in berries:\n            for berry in shrub:\n                current_berries += berry\n                if current_berries > capacity:\n                    current_berries -= berry\n                else:\n                    baskets += 1\n            current_berries = 0\n        return baskets\n\n    n, k = map(int, stdin.split())\n    shrubs = [list(map(int, input().split())) for _ in range(n)]\n    berries = [shrub for shrub, _, _ in shrubs]\n    a_i, b_i = zip(*shrubs)\n\n    max_baskets = fill_baskets(berries, k)\n    max_baskets_with_red = fill_baskets(zip(a_i, b_i), k)\n    max_baskets_with_blue = fill_baskets(zip(b_i, a_i), k)\n\n    return max(max_baskets, max_baskets_with_red, max_baskets_with_blue)\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into a, d, and b\n    a, deb = stdin.split('.')\n    d, b = deb.split('e')\n    \n    # Convert the input into a float\n    distance = float(f'{a}.{d}e{b}')\n    \n    # Convert the float into the desired output format\n    if distance.is_integer():\n        return str(int(distance))\n    else:\n        a, b = str(distance).split('.')\n        a = a.lstrip('0')\n        b = b.rstrip('0')\n        if b:\n            return f'{a}.{b}'\n        else:\n            return a"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split('.'))\n    if a == 0:\n        return str(b)\n    else:\n        return str(a * 10**b)\n\ndef"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    number_str, = stdin.split()\n    a, d, b = map(int, number_str.split(\"e\"))\n\n    if a == 0 and b != 0:\n        raise ValueError(\"Invalid input: a must be non-zero when b is non-zero\")\n\n    if a == 0:\n        return str(a)\n\n    x = a * (10 ** b)\n    x_int, x_dec = divmod(x, 1)\n\n    if x_dec == 0:\n        return str(int(x_int))\n    else:\n        x_dec_int, _ = divmod(x_dec, 1)\n        x_dec_str = \"{:.0{}f}\".format(x_dec, int(b))\n        x_dec_str = x_dec_str.rstrip(\"0\").rstrip(\".\")\n        return \"{:d}.{}\".format(int(x_int), x_dec_str)\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    number, exp = stdin.split('e')\n    exp = int(exp)\n    decimal = float(number) * 10 ** exp\n\n    if decimal.is_integer():\n        return str(int(decimal))\n    else:\n        integer_part, decimal_part = str(decimal).split('.')\n        integer_part = int(integer_part)\n        decimal_part = int(decimal_part)\n        decimal_part //= 10 ** (len(str(decimal_part)) - 1)\n        return f\"{integer_part}.{decimal_part}\"\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    number, exponent = stdin.split('e')\n    a, d = int(number), int(exponent)\n\n    if a == 0:\n        decimal_value = 0\n    else:\n        decimal_value = a * 10 ** d\n\n    if decimal_value.is_integer():\n        return str(int(decimal_value))\n    else:\n        integer_value, decimal_part = str(decimal_value).split('.')\n        return integer_value + '.' + decimal_part.lstrip('0')\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin.split('e')\n    base = int(input_string[0])\n    exponent = int(input_string[1])\n\n    result = base * (10 ** exponent)\n\n    if result == int(result):\n        return str(int(result))\n    else:\n        integer_part = int(result)\n        decimal_part = result - integer_part\n        decimal_part = str(decimal_part)[2:]  # Removing the '0.' part\n        decimal_part = decimal_part.rstrip('0')  # Removing trailing zeroes\n        return str(integer_part) + '.' + decimal_part\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    a, d, b = stdin.split('.')\n    a = int(a)\n    d = int(d[:-1])\n    b = int(b[:-1])\n\n    if a == 0:\n        return f\"{d:0.2f}\"\n\n    x = a * 10**b\n    p, q = x // 10, x % 10\n\n    if q == 0:\n        return f\"{p}\"\n\n    return f\"{p}.{q:02d}\"\n\ndef"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    value = stdin.split('e')\n    if value[0] == '0':\n        exponent = int(value[1])\n        value = '0.' + '0' * (exponent - 1) + value[0][1:]\n    else:\n        exponent = int(value[1])\n        value = float(value[0]) * 10 ** exponent\n    return '{:.100f}'.format(value).rstrip('0').rstrip('.')\n"
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    distance_value, _, exponent = stdin.partition('e')\n    base, _, exponent = exponent.partition('+')\n    base = int(base)\n    exponent = int(exponent)\n    distance = float(distance_value) * 10 ** exponent\n\n    if distance.is_integer():\n        return str(int(distance))\n    else:\n        integer_part, decimal_part = str(distance).split('.')\n        integer_part = int(integer_part)\n        decimal_part = int(decimal_part)\n        return f\"{integer_part}.{decimal_part}\"\n\n\nstdin = input().strip()\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 578,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    number = stdin.strip()\n    num_list = number.split('.')\n    if len(num_list) == 1:\n        a, b = num_list[0].split('e')\n    else:\n        a, b = num_list\n        b = b.replace('e', '')\n\n    a = int(a)\n    b = int(b)\n\n    if a == 0:\n        x = a + b * 10 ** (-b)\n    else:\n        x = a * 10 ** b\n\n    if x.is_integer():\n        return str(int(x))\n    else:\n        p = int(x)\n        q = round((x - p) * 10 ** b)\n        return f\"{p}.{q:0>{b}}\""
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P, C = parse_input(stdin)\n    memo = {}\n    for i in range(1, N+1):\n        memo[i] = [0]*N\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i == j:\n                continue\n            move_to(i, j, N, P, C, memo)\n    max_score = 0\n    for i in range(1, N+1):\n        max_score = max(max_score, memo[i][i-1])\n    return str(max_score)\n\ndef"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:]))\n    \n    def move(s: int, p: int, c: int) -> Tuple[int, int]:\n        return p, c + C[p-1]\n    \n    def get_max_score(s: int) -> int:\n        max_score = 0\n        for p in P:\n            if p != s:\n                new_s, new_score = move(s, p, 0)\n                max_score = max(max_score, get_max_score(new_s) + new_score)\n        return max_score\n    \n    return str(get_max_score(1))"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:]))\n\n    score = 0\n    current_square = 1\n\n    for _ in range(K):\n        next_square = P[current_square-1]\n        score += C[next_square-1]\n        current_square = next_square\n\n    return str(score)\n"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:N+2+N]))\n    \n    def move(pos: int, c: int) -> int:\n        return C[P[pos-1]-1]\n    \n    score = 0\n    pos = 1\n    for _ in range(K):\n        score += move(pos, C[pos-1])\n        pos = P[pos-1]\n    \n    return str(score)\n\ninput_str = \"5 2\\n2 4 5 1 3\\n3 4 -10 -8 8\"\nprint(solution(input_str)) "
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:N+2]))\n    C = list(map(int, stdin.split()[N+2:]))\n    \n    def move(i: int) -> int:\n        j = P[i]\n        return C[j]\n    \n    def max_score(i: int) -> int:\n        if i == 0:\n            return 0\n        if K == 0:\n            return 0\n        return max(move(i) + max_score(i-1), max_score(i-1))\n    \n    return max_score(N)"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:]))\n\n    scores = [0] * N\n    start = 1\n    for _ in range(K):\n        scores[P[start-1]-1] += C[start-1]\n        start = P[start-1]\n\n    return max(scores)"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:]))\n    C = list(map(int, stdin.split()[N+2:]))\n\n    score = 0\n    current_square = 1\n\n    for _ in range(K):\n        next_square = P[current_square-1]\n        score += C[current_square-1]\n        current_square = next_square\n\n    return score"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:N+2]))\n    C = list(map(int, stdin.split()[N+2:]))\n    score = 0\n    current_square = 1\n    for _ in range(K):\n        next_square = P[current_square-1]\n        score += C[current_square-1]\n        current_square = next_square\n    return score\n\ndef"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    P = list(map(int, stdin.split()[2:N+2]))\n    C = list(map(int, stdin.split()[N+2:]))\n    \n    def move(square: int, score: int) -> int:\n        if square == N:\n            return score\n        return move(P[square-1], score + C[square-1])\n    \n    score = 0\n    for i in range(N):\n        score = max(score, move(i+1, 0))\n    \n    return str(score)\n\ndef"
    },
    {
        "number": 579,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P, C = read_input(stdin)\n    score = 0\n    for _ in range(K):\n        for i in range(N):\n            if C[i] != 0:\n                score += C[i]\n                break\n    return score\n\ndef"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    roads = [list(map(int, line.split())) for line in input_data[1:]]\n\n    # Initialize the distance matrix\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n\n    # Floyd-Warshall algorithm to find the shortest paths\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    # Initialize the minimum cost matrix\n    min_cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if dist[i][j] != float('inf'):\n                min_cost[i][j] = abs(dist[i][j] - int(dist[i][j]))\n\n    # Check if there is a path from s to t\n    if dist[s - 1][t - 1] == float('inf'):\n        return \"NO\"\n\n    # Check if the President will definitely ride along each road\n    answer = []\n    for a, b, l in roads:\n        if dist[s - 1][a - 1] + dist[b - 1][t - 1] == dist[s - 1][b - 1] + dist[a - 1][t - 1]:\n            answer.append(\"YES\")\n        elif min_cost[s - 1][a - 1] + min_cost[b - 1][t - 1] == min_cost[s - 1][b - 1] + min_cost[a - 1][t - 1]:\n            answer.append(f\"CAN {min_cost[s - 1][a - 1] + min_cost[b - 1][t - 1]}\")\n        else:\n            answer.append(\"NO\")\n\n    return \"\\n\".join(answer) "
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_repair(l: int) -> bool:\n        return l > 1\n\n    def repair_cost(l: int) -> int:\n        return 1\n\n    n, m, s, t = map(int, stdin.split())\n    assert 2 <= n <= 10**5\n    assert 1 <= m <= 10**5\n    assert 1 <= s <= n\n    assert s != t\n    assert 1 <= s <= n\n\n    roads = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.split())\n        assert 1 <= a <= n\n        assert 1 <= b <= n\n        assert a != b\n        assert 1 <= l <= 10**6\n        roads.append((a, b, l))\n\n    # Determine the shortest path from s to t\n    parent = [-1] * n\n    distance = [float('inf')] * n\n    distance[s - 1] = 0\n\n    def dijkstra(graph: list, n: int, start: int):\n        queue = [(0, start)]\n        while queue:\n            dist, node = heapq.heappop(queue)\n            if distance[node - 1] < dist:\n                continue\n            for neighbor, weight in graph[node - 1]:\n                d = dist + weight\n                if d < distance[neighbor - 1]:\n                    distance[neighbor - 1] = d\n                    parent[neighbor - 1] = node\n                    heapq.heappush(queue, (d, neighbor))\n\n    dijkstra(roads, n, s)\n\n    # Check if we can reach t\n    if distance[t - 1] == float('inf'):\n        return \"NO\"\n\n    # Check which roads can be repaired and whether they can be used for the shortest path\n    repairable_roads = []\n    for a, b, l in roads:\n        if a != s and b != s and a != t and b != t:\n            if can_repair(l):\n                repairable_roads.append((a, b, repair_cost(l)))\n\n    # Determine the shortest path with repaired roads\n    parent = [-1] * n\n    distance = [float('inf')] * n\n    distance[s - 1] = 0\n\n    for a, b, c in repairable_roads:\n        roads.append((a, b, c))\n\n    dijkstra(roads, n, s)\n\n    if distance[t - 1] == float('inf'):\n        return \"NO\"\n\n    # Determine the shortest path with repaired and non-repairable roads\n    parent = [-1] * n\n    distance = [float('inf')] * n\n    distance[s - 1] = 0\n\n    for a, b, l in roads:\n        if a != s and b != s and a != t and b != t and (a, b, l) not in repairable_roads:\n            if can_repair(l):\n                repairable_roads.append((a, b, repair_cost(l)))\n                roads.append((a, b, repair_cost(l)))\n\n    dijkstra(roads, n, s)\n\n    if distance[t - 1] == float('inf'):\n        return \"NO\"\n\n    # Check which roads can be used for the shortest path\n    for a, b, l in roads:\n        if a != s and b != s and a != t and b != t and (a, b, l) not in repairable_roads:\n            if can_repair(l):\n                repairable_roads.append((a, b, repair_cost(l)))\n\n    # Check if the path includes the repairable roads\n    for a, b, c in repairable_roads:\n        if a == t and b == s:\n            return \"YES\"\n        if distance[a - 1] + c < distance[b - 1]:\n            return \"CAN\", distance[a - 1] + c\n\n    return \"NO\"\n"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    roads = [map(int, input().split()) for _ in range(m)]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, cost = queue.pop(0)\n            if node == end:\n                return cost\n            visited.add(node)\n            for a, b, l in roads:\n                if a == node and b not in visited:\n                    queue.append((b, cost + l))\n        return -1\n\n    shortest_paths = [bfs(s, i) for i in range(1, n + 1)]\n\n    def is_possible(a, b, l):\n        return b in [a, b] and l > 1\n\n    def can_repair(a, b, l):\n        return bfs(a, t) - bfs(a, b) + 1 >= l\n\n    result = []\n    for a, b, l in roads:\n        if bfs(a, b) == -1:\n            result.append(\"NO\")\n        elif b == t:\n            result.append(\"YES\")\n        elif is_possible(a, b, l):\n            result.append(\"CAN {}\".format(l - 1))\n        elif can_repair(a, b, l):\n            result.append(\"CAN {}\".format(l - 1))\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(road_costs, president_path):\n        min_cost = float('inf')\n        for i, j in enumerate(president_path):\n            if j in road_costs:\n                min_cost = min(min_cost, road_costs[j])\n            elif i > 0:\n                min_cost = min(min_cost, road_costs[president_path[i-1]])\n        return min_cost\n\n    n, m, s, t = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        a, b, l = map(int, input().split())\n        roads.append((a, b, l))\n\n    road_costs = {}\n    visited = set()\n    to_visit = [s]\n    min_cost = 0\n\n    while to_visit:\n        current = to_visit.pop(0)\n        visited.add(current)\n        min_cost = max(min_cost, road_costs.get(current, 0))\n\n        for a, b, l in roads:\n            if a == current and b not in visited:\n                road_costs[b] = max(road_costs.get(b, 0), l - min_cost)\n                to_visit.append(b)\n            elif b == current and a not in visited:\n                road_costs[a] = max(road_costs.get(a, 0), l - min_cost)\n                to_visit.append(a)\n\n    min_cost = max(min_cost, road_costs.get(t, 0))\n    president_path = [s]\n    visited = set()\n    to_visit = [s]\n\n    while t not in visited:\n        current = to_visit.pop(0)\n        visited.add(current)\n        if current == t:\n            break\n        for a, b, l in roads:\n            if a == current and b not in visited:\n                if road_costs.get(b, 0) > 0:\n                    to_visit.append(b)\n            elif b == current and a not in visited:\n                if road_costs.get(a, 0) > 0:\n                    to_visit.append(a)\n\n    if t not in visited:\n        return \"NO\"\n\n    return \"YES\" if len(president_path) == 1 else \"CAN \" + str(min_cost)\n\n\ninput_file = open(\"input.txt\", \"r\")\noutput_file = open(\"output.txt\", \"w\")\n\nstdin = input_file.read()\nresult = solution(stdin)\noutput_file.write(result + \"\\n\")\n\ninput_file.close()\noutput_file.close() "
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [map(int, stdin.split()[4:][i:i+3]) for i in range(0, m * 3, 3)]\n\n    visited = [False] * n\n    shortest_path = [float('inf')] * n\n    shortest_path[s] = 0\n\n    def dfs(node):\n        visited[node] = True\n        for a, b, l in roads:\n            if not visited[b] and shortest_path[a] + l < shortest_path[b]:\n                shortest_path[b] = shortest_path[a] + l\n                dfs(b)\n\n    dfs(s)\n    if shortest_path[t] == float('inf'):\n        return \"NO\"\n\n    repaired_roads = [(-1, -1, -1)] * m\n    for a, b, l in roads:\n        if shortest_path[a] + l < shortest_path[b]:\n            repaired_roads[a-1] = (a, b, l)\n\n    for a, b, l in repaired_roads:\n        if a != -1 and b != -1:\n            time_before = shortest_path[a] + l\n            time_after = shortest_path[a]\n            min_cost = 1\n            while time_after <= time_before and min_cost <= time_before - time_after:\n                min_cost += 1\n                time_after += 1\n            if min_cost <= time_before - time_after:\n                return \"CAN\", min_cost\n\n    return \"YES\"\n\nn, m, s, t = map(int, input().split()[:4])\nroads = [map(int, input().split()[1:]) for _ in range(m)]\n\nfor i in range(m):\n    print(solution(str(n) + \" \" + str(m) + \" \" + str(s) + \" \" + str(t) + \" \" + \" \".join(map(str, roads[i]))))"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_minimum_cost(a, b, c, n):\n        x = a + b + c - n\n        if x <= n:\n            return x\n        else:\n            return 2 * n - x\n\n    def repair_road(a, b, c, n):\n        x = a + b + c - n\n        if x <= n:\n            return True\n        else:\n            return False\n\n    def bfs(graph: list, visited: list, start: int, end: int) -> bool:\n        queue = [(start, 0)]\n        visited[start] = True\n        while queue:\n            node, cost = queue.pop(0)\n            if node == end:\n                return cost\n            for neighbor, edge_cost in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, cost + edge_cost))\n                    visited[neighbor] = True\n        return False\n\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    visited = [False] * (n + 1)\n    distance = bfs(graph, visited, s, t)\n\n    if not distance:\n        return \"NO\"\n    else:\n        for i in range(m):\n            a, b, c = map(int, stdin.split())\n            if repair_road(a, b, c, n):\n                cost = get_minimum_cost(a, b, c, n)\n                print(f\"CAN {cost}\")\n            else:\n                print(\"NO\")\n"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [tuple(map(int, stdin.split()[4:])) for _ in range(m)]\n    roads.sort(key=lambda x: x[2])\n    pres_path = [s]\n    min_cost = 0\n    min_time = 0\n    for a, b, l in roads:\n        if pres_path[-1] == a:\n            min_time += l\n            pres_path.append(b)\n            if pres_path[-1] == t:\n                min_cost += min_time\n                break\n        else:\n            pres_path.clear()\n    else:\n        return \"NO\"\n    if min_time <= 1:\n        return \"YES\"\n    return \"CAN\", min_cost"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def can_repair(road, min_time):\n        return (road[1] - road[0] + 1) * min_time >= road[2]\n\n    def repair_cost(road, min_time):\n        return (road[1] - road[0] + 1) * (min_time - road[2])\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [tuple(map(int, stdin.split()[i:i+3])) for i in range(4, 4 + m * 3, 3)]\n    adj_matrix = [[0] * n for _ in range(n)]\n\n    for road in roads:\n        adj_matrix[road[0] - 1][road[1] - 1] = road[2]\n\n    min_time = float('inf')\n    min_path = []\n    visited = [False] * n\n\n    def dfs(node, path, time):\n        nonlocal min_time, min_path, visited\n        if node == t - 1:\n            min_time = min(min_time, time)\n            if min_time == time:\n                min_path = path\n            return\n        visited[node] = True\n        for neighbor, cost in enumerate(adj_matrix[node]):\n            if not visited[neighbor] and cost > 0:\n                dfs(neighbor, path + [node + 1], time + cost)\n        visited[node] = False\n\n    dfs(s - 1, [], 0)\n\n    if not min_path:\n        return \"NO\"\n\n    result = \"YES\"\n    for i, road in enumerate(roads):\n        if road[0] == min_path[0] and road[1] == min_path[-1]:\n            if can_repair(road, min_time):\n                result = \"CAN \" + str(repair_cost(road, min_time))\n            break\n\n    return result"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    roads.sort(key=lambda x: x[2])\n\n    def is_possible(i: int) -> bool:\n        visited = [False] * (n + 1)\n        visited[s] = True\n        queue = [s]\n        while queue:\n            current = queue.pop(0)\n            if current == t:\n                return True\n            for a, b, l in roads:\n                if a == current and not visited[b]:\n                    if l <= roads[i][2]:\n                        visited[b] = True\n                        queue.append(b)\n        return False\n\n    def repair(i: int) -> Tuple[bool, int]:\n        time_before = roads[i][2]\n        roads[i] = (roads[i][0], roads[i][1], roads[i][2] - 1)\n        time_after = roads[i][2]\n        cost = abs(time_before - time_after)\n        return is_possible(i), cost\n\n    for i in range(m):\n        if is_possible(i):\n            print(\"YES\")\n        else:\n            repair_possible, cost = repair(i)\n            if repair_possible:\n                print(\"CAN\", cost)\n            else:\n                print(\"NO\")"
    },
    {
        "number": 580,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def can_repair_road(l: int) -> bool:\n        return l <= 1\n\n    def repair_cost(l: int) -> int:\n        return 1 if l % 2 == 0 else 2\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    roads = [tuple(map(int, stdin.split()[4:7])) for _ in range(m)]\n    visited = [False] * n\n\n    def dfs(v: int, path: str, depth: int) -> None:\n        if v == t:\n            path_list = path.split()\n            if len(path_list) == 1:\n                print(\"YES\")\n            else:\n                road_index = int(path_list[-1]) - 1\n                l = roads[road_index][2]\n                if can_repair_road(l):\n                    cost = repair_cost(l)\n                    print(\"CAN\", cost)\n                else:\n                    print(\"NO\")\n            return\n\n        visited[v] = True\n        for a, b, l in roads:\n            if not visited[b] and a == v:\n                dfs(b, path + f\"{v} -> {b} \", depth + 1)\n\n    dfs(s, f\"{s} -> {t} \", 1)\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    \n    n = int(input())\n    edges = defaultdict(set)\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        edges[a].add(b)\n        edges[b].add(a)\n    \n    # Find leaves\n    leaves = set()\n    for i in range(1, n + 1):\n        if i not in edges:\n            leaves.add(i)\n    \n    # DFS to find simple paths\n    def dfs(node, prev, path_length):\n        if node in edges:\n            for neighbor in edges[node]:\n                if neighbor != prev:\n                    dfs(neighbor, node, path_length + 1)\n        simple_paths[node] = path_length\n    \n    simple_paths = {}\n    dfs(1, None, 0)\n    \n    # Calculate the answer\n    max_answer = 0\n    operations = []\n    for leaf1 in leaves:\n        for leaf2 in leaves - {leaf1}:\n            path_length = simple_paths[leaf1] + simple_paths[leaf2]\n            if path_length > max_answer:\n                max_answer = path_length\n                operations = [(leaf1, leaf2, leaf1)]\n            elif path_length == max_answer:\n                operations.append((leaf1, leaf2, leaf1))\n    \n    # Apply the operations\n    leaves.remove(operations[0][2])\n    for i in range(n - 2):\n        leaf1, leaf2, c = operations[i]\n        leaves.remove(c)\n        path_length = simple_paths[leaf1] + simple_paths[leaf2]\n        if path_length > max_answer:\n            max_answer = path_length\n        print(leaf1, leaf2, c, max_answer)\n    \n    return str(max_answer) + \"\\n\" + \"\\n\".join(str(op) for op in operations) + \"\\n\"\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    tree = [tuple(map(int, input_data[i].split())) for i in range(1, n)]\n\n    def find_leaves(tree):\n        leaves = set()\n        for a, b in tree:\n            leaves.add(a)\n            leaves.add(b)\n        return leaves\n\n    leaves = find_leaves(tree)\n\n    def get_path_length(a, b):\n        path = []\n        while a != b:\n            path.append(a)\n            a = tree[tree.index((a, b)) - 1][0]\n        return len(path)\n\n    def find_pair_and_leaf(tree, leaves, chosen_leaves):\n        for a, b in tree:\n            if a in chosen_leaves and b in leaves - chosen_leaves:\n                c = a\n                return a, b, c\n            elif b in chosen_leaves and a in leaves - chosen_leaves:\n                c = b\n                return a, b, c\n        return None\n\n    answer = 0\n    operations = []\n    while len(leaves) > 1:\n        chosen_leaves = leaves.pop()\n        path_length = get_path_length(chosen_leaves, leaves)\n        answer += path_length\n        operations.append((chosen_leaves, chosen_leaves, chosen_leaves))\n        leaves.remove(chosen_leaves)\n        leaves.remove(chosen_leaves)\n        pair, leaf, _ = find_pair_and_leaf(tree, leaves, {chosen_leaves})\n        leaves.remove(leaf)\n        operations.append((pair, chosen_leaves, leaf))\n\n    return str(answer) + \"\\n\" + \"\\n\".join(str(o) for o in operations)\n\n\nstdin = \"\"\"3\n1 2\n1 3\n\n5\n1 2\n1 3\n2 4\n2 5\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(u: int) -> int:\n        while u != parent[u]:\n            u = parent[u]\n        return u\n\n    def union(u: int, v: int) -> None:\n        pu = find_parent(u)\n        pv = find_parent(v)\n        if pu != pv:\n            if rank[pu] < rank[pv]:\n                parent[pu] = pv\n            elif rank[pu] > rank[pv]:\n                parent[pv] = pu\n            else:\n                parent[pv] = pu\n                rank[pu] += 1\n\n    def add_leaf(u: int, v: int) -> int:\n        nonlocal ans\n        ans += len(path[u][v])\n        path[u][v] = path[v][u] = []\n\n    def remove_leaf(u: int) -> None:\n        for v in range(1, n + 1):\n            if u in path[v]:\n                path[v].remove(u)\n\n    def find_path(u: int, v: int) -> List[int]:\n        u = find_parent(u)\n        v = find_parent(v)\n        if u == v:\n            return [u]\n        for i, p in enumerate(path[u][v]):\n            if find_parent(p) == v:\n                return [u] + path[u][v][i + 1:] + [v]\n        return []\n\n    n, *edges = stdin.split()\n    n = int(n)\n\n    parent = list(range(1, n + 1))\n    rank = [0] * (n + 1)\n    path = [[[] for _ in range(n)] for _ in range(n)]\n\n    for u, v in map(int, edges):\n        union(u, v)\n        path[u - 1][v - 1] = find_path(u, v)\n        path[v - 1][u - 1] = find_path(v, u)\n\n    ans = 0\n    operations = []\n    leaves = [i for i in range(1, n + 1) if parent[i] == i]\n\n    while leaves:\n        u, v = leaves.pop(), leaves.pop()\n        add_leaf(u, v)\n        operations.append((u, v, u))\n        remove_leaf(u)\n        leaves.remove(u)\n        if len(leaves) == 1:\n            ans -= len(path[leaves[0]][parent[leaves[0]]]) - 1\n            operations.append((leaves[0], parent[leaves[0]], leaves[0]))\n            remove_leaf(leaves[0])\n            leaves.remove(leaves[0])\n            break\n\n    return str(ans) + '\\n' + '\\n'.join(str(op) for op in operations)\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    graph = [list(map(int, line.split())) for line in input_data[1:]]\n\n    def find_ancestor(node: int) -> int:\n        nonlocal parent\n        while parent[node] != -1:\n            node = parent[node]\n        return node\n\n    def lca(node1: int, node2: int) -> int:\n        nonlocal parent\n        node1, node2 = find_ancestor(node1), find_ancestor(node2)\n        while node1 != node2:\n            node1 = find_ancestor(node1)\n            node2 = find_ancestor(node2)\n        return node1\n\n    parent = [-1] * n\n    for a, b in graph:\n        parent[a], parent[b] = lca(a, b), lca(a, b)\n        parent[b] = a\n\n    def dfs(node: int) -> int:\n        nonlocal answer\n        if parent[node] == -1:\n            return 0\n        length = dfs(parent[node]) + 1\n        answer += length\n        return length\n\n    answer = 0\n    dfs(1)\n\n    operations = []\n    for a, b in graph:\n        parent[a] = parent[b] = -1\n        lca_node = lca(a, b)\n        operations.append((a, b, lca_node))\n\n    return f\"{answer}\\n\" + \"\\n\".join(f\"{a} {b} {c}\" for a, b, c in operations)\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, vertex):\n        if parent[vertex] != vertex:\n            parent[vertex] = find_parent(parent, parent[vertex])\n        return parent[vertex]\n\n    def union(parent, rank, x, y):\n        x_root = find_parent(parent, x)\n        y_root = find_parent(parent, y)\n\n        if x_root == y_root:\n            return False\n\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n        return True\n\n    n = int(stdin[0].strip())\n    edges = [tuple(map(int, line.strip().split())) for line in stdin[1:n - 1]]\n    parent = list(range(n))\n    rank = [0] * n\n\n    answer = 0\n    operations = []\n\n    for u, v in edges:\n        u_parent = find_parent(parent, u)\n        v_parent = find_parent(parent, v)\n\n        if u_parent != v_parent:\n            union(parent, rank, u_parent, v_parent)\n\n            path_length = len(edges) - len({(u, v) for u, v in edges if find_parent(parent, u) == find_parent(parent, v)})\n            answer += path_length\n            operations.append((u, v, u))\n\n    for i in range(n - 2, -1, -1):\n        u, v = edges[i]\n        u_parent = find_parent(parent, u)\n        v_parent = find_parent(parent, v)\n\n        if u_parent != v_parent:\n            union(parent, rank, u_parent, v_parent)\n\n            path_length = len(edges) - len({(u, v) for u, v in edges if find_parent(parent, u) == find_parent(parent, v)})\n            answer += path_length\n            operations.append((u, v, v))\n\n    return f\"{answer}\\n\" + \"\\n\".join(f\"{u} {v} {c}\" for u, v, c in operations[::-1])\n\n\ninput_data = [\n    \"3\",\n    \"1 2\",\n    \"1 3\",\n    \"2 4\",\n    \"2 5\",\n    \"5\",\n    \"1 2\",\n    \"1 3\",\n    \"2 4\",\n    \"2 5\",\n]\n\nprint(solution(input_data)) "
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, graph, visited, parent, dist):\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                dfs(child, graph, visited, node, dist + 1)\n                \n    def find_leaf(node, graph, visited, parent):\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                find_leaf(child, graph, visited, node)\n                \n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    max_dist = 0\n    for i in range(1, n + 1):\n        find_leaf(i, graph, visited, 0)\n        if not visited[i]:\n            return \"Impossible\"\n        visited = [False] * (n + 1)\n        dfs(i, graph, visited, 0, 0)\n        if max_dist < sum(visited):\n            max_dist = sum(visited)\n    answer = max_dist\n    operations = []\n    for i in range(1, n + 1):\n        if visited[i]:\n            continue\n        for j, leaf in enumerate(sorted([k for k in range(1, n + 1) if not visited[k] and k != i], key=lambda x: max_dist - sum(visited[u] for u in graph[x])))[:2]:\n            operations.append(f\"{i} {leaf} {leaf}\")\n            if visited[leaf] - max_dist < 2:\n                visited[leaf] = max_dist - 1\n                break\n        answer -= max_dist - sum(visited)\n        operations.append(f\"{i} {leaf} {leaf}\")\n    return str(answer) + '\\n' + '\\n'.join(operations) "
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(u: int) -> int:\n        while parent[u] != u:\n            u = parent[u]\n        return u\n\n    def union(u: int, v: int):\n        parent[u] = find_parent(u)\n        parent[v] = parent[u]\n\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    parent = list(range(n + 1))\n    max_length = 0\n    operations = []\n    for u, v in edges:\n        pu = find_parent(u)\n        pv = find_parent(v)\n        if pu != pv:\n            union(u, v)\n            length = pu - pv\n            max_length += length\n            operations.append((u, v, pv))\n\n    print(max_length)\n    for u, v, p in operations:\n        if p == u:\n            print(v, p, v)\n        else:\n            print(u, p, v)"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_leaf(root: int, edges: list, visited: list, max_path: int) -> tuple:\n        if visited[root]:\n            return max_path, visited[root]\n        visited[root] = True\n        max_path = max(max_path, 1)\n        for child in edges[root]:\n            if child != root:\n                path, leaf = find_leaf(child, edges, visited, max_path)\n                max_path = max(max_path, path + leaf)\n        return max_path, root\n\n    n = int(stdin.splitlines()[0])\n    edges = [[] for _ in range(n)]\n    for i in range(1, n):\n        a, b = map(int, stdin.splitlines()[i].split())\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n\n    max_path = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            path, leaf = find_leaf(i, edges, visited, max_path)\n            max_path = max(max_path, path + leaf)\n\n    answer = max_path\n    operations = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.splitlines()[i + 1].split())\n        a, b = a - 1, b - 1\n        for child in edges[a]:\n            if child != b:\n                break\n        for child in edges[b]:\n            if child != a:\n                break\n        edges[a].remove(child)\n        edges[b].remove(child)\n        operations.append((a + 1, b + 1, child + 1))\n\n    print(answer)\n    for operation in operations:\n        print(f\"{operation[0]}, {operation[1]}, {operation[2]}\")\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n-1]]\n    leaves = [set() for _ in range(n)]\n    for a, b in edges:\n        leaves[a].add(a)\n        leaves[b].add(b)\n\n    def dfs(node: int, parent: int) -> int:\n        if len(leaves[node]) == 1:\n            return 0\n        max_dist = 0\n        for leaf in leaves[node]:\n            if leaf != parent:\n                dist = dfs(leaf, node)\n                max_dist = max(max_dist, dist)\n        return max_dist + 1\n\n    max_dist = 0\n    for i in range(n):\n        dist = dfs(i, -1)\n        max_dist = max(max_dist, dist)\n\n    answer = 0\n    operations = []\n    for i in range(n-1):\n        max_leaf = -1\n        max_dist = 0\n        for leaf in leaves:\n            if leaf and leaf != leaves[i+1]:\n                dist = dfs(list(leaf)[0], -1)\n                if dist > max_dist or (dist == max_dist and list(leaf)[0] < max_leaf):\n                    max_leaf = list(leaf)[0]\n                    max_dist = dist\n        leaves[i+1].remove(max_leaf)\n        answer += max_dist + 1\n        operations.append((i, i+1, max_leaf))\n\n    return f\"{answer}\\n\" + \"\\n\".join(f\"{a} {b} {c}\" for a, b, c in operations)\n"
    },
    {
        "number": 581,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    adj_list = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n    max_answer = 0\n    operations = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            for leaf_a, leaf_b in [(leaf_a, leaf_b) for leaf_a in adj_list[i] for leaf_b in adj_list[j] if leaf_a != leaf_b]:\n                if leaf_a == adj_list[i][0] and leaf_b == adj_list[j][1]:\n                    path_length = adj_list[i].index(leaf_a) + adj_list[j].index(leaf_b) + 1\n                    if path_length > max_answer:\n                        max_answer = path_length\n                        operations.append([leaf_a, leaf_b, leaf_a])\n                        break\n                elif leaf_a == adj_list[i][1] and leaf_b == adj_list[j][0]:\n                    path_length = adj_list[i].index(leaf_a) + adj_list[j].index(leaf_b) + 1\n                    if path_length > max_answer:\n                        max_answer = path_length\n                        operations.append([leaf_a, leaf_b, leaf_b])\n                        break\n    result = str(max_answer) + \"\\n\" + \"\\n\".join([\" \".join(map(str, op)) for op in operations])\n    return result "
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    t = [int(x) for x in stdin.split('\\n')[2].split()]\n\n    max_t = max(t)\n    max_a = max(a)\n\n    if max_t * n <= max_a:\n        return \"0\"\n\n    t_sum = sum([x * a.count(x) for x in set(t)])\n    return max_t * n - t_sum\n"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    t = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    if n == 1:\n        return \"0\"\n\n    a_sorted = sorted(a, reverse=True)\n    t_sorted = sorted(t)\n\n    time = 0\n    for i in range(n - 1):\n        time += t_sorted[i]\n        if a_sorted[i] == a_sorted[i + 1]:\n            time += a_sorted[i] * t_sorted[i]\n            break\n\n    return str(time)\n\n\nn = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\nprint(solution(f\"{n}\\n{' '.join(map(str, a))}\\n{' '.join(map(str, t))}\\n\")) "
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    t = list(map(int, stdin.splitlines()[2].split()))\n\n    if len(set(a)) == n:\n        return 0\n\n    min_time = sum(t)\n    for i in range(n):\n        for j in range(n):\n            if i != j and a[i] == a[j]:\n                min_time = min(min_time, t[i] + t[j])\n\n    return min_time\n\n\nstdin = \"\"\"5\n3 7 9 7 8\n5 2 5 7 5\"\"\"\nprint(solution(stdin))  # Output: 6\n\nstdin = \"\"\"5\n1 2 3 4 5\n1 1 1 1 1\"\"\"\nprint(solution(stdin))  # Output: 0\n\nstdin = \"\"\"200000\n1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 100000"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    \n    total_time = sum(t)\n    if len(set(a)) == n:\n        return str(0)\n    \n    time_left = total_time\n    categories = sorted(range(n), key=lambda i: a[i], reverse=True)\n    \n    for i in range(n):\n        category = categories[i]\n        remaining = a[category]\n        if remaining == 1:\n            time_left -= t[category]\n        else:\n            while remaining > 1 and time_left >= t[category]:\n                remaining -= 1\n                time_left -= t[category]\n    \n    return str(total_time - time_left)\n\n\ndef"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    t = list(map(int, stdin.splitlines()[2].split()))\n\n    min_time = 0\n    for i in range(n):\n        min_time += t[i] * (a[i] - 1)\n\n    return str(min_time)\n"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    t = list(map(int, stdin.split('\\n')[2].split()))\n\n    a.sort()\n    t.sort()\n\n    max_t = sum(t[:n])\n\n    min_t = sum(t[i] for i in range(n) if a[i] != a[n - 1])\n\n    if min_t == max_t:\n        return 0\n    else:\n        return max_t\n\ndef"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    \n    if n == 1:\n        return 0\n    \n    max_time = max(t)\n    \n    # Calculate the total time needed for targeted algorithm to get rid of categories with the same size\n    total_time = 0\n    for i in range(n):\n        total_time += a[i] * t[i]\n        \n    # Calculate the total time needed for batch algorithm to select different number of publications\n    batch_time = sum(t) * max_time\n    \n    # The minimum total time necessary to add publications to the result of batch algorithm execution\n    # is the difference between the two times\n    min_time = total_time - batch_time\n    \n    return min_time"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    t = list(map(int, stdin.splitlines()[2].split()))\n\n    min_time = sum(t)\n    for i in range(n):\n        for j in range(i+1, n):\n            min_time = min(min_time, t[i] + t[j] - max(a[i], a[j]))\n\n    return str(min_time)\n"
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    t = list(map(int, stdin.splitlines()[2].split()))\n\n    if len(set(a)) == n:\n        return 0\n\n    min_time = 0\n    max_size = max(a)\n\n    for size in range(max_size, 0, -1):\n        min_time += size * t[a.index(size)]\n\n    return min_time\n\n\ninput_string = \"\"\"5\n3 7 9 7 8\n5 2 5 7 5\n\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 582,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    t = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    result = 0\n    min_a = min(a)\n    max_a = max(a)\n\n    for i in range(n):\n        result += (max_a - min_a) * t[i]\n\n    return str(result)"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    max_beauty = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            shifted_s = s[j:] + s[:j]\n            cyclical_shifts = [shifted_s[k:] + shifted_s[:k] for k in range(n)]\n            correct_shifts = [shift for shift in cyclical_shifts if is_correct(shift)]\n            if len(correct_shifts) > max_beauty:\n                max_beauty = len(correct_shifts)\n\n    if max_beauty == 0:\n        return \"0\\n1 1\"\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            shifted_s = s[j:] + s[:j]\n            cyclical_shifts = [shifted_s[k:] + shifted_s[:k] for k in range(n)]\n            correct_shifts = [shift for shift in cyclical_shifts if is_correct(shift)]\n            if len(correct_shifts) == max_beauty:\n                return f\"{max_beauty}\\n{i + 1} {j + 1}\"\n\n\ndef"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    \n    max_beauty = 0\n    max_swap_positions = [0, 0]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if s[i] + s[j] == \"()\":\n                beauty = s[:i] + s[i] + s[j] + s[i + 1:j] + s[j] + s[i + 1:j + 1] + s[j + 1:]\n                beauty_count = 0\n                for k in range(len(s) - len(beauty) + 1):\n                    if beauty == s[k:k + len(beauty)]:\n                        beauty_count += 1\n                if beauty_count > max_beauty:\n                    max_beauty = beauty_count\n                    max_swap_positions = [i + 1, j]\n    \n    return str(max_beauty) + \"\\n\" + \" \".join(map(str, max_swap_positions))"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    s = input()\n\n    max_beauty = 0\n    l, r = 1, 1\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            swapped = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]\n            beauty = 0\n            for k in range(n):\n                if k % 2 == 0:\n                    beauty += swapped.count(\"(\")\n                else:\n                    beauty -= swapped.count(\"(\")\n                    beauty += swapped.count(\")\")\n\n            if beauty > max_beauty:\n                max_beauty = beauty\n                l, r = i + 1, j + 1\n\n    return str(max_beauty) + \"\\n\" + str(l) + \" \" + str(r)\n\n\ndef"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    max_beauty = 0\n    max_swap = (1, 1)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] != s[j]:\n                swap = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                beauty = max(0, len([1 for k in range(n) if swap[k:] == swap[:k] + \"(\" + swap[k-1] + \")\"]) - 1)\n                if beauty > max_beauty:\n                    max_beauty = beauty\n                    max_swap = (i+1, j+1)\n\n    return str(max_beauty) + '\\n' + str(max_swap[0]) + ' ' + str(max_swap[1])"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    bracket_string = stdin.splitlines()[1]\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_bracket_string = bracket_string[:i] + bracket_string[j] + bracket_string[i+1:j] + bracket_string[i] + bracket_string[j+1:]\n            beauty = 0\n            for k in range(n):\n                temp_shifted_bracket_string = temp_bracket_string[k:] + temp_bracket_string[:k]\n                if temp_shifted_bracket_string == \"()\":\n                    beauty += 1\n            max_beauty = max(max_beauty, beauty)\n\n    max_beauty_positions = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_bracket_string = bracket_string[:i] + bracket_string[j] + bracket_string[i+1:j] + bracket_string[i] + bracket_string[j+1:]\n            beauty = 0\n            for k in range(n):\n                temp_shifted_bracket_string = temp_bracket_string[k:] + temp_bracket_string[:k]\n                if temp_shifted_bracket_string == \"()\":\n                    beauty += 1\n            if beauty == max_beauty:\n                max_beauty_positions.append((i, j))\n\n    if max_beauty_positions:\n        return str(max_beauty) + \"\\n\" + \" \".join(str(pos) for pos in max_beauty_positions[0])\n    else:\n        return \"0\\n1 1\"\n"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    bracket_string = stdin.splitlines()[1]\n\n    max_beauty = 0\n    max_swap = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_bracket_string = bracket_string[:i] + bracket_string[j] + bracket_string[i + 1:]\n            new_bracket_string = new_bracket_string[:j] + bracket_string[i] + new_bracket_string[j + 1:]\n\n            beauty = 0\n            for k in range(0, n, 2):\n                if new_bracket_string[k] == \"(\":\n                    beauty += 1\n                elif new_bracket_string[k] == \")\":\n                    beauty -= 1\n\n            if beauty > max_beauty:\n                max_beauty = beauty\n                max_swap = (i + 1, j + 1)\n\n    return str(max_beauty) + \"\\n\" + \" \".join(str(x) for x in max_swap)\n"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    max_beauty = 0\n    max_swap = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            swap = list(s)\n            swap[i], swap[j] = swap[j], swap[i]\n            swap_str = ''.join(swap)\n            swap_beauty = 0\n\n            for k in range(n):\n                cyclical_shift = swap_str[k:] + swap_str[:k]\n                if cyclical_shift.count('(') == cyclical_shift.count(')'):\n                    swap_beauty += 1\n\n            if swap_beauty > max_beauty:\n                max_beauty = swap_beauty\n                max_swap = [i + 1, j + 1]\n\n    return f\"{max_beauty}\\n{max_swap[0]} {max_swap[1]}\""
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    bracket_string = stdin.split(\"\\n\")[1]\n\n    def is_correct_bracket_sequence(s):\n        stack = []\n        for bracket in s:\n            if bracket == \"(\":\n                stack.append(bracket)\n            else:\n                if not stack or stack.pop() != \"(\":\n                    return False\n        return len(stack) == 0\n\n    def cyclical_shift(s, k):\n        return s[k:] + s[:k]\n\n    def count_cyclical_shifts(s):\n        count = 0\n        for k in range(len(s)):\n            if is_correct_bracket_sequence(cyclical_shift(s, k)):\n                count += 1\n        return count\n\n    max_beauty = 0\n    l, r = 1, 1\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            swapped_string = bracket_string[:i] + bracket_string[j] + bracket_string[i + 1:j] + bracket_string[i] + bracket_string[j + 1:]\n            if count_cyclical_shifts(swapped_string) > max_beauty:\n                max_beauty = count_cyclical_shifts(swapped_string)\n                l, r = i, j\n\n    return f\"{max_beauty}\\n{l} {r}\""
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    swap_max = 0\n    l, r = 1, 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_s = list(s)\n            temp_s[i], temp_s[j] = temp_s[j], temp_s[i]\n            temp_s = ''.join(temp_s)\n            cyclic_shift = 0\n            for k in range(n):\n                if not is_correct(temp_s[k:] + temp_s[:k]):\n                    break\n                cyclic_shift += 1\n            if cyclic_shift > swap_max:\n                swap_max = cyclic_shift\n                l, r = i + 1, j + 1\n\n    return swap_max, l, r\n\ndef"
    },
    {
        "number": 583,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    max_beauty = 0\n    swap_i = 0\n    swap_j = 0\n\n    for i in range(1, n):\n        if s[i] == '(' and s[i - 1] == ')':\n            beauty = 1\n            shift_i = i + 1\n            shift_j = i - 1\n\n            while shift_i < n and s[shift_i] == '(':\n                beauty += 1\n                shift_i += 1\n\n            while shift_j > 0 and s[shift_j] == ')':\n                beauty += 1\n                shift_j -= 1\n\n            max_beauty = max(max_beauty, beauty)\n            swap_i = i - 1\n            swap_j = i + 1\n\n    if max_beauty == 0:\n        swap_i = 0\n        swap_j = 0\n\n    return f\"{max_beauty}\\n{swap_i} {swap_j}\"\n"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    string_length = int(input_list[0])\n    input_string = input_list[1]\n\n    # Find longest word outside parentheses\n    longest_word_length = 0\n    longest_word = \"\"\n    word = \"\"\n    for char in input_string:\n        if char.isalpha():\n            word += char\n        else:\n            if word and word not in [\"(\", \")\", \"_\"]:\n                word = word.replace(\"_\", \" \")\n                word_length = len(word)\n                if word_length > longest_word_length:\n                    longest_word_length = word_length\n                    longest_word = word\n            word = \"\"\n    if word and word not in [\"(\", \")\", \"_\"]:\n        word = word.replace(\"_\", \" \")\n        word_length = len(word)\n        if word_length > longest_word_length:\n            longest_word_length = word_length\n            longest_word = word\n\n    if longest_word_length == 0:\n        longest_word_length = \"0\"\n\n    # Find words inside parentheses\n    parentheses_count = 0\n    parentheses_word_count = 0\n    for char in input_string:\n        if char == \"(\":\n            parentheses_count += 1\n        elif char == \")\":\n            parentheses_count -= 1\n        elif char.isalpha() and parentheses_count % 2 == 0:\n            word += char\n        elif char.isalpha() and parentheses_count % 2 == 1:\n            word = \"\"\n        else:\n            if word and word not in [\"(\", \")\", \"_\"]:\n                word = word.replace(\"_\", \" \")\n                word_length = len(word)\n                if word_length > 0:\n                    parentheses_word_count += 1\n            word = \"\"\n    if word and word not in [\"(\", \")\", \"_\"]:\n        word = word.replace(\"_\", \" \")\n        word_length = len(word)\n        if word_length > 0:\n            parentheses_word_count += 1\n\n    if parentheses_word_count == 0:\n        parentheses_word_count = \"0\"\n\n    return f\"{longest_word_length} {parentheses_word_count}\"\n"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    words_inside = 0\n    words_outside = 0\n    word_start = 0\n    for i in range(len(s)):\n        if s[i] == \"_\":\n            if i > 0 and s[i-1] != \"_\":\n                word_start = i+1\n            if i < n-1 and s[i+1] != \"_\":\n                words_outside += 1\n        elif s[i] == \"(\":\n            words_inside += 1\n        elif s[i] == \")\":\n            words_inside -= 1\n    if words_outside == 0:\n        words_outside = 0\n    return str(words_outside) + \" \" + str(words_inside)\n\n\ndef"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, string = stdin.strip().split('\\n')\n    n = int(n)\n    words = string.split('_')\n    outside_length = 0\n    inside_length = 0\n    outside_words = 0\n    inside_words = 0\n\n    for i, word in enumerate(words):\n        if word:\n            if i == 0 or words[i - 1] == '':\n                if not ('(' in word or ')' in word):\n                    outside_length = max(outside_length, len(word))\n                    outside_words += 1\n            else:\n                if not ('(' in word or ')' in word):\n                    inside_length = max(inside_length, len(word))\n                    inside_words += 1\n\n    return f\"{outside_length} {inside_length}\"\n\n\ninput_data = \"\"\"\n37\n_Hello_Vasya(and_Petya)__bye_(and_OK)\n\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data)\n\n\ninput_data = \"\"\"\n37\n_a_(_b___c)__de_f(g_)__h__i(j_k_l)m__\n\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data)\n\n\ninput_data = \"\"\"\n27\n(LoooonG)__shOrt__(LoooonG)\n\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data)\n\n\ninput_data = \"\"\"\n5\n(___)\n\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data)\n\n\ninput_data = \"\"\"\n27\n_a_(_b___c)__de_f(g_)__h__i(j_k_l)m__\n\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    s = input_lines[1]\n\n    outside_length = 0\n    inside_length = 0\n\n    words = s.split('_')\n\n    for word in words:\n        if word:\n            if not (word.startswith('(') and word.endswith(')')):\n                outside_length = max(outside_length, len(word))\n\n            if word.startswith('(') and word.endswith(')'):\n                inside_length += len(word) - 2\n\n    print(outside_length, inside_length)"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, input().split())\n    n = int(n)\n    s = s.replace('(', ' ( ').replace(')', ' ) ')\n    words = s.split()\n    words = [w for w in words if w not in '()']\n\n    longest_word_outside = max(words, key=len, default=0)\n    words_inside = sum(1 for w in words if w.startswith('_'))\n\n    return f\"{len(longest_word_outside)} {words_inside}\""
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    def is_word(c: str) -> bool:\n        return c.isalpha() or c == '_'\n\n    def get_words(s: str) -> List[str]:\n        words = []\n        start = -1\n        for i in range(len(s)):\n            if is_word(s[i]):\n                if start == -1:\n                    start = i\n            elif start != -1:\n                words.append(s[start:i])\n                start = -1\n        if start != -1:\n            words.append(s[start:])\n        return words\n\n    words_outside = get_words(s.replace('(', '__').replace(')', '__'))\n    words_inside = get_words(s.replace('_', '').replace('(', '__').replace(')', '__'))\n\n    longest_word_outside = max(words_outside, key=len, default=0)\n    count_words_inside = len(words_inside)\n\n    return f\"{len(longest_word_outside)} {count_words_inside}\"\n"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    s = lines[1]\n    \n    outside = 0\n    inside = 0\n    max_outside = 0\n    word = \"\"\n    inside_word = False\n    \n    for char in s:\n        if char == '(':\n            inside_word = True\n        elif char == ')':\n            inside_word = False\n        elif not inside_word:\n            if char == '_' or char == '(' or char == ')':\n                if word:\n                    max_outside = max(max_outside, len(word))\n                    word = \"\"\n            else:\n                word += char\n                \n    if word:\n        max_outside = max(max_outside, len(word))\n        \n    for i in range(len(s)):\n        if s[i] == '(':\n            inside_word = True\n            start = i + 1\n        elif s[i] == ')':\n            inside_word = False\n            if inside_word:\n                inside += 1\n            end = i - 1\n            if end - start + 1 > 0:\n                inside += 1\n        elif s[i] == '_':\n            if not inside_word:\n                inside += 1\n    \n    return f\"{max_outside} {inside}\"\n"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_string = input_list[1]\n\n    # Helper function to find words\n    def find_words(s: str, start: int, end: int) -> int:\n        count = 0\n        while start <= end and (s[start] == '_' or s[start] == '(' or s[start] == ')'):\n            if s[start] == '_' or s[start] == '(':\n                count += 1\n            start += 1\n        while start <= end and (s[end] == '_' or s[end] == ')' or s[end] == '('):\n            if s[end] == '_' or s[end] == ')':\n                count += 1\n            end -= 1\n        return count\n\n    # Helper function to find longest word outside parentheses\n    def find_longest_word(s: str) -> int:\n        longest = 0\n        for i in range(len(s)):\n            if s[i] == '_' or s[i] == '(' or s[i] == ')':\n                continue\n            start = i\n            end = i\n            while end + 1 < len(s) and (s[end + 1] != '_' and s[end + 1] != '(' and s[end + 1] != ')'):\n                end += 1\n            if end + 1 == len(s):\n                break\n            word_len = end - start + 1\n            if word_len > longest:\n                longest = word_len\n        return longest\n\n    longest_word = find_longest_word(input_string)\n    inside_count = find_words(input_string, 0, len(input_string) - 1)\n\n    return f\"{longest_word} {inside_count}\"\n\ninput_string = '''_Hello_Vasya(and_Petya)__bye_(and_OK)'''\nprint(solution(input_string))\n"
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_word_outside_parentheses(s: str) -> int:\n        words = s.split('_')\n        longest_word_length = 0\n        for word in words:\n            if word.isalpha() and word not in ('(', ')', '(' + word + ')', ')') and len(word) > longest_word_length:\n                longest_word_length = len(word)\n        return longest_word_length\n\n    def find_words_inside_parentheses(s: str) -> int:\n        words = s.split('_')\n        count = 0\n        for word in words:\n            if word.isalpha() and word.count('(') == word.count(')'):\n                count += 1\n        return count\n\n    n = int(stdin[0])\n    s = stdin[1]\n\n    longest_word_length_outside = find_longest_word_outside_parentheses(s)\n    words_inside_parentheses = find_words_inside_parentheses(s)\n\n    return f\"{longest_word_length_outside} {words_inside_parentheses}\" "
    },
    {
        "number": 584,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input string\n    n = int(stdin[0])\n    input_string = stdin[1]\n\n    # Initialize variables\n    longest_word_outside = 0\n    words_inside_parentheses = 0\n    current_word = \"\"\n    inside_parentheses = False\n\n    # Iterate through the input string\n    for char in input_string:\n        # Handle opening and closing parentheses\n        if char == \"(\":\n            inside_parentheses = True\n        elif char == \")\":\n            inside_parentheses = False\n\n        # Handle underscores and letters\n        elif char == \"_\":\n            if current_word:\n                if not inside_parentheses:\n                    longest_word_outside = max(longest_word_outside, len(current_word))\n                else:\n                    words_inside_parentheses += 1\n                current_word = \"\"\n        else:\n            current_word += char\n\n    # Handle the last word\n    if current_word:\n        if not inside_parentheses:\n            longest_word_outside = max(longest_word_outside, len(current_word))\n        else:\n            words_inside_parentheses += 1\n\n    # Print the results\n    print(longest_word_outside, words_inside_parentheses)"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[1:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n\n    b.sort()\n\n    total = 1\n    count = 0\n\n    for i in range(m):\n        min_value = b[i]\n        min_index = -1\n\n        for j in range(i, n, m):\n            if a[j] >= min_value:\n                min_index = j\n                break\n\n        if min_index == -1:\n            break\n\n        total *= count\n        total %= 998244353\n\n        count += 1\n        a[min_index], a[min_index + m] = a[min_index + m], a[min_index]\n\n    return str(total)\n\n\nn = int(input())\nm = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solution(str(n) + \" \" + str(m) + \" \" + \" \".join(map(str, a)) + \" \" + \" \".join(map(str, b)))) "
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    def divide_array(i, j):\n        if i == j:\n            return 1\n        if j - i + 1 == len(b):\n            return 1 if a[i] == b[j] else 0\n\n        count = 0\n        for k in range(i, j + 1):\n            if a[k] >= b[j]:\n                count += divide_array(k, j)\n                count %= 998244353\n        return count\n\n    result = divide_array(0, m - 1)\n    return str(result)\n\n\nn = int(input())\nm = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solution(str(n) + \"\\n\" + \" \".join(map(str, a)) + \"\\n\" + \" \".join(map(str, b))))\n"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    def count_ways(arr, b, m):\n        count = 0\n        left, right = 0, m\n        while right < len(arr):\n            if arr[right] >= b[left]:\n                count += (right - left)\n                left, right = left + 1, right + 1\n            else:\n                right += 1\n        return count % 998244353\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 + n]))\n    b = list(map(int, stdin.split()[2 + n:2 + n + m]))\n\n    if m == 1:\n        return 1\n\n    b.sort()\n\n    count = 0\n    for i in range(len(a) + 1):\n        if binary_search(b, a[i - 1] if i > 0 else float('-inf')):\n            count += count_ways(a[i:], b, m)\n\n    return count % 998244353\n"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def mod_pow(base: int, exponent: int, mod: int) -> int:\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exponent //= 2\n        return result\n\n    def count_ways(a: list, b: list) -> int:\n        n, m = len(a), len(b)\n        count = [1] * m\n\n        for i in range(n):\n            index = bisect.bisect_left(b, a[i])\n            count[index] += 1\n\n        result = 0\n        for i in range(m):\n            if i == 0:\n                result = (result + count[i] * mod_pow(2, count[i] - 1, 998244353)) % 998244353\n            else:\n                result = (result + count[i] * mod_pow(2, count[i] - 1, 998244353) * gcd(2 ** count[i - 1], 998244353)) % 998244353\n\n        return result\n\n    def read_input(stdin: str) -> tuple[list[int], list[int]]:\n        n, m = map(int, stdin.split()[:2])\n        a = list(map(int, stdin.split()[2:2 + n]))\n        b = list(map(int, stdin.split()[2 + n:]))\n        return a, b\n\n    a, b = read_input(stdin)\n    a.sort()\n    b.sort()\n    result = count_ways(a, b)\n    return str(result)\n"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def binomial_coefficient(n: int, k: int) -> int:\n        if k < 0 or k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    n, m = map(int, stdin.split()[:2])\n    a = sorted(map(int, stdin.split()[2:2 + n]))\n    b = sorted(map(int, stdin.split()[2 + n:]))\n\n    ways = binomial_coefficient(n, m)\n    for i in range(m):\n        ways = ways * (a[m - 1] - b[i] + 1) % 998244353\n        ways = ways * (a[m - 1] - b[i] + 1) % 998244353\n\n    return str(ways % 998244353)\n\n\ninput_file = open(\"input.txt\", \"r\")\nstdin = input_file.read()\noutput = solution(stdin)\nprint(output) "
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    modulo = 998244353\n    dp = [0] * (m + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        temp = dp[0]\n        for j in range(1, m + 1):\n            if b[j - 1] <= a[i - 1]:\n                dp[j] = (dp[j] + temp) % modulo\n            temp = dp[j]\n\n    return dp[m]\n\n\nstdin = \"\"\"6 3\n12 10 20 20 25 30\n10 20 30\"\"\"\nprint(solution(stdin))  # Output: 2\n\nstdin = \"\"\"4 2\n1 3 3 7\n3 7\"\"\"\nprint(solution(stdin))  # Output: 0\n\nstdin = \"\"\"8 2\n1 2 2 2 2 2 2 2\n1 2\"\"\"\nprint(solution(stdin))  # Output: 7 "
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target, low, high):\n        if high >= low:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] > target:\n                return binary_search(arr, target, low, mid - 1)\n            else:\n                return binary_search(arr, target, mid + 1, high)\n        else:\n            return -1\n\n    def count_ways(a, b):\n        ways = 1\n        i, j = 0, 0\n        n, m = len(a), len(b)\n\n        while j < m and i < n:\n            if a[i] <= b[j]:\n                i += 1\n            j += 1\n\n        if j == m:\n            ways *= pow(2, n - i, 998244353)\n\n        return ways\n\n    def main():\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n\n        b.sort()\n        a.sort()\n\n        ways = count_ways(a, b)\n        return ways % 998244353\n\n    return str(main())\n"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    b = list(map(int, input_lines[2].split()))\n\n    mod = 998244353\n\n    def count_ways(a, b, m):\n        if m == 1:\n            return 1\n        count = 0\n        for i in range(len(a) - m + 1):\n            if a[i] == b[0]:\n                count += count_ways(a[i + 1:], b[1:], m - 1)\n                count %= mod\n        return count\n\n    result = count_ways(a, b, m)\n\n    return str(result)\n\n\nstdin = \"\"\"6 3\n12 10 20 20 25 30\n10 20 30\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4 2\n1 3 3 7\n3 7\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"8 2\n1 2 2 2 2 2 2 2\n1 2\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(a, b, m):\n        n = len(a)\n        mod = 998244353\n\n        # Initialize dp[i][j] as the number of ways to divide the first i elements of a into j consecutive subarrays\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n        # There is only one way to divide an empty array\n        for j in range(1, m + 1):\n            dp[0][j] = 1\n\n        # Fill the dp table\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if a[i - 1] >= b[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j - 1]\n                dp[i][j] %= mod\n\n        # Return the number of ways to divide the whole array\n        return dp[n][m]\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    # Calculate and print the result\n    result = count_ways(a, b, m)\n    return str(result)\n"
    },
    {
        "number": 585,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    def count_ways(a, b):\n        if len(a) < m:\n            return 0\n\n        ways = [0] * m\n        ways[0] = 1\n\n        for i in range(m):\n            if b[i] > a[0]:\n                return 0\n\n            for j in range(i):\n                if b[i] <= a[j + 1]:\n                    ways[i] += ways[j]\n                    ways[i] %= 998244353\n\n            for j in range(i, len(a)):\n                if a[j] >= b[i]:\n                    ways[i] += ways[i - 1] if i > 0 else 1\n                    ways[i] %= 998244353\n\n        return ways[-1]\n\n    return str(count_ways(a, b))\n\n\ninput_str = '''6 3\n12 10 20 20 25 30\n10 20 30\n\n4 2\n1 3 3 7\n3 7\n\n8 2\n1 2 2 2 2 2 2 2\n1 2\n'''\n\nprint(solution(input_str)) "
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    \n    # Base cases\n    if n == 1:\n        return \"0\"\n    if n == 2 and k >= 3:\n        return \"6\"\n    \n    # C(n, 1) = C(n, n-1) = 1\n    # C(n, 2) = C(n, n-2) = n\n    # C(n, 3) = C(n, n-3) = n * (n-2) / 2\n    # ...\n    # C(n, n-1) = C(n, 1) = 1\n    # C(n, n) = C(n, 0) = 1\n    # C(n+1, 1) = C(n+1, n) = n+1\n    # C(n+1, 2) = C(n+1, n-1) = n+1\n    # ...\n    # C(n+1, n) = C(n+1, 1) = n+1\n    # C(n+1, n+1) = C(n+1, 0) = 1\n    \n    # C(n, k) = C(n-1, k) + C(n-1, k-1) * n\n    # C(n+1, k) = C(n, k) + C(n, k-1) * n\n    \n    # There are n+1 possible values for the first row (including all black and all white)\n    # There are n possible values for the second row (excluding all black and all white)\n    # There are n+1 possible values for the third row (including all black and all white)\n    # ...\n    # There are n possible values for the n-1th row (excluding all black and all white)\n    # There are n+1 possible values for the nth row (including all black and all white)\n    # The total number of possible colorings is the sum of all the above numbers\n    # We can simplify the above numbers by using the identity:\n    # C(n, k) = C(n-1, k) + C(n-1, k-1) * n\n    # We can then use dynamic programming to compute the answer\n    \n    # Initialize the dp array\n    dp = [[0] * (n+1) for _ in range(k+1)]\n    \n    # Base case: C(0, 0) = C(0, n) = C(n, 0) = C(n, k) = 1\n    for i in range(k+1):\n        dp[0][i] = 1\n    for i in range(n+1):\n        dp[i][0] = 1\n    dp[n][k] = 1\n    \n    # Fill the dp array using the recurrence relation\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j] + dp[i-1][j-1] * n\n            dp[i][j] %= mod\n    \n    # The answer is the sum of all the dp[i][j] values\n    return str(sum(dp[i][j] for i in range(n+1) for j in range(k+1)))\n"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    def count(n, k, m):\n        if n == 1:\n            return 0\n        if n == 2:\n            return (k == 1) + 4 * (k == 2)\n        if k >= n:\n            return (2 * n + 1) * pow(2, n - 1, m)\n        return (2 * n + 1) * pow(2, n - 1, m) - count(n - 1, k, m) - count(n - 1, k - 1, m)\n    \n    result = count(n, k, 998244353)\n    return str(result)\n"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, k = input_values\n\n    # Initialize the count of suitable colorings\n    count = 0\n\n    # Check if the number of tiles in a rectangle is valid\n    if k > n * n:\n        return str(count)\n\n    # Check if the board has at least one white tile\n    if n > 1:\n        count += 2\n\n    # Check if the board has at least one black tile\n    if n > 2:\n        count += 2\n\n    # Check the remaining tiles\n    for i in range(2, n):\n        for j in range(2, n):\n            if i == j:\n                count += 1\n            else:\n                count += 2\n\n    # Compute the answer modulo 998244353\n    count = count % 998244353\n\n    return str(count)"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    count = 1\n    \n    if n == 1:\n        return count % mod\n    \n    for i in range(n):\n        count *= 2\n        count %= mod\n    \n    if k == 1:\n        return count % mod\n    \n    count *= (n - 1)\n    count %= mod\n    \n    if k == n:\n        return count % mod\n    \n    count *= n\n    count %= mod\n    \n    if k == n + 1:\n        return count % mod\n    \n    count *= (n - 1)\n    count %= mod\n    \n    for i in range(2, n + 1):\n        count *= (2 * n - i) // i\n        count %= mod\n    \n    if k == 2 * n:\n        return count % mod\n    \n    return 0\n\nn, k = map(int, input().split())\nprint(solution(input())) "
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    modulo = 998244353\n\n    if n == 1:\n        return str((k == 1) + (k == n) % modulo)\n\n    def is_rectangle_of_single_color(x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if (i == x1 or i == x2) ^ (j == y1 or j == y2):\n                    return True\n        return False\n\n    def color_board(board):\n        n = len(board)\n        result = 0\n        for x1 in range(n):\n            for y1 in range(n):\n                for x2 in range(x1, n):\n                    for y2 in range(y1, n):\n                        if not (is_rectangle_of_single_color(x1, y1, x2, y2) or is_rectangle_of_single_color(y1, x1, y2, x2)):\n                            result += 1\n        return result\n\n    def count_suitable_colorings(board):\n        n = len(board)\n        result = 0\n        for board[0][0] in [0, 1]:\n            for i in range(1, n):\n                board[i][0] = board[i - 1][0] ^ board[i - 1][1]\n            for j in range(1, n):\n                board[n - 1][j] = board[n - 1][j - 1] ^ board[n - 2][j - 1]\n            for i in range(1, n):\n                for j in range(1, n):\n                    board[i][j] = board[i - 1][j] ^ board[i - 1][j - 1] ^ board[i - 1][j + 1] ^ board[i][j - 1] ^ board[i][j + 1]\n            result += color_board(board)\n        return result % modulo\n\n    board = [[0] * n for _ in range(n)]\n    return str(count_suitable_colorings(board))\n"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    \n    def count_suitable_colorings(n: int, k: int) -> int:\n        if n == 1:\n            return 1\n        \n        white_black = (2 * (n - 1) + 2) * (n - 1) // 2\n        beautiful = count_suitable_colorings(n - 1, k) * white_black\n        beautiful += count_suitable_colorings(n - 1, k - 1) * (n - 2) * (n - 1) // 2\n        beautiful += count_suitable_colorings(n - 1, k - 2) * (n - 2) * (n - 2) // 2\n        \n        return beautiful % mod\n    \n    return str(count_suitable_colorings(n, k))\n"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    dp = [[0] * n for _ in range(n)]\n\n    if k > n:\n        return 0\n\n    if n == 1:\n        return 0 if k > 1 else 1\n\n    if k == 1:\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = 1\n        return sum(sum(dp[i]) % mod for i in range(n)) % mod\n\n    if k >= n:\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = 2\n        return sum(sum(dp[i]) % mod for i in range(n)) % mod\n\n    def is_valid(board):\n        for i in range(n):\n            row = set()\n            col = set()\n            for j in range(n):\n                if board[i][j] == 0:\n                    return False\n                if board[i][j] == 1:\n                    row.add(j)\n                    col.add(i)\n                else:\n                    row.clear()\n                    col.clear()\n            if len(row) > 0 and len(col) > 0:\n                return False\n        return True\n\n    def dfs(board, i, j, color):\n        if i >= n or j >= n or board[i][j] == -1:\n            return 0\n        if board[i][j] == 0:\n            return dfs(board, i + 1, j, 1 - color) + dfs(board, i - 1, j, 1 - color) + dfs(board, i, j + 1, 1 - color) + dfs(board, i, j - 1, 1 - color)\n        if board[i][j] == color:\n            return dfs(board, i + 1, j, color) + dfs(board, i - 1, j, color) + dfs(board, i, j + 1, color) + dfs(board, i, j - 1, color)\n        if k >= n:\n            return dfs(board, i + 1, j, color) + dfs(board, i - 1, j, color) + dfs(board, i, j + 1, color) + dfs(board, i, j - 1, color)\n        return 0\n\n    for i in range(n):\n        for j in range(n):\n            board = [[-1] * n for _ in range(n)]\n            board[i][j] = 0\n            if is_valid(board):\n                count = dfs(board, 0, 0, 0) % mod\n                dp[i][j] = count\n\n    return sum(dp[i][j] for i in range(n) for j in range(n)) % mod\n\n\ndef"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, k = input_data[0], input_data[1]\n\n    def count_colorings(n, k):\n        if n == 1:\n            return 1\n        if k == 1:\n            return 1\n\n        mod = 998244353\n        count = 0\n\n        for i in range(2):\n            for j in range(2):\n                for m in range(1, n + 1):\n                    for p in range(1, n + 1):\n                        count += count_colorings(m, k - 1) * count_colorings(n - m, k - 1) * (1 - i) * (1 - j)\n                        count %= mod\n        return count\n\n    result = count_colorings(n, k)\n    return str(result)\n\n\ninput_data = '''49 1808'''\nprint(solution(input_data))\n"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # Count the number of suitable colorings for n x n board\n    count = 0\n    for i in range(2**n):\n        # Convert the binary number i to its decimal equivalent\n        decimal = 0\n        power = 1\n        while i > 0:\n            decimal += power * (i % 2)\n            power *= 2\n            i //= 2\n        # Check if the binary number decimal is a suitable coloring\n        suitable = True\n        for i in range(n):\n            row = []\n            for j in range(n):\n                if (decimal & (1 << (i*n + j))) > 0:\n                    row.append(1)\n                else:\n                    row.append(0)\n            # Check if there is a rectangle of the single color consisting of at least k tiles\n            if row.count(1) >= k:\n                suitable = False\n                break\n            # Check if the row is beautiful\n            for j in range(n-1):\n                if row[j] != row[j+1]:\n                    suitable = False\n                    break\n        if suitable:\n            count += 1\n    \n    # Print the result modulo 998244353\n    return str(count % 998244353)"
    },
    {
        "number": 586,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    mod = 998244353\n    count = 0\n    \n    # Beautiful colorings where no rectangle of a single color, consisting of at least k tiles\n    for first_row in range(2):\n        for second_row in range(2):\n            for first_col in range(2):\n                for second_col in range(2):\n                    color_count = 0\n                    color_count += (first_row == second_row)\n                    color_count += (first_col == second_col)\n                    if color_count >= k:\n                        continue\n                    count += 1\n                    \n    # Beautiful colorings where no rectangle of a single color, consisting of at least k tiles\n    for first_row in range(2):\n        for second_row in range(2):\n            for first_col in range(2):\n                for second_col in range(2):\n                    color_count = 0\n                    color_count += (first_row == second_row)\n                    color_count += (first_col == second_col)\n                    if color_count >= k:\n                        continue\n                    count += 1\n    \n    count = count % mod\n    return str(count)\n\nn = 2\nk = 3\nprint(solution(f\"{n} {k}\"))  # Output: 6\n\nn = 49\nk = 1808\nprint(solution(f\"{n} {k}\"))  # Output: 359087121 "
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    toppings = [tuple(map(int, input().split())) for _ in range(N)]\n    toppings.sort(key=lambda x: (-x[1], x[0]))\n    chosen_toppings = toppings[:K]\n    unique_toppings = set(t for _, t in chosen_toppings)\n    total_deliciousness = sum(d for _, d in chosen_toppings)\n    variety_bonus = len(unique_toppings) ** 2\n    satisfaction = total_deliciousness + variety_bonus\n    return satisfaction\n\n\ndef"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    toppings = []\n    \n    for _ in range(N):\n        t, d = map(int, input().split())\n        toppings.append((t, d))\n    \n    toppings.sort(key=lambda x: x[1], reverse=True)\n    \n    base_total_deliciousness = 0\n    unique_toppings = set()\n    \n    for i in range(K):\n        t, d = toppings[i]\n        base_total_deliciousness += d\n        unique_toppings.add(t)\n    \n    variety_bonus = len(unique_toppings) ** 2\n    satisfaction = base_total_deliciousness + variety_bonus\n    \n    return str(satisfaction)\n\ndef"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    sushi = []\n    \n    for i in range(N):\n        t_i, d_i = map(int, stdin.split()[2*i+2:2*i+4])\n        sushi.append((t_i, d_i))\n    \n    sushi.sort(key=lambda x: x[1], reverse=True)\n    \n    satisfied_sushi = sushi[:K]\n    \n    base_total_deliciousness = sum([sushi[0][1] for sushi in satisfied_sushi])\n    variety_bonus = len(set([sushi[0][0] for sushi in satisfied_sushi])) ** 2\n    \n    satisfaction = base_total_deliciousness + variety_bonus\n    \n    return satisfaction\n\n\ndef"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    toppings = []\n    for _ in range(N):\n        t, d = map(int, input().split())\n        toppings.append((t, d))\n    toppings.sort(key=lambda x: (-x[1], x[0]))\n    toppings = toppings[:K]\n    deliciousness = sum(t[1] for t in toppings)\n    variety_bonus = len(set(t[0] for t in toppings)) ** 2\n    satisfaction = deliciousness + variety_bonus\n    return satisfaction\n"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_satisfaction(deliciousness, toppings):\n        base_total_deliciousness = sum(deliciousness)\n        variety_bonus = len(toppings) * len(toppings)\n        return base_total_deliciousness + variety_bonus\n\n    def read_input(stdin: str) -> tuple:\n        N, K = map(int, stdin.split()[:2])\n        toppings = []\n        deliciousness = []\n        for i in range(N):\n            t, d = map(int, stdin.split()[2 * i: 2 * (i + 1)])\n            toppings.append(t)\n            deliciousness.append(d)\n        return N, K, toppings, deliciousness\n\n    N, K, toppings, deliciousness = read_input(stdin)\n    selected_sushi = [i for i in range(N) if toppings[i] in set(toppings[:K])]\n    max_satisfaction = calculate_satisfaction(deliciousness, toppings[:K])\n\n    for i in range(K, N):\n        selected_sushi.append(i)\n        current_satisfaction = calculate_satisfaction(deliciousness, toppings[:K + 1])\n        max_satisfaction = max(max_satisfaction, current_satisfaction)\n\n    return max_satisfaction\n"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    toppings = [list(map(int, input().split())) for _ in range(N)]\n    toppings.sort(key=lambda x: x[1], reverse=True)  # Sort by deliciousness in descending order\n    d_sum = sum([topping[1] for topping in toppings[:K]])\n    distinct_kinds = len(set(topping[0] for topping in toppings[:K]))\n    variety_bonus = distinct_kinds * distinct_kinds\n    satisfaction = d_sum + variety_bonus\n    return satisfaction\n"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    sushi_info = [list(map(int, line.split())) for line in input_list[1:]]\n\n    def deliciousness(sushi):\n        return sushi[1]\n\n    def variety(sushi):\n        return sushi[0]\n\n    def satisfaction(sushi_list):\n        total_deliciousness = sum(deliciousness(sushi) for sushi in sushi_list)\n        variety_bonus = len(set(variety(sushi) for sushi in sushi_list)) ** 2\n        return total_deliciousness + variety_bonus\n\n    sushi_list = sorted(sushi_info, key=deliciousness, reverse=True)\n    max_satisfaction = satisfaction(sushi_list[:K])\n\n    return str(max_satisfaction)\n"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    toppings = stdin.split()[2:]\n    toppings = [list(map(int, topping.split())) for topping in toppings]\n\n    max_satisfaction = 0\n    for comb in combinations(toppings, K):\n        topping_kinds = set()\n        total_deliciousness = 0\n        for piece in comb:\n            total_deliciousness += piece[1]\n            topping_kinds.add(piece[0])\n        variety_bonus = len(topping_kinds) ** 2\n        satisfaction = total_deliciousness + variety_bonus\n        max_satisfaction = max(max_satisfaction, satisfaction)\n\n    return str(max_satisfaction)\n"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    toppings = [tuple(map(int, stdin.split()[2*i:2*i+2])) for i in range(N)]\n    toppings.sort(key=lambda x: x[1], reverse=True)\n    topping_types = set(topping[0] for topping in toppings[:K])\n    base_total_deliciousness = sum(topping[1] for topping in toppings[:K])\n    variety_bonus = len(topping_types) * len(topping_types)\n    satisfaction = base_total_deliciousness + variety_bonus\n    return satisfaction\n\n\ndef"
    },
    {
        "number": 587,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    toppings = []\n    for i in range(N):\n        t_i, d_i = map(int, stdin.split())\n        toppings.append((t_i, d_i))\n    toppings.sort(key=lambda x: (-x[1], x[0]))  # Sort by decreasing deliciousness and increasing topping\n    max_satisfaction = 0\n    unique_toppings = set()\n    for i in range(K):\n        t_i, d_i = toppings[i]\n        max_satisfaction += d_i\n        unique_toppings.add(t_i)\n    variety_bonus = len(unique_toppings) ** 2\n    max_satisfaction += variety_bonus\n    return max_satisfaction\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    x = [int(i) for i in stdin[1].split()]\n    y = [int(i) for i in stdin[2].split()]\n\n    max_distance = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                for k in range(N):\n                    if k != i and k != j:\n                        dx = x[i] + x[j] + x[k]\n                        dy = y[i] + y[j] + y[k]\n                        distance = ((dx ** 2) + (dy ** 2)) ** 0.5\n                        if distance > max_distance:\n                            max_distance = distance\n\n    return f\"{max_distance:.10f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin)\n    x_i = []\n    y_i = []\n    for _ in range(N):\n        x, y = map(int, stdin.split())\n        x_i.append(x)\n        y_i.append(y)\n\n    # Find the maximum possible final distance\n    max_distance = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                x_sum = x_i[i] + x_i[j] + x_i[k]\n                y_sum = y_i[i] + y_i[j] + y_i[k]\n                distance = math.sqrt(x_sum**2 + y_sum**2)\n                max_distance = max(max_distance, distance)\n\n    # Print the maximum possible final distance\n    return f\"{max_distance:.10f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    engines = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    def get_distance(x, y):\n        return (x ** 2 + y ** 2) ** 0.5\n\n    max_distance = 0\n    for engines_to_use in itertools.permutations(range(N)):\n        x, y = 0, 0\n        for i in engines_to_use:\n            x_i, y_i = engines[i]\n            x += x_i\n            y += y_i\n        max_distance = max(max_distance, get_distance(x, y))\n\n    return f\"{max_distance:.{10}f}\""
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    engines = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    max_distance = 0\n\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            for k in range(j + 1, N + 1):\n                x = engines[i - 1][0] + engines[j - 1][0] + engines[k - 1][0]\n                y = engines[i - 1][1] + engines[j - 1][1] + engines[k - 1][1]\n                distance = (x ** 2 + y ** 2) ** 0.5\n                max_distance = max(max_distance, distance)\n\n    return f\"{max_distance:.10f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    engines = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        engines.append((x, y))\n\n    max_distance = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                for k in range(N):\n                    if k != i and k != j:\n                        x = engines[i][0] + engines[j][0] + engines[k][0]\n                        y = engines[i][1] + engines[j][1] + engines[k][1]\n                        distance = (x**2 + y**2)**0.5\n                        if distance > max_distance:\n                            max_distance = distance\n\n    return f\"{max_distance:.10f}\"\n\n\ndef"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N = int(input_list[0])\n    x_list = []\n    y_list = []\n    for i in range(1, N + 1):\n        x, y = input_list[i * 2 - 2:i * 2]\n        x_list.append(int(x))\n        y_list.append(int(y))\n\n    max_distance = 0\n    for i in range(2**N):\n        x = y = 0\n        for j in range(N):\n            if i & (1 << j):\n                x += x_list[j]\n                y += y_list[j]\n        distance = x**2 + y**2\n        max_distance = max(max_distance, distance)\n\n    return f\"{max_distance:.10f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def max_distance(x_i, y_i):\n        max_dist = 0\n        for i in range(len(x_i)):\n            for j in range(len(x_i)):\n                if i != j:\n                    dist = euclidean_distance(0, 0, x_i[i] + x_i[j], y_i[i] + y_i[j])\n                    max_dist = max(max_dist, dist)\n        return max_dist\n\n    N, *data = stdin.split()\n    N = int(N)\n    x_i = []\n    y_i = []\n    for _ in range(N):\n        x, y = data.pop(0), data.pop(0)\n        x_i.append(int(x))\n        y_i.append(int(y))\n\n    distance = max_distance(x_i, y_i)\n    return f\"{distance:.{10}f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    x_i = []\n    y_i = []\n    for i in range(1, N + 1):\n        x_i.append(int(input_list[i].split()[0]))\n        y_i.append(int(input_list[i].split()[1]))\n    \n    max_dist = 0\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if i != j and i != k and j != k:\n                    x = x_i[i] + x_i[j] + x_i[k]\n                    y = y_i[i] + y_i[j] + y_i[k]\n                    dist = (x*x + y*y) ** 0.5\n                    max_dist = max(max_dist, dist)\n    \n    return f\"{max_dist:.0f}\"\n\n\ndef"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.split()[0])\n    engines = [[int(x) for x in stdin.split()[1:]] for _ in range(n)]\n\n    # Calculate maximum possible distance\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and j != k and k != i:\n                    dist = (engines[i][0] + engines[j][0] + engines[k][0], engines[i][1] + engines[j][1] + engines[k][1])\n                    max_dist = max(max_dist, dist)\n    max_dist = max_dist[0] ** 2 + max_dist[1] ** 2\n\n    # Print result\n    return f\"{max_dist:.10f}\"\n"
    },
    {
        "number": 588,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x: int, y: int) -> float:\n        return math.sqrt(x**2 + y**2)\n\n    def max_distance(x: int, y: int, x_i: int, y_i: int) -> float:\n        return max(distance(x + x_i, y + y_i), distance(x, y), distance(x + x_i, y))\n\n    N, *data = stdin.split()\n    N = int(N)\n    data = list(map(int, data))\n\n    engines = [data[i:i + 2] for i in range(0, len(data), 2)]\n\n    max_dist = 0\n    for engine in engines:\n        x_i, y_i = engine\n        for x, y in [(0, 0)]:\n            dist = max_distance(x, y, x_i, y_i)\n            max_dist = max(max_dist, dist)\n\n    return f\"{max_dist:.{10}f}\""
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(safe, hint):\n        for i, digit in enumerate(hint):\n            if digit == \"?\":\n                continue\n            if digit.isdigit():\n                if safe[i] != digit:\n                    return False\n            else:\n                if safe[i] == digit:\n                    return False\n        return True\n\n    def generate_codes(hint, safe_code):\n        if not hint:\n            return [safe_code]\n\n        codes = []\n        if hint[0] == \"?\":\n            for digit in range(10):\n                codes.extend(generate_codes(hint[1:], safe_code + str(digit)))\n        else:\n            if hint[0].isdigit():\n                safe_code += hint[0]\n            else:\n                safe_code += str(ord(hint[0]) - ord('A') + 1)\n            codes.extend(generate_codes(hint[1:], safe_code))\n\n        return codes\n\n    hint = stdin\n    safe_code = \"\"\n    safe_codes = generate_codes(hint, safe_code)\n    count = len(safe_codes)\n    return count\n"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_code(code: str, hint: str) -> bool:\n        for i, digit in enumerate(hint):\n            if digit == \"?\":\n                continue\n            if digit.isdigit():\n                if code[i] != digit:\n                    return False\n            elif digit.isalpha() and digit.isupper():\n                if code[i] != digit:\n                    return False\n            elif digit.isalpha() and digit.islower():\n                if code[i] != digit.upper():\n                    return False\n        return True\n\n    def count_codes(s: str) -> int:\n        count = 0\n        if s[0].isalpha() and s[0].islower():\n            count += 1\n        for i in range(1, len(s)):\n            if s[i].isalpha():\n                if s[i - 1].isdigit() or s[i - 1].isalpha():\n                    count += 1\n                else:\n                    count *= 10\n            else:\n                count *= 10\n        return count\n\n    safe_codes = []\n    hint = stdin\n    hint_count = count_codes(hint)\n    for i in range(hint_count):\n        safe_code = str(i).zfill(len(hint))\n        if is_valid_code(safe_code, hint):\n            safe_codes.append(safe_code)\n    return len(safe_codes)"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(code, hint):\n        for i, digit in enumerate(hint):\n            if digit == \"?\":\n                continue\n            if digit.isdigit() and int(digit) != int(code[i]):\n                return False\n            if digit.upper() == code[i].upper():\n                continue\n            if digit.upper() in code[i].upper():\n                return False\n        return True\n\n    def count_variants(hint):\n        if hint.count(\"?\") == len(hint):\n            return 10\n        return 9 * count_variants(hint[:-1])\n\n    hint = stdin\n    safe_codes = [\"0123456789\", \"0123456789\", \"0123456789\", \"0123456789\", \"0123456789\"]\n    count = 0\n\n    for code in safe_codes:\n        if is_valid(code, hint):\n            count += 1\n\n    return count * count_variants(hint)"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_digit(char: str) -> bool:\n        return '0' <= char <= '9'\n\n    def get_digit_count(string: str, index: int) -> int:\n        count = 0\n        for i in range(index + 1):\n            if is_digit(string[i]):\n                count += 1\n        return count\n\n    def get_matching_digit(digit: int, index: int, string: str) -> int:\n        count = 0\n        for i in range(index + 1):\n            if is_digit(string[i]) and int(string[i]) == digit:\n                count += 1\n        return count\n\n    def count_codes(hint: str) -> int:\n        digit_count = get_digit_count(hint, -1)\n        if digit_count == 0:\n            return 10\n\n        result = 0\n        for digit in range(10):\n            matching_digits = get_matching_digit(digit, -1, hint)\n            if matching_digits == digit_count:\n                result += count_codes(hint[:-1])\n\n        return result\n\n    hint = stdin.strip()\n    return count_codes(hint)\n"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_variants(s: str) -> int:\n        def can_be(s: str, c: str, index: int) -> bool:\n            if s[index] == \"?\":\n                return True\n            return s[index] == c\n\n        def generate_code(s: str) -> str:\n            code = \"\"\n            for i, c in enumerate(s):\n                if c in \"0123456789\":\n                    code += c\n                elif c in \"AJ\":\n                    if code.count(c) == 0:\n                        code += c\n                    else:\n                        code += c * (code.count(c) + 1)\n                else:\n                    raise ValueError(f\"Invalid character {c}\")\n            return code\n\n        s = list(s)\n        stack = [s]\n        codes = []\n        while stack:\n            s = stack.pop()\n            code = generate_code(s)\n            if len(code) == len(s) and all(can_be(code, c, index) for index, c in enumerate(s)):\n                codes.append(code)\n            else:\n                for index, c in enumerate(s):\n                    if c != \"?\":\n                        s[index] = \"?\"\n                        stack.append(s.copy())\n                        break\n\n        return len(codes)\n\n    s = stdin.strip()\n    return count_variants(s)\n"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_digit(digit: str) -> str:\n        return str(digit) if digit.isdigit() else \"?\"\n\n    def is_digit_ok(digit: str, hint_digit: str) -> bool:\n        return digit == hint_digit or hint_digit == \"?\"\n\n    def is_digit_ok_for_position(digit: str, hint: str) -> bool:\n        hint_digit = hint[0]\n        for pos in range(len(hint)):\n            if not is_digit_ok(digit, hint[pos]):\n                return False\n        return True\n\n    def count_codes(hint: str) -> int:\n        result = 1\n        for digit in range(10):\n            if is_digit_ok_for_position(get_digit(digit), hint):\n                result *= 10\n        return result\n\n    hint = stdin\n    count = 0\n    for digit in range(10):\n        if is_digit_ok_for_position(get_digit(digit), hint):\n            count += count_codes(hint)\n            break\n\n    return str(count)\n"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(code: str) -> bool:\n        for i, (c, hint) in enumerate(zip(code, stdin)):\n            if hint == '?':\n                continue\n            elif hint.isdigit():\n                if c != hint:\n                    return False\n            else:\n                if c < hint or (c == hint and i < last_index[hint]):\n                    return False\n                last_index[hint] = i\n        return True\n\n    last_index = {chr(i): 0 for i in range(ord('A'), ord('J') + 1)}\n    count = 0\n    codes = [str(i).zfill(len(stdin)) for i in range(10 ** len(stdin))]\n\n    for code in codes:\n        if is_valid(code):\n            count += 1\n\n    return count\n"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    hint = []\n    for char in s:\n        if char.isdigit():\n            hint.append(int(char))\n        else:\n            hint.append(char)\n\n    def is_match(code: int, hint: List[Union[int, str]]) -> bool:\n        for i, char in enumerate(hint):\n            if char == \"?\":\n                continue\n            elif char == \"A\" or char == \"B\" or char == \"C\" or char == \"D\" or char == \"E\" or char == \"F\" or char == \"G\" or char == \"H\" or char == \"J\":\n                if code[i] != hint[i]:\n                    return False\n            elif code[i] != hint[i]:\n                return False\n        return True\n\n    def count_codes(hint: List[Union[int, str]]) -> int:\n        count = 0\n        for code in range(10**len(hint)):\n            code = str(code).zfill(len(hint))\n            if is_match(code, hint):\n                count += 1\n        return count\n\n    return count_codes(hint)\n\ndef"
    },
    {
        "number": 589,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_digit_at_index(index: int, hint: str) -> str:\n        if hint[index] == '?':\n            return '?'\n        else:\n            return hint[index]\n\n    def match_digit_at_index(digit: str, index: int, code: str) -> bool:\n        hint_digit = get_digit_at_index(index, hint)\n        if hint_digit == '?':\n            return True\n        else:\n            return hint_digit == digit\n\n    def is_valid_code(code: str) -> bool:\n        for index, digit in enumerate(code):\n            if not match_digit_at_index(digit, index, hint):\n                return False\n        return True\n\n    hint = stdin\n    valid_codes = 0\n\n    for digit in range(0, 10):\n        for letter1 in range(ord('A'), ord('J') + 1):\n            for letter2 in range(ord('A'), ord('J') + 1):\n                if letter1 == letter2:\n                    continue\n                for letter3 in range(ord('A'), ord('J') + 1):\n                    if letter3 in (letter1, letter2):\n                        continue\n                    code = str(digit) + chr(letter1) + chr(letter2) + chr(letter3) + str(digit)\n                    if is_valid_code(code):\n                        valid_codes += 1\n\n    return valid_codes"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    def is_permutation(arr: list) -> bool:\n        freq = [0] * n\n        for num in arr:\n            freq[num - 1] += 1\n        return all(freq[i] == 1 for i in range(n))\n\n    def lexicographic_minimal(arr: list) -> list:\n        if not is_permutation(arr):\n            raise ValueError(\"Array is not a permutation\")\n        return arr\n\n    def find_changes(arr: list) -> int:\n        freq = [0] * n\n        for num in arr:\n            freq[num - 1] += 1\n        return sum(1 for f in freq if f == 0)\n\n    q = find_changes(arr)\n    if q == 0:\n        return 0, \" \".join(map(str, arr))\n\n    freq = [0] * n\n    for num in arr:\n        freq[num - 1] += 1\n\n    perm = [i + 1 for i in range(n) if freq[i] == 0]\n    if len(perm) != n:\n        raise ValueError(\"Array is not a permutation\")\n\n    if q == 1:\n        return 1, f\"{perm[0]} {perm[1]} {perm[2]}\"\n\n    perm = lexicographic_minimal(perm)\n    return q, \" \".join(map(str, perm))\n"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if array is already a permutation\n    if len(set(a)) == len(a) and sorted(a) == list(range(1, n + 1)):\n        return 0, \" \".join(map(str, a))\n\n    # Count number of changes needed\n    count = 0\n    for i in range(1, n + 1):\n        if i not in a:\n            count += 1\n\n    # Calculate permutation\n    permutation = sorted(a) + [i for i in range(1, n + 1) if i not in a]\n\n    return count, \" \".join(map(str, permutation))\n"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def is_permutation(arr):\n        freq = [0] * (n + 1)\n        for num in arr:\n            freq[num] += 1\n        return all(freq[i] == 1 for i in range(1, n + 1))\n\n    def find_min_changes(arr, start, changes):\n        if start == n:\n            return changes\n\n        if is_permutation(arr):\n            return 0\n\n        min_changes = float('inf')\n        for i in range(start, n):\n            if is_permutation(arr[:i] + [i + 1] + arr[i + 1:]):\n                min_changes = min(min_changes, find_min_changes(arr[:i] + [i + 1] + arr[i + 1:], start + 1, changes + 1))\n            if is_permutation(arr[:i] + [i] + arr[i + 1:]):\n                min_changes = min(min_changes, find_min_changes(arr[:i] + [i] + arr[i + 1:], start + 1, changes + 1))\n\n        return min_changes\n\n    min_changes = find_min_changes(a, 0, 0)\n    if min_changes == float('inf'):\n        print(0)\n        print(a)\n        return\n\n    def min_lexicographic_permutation(arr, start, changes):\n        if start == n:\n            return changes\n\n        min_changes = float('inf')\n        min_perm = []\n        for i in range(start, n):\n            if is_permutation(arr[:i] + [i + 1] + arr[i + 1:]):\n                changes, perm = min_lexicographic_permutation(arr[:i] + [i + 1] + arr[i + 1:], start + 1, changes + 1)\n                if changes < min_changes:\n                    min_changes = changes\n                    min_perm = perm\n            if is_permutation(arr[:i] + [i] + arr[i + 1:]):\n                changes, perm = min_lexicographic_permutation(arr[:i] + [i] + arr[i + 1:], start + 1, changes + 1)\n                if changes < min_changes:\n                    min_changes = changes\n                    min_perm = perm\n\n        return min_changes, min_perm\n\n    min_changes, min_perm = min_lexicographic_permutation(a, 0, 0)\n    print(min_changes)\n    print(' '.join(map(str, min_perm)))\n\n\nstdin = \"4\\n3 2 2 3\\n6\\n4 5 6 3 2 1\\n10\\n6 8 4 6 7 1 6 3 4 5\"\nsolution(stdin) "
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(n):\n        if a[i] != i+1:\n            a.sort()\n            count = 0\n            for j in range(n):\n                if a[j] != j+1:\n                    a[j] = j+1\n                    count += 1\n                if count == n:\n                    break\n            break\n    print(count)\n    for i in range(n):\n        if a[i] != i+1:\n            a[i] = i+1\n    print(\" \".join(map(str, a)))"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    q = 0\n    \n    if sorted(a) != list(range(1, n+1)):\n        q = n - len(set(a))\n        q_changes = sorted(set(a), reverse=True)\n        a = sorted(a)\n        \n        for i in range(q):\n            a[a.index(q_changes[i])] = q_changes[i+1]\n    \n    result = \"\"\n    for i in range(1, n+1):\n        result += str(a.index(i)+1) + \" \"\n    \n    return f\"{q}\\n{result.strip()}\"\n\ndef"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lexicographically_smaller(p1: str, p2: str) -> bool:\n        for i in range(min(len(p1), len(p2))):\n            if p1[i] < p2[i]:\n                return True\n            elif p1[i] > p2[i]:\n                return False\n        return len(p1) <= len(p2)\n\n    def find_smallest_permutation(array: List[int]) -> str:\n        permutations = list(itertools.permutations(array))\n        smallest_permutation = ''.join(str(x) for x in sorted(array))\n        for p in permutations:\n            if lexicographically_smaller(str(p), smallest_permutation):\n                smallest_permutation = str(p)\n        return smallest_permutation\n\n    def count_changes_to_make_permutation(array: List[int]) -> int:\n        n = len(array)\n        frequency = [0] * n\n        for num in array:\n            frequency[num - 1] += 1\n        count = 0\n        for i in range(n):\n            if frequency[i] == 0:\n                count += 1\n                frequency[i] = 1\n        return count\n\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n    q = count_changes_to_make_permutation(array)\n    smallest_permutation = find_smallest_permutation(array)\n    print(q)\n    print(smallest_permutation)\n"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    def is_permutation(a):\n        freq = [0] * (n + 1)\n        for x in a:\n            freq[x] += 1\n        return all(x == 1 for x in freq)\n\n    def lexicographically_minimal(a):\n        a.sort()\n        for i in range(n - 1, -1, -1):\n            if a[i] != i + 1:\n                return i + 1\n        return 0\n\n    if is_permutation(a):\n        return 0, \" \".join(map(str, a))\n    else:\n        q = n - len([x for x in a if x == x])\n        a_min = a.copy()\n        a_min[lexicographically_minimal(a)] = a_min[-1]\n        a_min[-1] = n\n        return q, \" \".join(map(str, a_min))\n"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == len(set(a)):\n        return 0, \" \".join(map(str, a))\n    else:\n        counts = {}\n        for i in a:\n            counts[i] = counts.get(i, 0) + 1\n        \n        min_changes = min(counts.values())\n        q = n - len(set(a))\n        if q < min_changes:\n            min_changes = q\n        \n        min_permutation = []\n        for i in range(1, n+1):\n            if i not in a:\n                min_permutation.append(i)\n        for i in a:\n            min_permutation[i-1] = a[i-1]\n        min_permutation = [str(i) for i in min_permutation]\n        \n        return min_changes, \" \".join(min_permutation)\n\n\ndef"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    changed = False\n    i = 1\n    while i <= n:\n        if i not in arr:\n            changed = True\n            j = i\n            while j > 0 and j not in arr:\n                j -= 1\n            arr[arr.index(j)] = i\n        i += 1\n    \n    if changed:\n        q = sum(1 for i in range(n) if i not in arr)\n        min_permutation = [None] * n\n        for i in range(n):\n            if i + 1 in arr:\n                min_permutation[i] = i + 1\n        print(q)\n        print(\" \".join(map(str, min_permutation)))\n    else:\n        print(0)\n        print(\" \".join(map(str, arr)))"
    },
    {
        "number": 590,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = [int(i) for i in stdin.splitlines()[1].split()]\n\n    def is_permutation(array):\n        freq = [0] * (n + 1)\n        for num in array:\n            freq[num] += 1\n        return all(freq[i] == 1 for i in range(1, n + 1))\n\n    def lexicographically_smaller(array):\n        def compare(a, b):\n            for i in range(1, n + 1):\n                if a[i] < b[i]:\n                    return True\n                elif a[i] > b[i]:\n                    return False\n            return False\n\n        return any(compare(array, array_perm) for array_perm in permutations(array))\n\n    def make_permutation(array):\n        freq = [0] * (n + 1)\n        for num in array:\n            freq[num] += 1\n\n        sorted_freq = sorted(enumerate(freq), key=lambda x: x[1], reverse=True)\n        result = [i[0] for i in sorted_freq]\n        return result\n\n    if is_permutation(array):\n        print(0)\n        print(\" \".join(str(i) for i in array))\n    else:\n        permutation = make_permutation(array)\n        changes = 0\n        for i in range(n):\n            if array[i] != permutation[i]:\n                changes += 1\n                array[i] = permutation[i]\n\n        if lexicographically_smaller(array):\n            print(changes)\n            print(\" \".join(str(i) for i in array))\n        else:\n            array.reverse()\n            print(changes)\n            print(\" \".join(str(i) for i in array)) "
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    light = list(map(int, stdin.split()[2:]))\n    \n    min_light = float('inf')\n    min_light_hours = []\n    \n    for i in range(n - k + 1):\n        light_sum = sum(light[i:i+k])\n        if light_sum < min_light:\n            min_light = light_sum\n            min_light_hours = list(range(i+1, i+k+1))\n    \n    return f\"{min_light}\\n{' '.join(map(str, min_light_hours))}\"\n"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    light_levels = list(map(int, stdin.split()[2:]))\n\n    min_light = float('inf')\n    selected_hours = []\n\n    for hour in range(1, n + 1):\n        if light_levels[hour - 1] < min_light:\n            min_light = light_levels[hour - 1]\n            selected_hours = [hour]\n        elif light_levels[hour - 1] == min_light:\n            selected_hours.append(hour)\n\n    selected_hours.sort()\n\n    return f\"{min_light}\\n{' '.join(map(str, selected_hours[:k]))}\"\n\n\nprint(solution(input())) "
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    light_levels = list(map(int, input().split()))\n    min_light_level = float('inf')\n    selected_hours = []\n\n    for i in range(n):\n        if len(selected_hours) < k:\n            if light_levels[i] < min_light_level:\n                min_light_level = light_levels[i]\n                selected_hours = [i + 1]\n            elif light_levels[i] == min_light_level:\n                selected_hours.append(i + 1)\n\n    output = f'{min_light_level}\\n'\n    output += ' '.join(map(str, selected_hours))\n\n    return output\n"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    train_lights = list(map(int, input().split()))\n\n    min_light = float('inf')\n    reading_hours = []\n\n    for hour in range(n):\n        if hour in reading_hours:\n            continue\n\n        if len(reading_hours) == k:\n            break\n\n        min_light_in_this_hour = train_lights[hour]\n        max_light_in_selected_hours = min_light_in_this_hour\n\n        for i in range(hour + 1, n):\n            if i in reading_hours:\n                continue\n\n            min_light_in_this_hour = min(min_light_in_this_hour, train_lights[i])\n            max_light_in_selected_hours = max(max_light_in_selected_hours, train_lights[i])\n\n            if len(reading_hours) == k:\n                break\n\n        if min_light_in_this_hour < min_light:\n            min_light = min_light_in_this_hour\n            reading_hours = [hour]\n        elif min_light_in_this_hour == min_light:\n            reading_hours.append(hour)\n\n        if len(reading_hours) == k:\n            break\n\n    reading_hours.sort()\n    result = f\"{min_light}\\n{' '.join(map(str, reading_hours))}\"\n\n    return result\n\n\ninput_stdin = \"\"\"5 3\n20 10 30 40 10\"\"\"\noutput_stdout = \"\"\"20\n1 3 4\"\"\"\n\ninput_stdin = \"\"\"6 5\n90 20 35 40 60 100\"\"\"\noutput_stdout = \"\"\"35\n1 3 4 5 6\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    light_levels = list(map(int, input().split()))\n\n    # Find the minimum light level among the selected hours\n    min_light_level = min(light_levels[i-1] for i in range(k))\n\n    # Find the indexes of hours to read at\n    read_hours = [i for i in range(1, n+1) if light_levels[i-1] >= min_light_level]\n\n    # Print the minimum light level and the indexes of hours to read at\n    output = f\"{min_light_level}\\n\" + \" \".join(map(str, read_hours))\n    return output"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    min_light = float('inf')\n    opt_hours = []\n    \n    for i in range(n):\n        if i+k-1 < n:\n            total_light = sum(a[i:i+k])\n            if total_light < min_light:\n                min_light = total_light\n                opt_hours = list(range(i+1, i+k+1))\n                \n    return str(min_light) + '\\n' + ' '.join(map(str, opt_hours))\n\ninput_data = \"5 3\\n20 10 30 40 10\\n\"\nprint(solution(input_data))\n\ninput_data = \"6 5\\n90 20 35 40 60 100\\n\"\nprint(solution(input_data)) "
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    light_schedule = list(map(int, input().split()))\n    min_light = float('inf')\n    selected_hours = []\n\n    for hour in range(n):\n        light_level = light_schedule[hour]\n        if light_level > 0 and len(selected_hours) < k:\n            selected_hours.append(hour + 1)\n            if light_level < min_light:\n                min_light = light_level\n        elif len(selected_hours) == k and light_level > min_light:\n            min_light = light_level\n\n    print(min_light)\n    print(' '.join(map(str, selected_hours)))\n"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_optimal_reading_hours(light_schedule: list, k: int) -> tuple:\n        light_levels = {}\n        for i, light in enumerate(light_schedule, start=1):\n            if light not in light_levels:\n                light_levels[light] = []\n            light_levels[light].append(i)\n\n        min_light = min(light_levels.keys())\n        reading_hours = light_levels[min_light]\n        return min_light, reading_hours\n\n    n, k = map(int, stdin.split()[:2])\n    light_schedule = list(map(int, stdin.split()[2:]))\n\n    min_light, reading_hours = get_optimal_reading_hours(light_schedule, k)\n    reading_hours_str = ' '.join(map(str, reading_hours))\n    return f\"{min_light}\\n{reading_hours_str}\"\n"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    light_levels = list(map(int, stdin.split()[2:]))\n\n    min_light_level = min(light_levels)\n    selected_hours = [i + 1 for i, light_level in enumerate(light_levels) if light_level == min_light_level]\n\n    if len(selected_hours) < k:\n        selected_hours += [i + 1 for i in range(n) if i + 1 not in selected_hours]\n\n    return str(min_light_level) + '\\n' + ' '.join(map(str, selected_hours[:k]))\n\n\ndef"
    },
    {
        "number": 591,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    light_schedule = list(map(int, input_list[1].split()))\n\n    # Initialize variables\n    min_light = 101\n    reading_hours = []\n\n    # Iterate through the light schedule\n    for i, light in enumerate(light_schedule):\n        # If the light level is less than the current minimum light level\n        if light < min_light:\n            # Update the minimum light level and the reading hours\n            min_light = light\n            reading_hours = [i+1]\n        # If the light level is equal to the current minimum light level\n        elif light == min_light:\n            # Add the reading hour to the reading hours list\n            reading_hours.append(i+1)\n\n    # If the reading hours list has more than k elements, remove the last element\n    if len(reading_hours) > k:\n        reading_hours.pop()\n\n    # Print the minimum light level and the reading hours\n    result = [min_light] + reading_hours\n    return '\\n'.join(map(str, result)) "
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"0\"\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1, 2):\n        dp[i] = dp[i - 1] + 1\n    for i in range(4, n + 1, 2):\n        dp[i] = max(dp[i], dp[i - 1] + 1)\n    return str(dp[n])"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    dp = [0] * (n+1)\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + 1\n        for j in range(2, i):\n            if i % j == 0:\n                dp[i] = max(dp[i], dp[i//j] + 1)\n    return dp[n] if dp[n] > 0 else \"0\"\n"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_score = 0\n    for i in range(1, n+1):\n        visited = set()\n        q = [(i, 0)]\n        while q:\n            node, step = q.pop(0)\n            if node in visited:\n                continue\n            visited.add(node)\n            if max_score < step:\n                max_score = step\n            if node != 1 and 1 < abs(node) <= n:\n                for x in range(2, n+1):\n                    if node*x == 1:\n                        q.append((x, step+abs(x)))\n                    elif x*node == 1:\n                        q.append((x, step+abs(x)))\n            if node != -1 and -1 <= abs(node) <= n:\n                for x in range(2, n+1):\n                    if node*x == -1:\n                        q.append((-x, step+abs(x)))\n                    elif x*node == -1:\n                        q.append((-x, step+abs(x)))\n    return str(max_score)\n\n\ninput_string = \"6\"  # Change this to \"2\" for the third example\nprint(solution(input_string)) "
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    if n < 2:\n        return \"0\"\n\n    # calculate the maximum score\n    max_score = (n * (n + 1)) // 2\n\n    # check if it is possible to transform at least one integer\n    for i in range(2, n + 1):\n        if (i * (i + 1)) // 2 <= max_score:\n            return str(max_score)\n\n    return \"0\"\n"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n\n    for a in range(2, n + 1):\n        for b in range(2, n + 1):\n            if a == b:\n                continue\n\n            if abs(a) % b == 0 or b % abs(a) == 0:\n                max_score += abs(a)\n\n    return str(max_score)\n\n\ninput_str = \"6\\n\"\nprint(solution(input_str)) "
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    dp = [0] * (n + 1)\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1]\n        if i % 2 == 1:\n            dp[i] = max(dp[i], dp[i // 2])\n        if i % 3 == 0:\n            dp[i] = max(dp[i], dp[i // 3])\n    \n    return dp[n]\n"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n\n    for i in range(2, n + 1):\n        for j in range(2, n + 1):\n            if abs(i) != abs(j) and abs(i * j) <= n:\n                max_score = max(max_score, abs(i * j))\n            if abs(i) != abs(j) and abs(j * i) <= n:\n                max_score = max(max_score, abs(j * i))\n\n    return str(max_score)\n"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n    \n    for a in range(2, n + 1):\n        for b in range(2, n + 1):\n            if a == b:\n                continue\n            \n            x_a = b - a if b > a else a - b\n            x_b = b + a if b < a else a + b\n            \n            if x_a > 0 and (a * x_a == b or b * x_a == a):\n                max_score = max(max_score, abs(x_a))\n            elif x_b > 0 and (a * x_b == b or b * x_b == a):\n                max_score = max(max_score, abs(x_b))\n    \n    return max_score if max_score > 0 else \"0\"\n\n\ninput_stdin = \"6\"\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def transform(a, b, visited):\n        if a == b:\n            return visited + 1\n        if a in visited or b in visited:\n            return visited\n        visited.add(a)\n        for x in range(3, n+1):\n            if b*x == a:\n                return transform(b, a, visited)\n            elif a*x == b:\n                return transform(a, b, visited)\n        return visited\n    \n    n = int(stdin)\n    max_score = 0\n    \n    for a in range(1, n+1):\n        for b in range(1, n+1):\n            if a != b and (a < b or a > b) and abs(a - b) != n:\n                visited = set()\n                score = transform(a, b, visited)\n                max_score = max(max_score, score)\n                \n    return str(max_score)"
    },
    {
        "number": 592,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 2:\n        return \"0\"\n\n    dp = [0] * (n + 1)\n    dp[2] = 1\n\n    for i in range(3, n + 1, 2):\n        for j in range(2, i):\n            if j * j > i:\n                break\n            if j * j == i:\n                dp[i] = max(dp[i], dp[j] + 1)\n            if j * j < i:\n                if (i - j * j) % j == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n    return str(max(dp[2:]))\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    votes = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        row = list(map(int, stdin.split()[i+2:i+2+n]))\n        for j in range(n):\n            votes[i][j] = row[j]\n\n    def count_votes(votes: list) -> tuple:\n        max_votes = 0\n        max_candidate = -1\n        max_cities = 0\n        for i in range(n):\n            count = sum(votes[j][i] for j in range(m))\n            if count > max_votes or (count == max_votes and i < max_candidate):\n                max_votes = count\n                max_candidate = i\n                max_cities = 1\n            elif count == max_votes and i != max_candidate:\n                max_cities += 1\n        return max_votes, max_candidate, max_cities\n\n    winner_votes, winner_candidate, winner_cities = count_votes(votes)\n    if winner_cities == m:\n        return str(winner_candidate + 1)\n    else:\n        for i in range(n):\n            votes_copy = [votes[j][:i] + [0] + votes[j][i+1:] for j in range(m)]\n            if i == winner_candidate and count_votes(votes_copy)[2] == m:\n                return str(i + 1)\n        return str(winner_candidate + 1)\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    votes = [[0] * n for _ in range(m)]\n    for i, line in enumerate(stdin.split()[2:]):\n        for j, vote in enumerate(map(int, line.split())):\n            votes[i][j] = vote\n\n    # First stage of elections\n    winners = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if votes[j][i] > votes[winners[i]][i]:\n                winners[i] = j\n\n    # Second stage of elections\n    max_votes = 0\n    max_winners = []\n    for i in range(n):\n        if winners.count(i) > max_votes:\n            max_votes = winners.count(i)\n            max_winners = [i]\n        elif winners.count(i) == max_votes:\n            max_winners.append(i)\n\n    # Determine the winner\n    return min(max_winners)\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    votes = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        votes[i] = list(map(int, input().split()))\n\n    stage1_winners = [0] * n\n    stage2_winners = [0] * n\n\n    for city_votes in votes:\n        max_votes = max(city_votes)\n        max_winners = [i for i, vote in enumerate(city_votes) if vote == max_votes]\n        stage1_winners[max_winners[0]] += 1\n\n    max_stage1_winners = max(stage1_winners)\n    max_stage2_winners = 0\n    max_stage2_candidate = 0\n\n    for i in range(n):\n        if stage1_winners[i] > max_stage2_winners:\n            max_stage2_winners = stage1_winners[i]\n            max_stage2_candidate = i\n\n    for city_votes in votes:\n        max_votes = max(city_votes)\n        max_winners = [i for i, vote in enumerate(city_votes) if vote == max_votes]\n        if len(max_winners) > 1:\n            continue\n        stage2_winners[max_winners[0]] += 1\n\n    max_stage2_winners = max(stage2_winners)\n    max_stage2_candidate = stage2_winners.index(max_stage2_winners) + 1\n\n    return str(max_stage2_candidate)\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    votes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        row = list(map(int, input_list[i + 1].split()))\n        for j in range(n):\n            votes[i][j] = row[j]\n\n    max_votes = [0] * n\n    for i in range(n):\n        max_votes[i] = sum(votes[j][i] for j in range(m))\n\n    max_stage1 = max(max_votes)\n    max_stage2 = 0\n\n    for i in range(n):\n        if max_votes[i] == max_stage1:\n            max_stage2 += 1\n\n    return str(max_stage2)\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    votes = [[int(x) for x in stdin.split()[2+i*n:2+(i+1)*n]] for i in range(m)]\n    stage_winners = [[0 for _ in range(n)] for _ in range(m)]\n    city_winners = [0 for _ in range(n)]\n    \n    # First stage\n    for i in range(m):\n        winner_index = max(range(n), key=lambda x: votes[i][x])\n        stage_winners[i][winner_index] += 1\n    \n    # Second stage\n    for i in range(m):\n        city_winners = [max(city_winners[:j] + stage_winners[i][j:]) for j in range(n)]\n    \n    return str(city_winners.index(max(city_winners)) + 1)"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    votes = [[0] * n for _ in range(m)]\n\n    for i, line in enumerate(stdin.split('\\n')[1:]):\n        for j, value in enumerate(map(int, line.split())):\n            votes[i][j] = value\n\n    first_stage_winners = [0] * n\n    for city_votes in votes:\n        first_stage_winners[city_votes.index(max(city_votes))] += 1\n\n    max_votes = max(first_stage_winners)\n    second_stage_winners = [i + 1 for i in range(n) if first_stage_winners[i] == max_votes]\n\n    return min(second_stage_winners)"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    votes = [list(map(int, stdin.split()[2:])) for _ in range(m)]\n\n    stage1_votes = [0] * n\n    for votes_per_city in votes:\n        max_vote = max(votes_per_city)\n        stage1_votes[votes_per_city.index(max_vote)] += 1\n\n    stage1_winner_index = stage1_votes.index(max(stage1_votes)) + 1\n\n    stage2_votes = [0] * n\n    for votes_per_city in votes:\n        max_vote = max(votes_per_city)\n        if stage1_votes[votes_per_city.index(max_vote)] > 1:\n            stage2_votes[votes_per_city.index(max_vote)] += 1\n\n    if max(stage2_votes) > 1:\n        stage2_winner_index = stage2_votes.index(max(stage2_votes)) + 1\n    else:\n        stage2_winner_index = stage1_winner_index\n\n    return str(stage2_winner_index)\n"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    votes = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        row = list(map(int, stdin.split()[i*n+1:i*n+n+1]))\n        for j in range(n):\n            votes[i][j] = row[j]\n    \n    first_stage_votes = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if votes[i][j] > first_stage_votes[j]:\n                first_stage_votes[j] = votes[i][j]\n    \n    second_stage_votes = first_stage_votes.copy()\n    for i in range(m):\n        for j in range(n):\n            if votes[i][j] > second_stage_votes[j]:\n                second_stage_votes[j] = votes[i][j]\n    \n    winner = second_stage_votes.index(max(second_stage_votes)) + 1\n    \n    return str(winner)"
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    votes = [[0] * n for _ in range(m)]\n    for i in range(1, m + 1):\n        votes[i - 1] = list(map(int, input_list[i].split()))\n\n    candidates = [0] * n\n    for i in range(m):\n        for j in range(n):\n            candidates[j] += votes[i][j]\n\n    stage_winner = candidates.index(max(candidates)) + 1\n    return str(stage_winner)\n\n\ninput_str = \"\"\"3 3\n1 2 3\n2 3 1\n1 2 1\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"3 4\n10 10 3\n5 1 6\n2 2 2\n1 5 7\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 593,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    votes = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        row = list(map(int, stdin.split()[i+2:i+2+n]))\n        for j in range(n):\n            votes[i][j] = row[j]\n\n    first_stage_winners = [0] * n\n    for i in range(n):\n        max_votes = 0\n        max_j = 0\n        for j in range(m):\n            if votes[j][i] > max_votes:\n                max_votes = votes[j][i]\n                max_j = j\n        first_stage_winners[i] = max_j\n\n    second_stage_winners = [0] * n\n    for i in range(n):\n        max_votes = 0\n        max_j = 0\n        for j in range(n):\n            if votes[first_stage_winners[j]][j] > max_votes:\n                max_votes = votes[first_stage_winners[j]][j]\n                max_j = j\n        second_stage_winners[i] = max_j\n\n    winner = second_stage_winners.index(max(second_stage_winners)) + 1\n    return str(winner)\n"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tl(correct_solutions, wrong_solutions, tl):\n        for solution in correct_solutions:\n            if solution <= tl:\n                return True\n        for solution in wrong_solutions:\n            if solution <= tl:\n                return False\n        return any(2 * a <= tl for a in correct_solutions)\n\n    n, m = map(int, stdin.split()[0:2])\n    correct_solutions = list(map(int, stdin.split()[2:2 + n]))\n    wrong_solutions = list(map(int, stdin.split()[2 + n:]))\n    tl = 1\n    while not is_valid_tl(correct_solutions, wrong_solutions, tl):\n        tl += 1\n    return tl if is_valid_tl(correct_solutions, wrong_solutions, tl) else -1\n"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, v = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n\n    if any(a_time > v for a_time in a):\n        return \"1. a_time > v for some a_time\"\n\n    if any(b_time <= v for b_time in b):\n        return \"2. b_time <= v for some b_time\"\n\n    for i in range(1, n):\n        if a[i-1] > v and a[i] <= v:\n            if 2*a[i] > v:\n                return f\"3. a_time: {a[i]}\"\n    return \"4. All conditions are met\"\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solution(f\"{n} {m} 5\\n{a}\\n{b}\")) "
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, v = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    correct_solutions = set(a)\n    wrong_solutions = set(b)\n\n    for solution in correct_solutions:\n        if 2 * solution <= v:\n            return v\n\n    for solution in wrong_solutions:\n        if solution > v:\n            return v\n\n    return -1"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    correct_times = list(map(int, stdin.splitlines()[1].split()))\n    wrong_times = list(map(int, stdin.splitlines()[2].split()))\n\n    v = 1\n    while True:\n        correct_passed = 0\n        correct_extra_time = 0\n        for time in correct_times:\n            if time <= v:\n                correct_passed += 1\n                if time * 2 <= v:\n                    correct_extra_time += 1\n\n        wrong_passed = 0\n        for time in wrong_times:\n            if time > v:\n                wrong_passed += 1\n\n        if correct_passed == n and wrong_passed == m:\n            break\n\n        v += 1\n\n    if correct_extra_time > 0:\n        return v\n    else:\n        return -1\n\n\nn, m = map(int, input().split())\ncorrect_times = list(map(int, input().split()))\nwrong_times = list(map(int, input().split()))\n\nprint(solution(stdin=f\"{n} {m}\\n{' '.join(map(str, correct_times))}\\n{' '.join(map(str, wrong_times))}\"))"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    correct_solutions_times = list(map(int, input_data[1].split()))\n    wrong_solutions_times = list(map(int, input_data[2].split()))\n\n    # Sort correct_solutions_times and wrong_solutions_times\n    correct_solutions_times.sort()\n    wrong_solutions_times.sort()\n\n    # Initialize TL value\n    tl = 0\n\n    # Iterate through correct solutions times\n    for time in correct_solutions_times:\n        tl += time\n\n    # Check if at least one correct solution passes with \"extra\" time\n    for i in range(len(correct_solutions_times) - 1):\n        if (correct_solutions_times[i + 1] - correct_solutions_times[i]) % 2 == 0:\n            tl += 1\n            break\n\n    # Check if all wrong solutions don't pass\n    for time in wrong_solutions_times:\n        if time <= tl:\n            return -1\n\n    # Check if TL value is minimum\n    for time in correct_solutions_times:\n        if tl > time:\n            tl = time\n\n    return tl\n"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    correct_solutions = list(map(int, input_list[1].split()))\n    wrong_solutions = list(map(int, input_list[2].split()))\n\n    v = min(correct_solutions)\n    for i in range(m):\n        if wrong_solutions[i] > v:\n            v = wrong_solutions[i]\n\n    for solution in correct_solutions:\n        if solution > v:\n            return -1\n\n    return v"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tl(tl: int, correct_solutions: list, wrong_solutions: list) -> bool:\n        for solution in correct_solutions:\n            if solution <= tl:\n                return False\n        for solution in wrong_solutions:\n            if solution <= tl:\n                return False\n        return True\n\n    def get_min_tl(correct_solutions: list, wrong_solutions: list) -> int:\n        min_tl = min(correct_solutions)\n        for solution in wrong_solutions:\n            min_tl = min(min_tl, solution)\n        return min_tl\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    correct_solutions = list(map(int, lines[1].split()))\n    wrong_solutions = list(map(int, lines[2].split()))\n\n    min_tl = get_min_tl(correct_solutions, wrong_solutions)\n\n    for i in range(1, min_tl + 1):\n        if is_valid_tl(i, correct_solutions, wrong_solutions):\n            return i\n\n    return -1\n"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    a.sort()\n    b.sort()\n\n    v = 1\n    while True:\n        valid = True\n        for t in a + b:\n            if t > v:\n                break\n            if t == v and len(a) == 0:\n                break\n            if t == v and len(b) > 0 and b[0] > v:\n                break\n\n        if valid:\n            return v\n        else:\n            v += 1\n\n\nstdin = '''3 6\n4 5 2\n8 9 6 10 7 11'''\n\nprint(solution(stdin))\n\nstdin = '''3 1\n3 4 5\n6'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Reading input\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    \n    # Find the minimum TL\n    v = 1\n    while not (check_solutions(a, v) and check_solutions(b, v, True) and all(check_solutions(b, v, True))):\n        v += 1\n        if v > 100:\n            return -1\n    \n    # Print the minimum TL\n    return v\n\n\ndef"
    },
    {
        "number": 594,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    correct_times = list(map(int, stdin.splitlines()[1].split()))\n    wrong_times = list(map(int, stdin.splitlines()[2].split()))\n\n    v = max(correct_times)\n\n    if any(time >= v for time in wrong_times):\n        return -1\n\n    for time in correct_times:\n        if time + 1 <= v:\n            return v\n\n    return -1\n"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin)\n    next_year = year\n    \n    while True:\n        if (next_year % 4 == 0 and next_year % 100 != 0) or (next_year % 400 == 0):\n            # Leap year\n            days_in_year = 366\n        else:\n            # Not leap year\n            days_in_year = 365\n        \n        days_of_week = [0] * 7\n        for day in range(1, days_in_year + 1):\n            day_of_week = (day + sum(days_of_week) - 1) % 7\n            days_of_week[day_of_week] += 1\n        \n        if days_of_week == [31, 30, 31, 30, 31, 30, 31]:\n            # The calendar is the same\n            break\n        else:\n            next_year += 1\n    \n    return str(next_year)"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n        y = y + 366\n    else:\n        y = y + 365\n    return str(y)\n"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_year = int(stdin)\n    next_year = input_year + 1\n    while not is_same_calendar(input_year, next_year):\n        next_year += 1\n    return str(next_year)\n\ndef"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    if y % 400 == 0 or (y % 4 == 0 and y % 100 != 0):\n        leap = True\n    else:\n        leap = False\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    while True:\n        for i in range(1, 367):\n            week_day = (y + i) % 7\n            if week_day == 0:\n                week_day = 7\n            if days[week_day - 1] == \"Sunday\":\n                if leap:\n                    if i == 366:\n                        return str(y + i)\n                else:\n                    if i == 365:\n                        return str(y + i)\n        y += 1 "
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    \n    if y % 4 == 0 and (y % 100 != 0 or y % 400 == 0):\n        days_in_year = 366\n    else:\n        days_in_year = 365\n    \n    # find next year with the same calendar\n    y_next = y + 1\n    while True:\n        if y_next % 4 == 0 and (y_next % 100 != 0 or y_next % 400 == 0):\n            days_in_year_next = 366\n        else:\n            days_in_year_next = 365\n        \n        if days_in_year == days_in_year_next:\n            break\n        y_next += 1\n    \n    return str(y_next) "
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    leap = False\n    if y % 4 == 0:\n        if y % 100 == 0:\n            if y % 400 == 0:\n                leap = True\n        else:\n            leap = True\n    if leap:\n        if y % 400 == 0:\n            return str(y + 400)\n        else:\n            return str(y + 400 - (y % 400))\n    else:\n        if y % 100 == 0:\n            return str(y + 100)\n        else:\n            return str(y + 100 - (y % 100)) "
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    y_next = y + 1\n    while True:\n        if y_next % 4 == 0 and (y_next % 100 != 0 or y_next % 400 == 0):\n            break\n        else:\n            y_next += 1\n    return str(y_next)\n\n\ndef"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    year = y\n    while True:\n        is_leap_year = False\n        days = 0\n        if year % 400 == 0:\n            is_leap_year = True\n        elif year % 100 == 0:\n            is_leap_year = False\n        elif year % 4 == 0:\n            is_leap_year = True\n\n        days_of_week = {\n            \"Monday\": 0,\n            \"Tuesday\": 1,\n            \"Wednesday\": 2,\n            \"Thursday\": 3,\n            \"Friday\": 4,\n            \"Saturday\": 5,\n            \"Sunday\": 6\n        }\n\n        for day in days_of_week:\n            days += 1\n            if is_leap_year and days == 366:\n                break\n            elif not is_leap_year and days == 365:\n                break\n\n        if days == 365 or (days == 366 and is_leap_year):\n            break\n        year += 1\n\n    return year\n"
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin.strip())\n    next_year = year\n    \n    # Find the next year with the same calendar\n    while True:\n        is_leap = next_year % 4 == 0 and (next_year % 100 != 0 or next_year % 400 == 0)\n        days_in_month = [31, 29 if is_leap else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        if all(calendar.day_name[i] == days[i % 7] for i, days in enumerate(zip(*days_in_month))):\n            break\n        else:\n            next_year += 1\n    \n    return str(next_year) "
    },
    {
        "number": 595,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    year = int(stdin.strip())\n    \n    if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n        is_leap_year = True\n    else:\n        is_leap_year = False\n    \n    next_year = year + 1\n    while True:\n        if is_leap_year:\n            days_in_months = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        else:\n            days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        total_days = sum(days_in_months)\n        if next_year % 400 == 0 or (next_year % 4 == 0 and next_year % 100 != 0):\n            is_leap_year = True\n        else:\n            is_leap_year = False\n        \n        if total_days == 366:\n            return str(next_year)\n        \n        next_year += 1\n"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return True\n        return False\n\n    def days_between_months(month1: int, year1: int, month2: int, year2: int) -> int:\n        days = 0\n        for year in range(year1, year2):\n            if is_leap_year(year):\n                days += 366\n            else:\n                days += 365\n        days += (month1 - 1 + (30 if month1 > 2 and is_leap_year(year1) else 29))\n        days -= (month2 - 1 + (30 if month2 > 2 and is_leap_year(year2) else 29))\n        return days\n\n    year1, month1, day1 = map(int, stdin.split(':')[0].split('-'))\n    year2, month2, day2 = map(int, stdin.split(':')[1].split('-'))\n    days = days_between_months(month1, year1, month2, year2)\n    days += (day2 - 1 + (29 if is_leap_year(year2) and month2 == 2 else 0))\n    days -= (day1 - 1 + (29 if is_leap_year(year1) and month1 == 2 else 0))\n    return days\n"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        elif month == 2:\n            return 29 if is_leap_year(year) else 28\n        else:\n            return 31\n\n    def days_between_dates(date1: str, date2: str) -> int:\n        year1, month1, day1 = map(int, date1.split(':'))\n        year2, month2, day2 = map(int, date2.split(':'))\n\n        days = 0\n        year, month = year1, month1\n        while year < year2 or (year == year2 and month <= month2):\n            days += days_in_month(year, month)\n            month += 1\n            if month > 12:\n                month = 1\n                year += 1\n\n        days -= days_in_month(year1, month1) + day1\n        days -= day2\n\n        return days\n\n    stdin_list = stdin.split('\\n')\n    date1, date2 = stdin_list[0], stdin_list[1]\n    result = days_between_dates(date1, date2)\n    return str(result)\n\n\ninput_str = \"1900:01:01\\n2038:12:31\"\nprint(solution(input_str)) "
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    dates = stdin.split('\\n')\n    start_date = list(map(int, dates[0].split(':')))\n    end_date = list(map(int, dates[1].split(':')))\n\n    days = 0\n    for year in range(start_date[0], end_date[0] + 1):\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            days += 366\n        else:\n            days += 365\n\n    days_in_feb = 29 if start_date[0] % 4 == 0 and (start_date[0] % 100 != 0 or start_date[0] % 400 == 0) else 28\n    days_in_start_feb = min(days_in_feb, start_date[1])\n    days_in_end_feb = min(days_in_feb, end_date[1])\n\n    days += (end_date[2] - start_date[2]) + days_in_end_feb - days_in_start_feb\n\n    return str(days)"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        return 31\n\n    def days_between_dates(start_year: int, start_month: int, start_day: int, end_year: int, end_month: int, end_day: int) -> int:\n        days = 0\n        for year in range(start_year, end_year + 1):\n            days += days_in_year(year)\n        days += days_between_months(start_year, end_year, start_month, end_month)\n        days += (end_day - start_day) % days_in_month(start_year, start_month)\n        return days\n\n    def days_in_year(year: int) -> int:\n        return 366 if is_leap_year(year) else 365\n\n    def days_between_months(start_year: int, end_year: int, start_month: int, end_month: int) -> int:\n        days = 0\n        for month in range(start_month, 13):\n            if month == end_month:\n                break\n            days += days_in_month(start_year, month)\n        for year in range(start_year + 1, end_year + 1):\n            for month in range(1, 13):\n                days += days_in_month(year, month)\n        return days\n\n    start_year, start_month, start_day = map(int, stdin.split()[0].split(':'))\n    end_year, end_month, end_day = map(int, stdin.split()[1].split(':'))\n    return days_between_dates(start_year, start_month, start_day, end_year, end_month, end_day)"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.strip().split('\\n')\n    start_date = lines[0].split(':')\n    end_date = lines[1].split(':')\n\n    # Convert input dates to datetime objects\n    start_date = datetime.datetime(int(start_date[0]), int(start_date[1]), int(start_date[2]))\n    end_date = datetime.datetime(int(end_date[0]), int(end_date[1]), int(end_date[2]))\n\n    # Calculate the difference between the two dates\n    delta = end_date - start_date\n\n    # Calculate the number of days between the two dates\n    days = delta.days + 1\n\n    # Print the result\n    return str(days)\n"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    dates = stdin.split('\\n')\n    year_1, month_1, day_1 = map(int, dates[0].split(':'))\n    year_2, month_2, day_2 = map(int, dates[1].split(':'))\n\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days_in_february = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def is_leap_year(year: int) -> bool:\n        if year % 4 != 0:\n            return False\n        if year % 100 != 0:\n            return True\n        if year % 400 != 0:\n            return False\n        return True\n\n    def days_between(year_1: int, month_1: int, day_1: int, year_2: int, month_2: int, day_2: int) -> int:\n        days = 0\n        while (year_1, month_1, day_1) != (year_2, month_2, day_2):\n            days += 1\n            if month_1 == 12:\n                month_1 = 1\n                year_1 += 1\n            else:\n                month_1 += 1\n\n            if month_1 == 2:\n                if is_leap_year(year_1):\n                    days += days_in_february[1]\n                else:\n                    days += days_in_february[0]\n            else:\n                days += days_in_month[month_1 - 1]\n        return days\n\n    return str(days_between(year_1, month_1, day_1, year_2, month_2, day_2))"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        elif month in [4, 6, 9, 11]:\n            return 30\n        else:\n            return 31\n\n    def days_between_dates(start: tuple, end: tuple) -> int:\n        start_year, start_month, start_day = start\n        end_year, end_month, end_day = end\n\n        days = 0\n        while (start_year, start_month, start_day) != (end_year, end_month, end_day):\n            if start_month == 12 or start_day == days_in_month(start_year, start_month):\n                start_year += 1\n                start_month = 1\n                start_day = 1\n            else:\n                start_month += 1\n                start_day += 1\n            days += 1\n\n        return days\n\n    start_date, end_date = stdin.splitlines()\n    start_year, start_month, start_day = map(int, start_date.split(\":\"))\n    end_year, end_month, end_day = map(int, end_date.split(\":\"))\n\n    return days_between_dates((start_year, start_month, start_day), (end_year, end_month, end_day))\n"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        return [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1]\n\n    def days_between_dates(start_year: int, start_month: int, start_day: int, end_year: int, end_month: int, end_day: int) -> int:\n        days = 0\n        while (start_year, start_month, start_day) != (end_year, end_month, end_day):\n            if start_month < end_month or (start_month == end_month and start_day < end_day):\n                days += days_in_month(start_year, start_month)\n                if start_month == 2 and is_leap_year(start_year):\n                    days -= 1\n                start_month += 1\n                if start_month > 12:\n                    start_month = 1\n                    start_year += 1\n            else:\n                start_month -= 1\n                if start_month < 1:\n                    start_month = 12\n                    start_year -= 1\n                days -= days_in_month(start_year, start_month)\n                if start_month == 2 and is_leap_year(start_year):\n                    days += 1\n        days += (end_day - start_day)\n        return days\n\n    start_date, end_date = stdin.splitlines()\n    start_year, start_month, start_day = map(int, start_date.split(\":\"))\n    end_year, end_month, end_day = map(int, end_date.split(\":\"))\n\n    return str(days_between_dates(start_year, start_month, start_day, end_year, end_month, end_day))"
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        elif month in [1, 3, 5, 7, 8, 10, 12]:\n            return 31\n        elif year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return 29\n        else:\n            return 28\n\n    def date_to_days(year: int, month: int, day: int) -> int:\n        days = 0\n        for y in range(1900, year):\n            if y % 4 == 0 and (y % 100 != 0 or y % 400 == 0):\n                days += 366\n            else:\n                days += 365\n        for m in range(1, month):\n            days += days_in_month(year, m)\n        days += day - 1\n        return days\n\n    date1, date2 = stdin.split('\\n')\n    year1, month1, day1 = map(int, date1.split(':'))\n    year2, month2, day2 = map(int, date2.split(':'))\n\n    days1 = date_to_days(year1, month1, day1)\n    days2 = date_to_days(year2, month2, day2)\n\n    return abs(days2 - days1)\n\n\ninput_file = \"input.txt\"\noutput_file = \"output.txt\"\n\nwith open(input_file, \"r\") as file:\n    stdin = file.read()\n    stdout = solution(stdin)\n\nwith open(output_file, \"w\") as file:\n    file.write(str(stdout)) "
    },
    {
        "number": 596,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        return 31\n\n    def days_between_dates(start: tuple, end: tuple) -> int:\n        year, month, day = start\n        total_days = day - 1\n        while (year, month) < (end[0], end[1]):\n            total_days += days_in_month(year, month)\n            if month == 12:\n                year += 1\n                month = 1\n            else:\n                month += 1\n        return total_days + end[2]\n\n    start_date = tuple(map(int, stdin.split()[0].split(':')))\n    end_date = tuple(map(int, stdin.split()[1].split(':')))\n\n    return str(days_between_dates(start_date, end_date))\n"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    roads = {(int(u), int(v)) for u, v in (line.split() for line in input_lines[1:n])}\n    attack_cities = set(map(int, input_lines[n].split()))\n    \n    # Find the city that connects the most attacked cities\n    max_connections = 0\n    max_city = 0\n    for u in attack_cities:\n        connections = sum(v in attack_cities for v in roads[u])\n        if connections > max_connections:\n            max_connections = connections\n            max_city = u\n    \n    # Calculate the minimum time needed to scare all humans in cities being attacked\n    min_time = float('inf')\n    for u in attack_cities:\n        time = 1\n        for v in roads[u]:\n            if v in attack_cities:\n                time += 1\n        min_time = min(min_time, time)\n    \n    # Print the optimal answer\n    output = f\"{max_city}\\n{min_time}\"\n    return output"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    road_system = stdin.split()[2:]\n    attacked_cities = sorted(map(int, stdin.split()[-m:]))\n\n    min_time = float('inf')\n    min_city = 0\n\n    for attacked_city in attacked_cities:\n        time = 0\n        current_city = attacked_city\n        visited_cities = set()\n\n        while current_city != 1:\n            visited_cities.add(current_city)\n            adjacents = [u for u, v in road_system if v == current_city]\n\n            if not adjacents:\n                raise ValueError(\"No possible path found\")\n\n            next_city = adjacents[0]\n            for adjacent in adjacents:\n                if adjacent not in visited_cities:\n                    next_city = adjacent\n                    break\n\n            time += 1\n            current_city = next_city\n\n        if time < min_time:\n            min_time = time\n            min_city = attacked_city\n\n    output = f\"{min_city}\\n{min_time}\"\n    return output\n"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, m = map(int, stdin.split()[:2])\n    roads = [map(int, line.split()) for line in stdin.split('\\n')[1:-1]]\n    cities_to_attack = set(map(int, stdin.split()[-1].split()))\n    \n    # Find the shortest path from each city to the attacked cities\n    shortest_paths = {}\n    for city in range(1, n+1):\n        # Initialize the distance to each city as infinity\n        distances = [float('inf')] * (n+1)\n        distances[city] = 0\n        \n        # Relax the edges until all cities are reached\n        for _ in range(n-1):\n            min_dist = float('inf')\n            min_city = 0\n            for u, v in roads:\n                if distances[u] + 1 < distances[v]:\n                    distances[v] = distances[u] + 1\n                    if distances[v] < min_dist:\n                        min_dist = distances[v]\n                        min_city = v\n            if min_dist == float('inf'):\n                # The graph is not connected\n                break\n            distances[min_city] = min_dist\n        \n        # Store the shortest distances to the attacked cities\n        shortest_paths[city] = {c: distances[c] for c in cities_to_attack}\n    \n    # Find the minimum time needed to scare all humans in cities being attacked\n    min_time = float('inf')\n    for city in shortest_paths:\n        min_time = min(min_time, sum(shortest_paths[city].values()))\n    \n    # Find the city Super M should teleport to\n    optimal_city = min(shortest_paths, key=lambda x: (sum(shortest_paths[x].values()), x))\n    \n    # Print the result\n    return f\"{optimal_city}\\n{min_time}\" "
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph: dict, start: int, end: int) -> list:\n        visited = set()\n        queue = [(start, [start])]\n        while queue:\n            (node, path) = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor, weight in graph[node].items():\n                    if neighbor not in visited:\n                        if neighbor == end:\n                            return path + [neighbor]\n                        else:\n                            queue.append((neighbor, path + [neighbor]))\n        return []\n\n    def min_time_to_scare_all_humans(graph: dict, cities: list) -> int:\n        visited = set()\n        time = 0\n        for city in cities:\n            if city in visited:\n                continue\n            visited.add(city)\n            time += len(find_path(graph, 1, city)) - 1\n        return time\n\n    n, m = map(int, stdin.split()[:2])\n    roads = stdin.split('\\n')[1:-1]\n    cities_being_attacked = list(map(int, stdin.split('\\n')[-1].split()))\n\n    graph = {i: {} for i in range(1, n + 1)}\n    for road in roads:\n        u, v = map(int, road.split())\n        graph[u][v] = 1\n        graph[v][u] = 1\n\n    start_city = min(cities_being_attacked)\n    end_cities = [city for city in cities_being_attacked if city != start_city]\n    end_city = min(end_cities) if end_cities else None\n\n    path = find_path(graph, start_city, end_city)\n    if path:\n        print(path[1])\n        print(min_time_to_scare_all_humans(graph, cities_being_attacked))\n    else:\n        print(\"-1\")\n        print(\"-1\")\n"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    attacked_cities = set(map(int, input_list.pop().split()))\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v in (map(int, edge.split()) for edge in input_list):\n        graph[u].append(v)\n        graph[v].append(u)\n    for city in graph:\n        if city in attacked_cities:\n            break\n    else:\n        raise ValueError(\"No city is being attacked\")\n    min_time = 1\n    for city in attacked_cities:\n        min_time *= 2 * len(graph[city]) + 1\n    return f\"{city}\\n{min_time // 2}\""
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    edges = [map(int, line.split()) for line in stdin.split('\\n')[1:-1]]\n    attack_cities = sorted(map(int, stdin.split()[-1].split()))\n\n    # Find the shortest path from the first city to all other cities\n    dist = [-1] * (n + 1)\n    dist[1] = 0\n    queue = [(1, 0)]\n    while queue:\n        cur, d = queue.pop(0)\n        if d > dist[cur]:\n            continue\n        for next_city, cost in edges:\n            if next_city == cur:\n                dist[next_city] = d + cost\n                queue.append((next_city, d + cost))\n\n    # Find the attack cities with the lowest distance from the starting city\n    min_dist = n * 100\n    for city in attack_cities:\n        min_dist = min(min_dist, dist[city])\n\n    # Calculate the minimum time to scare all humans\n    time_to_scare = m * min_dist\n\n    # Find the city with the lowest number to teleport to\n    start_city = min(dist[1:])\n\n    return f\"{start_city}\\n{time_to_scare}\" "
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    city_list = [list(map(int, input_list[i].split())) for i in range(1, n)]\n    attack_city_list = sorted(map(int, input_list[-1].split()))\n    min_city = attack_city_list[0]\n    total_time = 0\n\n    # Find minimum city number\n    for city in attack_city_list:\n        for road in city_list:\n            if city in road:\n                if road[0] < min_city:\n                    min_city = road[0]\n                elif road[1] < min_city:\n                    min_city = road[1]\n                break\n\n    # Calculate total time\n    for city in attack_city_list:\n        for road in city_list:\n            if city in road:\n                total_time += 1\n                break\n\n    return f\"{min_city}\\n{total_time}\"\n\ninput_list = [\n    \"7 2\",\n    \"1 2\",\n    \"1 3\",\n    \"1 4\",\n    \"3 5\",\n    \"3 6\",\n    \"3 7\",\n    \"2 7\",\n    \"6 4\",\n    \"1 2\",\n    \"2 3\",\n    \"2 4\",\n    \"4 5\",\n    \"4 6\",\n    \"2 4 5 6\"\n]\n\nfor input_str in input_list:\n    print(solution(input_str)) "
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    road_list = [list(map(int, line.split())) for line in input_list[1:n]]\n    attack_list = list(map(int, input_list[n].split()))\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in road_list:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Find the city with the lowest number that is being attacked\n    min_attack = min(attack_list)\n    for i in range(1, n + 1):\n        if i in attack_list:\n            continue\n        for j in range(n):\n            if adj_list[i][j] == min_attack:\n                min_attack_city = i\n                break\n\n    # Calculate the minimum time needed to scare all humans\n    min_time = float('inf')\n    for attack in attack_list:\n        time = 0\n        curr_city = min_attack_city\n        while curr_city != attack:\n            for next_city in adj_list[curr_city]:\n                if next_city != min_attack and adj_list[curr_city].index(next_city) != adj_list[next_city].index(curr_city):\n                    time += 1\n                    curr_city = next_city\n                    break\n        min_time = min(min_time, time)\n\n    # Output the result\n    return f\"{min_attack_city}\\n{min_time}\"\n"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, List[Tuple[int, int]], List[int]]:\n        n, m = map(int, stdin.readline().split())\n        road_system = [map(int, stdin.readline().split()) for _ in range(n - 1)]\n        cities_being_attacked = sorted(set(map(int, stdin.readline().split())))\n        return n, m, road_system, cities_being_attacked\n\n    def find_shortest_path(start: int, end: int, road_system: List[Tuple[int, int]]) -> List[int]:\n        graph = defaultdict(set)\n        for u, v in road_system:\n            graph[u].add(v)\n            graph[v].add(u)\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            node, path = queue.pop(0)\n            if node == end:\n                return path\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    queue.append((neighbor, path + [neighbor]))\n        return []\n\n    n, m, road_system, cities_being_attacked = read_input()\n    city_to_attack = cities_being_attacked[0]\n    shortest_path = find_shortest_path(city_to_attack, 1, road_system)\n    time_to_scare_humans = len(shortest_path) - 1\n\n    return f\"{city_to_attack}\\n{time_to_scare_humans}\"\n"
    },
    {
        "number": 597,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(graph, start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (vertex, distance) = queue.pop(0)\n            if vertex == end:\n                return distance\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor in graph[vertex]:\n                    queue.append((neighbor, distance + 1))\n        return -1\n\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.splitlines()[1:-1]:\n        u, v = map(int, line.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    attacking_cities = sorted(map(int, stdin.splitlines()[-1].split()))\n\n    shortest_paths = []\n    for city in attacking_cities:\n        shortest_path = find_shortest_path(graph, 1, city)\n        if shortest_path == -1:\n            return \"impossible\"\n        shortest_paths.append(shortest_path)\n\n    min_path = min(shortest_paths)\n    min_path_cities = [attacking_cities.index(city) + 1 for city in attacking_cities if find_shortest_path(graph, 1, city) == min_path]\n\n    return min_path_cities[0], min_path\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, input().split())\n        vouchers.append((l, r, cost))\n\n    def is_disjoint(i, j):\n        return vouchers[i][1] < vouchers[j][0] or vouchers[j][1] < vouchers[i][0]\n\n    def duration(i):\n        return vouchers[i][1] - vouchers[i][0] + 1\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_disjoint(i, j):\n                durations = duration(i) + duration(j)\n                if durations == x and vouchers[i][2] + vouchers[j][2] < min_cost:\n                    min_cost = vouchers[i][2] + vouchers[j][2]\n\n    return min_cost if min_cost != float('inf') else -1\n\n\ninput_data = \"\"\"4 5\n1 3 4\n1 2 5\n5 6 1\n1 2 4\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_voucher(start: int, end: int, cost: int):\n        for i in range(start, end + 1):\n            if vouchers[i][2] >= cost:\n                return i\n        return None\n\n    def intersects(i: int, j: int) -> bool:\n        return max(l[i], l[j]) < min(r[i], r[j])\n\n    def total_duration(i: int) -> int:\n        return r[i] - l[i] + 1\n\n    n, x = map(int, stdin.split()[:2])\n    vouchers = [tuple(map(int, stdin.split()[i].split())) for i in range(2, 2 * n + 1, 3)]\n    l = [vouchers[i][0] for i in range(n)]\n    r = [vouchers[i][1] for i in range(n)]\n    cost = [vouchers[i][2] for i in range(n)]\n\n    min_cost = float('inf')\n    for i in range(n):\n        j = find_voucher(i + 1, n - 1, cost[i])\n        if j is None:\n            continue\n        if not intersects(i, j) and total_duration(i) + total_duration(j) == x:\n            min_cost = min(min_cost, cost[i] + cost[j])\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    vouchers = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    vouchers.sort(key=lambda v: v[0])\n    total_duration = 0\n    total_cost = 0\n\n    for i in range(n):\n        if vouchers[i][1] - vouchers[i][0] + 1 <= x - total_duration:\n            total_duration += vouchers[i][1] - vouchers[i][0] + 1\n            total_cost += vouchers[i][2]\n        else:\n            break\n\n    if total_duration == x and total_duration > 0:\n        return total_cost\n    else:\n        return -1\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    vouchers = []\n\n    for _ in range(n):\n        l, r, cost = map(int, input().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort(key=lambda v: v[1] - v[0] + 1)\n\n    left, right = 0, n - 1\n    while left < right:\n        current_duration = vouchers[left][1] - vouchers[left][0] + 1\n        if current_duration == x:\n            current_cost = vouchers[left][2]\n            for i in range(left + 1, right + 1):\n                if vouchers[i][0] >= vouchers[left][1]:\n                    break\n                current_duration += vouchers[i][1] - vouchers[i][0] + 1\n                if current_duration > x:\n                    break\n                current_cost += vouchers[i][2]\n            else:\n                return current_cost\n            right -= 1\n        elif current_duration < x:\n            left += 1\n        else:\n            right -= 1\n\n    return -1\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, input().split())\n        vouchers.append((l, r, cost))\n    \n    def is_disjoint(voucher1, voucher2):\n        return voucher1[1] < voucher2[0] or voucher2[1] < voucher1[0]\n\n    vouchers.sort(key=lambda voucher: voucher[2])\n    total_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_disjoint(vouchers[i], vouchers[j]):\n                total_duration = vouchers[i][1] - vouchers[i][0] + 1 + vouchers[j][1] - vouchers[j][0] + 1\n                if total_duration == x:\n                    total_cost += vouchers[i][2] + vouchers[j][2]\n                    if total_cost == 0:\n                        return total_cost\n\n    return -1 if total_cost == 0 else total_cost"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, x = input_data[0], input_data[1]\n    vouchers = [tuple(input_data[2*i+2:2*i+5]) for i in range(n)]\n    \n    def get_duration(voucher):\n        return voucher[1] - voucher[0] + 1\n    \n    def is_intersect(voucher1, voucher2):\n        return voucher1[1] >= voucher2[0] and voucher2[1] >= voucher1[0]\n    \n    result = float('inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if get_duration(vouchers[i]) + get_duration(vouchers[j]) == x and not is_intersect(vouchers[i], vouchers[j]):\n                result = min(result, vouchers[i][2] + vouchers[j][2])\n                \n    return str(result) if result != float('inf') else '-1'\n\ndef"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    vouchers = []\n    total_cost = 0\n    for _ in range(n):\n        l, r, cost = map(int, stdin.split()[1:4])\n        vouchers.append((l, r, cost))\n        total_cost += cost\n\n    # Sort vouchers by cost\n    vouchers.sort(key=lambda voucher: voucher[2])\n\n    # Check if it's possible to choose two vouchers with the total duration exactly x\n    for i in range(n):\n        for j in range(i+1, n):\n            l1, r1, c1 = vouchers[i]\n            l2, r2, c2 = vouchers[j]\n            duration1 = r1 - l1 + 1\n            duration2 = r2 - l2 + 1\n            if l1 > r2 or l2 > r1:\n                if duration1 + duration2 == x:\n                    return c1 + c2\n\n    # Find two disjoint vouchers with the total duration exactly x\n    for i in range(n):\n        for j in range(i+1, n):\n            l1, r1, c1 = vouchers[i]\n            l2, r2, c2 = vouchers[j]\n            duration1 = r1 - l1 + 1\n            duration2 = r2 - l2 + 1\n            if l1 > r2 or l2 > r1:\n                if duration1 + duration2 == x:\n                    return min(c1, c2)\n\n    return -1\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_disjoint(voucher1, voucher2):\n        return voucher1[1] < voucher2[0] or voucher2[1] < voucher1[0]\n\n    def get_duration(voucher):\n        return voucher[1] - voucher[0] + 1\n\n    def get_cost(voucher):\n        return voucher[2]\n\n    def get_total_duration(vouchers):\n        return sum(get_duration(v) for v in vouchers)\n\n    def get_total_cost(vouchers):\n        return sum(get_cost(v) for v in vouchers)\n\n    n, x = map(int, input().split())\n    vouchers = [tuple(map(int, input().split())) for _ in range(n)]\n\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_disjoint(vouchers[i], vouchers[j]):\n                duration = get_duration(vouchers[i]) + get_duration(vouchers[j])\n                cost = get_cost(vouchers[i]) + get_cost(vouchers[j])\n                if duration == x and cost < min_cost:\n                    min_cost = cost\n\n    return min_cost if min_cost != float('inf') else -1\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_vouchers(n: int, x: int) -> int:\n        vouchers = []\n        for _ in range(n):\n            l, r, cost = map(int, stdin.readline().split())\n            vouchers.append((l, r, cost))\n        vouchers.sort(key=lambda v: v[1])\n        min_cost = float('inf')\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if vouchers[i][1] < vouchers[j][0] or vouchers[i][2] + vouchers[j][2] >= min_cost:\n                    continue\n                if vouchers[i][1] - vouchers[i][0] + 1 + vouchers[j][1] - vouchers[j][0] + 1 == x:\n                    min_cost = min(min_cost, vouchers[i][2] + vouchers[j][2])\n        return min_cost if min_cost != float('inf') else -1\n\n    n, x = map(int, stdin.readline().split())\n    return str(find_vouchers(n, x))\n"
    },
    {
        "number": 598,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, input().split())\n        vouchers.append((l, r, cost))\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if vouchers[i][1] < vouchers[j][0] or vouchers[j][1] < vouchers[i][0]:\n                duration = vouchers[i][1] - vouchers[i][0] + 1 + vouchers[j][1] - vouchers[j][0] + 1\n                if duration == x and vouchers[i][2] + vouchers[j][2] < min_cost:\n                    min_cost = vouchers[i][2] + vouchers[j][2]\n\n    if min_cost == float('inf'):\n        return -1\n    else:\n        return min_cost\n"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    for i in range(len(s)):\n        for letter in \"abcdefghijklmnopqrstuvwxyz\":\n            if letter == s[i]:\n                continue\n            s[i] = letter\n            if s == s[::-1]:\n                return \"\".join(s)\n            s[i] = s[i].lower()\n    return \"NA\"\n\n\ndef"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    for i in range(len(s)):\n        for j in range(26):\n            if s[:i] + chr(ord('a') + j) + s[i:] == s[::-1]:\n                return s[:i] + chr(ord('a') + j) + s[i:]\n    return \"NA\"\n\ndef"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def insert_letter(s: str, letter: str) -> str:\n        return s[:-1] + letter + s[-1]\n\n    s = stdin.lower()\n    for letter in \"abcdefghijklmnopqrstuvwxyz\":\n        if is_palindrome(insert_letter(s, letter)):\n            return insert_letter(s, letter)\n    return \"NA\"\n"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    for i in range(len(s)):\n        for j in range(ord('a'), ord('z') + 1):\n            new_s = s[:i] + chr(j) + s[i:]\n            if new_s == new_s[::-1]:\n                return new_s\n    return \"NA\"\n\n\ndef"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def can_be_palindrome(s: str) -> bool:\n        return any(s[i] != s[-i-1] for i in range(len(s) // 2))\n\n    if is_palindrome(stdin):\n        return stdin\n    elif can_be_palindrome(stdin):\n        for i in range(len(s)):\n            if s[i] != s[-i-1]:\n                s[i] = s[-i-1]\n                return ''.join(s)\n    else:\n        return \"NA\"\n\n\ndef"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    for i in range(n):\n        for j in range(26):\n            if chr(ord('a') + j) != s[i]:\n                s[i] = chr(ord('a') + j)\n                s = ''.join(s)\n                if s == s[::-1]:\n                    return s\n                s[i] = s[i].upper()\n    return \"NA\"\n\n\nstdin = input().strip()\nprint(solution(stdin)) "
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n\n    for i in range(n):\n        s.insert(i, 'a')\n        if s[0] == s[-1] and s[1:-1] == s[-2:0:-1]:\n            return ''.join(s)\n        s.pop(i)\n\n    return \"NA\"\n"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if s == s[::-1]:\n        return \"NA\"\n    for i in range(len(s)):\n        for j in range(26):\n            if s[i] != chr(j + ord('a')):\n                new_s = s[:i] + chr(j + ord('a')) + s[i:]\n                if new_s == new_s[::-1]:\n                    return new_s\n    return \"NA\"\n\n\ndef"
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    if s == s[::-1]:\n        return \"NA\"\n    else:\n        for i in range(len(s)):\n            new_s = s[:i] + 'a' + s[i:]\n            if new_s == new_s[::-1]:\n                return new_s\n        return \"NA\""
    },
    {
        "number": 599,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    for i in range(len(s)):\n        for j in range(len(s)):\n            for c in \"abcdefghijklmnopqrstuvwxyz\":\n                if s[i] == c:\n                    continue\n                s[i] = c\n                if s[::-1] == s:\n                    return ''.join(s)\n                s[i] = c\n    return \"NA\"\n\n\ninput_string = input(\"Enter a string: \")\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n    tiredness = 0\n    while a != b:\n        tiredness += a - 1\n        a += 1\n        tiredness += a - b\n        a += 1\n    return tiredness\n"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def tiredness(n: int) -> int:\n        return n * (n + 1) // 2\n\n    a, b = map(int, stdin.split())\n\n    if a == b:\n        return 0\n\n    if a > b:\n        a, b = b, a\n\n    if a - b == 1:\n        return tiredness(1)\n\n    distance = b - a\n    tiredness_total = tiredness(distance)\n\n    return tiredness_total\n"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.splitlines())\n    return min(abs(a - b) * (abs(a - b) + 1) // 2, abs(a - b) + 1)\n\n\ninput_data = \"3\\n4\\n101\\n99\\n5\\n10\"\nprint(solution(input_data)) "
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    # We want to find the point where the two friends meet.\n    # We start with the point a and move towards b.\n    # If a > b, we move to the right, otherwise we move to the left.\n    # We keep track of the tiredness of each friend.\n    # The tiredness of the first friend increases by 1 on every move,\n    # the tiredness of the second friend increases by 2 on every move.\n    \n    tiredness_a = 0\n    tiredness_b = 0\n    meeting_point = a\n    \n    if a > b:\n        while a != b:\n            tiredness_a += 1\n            tiredness_b += 2\n            a += 1\n            meeting_point = a\n    else:\n        while b != a:\n            tiredness_a += 1\n            tiredness_b += 2\n            b -= 1\n            meeting_point = b\n    \n    # The total tiredness is the sum of tiredness of both friends.\n    total_tiredness = tiredness_a + tiredness_b\n    \n    return total_tiredness"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    a = int(input_values[0])\n    b = int(input_values[1])\n\n    tiredness = abs(a - b)\n    tiredness = tiredness * (tiredness + 1) // 2\n\n    return tiredness\n"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_tiredness = 0\n\n    if a == b:\n        return str(total_tiredness)\n    else:\n        if a < b:\n            total_tiredness = (b - a) * (b - a + 1) // 2\n        else:\n            total_tiredness = (a - b) * (a - b + 1) // 2\n\n        return str(total_tiredness)\n"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    tiredness = 0\n    while a != b:\n        if a > b:\n            tiredness += a - b\n            a -= a - b\n        else:\n            tiredness += b - a\n            b -= b - a\n    return tiredness\n"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    # Calculate the minimum tiredness\n    tiredness = abs(a - b)\n    \n    # Check if the tiredness is odd or even\n    if tiredness % 2 == 0:\n        tiredness //= 2\n    else:\n        tiredness = (tiredness // 2) + 1\n    \n    return tiredness"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    tiredness = abs(a - b)\n    if tiredness % 2 == 0:\n        tiredness //= 2\n    else:\n        tiredness //= 2\n        tiredness += 1\n    return tiredness\n\ndef"
    },
    {
        "number": 600,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    tiredness = 0\n    \n    if a > b:\n        b, a = a, b\n\n    while a != b:\n        tiredness += abs(b - a)\n        a += abs(b - a)\n        \n    return tiredness"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> tuple:\n        t = int(readline())\n        input_list = []\n        for _ in range(t):\n            p, f = map(int, readline().split())\n            cnt_s, cnt_w = map(int, readline().split())\n            s, w = map(int, readline().split())\n            input_list.append((p, f, cnt_s, cnt_w, s, w))\n        return input_list\n\n    def rob(p: int, f: int, cnt_s: int, cnt_w: int, s: int, w: int) -> int:\n        max_weapons = min(p // s, f // w)\n        max_weapons_s = min(p // s, cnt_s)\n        max_weapons_w = min(p // s, cnt_w)\n        return max_weapons + max_weapons_s + max_weapons_w\n\n    input_list = get_input(stdin)\n    result = []\n    for p, f, cnt_s, cnt_w, s, w in input_list:\n        result.append(rob(p, f, cnt_s, cnt_w, s, w))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(s: str) -> tuple:\n        t = int(s[0])\n        input_list = []\n        for _ in range(t):\n            p, f = map(int, s[1].split())\n            cnt_s, cnt_w = map(int, s[2].split())\n            s_w, w_w = map(int, s[3].split())\n            input_list.append((p, f, cnt_s, cnt_w, s_w, w_w))\n        return input_list\n\n    def write_output(result: list) -> str:\n        return '\\n'.join(map(str, result))\n\n    def max_weapons(p: int, f: int, cnt_s: int, cnt_w: int, s_w: int, w_w: int) -> int:\n        max_s = min(cnt_s, p // s_w)\n        max_w = min(cnt_w, p // w_w)\n        max_f_s = min(cnt_s, f // s_w)\n        max_f_w = min(cnt_w, f // w_w)\n        return max_s + max_w + max_f_s + max_f_w\n\n    input_list = read_input(stdin.split('\\n'))\n    result = [max_weapons(p, f, cnt_s, cnt_w, s_w, w_w) for p, f, cnt_s, cnt_w, s_w, w_w in input_list]\n    output = write_output(result)\n    return output"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    result = []\n    for _ in range(t):\n        p, f, cnt_s, cnt_w, s, w = map(int, stdin.splitlines()[1].split())\n        max_swords = min(cnt_s, p // s)\n        max_war_axes = min(cnt_w, p // w)\n        max_weapons = max_swords + max_war_axes\n        if f > 0:\n            max_weapons = min(max_weapons, min(cnt_s, f // s) + min(cnt_w, f // w))\n        result.append(max_weapons)\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    test_cases = int(input_data[0])\n    output = []\n\n    for i in range(1, test_cases + 1):\n        _, p, f = map(int, input_data[i].split())\n        cnt_s, cnt_w, s, w = map(int, input_data[i + 1].split())\n        max_weapons = min(p, cnt_s) * s + min(f, cnt_w) * w\n        output.append(max_weapons)\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def take_weapons(p: int, f: int, cnt_s: int, cnt_w: int, s: int, w: int) -> int:\n        total_weight = cnt_s * s + cnt_w * w\n        max_weight = min(p, f)\n        if total_weight > max_weight:\n            return 0\n        max_weight -= total_weight\n        max_weapons_s = max_weight // s\n        max_weapons_w = max_weight // w\n        return min(cnt_s, max_weapons_s) + min(cnt_w, max_weapons_w)\n\n    test_cases = stdin.split('\\n')\n    test_cases = test_cases[1:]\n    result = []\n    for test_case in test_cases:\n        params = test_case.split()\n        p = int(params[0])\n        f = int(params[1])\n        cnt_s = int(params[2])\n        cnt_w = int(params[3])\n        s = int(params[4])\n        w = int(params[5])\n        weapons = take_weapons(p, f, cnt_s, cnt_w, s, w)\n        result.append(weapons)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    answers = []\n    for _ in range(t):\n        p, f, cnt_s, cnt_w, s, w = map(int, stdin.splitlines()[1].split())\n        total_weight = (cnt_s * s + cnt_w * w)\n        if total_weight <= p + f:\n            answer = cnt_s + cnt_w\n        else:\n            max_p = (p + f) // (s + w)\n            answer = min(cnt_s, max_p) + min(cnt_w, max_p)\n        answers.append(answer)\n    return '\\n'.join(map(str, answers))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split(\"\\n\")[0])\n    output = []\n    for _ in range(t):\n        p, f = map(int, stdin.split(\"\\n\")[1].split())\n        cnt_s, cnt_w = map(int, stdin.split(\"\\n\")[2].split())\n        s, w = map(int, stdin.split(\"\\n\")[3].split())\n        \n        weights = [s * cnt_s + w * cnt_w]\n        capacities = [p, f]\n        \n        while weights:\n            current_weight = weights.pop()\n            current_capacity = capacities.pop()\n            \n            if current_weight <= current_capacity:\n                if not weights and not capacities:\n                    output.append(1)\n                elif not weights:\n                    output.append(capacities[0])\n                elif not capacities:\n                    output.append(weights[-1])\n                else:\n                    output.append(1)\n            else:\n                capacities.append(current_capacity - current_weight)\n                weights.append(current_weight)\n    \n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def max_weapons(capacity, weights, n):\n        total_weight = sum(weights)\n        if total_weight <= capacity:\n            return n\n        for i in range(n):\n            capacity -= weights[i]\n            if capacity < 0:\n                return i\n        return n\n\n    def max_weapons_with_follower(capacity, weights, n):\n        total_weight = sum(weights)\n        if total_weight <= capacity:\n            return n * 2\n        for i in range(n):\n            if weights[i] > capacity:\n                return i * 2\n        return n * 2\n\n    t = int(stdin[0])\n    for i in range(1, t + 1):\n        p, f = map(int, stdin[i * 5 - 4].split())\n        cnt_s, cnt_w = map(int, stdin[i * 5 - 3].split())\n        s, w = map(int, stdin[i * 5 - 2].split())\n        max_s = max_weapons(p, [s] * cnt_s, cnt_s)\n        max_w = max_weapons(p, [w] * cnt_w, cnt_w)\n        print(max_s + max_w)\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(swords, war_axes, max_weight, index):\n        left, right = 0, len(swords)\n        while left <= right:\n            mid = (left + right) // 2\n            total_weight = swords[mid] + war_axes[index]\n            if total_weight == max_weight:\n                return True\n            elif total_weight < max_weight:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    def backtrack(swords, war_axes, cur_weight, used_swords, used_war_axes):\n        nonlocal max_count\n        if cur_weight > max_weight:\n            return\n        if cur_weight == max_weight:\n            max_count = max(max_count, len(used_swords) + len(used_war_axes))\n            return\n        if len(swords) > 0 and binary_search(swords, war_axes, max_weight, len(used_war_axes)):\n            backtrack(swords[:-1], war_axes, cur_weight + swords[-1], used_swords + [swords[-1]], used_war_axes)\n        if len(war_axes) > 0 and binary_search(swords, war_axes, max_weight, len(used_war_axes)):\n            backtrack(swords, war_axes[:-1], cur_weight + war_axes[-1], used_swords, used_war_axes + [war_axes[-1]])\n\n    t = int(stdin.splitlines()[0])\n    max_count = 0\n    for i in range(1, t + 1):\n        p, f = map(int, stdin.splitlines()[i].split())\n        cnt_s, cnt_w = map(int, stdin.splitlines()[i + 1].split())\n        s, w = map(int, stdin.splitlines()[i + 2].split())\n        max_weight = p + f\n        swords = [s * cnt_s]\n        war_axes = [w * cnt_w]\n        backtrack(swords, war_axes, 0, [], [])\n        print(max_count)\n        max_count = 0\n"
    },
    {
        "number": 601,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for _ in range(t):\n        p, f = map(int, input().split())\n        cnt_s, cnt_w = map(int, input().split())\n        s, w = map(int, input().split())\n\n        max_swords = min(cnt_s, p // s)\n        max_war_axes = min(cnt_w, p // w)\n        max_weapons = max_swords + max_war_axes\n\n        max_follower_weapons = min(cnt_s // 2, f // s) + min(cnt_w // 2, f // w)\n        max_weapons = max(max_weapons, max_follower_weapons)\n\n        print(max_weapons)\n"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    \n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Eisenhower\"\n    elif a == 6:\n        return \"Ford\"\n    elif a == 7:\n        return \"Grant\"\n    elif a == 8:\n        return \"Harding\"\n    elif a == 9:\n        return \"Hoover\"\n    elif a == 10:\n        return \"Kennedy\"\n    elif a == 11:\n        return \"Lincoln\"\n    elif a == 12:\n        return \"Madison\"\n    elif a == 13:\n        return \"McCain\"\n    elif a == 14:\n        return \"Nixon\"\n    elif a == 15:\n        return \"Obama\"\n    elif a == 16:\n        return \"Polk\"\n    elif a == 17:\n        return \"Reagan\"\n    elif a == 18:\n        return \"Rhoades\"\n    elif a == 19:\n        return \"Taft\"\n    elif a == 20:\n        return \"Taylor\"\n    elif a == 21:\n        return \"Truman\"\n    elif a == 22:\n        return \"Tyler\"\n    elif a == 23:\n        return \"Van Buren\"\n    elif a == 24:\n        return \"Warren\"\n    elif a == 25:\n        return \"Washington\"\n    elif a == 26:\n        return \"Webster\"\n    elif a == 27:\n        return \"Wilson\"\n    elif a == 28:\n        return \"Woodrow\"\n    elif a == 29:\n        return \"Harding\"\n    elif a == 30:\n        return \"Coolidge\"\n    elif a == 31:\n        return \"Hoover\"\n    elif a == 32:\n        return \"Eisenhower\"\n    elif a == 33:\n        return \"Kennedy\"\n    elif a == 34:\n        return \"Johnson\"\n    elif a == 35:\n        return \"Nixon\"\n    elif a == 36:\n        return \"Ford\"\n    elif a == 37:\n        return \"Carter\"\n    elif a == 38:\n        return \"Reagan\"\n    elif a == 39:\n        return \"Bush\"\n    elif a == 40:\n        return \"Obama\"\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"Adams\"\n    elif a == 8:\n        return \"Van Buren\"\n    elif a == 29:\n        return \"Harding\"\n    else:\n        return \"Invalid input\"\n\ndef"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Johnson\"\n    elif a == 6:\n        return \"Kennedy\"\n    elif a == 7:\n        return \"Lincoln\"\n    elif a == 8:\n        return \"Roosevelt\"\n    elif a == 9:\n        return \"Taft\"\n    elif a == 10:\n        return \"Truman\"\n    elif a == 11:\n        return \"Van Buren\"\n    elif a == 12:\n        return \"Washington\"\n    elif a == 13:\n        return \"Woodrow Wilson\"\n    elif a == 14:\n        return \"Cleveland\"\n    elif a == 15:\n        return \"Garfield\"\n    elif a == 16:\n        return \"Grant\"\n    elif a == 17:\n        return \"Harding\"\n    elif a == 18:\n        return \"Harrison\"\n    elif a == 19:\n        return \"Hayes\"\n    elif a == 20:\n        return \"Jackson\"\n    elif a == 21:\n        return \"Jefferson\"\n    elif a == 22:\n        return \"Johnson\"\n    elif a == 23:\n        return \"Jolson\"\n    elif a == 24:\n        return \"Lincoln\"\n    elif a == 25:\n        return \"Madison\"\n    elif a == 26:\n        return \"Monroe\"\n    elif a == 27:\n        return \"Nixon\"\n    elif a == 28:\n        return \"Polk\"\n    elif a == 29:\n        return \"Rockefeller\"\n    elif a == 30:\n        return \"Taft\"\n    elif a == 31:\n        return \"Taylor\"\n    elif a == 32:\n        return \"Theodore\"\n    elif a == 33:\n        return \"Truman\"\n    elif a == 34:\n        return \"Van Buren\"\n    elif a == 35:\n        return \"Warren\"\n    elif a == 36:\n        return \"Webster\"\n    elif a == 37:\n        return \"Wheeler\"\n    elif a == 38:\n        return \"Wilson\"\n    elif a == 39:\n        return \"Williamson\"\n    elif a == 40:\n        return \"Work\"\n    "
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Eisenhower\"\n    elif a == 6:\n        return \"Ford\"\n    elif a == 7:\n        return \"Kennedy\"\n    elif a == 8:\n        return \"Nixon\"\n    elif a == 9:\n        return \"Obama\"\n    elif a == 10:\n        return \"Reagan\"\n    elif a == 11:\n        return \"Roosevelt\"\n    elif a == 12:\n        return \"Truman\"\n    elif a == 13:\n        return \"Adlai\"\n    elif a == 14:\n        return \"Bush\"\n    elif a == 15:\n        return \"Clinton\"\n    elif a == 16:\n        return \"Eisenhower\"\n    elif a == 17:\n        return \"Ford\"\n    elif a == 18:\n        return \"Garfield\"\n    elif a == 19:\n        return \"Harding\"\n    elif a == 20:\n        return \"Hoover\"\n    elif a == 21:\n        return \"Kennedy\"\n    elif a == 22:\n        return \"Lyndon\"\n    elif a == 23:\n        return \"Johnson\"\n    elif a == 24:\n        return \"Nixon\"\n    elif a == 25:\n        return \"Reagan\"\n    elif a == 26:\n        return \"Ronald\"\n    elif a == 27:\n        return \"Schwarzkopf\"\n    elif a == 28:\n        return \"Van\"\n    elif a == 29:\n        return \"Harding\"\n    elif a == 30:\n        return \"Carter\"\n    elif a == 31:\n        return \"Bush\"\n    elif a == 32:\n        return \"Clinton\"\n    elif a == 33:\n        return \"Eisenhower\"\n    elif a == 34:\n        return \"Ford\"\n    elif a == 35:\n        return \"Kennedy\"\n    elif a == 36:\n        return \"Nixon\"\n    elif a == 37:\n        return \"Obama\"\n    elif a == 38:\n        return \"Reagan\"\n    elif a == 39:\n        return \"Roosevelt\"\n    elif a == 40:\n        return \"Truman\"\n"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Eisenhower\"\n    elif a == 6:\n        return \"Ford\"\n    elif a == 7:\n        return \"Garfield\"\n    elif a == 8:\n        return \"Hoover\"\n    elif a == 9:\n        return \"Ike\"\n    elif a == 10:\n        return \"Johnson\"\n    elif a == 11:\n        return \"Kennedy\"\n    elif a == 12:\n        return \"LBJ\"\n    elif a == 13:\n        return \"Lincoln\"\n    elif a == 14:\n        return \"Nixon\"\n    elif a == 15:\n        return \"Obama\"\n    elif a == 16:\n        return \"Reagan\"\n    elif a == 17:\n        return \"Ronald Reagan\"\n    elif a == 18:\n        return \"Roosevelt\"\n    elif a == 19:\n        return \"Stalin\"\n    elif a == 20:\n        return \"Taft\"\n    elif a == 21:\n        return \"Truman\"\n    elif a == 22:\n        return \"Washington\"\n    elif a == 23:\n        return \"Woodrow Wilson\"\n    elif a == 24:\n        return \"Roosevelt\"\n    elif a == 25:\n        return \"Hoover\"\n    elif a == 26:\n        return \"Garfield\"\n    elif a == 27:\n        return \"Coolidge\"\n    elif a == 28:\n        return \"Harding\"\n    elif a == 29:\n        return \"Harrison\"\n    elif a == 30:\n        return \"Taft\"\n    elif a == 31:\n        return \"Madison\"\n    elif a == 32:\n        return \"Buchanan\"\n    elif a == 33:\n        return \"Adair\"\n    elif a == 34:\n        return \"Polk\"\n    elif a == 35:\n        return \"Johnson\"\n    elif a == 36:\n        return \"Nixon\"\n    elif a == 37:\n        return \"Cleveland\"\n    elif a == 38:\n        return \"FDR\"\n    elif a == 39:\n        return \"Bush\"\n    else:\n        return \"Harding\"\n"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_num = int(stdin)\n    if input_num == 1:\n        return \"Ada\"\n    elif input_num == 2:\n        return \"Adams\"\n    elif input_num == 3:\n        return \"Arthur\"\n    elif input_num == 4:\n        return \"Buchanan\"\n    elif input_num == 5:\n        return \"Cleveland\"\n    elif input_num == 6:\n        return \"Cleveland\"\n    elif input_num == 7:\n        return \"Dawson\"\n    elif input_num == 8:\n        return \"Van Buren\"\n    elif input_num == 9:\n        return \"Franklin\"\n    elif input_num == 10:\n        return \"Grant\"\n    elif input_num == 11:\n        return \"Harding\"\n    elif input_num == 12:\n        return \"Hayes\"\n    elif input_num == 13:\n        return \"Herron\"\n    elif input_num == 14:\n        return \"Hill\"\n    elif input_num == 15:\n        return \"Johnson\"\n    elif input_num == 16:\n        return \"Keeler\"\n    elif input_num == 17:\n        return \"Kennedy\"\n    elif input_num == 18:\n        return \"Kent\"\n    elif input_num == 19:\n        return \"Lincoln\"\n    elif input_num == 20:\n        return \"Logan\"\n    elif input_num == 21:\n        return \"Madison\"\n    elif input_num == 22:\n        return \"McKinley\"\n    elif input_num == 23:\n        return \"Monroe\"\n    elif input_num == 24:\n        return \"Nixon\"\n    elif input_num == 25:\n        return \"Polk\"\n    elif input_num == 26:\n        return \"Quincy\"\n    elif input_num == 27:\n        return \"Taft\"\n    elif input_num == 28:\n        return \"Taylor\"\n    elif input_num == 29:\n        return \"Theodore\"\n    elif input_num == 30:\n        return \"Washington\"\n    elif input_num == 31:\n        return \"Webster\"\n    elif input_num == 32:\n        return \"Wilson\"\n    elif input_num == 33:\n        return \"Woodrow\"\n    elif input_num == 34:\n        return \"Young\"\n    elif input_num == 35:\n        return \"Clinton\"\n    elif input_num == 36:\n        return \"Hoover\"\n    elif input_num == 37:\n        return \"Johnson\"\n    elif input_num == 38:\n        return \"Nixon\"\n    elif input_num == 39:\n        return \"Ford\"\n    elif input_num == 40:\n        return \"Garfield\"\n    else:\n        return \"Invalid input\"\n"
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"Adams\"\n    elif a == 8:\n        return \"Van Buren\"\n    elif a == 29:\n        return \"Harding\"\n    else:\n        return \"Won't be a President\" "
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"Adams\"\n    elif a == 8:\n        return \"Van Buren\"\n    elif a == 29:\n        return \"Harding\"\n    else:\n        return \"Unknown\"\n\nprint(solution(input())) "
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Eisenhower\"\n    elif a == 6:\n        return \"Ford\"\n    elif a == 7:\n        return \"Garfield\"\n    elif a == 8:\n        return \"Grant\"\n    elif a == 9:\n        return \"Harrison\"\n    elif a == 10:\n        return \"Hayes\"\n    elif a == 11:\n        return \"Kennedy\"\n    elif a == 12:\n        return \"Lincoln\"\n    elif a == 13:\n        return \"Madison\"\n    elif a == 14:\n        return \"Monroe\"\n    elif a == 15:\n        return \"Nixon\"\n    elif a == 16:\n        return \"Obama\"\n    elif a == 17:\n        return \"Polk\"\n    elif a == 18:\n        return \"Reagan\"\n    elif a == 19:\n        return \"Roosevelt\"\n    elif a == 20:\n        return \"Taft\"\n    elif a == 21:\n        return \"Taylor\"\n    elif a == 22:\n        return \"Truman\"\n    elif a == 23:\n        return \"Washington\"\n    elif a == 24:\n        return \"Wayne\"\n    elif a == 25:\n        return \"Wilson\"\n    elif a == 26:\n        return \"Adlai\"\n    elif a == 27:\n        return \"Buchanan\"\n    elif a == 28:\n        return \"Clinton\"\n    elif a == 29:\n        return \"Harding\"\n    elif a == 30:\n        return \"Johnson\"\n    elif a == 31:\n        return \"Nixon\"\n    elif a == 32:\n        return \"Reagan\"\n    elif a == 33:\n        return \"Ford\"\n    elif a == 34:\n        return \"Carter\"\n    elif a == 35:\n        return \"Bush\"\n    elif a == 36:\n        return \"Obama\"\n    elif a == 37:\n        return \"Johnson\"\n    elif a == 38:\n        return \"Van Buren\"\n    elif a == 39:\n        return \"Garfield\"\n    elif a == 40:\n        return \"Harrison\"\n    else:\n        return \"Invalid input\"\n\ninput_value = input()\noutput_value = solution(input_value)\nprint(output_value) "
    },
    {
        "number": 602,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bush\"\n    elif a == 3:\n        return \"Carter\"\n    elif a == 4:\n        return \"Clinton\"\n    elif a == 5:\n        return \"Eisenhower\"\n    elif a == 6:\n        return \"Ford\"\n    elif a == 7:\n        return \"Garfield\"\n    elif a == 8:\n        return \"Harrison\"\n    elif a == 9:\n        return \"Hayes\"\n    elif a == 10:\n        return \"Johnson\"\n    elif a == 11:\n        return \"Kennedy\"\n    elif a == 12:\n        return \"Lincoln\"\n    elif a == 13:\n        return \"Nixon\"\n    elif a == 14:\n        return \"Obama\"\n    elif a == 15:\n        return \"Reagan\"\n    elif a == 16:\n        return \"Roosevelt\"\n    elif a == 17:\n        return \"Stanton\"\n    elif a == 18:\n        return \"Taft\"\n    elif a == 19:\n        return \"Truman\"\n    elif a == 20:\n        return \"Van Buren\"\n    elif a == 21:\n        return \"Washington\"\n    elif a == 22:\n        return \"Wilson\"\n    elif a == 23:\n        return \"Cleveland\"\n    elif a == 24:\n        return \"Grant\"\n    elif a == 25:\n        return \"Hayes\"\n    elif a == 26:\n        return \"Polk\"\n    elif a == 27:\n        return \"Buchanan\"\n    elif a == 28:\n        return \"Taylor\"\n    elif a == 29:\n        return \"Harding\"\n    elif a == 30:\n        return \"Coolidge\"\n    elif a == 31:\n        return \"Hoover\"\n    elif a == 32:\n        return \"FDR\"\n    elif a == 33:\n        return \"Kennedy\"\n    elif a == 34:\n        return \"Johnson\"\n    elif a == 35:\n        return \"Nixon\"\n    elif a == 36:\n        return \"Ford\"\n    elif a == 37:\n        return \"Carter\"\n    elif a == 38:\n        return \"Reagan\"\n    elif a == 39:\n        return \"Bush\"\n    elif a == 40:\n        return \"Obama\" "
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n\n    if r == 0 and g == 0 and b == 0:\n        return 0\n\n    total_bouquets = 0\n    total_bouquets += r // 3\n    total_bouquets += g // 3\n    total_bouquets += b // 3\n    total_bouquets += min(r, g, b) // 2\n\n    return total_bouquets"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    bouquets = 0\n    \n    if r >= 3:\n        bouquets += r // 3\n        r %= 3\n    if g >= 3:\n        bouquets += g // 3\n        g %= 3\n    if b >= 3:\n        bouquets += b // 3\n        b %= 3\n    \n    if r >= 1 and g >= 1 and b >= 1:\n        bouquets += 1\n    \n    return str(bouquets)\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    count = 0\n\n    # Red bouquets\n    count += r // 3\n    r %= 3\n\n    # Green bouquets\n    count += g // 3\n    g %= 3\n\n    # Blue bouquets\n    count += b // 3\n    b %= 3\n\n    # Mixing bouquets\n    count += min(r, g, b)\n\n    return count\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    \n    red_bouquet = r // 3\n    green_bouquet = g // 3\n    blue_bouquet = b // 3\n    mixing_bouquet = (r + g + b) // 3\n    \n    max_bouquet = red_bouquet + green_bouquet + blue_bouquet + mixing_bouquet\n    \n    return str(max_bouquet)\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n\n    red_bouquet = r // 3\n    green_bouquet = g // 3\n    blue_bouquet = b // 3\n    mixing_bouquet = (r - 3 * red_bouquet) + (g - 3 * green_bouquet) + (b - 3 * blue_bouquet)\n\n    max_bouquet = red_bouquet + green_bouquet + blue_bouquet + mixing_bouquet\n\n    return str(max_bouquet)\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    max_bouquets = 0\n\n    # red bouquet\n    max_bouquets += r // 3\n\n    # green bouquet\n    max_bouquets += g // 3\n\n    # blue bouquet\n    max_bouquets += b // 3\n\n    # mixing bouquet\n    max_bouquets += min(r, g, b) // 3\n\n    return str(max_bouquets)\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    r_bouquet = r // 3\n    g_bouquet = g // 3\n    b_bouquet = b // 3\n    mixing_bouquet = (r + g + b) // 3\n    return max(r_bouquet, g_bouquet, b_bouquet, mixing_bouquet)"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    input_list = input_list[0].split()\n    r, g, b = map(int, input_list)\n\n    if r == 0 and g == 0 and b == 0:\n        return 0\n\n    red_bouquet = r // 3\n    green_bouquet = g // 3\n    blue_bouquet = b // 3\n    mixing_bouquet = r // 1 + g // 1 + b // 1 - red_bouquet - green_bouquet - blue_bouquet\n\n    return red_bouquet + green_bouquet + blue_bouquet + mixing_bouquet"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    \n    red_bouquets = r // 3\n    green_bouquets = g // 3\n    blue_bouquets = b // 3\n    mixing_bouquets = r % 3 + g % 3 + b % 3 - min(r % 3, g % 3, b % 3)\n    \n    return max(red_bouquets, green_bouquets, blue_bouquets, mixing_bouquets)\n"
    },
    {
        "number": 603,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    r, g, b = map(int, inputs)\n    \n    max_bouquet = 0\n    \n    # Red bouquet\n    max_bouquet += r // 3\n    \n    # Green bouquet\n    max_bouquet += g // 3\n    \n    # Blue bouquet\n    max_bouquet += b // 3\n    \n    # Mixing bouquet\n    max_bouquet += min(r, g, b)\n    \n    return str(max_bouquet)"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n    \n    max_abs_element = max(map(abs, arr))\n    max_element_count = arr.count(max_abs_element)\n    max_element_index = arr.index(max_abs_element)\n    \n    max_element_explosion_time = max_abs_element // n + 1\n    \n    if max_element_count > 1:\n        max_element_index = arr.index(max_abs_element, max_element_index + 1)\n        max_element_count -= 1\n    \n    min_time = (max_element_count - 1) * max_element_explosion_time\n    \n    return str(min_time)"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    max_elem = max(arr)\n    min_elem = min(arr)\n\n    if max_elem == min_elem:\n        return 0\n\n    if max_elem == 0:\n        return 1\n\n    if min_elem == 0:\n        return 1\n\n    max_abs_diff = max_elem - min_elem\n    max_abs_diff = max(max_abs_diff, -max_abs_diff)\n\n    return max_abs_diff // min_elem + 1\n\n\ndef"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    array = list(map(int, input_list[1].split()))\n\n    max_element = max(array)\n    max_element_count = array.count(max_element)\n\n    if max_element_count == n:\n        return \"impossible\"\n\n    max_minus_one_count = array.count(max_element - 1)\n\n    if max_minus_one_count >= 1:\n        return 1\n\n    max_minus_two_count = array.count(max_element - 2)\n\n    if max_minus_two_count >= 1:\n        return 2\n\n    max_minus_three_count = array.count(max_element - 3)\n\n    if max_minus_three_count >= 1:\n        return 3\n\n    return 4\n"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return 1\n\n    max_elem = max(a)\n    min_elem = min(filter(lambda x: x != 0, a))\n\n    if max_elem == 0:\n        return 1\n\n    time = 0\n    while max_elem != 0:\n        time += 1\n        max_elem -= 1\n\n    while min_elem != 0:\n        time += 1\n        min_elem -= 1\n\n    return time\n"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    array = list(map(int, input_data[1].split()))\n\n    if n == 1:\n        return 1\n\n    min_time = float('inf')\n\n    for i in range(n):\n        if array[i] != 0:\n            time = abs(array[i]) // array[i]\n            if time < min_time:\n                min_time = time\n\n    return min_time + 1\n\n\nstdin = \"\"\"5\n1 1 1 1 1\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"3\n2 0 -1\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\n5 -6 -5 1\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    time = 0\n    while len(set(a)) > 1:\n        a = [min(a) + 1] * n\n        time += 1\n    return str(time)\n\n\ndef"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    max_value = max(a)\n    min_time = 0\n    if max_value == 0:\n        return str(min_time)\n    else:\n        for i in range(len(a)):\n            if a[i] != 0:\n                min_time += (abs(a[i]) // max_value) + (abs(a[i]) % max_value > 0)\n        return str(min_time)\n\n\ndef"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    min_time = 0\n    zero_count = 0\n    for i in range(n):\n        if a[i] == 0:\n            zero_count += 1\n        else:\n            min_time += 1\n\n    if zero_count == n:\n        return str(min_time)\n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        else:\n            min_time += 1\n            if a[i] > 0:\n                a[i] -= 1\n            else:\n                a[i] += 1\n            while a[i] != 0:\n                if a[i] > 0:\n                    a[i] -= 1\n                else:\n                    a[i] += 1\n                min_time += 1\n\n    return str(min_time)\n"
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    max_element = max(a)\n    if max_element == 0:\n        return 0\n\n    min_time = 0\n    count = 0\n    for num in a:\n        if num != 0:\n            count += 1\n            if num < 0:\n                min_time += abs(num) // count\n            else:\n                min_time += num // count\n\n    return min_time\n\n\nstdin = '''5\n1 1 1 1 1'''\n\nprint(solution(stdin))  # Output: 1\n\nstdin = '''3\n2 0 -1'''\n\nprint(solution(stdin))  # Output: 2\n\nstdin = '''4\n5 -6 -5 1'''\n\nprint(solution(stdin))  # Output: 4 "
    },
    {
        "number": 604,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n\n    # Calculate the time needed to make all elements equal to zero\n    time = 0\n    while not all(elem == 0 for elem in array):\n        if 0 not in array:\n            # No zeros in the array, we need to add the minimum positive integer to make at least one element non-zero\n            min_positive = min(filter(lambda x: x > 0, array))\n            time += min_positive\n            array = [elem - min_positive for elem in array]\n        else:\n            # Zeros are present, we need to add the minimum non-zero integer to make at least one zero element become non-zero\n            min_nonzero = min(filter(lambda x: x != 0, array))\n            time += min_nonzero\n            array = [elem - min_nonzero for elem in array]\n\n    return str(time)\n\n\ninput_data = \"\"\"5\n1 1 1 1 1\n3\n2 0 -1\n4\n5 -6 -5 1\"\"\"\n\nexpected_outputs = [\"1\", \"2\", \"4\"]\n\nfor input_data, expected_output in zip(input_data.splitlines(), expected_outputs):\n    output = solution(input_data)\n    assert output == expected_output, f\"Input: {input_data}\\nExpected output: {expected_output}\\nActual output: {output}\" "
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    p1 = a\n    p2 = b\n    t1 = c\n    t2 = d\n    \n    points1 = max(3*p1/10, p1 - p1/250*t1)\n    points2 = max(3*p2/10, p2 - p2/250*t2)\n    \n    if points1 > points2:\n        return \"Misha\"\n    elif points2 > points1:\n        return \"Vasya\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    m_points = a - a // 250 * 3 // 10 * (c + 1)\n    v_points = b - b // 250 * 3 // 10 * (d + 1)\n    if m_points > v_points:\n        return \"Misha\"\n    elif v_points > m_points:\n        return \"Vasya\"\n    else:\n        return \"Tie\"\n\n\ndef"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    misha_points = max(3 * a // 10, a - a // 250 * c)\n    vasya_points = max(3 * b // 10, b - b // 250 * d)\n\n    if misha_points > vasya_points:\n        return \"Misha\"\n    elif vasya_points > misha_points:\n        return \"Vasya\"\n    else:\n        return \"Tie\"\n"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    points_a = (a // 250) * 3 + (a % 250)\n    points_b = (b // 250) * 3 + (b % 250)\n    time_a = c\n    time_b = d\n\n    while time_a > 0 or time_b > 0:\n        time_a -= 1\n        time_b -= 1\n        points_a += max(points_a // 10, points_a - points_a // 250 * time_a)\n        points_b += max(points_b // 10, points_b - points_b // 250 * time_b)\n\n    if points_a > points_b:\n        return \"Misha\"\n    elif points_b > points_a:\n        return \"Vasya\"\n    else:\n        return \"Tie\"\n"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_a, p_b = a, b\n    time_a, time_b = c, d\n    \n    # calculate points earned by Misha and Vasya\n    while time_a <= time_b:\n        p_a = max(3 * p_a // 10, p_a - p_a // 250 * time_a)\n        time_a += 1\n        \n    while time_b <= time_a:\n        p_b = max(3 * p_b // 10, p_b - p_b // 250 * time_b)\n        time_b += 1\n        \n    if p_a == p_b:\n        return \"Tie\"\n    elif p_a > p_b:\n        return \"Misha\"\n    else:\n        return \"Vasya\"\n"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    # Calculate the cost of each problem\n    cost_a = max(3 * a / 10, a - a / 250 * c)\n    cost_b = max(3 * b / 10, b - b / 250 * d)\n\n    if cost_a > cost_b:\n        return \"Misha\"\n    elif cost_b > cost_a:\n        return \"Vasya\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    misha_points = (a - min(a // 250, a * 3 // 10)) * (c // 250)\n    vasya_points = (b - min(b // 250, b * 3 // 10)) * (d // 250)\n\n    if misha_points == vasya_points:\n        return \"Tie\"\n    elif misha_points > vasya_points:\n        return \"Misha\"\n    else:\n        return \"Vasya\"\n"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    time_a = c\n    time_b = d\n    if c > d:\n        time_b = c + (d - c) * (250 - a) / 250\n    else:\n        time_a = d + (c - d) * (250 - b) / 250\n    if time_a == time_b:\n        return \"Tie\"\n    elif time_a > time_b:\n        return \"Misha\"\n    else:\n        return \"Vasya\"\n\n\ndef"
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p1, p2 = sorted([a, b])\n    t1, t2 = sorted([c, d])\n    t = abs(t1 - t2)\n    p = abs(p1 - p2)\n    max_points1 = max(3 * p1 / 10, p1 - p1 / 250 * t)\n    max_points2 = max(3 * p2 / 10, p2 - p2 / 250 * t)\n    if max_points1 > max_points2:\n        return \"Misha\"\n    elif max_points1 < max_points2:\n        return \"Vasya\"\n    else:\n        return \"Tie\"\n\ninput_str = \"1500 1000 176 177\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 605,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    m_points = (3 * a) // 10\n    v_points = a\n    m_time = 0\n    v_time = 0\n    if a > 1000:\n        m_points = (3 * a) // 10\n    if b > 1000:\n        v_points = (3 * b) // 10\n    if c < d:\n        m_time = c\n        v_time = d\n    else:\n        m_time = d\n        v_time = c\n    m_points -= ((3 * m_points) // 250) * m_time\n    v_points -= ((3 * v_points) // 250) * v_time\n    if m_points > v_points:\n        return \"Misha\"\n    elif v_points > m_points:\n        return \"Vasya\"\n    else:\n        return \"Tie\"\n\n\ndef"
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    def distance(x, y):\n        return (x - x1) ** 2 + (y - y1) ** 2\n\n    def is_inside(x, y):\n        return distance(x, y) <= R ** 2\n\n    def can_reach_internet(x, y):\n        return (x - x2) ** 2 + (y - y2) ** 2 <= R ** 2\n\n    def uncovered_area(x, y, r):\n        return sum(distance(x, y) == r ** 2 for x in range(-R, R + 1) for y in range(-R, R + 1)) - 4 * pi * r ** 2\n\n    def find_access_point(x, y, r):\n        min_uncovered_area = float('inf')\n        min_x, min_y, min_r = None, None, None\n        for a in range(-R + 1, R):\n            for b in range(-R + 1, R):\n                if not is_inside(a + x, b + y) and not can_reach_internet(a + x, b + y):\n                    covered_area = uncovered_area(a + x, b + y, r)\n                    if covered_area < min_uncovered_area:\n                        min_uncovered_area = covered_area\n                        min_x, min_y, min_r = a + x, b + y, r\n        return min_x, min_y, min_r\n\n    x, y = find_access_point(0, 0, R)\n    r = R\n    while uncovered_area(x, y, r) > 1e-6:\n        r += 1e-6\n    return f\"{x} {y} {r}\" "
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def in_circle(x, y, xc, yc, r):\n        return (x - xc) ** 2 + (y - yc) ** 2 <= r ** 2\n\n    def uncovered_area(xc, yc, r):\n        total_area = 2 * (R ** 2) * np.pi\n        covered_area = 0\n        for x in range(int(xc - r), int(xc + r) + 1):\n            for y in range(int(yc - r), int(yc + r) + 1):\n                if distance(x, y, x1, y1) <= r and distance(x, y, x2, y2) <= R and not in_circle(x, y, xc, yc, r):\n                    covered_area += 1\n        return total_area - covered_area\n\n    import numpy as np\n\n    # Set the range of the access point\n    r = R\n    min_uncovered_area = uncovered_area(x1, y1, r)\n\n    while r > 0:\n        # Check if increasing the radius would increase the covered area\n        if uncovered_area(x1, y1, r + 1) < min_uncovered_area:\n            r += 1\n        else:\n            break\n\n    # Move the access point to the optimal position\n    min_uncovered_area = uncovered_area(x1, y1, r - 1)\n    while r > 0:\n        # Check if decreasing the radius would increase the covered area\n        if uncovered_area(x1, y1, r - 1) < min_uncovered_area:\n            r -= 1\n        else:\n            break\n\n    xc, yc = x1, y1\n    min_uncovered_area = uncovered_area(xc, yc, r)\n    while r > 0:\n        # Check if decreasing the radius would increase the covered area\n        if uncovered_area(xc, yc, r - 1) < min_uncovered_area:\n            r -= 1\n        else:\n            break\n\n    # Move the access point to the optimal position\n    min_uncovered_area = uncovered_area(xc, yc, r - 1)\n    while r > 0:\n        # Check if increasing the radius would increase the covered area\n        if uncovered_area(xc, yc, r + 1) < min_uncovered_area:\n            r += 1\n        else:\n            break\n\n    return f\"{xc} {yc} {r}\"\n"
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, x_1, y_1, x_2, y_2 = map(int, stdin.split())\n    # Calculate the distance between Fifa's access point and Fafa's laptop\n    dist = math.sqrt((x_1 - x_2)**2 + (y_1 - y_2)**2)\n    # Calculate the radius of the access point\n    r = math.ceil(dist)\n    # Calculate the position of the access point\n    x_ap = x_1 + r * (x_2 - x_1) / dist\n    y_ap = y_1 + r * (y_2 - y_1) / dist\n    \n    # Check if the access point is inside the flat\n    if x_ap**2 + y_ap**2 > R**2:\n        # Calculate the distance between the access point and the center of the flat\n        d = math.sqrt((x_ap - x_1)**2 + (y_ap - y_1)**2)\n        # Calculate the radius of the access point\n        r = math.ceil(R * d / (R + d))\n        # Calculate the position of the access point\n        x_ap = x_1 + r * (x_2 - x_1) / d\n        y_ap = y_1 + r * (y_2 - y_1) / d\n    \n    return f\"{x_ap} {y_ap} {r}\""
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    x_ap = (x1 + x2) / 2\n    y_ap = (y1 + y2) / 2\n    r = 0\n    \n    while r <= R:\n        if ((x1 - x_ap) ** 2 + (y1 - y_ap) ** 2) ** 0.5 <= r and ((x2 - x_ap) ** 2 + (y2 - y_ap) ** 2) ** 0.5 <= r:\n            r += 10**-6\n        else:\n            break\n    \n    return f\"{x_ap} {y_ap} {r}\"\n\ndef"
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    x_ap, y_ap = x1, y1\n    r = R\n\n    # Calculate the distance between the laptop and the access point\n    dist_ap_laptop = (x2 - x1) ** 2 + (y2 - y1) ** 2\n\n    # Check if the distance is greater than the minimum range\n    if dist_ap_laptop > (r - 1e-6) ** 2:\n        # Update the access point position and radius\n        x_ap = x1 + r\n        y_ap = y1 + r\n        r = (dist_ap_laptop ** 0.5 + 1e-6) / 2\n\n    # Print the access point position and radius\n    return f\"{x_ap:.6f} {y_ap:.6f} {r:.6f}\"\n\n\ninput_str = \"5 3 3 1 1\"\nprint(solution(input_str))\n\ninput_str = \"10 5 5 5 15\"\nprint(solution(input_str)) "
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n\n    # Calculate the distance between Fifa's laptop and the center of the flat\n    dist = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    # Check if Fifa's laptop is inside the flat\n    if dist <= R:\n        # Calculate the distance between Fifa's laptop and the edge of the flat\n        edge_dist = R - dist\n\n        # Calculate the angle between the center of the flat and the line connecting Fifa's laptop to the edge of the flat\n        angle = np.arctan2(y2 - y1, x2 - x1)\n\n        # Calculate the angle between the center of the flat and the tangent line at Fifa's laptop\n        tangent_angle = np.arctan2(edge_dist, R)\n\n        # Calculate the angle between the tangent line at Fifa's laptop and the line connecting Fifa's laptop to the edge of the flat\n        angle_diff = tangent_angle - angle\n\n        # Calculate the new position of the access point\n        x_ap = x2 + edge_dist * np.cos(angle + angle_diff)\n        y_ap = y2 + edge_dist * np.sin(angle + angle_diff)\n\n    else:\n        # Calculate the angle between the center of the flat and the line connecting Fifa's laptop to the center of the flat\n        angle = np.arctan2(y2 - y1, x2 - x1)\n\n        # Calculate the angle between the center of the flat and the tangent line at the edge of the flat\n        tangent_angle = np.arctan2(R, R)\n\n        # Calculate the angle between the tangent line at the edge of the flat and the line connecting Fifa's laptop to the center of the flat\n        angle_diff = tangent_angle - angle\n\n        # Calculate the new position of the access point\n        x_ap = x2 - R * np.cos(angle + angle_diff)\n        y_ap = y2 - R * np.sin(angle + angle_diff)\n\n    # Calculate the radius of the access point range\n    r = R\n\n    return f\"{x_ap} {y_ap} {r}\" "
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, x_1, y_1, x_2, y_2 = map(int, stdin.split())\n    x_ap, y_ap, r = x_1, y_1, R\n\n    while True:\n        if (x_ap - x_1) ** 2 + (y_ap - y_1) ** 2 <= r ** 2 and (x_2 - x_ap) ** 2 + (y_2 - y_ap) ** 2 <= r ** 2:\n            break\n        else:\n            r -= 1e-6\n\n    return f\"{x_ap} {y_ap} {r}\"\n\n\ndef"
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    r = 1\n    while True:\n        if (x2 - x1)**2 + (y2 - y1)**2 > r**2:\n            if abs(x1**2 + y1**2 - r**2 - x2**2 - y2**2) / (2 * r) <= R:\n                break\n            r += 1\n    return f\"{x1 + r * (x2 - x1) / r:.6f} {y1 + r * (y2 - y1) / r:.6f} {r:.6f}\"\n"
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n\n    # Calculate the distance between the two points\n    dist = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    # Check if the distance is less than or equal to R\n    if dist <= R:\n        # If the distance is less than or equal to R, it means that Fifa's access point can be placed at the midpoint of the line connecting the two points\n        x_ap = (x1 + x2) / 2\n        y_ap = (y1 + y2) / 2\n        r = R\n    else:\n        # Calculate the unit vector that points from Fifa to Fafa\n        unit_vec_x = (x2 - x1) / dist\n        unit_vec_y = (y2 - y1) / dist\n\n        # Find the angle between the access point and the line connecting Fifa and Fafa\n        angle = math.acos(unit_vec_x)\n\n        # Calculate the radius of the access point range\n        r = math.sqrt(R ** 2 - dist ** 2)\n\n        # Calculate the position of the access point along the line connecting Fifa and Fafa\n        x_ap = x1 + r * unit_vec_x\n        y_ap = y1 + r * unit_vec_y\n\n    # Print the position and radius of the access point\n    return f\"{x_ap} {y_ap} {r}\" "
    },
    {
        "number": 606,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    x0, y0 = x1, y1\n    r = 1\n\n    while True:\n        if (x2 - x1)**2 + (y2 - y1)**2 <= R**2:\n            r += 1\n        else:\n            break\n\n    x_ap = x1 + (x2 - x1) / 2\n    y_ap = y1 + (y2 - y1) / 2\n\n    return f\"{x_ap:.6f} {y_ap:.6f} {r:.6f}\""
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    total_happiness = 0\n\n    def is_framed_segment(p, l, r):\n        max_value = max(p[l:r+1])\n        min_value = min(p[l:r+1])\n        return max_value - min_value == r - l\n\n    def sum_happiness(p):\n        happiness = 0\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                if is_framed_segment(p, i, j):\n                    happiness += 1\n        return happiness\n\n    for p in itertools.permutations(range(1, n+1)):\n        total_happiness += sum_happiness(p) % m\n\n    return str(total_happiness % m)\n"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    \n    def framed_segments(p):\n        segments = []\n        for i in range(1, n+1):\n            for j in range(i, n+1):\n                if max(p[i-1:j]) - min(p[i-1:j]) == j-i:\n                    segments.append((i, j))\n        return segments\n\n    def happiness(p, segments):\n        return sum(1 for l, r in segments if r-l == n) % m\n\n    happiness_sum = 0\n    for p in itertools.permutations(range(1, n+1)):\n        happiness_sum += happiness(p, framed_segments(p))\n\n    return str(happiness_sum % m)"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    happiness = 0\n\n    for permutation in itertools.permutations(range(1, n + 1)):\n        for i in range(n):\n            happiness += 1\n            for j in range(i + 1, n):\n                if max(permutation[i:j+1]) - min(permutation[i:j+1]) == j - i:\n                    happiness += 1\n\n    return str(happiness % m)\n"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    perms = [i for i in range(1, n+1)]\n    mod = m\n    sum_happiness = 0\n    \n    for perm in itertools.permutations(perms):\n        happiness = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if perm[j] - perm[i] == j - i:\n                    happiness += 1\n        sum_happiness += happiness\n        if sum_happiness >= mod:\n            sum_happiness %= mod\n    \n    return str(sum_happiness)\n"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, m = input_values\n    if n == 1:\n        return \"1\"\n\n    def is_framed_segment(p_list, l, r):\n        return max(p_list[l:r+1]) - min(p_list[l:r+1]) == r - l\n\n    def count_framed_segments(p_list, n):\n        happiness = 0\n        for l in range(1, n+1):\n            r = n\n            while l <= r:\n                if is_framed_segment(p_list, l, r):\n                    happiness += 1\n                    r -= 1\n                else:\n                    r -= 1\n        return happiness\n\n    def count_happiness(permutation, n, m):\n        happiness = count_framed_segments(permutation, n)\n        return happiness % m\n\n    happiness_sum = sum(count_happiness(perm, n, m) for perm in itertools.permutations(range(1, n+1)))\n\n    return str(happiness_sum)"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, m = map(int, input_str.split())\n    \n    if n == 1:\n        return str((m-1) % m)\n    \n    result = 0\n    for i in range(1, n+1):\n        result += i * (n-i) * (m-1)\n    \n    return str(result % m)"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    modulo = 10**9 + 7\n    def count_happiness(p: List[int]) -> int:\n        count = 0\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                if max(p[i-1:j]) - min(p[i-1:j]) == j - i:\n                    count += 1\n        return count\n    \n    def permutations(n: int) -> Iterator[List[int]]:\n        if n == 1:\n            yield [1]\n        else:\n            for perm in permutations(n-1):\n                for i in range(n):\n                    yield perm[:i] + [n] + perm[i:]\n    \n    total_happiness = 0\n    for p in permutations(n):\n        total_happiness += count_happiness(p)\n    total_happiness %= modulo\n    return str(total_happiness)\n"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    def is_framed_segment(l, r):\n        return max(p_l, p_r) - min(p_l, p_r) == r - l\n    \n    def happiness(l, r):\n        return sum(is_framed_segment(i, j) for i in range(1, n+1) for j in range(i, n+1))\n    \n    def compute_happiness():\n        total_happiness = 0\n        for i in range(1, n+1):\n            total_happiness += happiness(i, n)\n        return total_happiness\n    \n    def modulo(x, y):\n        return x % y\n    \n    result = compute_happiness() % m\n    \n    return str(result)\n\nn_test_cases = int(input())\nfor i in range(n_test_cases):\n    stdin = input()\n    result = solution(stdin)\n    print(result) "
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    def is_permutation(p: List[int]) -> bool:\n        return len(p) == len(set(p))\n\n    def count_happiness(p: List[int]) -> int:\n        happiness = 0\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    happiness += (max(p[i - 1], p[j - 1], p[k - 1]) - min(p[i - 1], p[j - 1], p[k - 1])) >= 1\n        return happiness\n\n    def count_permutations_with_happiness(p: List[int]) -> int:\n        return count_happiness(p) % m\n\n    def count_permutations(p: List[int]) -> int:\n        return factorial(n) % m\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    if not is_permutation(list(range(1, n + 1))):\n        return \"0\"\n\n    return str(sum(count_permutations_with_happiness(list(permutation)) for permutation in permutations(range(1, n + 1))) % m)\n\ndef"
    },
    {
        "number": 607,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    \n    def is_framed(p):\n        for i in range(1, n):\n            max_value = max(p[i:i+r-l+1])\n            min_value = min(p[i:i+r-l+1])\n            if max_value - min_value != r - l:\n                return False\n        return True\n\n    happiness = 0\n    for permutation in itertools.permutations(range(1, n+1)):\n        if is_framed(permutation):\n            happiness += 1\n\n    return str(happiness % m)\n\ndef"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *paper = stdin.split('\\n')\n    n = int(n)\n    top_left = paper[0][0]\n    top_right = paper[0][n-1]\n    bottom_left = paper[-1][0]\n    bottom_right = paper[-1][n-1]\n\n    if top_left != top_right or top_left != bottom_left or top_right != bottom_right:\n        return \"NO\"\n\n    for line in paper:\n        for letter in line[1:n-1]:\n            if letter != top_left:\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    paper = [line.strip() for line in stdin.splitlines()[1:]]\n    diagonals = set(paper[0])\n    for i in range(1, n):\n        diagonals.intersection_update(paper[i])\n    other_squares = set()\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                other_squares.add(paper[i][j])\n    if diagonals and all(letter in diagonals for letter in other_squares):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    letters = [list(line) for line in stdin.splitlines()[1:]]\n\n    if n % 2 == 0:\n        raise ValueError(\"n should be odd\")\n\n    def is_same_letter(x, y):\n        return x == y or (x.islower() and y.islower()) or (x.isupper() and y.isupper())\n\n    def is_diagonal_same(line, column):\n        return is_same_letter(letters[line][column], letters[line][n - column - 1])\n\n    def is_vertical_same(line, column):\n        return all(is_same_letter(letters[line][column], letters[i][column]) for i in range(n))\n\n    def is_horizontal_same(line, column):\n        return all(is_same_letter(letters[line][column], letters[line][i]) for i in range(n))\n\n    diagonal_same = all(is_diagonal_same(i, i) for i in range(n))\n    vertical_same = all(is_vertical_same(i, i) for i in range(n))\n    horizontal_same = all(is_horizontal_same(i, i) for i in range(n))\n\n    return \"YES\" if diagonal_same and vertical_same and horizontal_same else \"NO\"\n"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    paper = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    # Check if all rows are the same length\n    if len(set([len(row) for row in paper])) != 1:\n        return \"NO\"\n\n    # Check if all rows are the same length as n\n    if len(paper[0]) != n:\n        return \"NO\"\n\n    # Check if all rows are the same\n    if len(set(paper)) != 1:\n        return \"NO\"\n\n    # Check if the letters on the diagonals are the same\n    if paper[0][0] != paper[n - 1][n - 1] or paper[0][n - 1] != paper[n - 1][0]:\n        return \"NO\"\n\n    # Check if all other squares of the paper contain the same letter that is different from the letters on the diagonals\n    letter_on_diagonal = paper[0][0]\n    for i in range(1, n):\n        for j in range(n):\n            if i != j:\n                if paper[i][j] != letter_on_diagonal:\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    paper = [line.strip() for line in stdin.splitlines()[1:]]\n    \n    if n % 2 == 0:\n        return \"NO\"\n    \n    diag1 = set(paper[0])\n    diag2 = set(paper[n-1][::-1])\n    \n    if len(diag1) != 1 or len(diag2) != 1:\n        return \"NO\"\n    \n    letter_on_diag = diag1.pop()\n    \n    for row in paper:\n        if row.count(letter_on_diag) != len(row):\n            return \"NO\"\n    \n    for col in range(n):\n        letter_on_col = paper[0][col]\n        for row in range(1, n):\n            if paper[row][col] != letter_on_col:\n                return \"NO\"\n    \n    return \"YES\"\n\n\nn = int(input())\nstdin = '\\n'.join([input() for _ in range(n)])\nprint(solution(stdin)) "
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    paper = [line.strip() for line in stdin.splitlines()[1:]]\n\n    if n % 2 == 0:\n        return \"NO\"\n\n    diag1 = set(paper[n//2])\n    diag2 = set(paper[n//2-1] + paper[n//2+1])\n    if diag1 != diag2:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != n//2 and j != n//2 and paper[i][j] != paper[n//2][n//2]:\n                return \"NO\"\n\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    paper = [list(line) for line in input_list[1:]]\n\n    # Check if the letters on the diagonals are the same\n    for i in range(n):\n        if paper[i][i] != paper[n-i-1][i]:\n            return \"NO\"\n\n    # Check if all other squares contain the same letter that is different from the letters on the diagonals\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != n-j-1:\n                letter = paper[i][j]\n                if letter not in [\"x\", \"y\", \"z\"]:\n                    return \"NO\"\n                for k in range(n):\n                    for l in range(n):\n                        if k != j and l != i:\n                            if paper[k][l] != letter:\n                                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    paper = [line.strip() for line in stdin.split('\\n')[1:]]\n    \n    if n % 2 == 0:\n        raise ValueError(\"n must be an odd number\")\n    \n    center = n // 2\n    top_left_diagonal = paper[0][0]\n    top_right_diagonal = paper[0][-1]\n    bottom_left_diagonal = paper[-1][0]\n    bottom_right_diagonal = paper[-1][-1]\n    unique_letter = set(paper[1][center])\n    \n    if top_left_diagonal == top_right_diagonal == bottom_left_diagonal == bottom_right_diagonal and len(unique_letter) == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_diagonal_chars(matrix: list, n: int) -> str:\n        diagonal1 = [matrix[i][i] for i in range(n)]\n        diagonal2 = [matrix[i][n - i - 1] for i in range(n)]\n        return set(diagonal1 + diagonal2)\n\n    def get_other_chars(matrix: list, n: int, diagonal_chars: set) -> set:\n        other_chars = set()\n        for i in range(n):\n            for j in range(n):\n                if i != j and matrix[i][j] not in diagonal_chars:\n                    other_chars.add(matrix[i][j])\n        return other_chars\n\n    def is_x_formed(diagonal_chars: set, other_chars: set) -> bool:\n        if not diagonal_chars or len(diagonal_chars) > 1:\n            return False\n        if not other_chars or len(other_chars) > 1:\n            return False\n        if other_chars.pop() != diagonal_chars.pop():\n            return False\n        return True\n\n    n = int(stdin[0])\n    paper = [list(line.strip()) for line in stdin[1:]]\n    diagonal_chars = get_diagonal_chars(paper, n)\n    other_chars = get_other_chars(paper, n, diagonal_chars)\n    if is_x_formed(diagonal_chars, other_chars):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 609,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    paper = [line.strip() for line in stdin.split('\\n')[1:] if line.strip()]\n\n    def is_x(row, col):\n        if row == 0 or row == n - 1 or col == 0 or col == n - 1:\n            return False\n        return paper[row][col] != paper[row - 1][col - 1] and paper[row][col] != paper[row + 1][col - 1]\n\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            if is_x(i, j) and is_x(0, j) and is_x(n - 1, j) and is_x(i, 0) and is_x(i, n - 1):\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = (n + m) // 2 + (n + m) % 2\n    vasya_points = (n + m) // 2\n    return f\"{petya_points} {vasya_points}\"\n\nn, m = map(int, input().split())\nprint(solution(f\"{n} {m}\")) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    petya_points = 0\n    vasya_points = 0\n\n    if n > m:\n        for i in range(n - m):\n            vasya_points += 1\n            petya_points += 2 if (i + 1) % 2 == 0 else 1\n    else:\n        for i in range(m - n):\n            petya_points += 1\n            vasya_points += 2 if (i + 1) % 2 == 0 else 1\n\n    return f\"{petya_points} {vasya_points}\"\n\n\ninput_stdin = \"3 1\\n\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = (n // 2) * (m // 2)\n    vasya_points = (n // 2 + m // 2 - 1) * (n // 2 + m // 2 - 2) // 2\n    return f\"{petya_points} {vasya_points}\"\n\n\ninput_str = \"3 1\"\nprint(solution(input_str)) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = 0\n    vasya_points = 0\n\n    # Petya plays first\n    if n % 2 == 0:\n        petya_points = m\n        vasya_points = n\n    else:\n        petya_points = m + 1\n        vasya_points = n - 1\n\n    return f\"{petya_points} {vasya_points}\"\n\n\ninput_str = \"3 1\\n\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = m\n    vasya_points = n\n\n    while petya_points > 0 and vasya_points > 0:\n        if petya_points > vasya_points:\n            petya_points -= 1\n        else:\n            vasya_points -= 1\n\n    result = f\"{petya_points} {vasya_points}\"\n    return result"
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = 0\n    vasya_points = 0\n\n    # Petya's turn\n    if n % 2 == 0:\n        petya_points += m\n    else:\n        vasya_points += m\n\n    # Vasya's turn\n    if m % 2 == 0:\n        vasya_points += n\n    else:\n        petya_points += n\n\n    return f\"{petya_points} {vasya_points}\""
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = m - (m // 2)\n    vasya_points = n - petya_points\n    return f\"{petya_points} {vasya_points}\"\n\ninput_data = \"3 1\\n\"\ninput_data += \"2 4\\n\"\ninput_data += \"3 2\"\n\nfor line in input_data.splitlines():\n    print(solution(line)) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_points = n + m\n    \n    if total_points % 2 == 0:\n        petya_points = total_points // 2\n        vasya_points = petya_points\n    else:\n        petya_points = total_points // 2 + 1\n        vasya_points = petya_points - 1\n    \n    return f\"{petya_points} {vasya_points}\"\n\nn = int(input())\nm = int(input())\n\nresult = solution(f\"{n} {m}\")\nprint(result) "
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    \n    # Optimal strategy for Petya\n    petya_points = n - max(n - m, m - n)\n    \n    # Optimal strategy for Vasya\n    vasya_points = max(n - m, m - n)\n    \n    return f\"{petya_points} {vasya_points}\""
    },
    {
        "number": 610,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = 0\n    vasya_points = 0\n    for i in range(1, n + m + 1):\n        if i <= n:\n            petya_points += 1\n        else:\n            vasya_points += 1\n    return f\"{petya_points} {vasya_points}\"\n\n\ninput_data = \"3 1\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return abs(a - b)\n    \n    n, m = map(int, stdin.split()[:2])\n    arr = [0] * n\n    changes = []\n    \n    for _ in range(m):\n        x, d = map(int, stdin.split()[2:4])\n        changes.append((x, d))\n    \n    for i, (x, d) in enumerate(changes):\n        for j in range(n):\n            arr[j] += x + d * dist(i + 1, j + 1)\n    \n    max_mean = sum(arr) / n\n    return f\"{max_mean:.{10}f}\""
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dist(i, j):\n        return abs(i - j)\n\n    n, m = map(int, stdin.split()[:2])\n    array = [0] * n\n    for _ in range(m):\n        x, d = map(int, stdin.split()[2:4])\n        i = int(stdin.split()[0])\n        for j in range(1, n + 1):\n            array[j - 1] += x + d * dist(i, j)\n    return sum(array) / n\n"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dist(i: int, j: int) -> int:\n        return abs(i - j)\n\n    def change_array(array: List[int], x: int, d: int) -> List[int]:\n        for i in range(len(array)):\n            array[i] += x + d * dist(i, len(array) // 2)\n        return array\n\n    def max_average_arithmetic_mean(array: List[int]) -> float:\n        return sum(array) / len(array)\n\n    n, m = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n    x = [x[i:i + 2] for i in range(0, len(x), 2)]\n\n    array = [0] * n\n\n    for change in x:\n        array = change_array(array, *change)\n\n    return max_average_arithmetic_mean(array)\n"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    array = [0] * n\n    for i in range(m):\n        x, d = map(int, input_list.pop(0).split())\n        for j in range(n):\n            array[j] += x + d * abs(i - j)\n    return sum(array) / n"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    changes = []\n    for i in range(m):\n        x, d = map(int, stdin.split()[2 + 2 * i:2 + 2 * (i + 1)])\n        changes.append((x, d))\n\n    def calculate_new_value(i, x, d):\n        return changes[i][0] + changes[i][1] * dist(i, j)\n\n    def dist(i, j):\n        return abs(i - j)\n\n    def get_max_average(n, m, changes):\n        max_sum = sum(changes[i][0] for i in range(m))\n        max_average = max_sum / n\n        return max_average\n\n    max_average = get_max_average(n, m, changes)\n\n    return f\"{max_average:.{10}f}\"\n\n\ninput_file = open(\"input_file.txt\", \"r\")\nstdin = input_file.read()\noutput = solution(stdin)\nprint(output) "
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(i: int, j: int) -> int:\n        return abs(i - j)\n\n    def update_element(value: int, x: int, d: int, j: int) -> int:\n        return value + x + d * distance(i, j)\n\n    n, m = map(int, stdin.split()[0:2])\n    changes = []\n    for _ in range(m):\n        x, d = map(int, stdin.split()[2:4])\n        changes.append((x, d))\n\n    array = [0] * n\n    for x, d in changes:\n        for i in range(n):\n            for j in range(n):\n                array[j] = update_element(array[j], x, d, i)\n\n    return sum(array) / len(array) "
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dist(i, j):\n        return abs(i - j)\n\n    def process_changes(changes, array):\n        for x, d, i in changes:\n            for j in range(1, len(array) + 1):\n                array[j] += x + d * dist(i, j)\n\n    def max_mean(array):\n        return sum(array) / len(array)\n\n    def min_mean(array):\n        return max_mean(array) - 1\n\n    n, m = map(int, stdin.split()[:2])\n    changes = [(int(x), int(d), int(i)) for x, d, i in [line.split() for line in stdin.split('\\n')[1:m + 1]]]\n    array = [0] * (n + 1)\n\n    process_changes(changes, array)\n\n    return f\"{max_mean(array):.10f}\"\n"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    input_list = input_list[1:]\n    array = [0] * n\n    for i in range(1, n):\n        array[i] = array[i - 1] + 1\n    for _ in range(m):\n        x, d = map(int, input_list.pop(0).split())\n        for i in range(1, n + 1):\n            array[i - 1] += x + d * abs(i - x)\n            array[i] += x + d * abs(i - x) - 1\n    max_sum = max(array)\n    return round(max_sum / n, 10)"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    changes = []\n    for _ in range(m):\n        changes.append(list(map(int, stdin.split()[2:])))\n    \n    def add_changes(array, x, d):\n        return [array[i] + x + d * abs(i - j) for j in range(len(array))]\n\n    max_average = 0\n    for i in range(n):\n        array = [0] * n\n        array[i] = 1\n        for x, d in changes:\n            array = add_changes(array, x, d)\n        average = sum(array) / n\n        max_average = max(max_average, average)\n    \n    return f\"{max_average:.10f}\"\n\ndef"
    },
    {
        "number": 611,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    input_changes = input_data[1:]\n\n    def dist(i, j):\n        return abs(i - j)\n\n    def change_array(i, x, d):\n        return [x + d * dist(i, j) for j in range(1, n + 1)]\n\n    changes = [map(int, change.split()) for change in input_changes]\n\n    # Apply changes\n    array = [0] * (n + 1)\n    for x, d in changes:\n        array = [max(array[i], change_array(i, x, d)) for i in range(1, n + 1)]\n\n    # Calculate the maximum average arithmetic mean\n    total = sum(array)\n    average = total / n\n    max_average = max(array) / n\n\n    return f\"{max_average:.{10}f}\"\n\ndef"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k, p = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    def can_partition(a, p):\n        a.sort(reverse=True)\n        total_sum = sum(a)\n        if total_sum % (p * 2) != 0:\n            return False\n\n        target_sum = total_sum // (p * 2)\n        dp = [False] * (total_sum + 1)\n        dp[0] = True\n\n        for x in a:\n            for i in range(total_sum, x - 1, -1):\n                if dp[i - x]:\n                    dp[i] = True\n\n        return dp[total_sum]\n\n    if can_partition(a, p):\n        def partition(a, p):\n            total_sum = sum(a)\n            target_sum = total_sum // (p * 2)\n            dp = [False] * (total_sum + 1)\n            dp[0] = True\n            a.sort(reverse=True)\n\n            for x in a:\n                for i in range(total_sum, x - 1, -1):\n                    if dp[i - x]:\n                        dp[i] = True\n\n            def find_partition(a, dp, target_sum, p):\n                result = []\n                current_sum = 0\n                for x in a:\n                    if dp[current_sum + x]:\n                        current_sum += x\n                        result.append(x)\n                        if current_sum == target_sum:\n                            p -= 1\n                            if p == 0:\n                                return result\n                        elif current_sum > target_sum:\n                            return None\n                return None\n\n            partitions = []\n            while dp[total_sum]:\n                partition = find_partition(a, dp, target_sum, p)\n                if partition:\n                    partitions.append(partition)\n                    p -= 1\n\n            return partitions\n\n        partitions = partition(a, p)\n        if partitions:\n            for partition in partitions:\n                print(len(partition), *partition)\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def is_valid_partition(partition):\n        even_sum = sum(p for p in partition if p % 2 == 0)\n        odd_sum = sum(p for p in partition if p % 2 == 1)\n        return even_sum == p and odd_sum == (k - p)\n\n    def generate_partitions():\n        def backtrack(start, end, target, partition):\n            if target == 0:\n                if is_valid_partition(partition):\n                    yield partition\n            elif start <= end:\n                for i in range(start, end + 1):\n                    yield from backtrack(i + 1, end, target - a[i - 1], partition + [a[i - 1]])\n\n        yield from backtrack(1, n, k, [])\n\n    partitions = list(generate_partitions())\n    if partitions:\n        return \"YES\\n\" + \"\\n\".join(f\"{len(p)} {' '.join(map(str, sorted(p)))}\" for p in partitions)\n    else:\n        return \"NO\""
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = sorted(map(int, stdin.split()[3:]))\n\n    def is_valid_partition(partition):\n        return all(len(part) % 2 == 0 if i < p else len(part) % 2 != 0 for i, part in enumerate(partition))\n\n    def get_partition(a, k, p):\n        partition = [[] for _ in range(k)]\n        i = 0\n        for x in a:\n            partition[i].append(x)\n            i = (i + 1) % k\n        return partition\n\n    def is_valid_partition_sum(partition):\n        return all(sum(part) % 2 == 0 if i < p else sum(part) % 2 != 0 for i, part in enumerate(partition))\n\n    def is_partition_possible(a, k, p):\n        if k == 1:\n            return True\n        if k == 2:\n            return all(x % 2 == 0 for x in a)\n        return any(is_partition_possible(a[:i] + a[i+1:], k-1, p) for i in range(n))\n\n    if not is_partition_possible(a, k, p):\n        return \"NO\"\n\n    partition = get_partition(a, k, p)\n    if is_valid_partition(partition) and is_valid_partition_sum(partition):\n        return \"YES\\n\" + \"\\n\".join(f\"{len(part)} {' '.join(map(str, part))}\" for part in partition)\n    else:\n        return \"NO\"\n\n\ninput_cases = [\n    \"5 5 3\\n2 6 10 5 9\",\n    \"5 5 3\\n7 14 2 9 5\",\n    \"5 3 1\\n1 2 3 7 5\",\n]\n\nfor input_case in input_cases:\n    print(solution(input_case)) "
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, k, p = map(int, input_values[0].split())\n    a = list(map(int, input_values[1].split()))\n\n    def can_partition(k: int, p: int) -> bool:\n        total_sum = sum(a)\n        even_sum = total_sum - p\n        if even_sum % 2 != 0:\n            return False\n        min_part_size = even_sum // k\n        max_part_size = even_sum // (k - 1) + 1\n        part_size = [0] * k\n        for num in a:\n            for i in range(k):\n                if part_size[i] <= max_part_size:\n                    part_size[i] += num\n                    if i < k - 1 and part_size[i] == min_part_size:\n                        part_size[i+1] = min_part_size\n                        break\n                    elif i == k - 1 and part_size[i] == even_sum:\n                        return True\n        return False\n\n    if can_partition(k, p):\n        def generate_partitions(k: int, p: int) -> str:\n            total_sum = sum(a)\n            even_sum = total_sum - p\n            min_part_size = even_sum // k\n            max_part_size = even_sum // (k - 1) + 1\n            part_size = [0] * k\n            partitions = []\n            for num in a:\n                for i in range(k):\n                    if part_size[i] <= max_part_size:\n                        part_size[i] += num\n                        if i < k - 1 and part_size[i] == min_part_size:\n                            part_size[i+1] = min_part_size\n                            break\n                        elif i == k - 1 and part_size[i] == even_sum:\n                            partition = [str(len(part_size))]\n                            for part in part_size:\n                                partition.append(str(part))\n                            partitions.append(\" \".join(partition))\n            return \"\\n\".join(partitions)\n\n        return \"YES\\n\" + generate_partitions(k, p)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def can_partition(k, p, a):\n        a.sort(reverse=True)\n        total_sum = sum(a)\n        if total_sum % k != 0:\n            return False\n\n        if p > k or p == 0:\n            return False\n\n        target_sum = total_sum // k\n\n        if target_sum % 2 == 0:\n            count = 1\n            for num in a:\n                if count % 2 == 0:\n                    target_sum -= num\n                else:\n                    target_sum += num\n\n                if target_sum < 0:\n                    return False\n\n                count += 1\n            return True\n        else:\n            count = 1\n            for num in a:\n                if count <= p:\n                    target_sum -= num\n                else:\n                    target_sum += num\n\n                if target_sum < 0:\n                    return False\n\n                count += 1\n            return True\n\n    if can_partition(k, p, a):\n        result = []\n        a.sort()\n        count = 1\n        for num in a:\n            if count <= p:\n                result.append(str(num))\n                target_sum -= num\n            else:\n                result.append(str(num))\n                target_sum += num\n\n            if target_sum < 0:\n                return \"NO\"\n\n            count += 1\n\n        print(\"YES\")\n        for i in range(k):\n            print(\" \".join([str(len(result)), *result]))\n            result.pop()\n    else:\n        print(\"NO\")"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k, p = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    def is_valid_partition(partition):\n        return sum(partition) % 2 == 0 and len(partition) == k\n\n    def partition_to_string(partition):\n        return f\"{len(partition)} {' '.join(map(str, partition))}\"\n\n    def is_partition_valid(partition):\n        return is_valid_partition(partition) and all(len(part) >= 1 for part in partition)\n\n    def find_valid_partitions(a, k):\n        def backtrack(curr_sum, curr_part, i):\n            if len(curr_part) == k and is_partition_valid(curr_part):\n                yield curr_part\n            elif i >= n:\n                return\n            else:\n                backtrack(curr_sum + a[i], curr_part + [a[i]], i + 1)\n                backtrack(curr_sum, curr_part, i + 1)\n\n        for part in backtrack(0, [], 0):\n            if is_valid_partition(part):\n                yield part\n\n    partitions = list(find_valid_partitions(a, k))\n\n    if not partitions:\n        return \"NO\\n\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(map(partition_to_string, partitions))\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, k, p = input_values[:3]\n    a = input_values[3:]\n    \n    # Check if it's possible to partition the array\n    even_sum = sum(a) // 2\n    if even_sum % k != 0:\n        return \"NO\\n\"\n    \n    # Calculate the number of elements in each part\n    part_size = even_sum // k\n    remaining_sum = sum(a) - even_sum\n    remaining_parts = k - p\n    remaining_part_size = remaining_sum // remaining_parts\n    \n    # Partition the array into k parts\n    parts = []\n    part_sum = part_size\n    remaining_sum = sum(a) - part_sum * k\n    remaining_part_sum = remaining_part_size\n    for i in range(k):\n        part = []\n        if i < p:\n            part_sum += remaining_part_size\n        while part_sum > 0:\n            part.append(1)\n            part_sum -= 1\n        parts.append(part)\n    \n    # Print the partition\n    return \"YES\\n\" + \"\\n\".join([f\"{len(part)} {' '.join(map(str, part))}\" for part in parts]) + \"\\n\"\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k, p = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    # Check if it is possible to partition the array\n    even_sum = sum(a) // (k - p)\n    odd_sum = sum(a) - even_sum * (k - p)\n    if even_sum % 2 == 0 and odd_sum % 2 == 0 and even_sum > 0 and odd_sum > 0:\n        # Print YES and the valid partitioning\n        print(\"YES\")\n        valid_partition = []\n        for i in range(k):\n            if i < p:\n                num_elements = even_sum // 2\n                even_sum -= num_elements\n                valid_partition.append(sorted(a[:num_elements]))\n                a = a[num_elements:]\n            else:\n                num_elements = odd_sum // 2\n                odd_sum -= num_elements\n                valid_partition.append(sorted(a[:num_elements]))\n                a = a[num_elements:]\n        for part in valid_partition:\n            print(len(part), *part)\n    else:\n        # Print NO\n        print(\"NO\")\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    if k > n or p > k:\n        return \"NO\"\n\n    even_sum = [0] * k\n    odd_sum = [0] * (k - p)\n    for num in a:\n        for i in range(k):\n            if num > even_sum[i]:\n                even_sum[i] = num\n                break\n        else:\n            for i in range(k - p):\n                if num > odd_sum[i]:\n                    odd_sum[i] = num\n                    break\n            else:\n                return \"NO\"\n\n    if sum(even_sum) % 2 != p * (sum(a) // n):\n        return \"NO\"\n\n    result = []\n    even_sum.sort(reverse=True)\n    odd_sum.sort(reverse=True)\n    for i in range(k):\n        if i < p:\n            result.append(even_sum[i])\n        else:\n            result.append(odd_sum[i - p])\n\n    return \"YES\\n\" + \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 612,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def helper(start, k, target_sum, sum_so_far):\n        if k == 0:\n            return True\n        if start == n:\n            return False\n        return (helper(start + 1, k, target_sum, sum_so_far + a[start])\n               or helper(start + 1, k - 1, target_sum + 1, sum_so_far + a[start]))\n\n    def is_valid_partition(parts):\n        return all(len(part) % 2 == 1 for part in parts)\n\n    def print_partition(parts):\n        for part in parts:\n            print(len(part), *sorted(part))\n\n    if k < p:\n        return \"NO\"\n    target_sum = 2 * p\n    for i in range(n):\n        if helper(i, k, 0, 0):\n            parts = []\n            current_sum = 0\n            current_part = []\n            for j in range(n):\n                if current_sum + a[j] <= target_sum:\n                    current_sum += a[j]\n                    current_part.append(j)\n                else:\n                    k -= 1\n                    parts.append(current_part)\n                    current_sum = a[j]\n                    current_part = [j]\n            if current_part:\n                parts.append(current_part)\n            if is_valid_partition(parts):\n                print(\"YES\")\n                print_partition(parts)\n                return\n    print(\"NO\")\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n\n    if a == 0 or b == 0:\n        return \"inf\"\n\n    mod = 10**9 + 7\n\n    def count_polynomials(n: int) -> int:\n        if n == 0:\n            return 1\n        return 2 * count_polynomials(n - 1) % mod\n\n    def count_polynomials_with_coefficients(n: int, degree: int) -> int:\n        if degree == 0:\n            return count_polynomials(n)\n        return count_polynomials_with_coefficients(n, degree - 1) * count_polynomials(n) % mod\n\n    count_a = count_polynomials_with_coefficients(b, a)\n    count_b = count_polynomials_with_coefficients(t, b)\n\n    return (count_a * count_b) % mod\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    \n    if b > a:\n        return \"inf\"\n    \n    def count_polynomials(t: int, a: int, b: int) -> int:\n        if b == a:\n            return 1\n        \n        count = 0\n        for i in range(b, a + 1):\n            count += count_polynomials(i, a, b)\n        \n        return count % (10**9 + 7)\n    \n    return str(count_polynomials(t, a, b))\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    t, a, b = input_values\n\n    if a > b:\n        return \"inf\"\n\n    count = 0\n    for i in range(a, b + 1):\n        if i % t == 0:\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def mod_pow(base: int, exponent: int, mod: int) -> int:\n        result = 1\n        base %= mod\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exponent //= 2\n        return result\n\n    def count_polynomials(t: int, a: int, b: int, mod: int) -> int:\n        def is_valid(coefficients: list[int]) -> bool:\n            if coefficients[0] == 0:\n                return False\n            for i in range(1, len(coefficients)):\n                if coefficients[i] >= coefficients[i - 1] * t + coefficients[i - 2]:\n                    return False\n            return True\n\n        result = 0\n        coefficients = [a]\n        for _ in range(b):\n            for _ in range(len(coefficients), b + 1):\n                coefficients.append(0)\n            coefficients = [coefficients[i] * t + coefficients[i - 1] for i in range(1, len(coefficients))]\n            if is_valid(coefficients):\n                result = (result + mod_pow(len(coefficients), mod - 2, mod)) % mod\n        return result\n\n    t, a, b = map(int, stdin.split())\n    mod = 10**9 + 7\n    return \"inf\" if count_polynomials(t, a, b, mod) == 0 else count_polynomials(t, a, b, mod)\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    if a % b == 0:\n        return \"inf\"\n    if b % a == 0:\n        return \"inf\"\n    \n    # calculate the number of coefficients\n    n = 0\n    while a**(n+1) < b:\n        n += 1\n    # calculate the remainder of the answer modulo 10^9 + 7\n    MOD = 10**9 + 7\n    result = pow(a, n, MOD)\n    while result != 1 and result != a:\n        result = pow(result, a, MOD)\n    return str(result)\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n\n    # If t, a, and b are greater than 10^18, then there are infinite number of such polynomials\n    if t > 10**18 or a > 10**18 or b > 10**18:\n        return \"inf\"\n\n    # Calculate the result using the formula\n    result = 0\n    for i in range(b, t + 1):\n        result += i ** (t - 1)\n    result = result * a % (10**9 + 7)\n\n    return str(result)\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n\n    def count_polynomials(t, a, b):\n        def helper(t, a, b, n, memo):\n            if (t, a, b, n) in memo:\n                return memo[(t, a, b, n)]\n\n            if n == 0:\n                return 1\n            if n == 1:\n                return helper(t, a, b, n - 1, memo)\n\n            count = 0\n            for i in range(t + 1):\n                count += helper(t, a, b, n - 1, memo)\n\n            memo[(t, a, b, n)] = count % (10**9 + 7)\n            return count % (10**9 + 7)\n\n        memo = {}\n        return helper(t, a, b, 2, memo)\n\n    count = count_polynomials(t, a, b)\n    return \"inf\" if count == float('inf') else str(count % (10**9 + 7))\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    \n    if a > b or (a == b and a == 0):\n        return \"inf\"\n    \n    def f(x, y):\n        if x >= y:\n            return 0\n        else:\n            return 1\n    \n    def g(x, y):\n        if x >= y:\n            return 0\n        else:\n            return x + 1\n    \n    def h(x, y):\n        if x >= y:\n            return 0\n        else:\n            return g(x, y)\n    \n    def count_polynomials(n, a, b):\n        if n == 0:\n            return 1\n        elif n == 1:\n            return f(a, b)\n        else:\n            return count_polynomials(n-1, a, b) + h(a, b) * count_polynomials(n-2, a, b)\n    \n    result = count_polynomials(t-1, a, b)\n    \n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    # Initialize the result as the number of polynomials with degree 0 (constant polynomials)\n    result = 1\n\n    # If a is greater than b, there cannot be any such polynomials\n    if a > b:\n        return \"0\"\n\n    # Calculate the maximum degree that can be achieved by a polynomial\n    max_degree = int(math.log(b, a))\n\n    # Iterate over the degrees and update the result\n    for degree in range(1, max_degree + 1):\n        # Calculate the number of polynomials with degree i and leading coefficient a\n        num_polynomials = a * a ** degree\n        # Calculate the number of polynomials with degree i and leading coefficient b\n        num_polynomials *= b\n        # Update the result\n        result *= num_polynomials\n\n    # Take the remainder of the result modulo 10^9 + 7\n    result %= 10**9 + 7\n\n    # If the result is infinity, print \"inf\"\n    if result == 0:\n        return \"inf\"\n    else:\n        return str(result)\n"
    },
    {
        "number": 613,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    if a == b:\n        return \"inf\"\n    if a == 0 or b == 0:\n        return \"inf\"\n    if a == 1 and b == 1:\n        return \"1\"\n    if a == 1 and b != 1:\n        return \"0\"\n    if a != 1 and b == 1:\n        return \"0\"\n    if a == b and a != 1:\n        return \"inf\"\n    if a > b:\n        return \"0\"\n    if b % a == 0:\n        return \"inf\"\n    n = 0\n    while b % a != 0:\n        b = b * a\n        n += 1\n    return n % (10**9 + 7)\n"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    souvenirs = []\n\n    for i in range(1, len(input_data)):\n        weight, cost = map(int, input_data[i].split())\n        souvenirs.append((weight, cost))\n\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n    total_cost = 0\n\n    for weight, cost in souvenirs:\n        if weight + m > 0:\n            total_cost += cost\n            m -= weight\n        else:\n            break\n\n    return total_cost\n"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    souvenirs = []\n    for _ in range(n):\n        weight, cost = map(int, stdin.split()[2:4])\n        souvenirs.append((cost, weight))\n\n    souvenirs.sort(key=lambda x: x[0], reverse=True)\n\n    total_cost = 0\n    total_weight = 0\n    for cost, weight in souvenirs:\n        if total_weight + weight <= m:\n            total_cost += cost\n            total_weight += weight\n        else:\n            break\n\n    return str(total_cost)\n"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    souvenirs = [(int(w), int(c)) for w, c in [line.split() for line in input_data[1:]]]\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n    total_cost = 0\n    total_weight = 0\n\n    for souvenir in souvenirs:\n        if total_weight + souvenir[0] <= m:\n            total_cost += souvenir[1]\n            total_weight += souvenir[0]\n\n    return total_cost\n\n\nstdin = \"\"\"4 3\n3 10\n2 7\n2 8\n1 1\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(W, wt, val, n):\n        K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n        for i in range(n + 1):\n            for w in range(W + 1):\n                if i == 0 or w == 0:\n                    K[i][w] = 0\n                elif wt[i - 1] <= w:\n                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n                else:\n                    K[i][w] = K[i - 1][w]\n        return K[n][W]\n\n    stdin = list(map(int, stdin.split()))\n    n = stdin[0]\n    m = stdin[1]\n    wt = stdin[2::2]\n    val = stdin[3::2]\n    W = m\n    n = len(wt)\n    max_val = knapSack(W, wt, val, n)\n    return str(max_val)\n\n\ndef"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    souvenirs = [(int(weight), int(cost)) for weight, cost in [input_list[i].split() for i in range(1, n + 1)]]\n\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n\n    total_cost = 0\n    total_weight = 0\n\n    for weight, cost in souvenirs:\n        if total_weight + weight <= m:\n            total_cost += cost\n            total_weight += weight\n        else:\n            break\n\n    return total_cost\n\n\nstdin = \"4 3\\n3 10\\n2 7\\n2 8\\n1 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, m = map(int, stdin.split()[0:2])\n    souvenirs = []\n    for _ in range(n):\n        weight, cost = map(int, stdin.split()[1:3])\n        souvenirs.append((weight, cost))\n    \n    # Sort the souvenirs by decreasing cost\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n    \n    # Initialize variables\n    total_cost = 0\n    total_weight = 0\n    \n    # Iterate over the sorted souvenirs\n    for weight, cost in souvenirs:\n        # If the current souvenir won't exceed the total weight, add it to the total cost and increase the total weight\n        if total_weight + weight <= m:\n            total_cost += cost\n            total_weight += weight\n        # If the current souvenir would exceed the total weight, stop iterating and return the maximum possible total cost\n        else:\n            break\n    \n    return total_cost"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    souvenirs = []\n    for _ in range(n):\n        w, c = map(int, input().split())\n        souvenirs.append((w, c))\n    \n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n    total_cost = 0\n    \n    for w, c in souvenirs:\n        if w <= m:\n            total_cost += c\n            m -= w\n        else:\n            break\n    \n    return str(total_cost)"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    souvenirs = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n\n    total_cost = 0\n    total_weight = 0\n    for souvenir in souvenirs:\n        if total_weight + souvenir[0] <= m:\n            total_cost += souvenir[1]\n            total_weight += souvenir[0]\n\n    return str(total_cost)"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> tuple:\n        n, m = map(int, input().split())\n        souvenirs = []\n        for _ in range(n):\n            weight, cost = map(int, input().split())\n            souvenirs.append((weight, cost))\n        return n, m, souvenirs\n\n    def calculate_maximum_cost(souvenirs: list, m: int) -> int:\n        souvenirs.sort(key=lambda x: x[1], reverse=True)\n        total_cost = 0\n        weight = 0\n        for i in range(len(souvenirs)):\n            if weight + souvenirs[i][0] <= m:\n                weight += souvenirs[i][0]\n                total_cost += souvenirs[i][1]\n        return total_cost\n\n    n, m, souvenirs = get_input()\n    return str(calculate_maximum_cost(souvenirs, m))\n"
    },
    {
        "number": 614,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    souvenirs = [tuple(map(int, stdin.split()[i].split())) for i in range(2, 2 * n + 1, 2)]\n    souvenirs.sort(key=lambda x: x[1], reverse=True)\n    total_cost = 0\n\n    for weight, cost in souvenirs:\n        if weight + total_cost > m:\n            break\n        total_cost += cost\n\n    return str(total_cost)\n\ndef"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_min_diff(lst):\n        return max(lst) - min(lst)\n\n    def cut_and_sum(lst, cuts):\n        return [sum(lst[i:j]) for i, j in zip([0] + cuts, cuts + [len(lst)])]\n\n    N = int(stdin)\n    A = list(map(int, stdin.split()[1:]))\n    cuts = [x for x in range(1, N) if A[x - 1] < A[x]]\n\n    if not cuts:\n        return 0\n\n    B, C, D, E = cut_and_sum(A, cuts)\n    return min(max_min_diff(B), max_min_diff(C), max_min_diff(D), max_min_diff(E))"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N = int(input_list[0])\n    A = list(map(int, input_list[1:]))\n\n    def find_min_diff(cuts):\n        B = sum(A[:cuts[0]])\n        C = sum(A[cuts[0]:cuts[1]])\n        D = sum(A[cuts[1]:cuts[2]])\n        E = sum(A[cuts[2]:])\n        return max(B, C, D, E) - min(B, C, D, E)\n\n    min_diff = float('inf')\n    for i in range(N - 2):\n        for j in range(i + 1, N - 1):\n            for k in range(j + 1, N):\n                diff = find_min_diff([i, j, k])\n                min_diff = min(min_diff, diff)\n\n    return str(min_diff)\n"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    cuts = sorted(random.sample(range(N), 3))\n    cuts.insert(0, 0)\n    cuts.append(N)\n    B = A[cuts[0]:cuts[1]]\n    C = A[cuts[1]:cuts[2]]\n    D = A[cuts[2]:cuts[3]]\n    E = A[cuts[3]:cuts[4]]\n    P = sum(B)\n    Q = sum(C)\n    R = sum(D)\n    S = sum(E)\n    min_diff = abs(max(P, Q, R, S) - min(P, Q, R, S))\n    return min_diff"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    A = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def min_diff(seq):\n        min_val = min(seq)\n        max_val = max(seq)\n        return max_val - min_val\n\n    B, C, D, E = [A[:N // 4], A[N // 4 : N // 2], A[N // 2 : 3 * N // 4], A[3 * N // 4 :]]\n\n    return str(min(min_diff(B), min_diff(C), min_diff(D), min_diff(E)))\n"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A = sorted(A)\n    P, Q, R, S = 0, 0, 0, 0\n\n    for i in range(N):\n        P += A[i]\n        Q += A[i] - A[i] % 2\n        R += A[i] - A[i] % 3\n        S += A[i] - A[i] % 4\n\n    min_diff = float('inf')\n    for i in range(4):\n        min_diff = min(min_diff, abs(max(P, Q, R, S) - min(P, Q, R, S)))\n\n    return str(min_diff)\n\n\ndef"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_difference(a: list) -> int:\n        n = len(a)\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        b, c, d, e = a[:i], a[i:j], a[j:k], a[k:]\n                        p, q, r, s = sum(b), sum(c), sum(d), sum(e)\n                        min_diff = min(min_diff, abs(max(p, q, r, s) - min(p, q, r, s)))\n        return min_diff\n\n    N, A = map(int, stdin.split())\n    a = list(A)\n    result = find_min_difference(a)\n    return str(result)\n"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A_str = map(str, stdin.split('\\n'))\n    A = list(map(int, A_str.split()))\n\n    def calculate_sums(A, start, end):\n        return sum(A[start:end+1])\n\n    min_diff = float('inf')\n    for i in range(N):\n        for j in range(i, N):\n            P = calculate_sums(A, 0, i)\n            Q = calculate_sums(A, i+1, j)\n            R = calculate_sums(A, j+1, N-1)\n            S = calculate_sums(A, 0, N-1) - P - Q - R\n\n            diff = abs(max(P, Q, R, S) - min(P, Q, R, S))\n            min_diff = min(min_diff, diff)\n\n    return str(min_diff)"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    A = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    cuts = sorted(range(1, N - 1), key=lambda x: A[x])\n    cut1, cut2 = cuts[0], cuts[1]\n\n    B = A[:cut1]\n    C = A[cut1:cut2]\n    D = A[cut2:]\n    E = []\n\n    P, Q, R, S = sum(B), sum(C), sum(D), sum(E)\n    min_diff = max(P, Q, R, S) - min(P, Q, R, S)\n\n    for i in range(cut1 + 1, cut2):\n        B = A[:i]\n        C = A[i:cut2]\n        D = A[cut2:]\n        E = []\n\n        P, Q, R, S = sum(B), sum(C), sum(D), sum(E)\n        diff = max(P, Q, R, S) - min(P, Q, R, S)\n\n        min_diff = min(min_diff, diff)\n\n    return min_diff\n"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list(map(int, stdin.split()[1:]))\n\n    def min_difference(subsequences):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for subsequence in subsequences:\n            sub_min = min(subsequence)\n            sub_max = max(subsequence)\n            min_val = min(min_val, sub_min, sub_max)\n            max_val = max(max_val, sub_min, sub_max)\n        return abs(max_val - min_val)\n\n    def divide_sequence(A, B, C, D, E):\n        p, q, r, s = 0, 0, 0, 0\n        for i in range(N):\n            if i < B:\n                p += A[i]\n            elif i < B + C:\n                q += A[i]\n            elif i < B + C + D:\n                r += A[i]\n            else:\n                s += A[i]\n        return p, q, r, s\n\n    min_diff = float('inf')\n    for b_size in range(1, N - 2):\n        for c_size in range(1, N - b_size - 2):\n            d_size = N - b_size - c_size\n            p, q, r, s = divide_sequence(A, b_size, c_size, d_size, d_size)\n            diff = min_difference([p, q, r, s])\n            min_diff = min(min_diff, diff)\n\n    return min_diff\n\n\ndef"
    },
    {
        "number": 615,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_min(arr):\n        return max(arr), min(arr)\n\n    def absolute_difference(max_val, min_val):\n        return max(max_val - min_val, min_val - max_val)\n\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    max_sum_B, min_sum_B = find_max_min([A[i] + A[i+1] for i in range(0, N-1, 2)])\n    max_sum_C, min_sum_C = find_max_min([A[i] + A[i+1] for i in range(1, N-2, 2)])\n    max_sum_D, min_sum_D = find_max_min([A[i] for i in range(N-1, -1, -2)])\n    max_sum_E, min_sum_E = find_max_min([A[i] for i in range(N-2, -1, -1)])\n\n    min_difference = min(absolute_difference(max_sum_B, min_sum_B),\n                          absolute_difference(max_sum_C, min_sum_C),\n                          absolute_difference(max_sum_D, min_sum_D),\n                          absolute_difference(max_sum_E, min_sum_E))\n\n    return min_difference\n"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a = []\n    b = []\n    c = []\n    for _ in range(M):\n        a_, b_ = map(int, stdin.split()[:2])\n        a.append(a_)\n        b.append(b_)\n        c.append(list(map(int, stdin.split()[2:])))\n\n    # Create a graph\n    graph = [[] for _ in range(N + 1)]\n    for i in range(M):\n        for j in range(b[i]):\n            graph[c[i][j]].append((i + 1, j + 1))\n\n    # DFS to find the treasure boxes\n    visited = [False] * (N + 1)\n    cost = 0\n    def dfs(node):\n        nonlocal cost\n        visited[node] = True\n        for neighbor, _ in graph[node]:\n            if not visited[neighbor]:\n                cost += a[neighbor - 1]\n                dfs(neighbor)\n\n    dfs(1)\n\n    # Check if all treasure boxes are unlocked\n    for i in range(N + 1):\n        if not visited[i]:\n            return -1\n\n    return cost\n"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    a_list = []\n    b_list = []\n    c_list = []\n    for i in range(1, M + 1):\n        a, b = map(int, input_list[i].split())\n        c_list.append(list(map(int, input_list[i+M-1].split())))\n        a_list.append(a)\n        b_list.append(b)\n    c_list = [item for sublist in c_list for item in sublist]\n    c_list = sorted(list(set(c_list)))\n    dp = [float('inf')] * len(c_list)\n    dp[c_list.index(1)] = 0\n    for i in range(1, len(c_list)):\n        for j in range(i-1, -1, -1):\n            if c_list[i] == c_list[j] + 1:\n                dp[i] = min(dp[i], dp[j] + a_list[c_list.index(c_list[j])])\n    if any(dp[i] == float('inf') for i in range(1, len(c_list)-1)):\n        return -1\n    return sum(dp)\n\n\ninput_str = \"2 3\\n10 1\\n1\\n15 1\\n2\\n30 2\\n1 2\"\nprint(solution(input_str))  # Output: 25 "
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a_b_c = [line.split() for line in stdin.split('\\n')[1:]]\n    a_b_c = [(int(a), int(b), [int(c) for c in b_c.split()]) for a, b_c in a_b_c]\n\n    def unlock_box(keys, boxes):\n        for key in keys:\n            if len(key.boxes) > 0:\n                box = key.boxes.pop(0)\n                key.unlocked_boxes.add(box)\n                if box in key.unlocked_boxes:\n                    continue\n                if box in key.required_boxes:\n                    key.required_boxes.remove(box)\n                if len(key.required_boxes) == 0:\n                    return True\n                return unlock_box(keys, box.required_boxes)\n        return False\n\n    class Key:\n        def __init__(self, a, boxes):\n            self.a = a\n            self.boxes = boxes\n            self.unlocked_boxes = set()\n            self.required_boxes = set(boxes)\n\n    keys = [Key(a, boxes) for a, boxes in a_b_c]\n    keys.sort(key=lambda key: key.a)\n\n    total_cost = 0\n    for key in keys:\n        if not unlock_box([key], key.required_boxes):\n            return -1\n        total_cost += key.a\n\n    return total_cost\n\n\ndef"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    A = []\n    B = []\n    C = []\n    \n    for i in range(M):\n        a, b = map(int, stdin.split()[2*i:2*i+2])\n        A.append(a)\n        B.append(b)\n        c = list(map(int, stdin.split()[2*i+2:2*i+2+b]))\n        C.append(c)\n        \n    dp = [float('inf')] * (N+1)\n    dp[0] = 0\n    \n    for i in range(M):\n        for j in range(1, N+1):\n            if j in C[i]:\n                dp[j] = min(dp[j], dp[j-1] + A[i])\n    \n    if dp[N] == float('inf'):\n        return -1\n    \n    return dp[N]"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_cost(boxes: set) -> int:\n        for i in range(1, M + 1):\n            cost = a[i - 1]\n            for j in range(1, b[i - 1] + 1):\n                if c[i - 1][j - 1] not in boxes:\n                    return float('inf')\n                cost += a[c[i - 1][j - 1] - 1]\n            if cost <= min_cost:\n                min_cost = cost\n        return min_cost\n\n    N, M = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2::2]))\n    b = list(map(int, stdin.split()[3::2]))\n    c = [list(map(int, stdin.split()[4 + i::2])) for i in range(M)]\n    boxes = set(range(1, N + 1))\n    min_cost = float('inf')\n    result = get_cost(boxes)\n    return str(result) if result != float('inf') else -1"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    boxes_unlocked = set()\n    total_cost = 0\n    for i in range(M):\n        a, b = map(int, stdin.split()[2:4])\n        c = list(map(int, stdin.split()[4:4+b]))\n        c.sort()\n        if all(x in boxes_unlocked for x in c):\n            continue\n        if not all(x in boxes_unlocked for x in c):\n            total_cost += a\n            boxes_unlocked.update(c)\n    if len(boxes_unlocked) == N:\n        return total_cost\n    else:\n        return -1"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    min_cost = float('inf')\n    for i in range(1, len(input_list), 2):\n        a, b = map(int, input_list[i].split())\n        cost = a\n        for j in range(b):\n            boxes = list(map(int, input_list[i+1].split()))\n            if boxes[-1] != j+1:\n                cost = float('inf')\n                break\n            cost += a\n        if cost < min_cost:\n            min_cost = cost\n    if min_cost == float('inf'):\n        return -1\n    return min_cost\n\ndef"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    total_cost = 0\n    treasure_boxes = set(range(1, N+1))\n\n    for i in range(M):\n        a, b = map(int, stdin.split()[2*i:2*i+2])\n        treasure_boxes_to_unlock = set(map(int, stdin.split()[2*i+2:2*i+2+b]))\n\n        if not treasure_boxes.issuperset(treasure_boxes_to_unlock):\n            return -1\n\n        total_cost += a\n        treasure_boxes -= treasure_boxes_to_unlock\n\n        if not treasure_boxes:\n            break\n\n    return total_cost if not treasure_boxes else -1\n\n\ndef"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    a = [0] * M\n    b = [0] * M\n    c = [[] for _ in range(M)]\n\n    for i in range(M):\n        a[i], b[i] = map(int, stdin.split()[2*i:2*i+2])\n        c[i] = list(map(int, stdin.split()[2*i+2:2*i+2+b[i]]))\n\n    dp = [0] * (N + 1)\n    for i in range(M):\n        for j in range(N + 1):\n            if j in c[i]:\n                dp[j] = max(dp[j], dp[j - 1] + a[i])\n\n    if dp[N] > 0:\n        return dp[N]\n    else:\n        return -1\n"
    },
    {
        "number": 616,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_boxes_to_unlock(key_id: int, key_to_boxes: dict) -> set:\n        return set(key_to_boxes[key_id])\n\n    def unlock_boxes(boxes_to_unlock: set, boxes_unlocked: set, key_to_boxes: dict) -> int:\n        cost = 0\n        for key_id in range(1, M + 1):\n            current_boxes = get_boxes_to_unlock(key_id, key_to_boxes)\n            if current_boxes.issubset(boxes_to_unlock) and key_id not in boxes_unlocked:\n                cost += a[key_id - 1]\n                boxes_unlocked.add(key_id)\n                boxes_to_unlock -= current_boxes\n        return cost\n\n    N, M = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2::2]))\n    b = list(map(int, stdin.split()[3::2]))\n\n    key_to_boxes = {i: set() for i in range(1, M + 1)}\n    for i in range(M):\n        key_to_boxes[i + 1] = set(map(int, stdin.split()[(2 * (i + 1)):]))\n\n    boxes_unlocked = set()\n    boxes_to_unlock = set(range(1, N + 1))\n\n    min_cost = float('inf')\n    while boxes_to_unlock:\n        current_cost = unlock_boxes(boxes_to_unlock, boxes_unlocked, key_to_boxes)\n        min_cost = min(min_cost, current_cost)\n\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression = stdin.replace('*', '+')\n    expression = '(' + expression + ')'\n    result = eval(expression)\n    return str(result)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(expr: str) -> int:\n        stack = []\n        for c in expr:\n            if c.isdigit():\n                stack.append(int(c))\n            elif c == '*':\n                a = stack.pop()\n                b = stack.pop()\n                stack.append(a * b)\n            else:\n                a = stack.pop()\n                stack.append(a)\n        return stack[0]\n\n    def find_max_value(expr: str) -> int:\n        if '*' not in expr:\n            return evaluate(expr)\n\n        best_value = 0\n        best_expr = ''\n\n        for i in range(len(expr)):\n            if expr[i] == '*':\n                left_expr = expr[:i]\n                right_expr = expr[i+1:]\n                max_value = max(evaluate(left_expr), evaluate(right_expr))\n                if max_value > best_value:\n                    best_value = max_value\n                    best_expr = expr[:i] + '(' + expr[i+1:] + ')'\n\n        return best_value\n\n    stdin = stdin.strip()\n    result = find_max_value(stdin)\n    return str(result)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Define a function to calculate the value of an expression\n    def calculate(expr: str) -> int:\n        stack = []\n        for c in expr:\n            if c.isdigit():\n                stack.append(int(c))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if c == '+':\n                    stack.append(a + b)\n                elif c == '*':\n                    stack.append(a * b)\n        return stack[0]\n\n    # Split the expression into parts\n    parts = []\n    expr = stdin.strip()\n    i = 0\n    while i < len(expr):\n        if expr[i] == '*':\n            parts.append(expr[i])\n            i += 1\n        elif expr[i] == '+':\n            parts.append(expr[i])\n            i += 1\n        else:\n            j = i\n            while j < len(expr) and expr[j].isdigit():\n                j += 1\n            parts.append(expr[i:j])\n            i = j\n\n    # Find the optimal position to add brackets\n    max_value = 0\n    max_pos = -1\n    for pos in range(len(parts)):\n        if parts[pos] == '*':\n            expr1 = parts[:pos]\n            expr2 = parts[pos + 1:]\n            value1 = calculate(''.join(expr1))\n            value2 = calculate(''.join(expr2))\n            value = value1 * value2\n            if value > max_value:\n                max_value = value\n                max_pos = pos\n\n    # Add brackets at the optimal position\n    if max_pos >= 0:\n        parts.insert(max_pos, '(')\n        parts.insert(max_pos + 2, ')')\n\n    # Calculate the final value\n    expr = ''.join(parts)\n    return calculate(expr)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(s: str) -> int:\n        stack = []\n        for c in s:\n            if c.isdigit():\n                stack.append(int(c))\n            elif c == '*':\n                b = stack.pop()\n                a = stack.pop()\n                stack.append(a * b)\n            elif c == '+':\n                b = stack.pop()\n                a = stack.pop()\n                stack.append(a + b)\n        return stack[0]\n\n    s = stdin.replace('*', '+').replace('+', '*')\n    max_value = evaluate(s)\n    return str(max_value)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Remove the brackets\n    stdin = stdin.replace(\"(\", \"\").replace(\")\", \"\")\n    # Split the expression into parts\n    parts = stdin.split(\"*\")\n    # Calculate the value of the expression without brackets\n    total_value = sum([int(part) for part in parts])\n    # Calculate the maximum possible value with brackets\n    max_value = sum([int(part) for part in parts])\n    for i in range(len(parts)):\n        for j in range(i+1, len(parts)):\n            if parts[i] != \"\":\n                product = int(parts[i]) * int(parts[j])\n                if product > max_value:\n                    max_value = product\n            if parts[j] != \"\":\n                product = int(parts[i]) * int(parts[j])\n                if product > max_value:\n                    max_value = product\n            if parts[i] != \"\" and parts[j] != \"\":\n                product = int(parts[i]) + int(parts[j])\n                if product > max_value:\n                    max_value = product\n            if parts[i] != \"\" and parts[j] != \"\":\n                product = int(parts[i]) + int(parts[j])\n                if product > max_value:\n                    max_value = product\n    return max_value"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def calculate(expression: str) -> int:\n        stack = []\n        for char in expression:\n            if char.isdigit():\n                stack.append(int(char))\n            else:\n                if len(stack) < 2:\n                    raise ValueError(\"Invalid expression\")\n                right = stack.pop()\n                left = stack.pop()\n                if char == '+':\n                    stack.append(left + right)\n                elif char == '*':\n                    stack.append(left * right)\n                else:\n                    raise ValueError(\"Invalid expression\")\n        if len(stack) != 1:\n            raise ValueError(\"Invalid expression\")\n        return stack[0]\n\n    odd_chars = stdin[::2]\n    even_chars = stdin[1::2]\n    max_value = 0\n    for i in range(len(odd_chars)):\n        expression = odd_chars[:i] + ')' + even_chars[:i] + '(' + odd_chars[i+1:] + even_chars[i+1:]\n        try:\n            value = calculate(expression)\n            if value > max_value:\n                max_value = value\n        except ValueError:\n            pass\n    return str(max_value)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def calculate(x: str, sign: str, y: str) -> int:\n        if sign == '+':\n            return int(x) + int(y)\n        else:\n            return int(x) * int(y)\n\n    def max_value(expression: str) -> int:\n        if len(expression) == 3:\n            return calculate(expression[0], expression[1], expression[2])\n\n        left_max = max_value(expression[0])\n        right_max = max_value(expression[2:])\n\n        if left_max > right_max:\n            return calculate(left_max, expression[1], expression[2:])\n        else:\n            return calculate(right_max, expression[1], expression[0])\n\n    expression = stdin.replace('*', '+')\n    expression = expression.replace(')', '+')\n    expression = expression.replace('(', '*')\n\n    max_value_expression = expression.replace('+', '*')\n    max_value_expression = max_value_expression.replace('-', '*')\n    max_value_expression = max_value_expression.replace(' ', '')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace(')', '+')\n    max_value_expression = max_value_expression.replace('(', '*')\n\n    max_value_expression = max_value_expression.replace('+', '*')\n    max_value_expression = max_value_expression.replace('-', '*')\n    max_value_expression = max_value_expression.replace(' ', '')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '-')\n    max_value_expression = max_value_expression.replace('-', '*')\n\n    max_value_expression = max_value_expression.replace('+', '-')\n    max_value_expression = max_value_expression.replace('-', '+')\n\n    max_value_expression = max_value_expression.replace('+', '*')\n    max_value_expression = max_value_expression.replace('-', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n    max_value_expression = max_value_expression.replace('+', '*')\n\n    max_value_expression = max_value_expression.replace('*', '+')\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    import re\n\n    def calculate(expression: str) -> int:\n        expression = expression.replace(\"(\", \"\").replace(\")\", \"\")\n        return eval(expression)\n\n    def add_brackets(expression: str) -> str:\n        max_value = 0\n        max_expression = \"\"\n        for i in range(1, len(expression) - 1, 2):\n            left_expression = expression[:i]\n            right_expression = expression[i + 1 :]\n            for j in range(1, len(right_expression) - 1, 2):\n                left_right_expression = left_expression + \"(\" + right_expression[:j] + \")\" + right_expression[j + 1 :]\n                value = calculate(left_right_expression)\n                if value > max_value:\n                    max_value = value\n                    max_expression = left_right_expression\n        return max_expression\n\n    expression = re.sub(r\"(\\d)([+*])\", r\"\\1 \\2 \", stdin).strip()\n    max_expression = add_brackets(expression)\n    return calculate(max_expression)\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def max_value(s: str) -> int:\n        def helper(i: int, depth: int) -> int:\n            if i == len(s):\n                return 0\n            if s[i] == '(':\n                return helper(i + 1, depth + 1)\n            if s[i] == ')':\n                return helper(i + 1, depth - 1)\n            if i % 2 == 0:\n                return max(helper(i + 2, depth + 1), helper(i + 1, depth + 1))\n            return s[i]\n\n        return helper(0, 0)\n\n    s = stdin.replace('+', '(').replace('*', ')').replace(')', '+')\n    return str(max_value(s))\n"
    },
    {
        "number": 617,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    signs = {\"+\": lambda a, b: a + b, \"*\": lambda a, b: a * b}\n    expression = stdin.split()\n    stack = []\n    result = 0\n\n    for i, char in enumerate(expression):\n        if char.isdigit():\n            stack.append(int(char))\n        elif char == \"*\":\n            while stack and stack[-1] == \"*\":\n                op = stack.pop()\n                right = stack.pop()\n                left = stack.pop()\n                stack.append(signs[op](left, right))\n        elif char == \"+\":\n            while stack and stack[-1] == \"+\":\n                op = stack.pop()\n                right = stack.pop()\n                left = stack.pop()\n                stack.append(signs[op](left, right))\n        else:\n            continue\n\n        if i % 2 == 1:\n            while stack:\n                result = stack.pop()\n\n    return str(result)\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.split('\\n')\n    left_weights, right_weights = scales.split('|')\n    left_weights = left_weights.split()\n    right_weights = right_weights.split()\n    \n    available_weights = set(weights)\n    left_total = sum(len(left_weights) - left_weights.index(weight))\n    right_total = sum(len(right_weights) - right_weights.index(weight))\n    \n    for weight in left_weights:\n        if weight in available_weights:\n            available_weights.remove(weight)\n            left_total += 1\n            right_total -= 1\n            if left_total == right_total:\n                return '|'.join(left_weights + right_weights)\n    \n    return \"Impossible\"\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    weights, available_weights = input_data[0], input_data[1]\n\n    weights = weights.split('|')\n    available_weights = list(available_weights)\n\n    left_pan = weights[0].split(',')\n    right_pan = weights[1].split(',')\n\n    left_pan_sum = sum(map(int, left_pan))\n    right_pan_sum = sum(map(int, right_pan))\n\n    if left_pan_sum == right_pan_sum:\n        available_weights.sort()\n        return f\"{'|'.join(left_pan + available_weights)}\\n{'|'.join(right_pan + available_weights)}\"\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def total_weights(weights: str) -> int:\n        return sum(ord(c) - ord('A') + 1 for c in weights)\n\n    scales, weights = stdin.split('\\n')\n    left_weights, right_weights = scales.split('|')\n\n    left_total = total_weights(left_weights)\n    right_total = total_weights(right_weights)\n\n    if left_total != right_total:\n        return \"Impossible\"\n\n    for weight in sorted(weights):\n        left_total -= ord(weight) - ord('A') + 1\n        right_total += ord(weight) - ord('A') + 1\n        if left_total == right_total:\n            return left_weights + '|' + right_weights + weight\n\n    return \"Impossible\"\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.split('\\n')\n    left_pan = scales.split('|')[0]\n    right_pan = scales.split('|')[1]\n    total_left = sum(left_pan)\n    total_right = sum(right_pan)\n    \n    weights = set(weights)\n    weights.update(left_pan)\n    weights.update(right_pan)\n    \n    if total_left == total_right:\n        return stdin\n    \n    for w in sorted(weights):\n        if w in left_pan and w not in right_pan:\n            left_pan.remove(w)\n            right_pan.add(w)\n            total_left -= ord(w)\n            total_right += ord(w)\n            if total_left == total_right:\n                return f\"{''.join(left_pan) if left_pan else '|'}{w}|{''.join(right_pan)}\"\n            else:\n                left_pan.add(w)\n                right_pan.remove(w)\n                total_left += ord(w)\n                total_right -= ord(w)\n                \n    return \"Impossible\""
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.strip().split(\"\\n\")\n    weights = sorted(weights)\n\n    def check_scales(scales, weights):\n        left_pan = [scale for scale in scales if scale != \"|\"]\n        right_pan = [scale for scale in scales if scale == \"|\"]\n        weight_count = len(left_pan) + len(right_pan)\n        if weight_count == len(weights):\n            return \"\".join(left_pan) + \"|\" + \"\".join(right_pan)\n        return None\n\n    for weight in weights:\n        scales = scales.replace(\"|\", \"\")\n        scales = \"|\".join(sorted(scales + weight))\n        result = check_scales(scales, weights)\n        if result:\n            return result\n    return \"Impossible\""
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.split('\\n')\n    left_weights = [w for w in scales.split('|')[0]]\n    right_weights = [w for w in scales.split('|')[1]]\n    \n    if weights in left_weights or weights in right_weights:\n        return \"Impossible\"\n    \n    left_weights.append(weights)\n    left_weights.sort()\n    right_weights.sort()\n    \n    left_total = sum(ord(w) for w in left_weights)\n    right_total = sum(ord(w) for w in right_weights)\n    \n    if left_total == right_total:\n        return \"|\".join(left_weights) + \"|\" + \"|\".join(right_weights)\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.strip().split('\\n')\n    left, right = scales.split('|')\n    left_weights = set(left)\n    right_weights = set(right)\n    available_weights = set(weights)\n\n    if not available_weights.issubset(left_weights.union(right_weights)):\n        return \"Impossible\"\n\n    for weight in available_weights:\n        if weight in left_weights and weight in right_weights:\n            left_weights.remove(weight)\n            right_weights.remove(weight)\n\n    result = ''\n    for weight in left_weights:\n        result += weight\n    result += '|'\n    for weight in right_weights:\n        result += weight\n\n    return result\n"
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.split(\"\\n\")\n    left_weights = scales.split(\"|\")[0].split()\n    right_weights = scales.split(\"|\")[1].split()\n    used_weights = set(left_weights + right_weights)\n    \n    if any(weight not in used_weights for weight in weights):\n        return \"Impossible\"\n    \n    left_weights += weights.split()\n    right_weights = [weight for weight in right_weights if weight not in weights.split()]\n    \n    if sum(int(weight) for weight in left_weights) == sum(int(weight) for weight in right_weights):\n        return \"|\".join(scales.split(\"|\") + [weights])\n    else:\n        return \"Impossible\"\n\n\ninput_data = \"\"\"\nAC|T\nL\n\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"\n|ABC\nXYZ\n\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"\nW|T\nF\n\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"\nABC|\nD\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    scales, weights = stdin.splitlines()\n    weights = sorted(list(weights))\n    left_weights, right_weights = scales.split('|')\n    left_weights = sorted(list(left_weights))\n    right_weights = sorted(list(right_weights))\n\n    if not left_weights or not right_weights:\n        return \"Impossible\"\n\n    left_sum = sum(left_weights)\n    right_sum = sum(right_weights)\n\n    if left_sum != right_sum:\n        return \"Impossible\"\n\n    for weight in weights:\n        if weight in left_weights and weight in right_weights:\n            left_weights.remove(weight)\n            right_weights.remove(weight)\n\n    if not left_weights or not right_weights:\n        return \"|\".join(weights)\n\n    return \"Impossible\"\n\n\nstdin = \"AC|T\\nL\"\nprint(solution(stdin)) "
    },
    {
        "number": 618,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    left_weights, right_weights = lines[0].split('|')\n    left_weights = left_weights.split('')\n    right_weights = right_weights.split('')\n    target_weights = lines[1].split('')\n    \n    def is_equilibrium(weights):\n        left_sum = sum([weights[weight] for weight in left_weights])\n        right_sum = sum([weights[weight] for weight in right_weights])\n        return left_sum == right_sum\n    \n    weights = {weight: 0 for weight in target_weights}\n    if not is_equilibrium(weights):\n        return \"Impossible\"\n    \n    for weight in left_weights:\n        weights[weight] += 1\n    if not is_equilibrium(weights):\n        return \"Impossible\"\n    \n    for weight in right_weights:\n        weights[weight] += 1\n    if not is_equilibrium(weights):\n        return \"Impossible\"\n    \n    return '|'.join(left_weights + right_weights)\n"
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    \n    sasha_coconuts = x // z\n    masha_coconuts = y // z\n    \n    return sasha_coconuts + masha_coconuts, abs(x - y)\n\n\ninput_data = \"5 4 3\"\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    \n    min_give = abs(x - y) // z\n    max_coconuts = min(x // z, y // z) + min((x + min_give * z) // z, (y - min_give * z) // z)\n\n    return max_coconuts, min_give\n\nprint(solution(\"5 4 3\"))  # Output: 3 1\nprint(solution(\"6 8 2\"))  # Output: 7 0 "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    \n    min_chizhik = min(x, y)\n    max_coconuts = min_chizhik // z\n    \n    return max_coconuts, min_chizhik - max_coconuts * z"
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    sash_coconuts = (x - y) // z\n    max_coconuts = min(x, y) // z\n    min_chizhiks = abs(sash_coconuts - max_coconuts) * z\n    return f\"{max_coconuts} {min_chizhiks}\" "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    x, y, z = map(int, input_data[0].split())\n    a = min(x, y)\n    b = max(x, y)\n    c = a * z\n    d = b * z\n    e = max(x, y) - min(x, y)\n    result = (c + d) // z\n    return str(result) + \" \" + str(e)\n"
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    min_chizhiks = min(x, y)\n    max_coconuts = min(x // z, y // z) * z\n    return str(max_coconuts) + \"\\n\" + str(min_chizhiks)\n\nprint(solution(input())) "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    max_coconuts = (x + y) // z\n    min_chizhiks = min(x, y)\n    return f\"{max_coconuts} {min_chizhiks}\"\n\n\ninput_data = \"5 4 3\\n6 8 2\"\noutput_data = \"3 1\\n7 0\"\n\ninput_lines = input_data.split(\"\\n\")\noutput_lines = output_data.split(\"\\n\")\n\nfor i, line in enumerate(input_lines):\n    result = solution(line)\n    assert result == output_lines[i], f\"Test case {i} failed\"\n    \nprint(\"All test cases passed\") "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    min_chizhiks = min(x, y)\n    max_coconuts = min_chizhiks // z\n    return f\"{max_coconuts} {min_chizhiks}\"\n\nprint(solution(input())) "
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n\n    a = x // z\n    b = y // z\n\n    coconuts = min(a, b)\n    chizhiks_to_give = abs(x - coconuts * z)\n\n    return str(coconuts), str(chizhiks_to_give)\n"
    },
    {
        "number": 619,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    coconuts_sasha = x // z\n    coconuts_masha = y // z\n\n    while x % z != 0 or y % z != 0:\n        if coconuts_sasha <= coconuts_masha:\n            x += z\n            coconuts_sasha += 1\n        else:\n            y += z\n            coconuts_masha += 1\n\n    return f\"{coconuts_sasha + coconuts_masha} {abs(x - y)}\"\n\ndef"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_positive_area(p1, p2, p3):\n        a = (p2[0] - p1[0], p2[1] - p1[1])\n        b = (p3[0] - p1[0], p3[1] - p1[1])\n        return a[0] * b[1] - a[1] * b[0] > 0\n\n    points = []\n    for line in stdin.splitlines():\n        x, y = map(int, line.split())\n        points.append((x, y))\n\n    k = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                if is_positive_area(points[i], points[j], points[k]):\n                    k += 1\n\n    print(k)\n    for i in range(k):\n        print(points[0][0] + i, points[0][1])\n        print(points[0][0], points[0][1] - i)\n        print(points[0][0] + i, points[0][1] - i)\n        print(points[0][0] + i, points[0][1])\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    \n    def is_valid_point(x, y):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x3, y3 = points[2]\n        \n        if (x1 - x2) * (y3 - y2) - (y1 - y2) * (x3 - x2) == 0:\n            return False\n        if (x1 - x2) * (y - y2) - (y1 - y2) * (x - x2) == 0:\n            return False\n        if (x - x1) * (y3 - y1) - (y - y1) * (x3 - x1) == 0:\n            return False\n        return True\n    \n    valid_points = 0\n    for x in range(-1001, 1002):\n        for y in range(-1001, 1002):\n            if is_valid_point(x, y):\n                valid_points += 1\n                \n    print(valid_points)\n    for x in range(-1001, 1002):\n        for y in range(-1001, 1002):\n            if is_valid_point(x, y):\n                print(x, y)\n                valid_points -= 1\n                if valid_points == 0:\n                    break\n        if valid_points == 0:\n            break\n\n\nstdin = '''0 0\n1 0\n0 1'''\n\nsolution(stdin) "
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    \n    # Check if points are in counter-clockwise order\n    if points[1][0] - points[0][0] * (points[1][1] - points[0][1]) < 0:\n        points = points[::-1]\n    \n    # Calculate the slope of the diagonal line\n    slope = (points[1][1] - points[0][1]) / (points[1][0] - points[0][0])\n    \n    # Calculate the equation of the line perpendicular to the diagonal line and passing through the first point\n    perpendicular_line = (slope, -1 / slope, points[0][1] - slope * points[0][0])\n    \n    # Calculate the intersection point of the perpendicular line with the second line\n    x = (perpendicular_line[2] - perpendicular_line[1]) / (perpendicular_line[0] - points[1][0] * slope)\n    y = slope * x + points[1][1]\n    intersection_point = (int(round(x)), int(round(y)))\n    \n    # Check if the intersection point is inside the parallelogram\n    if intersection_point[0] >= min(points[0][0], points[1][0]) and intersection_point[0] <= max(points[0][0], points[1][0]) and intersection_point[1] >= min(points[0][1], points[1][1]) and intersection_point[1] <= max(points[0][1], points[1][1]):\n        k = 1\n    else:\n        # Calculate the distance between the intersection point and the parallelogram\n        dist = abs(intersection_point[0] - points[0][0]) + abs(intersection_point[1] - points[0][1])\n        \n        # Calculate the maximum distance between two points on the diagonal line\n        max_dist = max(abs(points[1][0] - points[0][0]), abs(points[1][1] - points[0][1]))\n        \n        # Calculate the number of ways to add one new integer point such that the obtained set defines some parallelogram of positive area\n        k = (max_dist + 1) // dist\n    \n    result = '\\n'.join(f\"{p[0]} {p[1]}\" for p in itertools.product((points[0][0], points[1][0]), (-1, 0, 1)))\n    \n    return f\"{k}\\n{result}\" "
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    dx1, dy1 = x2 - x1, y2 - y1\n    dx2, dy2 = x3 - x2, y3 - y2\n\n    cross_product = dx1 * dy2 - dy1 * dx2\n\n    if cross_product == 0:\n        return \"0\\n\"\n\n    k = abs(cross_product) // 2\n    signs = [(-1) ** sum(i) for i in zip(points[0] < points[1:], points[1:])]\n\n    result = []\n    for i in range(k):\n        x4, y4 = points[0] + (i * signs) * (dx1, dy1) + ((k - i - 1) * signs) * (dx2, dy2)\n        result.append(f\"{x4} {y4}\")\n\n    return f\"{k}\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into lines and parse integer coordinates\n    points = []\n    for line in stdin.split('\\n'):\n        x, y = map(int, line.split())\n        points.append((x, y))\n\n    # Calculate area of original parallelogram\n    a, b, c, d = points\n    area = abs((a[0] - d[0]) * (b[1] - c[1]) - (b[0] - c[0]) * (a[1] - d[1]))\n\n    # Calculate all possible new points\n    k = 0\n    new_points = []\n    for x, y in points:\n        # Check each point not already in the set\n        if (x, y) not in points:\n            k += 1\n            # Check if the point lies on any of the diagonals\n            for a, b in ((x - d[0], y - d[1]), (x - c[0], y - c[1]), (x - b[0], y - b[1]), (x - a[0], y - a[1])):\n                # Calculate the area of the parallelogram formed by the new point and the diagonal\n                new_area = abs((a[0] - b[0]) * (y - b[1]) - (x - b[0]) * (b[1] - y))\n                # Check if the area is positive\n                if new_area > 0:\n                    # Add the point to the new set\n                    new_points.append((x, y))\n                    break\n\n    # Print the number of new points and their coordinates\n    return f\"{k}\\n\" + '\\n'.join(f\"{x} {y}\" for x, y in new_points)\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_positive_area(x1, y1, x2, y2, x3, y3):\n        a = abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))\n        b = abs((x3 - x2) * (y1 - y2) - (x1 - x2) * (y3 - y2))\n        c = abs((x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3))\n        return a + b > c and b + c > a and c + a > b\n\n    def is_unique(x, y, points):\n        return not any(x == p[0] and y == p[1] for p in points)\n\n    x1, y1 = map(int, stdin.splitlines()[0].split())\n    x2, y2 = map(int, stdin.splitlines()[1].split())\n    x3, y3 = map(int, stdin.splitlines()[2].split())\n\n    points = [(x1, y1), (x2, y2), (x3, y3)]\n    k = 0\n\n    for x4 in range(-1000, 1001):\n        for y4 in range(-1000, 1001):\n            if is_unique(x4, y4, points):\n                new_points = sorted(points + [(x4, y4)])\n                if is_positive_area(new_points[0][0], new_points[0][1], new_points[1][0], new_points[1][1], new_points[2][0], new_points[2][1]):\n                    k += 1\n                    print(x4, y4)\n\n    return str(k)\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_parallelogram(points):\n        # check if three points define a parallelogram\n        if len(set(points)) != 3:\n            return False\n\n        # check if the three points are not on the same line\n        x1, y1, x2, y2, x3, y3 = points\n        if (x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1):\n            return False\n\n        # check if the three points have positive area\n        a, b, c = sorted([(x1 ** 2 + y1 ** 2), (x2 ** 2 + y2 ** 2), (x3 ** 2 + y3 ** 2)])\n        return a + b > c\n\n    def add_fourth_point(points, x, y):\n        # check if the given point is not on the same line with the three existing points\n        x1, y1, x2, y2, x3, y3 = points\n        if (x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1):\n            return None\n\n        # calculate the slope of the line passing through the three points and the given point\n        m1 = (y2 - y1) / (x2 - x1)\n        m2 = (y3 - y2) / (x3 - x2)\n        m3 = (y3 - y1) / (x3 - x1)\n        m4 = (y2 - y1) / (x2 - x1)\n\n        # calculate the intersection point of the two lines passing through the three points and the given point\n        if m1 == m2:\n            return None\n        if m3 == m4:\n            return None\n        if m1 == m3:\n            return None\n        if m2 == m4:\n            return None\n\n        x_int = (m1 * m2 * (y1 - y3) - m2 * m3 * (y1 - y2) + m3 * m4 * (y2 - y1)) / (m1 * m2 - m3 * m4)\n        y_int = (m1 * m2 * (x1 - x3) - m2 * m3 * (x1 - x2) + m3 * m4 * (x2 - x1)) / (m1 * m2 - m3 * m4)\n\n        # check if the intersection point is within the bounding box of the three points\n        if min(x1, x2, x3) <= x_int <= max(x1, x2, x3) and min(y1, y2, y3) <= y_int <= max(y1, y2, y3):\n            return (x_int, y_int)\n        else:\n            return None\n\n    def find_fourth_point(points):\n        x1, y1, x2, y2, x3, y3 = points\n        min_x, max_x = sorted([x1, x2, x3])\n        min_y, max_y = sorted([y1, y2, y3])\n\n        # generate candidate points within the bounding box of the three points\n        candidates = [(x, y) for x in range(min_x, max_x + 1) for y in range(min_y, max_y + 1)]\n\n        # filter out points that are not valid fourth points\n        valid_candidates = [p for p in candidates if is_valid_parallelogram(points + [p])]\n\n        return valid_candidates\n\n    points = list(map(int, stdin.split()))\n    points = [points[i], points[i + 1]] for i in range(0, len(points), 2)\n\n    if is_valid_parallelogram(points):\n        k = len(find_fourth_point(points))\n        print(k)\n        for p in find_fourth_point(points):\n            print(p[0], p[1])\n    else:\n        print(0)\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.split('\\n'):\n        x, y = map(int, line.split())\n        points.append((x, y))\n    \n    # check if points form a parallelogram\n    if len(set(points)) != 3:\n        return \"Points do not form a parallelogram\"\n    \n    # calculate the area of the parallelogram\n    area = abs((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) - (points[2][0] - points[1][0]) * (points[0][1] - points[1][1]))\n    \n    # if area is not positive, there is no way to add one more point to form a parallelogram\n    if area <= 0:\n        return \"No possible ways to add one more point to form a parallelogram\"\n    \n    # calculate the distance between two points\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n    \n    # calculate the possible fourth point\n    possible_points = []\n    for i in range(3):\n        for j in range(3):\n            if i != j:\n                p4 = ((points[i][0] + points[j][0]) / 2, (points[i][1] + points[j][1]) / 2)\n                p4_distance = distance(points[i], p4) + distance(points[j], p4)\n                if p4_distance == distance(points[i], points[j]):\n                    possible_points.append(p4)\n    \n    # calculate the number of ways to add one more point\n    k = min(len(possible_points), area)\n    \n    # print the output\n    print(k)\n    for i in range(k):\n        print(possible_points[i][0], possible_points[i][1])\n    \n    return \"Output done\""
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n\n    # find the two non-parallel lines\n    slopes = []\n    for i in range(3):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % 3]\n        if x2 - x1 != 0:\n            slope = (y2 - y1) / (x2 - x1)\n            slopes.append(slope)\n\n    # find the two parallel lines\n    lines = []\n    for i in range(2):\n        for j in range(i + 1, 3):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            if x1 == x2:\n                a = 1\n                b = -1\n                c = -x1\n            else:\n                a = y2 - y1\n                b = x1 - x2\n                c = x1 * y2 - x2 * y1\n            lines.append((a, b, c))\n\n    # count the ways to add a new point\n    k = 0\n    for a, b, c in lines:\n        if a != 0:\n            k += 2\n        else:\n            k += 1\n\n    # print the possible points\n    for i in range(k):\n        x, y = points[0]\n        if i < 3:\n            x1, y1 = points[i]\n            if a != 0:\n                x = x1 + (c - b * y1) / a\n                y = y1 + (a * x - c) / b\n            else:\n                x = x1 + (b * y1) / c\n                y = y1 + (-a * x1) / c\n        print(x, y)\n\n    return str(k)\n"
    },
    {
        "number": 620,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for _ in range(3):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    # Calculate slopes of three lines\n    slopes = [(y2 - y1) / (x2 - x1) for x1, y1, x2, y2 in zip(points, points[1:] + points[:1], points[2:] + points[:2])]\n\n    # Calculate angles between the lines\n    angles = [(slope1 - slope2) / (1 + slope1 * slope2) for slope1, slope2 in zip(slopes, slopes[1:] + slopes[:1])]\n\n    # Count number of possible points to add\n    k = sum(1 for angle in angles if angle != 0)\n\n    # Generate possible points to add\n    for i in range(k):\n        x = (points[i][1] - points[i + 1][1]) / (angles[i] + 1)\n        y = points[i][1] + x * angles[i]\n        print(x, y)\n\n    return str(k)"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_i_list = map(int, stdin.split())\n    a_i_list = sorted(a_i_list)\n\n    losses = [1] * n\n    for i in range(1, n):\n        if a_i_list[i] < 0:\n            losses[i] = losses[i-1] + 1\n\n    k = 1\n    b_k = [n]\n    for j in range(1, n):\n        if losses[j] > losses[j-1]:\n            k += 1\n            b_k.append(j)\n        else:\n            b_k[-1] = j\n            if k > 1:\n                b_k[-2] = j - 1\n                b_k.append(n)\n                k += 1\n\n    return k, b_k\n\n\ndef"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n\n    def count_losses(reports):\n        return sum(1 for report in reports if report < 0)\n\n    def group_reports(n, a):\n        groups = []\n        group_size = 1\n        current_group = []\n        for i in range(n):\n            current_group.append(a[i])\n            if count_losses(current_group) >= 3:\n                groups.append(current_group)\n                current_group = []\n                group_size += 1\n        if current_group:\n            groups.append(current_group)\n        return groups, group_size\n\n    groups, group_size = group_reports(n, a)\n    print(group_size)\n    for group in groups:\n        print(len(group), end=\" \")\n"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, a = list(map(int, input().split()))\n    loss_days = 0\n    for i in range(n):\n        if a[i] < 0:\n            loss_days += 1\n    if loss_days <= 2:\n        return 1, \"5\"\n    else:\n        k = (loss_days - 2) // 2 + 1\n        b = [5] * k\n        b[-1] = loss_days % 5 + 1\n        return k, \" \".join(map(str, b))\n"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    total_loss = sum(1 for x in a if x < 0)\n    if total_loss == 0:\n        print(1)\n        print(\" \".join(str(len(a)) for _ in range(1)))\n    elif total_loss == 1:\n        print(1)\n        print(\" \".join(str(len(a)) for _ in range(1)))\n    else:\n        k = 1\n        while True:\n            folders = []\n            for i in range(n):\n                folders.append(a[i:i+k])\n            max_loss = max(sum(1 for x in folder if x < 0) for folder in folders)\n            if max_loss == 0:\n                break\n            else:\n                k += 1\n        print(k)\n        print(\" \".join(str(len(folder)) for folder in folders))\n\n\ninput_str = \"\"\"5\n0 -1 100 -1 0\"\"\"\nsolution(input_str)"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    min_k = 1\n    k = 1\n\n    while k <= n:\n        if all(a[i] >= 0 for i in range(k, n, k)):\n            min_k = max(min_k, k)\n        k += 1\n\n    b = [0] * min_k\n\n    for i in range(n):\n        j = (i + 1) % min_k\n        b[j] += 1\n\n    return f\"{min_k}\\n{' '.join(map(str, b))}\"\n\n\ndef"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    num_losses = 0\n    loss_streak = 0\n    for i in range(n):\n        if a[i] < 0:\n            loss_streak += 1\n            num_losses += 1\n        else:\n            loss_streak = 0\n        if i == n - 1:\n            num_losses -= loss_streak\n    if num_losses == 0:\n        return 1, '1 ' + str(n)\n    max_folders = num_losses // 3 + 1\n    min_folders = (num_losses + 1) // 2 + 1\n    return max(max_folders, min_folders), ' '.join([str(max_folders)] + [str((i + 1) * 3 - num_losses) for i in range(max_folders - 1, -1, -1)])\n\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solution(n, a)) "
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    total_loss = sum(1 for x in a if x < 0)\n\n    if total_loss == 0:\n        return 1, \"1 0 0 0 0 0 0 0 0 0\"\n    elif total_loss == 1:\n        return 1, \"1 1 1 1 1 1\"\n    elif total_loss == 2:\n        return 2, \"2 2 2 2 2 2\"\n    else:\n        return 3, \"3 2 1 1 1 1\"\n\nn = int(input())\na = list(map(int, input().split()))\nk, b = solution(stdin=f\"{n}\\n{' '.join(map(str, a))}\")\nprint(k)\nprint(b) "
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a_i = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Count the number of loss days for each folder\n    loss_days = [0] * n\n    for i in range(n):\n        loss_days[i % n] += 1 if a[i] < 0 else 0\n\n    # Find the minimum number of folders\n    min_folders = 1\n    for loss_days_sum in range(n):\n        folders = [0] * n\n        for i in range(n):\n            folders[i % n] += 1 if loss_days_sum + loss_days[i] <= n else 0\n        min_folders = min(min_folders, max(folders) + 1)\n\n    # Print the result\n    print(min_folders)\n    for i in range(n):\n        print(loss_days[(i + 1) % n], end=' ')\n\n\nstdin = \"\"\"11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\n5\n0 -1 100 -1 0\n\"\"\"\n\nstdout = \"\"\"3\n5 3 3\n1\n5\n\"\"\""
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    k = 1\n    b = [0] * k\n    j = 0\n    for i in range(n):\n        if a[i] < 0:\n            j += 1\n            b[j - 1] += 1\n            if j == k:\n                k += 1\n                b.append(0)\n        else:\n            b[j] += 1\n    return k, ' '.join(map(str, b[:k]))\n\n\ninput_str = \"\"\"11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\"\"\"\n\nn, k, b = solution(input_str)\nprint(n)\nprint(k)\nprint(b)\n\n\ninput_str = \"\"\"5\n0 -1 100 -1 0\"\"\"\n\nn, k, b = solution(input_str)\nprint(n)\nprint(k)\nprint(b)"
    },
    {
        "number": 621,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    max_loss = 0\n    for i in range(n):\n        max_loss = max(max_loss, -a[i])\n    k = max_loss + 1\n    min_folders = 1\n    while k > 1:\n        if k % 2 == 0:\n            k //= 2\n            min_folders += 1\n        else:\n            break\n    b = [0] * min_folders\n    for i in range(n):\n        if -a[i] <= k:\n            b[a[i] + k - 1] += 1\n    return str(min_folders) + '\\n' + ' '.join(str(x) for x in b)\n\n\ninput_data = '''11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\n5\n0 -1 100 -1 0\n'''\n\noutput_data = '''3\n5 3 3 \n1\n5 \n'''\n\nprint(solution(input_data))\nprint(output_data) "
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n, k = map(int, input_data)\n    sequence = [1]\n    for _ in range(n - 1):\n        sequence.append(sequence[-1])\n        for i in range(len(sequence)):\n            if i not in sequence:\n                sequence.insert(i + 1, i + 1)\n                break\n    return str(sequence[k])\n"
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for _ in range(n - 1):\n        sequence += sequence\n        unique_numbers = set(sequence)\n        min_number = min(unique_numbers)\n        while min_number in unique_numbers:\n            min_number += 1\n        sequence.insert(len(sequence) // 2, min_number)\n    return sequence[k - 1]\n\n\ninput_str = \"3 2\\n\"\noutput_str = str(solution(input_str))\nprint(output_str) "
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    sequence = [1]\n    for _ in range(n-1):\n        sequence += sequence\n        min_unused = min(set(range(1, len(sequence)+1)) - set(sequence))\n        sequence.insert(len(sequence)//2, min_unused)\n    \n    return str(sequence[k-1])\n"
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for _ in range(n - 1):\n        sequence += sequence\n        for i in range(len(sequence) // 2 + 1):\n            if sequence[i] == i + 1:\n                continue\n            sequence.insert(i * 2 + 1, i + 1)\n            break\n    return str(sequence[k - 1])\n\n\ninput_data = \"3 2\\n4 8\"\nprint(solution(input_data)) "
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        sequence += sequence\n        min_positive_integer = max(max(sequence) + 1, k - sum(sequence) + len(sequence) + 1)\n        sequence.insert(len(sequence) // 2, min_positive_integer)\n    return sequence[k - 1]\n\ninput_string = \"3 2\\n\"\noutput_string = str(solution(input_string))\nprint(output_string)\n\ninput_string = \"4 8\\n\"\noutput_string = str(solution(input_string))\nprint(output_string) "
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str, k = stdin.split()\n    n, k = int(input_str.split()[0]), int(input_str.split()[1])\n    \n    if k == 1:\n        return \"1\"\n    \n    sequence = [1]\n    for i in range(n-1):\n        sequence.extend([sequence[-1]])\n        sequence.insert(i+2, i+2)\n        while True:\n            if i+2 in sequence:\n                sequence.insert(i+1, i+1)\n            else:\n                break\n    \n    return str(sequence[k-1])\n\n\ninput_str = \"4 8\"\nprint(solution(input_str)) "
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        sequence.extend(sequence)\n        min_value = min(j for j in range(1, len(sequence) + 1) if j not in sequence)\n        sequence.insert(len(sequence) // 2, min_value)\n    return sequence[k - 1]\n\n\ndef"
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n = input_values[0]\n    k = input_values[1]\n\n    sequence = [1]\n    for i in range(n - 1):\n        sequence += sequence + [i + 2]\n\n    sequence.sort()\n    return sequence[k - 1]\n"
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        sequence.extend(sequence)\n        min_positive = max(sequence) + 1\n        sequence.insert(len(sequence) // 2, min_positive)\n    print(sequence[k - 1])\n    return sequence[k - 1]\n\nn, k = map(int, input().split())\nsolution(f\"{n} {k}\")\n"
    },
    {
        "number": 622,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(n - 1):\n        sequence += [j + 1 for j in range(len(sequence) + 1)]\n        sequence.sort()\n    return sequence[k - 1]\n"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n\n    minutes = 0\n    while a1 > 0 and a2 > 0:\n        if minutes % 60 == 0:\n            a1 += 1 if a1 < 100 else 0\n            a2 += 1 if a2 < 100 else 0\n        a1 -= 2 if a1 > 2 else 0\n        a2 -= 1 if a2 > 1 else 0\n        minutes += 1\n\n    return str(minutes // 2) if minutes % 2 == 0 else str((minutes + 1) // 2)"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    a1, a2 = int(input_values[0]), int(input_values[1])\n    max_minutes = 0\n\n    while a1 > 0 and a2 > 0:\n        max_minutes += 1\n\n        if a1 == 100:\n            a1 += 1\n        else:\n            a1 += 1\n\n        if a2 == 100:\n            a2 += 1\n        else:\n            a2 += 1\n\n        if a1 == 101 or a2 == 101:\n            a1 = a2 = 0\n\n    return str(max_minutes)\n\ndef"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    minutes = 1\n    while a_1 > 0 and a_2 > 0:\n        if minutes % 2 == 1:\n            a_1 = max(0, a_1 - 2)\n            a_2 = max(0, a_2 - 1)\n        else:\n            a_1 = max(0, a_1 + 1)\n            a_2 = max(0, a_2 + 2)\n        minutes += 1\n    return minutes - 1\n\n\ninput_str = \"3 5\\n4 4\"\noutput_str = \"\"\nfor line in input_str.split(\"\\n\"):\n    output_str += str(solution(line)) + \"\\n\"\n\nprint(output_str.strip()) "
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    if a_1 == 0:\n        return 1\n    elif a_2 == 0:\n        return 1\n    else:\n        return 1 + (a_1-1)//2 + (a_2-1)//2\n\ndef"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    max_charge = 100\n    charge_1, charge_2 = a1, a2\n    minutes = 1\n\n    while charge_1 > 0 and charge_2 > 0:\n        if minutes % 2 == 1:\n            charge_1 = max(charge_1 - 2, 0)\n            charge_2 = max(charge_2 + 1, 0)\n        else:\n            charge_1 = max(charge_1 + 1, 0)\n            charge_2 = max(charge_2 - 2, 0)\n\n        if charge_1 == 0 or charge_2 == 0:\n            break\n\n        minutes += 1\n\n    return minutes - 1\n"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    \n    minutes = 0\n    while a1 > 0 and a2 > 0:\n        a1 = max(a1 - 2, a1)\n        a2 = max(a2 - 1, a2)\n        minutes += 1\n    \n    return str(minutes)"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n\n    minutes = 0\n    while a_1 > 0 and a_2 > 0:\n        a_1 = max(a_1 - 1, a_1 + 1)\n        a_2 = max(a_2 - 1, a_2 + 1)\n        minutes += 1\n\n    return minutes\n"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    minutes = 0\n\n    while a_1 > 0 and a_2 > 0:\n        a_1 -= 2 if a_1 > 2 else 0\n        a_2 += 1 if a_2 > 0 else 0\n        minutes += 1\n\n    return minutes\n"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    minutes = 0\n    while a1 > 0 and a2 > 0:\n        a1, a2 = max(0, a1 - 2), max(0, a2 - 1)\n        minutes += 1\n    return minutes\n"
    },
    {
        "number": 623,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, input().split())\n    max_minutes = 0\n    \n    while a1 > 0 and a2 > 0:\n        max_minutes += 1\n        \n        a1 -= 2\n        if a1 > 0:\n            a1 += 1\n        \n        a2 -= 1\n        if a2 > 0:\n            a2 += 1\n    \n    return str(max_minutes)"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, k, m = map(int, input_list[:3])\n    a = list(map(int, input_list[3:]))\n    \n    def get_max_average(a):\n        max_sum = sum(a)\n        max_power = max(a)\n        return max_sum - max_power + (k * max_power)\n    \n    max_average = float('-inf')\n    for i in range(n):\n        if i >= 1:\n            a_copy = a.copy()\n            del a_copy[i]\n            max_average = max(max_average, get_max_average(a_copy))\n        if i < n-1:\n            a[i] += 1\n            max_average = max(max_average, get_max_average(a))\n            a[i] -= 1\n    \n    return f\"{max_average:.12f}\""
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k, m = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n\n    def max_average_power(a_list):\n        def increase_power(a_list, i, k):\n            if i < n and k > 0:\n                a_list[i] += 1\n                k -= 1\n\n        def remove_superhero(a_list, i):\n            if i < n and n > 1:\n                a_list.pop(i)\n                n -= 1\n\n        max_avg = sum(a_list) / n\n\n        for _ in range(m):\n            max_avg = max(max_avg, sum(a_list) / n)\n            for i in range(n):\n                increase_power(a_list, i, k)\n            for i in range(n - 1, -1, -1):\n                if n > 1:\n                    remove_superhero(a_list, i)\n        return max_avg\n\n    result = max_average_power(a_list)\n    return f\"{result:.6f}\"\n"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, input().split())\n    powers = list(map(int, input().split()))\n\n    def increase_power(superhero_id: int) -> None:\n        powers[superhero_id] += 1\n\n    def remove_superhero(superhero_id: int) -> None:\n        powers.pop(superhero_id)\n\n    def calculate_average_power() -> float:\n        return sum(powers) / len(powers)\n\n    max_average_power = calculate_average_power()\n    operations = []\n\n    for i in range(m):\n        operations.append((i, \"increase\"))\n\n    for i in range(n - 1, -1, -1):\n        operations.append((i, \"delete\"))\n\n    operations.sort(key=lambda x: (-x[1] == \"increase\", x[0]))\n\n    for operation in operations:\n        superhero_id, action = operation\n\n        if action == \"increase\":\n            increase_power(superhero_id)\n        elif action == \"delete\":\n            remove_superhero(superhero_id)\n\n        new_average_power = calculate_average_power()\n\n        if new_average_power > max_average_power:\n            max_average_power = new_average_power\n        else:\n            break\n\n    return \"{:.6f}\".format(max_average_power)"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_power(superhero_index: int) -> int:\n        return powers[superhero_index]\n\n    def set_power(superhero_index: int, new_power: int) -> None:\n        nonlocal powers\n        powers[superhero_index] = new_power\n\n    def is_valid_operation(superhero_index: int, max_increase: int) -> bool:\n        return powers[superhero_index] + 1 <= max_increase\n\n    def perform_operation(operation: str, superhero_index: int) -> None:\n        nonlocal powers, operations_done\n        if operation == 'delete':\n            powers.pop(superhero_index)\n        elif operation == 'increase':\n            set_power(superhero_index, get_power(superhero_index) + 1)\n        operations_done[superhero_index] += 1\n\n    n, k, m = map(int, stdin.split()[:3])\n    powers = list(map(int, stdin.split()[3:]))\n    operations_done = [0] * n\n\n    max_power = sum(powers) / n\n    max_average = max_power\n\n    for _ in range(m):\n        valid_operations = [(i, 'delete') for i in range(n) if n > 1 and operations_done[i] < k]\n        valid_operations.extend((i, 'increase') for i in range(n) if is_valid_operation(i, k)))\n\n        if not valid_operations:\n            break\n\n        operation, superhero_index = max(valid_operations, key=lambda x: (get_power(x[0]), x[1]))\n        perform_operation(operation, superhero_index)\n\n        new_average = sum(powers) / len(powers)\n        max_average = max(max_average, new_average)\n\n    return f\"{max_average:.{10}f}\"\n"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    powers = list(map(int, stdin.split()[3:]))\n\n    # Remove one superhero if n >= 2\n    if n >= 2:\n        powers.pop()\n        n -= 1\n\n    # Increase the power of a superhero by 1\n    max_power = max(powers)\n    max_power_hero_index = powers.index(max_power)\n    if m - k >= 1:\n        powers[max_power_hero_index] += 1\n        m -= 1\n\n    # Increase the power of a superhero by k\n    for i in range(k):\n        max_power = max(powers)\n        max_power_hero_index = powers.index(max_power)\n        if m - k * (i + 1) >= 1:\n            powers[max_power_hero_index] += 1\n            m -= 1\n\n    # Calculate the maximum final average power\n    max_final_average = sum(powers) / n\n\n    return f\"{max_final_average:.6f}\""
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, k, m = map(int, input_values[0].split())\n    powers = list(map(int, input_values[1].split()))\n\n    # Helper function to calculate the maximum average power\n    def max_average_power(powers, k):\n        max_power = max(powers)\n        if k >= max_power:\n            return sum(powers) / len(powers)\n        else:\n            return (sum(powers) - max_power * k) / (len(powers) - k)\n\n    # Helper function to calculate the maximum average power with at most m operations\n    def max_average_power_with_max_operations(powers, k, m):\n        if m == 0 or k == 0:\n            return sum(powers) / len(powers)\n        if k == 1:\n            return max(powers)\n\n        max_power = max(powers)\n        if m >= len(powers) - 1:\n            return (sum(powers) - max_power * k) / (len(powers) - k)\n\n        min_power = min(powers)\n        max_average = max_average_power(powers, k)\n        min_average = sum(powers) / len(powers)\n        max_average_with_one_deletion = (sum(powers) - min_power) / (len(powers) - 1)\n\n        if max_average <= min_average:\n            return max_average\n        elif max_average <= max_average_with_one_deletion:\n            return max_average_with_one_deletion\n        else:\n            return min_average\n\n    # Calculate the maximum average power with at most m operations\n    result = max_average_power_with_max_operations(powers, k, m)\n\n    return f\"{result:.10f}\"\n"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def increase_power(superheroes: list, index: int, k: int) -> int:\n        superheroes[index] += 1\n        return sum(superheroes) // len(superheroes)\n\n    def remove_superhero(superheroes: list, index: int) -> int:\n        superheroes.pop(index)\n        return sum(superheroes) // len(superheroes)\n\n    n, k, m = map(int, stdin.split()[:3])\n    superheroes = list(map(int, stdin.split()[3:]))\n\n    max_average = sum(superheroes) // n\n    operations = 0\n\n    while operations < m:\n        max_superhero_power = max(superheroes)\n        if max_superhero_power > max_average and operations < m:\n            index = superheroes.index(max_superhero_power)\n            if operations < m and operations < k:\n                max_average = increase_power(superheroes, index, k)\n                operations += 1\n        else:\n            if len(superheroes) > 2:\n                index = superheroes.index(max(superheroes))\n                if operations < m and operations < k:\n                    max_average = remove_superhero(superheroes, index)\n                    operations += 1\n            else:\n                break\n\n    return f\"{max_average:.{10}f}\"\n"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, k, m = map(int, input_data[0].split())\n    powers = list(map(int, input_data[1].split()))\n\n    def count_operations(n: int, k: int, m: int, powers: list) -> int:\n        operations = 0\n        for i in range(n):\n            operations += min(k, powers[i])\n        return operations\n\n    def calculate_average(n: int, k: int, m: int, powers: list) -> float:\n        operations = count_operations(n, k, m, powers)\n        if operations > m:\n            return -1\n        m -= operations\n        total_power = sum(powers)\n        max_power = max(powers)\n        avg_power = total_power / n\n        while m > 0:\n            for i in range(n):\n                if powers[i] < max_power:\n                    powers[i] += 1\n                    total_power += 1\n                    avg_power = total_power / n\n                    m -= 1\n                    if m == 0:\n                        break\n        return avg_power\n\n    max_average = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max_average == -1:\n                max_average = calculate_average(2, k, m, powers[i:j + 1])\n            else:\n                avg = calculate_average(2, k, m, powers[i:j + 1])\n                max_average = max(max_average, avg)\n\n    return f\"{max_average:.15f}\"\n"
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, k, m = map(int, input_data[0].split())\n    powers = list(map(int, input_data[1].split()))\n\n    max_power = max(powers)\n    min_power = min(powers)\n    powers_sum = sum(powers)\n\n    def is_valid(powers_sum):\n        return powers_sum >= max_power * n - (k * (n - 1)) and powers_sum <= max_power * n + (k * (n - 1))\n\n    def average_power(powers_sum):\n        return powers_sum / n\n\n    def calculate_powers_sum(powers_sum, index, op):\n        if op == \"delete\":\n            return powers_sum - powers[index]\n        elif op == \"increase\":\n            return powers_sum + 1\n\n    def backtrack(powers_sum, index, operations):\n        if index == n:\n            if is_valid(powers_sum):\n                return average_power(powers_sum)\n            else:\n                return float(\"-inf\")\n\n        current_max = float(\"-inf\")\n        for op in [\"delete\", \"increase\"]:\n            new_powers_sum = calculate_powers_sum(powers_sum, index, op)\n            if new_powers_sum < min_power * n:\n                continue\n            new_max = backtrack(new_powers_sum, index + 1, operations + [op])\n            current_max = max(current_max, new_max)\n\n        return current_max\n\n    result = backtrack(powers_sum, 0, [])\n    return \"{:.6f}\".format(result) "
    },
    {
        "number": 624,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    powers = list(map(int, stdin.split()[3:]))\n\n    max_sum = sum(powers)\n    max_avg = max_sum / n\n\n    for i in range(m):\n        min_pow = min(powers)\n        min_idx = powers.index(min_pow)\n        powers[min_idx] += 1\n\n        max_sum += 1 - min_pow\n        max_avg = max_sum / n\n\n    return f\"{max_avg:.{10}f}\"\n"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    f_n = 0\n    sign = 1\n    for i in range(1, n+1):\n        f_n += sign * i\n        sign *= -1\n    return str(f_n)\n\ninput_str = \"5\"  # Replace with input\nprint(solution(input_str)) "
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**(i-1) * i\n    return str(result)\n"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**(i-1) * i\n        \n    return str(result)\n\ninput_str = input()\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    f = 0\n    for i in range(1, n+1):\n        f += (-1)**i * i\n    return str(f)\n\n\ndef"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**i * i\n    return str(result)"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**i * i\n    return str(result)\n\ndef"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    f_n = 0\n    for i in range(1, n+1):\n        f_n += (-1)**(i-1)*i\n    return str(f_n)"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**(i-1) * i\n    return str(result)\n\nn = 5\ninput_str = str(n) + '\\n'\nprint(solution(input_str)) "
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(1, n+1):\n        if i % 2 == 1:\n            result -= i\n        else:\n            result += i\n    return str(result)\n"
    },
    {
        "number": 625,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(1, n+1):\n        result += (-1)**i * i\n    return str(result)\n\nn = input()\nprint(solution(n)) "
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Calculate the minimum number of changes of direction\n    changes = 0\n    current = 0\n    for i in range(1, n):\n        while current < i:\n            changes += 1\n            current += 1\n        current += 1\n\n    return str(changes)"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the current position of the robot\n    current_position = 1\n    # Initialize the number of changes of direction\n    changes_of_direction = 0\n\n    # Iterate through all the pieces of information\n    for i in range(n):\n        # If the current position is not adjacent to the i-th computer,\n        # the robot needs to change direction\n        if current_position not in [i, i+1, i-1]:\n            changes_of_direction += 1\n\n        # Move to the i-th computer\n        current_position = i + 1\n\n    return str(changes_of_direction)\n"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n\n    # Initialize the count of changes of direction\n    changes_of_direction = 0\n\n    # Compute the minimum number of changes of direction required\n    for i in range(n):\n        if i == 0:\n            changes_of_direction += a[i]\n        elif a[i] > 0:\n            changes_of_direction += 1\n\n    return str(changes_of_direction)"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(enumerate(a))\n    a.sort(key=lambda x: x[1])\n    min_changes = 0\n    left = 0\n    right = n - 1\n    while left < right:\n        if a[left][1] + a[right][1] < n:\n            min_changes += 1\n            left += 1\n        else:\n            right -= 1\n    return min_changes"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    # Calculate the minimum number of changes of direction\n    min_changes = 0\n    for i in range(n):\n        min_changes += a[i]\n    \n    # If the minimum number of changes of direction is odd, add 1\n    if min_changes % 2 == 1:\n        min_changes += 1\n    \n    return str(min_changes // 2)"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    # Initialize minimum number of changes of direction\n    min_changes = 0\n    \n    # Initialize current change of direction\n    current_change = 0\n    \n    # Initialize current index of computer\n    current_index = 0\n    \n    # Iterate over a and update current_change and min_changes\n    for i in range(len(a)):\n        if a[i] == 0:\n            continue\n        if a[i] > current_index:\n            current_index = a[i]\n        elif a[i] < current_index:\n            current_index = a[i]\n            current_change += 1\n        min_changes = min(min_changes, current_change)\n        \n    return str(min_changes)"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the current position and the number of changes of direction\n    current_position = 1\n    changes_of_direction = 0\n\n    # Collect all the pieces of information in the optimal manner\n    while len(a) > 0:\n        # Check if the current computer contains a piece of information\n        if a[current_position - 1] > 0:\n            # Remove the piece of information from the current computer\n            a[current_position - 1] = 0\n\n        # Check if there is no more space to the right of the current position\n        if current_position == n and len(a) > 0:\n            # Change direction to the left and move to the last computer\n            current_position = n\n            changes_of_direction += 1\n\n        # Check if there is no more space to the left of the current position\n        if current_position == 1 and len(a) > 0:\n            # Change direction to the right and move to the first computer\n            current_position = 1\n            changes_of_direction += 1\n\n        # Move to the next computer\n        current_position += 1\n\n        # Check if the current position is out of the line\n        if current_position > n:\n            current_position = 1\n            changes_of_direction += 1\n\n    return str(changes_of_direction)"
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    direction = 0\n    changes_of_direction = 0\n    i = 0\n    collected_information = 0\n\n    while collected_information < n:\n        if direction == 0:\n            if collected_information < i:\n                collected_information += 1\n            else:\n                direction = 1\n                changes_of_direction += 1\n        elif direction == 1:\n            if collected_information < i + a[i]:\n                collected_information += 1\n            else:\n                direction = 0\n                changes_of_direction += 1\n\n        i = (i + 1) % n\n\n    return changes_of_direction\n\n\ninput_str = \"\"\"3\n0 2 0\n5\n4 2 3 0 1\n7\n0 3 1 0 5 2 6\"\"\"\n\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    min_changes = 0\n\n    for i in range(1, n):\n        min_changes += a[i]\n\n    if min_changes % 2 == 1:\n        min_changes += 1\n\n    return min_changes // 2\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_changes = solution(f\"{n}\\n{' '.join(map(str, a))}\")\n\nprint(min_changes) "
    },
    {
        "number": 626,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # Calculate the number of changes of direction\n    changes = 0\n    for i in range(1, n):\n        if a[i] > 0:\n            changes += 1\n\n    return str(changes)"
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    \n    # If the length of the string is 1, return an empty string\n    if n == 1:\n        return \"\"\n    \n    # If the length of the string is 2, return the first character\n    if n == 2:\n        return s[0]\n    \n    # Initialize variables\n    result = s\n    smallest = s[0] + s[1:n-1]\n    \n    # Loop through the string to find the smallest possible lexicographically string\n    for i in range(n):\n        if i > 0:\n            new_result = s[0:i] + s[i+1:]\n            new_smallest = s[0:i] + s[i+1:n-1]\n            \n            # If the new string is lexicographically smaller, replace the result and smallest variables\n            if new_result < result:\n                result = new_result\n                smallest = new_smallest\n                \n            # If the new string is lexicographically equal to the result, remove the next character and check again\n            elif new_result == result:\n                new_smallest = s[0:i] + s[i+2:n-1]\n                \n                # If the new string is lexicographically smaller, replace the smallest variable\n                if new_smallest < smallest:\n                    smallest = new_smallest\n    \n    # Return the smallest possible lexicographically string\n    return smallest\n"
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    s = input_data[1]\n\n    if n == 1:\n        return \"\"\n    elif n == 2:\n        return min(s[0], s[1])\n    else:\n        min_s = min(s)\n        s = s.replace(min_s, '')\n        if n - 1 == 1:\n            return s\n        else:\n            min_s = min(s)\n            s = s.replace(min_s, '')\n            return s\n\n\nstdin = \"\"\"5\nabcda\"\"\"\n\nresult = solution(stdin)\nprint(result)  # Output: abca "
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin.split()[1]\n\n    if n == 2:\n        return min(s)\n\n    if n == 3:\n        if s[0] == s[2]:\n            return s[0] + s[1]\n        elif s[1] == s[2]:\n            return s[0] + s[2]\n        else:\n            return min(s)\n\n    if n == 4:\n        if s[0] == s[2]:\n            return s[0] + s[1] + s[3]\n        elif s[0] == s[3]:\n            return s[0] + s[1] + s[2]\n        elif s[1] == s[2]:\n            return s[0] + s[2] + s[3]\n        elif s[1] == s[3]:\n            return s[0] + s[1] + s[2]\n        else:\n            return min(s)\n\n    if n == 5:\n        if s[0] == s[2]:\n            return s[0] + s[1] + s[4]\n        elif s[0] == s[4]:\n            return s[0] + s[1] + s[2] + s[3]\n        elif s[1] == s[2]:\n            return s[0] + s[2] + s[3] + s[4]\n        elif s[1] == s[3]:\n            return s[0] + s[1] + s[3] + s[4]\n        elif s[2] == s[3]:\n            return s[0] + s[1] + s[2] + s[4]\n        elif s[2] == s[4]:\n            return s[0] + s[1] + s[2] + s[3]\n        elif s[3] == s[4]:\n            return s[0] + s[1] + s[3] + s[4]\n        else:\n            return min(s)\n\n    return min(s)\n\n\nn = int(input())\ns = input().split()[1]\nprint(solution(n, s)) "
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    s = input_list[1]\n    result = ''\n    if n > 1:\n        result = s[0] + s[2:]\n    return result\n\n\ninput_stdin = '''3\naaa\n5\nabcda'''\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    if len(set(s)) == 1:\n        return \"\"\n    if len(set(s)) == n:\n        return s\n    for i in range(n):\n        if s[i] != min(set(s)):\n            return s[:i] + s[i+1:]"
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    if n <= 1:\n        return s\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            return s[:i] + s[i + 1:]\n\n    return s[:-1]\n\n\ndef"
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    s = input_list[1]\n    if n > 1:\n        return s[:n-1] + \"a\"\n    else:\n        return \"aa\"\n"
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    s = input_list[1]\n    min_s = s[:n-1] + chr(ord(s[n-1])+1)\n    if min_s < s:\n        return min_s\n    else:\n        return s\n\n\ninput_str = \"\"\"3\naaa\n5\nabcda\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    if n == 1:\n        return \"\"\n    if n == 2:\n        return s[0]\n    removed = False\n    for i in range(1, n):\n        if s[i] < s[i-1]:\n            if not removed:\n                s = s[:i] + s[i+1:]\n                removed = True\n    return s\n\n\nstdin = \"\"\"\n3\naaa\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5\nabcda\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n2\nab\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n1\na\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n10\nabcdefghij\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n4\nabcd\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n1\na\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n7\nabcdefg\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n10\nabcdefghij\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n1\na\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n10\nabcdefghij\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3\naaa\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5\nabcda\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3\naaa\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5\nabcda\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3\naaa\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5\nabcda\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3\naaa\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5\nabcda\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 627,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    if n == 1:\n        return \"\"\n    s_list = list(s)\n    if n == 2:\n        if s_list[0] < s_list[1]:\n            s_list.pop(0)\n        else:\n            s_list.pop(1)\n    else:\n        for i in range(n):\n            if i > 0 and s_list[i] < s_list[i-1]:\n                s_list.pop(i)\n                break\n            if i < n-1 and s_list[i] < s_list[i+1]:\n                s_list.pop(i)\n                break\n    return ''.join(s_list)\n"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    book_prices = list(map(int, input_list[1].split()))\n\n    # Sort the book prices in ascending order\n    book_prices.sort()\n\n    # Calculate the sum of the first k books\n    k_books_sum = sum(book_prices[:k])\n\n    # Calculate the sum of the remaining n-k books\n    remaining_books_sum = sum(book_prices[k:])\n\n    # Calculate the bitwise AND of the k_books_sum and remaining_books_sum\n    beauty = k_books_sum & remaining_books_sum\n\n    return beauty\n\n\ndef"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Sort the books by price\n    a.sort()\n\n    # Initialize the beauty of the shelves\n    beauty = 0\n\n    # Calculate the maximum possible beauty\n    for i in range(k):\n        beauty |= a[i]\n\n    return beauty\n"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    prices = list(map(int, stdin.split()[2:]))\n\n    # Compute the value of each shelf as the sum of book prices\n    shelf_values = [sum(prices[:i]) for i in range(1, n+1)]\n\n    # Sort the shelves by their values in descending order\n    sorted_shelves = sorted(shelf_values, reverse=True)\n\n    # Compute the maximum possible beauty\n    max_beauty = 0\n    for i in range(k):\n        max_beauty |= sorted_shelves[i]\n\n    return max_beauty\n"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    prices = list(map(int, input_data[1].split()))\n\n    def bitwise_and(a, b):\n        return a & b\n\n    def calculate_shelf_value(shelf_prices):\n        return sum(shelf_prices)\n\n    def calculate_max_shelf_value(shelf_prices, k):\n        return sum(sorted(shelf_prices, reverse=True)[:k])\n\n    def calculate_shelves_beauty(shelf_prices, k):\n        max_shelf_value = calculate_max_shelf_value(shelf_prices, k)\n        beauty = 0\n        for i in range(1, k + 1):\n            beauty += max_shelf_value\n            max_shelf_value = calculate_max_shelf_value(shelf_prices, k - i)\n        return beauty\n\n    shelf_prices = []\n    for i in range(k):\n        shelf_prices.append(prices[:n // k])\n        prices = prices[n // k:]\n\n    beauty = 0\n    for i in range(k):\n        beauty += calculate_shelves_beauty(shelf_prices[i], k)\n\n    return beauty // k\n"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    prices = list(map(int, stdin.split()[2:]))\n    \n    def bitwise_and(a, b):\n        return a & b\n\n    def max_beauty(shelves):\n        return sum(map(lambda shelf: sum(shelf), shelves))\n\n    def split_books(prices, k):\n        shelves = [[] for _ in range(k)]\n        for i, price in enumerate(prices):\n            shelves[i % k].append(price)\n        return shelves\n\n    shelves = split_books(prices, k)\n    beauty = max_beauty(shelves)\n    return str(beauty)"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    prices = list(map(int, stdin.split()[2:]))\n    \n    # Initialize a list to store the values of each shelf\n    shelves = []\n    \n    # Calculate the value of each shelf\n    for i in range(0, n, k):\n        shelf_value = sum(prices[i:i+k])\n        shelves.append(shelf_value)\n    \n    # Compute the maximum possible beauty\n    max_beauty = shelves[0]\n    for i in range(1, k):\n        max_beauty &= shelves[i]\n    \n    return str(max_beauty)"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    books_prices = list(map(int, input_data[1].split()))\n\n    shelves_values = []\n    books_per_shelf = n // k\n    for i in range(k):\n        shelf_value = sum(books_prices[i * books_per_shelf:(i + 1) * books_per_shelf])\n        shelves_values.append(shelf_value)\n\n    beauty = shelves_values[0]\n    for i in range(1, k):\n        beauty &= shelves_values[i]\n\n    return beauty\n"
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    def bitwise_and(x: int, y: int) -> int:\n        return x & y\n    \n    def bitwise_and_of_shelves(shelves: List[int]) -> int:\n        return functools.reduce(bitwise_and, shelves)\n    \n    shelves = [0] * k\n    shelf_size = n // k\n    for i in range(k):\n        for j in range(shelf_size):\n            shelves[i] += a[i * shelf_size + j]\n    \n    return bitwise_and_of_shelves(shelves)\n\n\ninput_stdin = \"\"\"10 4\n9 14 28 1 7 13 15 29 2 31\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def max_and(prices: list) -> int:\n        max_value = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_value = max(max_value, prices[i] & prices[j])\n        return max_value\n\n    n, k = map(int, input().split())\n    prices = list(map(int, input().split()))\n    shelves = []\n\n    while k > 0:\n        shelf_prices = []\n        for i in range(n):\n            if k > 0:\n                shelf_prices.append(prices.pop(0))\n                k -= 1\n            else:\n                break\n        shelves.append(max_and(shelf_prices))\n\n    return max(shelves)\n\nn = 10\nk = 4\nstdin = f\"{n} {k}\\n9 14 28 1 7 13 15 29 2 31\"\nprint(solution(stdin))  # Output: 24\n\nn = 7\nk = 3\nstdin = f\"{n} {k}\\n3 14 15 92 65 35 89\"\nprint(solution(stdin))  # Output: 64 "
    },
    {
        "number": 628,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    books = sorted(map(int, input().split()), reverse=True)\n\n    total_sum = sum(books)\n    beauty = 0\n\n    for i in range(k):\n        shelf_sum = 0\n        for j in range(i * n // k, (i + 1) * n // k):\n            shelf_sum += books[j]\n        beauty |= shelf_sum\n\n    return beauty"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    total_time = 0\n    for i in range(n - 1):\n        total_time += a[i]\n\n    for j in range(n - 1):\n        total_time += b[j]\n\n    return str(total_time)\n"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [list(map(int, line.split())) for line in stdin.splitlines()[1:4]]\n    b = list(map(int, stdin.splitlines()[4].split()))\n    \n    a_min = min(a[0][i] + a[1][j] for i in range(n-1) for j in range(n-1))\n    b_min = min(b[j] for j in range(n))\n    \n    return str(a_min + b_min)"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = [[int(i) for i in input_list[1].split()], [int(i) for i in input_list[2].split()]]\n    b = [int(i) for i in input_list[3].split()]\n\n    total_time = 0\n\n    # First crossing on the avenue\n    total_time += a[1][0]\n\n    # Crossing from first row to second row\n    total_time += b[0]\n\n    # Second crossing on the avenue\n    total_time += a[0][n - 1]\n\n    # Crossing from second row to first row\n    total_time += b[n - 1]\n\n    # Last crossing on the avenue\n    total_time += a[1][n - 2]\n\n    return str(total_time)"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a_ij = list(map(int, stdin.split()[1:n]))\n    b_j = list(map(int, stdin.split()[n:]))\n\n    total_time = sum(b_j) + sum(a_ij) * (n - 1)\n\n    return str(total_time)\n\n\ndef"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, a_ij, b_j = [], [], []\n    for i in range(3):\n        input_line = input()\n        n.append(int(input_line.split()[0]))\n        a_ij.append([int(x) for x in input_line.split()[1:]])\n        b_j.append([int(x) for x in input_line.split()[1:]])\n    \n    # Total time to cross the avenue once\n    total_wait = sum(a_ij[0]) + sum(b_j)\n    \n    # Minimum waiting time at each crossing\n    min_wait = [min(a_ij[i][j], a_ij[i][j+1]) for i in range(2) for j in range(n[i]-1)] + [min(b_j[i][j], b_j[i+1][j]) for i in range(2) for j in range(n[i])]\n    \n    # Sum of minimum waiting times\n    total_min_wait = sum(min_wait)\n    \n    return total_min_wait + total_wait\n\ninput_file = open(\"input.txt\", \"r\")\ninput_stdin = input_file.read()\ninput_file.close()\n\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    total_time = 0\n    crossings = [(i, j) for i in range(1, n) for j in range(1, n)]\n    for i, j in crossings:\n        if i == 1:\n            total_time += a[j - 1]\n        elif j == n:\n            total_time += b[j - 1]\n        else:\n            total_time += a[j - 1]\n\n    return str(total_time)"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    a = [int(i) for i in input_data[1].split()]\n    b = [int(i) for i in input_data[2].split()]\n\n    total_time = 0\n    # Cross the avenue\n    total_time += a[n - 1]\n    # Use the first crossing in the first row\n    total_time += b[0]\n    # Use the first crossing in the second row\n    total_time += a[n - 1]\n    # Use the second crossing in the second row\n    total_time += b[n - 1]\n    # Cross the avenue\n    total_time += a[n - 1]\n\n    return str(total_time)"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    total_time = 0\n\n    # First row crossings\n    for i in range(1, n - 1):\n        total_time += a[i - 1]\n\n    # Last row crossings\n    for i in range(1, n):\n        total_time += b[i - 1]\n\n    # First and last crossings of the avenue\n    total_time += max(a[0], b[0])\n    total_time += max(a[n - 2], b[n - 1])\n\n    return str(total_time)\n"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()[1:]))\n    b = list(map(int, stdin.split()[2:]))\n\n    a = [[a[i], a[i+1]] for i in range(0, len(a), 2)]\n    b = [[b[i], b[i+1]] if i % 2 == 0 else [b[i-1], b[i]] for i in range(len(b))]\n\n    a.reverse()\n    b.reverse()\n\n    total_time = 0\n    for i in range(n-1):\n        total_time += max(a[i][0], a[i][1])\n    total_time += max(b[0][0], b[0][1])\n\n    return str(total_time)\n\n\ndef"
    },
    {
        "number": 629,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_time = 0\n    for i in range(n - 1):\n        total_time += a[i]\n\n    total_time += b[n - 1]\n\n    return str(total_time)\n"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, stdin.split()))\n    prev_messages = set()\n    curr_messages = set()\n    for i in range(n):\n        if a[i] > i:\n            curr_messages.add(a[i])\n        for j in range(max(0, i - k), min(i + k + 1, n)):\n            if a[j] > j:\n                curr_messages.add(a[j])\n        curr_messages -= prev_messages\n        prev_messages = curr_messages.copy()\n        if not curr_messages:\n            break\n    output = [len(prev_messages) for i in range(n)]\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        if a[i - 1] == 0:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = dp[i - 1]\n\n    for i in range(2, n + 1):\n        if a[i - 1] > 0 and a[i - 1] < i:\n            for j in range(max(1, i - k - 1), i):\n                if j != a[i - 1]:\n                    dp[i] += dp[j]\n\n    return ' '.join(map(str, dp))\n\n\nn = int(input())\nk = int(input())\na = list(map(int, input().split()))\n\nprint(solution(stdin)) "
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Initialize the sequence with the current message and the k previous and next messages\n    seq = [i for i in range(max(1, t-k), min(n, t+k+1))]\n    \n    # Initialize the number of distinct messages\n    num_distinct_messages = [1] * n\n    \n    # Initialize the message index map\n    message_index_map = [i for i in range(n)]\n    \n    for i in range(n):\n        # Get the current message\n        message = seq[k]\n        \n        # Check if there is a link to a previous message\n        if a[message] > 0:\n            # Update the message index map\n            message_index_map[a[message]] = i\n            \n            # Add the previous message to the sequence\n            seq.insert(k+1, a[message])\n        \n        # Check if there is a link to a next message\n        if a[message] < n-1:\n            # Add the next message to the sequence\n            seq.insert(k+1, a[message]+1)\n        \n        # Check if the link sequence breaks\n        if a[message] == 0 or a[message] >= seq[k]:\n            # Check if there are less than k messages somewhere\n            if any(i < k+1 and i > 0 for i in seq):\n                # Update the number of distinct messages\n                num_distinct_messages[t] += 1\n            \n            # Remove the current message from the sequence\n            seq.pop(k)\n        \n        # Move to the next message\n        t += 1\n        \n    # Return the number of distinct messages for each message index\n    return ' '.join(map(str, num_distinct_messages))\n"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def read_messages(t: int) -> int:\n        visited = set()\n        i = t\n        while i > 0:\n            visited.add(i)\n            if i in a and a[i] < i:\n                i = a[i]\n            else:\n                i = 0\n        return len(visited)\n\n    result = [read_messages(i) for i in range(1, n + 1)]\n    return \" \".join(map(str, result))"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    mod = 10**9 + 7\n\n    # initialize a dictionary to store the visited messages\n    visited = {}\n    # initialize the result list with all 0s\n    result = [0] * n\n    # initialize the current index\n    curr_index = 0\n\n    def dfs(index):\n        nonlocal curr_index\n        # if the message is already visited, return\n        if visited.get(index, 0):\n            return\n        # mark the message as visited\n        visited[index] = curr_index\n        # add the current index to the result list\n        result[index] += curr_index\n        # if there's a link, go to the next message and continue the DFS\n        if a[index]:\n            dfs(a[index])\n            # update the current index\n            curr_index += 1\n\n    # start the DFS from the first message\n    dfs(0)\n\n    # return the result list\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, k = map(int, input_values[0].split())\n    a = list(map(int, input_values[1].split()))\n    mod = 10**9 + 7\n\n    def dfs(i, visited):\n        if i in visited:\n            return 0\n        visited.add(i)\n        count = 1\n        if a[i] != 0:\n            count += dfs(a[i] - 1, visited)\n        if i - k - 1 >= 0:\n            count += dfs(i - k - 1, visited)\n        if i + k < n:\n            count += dfs(i + k, visited)\n        return count\n\n    result = [dfs(i, set()) for i in range(n)]\n\n    return ' '.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    def count_distinct_messages(t: int) -> int:\n        visited = set()\n        messages_read = 0\n        queue = [t]\n        \n        while queue:\n            current = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                messages_read += 1\n                if k < a[current] < current:\n                    queue.append(a[current])\n                    \n        return messages_read\n    \n    result = [count_distinct_messages(i) for i in range(1, n+1)]\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        return n, k, a\n\n    def count_messages(n: int, k: int, a: list, t: int) -> int:\n        visited = [False] * (n + 1)\n        visited[t] = True\n        stack = [t]\n        total_messages = 1\n        while stack:\n            message = stack.pop()\n            total_messages += 1\n            if message == 0:\n                break\n            if visited[a[message - 1]]:\n                continue\n            visited[a[message - 1]] = True\n            stack.append(a[message - 1])\n\n        return total_messages\n\n    n, k, a = read_input()\n    result = [count_messages(n, k, a, i) for i in range(1, n + 1)]\n    return \" \".join(map(str, result))\n\n\ninput_data = \"\"\"6 0\n0 1 1 2 3 2\n10 1\n0 1 0 3 4 5 2 3 7 0\n2 2\n0 1\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def count_distinct_messages(t):\n        seen = set()\n        i = t\n        while i <= n:\n            seen.add(i)\n            j = a[i-1]\n            while j > 0 and j < i:\n                seen.add(j)\n                j = a[j-1]\n            i += 1\n        return len(seen)\n\n    result = [count_distinct_messages(i) for i in range(1, n+1)]\n    return ' '.join(map(str, result))\n\n\ninput_stdin = \"\"\"6 0\n0 1 1 2 3 2\"\"\"\noutput_stdout = \"1 2 2 3 3 3\"\n\ninput_stdin = \"\"\"10 1\n0 1 0 3 4 5 2 3 7 0\"\"\"\noutput_stdout = \"2 3 3 4 5 6 6 6 8 2\"\n\ninput_stdin = \"\"\"2 2\n0 1\"\"\"\noutput_stdout = \"2 2\"\n\n\nassert solution(input_stdin) == output_stdout"
    },
    {
        "number": 630,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, stdin.split()))\n    \n    result = [1] * n\n    \n    for i in range(n):\n        if a[i] > i:\n            for j in range(max(0, i - k), min(i + k + 1, n)):\n                if a[i] > a[j]:\n                    result[i] += result[a[j]]\n    \n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n, m, a):\n        total = sum(a)\n        if total == m:\n            return True\n        return False\n\n    def compute_sum(n, m, a):\n        total = sum(a)\n        s = 0\n        for i in range(n):\n            s += sum([a[j] / (j + 1) for j in range(i, n)])\n        return s\n\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        if is_possible(n, m, a):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        total_sum = sum(a)\n        if m % n != 0:\n            print(\"NO\")\n            continue\n        if total_sum < m:\n            print(\"NO\")\n            continue\n        expected_sum = m // n\n        for i in range(n):\n            if sum(a[i:]) < expected_sum:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(a: List[int], m: int) -> bool:\n        total_sum = sum(a)\n        if m > total_sum:\n            return False\n        inner_sum = 0\n        for i in range(len(a)):\n            inner_sum += a[i] / (i + 1)\n            if inner_sum >= m:\n                return True\n        return False\n\n    t = int(stdin)\n    result = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        if is_possible(a, m):\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sum(n: int, a: list) -> float:\n        total = 0\n        for i in range(n):\n            total += sum([a[j] / (j + 1) for j in range(i, n)])\n        return total\n\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t + 1):\n        n, m = map(int, stdin.split('\\n')[i * 2 - 1].split())\n        a = list(map(int, stdin.split('\\n')[i * 2].split()))\n        if calculate_sum(n, a) == m:\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return '\\n'.join(output)\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for i in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n\n        if sum(a) * n - m > 0:\n            print(\"NO\")\n        else:\n            # Create a list to store the remaining values\n            remaining = [m - (sum(a) * n - a[j] * j) for j in range(n)]\n\n            # Check if the remaining values are all positive\n            if all(x > 0 for x in remaining):\n                # Create a list to store the reordering\n                reorder = []\n\n                # Iterate through the remaining values and find the index with the smallest value\n                index = remaining.index(min(remaining))\n\n                # Add the index to the reordering list\n                reorder.append(index)\n\n                # Remove the value at the index from the remaining list\n                remaining.pop(index)\n\n                # Calculate the new value for the remaining values and add it to the reordering list\n                new_value = sum(a[j] * j for j in range(index + 1, n)) + remaining[0]\n                reorder.append(index + 1)\n\n                # Remove the value at the index from the remaining list\n                remaining.pop(0)\n\n                # Calculate the new value for the remaining values and add it to the reordering list\n                reorder.append(index)\n                reorder.append(index + 1)\n                new_value -= sum(a[j] * j for j in range(index + 1, n)) + remaining[0]\n                reorder.append(index + 2)\n\n                # Remove the value at the index from the remaining list\n                remaining.pop(0)\n\n                # Calculate the new value for the remaining values and add it to the reordering list\n                reorder.append(index)\n                reorder.append(index + 1)\n                new_value -= sum(a[j] * j for j in range(index + 1, n)) + remaining[0]\n                reorder.append(index + 3)\n\n                # Remove the value at the index from the remaining list\n                remaining.pop(0)\n\n                # Calculate the new value for the remaining values and add it to the reordering list\n                reorder.append(index)\n                reorder.append(index + 1)\n                new_value -= sum(a[j] * j for j in range(index + 1, n)) + remaining[0]\n                reorder.append(index + 4)\n\n                # Check if the reordering is possible and if the new sum is equal to the given value\n                if new_value == m:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n            else:\n                print(\"NO\")\n    return"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        total_sum = sum(a)\n        if total_sum == m:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        sum_a = sum(a)\n        if sum_a % n != 0:\n            print(\"NO\")\n        else:\n            s = (sum_a // n) * (1 + n) // 2\n            if s == m:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\n\ninput_str = \"\"\"2\n3 8\n2 5 1\n4 4\n0 1 2 3\"\"\"\n\nsolution(input_str) "
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(m, n, a):\n        total = 0\n        for i in range(n):\n            total += sum(a[j] / (j + 1) for j in range(i, n))\n        return total == m\n\n    t = int(stdin.split(\"\\n\")[0])\n    output = []\n    for _ in range(t):\n        n, m = map(int, stdin.split(\"\\n\")[1].split())\n        a = list(map(int, stdin.split(\"\\n\")[2].split()))\n        if is_valid(m, n, a):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.readline())\n    result = []\n    for i in range(test_cases):\n        n, m = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        memo = [0] * (n + 1)\n        memo[0] = 1\n        for j in range(1, n + 1):\n            memo[j] = memo[j - 1] + a[j - 1] / j\n        if sum(memo) == m:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 631,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split(\"\\n\")[0])\n    result = []\n    \n    for _ in range(t):\n        n, m = map(int, stdin.split(\"\\n\")[1].split())\n        a = list(map(int, stdin.split(\"\\n\")[2].split()))\n        \n        for i in range(n):\n            if sum(a[i:]) >= m:\n                result.append(\"YES\")\n                break\n        else:\n            result.append(\"NO\")\n    \n    return \"\\n\".join(result)\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    outputs = []\n\n    for _ in range(t):\n        n, k = map(int, input().split())\n        divisor = n\n        for _ in range(k):\n            divisor *= f(divisor)\n        outputs.append(divisor)\n\n    return '\\n'.join(map(str, outputs))\n\n\ninput_stdin = \"\"\"3\n5 1\n8 2\n3 4\"\"\"\n\noutput_stdout = \"\"\"10\n12\n12\"\"\"\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_smallest_divisor(n: int) -> int:\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                if i != n // i:\n                    divisors.add(n // i)\n        return min(divisors)\n\n    t = int(stdin.split()[0])\n    output = []\n    for i in range(1, t + 1):\n        n, k = map(int, stdin.split()[i])\n        new_n = n\n        for j in range(k):\n            divisor = find_smallest_divisor(new_n)\n            new_n += divisor\n        output.append(new_n)\n    return \"\\n\".join(map(str, output))\n\n\ninput_str = \"\"\"3\n5 1\n8 2\n3 4\"\"\"\n\nprint(solution(input_str))\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    input_data = stdin.split()[1:]\n    output = []\n\n    for i in range(t):\n        n, k = map(int, input_data[i * 2:(i + 1) * 2])\n        f_n = n\n\n        for j in range(k):\n            f_n += 1\n            divisors = [1]\n            for i in range(2, int(f_n ** 0.5) + 1):\n                if f_n % i == 0:\n                    if i != f_n // i:\n                        divisors.append(i)\n                        divisors.append(f_n // i)\n            divisors.sort()\n            f_n = divisors[-2]\n\n        output.append(f_n)\n\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    \n    for i in range(t):\n        n, k = map(int, input().split())\n        divisor = 1\n        \n        while k > 0:\n            divisor += 1\n            while n % divisor == 0:\n                n //= divisor\n            k -= 1\n        \n        output.append(n + 1)\n    \n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def f(n: int) -> int:\n        divisors = [1]\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                if i != n // i:\n                    divisors.append(i)\n                if n // i != i:\n                    divisors.append(n // i)\n        divisors.sort()\n        return divisors[1]\n\n    t = int(stdin.splitlines()[0])\n    queries = stdin.splitlines()[1:]\n    result = []\n\n    for query in queries:\n        n, k = map(int, query.split())\n        for _ in range(k):\n            n += f(n)\n        result.append(n)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    result = []\n    \n    for _ in range(t):\n        n, k = map(int, input().split())\n        divisors = set(range(1, n+1))\n        \n        for _ in range(k):\n            smallest_divisor = min(divisors)\n            n += smallest_divisor\n            divisors.remove(smallest_divisor)\n        \n        result.append(n)\n    \n    return '\\n'.join(map(str, result))\n\n\ninput_stdin = \"\"\"3\n5 1\n8 2\n3 4\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    inputs = stdin.split('\\n')[1:]\n    \n    for i in range(t):\n        n, k = map(int, inputs[i].split())\n        current_n = n\n        for j in range(k):\n            f_n = current_n\n            for div in range(2, int(f_n ** 0.5) + 1):\n                if f_n % div == 0:\n                    if div * div == f_n:\n                        current_n += div\n                    else:\n                        current_n += div + f_n // div\n                    break\n            else:\n                if f_n > 2:\n                    current_n += f_n\n        print(current_n)\n\ninput_data = \"\"\"3\n5 1\n8 2\n3 4\"\"\"\n\nsolution(input_data) "
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    queries = stdin.split('\\n')[1:]\n\n    def find_f(n: int) -> int:\n        divisors = set(x for t in range(1, int(n**0.5) + 1) if n % t == 0 for x in (t, n//t))\n        return min(x for x in divisors if x != 1)\n\n    for i in range(t):\n        n, k = map(int, queries[i].split())\n        result = n\n        for _ in range(k):\n            result = result + find_f(result)\n        print(result)\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for i in range(t):\n        n, k = map(int, stdin.split()[1:])\n        while k > 0 and n != 1:\n            f_n = min(x for x in range(2, n + 1) if n % x == 0)\n            n += f_n\n            k -= 1\n        print(n)\n"
    },
    {
        "number": 632,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for i in range(t):\n        n, k = map(int, stdin.split())\n        for j in range(k):\n            n = n * (n // f(n) + 1)\n        output.append(n)\n    return \"\\n\".join(map(str, output))\n\n\ndef"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n < 2 or m < 1 or n > 10**5 or m > 10**5:\n        return \"Impossible\"\n\n    edges = []\n    num_vertices = 2\n    num_edges = 0\n\n    while num_edges < m:\n        v = random.randint(1, n)\n        u = random.randint(1, n)\n\n        if v == u:\n            continue\n\n        for edge in edges:\n            if edge == (v, u) or edge == (u, v):\n                break\n        else:\n            num_edges += 1\n            edges.append((v, u))\n            num_vertices = max(num_vertices, v, u)\n\n    if num_edges < m:\n        return \"Impossible\"\n\n    return \"Possible\\n\" + \"\\n\".join(map(str, edges))\n"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m < n - 1:\n        return \"Impossible\"\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        v, u = map(int, input().split())\n        graph[v].append(u)\n        graph[u].append(v)\n    return \"Possible\\n\" + \"\\n\".join(str(edge[0]) + \" \" + str(edge[1]) for edge in graph if len(graph[edge[0]]) == 1 and len(graph[edge[1]]) == 1)\n\n\ninput_data = \"\"\"5 6\n2 5\n3 2\n5 1\n3 4\n4 1\n5 4\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n < 2 or n > 10**5 or m < 1 or m > 10**5:\n        return \"Impossible\"\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def generate_graph():\n        result = []\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if is_prime(abs(i - j)) and (i, j) not in result:\n                    result.append((i, j))\n                    if len(result) == m:\n                        return result\n        return None\n\n    graph = generate_graph()\n    if graph is None:\n        return \"Impossible\"\n    else:\n        return \"Possible\\n\" + \"\\n\".join(str(edge) for edge in graph)"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    if n == 1:\n        return \"Impossible\"\n    \n    if m == 0:\n        return \"Possible\"\n    \n    def is_valid_edge(v, u, used):\n        if v == u or v in used or u in used:\n            return False\n        return True\n    \n    def find_edges(used):\n        edges = []\n        for v in range(1, n+1):\n            for u in range(v+1, n+1):\n                if is_valid_edge(v, u, used):\n                    edges.append((v, u))\n        return edges\n    \n    def backtrack(used, edges):\n        if len(edges) == m:\n            return edges\n        \n        for v, u in find_edges(used):\n            if is_valid_edge(v, u, used):\n                used.add(v)\n                used.add(u)\n                edges.append((v, u))\n                result = backtrack(used, edges)\n                if result is not None:\n                    return result\n                used.remove(v)\n                used.remove(u)\n                edges.pop()\n    \n    result = backtrack(set(), [])\n    if result is None:\n        return \"Impossible\"\n    \n    output = \"Possible\\n\"\n    for edge in result:\n        output += f\"{edge[0]} {edge[1]}\\n\"\n    return output"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    # Check if the input is valid\n    if not (1 <= n <= 10**5) or not (1 <= m <= 10**5):\n        return \"Impossible\"\n\n    # Generate a random relatively prime graph\n    from random import randint\n\n    adj_list = [[] for _ in range(n)]\n    visited = [False] * n\n    edges = []\n\n    def dfs(v):\n        visited[v] = True\n        for u in range(n):\n            if not visited[u] and (randint(1, n) == 1 or n % 2 == 0):\n                adj_list[v].append(u)\n                adj_list[u].append(v)\n                edges.append((v, u))\n                dfs(u)\n\n    dfs(0)\n\n    if len(edges) < m:\n        # Add extra edges to make the graph connected\n        from itertools import combinations\n        available_vertices = set(range(n)) - {v for edge in edges for v in edge}\n        for u, v in combinations(available_vertices, 2):\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            edges.append((u, v))\n            if len(edges) == m:\n                break\n\n    if len(edges) < m:\n        # Remove excess edges to make the graph satisfy the constraints\n        excess_edges = len(edges) - m\n        for _ in range(excess_edges):\n            edges.pop()\n\n    # Check if the graph satisfies the constraints\n    for edge in edges:\n        if GCD(*edge) != 1:\n            return \"Impossible\"\n\n    # Output the result\n    return \"Possible\\n\" + \"\\n\".join(f\"{v} {u}\" for v, u in edges)\n"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    # Check if n and m are valid\n    if n < 2 or n > 10**5 or m < 1 or m > 10**5:\n        return \"Impossible\"\n    \n    # Generate a random connected graph\n    graph = nx.gnm_random_graph(n, m)\n    \n    # Check if the graph is connected\n    if not nx.is_connected(graph):\n        return \"Impossible\"\n    \n    # Check for multiple edges\n    if len(graph.edges()) > m:\n        return \"Impossible\"\n    \n    # Check for self-loops\n    if any(v == u for (v, u) in graph.edges()):\n        return \"Impossible\"\n    \n    # Check for relative primality\n    for (u, v) in graph.edges():\n        if math.gcd(u, v) != 1:\n            return \"Impossible\"\n    \n    # Output the graph as a list of edges\n    output = \"Possible\\n\" + \"\\n\".join(map(str, graph.edges()))\n    return output\n"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n < 3 or m < 1 or n > 10**5 or m > 10**5:\n        return \"Impossible\"\n\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n\n    def check_gcd(v, u, gcd):\n        if gcd == 1:\n            return True\n        for i in range(2, int(v * u**0.5) + 1):\n            if v % i == 0 and u % i == 0:\n                return False\n        return True\n\n    def find_connected(edges):\n        g = Graph(n)\n        for v, u in edges:\n            if not g.add_edge(v-1, u-1):\n                return None\n        return g\n\n    class Graph:\n        def __init__(self, n):\n            self.adj_list = [[] for _ in range(n)]\n            self.visited = [False] * n\n\n        def add_edge(self, v, u):\n            if v == u:\n                return False\n            if v not in self.adj_list[u]:\n                self.adj_list[v].append(u)\n                self.adj_list[u].append(v)\n                return True\n            return False\n\n        def dfs(self, u, gcd):\n            self.visited[u] = True\n            for v in self.adj_list[u]:\n                if not self.visited[v]:\n                    if check_gcd(u+1, v+1, gcd):\n                        if self.dfs(v, gcd):\n                            return True\n            return False\n\n        def is_connected(self, gcd):\n            start = 0\n            while not self.visited[start]:\n                if self.dfs(start, gcd):\n                    return True\n                start += 1\n            return False\n\n    if m == n*(n-1)//2:\n        gcd = 1\n        for v, u in edges:\n            gcd = gcd * math.gcd(v, u)\n        gcd = math.gcd(gcd, n)\n    else:\n        gcd = math.gcd(n, m)\n        if gcd == 1:\n            return \"Impossible\"\n        for v, u in edges:\n            if math.gcd(v, u) != 1:\n                return \"Impossible\"\n\n    if gcd != 1:\n        return \"Impossible\"\n\n    g = find_connected(edges)\n    if g is None:\n        return \"Impossible\"\n\n    if not g.is_connected(gcd):\n        return \"Impossible\"\n\n    return \"Possible\\n\" + \"\\n\".join([f\"{v} {u}\" for v, u in edges])\n"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, m = map(int, input_str.split())\n\n    if n == 1:\n        return \"Impossible\"\n\n    g = nx.Graph()\n    g.add_nodes_from(range(1, n + 1))\n\n    if m == 0:\n        if n > 2:\n            return \"Impossible\"\n        else:\n            g.add_edge(1, 2)\n    else:\n        edges = [(i + 1, (i * n) % (n * (n - 1) // 2) + 1) for i in range(m)]\n        for u, v in edges:\n            if u == v:\n                return \"Impossible\"\n            else:\n                g.add_edge(u, v)\n\n    if not nx.is_connected(g):\n        return \"Impossible\"\n\n    if len(g) < n:\n        return \"Impossible\"\n\n    return \"Possible\\n\" + \"\\n\".join(map(str, sorted(edges)))"
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    if n < 2 or m < 1:\n        return \"Impossible\"\n    \n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n    \n    def generate_graph(n, m):\n        if m > n * (n - 1) // 2:\n            return \"Impossible\"\n        \n        adj_list = [[] for _ in range(n + 1)]\n        num_edges = 0\n        \n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                if num_edges == m:\n                    break\n                \n                if gcd(i, j) == 1:\n                    adj_list[i].append(j)\n                    adj_list[j].append(i)\n                    num_edges += 1\n        \n        if num_edges < m:\n            return \"Impossible\"\n        \n        return adj_list\n    \n    adj_list = generate_graph(n, m)\n    \n    if adj_list == \"Impossible\":\n        return \"Impossible\"\n    \n    edges = []\n    for i in range(1, n + 1):\n        for j in adj_list[i]:\n            edges.append((i, j))\n    \n    return \"Possible\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), edges)) "
    },
    {
        "number": 633,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m == 0:\n        return \"Impossible\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def generate_graph(n, m):\n        if m == 1:\n            return [(1, 2)]\n\n        edges = []\n        for i in range(1, n):\n            edges.append((i, i + 1))\n            m -= 1\n            if m == 0:\n                break\n\n        if m > 0:\n            return \"Impossible\"\n\n        edges = sorted(edges, key=lambda x: x[0])\n        return edges\n\n    graph = generate_graph(n, m)\n    if graph == \"Impossible\":\n        return \"Impossible\"\n\n    result = [\"Possible\"]\n    for edge in graph:\n        result.append(f\"{edge[0]} {edge[1]}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed_cells = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n    \n    for cell in reclaimed_cells:\n        r, c = cell\n        for dr, dc in [(-1, 2), (1, 2), (2, 1)]:\n            if 1 <= r + dr <= r and 1 <= c + dc <= 2:\n                reclaimed_cells.append((r + dr, c + dc))\n    \n    for cell in reclaimed_cells:\n        r, c = cell\n        if (r, c) == (r - 1, 3 - c) or (r, c) == (r, 3 - c) or (r, c) == (r + 1, 3 - c):\n            continue\n        else:\n            return \"WIN\"\n    \n    return \"LOSE\"\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed_cells = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def is_valid_cell(r, c):\n        for dr, dc in ((-1, 2), (0, 2), (1, 2), (-1, 1), (0, 1), (1, 1), (-1, 0), (0, 0), (1, 0)):\n            new_r, new_c = r + dr, c + dc\n            if 1 <= new_r <= r and 1 <= new_c <= 2 and (new_r, new_c) not in reclaimed_cells:\n                return False\n        return True\n\n    if n == r * 2:\n        return \"WIN\"\n    else:\n        for i in range(1, r + 1):\n            if is_valid_cell(i, 1) and is_valid_cell(i, 2):\n                return \"WIN\"\n        return \"LOSE\"\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def can_reclaim_cell(r: int, c: int, reclaimed_cells: set) -> bool:\n        for dr, dc in [(-1, 2), (0, 2), (1, 2), (-1, 1), (0, 1), (1, 1)]:\n            if (r + dr, c + dc) in reclaimed_cells:\n                return False\n        return True\n\n    def find_last_reclaimer(reclaimed_cells: set) -> int:\n        for r in range(1, r + 1):\n            if can_reclaim_cell(r, 1, reclaimed_cells) and can_reclaim_cell(r, 2, reclaimed_cells):\n                return r\n        return -1\n\n    def is_last_reclaimer(last_reclaimer: int, reclaimed_cells: set) -> bool:\n        for r, c in reclaimed_cells:\n            if r == last_reclaimer:\n                return False\n        return True\n\n    def main():\n        r, n = map(int, stdin.split()[:2])\n        reclaimed_cells = set(tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2 * n + 2, 2))\n        last_reclaimer = find_last_reclaimer(reclaimed_cells)\n        return \"WIN\" if last_reclaimer == -1 or is_last_reclaimer(last_reclaimer, reclaimed_cells) else \"LOSE\"\n\n    return main() "
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[0:2])\n    reclaimed_cells = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n + 1]]\n    reclaimed_cells.sort()\n    reclaimed_cells.reverse()\n\n    for i in range(n):\n        row, col = reclaimed_cells[i]\n        if row == 1:\n            continue\n        if (row - 1, 3 - col) in reclaimed_cells or (row, 3 - col) in reclaimed_cells or (row + 1, 3 - col) in reclaimed_cells:\n            return \"LOSE\"\n\n    return \"WIN\"\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed_cells = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    if n == r:\n        return \"WIN\"\n\n    for i in range(1, r+1):\n        for j in range(1, 3):\n            valid_cells = [(i-1, 3-j), (i, 3-j), (i+1, 3-j)]\n            if any([cell not in reclaimed_cells for cell in valid_cells]):\n                return \"WIN\"\n\n    return \"LOSE\"\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, input().split())\n    reclaimed_cells = []\n    for _ in range(n):\n        r_i, c_i = map(int, input().split())\n        reclaimed_cells.append((r_i, c_i))\n    \n    # Check if the last city can win\n    for r_i, c_i in reclaimed_cells:\n        for dr, dc in [(-1, 2), (1, 2), (0, 1)]:\n            if (r_i + dr, c_i + dc) not in reclaimed_cells:\n                return \"WIN\"\n    \n    return \"LOSE\""
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, n = map(int, input_list.pop(0).split())\n    reclaimed_cells = []\n\n    for _ in range(n):\n        reclaimed_cells.append(tuple(map(int, input_list.pop(0).split())))\n\n    reclaimed_cells.sort()\n    last_reclaimed_cell = reclaimed_cells[-1] if reclaimed_cells else None\n\n    if last_reclaimed_cell is None or last_reclaimed_cell[1] == 1:\n        return \"WIN\"\n\n    for r_i, c_i in reclaimed_cells:\n        for row_delta in (-1, 0, 1):\n            for col_delta in (-1, 0, 1):\n                new_r = r_i + row_delta\n                new_c = c_i + col_delta\n\n                if 1 <= new_r <= r and 1 <= new_c <= 2:\n                    if (new_r, new_c) not in reclaimed_cells:\n                        return \"LOSE\"\n\n    return \"WIN\"\n"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed_cells = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    cells_to_reclaim = [(i, j) for i in range(1, r+1) for j in range(1, 3)]\n    \n    for reclaimed in reclaimed_cells:\n        cells_to_reclaim.remove(reclaimed)\n    \n    if not cells_to_reclaim:\n        return \"WIN\"\n    \n    last_city = len(cells_to_reclaim) % 2\n    \n    for cell in cells_to_reclaim:\n        if cell[1] == 1:\n            if cell[0] - 1 not in [r[0] for r in reclaimed_cells]:\n                if last_city == 0:\n                    return \"WIN\"\n                last_city = 1\n            else:\n                last_city = 0\n        elif cell[1] == 2:\n            if cell[0] + 1 not in [r[0] for r in reclaimed_cells]:\n                if last_city == 1:\n                    return \"WIN\"\n                last_city = 0\n            else:\n                last_city = 1\n                \n    return \"LOSE\"\n\n\ndef"
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed_cells = [tuple(map(int, stdin.split()[2*i:2*i+2])) for i in range(n)]\n\n    river_area = set()\n    for i in range(1, r+1):\n        for j in range(1, 3):\n            river_area.add((i, j))\n\n    for cell in reclaimed_cells:\n        for delta_row, delta_col in [(1, 2), (-1, 2), (1, -2), (-1, -2)]:\n            river_area.discard((cell[0] + delta_row, cell[1] + delta_col))\n\n    for i in range(1, r+1):\n        for j in range(1, 3):\n            if (i, j) in river_area:\n                river_area.discard((i, j))\n\n    if not river_area:\n        return \"WIN\"\n    else:\n        return \"LOSE\""
    },
    {
        "number": 634,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split()[:2])\n    reclaimed = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n\n    def is_valid(cell):\n        row, col = cell\n        for r, c in reclaimed:\n            if (row - r, 3 - c) == (0, 0) or (row - r, 3 - c) == (0, 1) or (row - r, 3 - c) == (1, 0):\n                return False\n        return True\n\n    if n >= r:\n        return \"WIN\"\n\n    last_city = (r, 1) if n % 2 == 0 else (r, 2)\n    if is_valid(last_city):\n        return \"WIN\"\n    else:\n        return \"LOSE\""
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, s = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n\n    if a[s] == 1 and b[n] == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s, a, b = input().split()\n    n, s, a, b = int(n), int(s), list(map(int, a.split())), list(map(int, b.split()))\n\n    for i in range(1, n + 1):\n        if a[i - 1] == 0 and b[i - 1] == 0:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:2*n+2]))\n\n    if a[s-1] + b[n-s+1] == 2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s, a, b = map(int, input().split())\n    a, b = a[1:], b[1:]\n    \n    for i in range(n):\n        if a[i] == 0 and b[i] == 0:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    if a[s] == 1 and b[n] == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(track: int, station: int) -> bool:\n        if track == 1:\n            return a[station] == 1\n        else:\n            return b[station] == 1\n\n    n, s, *data = stdin.split()\n    n, s = int(n), int(s)\n    a = [int(x) for x in data[:n]]\n    b = [int(x) for x in data[n:]]\n\n    if is_valid(1, s) and is_valid(2, n):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n    \n    for i in range(1, n+1):\n        if i <= s and a[i-1] == 0:\n            return \"NO\"\n        elif i > s and b[i-1] == 0:\n            return \"NO\"\n    return \"YES\"\n\ndef"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def can_travel(station: int, track: int, is_open: list) -> bool:\n        if is_open[station - 1][track - 1] == 0:\n            return False\n        if is_open[station - 1][track - 1] == 1:\n            if (station - 1, track - 1) in visited:\n                return False\n            visited.add((station - 1, track - 1))\n            return True\n        return False\n\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    b = list(map(int, stdin.split()[n + 2:]))\n    is_open = [[a[i], b[i]] for i in range(n)]\n    visited = set()\n\n    if can_travel(s, 1, is_open) or can_travel(s, 2, is_open):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def check_path(n: int, s: int, a: list, b: list) -> bool:\n        \"\"\"\n        Check if there's a path from station 1 to station s.\n        \"\"\"\n        opened = [a[i] or b[i] for i in range(n)]\n        if opened[0] == 0 or opened[s] == 0:\n            return False\n        if not (a[0] or b[0]):\n            return opened[n - 1] != 0\n        for i in range(n):\n            if opened[i] == 0:\n                continue\n            if i < s and a[i + 1] == 0:\n                return False\n            if i > s and b[i - 1] == 0:\n                return False\n        return True\n\n    # Read input\n    lines = stdin.splitlines()\n    n, s = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    # Check if there's a path from station 1 to station s\n    if check_path(n, s, a, b):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 635,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * n:2]))\n    b = list(map(int, stdin.split()[3:3 * n:2]))\n\n    for i in range(n):\n        if a[i] + b[i] == 0:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    if k < n:\n        return \"0\\n\"\n    a.sort(reverse=True)\n    m = 0\n    res = []\n    for i in range(n):\n        if k >= a[i]:\n            k -= a[i]\n            m += 1\n            res.append(i+1)\n    return f\"{m}\\n{' '.join(map(str, res))}\"\n\n\ndef"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # sort the instruments by learning time\n    a.sort()\n\n    m = 0\n    indices = []\n\n    # iterate over the sorted instruments\n    for i in range(n):\n        # if we can still learn the instrument and we have enough time\n        if k >= a[i] and m < n:\n            # add the instrument to the list\n            indices.append(i + 1)\n            # reduce the number of days left\n            k -= a[i]\n            # increment the number of instruments learned\n            m += 1\n\n    # output the maximum number of instruments and their indices\n    output = f\"{m}\\n\" + \" \".join(map(str, indices))\n    return output\n\n\ndef"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    a.sort()\n    res = 0\n    m = 0\n    for i in range(n):\n        if a[i] <= k:\n            k -= a[i]\n            res += 1\n        else:\n            break\n    m = res\n    result = [str(i + 1) for i in range(m)]\n    return str(m) + \"\\n\" + \" \".join(result) + \"\\n\"\n"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    a_sum = sum(a)\n    max_instruments = n\n    if a_sum > k:\n        max_instruments = k // a_sum\n\n    if max_instruments == 0:\n        return \"0\\n\"\n\n    result = sorted(range(n), key=lambda x: a[x], reverse=True)[:max_instruments]\n\n    return f\"{max_instruments}\\n{' '.join(map(str, result))}\\n\"\n\n\ninput_string = \"\"\"4 10\n4 3 1 2\n5 6\n4 3 1 1 2\n1 3\n4\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    instruments = list(map(int, input_list[1].split()))\n\n    max_instruments = 0\n    best_indices = []\n\n    for i in range(1, n + 1):\n        days_left = k\n        current_instrument = 0\n        current_days = 0\n\n        while days_left > 0 and current_instrument < i:\n            days_left -= instruments[current_instrument]\n            current_instrument += 1\n            current_days += 1\n\n        if current_instrument == i and current_days > max_instruments:\n            max_instruments = current_days\n            best_indices = list(range(1, i + 1))\n\n    output_list = [str(max_instruments)]\n    output_list.extend(map(str, best_indices))\n    return \"\\n\".join(output_list)"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    a.sort(reverse=True)\n    days_spent = 0\n    answer = []\n\n    for i in range(n):\n        if days_spent + a[i] <= k:\n            answer.append(i + 1)\n            days_spent += a[i]\n\n    return f\"{len(answer)}\\n{' '.join(map(str, answer))}\""
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, k = input_values[0], input_values[1]\n    instruments = input_values[2:]\n    days_to_learn = list(sorted(instruments, reverse=True))\n\n    learned_instruments = []\n    days_spent = 0\n\n    for i in range(len(days_to_learn)):\n        if days_spent + days_to_learn[i] <= k:\n            learned_instruments.append(i + 1)\n            days_spent += days_to_learn[i]\n\n    output = f\"{len(learned_instruments)}\\n\" + \" \".join(map(str, learned_instruments))\n    return output\n\n\nstdin = \"4 10\\n4 3 1 2\"\nprint(solution(stdin))\n\nstdin = \"5 6\\n4 3 1 1 2\"\nprint(solution(stdin))\n\nstdin = \"1 3\\n4\"\nprint(solution(stdin)) "
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Sort the instruments by learning time\n    a.sort(reverse=True)\n    \n    # Calculate the total learning time\n    total_time = sum(a)\n    \n    # Check if we have enough time to learn all instruments\n    if total_time > k:\n        return \"0\\n\"\n    \n    # Calculate the maximum number of instruments we can learn\n    max_instruments = n\n    \n    # Initialize the result\n    result = []\n    \n    # Iterate through the instruments\n    for i in range(n):\n        # Add the current instrument to the result\n        result.append(i + 1)\n        \n        # Decrease the total learning time by the current instrument learning time\n        total_time -= a[i]\n        \n        # If we have enough time to learn the next instrument, add it to the result\n        if total_time >= a[i]:\n            result.append(i + 2)\n            total_time -= a[i]\n        \n        # Remove the instruments we have already added to the result\n        if i > 0:\n            result.pop(0)\n            result.pop(0)\n        \n        # Calculate the maximum number of instruments we can learn\n        max_instruments = min(max_instruments, n - i)\n        \n        # Check if we have enough time to learn the remaining instruments\n        if total_time < k:\n            break\n        \n    return f\"{max_instruments}\\n{' '.join(map(str, result))}\\n\"\n\n\ninput_str = \"\"\"4 10\n4 3 1 2\"\"\"\n\nprint(solution(input_str))\n"
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if k < n:\n        return \"0\\n\"\n\n    a.sort(reverse=True)\n    m = 0\n\n    for i in range(n):\n        if k >= a[i]:\n            k -= a[i]\n            m += 1\n\n    return f\"{m}\\n{' '.join(map(str, range(1, n+1)))}\""
    },
    {
        "number": 636,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    days_left = k\n    instruments_to_learn = []\n    \n    for i in range(n):\n        if days_left >= a[i]:\n            instruments_to_learn.append(i)\n            days_left -= a[i]\n    \n    result = len(instruments_to_learn)\n    if result > 0:\n        print(result)\n        print(\" \".join(map(str, instruments_to_learn)))\n    else:\n        print(0)\n    \n    return \"0\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    photo = list(map(int, input().split()))\n\n    # Check if the photo is all white or all black\n    if all(photo) or not any(photo):\n        return \"NO\"\n\n    # Initialize variables\n    stripe_width = 0\n    black_count = 0\n    white_count = 0\n\n    # Iterate through the photo\n    for pixel in photo:\n        # Increment the stripe width\n        stripe_width += 1\n\n        # If it's a black pixel, increment the black count\n        if pixel == 0:\n            black_count += 1\n\n        # If it's a white pixel, increment the white count\n        elif pixel == 1:\n            white_count += 1\n\n        # If the width of the stripe is equal to the number of white pixels, the photo can't be a photo of zebra\n        if stripe_width == white_count:\n            return \"NO\"\n\n    # If the width of the stripe is equal to the number of black pixels, the photo can be a photo of zebra\n    if stripe_width == black_count:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    photo = stdin.split('\\n')[1].split()\n    \n    # Check if the photo can be a photo of zebra\n    if n % 2 == 0:\n        width = n // 2\n        for i in range(width):\n            if photo[2*i] != photo[2*i+1]:\n                return \"NO\"\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    photo = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    width = 0\n    white_stripe = False\n    \n    for i in range(n):\n        if white_stripe:\n            if photo[i] == 1:\n                width += 1\n            else:\n                white_stripe = False\n        else:\n            if photo[i] == 0:\n                width += 1\n            else:\n                white_stripe = True\n    \n    if white_stripe:\n        return \"NO\"\n    else:\n        return \"YES\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    photo = list(map(int, input().split()))\n\n    stripe_width = 0\n    stripe_count = 0\n\n    for pixel in photo:\n        if pixel == 1:\n            stripe_width += 1\n        else:\n            if stripe_count % 2 == 1:\n                return \"NO\"\n            stripe_width = 0\n        stripe_count += 1\n\n    if stripe_count % 2 == 1:\n        return \"NO\"\n    else:\n        return \"YES\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    photo = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n\n    white_count = photo.count(1)\n    black_count = photo.count(0)\n\n    if white_count == 0 or black_count == 0:\n        return \"NO\"\n\n    width = photo.count(1) // white_count\n    black_width = 2 * black_count + 1\n\n    if width == black_width:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_str = \"\"\"9\n0 0 0 1 1 1 0 0 0\n7\n0 0 0 1 1 1 1\n5\n1 1 1 1 1\n8\n1 1 0 1 1 0 1 1\n9\n1 1 0 1 1 0 1 1 0\"\"\"\n\ninput_str = input_str.strip().split('\\n')\ninput_str = '\\n'.join(input_str)\n\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    photo = stdin.splitlines()[1]\n    photo = photo.split()\n    photo = [int(pixel) for pixel in photo]\n    i = 0\n    count = 0\n    while i < n:\n        if photo[i] == 1:\n            count += 1\n        else:\n            if count % 2 == 0:\n                return \"NO\"\n            count = 0\n        i += 1\n    if count % 2 == 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n\n    black_count = 0\n    white_count = 0\n    for i in range(n):\n        if a[i] == 0:\n            white_count += 1\n        else:\n            black_count += 1\n            white_count = 0\n\n        if black_count == 1 and white_count == 1:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    photo = stdin.splitlines()[1]\n    photo = [int(pixel) for pixel in photo.split()]\n\n    black_stripe_width = 1\n    white_stripe_width = 1\n    zebra_stripes = []\n\n    for i in range(n):\n        if photo[i] == 0:\n            white_stripe_width += 1\n            if black_stripe_width == white_stripe_width:\n                zebra_stripes.append(True)\n            elif i == n - 1:\n                zebra_stripes.append(False)\n        else:\n            black_stripe_width += 1\n            if black_stripe_width == white_stripe_width:\n                zebra_stripes.append(True)\n            elif i == n - 1:\n                zebra_stripes.append(False)\n\n    if all(zebra_stripes):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    photo = stdin.split('\\n')[1].split()\n    stripe_width = 0\n\n    for i in range(n):\n        if photo[i] == '1':\n            stripe_width += 1\n        else:\n            if stripe_width > 0:\n                if stripe_width % 2 == 0:\n                    return \"NO\"\n            stripe_width = 0\n\n    if stripe_width > 0 and stripe_width % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 637,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    photo = [int(i) for i in input_list[1].split()]\n\n    if photo[0] == 0 and photo[n-1] == 1:\n        for i in range(1, n):\n            if photo[i] == photo[i-1]:\n                continue\n            if photo[i] == 0:\n                white_width = i\n                break\n        else:\n            return \"NO\"\n        for i in range(white_width, n):\n            if photo[i] == 0:\n                return \"NO\"\n        if (i-white_width) % 2 == 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    t = list(map(int, stdin.split()[2:]))\n    \n    min_fail = [0] * n\n    for i in range(1, n):\n        min_fail[i] = min_fail[i-1]\n        for j in range(i):\n            if t[i] + t[j] > M:\n                min_fail[i] = max(min_fail[i], j+1)\n                \n    result = [min_fail[i] for i in range(n)]\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    t = list(map(int, stdin.split()[2:]))\n    res = []\n\n    for i in range(n):\n        min_students = n - i - 1\n        res.append(min_students)\n\n        for j in range(i + 1):\n            if t[j] > M:\n                min_students -= 1\n        res[-1] = min_students\n\n    return \" \".join(map(str, res))"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    ti = list(map(int, stdin.split()[2:]))\n\n    answer = []\n    for i in range(n):\n        # Initialize variables\n        total_time = 0\n        count_fail = 0\n        for j in range(i):\n            total_time += ti[j]\n            if total_time > M:\n                count_fail += 1\n                total_time = ti[j]\n        if total_time > M:\n            count_fail += 1\n        answer.append(count_fail)\n\n    return ' '.join(map(str, answer))\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    exams = list(map(int, stdin.split()[2:]))\n    min_failed_students = [0] * n\n\n    # Calculate the time spent by the first student\n    total_time_spent = exams[0]\n\n    # Iterate through the remaining exams\n    for i in range(1, n):\n        # Calculate the total time spent by the current student and the remaining students\n        remaining_time = M - total_time_spent\n\n        # If the remaining time is less than the time spent by the current student, then all previous students must fail\n        if remaining_time < exams[i]:\n            min_failed_students[i] = i + 1\n        else:\n            # Calculate the minimum number of students who must fail\n            for j in range(1, i + 1):\n                remaining_time = remaining_time - exams[j - 1]\n                if remaining_time < exams[i]:\n                    min_failed_students[i] = j\n                    break\n\n            # Calculate the total time spent by the current student and the remaining students\n            total_time_spent += exams[i]\n\n    # Print the minimum number of failed students\n    return \" \".join(map(str, min_failed_students))\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, input().split())\n    t = list(map(int, input().split()))\n\n    def count_leaving(i: int) -> int:\n        total_time = 0\n        count = 0\n        for j in range(i):\n            total_time += t[j]\n            if total_time > M:\n                break\n        return count\n\n    result = [count_leaving(i) for i in range(n)]\n    return \" \".join(map(str, result))"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    exams = list(map(int, stdin.split()[2:]))\n    min_leave = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            if exams[i] - exams[j] <= M:\n                min_leave[i] += 1\n\n    return ' '.join(map(str, min_leave))\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    ti = map(int, stdin.split()[2:])\n    ans = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            M -= ti[j]\n            if M <= 0:\n                ans[i] += 1\n                break\n        if M <= 0:\n            break\n\n    return \" \".join(map(str, ans))\n"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    t = list(map(int, stdin.split()[2:]))\n    \n    students = [0] * n\n    for i in range(n):\n        students[i] = i + 1\n    for i in range(n):\n        for j in range(i):\n            if t[j] + t[i] > M:\n                students[i] += 1\n                students[j] += 1\n                \n    return ' '.join(map(str, students))"
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[:2])\n    exam_times = list(map(int, stdin.split()[2:]))\n\n    min_num_students = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            if exam_times[i] > M - exam_times[j]:\n                min_num_students[i] += 1\n\n    return \" \".join(map(str, min_num_students))\n\n\ninput_string = \"\"\"7 15\n1 2 3 4 5 6 7\n\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 638,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, input().split())\n    times = list(map(int, input().split()))\n    \n    answer = []\n    for i in range(n):\n        min_students_to_fail = 0\n        for j in range(i):\n            if times[j] > M - sum(times[:j+1]):\n                min_students_to_fail += 1\n        answer.append(min_students_to_fail)\n    \n    return ' '.join(map(str, answer))\n"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, x = map(int, input_list[0].split())\n    evil_set = set(map(int, input_list[1].split()))\n\n    if x == 0:\n        return str(n)\n\n    min_operations = 0\n    for i in range(1, n + 1):\n        if i not in evil_set:\n            min_operations += 1\n        else:\n            break\n\n    return str(min_operations)"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    set_ = set(map(int, input().split()))\n    \n    if sum(set_) == x:\n        return \"0\"\n    \n    count = 0\n    if x not in set_:\n        count = 1\n        set_.add(x)\n    else:\n        set_.remove(x)\n        set_.add(x+1)\n        count = 1\n    \n    return str(count)\n\n\ndef"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, x = map(int, input_list[0].split())\n    num_set = set(map(int, input_list[1].split()))\n\n    operations = 0\n    mex = 0\n    for i in range(n + 1):\n        if i not in num_set:\n            mex = i\n            break\n\n    if mex != x:\n        operations += 1\n        num_set.add(mex)\n\n        if x not in num_set:\n            operations += 1\n            num_set.add(x)\n\n    return str(operations)"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    numbers = list(map(int, input().split()))\n    if x == 0:\n        return str(len(numbers))\n    for i in range(1, x + 1):\n        if i not in numbers:\n            return str(i)\n    return str(x + 1)\n"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    input_list = stdin.split(\"\\n\")\n    n, x = map(int, input_list[0].split())\n    set_list = list(map(int, input_list[1].split()))\n\n    # calculate MEX\n    mex = 0\n    while mex in set_list:\n        mex += 1\n\n    # check if set is evil\n    if mex == x:\n        return 0\n\n    # perform operations\n    operations = 0\n    while mex != x:\n        # add smallest number not in set\n        set_list.append(mex)\n        operations += 1\n        # update MEX\n        while mex in set_list:\n            mex += 1\n\n    return operations\n"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    numbers = sorted(map(int, stdin.split()[2:]))\n    min_operations = 0\n    \n    if numbers[-1] >= x:\n        min_operations = n\n    else:\n        for i in range(len(numbers)):\n            if numbers[i] < x:\n                break\n        min_operations = i + x - numbers[i]\n    \n    return str(min_operations)\n"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    set_of_integers = list(map(int, input().split()))\n    operations = 0\n\n    for num in set_of_integers:\n        if num == x:\n            operations += 1\n\n    return operations"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[:2])\n    numbers = list(map(int, stdin.split()[2:]))\n    \n    if x == 0:\n        return str(n)\n    \n    operations = 0\n    numbers.sort()\n    \n    for i in range(n):\n        if numbers[i] < x:\n            operations += x - numbers[i]\n            numbers[i] = x\n            break\n    \n    if numbers[-1] < x:\n        operations += x - numbers[-1]\n        numbers[-1] = x\n    \n    return str(operations)\n\n\ninput_cases = [\n    \"5 3\\n0 4 5 6 7\",\n    \"1 0\\n0\",\n    \"5 0\\n1 2 3 4 5\",\n]\n\nfor input_case in input_cases:\n    print(solution(input_case)) "
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, x = map(int, input_list[0].split())\n    set_list = list(map(int, input_list[1].split()))\n\n    # initialize the MEX\n    mex = 0\n\n    # initialize the number of operations\n    operations = 0\n\n    # sort the set in ascending order\n    set_list.sort()\n\n    # check if the set is already evil\n    if set_list[0] == x:\n        return str(operations)\n\n    # add the elements until the MEX is x\n    while mex != x:\n        # find the next element to add\n        next_element = set_list[-1] + 1\n\n        # add the next element\n        set_list.append(next_element)\n        operations += 1\n\n        # update the MEX\n        mex = set_list[-1]\n\n    # the number of operations is the final result\n    return str(operations)\n\n\ndef"
    },
    {
        "number": 639,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    set_numbers = sorted(list(map(int, input().split())))\n\n    operations = 0\n    i = 0\n    while i < len(set_numbers) and set_numbers[i] <= x:\n        i += 1\n\n    if i < len(set_numbers):\n        operations += 1\n        set_numbers[i] -= 1\n        x -= 1\n        i += 1\n\n    while i < len(set_numbers):\n        operations += 1\n        set_numbers[i] -= 1\n        x -= 1\n        i += 1\n\n    return str(operations)\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    def throw_dice(x: int, y: int) -> int:\n        if abs(x - y) <= 2:\n            return 3\n        elif abs(x - y) <= 4:\n            return 2\n        else:\n            return 1\n    first_wins = throw_dice(a, 1) + throw_dice(a, 2) + throw_dice(a, 3) + throw_dice(a, 4) + throw_dice(a, 5) + throw_dice(a, 6)\n    draw = throw_dice(b, 1) + throw_dice(b, 2) + throw_dice(b, 3) + throw_dice(b, 4) + throw_dice(b, 5) + throw_dice(b, 6)\n    second_wins = throw_dice(b, 1) + throw_dice(b, 2) + throw_dice(b, 3) + throw_dice(b, 4) + throw_dice(b, 5) + throw_dice(b, 6) - draw\n    return f\"{first_wins} {draw} {second_wins}\"\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    wins_a = 0\n    wins_b = 0\n    draws = 0\n\n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n\n        if diff_a < diff_b:\n            wins_a += 1\n        elif diff_a > diff_b:\n            wins_b += 1\n        else:\n            draws += 1\n\n    return f\"{wins_a} {draws} {wins_b}\"\n\n\ninput_data = \"2 5\\n2 4\"\noutput_data = [solution(i) for i in input_data.split(\"\\n\")]\n\nprint(\"\\n\".join(output_data)) "
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    num_ways = [0] * 7\n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        if diff_a < diff_b:\n            num_ways[diff_a] += 1\n        elif diff_a > diff_b:\n            num_ways[diff_b] += 1\n        else:\n            num_ways[diff_a] += 1\n    return \" \".join(map(str, num_ways))\n\n\ninput_stdin = \"2 5\\n2 4\"\noutput_stdout = [\n    \"3 0 3\",\n    \"2 1 3\"\n]\n\nfor stdin, expected in zip(input_stdin.split(\"\\n\"), output_stdout):\n    assert solution(stdin) == expected\n    print(solution(stdin)) "
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    wins_a = 0\n    draws = 0\n    wins_b = 0\n    \n    for x in range(1, 7):\n        if abs(a - x) < abs(b - x):\n            wins_a += 1\n        elif abs(a - x) > abs(b - x):\n            wins_b += 1\n        else:\n            draws += 1\n            \n    return f\"{wins_a} {draws} {wins_b}\"\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    count_wins_first_player = 0\n    count_draw = 0\n    count_wins_second_player = 0\n    \n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n        \n        if diff_a < diff_b:\n            count_wins_first_player += 1\n        elif diff_a == diff_b:\n            count_draw += 1\n        else:\n            count_wins_second_player += 1\n    \n    return f\"{count_wins_first_player} {count_draw} {count_wins_second_player}\""
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    count_a_win = count_draw = count_b_win = 0\n\n    # Count number of ways to throw the dice at which the first player wins\n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n\n        if diff_a < diff_b:\n            count_a_win += 1\n        elif diff_a > diff_b:\n            count_b_win += 1\n        else:\n            count_draw += 1\n\n    # Count number of ways to throw the dice at which the game ends with a draw\n    count_draw = count_a_win + count_draw + count_b_win\n\n    # Count number of ways to throw the dice at which the second player wins\n    count_b_win = 6 - count_a_win\n\n    return f\"{count_a_win} {count_draw} {count_b_win}\"\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = [0] * 3\n\n    for x in range(1, 7):\n        diff_a = abs(a - x)\n        diff_b = abs(b - x)\n\n        if diff_a < diff_b:\n            count[0] += 1\n        elif diff_a == diff_b:\n            count[1] += 1\n        else:\n            count[2] += 1\n\n    return \" \".join(map(str, count))\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    def count_wins(a: int, b: int) -> tuple:\n        first_player_wins = 0\n        draw = 0\n        second_player_wins = 0\n        for x in range(1, 7):\n            if abs(a - x) < abs(b - x):\n                first_player_wins += 1\n            elif abs(a - x) > abs(b - x):\n                second_player_wins += 1\n            else:\n                draw += 1\n        return first_player_wins, draw, second_player_wins\n\n    first_player_wins, draw, second_player_wins = count_wins(a, b)\n\n    return f\"{first_player_wins} {draw} {second_player_wins}\"\n\n\ndef"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    def count_wins(player1, player2, target):\n        count = 0\n        for i in range(1, 7):\n            if abs(i - player1) < abs(i - player2) and i != target:\n                count += 1\n            elif abs(i - player2) < abs(i - player1) and i != target:\n                count += 1\n        return count\n\n    wins1 = count_wins(a, b, 1)\n    wins2 = count_wins(a, b, 2)\n    wins3 = count_wins(a, b, 3)\n    wins4 = count_wins(a, b, 4)\n    wins5 = count_wins(a, b, 5)\n    wins6 = count_wins(a, b, 6)\n\n    return f\"{wins1} {wins2} {wins3}\\n{wins4} {wins5} {wins6}\"\n"
    },
    {
        "number": 640,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count_player_1_wins = 0\n    count_draw = 0\n    count_player_2_wins = 0\n    \n    for i in range(1, 7):\n        diff_player_1 = abs(a - i)\n        diff_player_2 = abs(b - i)\n        \n        if diff_player_1 < diff_player_2:\n            count_player_1_wins += 1\n        elif diff_player_1 == diff_player_2:\n            count_draw += 1\n        else:\n            count_player_2_wins += 1\n    \n    return f\"{count_player_1_wins} {count_draw} {count_player_2_wins}\"\n\n\ninput_data = \"2 4\"\nprint(solution(input_data)) # Output: \"2 1 3\" "
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, input_type = stdin.split()\n\n    if input_type == \"of week\":\n        day_of_week = int(input_str)\n        return 52 // 4 * (day_of_week - 1) + (day_of_week <= 4)\n    elif input_type == \"of month\":\n        day_of_month = int(input_str)\n        return 11\n    else:\n        raise ValueError(\"Invalid input type\")\n\ndef"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    days_in_week = 7\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    input_type, input_value = input_str.split()\n    input_value = int(input_value)\n    \n    if input_type == \"of week\":\n        if input_value == 1:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31\n        elif input_value == 2:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31\n        elif input_value == 3:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31\n        elif input_value == 4:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31\n        elif input_value == 5:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31\n        elif input_value == 6:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31\n        elif input_value == 7:\n            output = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 +"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if 'of week' in input_str:\n        week_day = int(input_str.split(' ')[0])\n        number_of_candies = 52 // 7 * 7\n        return number_of_candies\n    else:\n        month_day = int(input_str.split(' ')[0])\n        number_of_candies = 0\n        for month in range(1, 13):\n            if month % 2 == 0 or month == 8 or month == 10:\n                days_in_month = 30\n            elif month == 2:\n                days_in_month = 28\n            else:\n                days_in_month = 31\n            if month_day <= days_in_month:\n                number_of_candies += 1\n        return number_of_candies"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if \"of week\" in input_str:\n        day = int(input_str.split()[0])\n        candies_per_week = 52 // 7\n        candies_to_save = candies_per_week * (day - 1)\n    else:\n        day = int(input_str.split()[0])\n        candies_to_save = 52 * (day // 31) + (day % 31)\n    return str(candies_to_save)"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    day_or_month, day = input_data\n    if day_or_month == \"of week\":\n        if day == \"1\":\n            day = \"7\"  # If Monday, save on Sunday\n        elif day == \"7\":\n            day = \"1\"  # If Sunday, save on Monday\n        else:\n            day = int(day) - 1  # Otherwise, subtract 1\n        n_days = 52  # There are 52 weeks in the year\n    else:\n        n_days = int(day)\n        if n_days < 1 or n_days > 31:\n            return \"Error: invalid day of month\"\n        if n_days in [1, 8, 15, 22, 29]:\n            n_days = 4  # If day of month is in [1, 8, 15, 22, 29], save on the 4-th day of the week\n        elif n_days in [3, 10, 17, 24, 31]:\n            n_days = 5  # If day of month is in [3, 10, 17, 24, 31], save on the 5-th day of the week\n        elif n_days in [5, 12, 19, 26]:\n            n_days = 6  # If day of month is in [5, 12, 19, 26], save on the 6-th day of the week\n        else:\n            n_days = 7  # If day of month is in [7, 14, 21, 28], save on the 7-th day of the week\n    return n_days\n"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if \"of week\" in input_str:\n        day_of_week = int(input_str.split()[0])\n        number_of_weekly_candies = 52 // 7 * (day_of_week - 1)\n        number_of_special_week = 52 % 7\n        if day_of_week <= number_of_special_week:\n            number_of_special_week += 7\n        number_of_weekly_candies += number_of_special_week - day_of_week\n        return number_of_weekly_candies\n    else:\n        day_of_month = int(input_str.split()[0])\n        number_of_monthly_candies = 0\n        for i in range(1, 13):\n            if i == 2:\n                continue\n            if day_of_month > calendar.monthrange(2016, i)[1]:\n                day_of_month -= calendar.monthrange(2016, i)[1]\n            else:\n                number_of_monthly_candies += 1\n        return number_of_monthly_candies "
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str, input_type = stdin.split()\n    input_str = int(input_str)\n\n    if input_type == \"of week\":\n        days_in_year = 52\n        days_in_week = 7\n        week_index = input_str\n        month_index = 0\n    elif input_type == \"of month\":\n        days_in_year = 365\n        days_in_week = 4\n        week_index = 0\n        month_index = input_str\n\n    if input_type == \"of week\":\n        candies_saved = days_in_year // days_in_week\n    elif input_type == \"of month\":\n        candies_saved = days_in_year // days_in_month\n\n    return str(candies_saved)\n\n\nprint(solution(input())) "
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str, _, frequency_str = stdin.partition(' ')\n    frequency, _, day_or_month = frequency_str.partition(' of ')\n    frequency = int(frequency)\n\n    if day_or_month == 'week':\n        total_days = 52\n    elif day_or_month == 'month':\n        total_days = 11\n    else:\n        raise ValueError(f\"Invalid input format: {stdin}\")\n\n    candies = frequency * total_days\n    return str(candies)"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str, _, input_format = stdin.strip().partition(' ')\n    day, month = input_str.split()\n    day = int(day)\n    month = int(month)\n    \n    if input_format == \"of week\":\n        weeks_in_year = 52\n        days_in_week = 7\n    elif input_format == \"of month\":\n        weeks_in_year = 52 * 7\n        days_in_week = 30\n    else:\n        return \"Invalid input format\"\n    \n    candies_saved = (days_in_week * weeks_in_year) // days_in_week\n    return str(candies_saved)\n"
    },
    {
        "number": 641,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    day, _, date = stdin.strip().partition(\" of \")\n    if day == \"week\":\n        _, _, day_of_week = date.partition(\"day\")\n        number_of_candies = 52 if int(day_of_week) == 4 else 0  # Thursday is the 4th day of the week\n    elif day == \"month\":\n        number_of_candies = 11 if int(date) == 30 else 0  # Only 11 months have the 30th day\n    else:\n        raise ValueError(\"Invalid input format\")\n    return str(number_of_candies)\n\ninput_string = \"4 of week\"\noutput = solution(input_string)\nprint(output)\n\ninput_string = \"30 of month\"\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    dirty_stairs = sorted(set(map(int, input().split())))\n\n    if dirty_stairs[0] == 1 or dirty_stairs[-1] == n:\n        return \"NO\"\n\n    for stair in range(2, n-1):\n        if stair not in dirty_stairs and (stair-1) not in dirty_stairs and (stair+1) not in dirty_stairs:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    dirty_stairs = sorted(map(int, stdin.split()[2:]))\n\n    if n < 3 or (m > 0 and n - dirty_stairs[0] == dirty_stairs[-1] - 1):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    dirty_stairs = list(map(int, input_data[1].split()))\n\n    if 1 in dirty_stairs or n in dirty_stairs:\n        return \"NO\"\n\n    clean_stairs = [i for i in range(1, n + 1) if i not in dirty_stairs]\n\n    if len(clean_stairs) == 0:\n        return \"NO\"\n\n    if len(clean_stairs) % 2 != 0:\n        return \"NO\"\n\n    for i in range(0, len(clean_stairs), 2):\n        if clean_stairs[i] + 2 != clean_stairs[i + 1]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    dirty_stairs = sorted(map(int, stdin.splitlines()[1].split()))\n    if dirty_stairs[0] == 1 or dirty_stairs[-1] == n:\n        return \"NO\"\n    for i in range(m):\n        if dirty_stairs[i] < n - 1:\n            return \"NO\"\n        if dirty_stairs[i] > n - 2:\n            return \"NO\"\n    return \"YES\"\n\n\nstdin = \"\"\"10 5\n2 4 8 3 6\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    dirty_stairs = sorted(set(map(int, input().split())))\n    \n    if dirty_stairs[0] == 1:\n        return \"YES\"\n    if dirty_stairs[-1] == n:\n        return \"YES\"\n    \n    for i in range(len(dirty_stairs) - 1):\n        if dirty_stairs[i+1] - dirty_stairs[i] <= 2:\n            continue\n        else:\n            return \"NO\"\n        \n    return \"YES\"\n\nstdin = \"10 5\\n2 4 8 3 6\"\nprint(solution(stdin)) "
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_clean(stairs: str) -> bool:\n        return stairs.count(\"*\") == 0\n\n    n, m = map(int, stdin.split()[:2])\n    dirty_stairs = sorted(map(int, stdin.split()[2:]))\n\n    if not (1 <= n <= 10**9 and 0 <= m <= 3000):\n        return \"NO\"\n\n    if not (1 <= dirty_stairs[0] <= dirty_stairs[-1] <= n):\n        return \"NO\"\n\n    clean_stairs = \"*\" * (n - 1)\n    for stair in dirty_stairs:\n        clean_stairs = clean_stairs[:stair - 1] + \"*\" + clean_stairs[stair:]\n\n    if is_clean(clean_stairs):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\nstdin = \"10 5\\n2 4 8 3 6\"\nprint(solution(stdin)) "
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    dirty_stairs = sorted(set(map(int, stdin.split()[2:])))\n    \n    if n in dirty_stairs:\n        return \"NO\"\n    \n    if dirty_stairs[0] == 1 or dirty_stairs[-1] == n:\n        return \"NO\"\n    \n    for i in range(len(dirty_stairs) - 1):\n        if dirty_stairs[i] + 1 == dirty_stairs[i+1]:\n            return \"NO\"\n        \n    return \"YES\"\n"
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    dirty_stairs = sorted(map(int, input_data[1].split()))\n    \n    if n in dirty_stairs:\n        return \"NO\"\n    if 1 in dirty_stairs:\n        return \"NO\"\n    if n-1 in dirty_stairs:\n        return \"NO\"\n    \n    for i in range(m):\n        if dirty_stairs[i] - dirty_stairs[i-1] > 2:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef"
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    dirty_stairs = sorted(map(int, input().split()))\n    \n    if dirty_stairs[0] == 1 or dirty_stairs[-1] == n:\n        return \"NO\"\n    \n    for i in range(m):\n        if dirty_stairs[i] <= n and dirty_stairs[i] > dirty_stairs[i-1]:\n            if dirty_stairs[i] - dirty_stairs[i-1] > 1:\n                return \"NO\"\n            elif dirty_stairs[i] - dirty_stairs[i-1] == 1:\n                dirty_stairs[i+1:] = [i+2 for i in dirty_stairs[i+1:]]\n            elif dirty_stairs[i+1] - dirty_stairs[i] == 1:\n                dirty_stairs[i] = dirty_stairs[i+1]\n                dirty_stairs[i+1:] = [i+2 for i in dirty_stairs[i+1:]]\n            else:\n                return \"NO\"\n        elif dirty_stairs[i] > n:\n            break\n    return \"YES\"\n\nn = 10\nm = 5\ndirty_stairs = [2, 4, 8, 3, 6]\nprint(solution(stdin=f\"{n} {m}\\n{' '.join(map(str, dirty_stairs))}\"))\n\nn = 10\nm = 5\ndirty_stairs = [2, 4, 5, 7, 9]\nprint(solution(stdin=f\"{n} {m}\\n{' '.join(map(str, dirty_stairs))}\")) "
    },
    {
        "number": 642,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    dirty_stairs = sorted(map(int, stdin.split()[2:]))\n\n    if dirty_stairs[0] == 1 or dirty_stairs[-1] == n:\n        return \"NO\"\n\n    i = 1\n    while i <= m:\n        if dirty_stairs[i - 1] - dirty_stairs[i - 2] > 1:\n            return \"NO\"\n        i += 1\n\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    input_data = stdin.split('\\n')[1:]\n    for i in range(t):\n        x, y, p, q = map(int, input_data[i].split())\n        success_rate = x / y\n        if p / q > success_rate:\n            submissions = 0\n        elif p / q == success_rate:\n            submissions = 1\n        else:\n            submissions = -1\n        print(submissions)\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    t = int(stdin)\n    output = []\n\n    for _ in range(t):\n        x, y, p, q = map(int, input().split())\n        if x == y == 0:\n            output.append(0)\n        else:\n            successful_submissions = lcm(p, q)\n            if successful_submissions <= y:\n                output.append(successful_submissions)\n            else:\n                output.append(-1)\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    result = []\n    for _ in range(t):\n        x, y, p, q = map(int, input().split())\n        if p == 0:\n            result.append(y)\n        else:\n            if x == y:\n                result.append(-1)\n            else:\n                x_submissions = y - x\n                success_rate = x / y\n                if success_rate == p / q:\n                    result.append(x_submissions)\n                else:\n                    x_submissions += 1\n                    while True:\n                        success_rate = (x + x_submissions) / (y + x_submissions)\n                        if success_rate == p / q:\n                            result.append(x_submissions)\n                            break\n                        elif success_rate > p / q:\n                            result.append(-1)\n                            break\n                        else:\n                            x_submissions += 1\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    result = []\n    \n    for i in range(t):\n        x, y, p, q = map(int, stdin.split())\n        success_rate = x / y\n        if success_rate == p / q:\n            result.append(0)\n        elif success_rate < p / q:\n            submissions = 0\n            while x + submissions * (y - x) < (p * submissions + q * x) * y:\n                submissions += 1\n            if submissions * (y - x) >= (p * submissions + q * x) * y:\n                result.append(submissions)\n            else:\n                result.append(-1)\n        else:\n            result.append(-1)\n    \n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    input_data = stdin.splitlines()[1:]\n    output = []\n\n    for i in range(t):\n        x, y, p, q = map(int, input_data[i].split())\n        if x == y:\n            output.append(0)\n        else:\n            success_rate = x / y\n            if success_rate == p / q:\n                output.append(y)\n            else:\n                if success_rate < p / q:\n                    output.append(-1)\n                else:\n                    success_sum = 0\n                    count = 0\n                    while success_sum < p * q:\n                        success_sum += y - x + count\n                        count += 1\n                    output.append(count)\n\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        x, y, p, q = map(int, input().split())\n        if q == 0:\n            output.append(-1)\n            continue\n        gcd = math.gcd(p, q)\n        p //= gcd\n        q //= gcd\n        success_rate = x / y\n        if p / q > success_rate:\n            submissions = q * (success_rate * y - x) + y - 1\n            output.append(submissions // y + 1)\n        else:\n            output.append(-1)\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    result = []\n\n    for i in range(t):\n        x, y, p, q = map(int, input().split())\n\n        if p % q != 0:\n            num_submissions = y // p\n            if num_submissions * p == y:\n                result.append(num_submissions)\n            else:\n                result.append(-1)\n        else:\n            result.append(-1)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    t = int(input_data.pop(0))\n    output = []\n    for line in input_data:\n        x, y, p, q = map(int, line.split())\n        if y <= p or x > q:\n            output.append(-1)\n        else:\n            gcd = math.gcd(p, q)\n            x_success = y // p * q\n            x_total = (x_success + (y - p) // q * gcd) // y\n            output.append(x_total - x)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        x, y, p, q = map(int, stdin.split()[1:])\n        if y == 0:\n            print(\"-1\")\n        else:\n            x_min = x * q // y\n            y_min = q\n            if x_min * y >= x * y_min:\n                print(x_min)\n            else:\n                print(\"-1\")\n"
    },
    {
        "number": 643,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(x: int, y: int, p: int, q: int) -> bool:\n        return x * q >= y * p\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // math.gcd(a, b)\n\n    t = int(stdin)\n    result = []\n\n    for _ in range(t):\n        x, y, p, q = map(int, stdin.split())\n        if is_possible(x, y, p, q):\n            result.append(x)\n        else:\n            result.append(-1)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def execute(commands):\n        x = 0\n        for command in commands:\n            if command[0] == \"add\":\n                x += 1\n            elif command[0] == \"for\":\n                n = int(command[1])\n                x = execute(commands[:i + n]) * n\n        return x\n\n    input_lines = stdin.split(\"\\n\")\n    commands = []\n    for i, line in enumerate(input_lines):\n        if line.startswith(\"for\"):\n            commands.append((\"for\", line[4:]))\n        elif line.startswith(\"end\"):\n            commands.append((\"end\", \"\"))\n        else:\n            commands.append((\"add\", \"\"))\n\n    x = execute(commands)\n    if x > (2**32) - 1:\n        return \"OVERFLOW!!!\"\n    else:\n        return str(x)\n"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l = int(stdin.split('\\n')[0])\n    for_blocks = [[]]\n    current_block = 0\n    for line in stdin.split('\\n')[1:]:\n        if line.startswith('for'):\n            current_block += 1\n            n = int(line.split(' ')[1])\n            for_blocks.append([])\n            current_block_index = current_block\n        elif line.startswith('end'):\n            current_block -= 1\n        elif line.startswith('add'):\n            for_blocks[current_block_index].append('add')\n    x = 0\n    for i in range(l):\n        for block in for_blocks:\n            for cmd in block:\n                if cmd == 'add':\n                    x = (x + 1) % (2**32)\n    if x > 2**31 - 1:\n        return 'OVERFLOW!!!'\n    else:\n        return str(x)"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def execute_commands(x, commands):\n        for command in commands:\n            if command == \"add\":\n                x += 1\n            elif command.startswith(\"for\"):\n                n = int(command[3:])\n                for _ in range(n):\n                    x += 1\n            elif command == \"end\":\n                pass\n            else:\n                raise ValueError(\"Invalid command\")\n            if x > (1 << 32) - 1:\n                return \"OVERFLOW!!!\"\n        return x\n\n    l = int(stdin.split(\"\\n\")[0])\n    commands = stdin.split(\"\\n\")[1:]\n    x = 0\n    result = execute_commands(x, commands)\n    return result\n"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def execute_command(command: str, x: int) -> int:\n        if command.startswith(\"for\"):\n            n = int(command.split()[1])\n            return x\n        elif command.startswith(\"add\"):\n            return x + 1\n        elif command.startswith(\"end\"):\n            return x\n\n    n = int(stdin.split('\\n')[0].strip())\n    x = 0\n    for line in stdin.split('\\n')[1:]:\n        x = execute_command(line.strip(), x)\n        if x > 2**32-1:\n            return \"OVERFLOW!!!\"\n    return x "
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    x = 0\n    for i in range(1, n + 1):\n        command = lines[i].split()\n        if command[0] == \"for\":\n            n = int(command[1])\n            for j in range(n):\n                x += 1\n        elif command[0] == \"end\":\n            pass\n        elif command[0] == \"add\":\n            x += 1\n        if x > (2**32)-1:\n            return \"OVERFLOW!!!\"\n    return x\n"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def execute(code: str, x: int) -> int:\n        for line in code.split('\\n'):\n            if line.startswith('add'):\n                x += 1\n            elif line.startswith('for '):\n                n = int(line[4:])\n                for _ in range(n):\n                    x = execute(code[code.index('end') + 3:], x)\n                    if x > 2**32 - 1:\n                        return 2**32 - 1\n            elif line.startswith('end'):\n                continue\n            else:\n                raise ValueError('Invalid command')\n        return x\n\n    l = int(stdin.split('\\n')[0])\n    code = '\\n'.join(stdin.split('\\n')[1:])\n\n    x = execute(code, 0)\n\n    if x > 2**32 - 1:\n        return 'OVERFLOW!!!'\n    else:\n        return str(x)"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def execute_command(command: str, x: int) -> int:\n        if command == \"add\":\n            x += 1\n        return x\n\n    def execute_for_loop(n: int, x: int) -> int:\n        for _ in range(n):\n            x = execute_command(\"add\", x)\n        return x\n\n    lines = stdin.split(\"\\n\")\n    x = 0\n\n    for i in range(1, len(lines), 2):\n        command = lines[i].strip()\n        if command.startswith(\"for \"):\n            n = int(command[4:-1])\n            x = execute_for_loop(n, x)\n        else:\n            x = execute_command(command, x)\n\n    if x > 2**32 - 1:\n        return \"OVERFLOW!!!\"\n    else:\n        return x\n"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    lines = lines[1:]\n    x = 0\n    for line in lines:\n        if line.startswith(\"for\"):\n            _, n = line.split()\n            n = int(n)\n            for _ in range(n):\n                x += 1\n        else:\n            x += 1\n        if x > 2**32 - 1:\n            return \"OVERFLOW!!!\"\n    return x\n\n\ndef"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def execute_commands(stdin: str) -> int:\n        commands = stdin.split('\\n')\n        x = 0\n\n        for i in range(len(commands)):\n            command = commands[i]\n\n            if command.startswith('add'):\n                x += 1\n            elif command.startswith('for'):\n                _, n = command.split()\n                for _ in range(int(n)):\n                    x += 1\n\n                    if x > 2**32 - 1:\n                        return -1\n\n        return x\n\n    n = int(stdin.split('\\n', 1)[0])\n    stdin = stdin.split('\\n', 1)[1]\n\n    x = execute_commands(stdin)\n\n    if x == -1:\n        return \"OVERFLOW!!!\"\n    else:\n        return str(x)"
    },
    {
        "number": 644,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    l = int(input_list[0])\n    x = 0\n\n    for i in range(1, l + 1):\n        command = input_list[i]\n        if \"for\" in command:\n            n = int(command.split()[1])\n            if n > 100:\n                return \"OVERFLOW!!!\"\n            for j in range(n):\n                x += 1\n        elif \"end\" in command:\n            continue\n        else:\n            x += 1\n\n        if x > 2**32 - 1:\n            return \"OVERFLOW!!!\"\n\n    return str(x)\n\n\nstdin = \"\"\"9\nadd\nfor 43\nend\nfor 10\nfor 15\nadd\nend\nadd\nend\n\"\"\"\nprint(solution(stdin))\n\n\nstdin = \"\"\"2\nfor 62\nend\n\"\"\"\nprint(solution(stdin))\n\n\nstdin = \"\"\"11\nfor 100\nfor 100\nfor 100\nfor 100\nfor 100\nadd\nend\nend\nend\nend\nend\n\"\"\"\nprint(solution(stdin))"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    cards = stdin\n\n    # Count the number of vowels and even digits\n    vowels = sum(1 for c in cards if c in 'aeiou')\n    even_digits = sum(1 for c in cards if c in '02468')\n\n    # Check if the statement is true\n    if vowels == 0:\n        return 0\n    elif even_digits == vowels:\n        return 0\n    else:\n        return 1"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    seen = set(stdin)\n    flips = 0\n    \n    if any('a' <= c <= 'u' for c in seen):\n        flips += 1\n    \n    if any('0' <= c <= '8' for c in seen):\n        flips += 1\n    \n    return flips"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def has_vowel(card: str) -> bool:\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        return any(char in vowels for char in card)\n\n    def has_even_digit(card: str) -> bool:\n        even_digits = {'0', '2', '4', '6', '8'}\n        return any(char in even_digits for char in card)\n\n    def is_true_for_all_cards(sides: str) -> bool:\n        for i in range(0, len(sides), 2):\n            if has_vowel(sides[i]):\n                if not has_even_digit(sides[i + 1]):\n                    return False\n        return True\n\n    def min_flips(sides: str) -> int:\n        count = 0\n        for i in range(0, len(sides), 2):\n            if has_vowel(sides[i]):\n                count += 1\n        return count\n\n    if is_true_for_all_cards(stdin):\n        return 0\n    else:\n        return min_flips(stdin)\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count_vowel = 0\n    count_even_digit = 0\n\n    for i in range(n):\n        if s[i].isdigit() and int(s[i]) % 2 == 0:\n            count_even_digit += 1\n        if s[i] in 'aeiou':\n            count_vowel += 1\n\n    if count_vowel == 0:\n        return \"0\"\n    elif count_vowel == count_even_digit:\n        return str(count_vowel)\n    else:\n        return str(count_vowel - count_even_digit)\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(c: str) -> bool:\n        return c in 'aeiou'\n\n    def is_even(c: str) -> bool:\n        return c in '02468'\n\n    def is_valid_card(s1: str, s2: str) -> bool:\n        return is_vowel(s1) == is_even(s2)\n\n    def flip_card(cards: List[str], index: int) -> None:\n        cards[index], cards[index + 1] = cards[index + 1], cards[index]\n\n    n = len(stdin)\n    cards = list(stdin)\n\n    if n % 2 != 0:\n        return \"0\"\n\n    valid_cards = 0\n    min_flips = 0\n    for i in range(0, n, 2):\n        if is_valid_card(cards[i], cards[i + 1]):\n            valid_cards += 1\n        else:\n            min_flips += 1\n            flip_card(cards, i)\n            min_flips += 1\n            flip_card(cards, i + 1)\n\n    if valid_cards == n // 2:\n        return str(min_flips)\n    else:\n        return str(min_flips + 2)\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    cards = stdin\n\n    # Initialize variables\n    has_vowel = False\n    has_even = False\n\n    # Check cards\n    for i in range(0, len(cards), 2):\n        # Check if vowel on one side\n        if cards[i] in 'aeiouAEIOU':\n            has_vowel = True\n\n        # Check if even digit on other side\n        if cards[i+1] in '02468':\n            has_even = True\n\n        # If both conditions are true, return 1\n        if has_vowel and has_even:\n            return 1\n\n        # Reset variables for next pair of cards\n        has_vowel = False\n        has_even = False\n\n    # If we've checked all cards and haven't found any pairs, return 0\n    return 0"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n_vowels = sum(1 for c in s if c in 'aeiou')\n    n_even_digits = sum(1 for c in s if c in '02468')\n    if n_vowels == 0:\n        return 0\n    if n_even_digits == 0:\n        return len(s)\n    return min(n_vowels, n_even_digits)\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    cards = stdin\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    evens = {'0', '2', '4', '6', '8'}\n    even_digits = 0\n    for card in cards:\n        if card in vowels:\n            even_digits += 1\n    return min(len(cards), even_digits)\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    sides = stdin\n\n    flipped_cards = 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    for i in range(len(sides)):\n        if sides[i] in vowels:\n            if i % 2 == 0:\n                flipped_cards += 1\n            else:\n                flipped_cards += 2\n\n    return flipped_cards\n"
    },
    {
        "number": 645,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(c: str) -> bool:\n        return c in 'aeiou'\n\n    def is_even(c: str) -> bool:\n        return c in '02468'\n\n    def is_valid_card(card: str) -> bool:\n        return is_vowel(card[0]) == is_even(card[1])\n\n    def count_flips(cards: List[str]) -> int:\n        valid_cards = [card for card in cards if is_valid_card(card)]\n        return len(valid_cards)\n\n    def process(cards: List[str]) -> int:\n        return min(count_flips(cards), 2)\n\n    cards = list(stdin)\n    return process(cards)\n"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        for i in range(n):\n            if x == x_i[i] and y == y_i[i]:\n                return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    x_i, y_i = [], []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        x_i.append(x)\n        y_i.append(y)\n\n    t = 100\n    while not all(is_valid(x + t, y) or is_valid(x - t, y) or is_valid(x, y + t) or is_valid(x, y - t) for x, y in zip(x_i, y_i)):\n        t += 1\n\n    if t <= 100:\n        return str(t)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    detachments = [tuple(map(int, line.split())) for line in input_data[1:]]\n    \n    # Check if there is any point that can be reached by Brimstone\n    def is_reachable(x, y):\n        dx, dy = 0, 0\n        while dx != x or dy != y:\n            if dx == x and dy == y:\n                return True\n            dx, dy = dx + 1, dy\n            if dx > x:\n                dx, dy = 0, dy + 1\n        return False\n    \n    # Check if there is any detachment that Brimstone can visit\n    for x, y in detachments:\n        if is_reachable(x, y):\n            return \"1\"\n    return \"-1\""
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    detachments = [tuple(map(int, input_list[i].split())) for i in range(1, n+1)]\n\n    if n == 1:\n        return 0\n\n    def is_valid(x, y, detachments, new_detachment=False):\n        for det in detachments:\n            if (det[0] == x and det[1] == y) or (new_detachment and det[0] == x and det[1] == y - 1):\n                return False\n        return True\n\n    for x in range(101):\n        for y in range(101):\n            if is_valid(x, y, detachments):\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if is_valid(x+dx, y+dy, detachments, True):\n                            return x + abs(dx) + abs(dy)\n\n    return -1"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def detachment_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def orbital_strike(t):\n        return n * t\n\n    def visit_detachments(t, detachments):\n        x, y = detachments[0]\n        for i in range(1, n):\n            x_i, y_i = detachments[i]\n            distance = detachment_distance(x, y, x_i, y_i)\n            time = distance / 1\n            if t < time:\n                return False\n            t -= time\n            x, y = x_i, y_i\n        return True\n\n    def visit_all_detachments(detachments):\n        for t in range(1, orbital_strike(n) + 1):\n            if visit_detachments(t, detachments):\n                return t\n        return -1\n\n    def add_detachment(detachments, x, y):\n        if any(x == x_i and y == y_i for x_i, y_i in detachments):\n            return False\n        detachments.append((x, y))\n        return True\n\n    n = int(stdin)\n    detachments = [tuple(map(int, input().split())) for _ in range(n)]\n    t = visit_all_detachments(detachments)\n    return str(t)\n"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *coordinates = stdin.strip().split('\\n')\n    n = int(n)\n    coordinates = list(map(lambda x: tuple(map(int, x.split())), coordinates))\n\n    x = sorted(set([x for x, _ in coordinates]))\n    y = sorted(set([y for _, y in coordinates]))\n\n    t = 1\n    while True:\n        covered = set()\n        for i in range(n):\n            xi, yi = coordinates[i]\n            for j in range(4):\n                dx, dy = (1, 0), (0, 1), (-1, 0), (0, -1)\n                if j == 0:\n                    pass\n                elif j == 1:\n                    dx, dy = dy, -dx\n                elif j == 2:\n                    dx, dy = -dx, -dy\n                else:\n                    dx, dy = -dy, dx\n\n                xn, yn = xi + dx, yi + dy\n                if (xn, yn) in coordinates:\n                    covered.add((xn, yn))\n                    break\n            if len(covered) == n:\n                return t\n\n        t += 1"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x = [0] * n\n    y = [0] * n\n\n    for i in range(n):\n        x[i], y[i] = map(int, stdin.split())\n\n    # Determine the size of the grid\n    max_x = max(x)\n    min_x = min(x)\n    max_y = max(y)\n    min_y = min(y)\n\n    size = max(max_x - min_x + 1, max_y - min_y + 1)\n\n    # Determine the maximum time it takes for Brimstone to visit all detachments\n    t = size * size\n\n    # Check if it is possible to visit all detachments\n    visited = [False] * n\n\n    def visit(i):\n        visited[i] = True\n        for j in range(n):\n            if not visited[j]:\n                dx, dy = abs(x[i] - x[j]), abs(y[i] - y[j])\n                if dx + dy <= size:\n                    visit(j)\n\n    visit(0)\n\n    if all(visited):\n        return str(t)\n    else:\n        return \"-1\""
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_point_valid(x, y):\n        for i in range(n):\n            if x == x_i[i] and y == y_i[i]:\n                return False\n        return True\n\n    def count_orbital_strikes(x, y):\n        count = 0\n        for i in range(n):\n            if x == x_i[i] and y == y_i[i]:\n                return 1\n            count += abs(x - x_i[i]) + abs(y - y_i[i])\n        return count\n\n    n = int(stdin.splitlines()[0])\n    x_i = [0] * n\n    y_i = [0] * n\n\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        x_i[i - 1] = x\n        y_i[i - 1] = y\n\n    t = float('inf')\n    for x in range(-1000, 1001):\n        for y in range(-1000, 1001):\n            if is_point_valid(x, y):\n                t = min(t, count_orbital_strikes(x, y))\n\n    if t == float('inf'):\n        return -1\n    else:\n        return int(t)\n\ninput_data = '''4\n100 0\n0 100\n-100 0\n0 -100\n'''\nprint(solution(input_data)) "
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    x = [int(x) for x in stdin[1].split()]\n    y = [int(y) for y in stdin[2].split()]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                if abs(dx) > 1 or abs(dy) > 1:\n                    t = max(abs(dx), abs(dy))\n                    if all(abs(x[i] - x[j]) <= t and abs(y[i] - y[j]) <= t for j in range(n) if i != j):\n                        return str(t)\n    return \"-1\""
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return x >= 0 and y >= 0 and x <= 1000 and y <= 1000\n\n    def is_empty(x, y):\n        return (x, y) not in detachments and is_valid(x, y)\n\n    n = int(stdin.splitlines()[0])\n    detachments = set()\n    orbital_strikes = set()\n    brimstone_pos = None\n\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        detachments.add((x, y))\n        orbital_strikes.add((x, y))\n\n    min_t = float('inf')\n\n    while brimstone_pos is None or orbital_strikes:\n        brimstone_pos = detachments.pop()\n        min_t = 0\n        orbital_strikes.remove(brimstone_pos)\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_pos = (brimstone_pos[0] + dx, brimstone_pos[1] + dy)\n\n            if is_valid(new_pos[0], new_pos[1]) and is_empty(new_pos[0], new_pos[1]):\n                detachments.add(new_pos)\n                orbital_strikes.add(new_pos)\n\n        if not orbital_strikes:\n            break\n\n    return min_t if min_t != float('inf') else -1"
    },
    {
        "number": 646,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    detachments = []\n\n    for _ in range(n):\n        x, y = map(int, input().split())\n        detachments.append((x, y))\n\n    # Find the maximum distance from the origin for any detachment\n    max_distance = max(abs(x) + abs(y) for x, y in detachments)\n\n    # Check if it is possible to visit all detachments with a orbital strike every 1 second\n    if max_distance < 1:\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    hand_order = stdin.splitlines()[1]\n\n    # Initialize two lists to keep track of lefthanders and righthanders\n    lefthanders = []\n    righthanders = []\n\n    # Fill the two lists\n    for i, hand in enumerate(hand_order, 1):\n        if hand == 'L':\n            lefthanders.append(i)\n        else:\n            righthanders.append(i)\n\n    # Initialize the list to keep track of pairs\n    pairs = []\n\n    # Iterate over the even numbers from 2 to n/2\n    for i in range(2, n//2 + 1, 2):\n        # If there are less lefthanders than i, move to the next iteration\n        if len(lefthanders) < i:\n            continue\n        # If there are less righthanders than i, move to the next iteration\n        if len(righthanders) < i:\n            continue\n        # If i is equal to the length of both lefthanders and righthanders, add the first i pairs to the list\n        if len(lefthanders) == i and len(righthanders) == i:\n            for j in range(i):\n                pairs.append((lefthanders[j], righthanders[j]))\n            lefthanders = lefthanders[i:]\n            righthanders = righthanders[i:]\n        # If i is less than the length of both lefthanders and righthanders, add the first i pairs to the list\n        elif len(lefthanders) > len(righthanders):\n            for j in range(i):\n                pairs.append((lefthanders[j], righthanders[-1-j]))\n            lefthanders = lefthanders[i:]\n        # If i is greater than the length of both lefthanders and righthanders, add the first i pairs to the list, with the last student in each pair\n        else:\n            for j in range(i):\n                pairs.append((lefthanders[-1-j], righthanders[j]))\n            lefthanders = lefthanders[:-i]\n            righthanders = righthanders[i:]\n\n    # If there are any leftover lefthanders or righthanders, add them to the list with the last student in each pair\n    if len(lefthanders) > 0:\n        for i in range(1, len(lefthanders)+1):\n            pairs.append((lefthanders[-i], righthanders[-i+1]))\n    if len(righthanders) > 0:\n        for i in range(1, len(righthanders)+1):\n            pairs.append((lefthanders[-i+1], righthanders[-i]))\n\n    # Print the pairs in the desired format\n    for pair in pairs:\n        print(f\"{pair[0]} {pair[1]}\")"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lefthanders = stdin.splitlines()[1]\n    \n    # Create two lists with the lefthanders and righthanders\n    lefthanders = [i + 1 for i in range(n) if lefthanders[i] == 'L']\n    righthanders = [i + 1 for i in range(n) if lefthanders[i] == 'R']\n    \n    # Calculate the number of desks needed\n    num_desks = n // 2\n    \n    # Define a function to swap two elements in a list\n    def swap(lst: list, i: int, j: int) -> None:\n        lst[i], lst[j] = lst[j], lst[i]\n    \n    # Define a function to assign students to desks\n    def assign_desks(desks: list, lefthanders: list, righthanders: list) -> None:\n        # Sort the lefthanders and righthanders\n        lefthanders.sort()\n        righthanders.sort(reverse=True)\n        \n        # Assign the students to the desks\n        for i in range(num_desks):\n            desks[i].append(lefthanders.pop(0))\n            desks[i].append(righthanders.pop(0))\n    \n    # Create a list of desks\n    desks = [[] for i in range(num_desks)]\n    \n    # Define a function to check if two desks do not interfere\n    def no_interference(desk1: list, desk2: list) -> bool:\n        if desk1[-1] - desk1[0] == desk2[-1] - desk2[0]:\n            return False\n        if desk1[-1] - desk1[0] == desk2[0] - desk1[0] or desk1[-1] - desk1[0] == desk2[-1] - desk2[0]:\n            return True\n        return False\n    \n    # Try to assign the students to desks until a valid arrangement is found\n    for i in range(num_desks):\n        if not lefthanders and not righthanders:\n            break\n        assign_desks(desks, lefthanders, righthanders)\n        \n        # Swap the last two students on the desk if they are both lefthanders or righthanders\n        if len(desks[i]) >= 2 and (desks[i][-1] % 2 == desks[i][-2] % 2):\n            swap(desks[i], -1, -2)\n        \n        # Check if the desks do not interfere with each other\n        for j in range(num_desks):\n            if j != i and not no_interference(desks[i], desks[j]):\n                swap(desks[i], -1, -2)\n                break\n    \n    # Print the result\n    for i in range(num_desks):\n        print(desks[i][0], desks[i][1])\n"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    hand_data = stdin.split('\\n')[1]\n    \n    left_handed = []\n    right_handed = []\n    \n    for i in range(n):\n        if hand_data[i] == 'L':\n            left_handed.append(i+1)\n        else:\n            right_handed.append(i+1)\n    \n    desk_order = []\n    \n    for i in range(0, n//2):\n        desk_order.append((left_handed[i], right_handed[n//2-i-1]))\n    \n    if n % 2 == 1:\n        desk_order.append((right_handed[-1], left_handed[n//2]))\n    \n    return '\\n'.join([f\"{pair[0]} {pair[1]}\" for pair in desk_order])\n\n\ndef"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    lefthanders = list(stdin.split(\"\\n\")[1])\n    result = []\n    \n    for i in range(0, n, 2):\n        pair = (i + 1, i + 2) if lefthanders[i] == \"L\" else (i, i + 1)\n        result.append(pair)\n    \n    return \"\\n\".join(f\"{a} {b}\" for a, b in result)\n"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, hand = map(str, stdin.split('\\n'))\n    n = int(n)\n    hand = hand.strip()\n\n    # Seat the students at the desks\n    seats = [[] for _ in range(n // 2)]\n    left_handers = [i for i in range(1, n + 1) if hand[i - 1] == 'L']\n    right_handers = [i for i in range(1, n + 1) if hand[i - 1] == 'R']\n    for i in range(n // 2):\n        seats[i].append(left_handers.pop())\n        seats[i].append(right_handers.pop())\n\n    # Print the seats\n    result = '\\n'.join([f\"{seats[i][0]} {seats[i][1]}\" for i in range(n // 2)])\n    return result\n"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    hands = stdin[1].split()\n\n    def seat_students(desk_num: int, left_hander_count: int, right_hander_count: int, lefthanders: list, righthanders: list) -> None:\n        if desk_num == 0:\n            if left_hander_count >= 1:\n                left_hander = lefthanders.pop()\n                print(left_hander, n - left_hander + 1)\n            else:\n                right_hander = righthanders.pop()\n                print(n - right_hander + 1, right_hander)\n        else:\n            if left_hander_count >= 1:\n                left_hander = lefthanders.pop()\n                right_hander = righthanders.pop()\n                print(left_hander, n - left_hander + 1)\n                print(n - right_hander + 1, right_hander)\n            else:\n                right_hander = righthanders.pop()\n                left_hander = lefthanders.pop()\n                print(left_hander, n - left_hander + 1)\n                print(n - right_hander + 1, right_hander)\n\n    for i in range(n):\n        if hands[i] == \"L\":\n            lefthanders.append(i + 1)\n        else:\n            righthanders.append(i + 1)\n\n    lefthanders.sort(reverse=True)\n    righthanders.sort()\n\n    for i in range(0, n, 2):\n        seat_students(i, len(lefthanders), len(righthanders), lefthanders, righthanders)\n\nstdin = \"6\\nLLRLLL\"\nsolution(stdin.splitlines()) "
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    hand_order = stdin[1].split()\n    lefthanders = [i for i, hand in enumerate(hand_order) if hand == \"L\"]\n    righthanders = [i for i, hand in enumerate(hand_order) if hand == \"R\"]\n\n    desks = []\n    for i in range(n // 2):\n        desks.append((lefthanders.pop(0), righthanders.pop(0)))\n        desks.append((righthanders.pop(0), lefthanders.pop(0)))\n\n    return \"\\n\".join(f\"{pair[0]} {pair[1]}\" for pair in desks)\n"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lr_str = stdin.split('\\n')[1]\n    lefthanders = []\n    righthanders = []\n\n    for i in range(n):\n        if lr_str[i] == 'L':\n            lefthanders.append(i)\n        else:\n            righthanders.append(i)\n\n    pairs = []\n    for i in range(n//2):\n        left_student = lefthanders[i]\n        right_student = righthanders[n//2 - i - 1]\n        pairs.append((left_student, right_student))\n\n    return '\\n'.join([f\"{pair[0]} {pair[1]}\" for pair in pairs])\n\n\ninput_data = \"\"\"6\nLLRLLL\n4\nRRLL\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    lefthanders = stdin[1].split()\n    \n    result = []\n    lefthander_count = 0\n    righthander_count = n // 2\n    \n    for i in range(n):\n        if lefthanders[i] == \"L\":\n            result.append((i+1, righthander_count))\n            lefthander_count += 1\n        else:\n            result.append((righthander_count, i+1))\n            righthander_count -= 1\n    \n    return \"\\n\".join([\" \".join(map(str, pair)) for pair in result])\n"
    },
    {
        "number": 647,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    hand = list(stdin[1])\n    \n    for i in range(n):\n        if hand[i] == 'L':\n            continue\n        elif hand[i] == 'R':\n            hand[i] = 'L'\n            hand[n-i-1] = 'R'\n        else:\n            raise ValueError(\"Invalid input. Expected 'L' or 'R', but got\", hand[i])\n    \n    result = []\n    for i in range(n//2):\n        result.append([i+1, n-i])\n        result.append([n-i, i+1])\n    \n    return '\\n'.join(f\"{pair[0]} {pair[1]}\" for pair in result) "
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    x = y = 0\n    while y <= -x / m + b:\n        x += 1\n    x -= 1\n    y = -x / m + b\n    area = (y - (-x / m + b)) * x\n    return area\n\ndef"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    max_bananas = 0\n    for x in range(m + 1):\n        y = -x / m + b\n        if y >= 0:\n            max_bananas = max(max_bananas, x + y)\n    return str(max_bananas)\n\nm = int(input())\nb = int(input())\nprint(solution(f\"{m} {b}\")) "
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    m = int(input_values[0])\n    b = int(input_values[1])\n\n    x = 0\n    y = b\n    bananas = 0\n\n    while x <= m:\n        bananas += (x + y)\n        x += 1\n        y = b - m * x\n\n    return str(bananas)\n\n\ninput_stdin = \"1 5\\n2 3\"\noutput_stdin = \"1 5\\n2 3\"\n\nfor i in range(len(input_stdin)):\n    input_line = input_stdin[i].strip()\n    output_line = output_stdin[i].strip()\n\n    input_values = input_line.split()\n    output_value = int(output_line)\n\n    result = solution(input_line)\n\n    if int(result) != output_value:\n        print(f\"Test failed at line {i + 1}:\\n\"\n              f\"Expected output: {output_value}\\n\"\n              f\"Computed output: {result}\\n\"\n              f\"Input: {input_line}\\n\")\n        break\nelse:\n    print(\"All tests passed successfully!\") "
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    m, b = int(input_list[0]), int(input_list[1])\n    \n    # Find the coordinates of the rectangle's top left and bottom right corners\n    x1 = y1 = max(-b // m, -b // (m+1))\n    x2 = y2 = min((10000 - b) // m, (10000 - b) // (m+1))\n    \n    # Calculate the total number of bananas in the rectangle\n    total_bananas = (x2 - x1 + 1) * (y1 - y2 + 1) * (x1 + y1 + 1) // 2\n    \n    return str(total_bananas)\n\ndef"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    x_min, x_max = 0, 1001\n    y_min, y_max = -1001, 1001\n\n    def cut_trees(x1, x2, y1, y2):\n        area = (x2 - x1) * (y2 - y1)\n        max_bananas = 0\n\n        for x in range(x1, x2 + 1):\n            for y in range(y1, y2 + 1):\n                bananas = x + y\n                if bananas > max_bananas:\n                    max_bananas = bananas\n\n        return max_bananas\n\n    def solve(x1, x2, y1, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        x_mid = (x1 + x2) // 2\n        y_mid = -x_mid // m + b\n\n        left_bananas = cut_trees(x1, x_mid, y1, y_mid)\n        right_bananas = cut_trees(x_mid + 1, x2, y1, y_mid)\n        top_bananas = cut_trees(x1, x2, y1, y_mid)\n        bottom_bananas = cut_trees(x1, x2, y_mid + 1, y2)\n\n        return max(left_bananas, right_bananas, top_bananas, bottom_bananas)\n\n    while x_min <= x_max and y_min <= y_max:\n        x_mid = (x_min + x_max) // 2\n        y_mid = -x_mid // m + b\n\n        if y_mid > y_max or y_mid < y_min:\n            x_min = x_mid + 1\n        else:\n            x_max = x_mid\n            y_min = y_mid\n\n    return solve(x_min, x_max, y_min, y_max)\n"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split()\n    m, b = map(int, input_str)\n    max_bananas = 0\n    for x in range(m+1):\n        y = -x/m + b\n        if y % 1 == 0 and y >= 0:\n            max_bananas += x + int(y)\n    return str(max_bananas)"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, input().split())\n    max_bananas = 0\n    for x in range(m + 1):\n        y = -x / m + b\n        if y == int(y):\n            bananas = x + int(y)\n            max_bananas = max(max_bananas, bananas)\n    return str(max_bananas)\n\nprint(solution(\"1 5\\n\"))  # Output: 30\nprint(solution(\"2 3\\n\"))  # Output: 25 "
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    max_bananas = 0\n    for x in range(1001):\n        y = - x * m / b\n        if y % 1 == 0 and y >= 0 and y <= b:\n            bananas = x + int(y)\n            max_bananas = max(max_bananas, bananas)\n    return str(max_bananas)\n"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    \n    if m == 1:\n        return 0\n    \n    x_min, x_max = -1000, 1000\n    y_min, y_max = -1000, 1000\n    \n    x_mid = (x_min + x_max) // 2\n    y_mid = -x_mid * m // 2 + b\n    \n    max_bananas = 0\n    \n    while x_min <= x_mid <= x_max and y_min <= y_mid <= y_max:\n        bananas = 0\n        \n        for x in range(x_min, x_mid + 1):\n            y = -x * m // 2 + b\n            if y_min <= y <= y_mid:\n                bananas += x + y\n        \n        for y in range(y_min, y_mid + 1):\n            x = -y * 2 // b\n            if x_min <= x <= x_mid:\n                bananas += x + y\n        \n        max_bananas = max(max_bananas, bananas)\n        \n        x_min += 1\n        x_mid = (x_min + x_max) // 2\n        y_mid = -x_mid * m // 2 + b\n    \n    return max_bananas\n"
    },
    {
        "number": 648,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    x = m * b\n    y = -x // m\n    area = (x + 1) * (y + 1)\n    return str(area)"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    t = list(map(int, input().split()))\n    \n    def count_visited_cells(level: int, remaining_parts: int, start_cell: tuple[int, int]) -> int:\n        if level == 0:\n            return 1 if remaining_parts == 1 else 0\n        \n        visited_cells = 0\n        for i in range(4):\n            next_cell = (start_cell[0] + i // 2, start_cell[1] + (i % 2) * 2)\n            visited_cells += count_visited_cells(level - 1, remaining_parts // 4, next_cell)\n        \n        return visited_cells\n    \n    visited_cells = 0\n    for i in range(n):\n        visited_cells += count_visited_cells(i, 2**i - 1, (0, 0))\n    \n    return str(visited_cells)\n\ninput_str = '''4\n4 2 2 3\n6\n1 1 1 1 1 3\n1\n3'''\n\noutput_str = '''39\n85\n3'''"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *ts = map(int, stdin.split())\n    total = 0\n    for i in range(n):\n        total += (2**i - 1) * ts[i]\n    return str(total)\n"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n\n    def count_cells(n: int, t: list) -> int:\n        if n == 1:\n            return 3\n\n        count = 0\n        count += count_cells(n - 1, t)\n        count += (t[n - 1] - 1) * 2 ** (n - 1)\n\n        return count\n\n    result = count_cells(n, t)\n    return str(result)\n"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_visited_cells(n: int, t: list) -> int:\n        visited_cells = 0\n        for i in range(1, n + 1):\n            num_parts = 2**(i - 1) - 1\n            visited_cells += num_parts * t[i - 1]\n        return visited_cells\n\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n    return str(count_visited_cells(n, t))\n"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n\n    # calculate the number of cells that will be visited at least once\n    visited = 0\n    for i in range(n):\n        visited += 2**i - 1 + t[i] - 1\n\n    return str(visited)"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    t = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    total = 0\n    for i in range(n):\n        total += 2 ** i - 1\n\n    return str(total)\n\n\ninput_str = \"\"\"4\n4 2 2 3\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *ts = map(int, stdin.split())\n    total = 0\n    for i in range(n):\n        total += 2**i * (ts[i] + i + 1)\n    return str(total)\n\ninput_data = \"\"\"\n4\n4 2 2 3\n\"\"\"\n\nprint(solution(input_data)) # Output: 39\n\ninput_data = \"\"\"\n6\n1 1 1 1 1 3\n\"\"\"\n\nprint(solution(input_data)) # Output: 85\n\ninput_data = \"\"\"\n1\n3\n\"\"\"\n\nprint(solution(input_data)) # Output: 3 "
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n    total_cells = 0\n\n    for i in range(n):\n        total_cells += (2 ** i - 1) * t[i]\n\n    return str(total_cells)\n"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    t = [int(t) for t in stdin.split(\"\\n\")[1].split()]\n    visited_cells = 0\n    for i in range(n):\n        visited_cells += 2 ** i * (t[i] + i)\n    return str(visited_cells)\n"
    },
    {
        "number": 649,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n    \n    def count_cells(i: int, x: int, y: int) -> int:\n        if i == 0:\n            return 1\n        count = 0\n        for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n            count += count_cells(i-1, x+dx*t[i-1], y+dy*t[i-1])\n        return count\n    \n    total_cells = 0\n    for i in range(1, n+1):\n        total_cells += count_cells(i, 0, 0)\n    \n    return str(total_cells) "
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    \n    if stdin[0] == \"Y\" and stdin[-1] == \"E\":\n        return \"YES\"\n    elif len(stdin) == 2 and stdin[0] == \"A\" and stdin[1] in consonants:\n        return \"YES\"\n    elif len(stdin) == 4 and stdin[0] == \"J\" and stdin[1] == \"U\" and stdin[2] == \"R\" and stdin[3] == \"O\":\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    return 'YES' if sum(1 for c in stdin if c in vowels) % 2 == 1 else 'NO'\n"
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for letter in stdin:\n        if letter in vowels:\n            count += 1\n    \n    return \"YES\" if count >= 2 else \"NO\"\n\n\ndef"
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    consonants = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    consonant_count = 0\n    vowel_count = 0\n    for char in stdin:\n        if char in vowels:\n            vowel_count += 1\n        elif char in consonants:\n            consonant_count += 1\n    if consonant_count >= 2 and vowel_count >= 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    count_vowels = 0\n    for char in stdin:\n        if char in vowels:\n            count_vowels += 1\n    if count_vowels % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    stdin = stdin.upper()\n    \n    if len(stdin) == 1 and stdin in consonants:\n        return \"YES\"\n    elif len(stdin) == 2 and stdin[0] in vowels and stdin[1] in vowels:\n        return \"YES\"\n    elif len(stdin) == 4 and stdin[1] in vowels and stdin[2] in vowels and stdin[3] in vowels:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    vowel_count = 0\n    consonant_count = 0\n    \n    for char in stdin:\n        if char in vowels:\n            vowel_count += 1\n        elif char in consonants:\n            consonant_count += 1\n    \n    if vowel_count == 0:\n        return \"NO\"\n    elif vowel_count > consonant_count:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    vowels = 'AEIOU'\n    consonants = 'BCDFGHJKLMNPQRSTVWXYZ'\n    vowel_count = 0\n    consonant_count = 0\n\n    for char in stdin:\n        if char in vowels:\n            vowel_count += 1\n        elif char in consonants:\n            consonant_count += 1\n\n    if vowel_count == 0 or consonant_count == 0:\n        return 'NO'\n    elif vowel_count > consonant_count:\n        return 'YES'\n    else:\n        return 'NO'\n"
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) == 1:\n        return \"NO\"\n    elif len(stdin) == 2:\n        if stdin[0] == stdin[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\""
    },
    {
        "number": 650,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    vowel_count = 0\n    consonant_count = 0\n    for char in stdin:\n        if char in vowels:\n            vowel_count += 1\n        elif char in consonants:\n            consonant_count += 1\n        else:\n            return \"NO\"\n    \n    if vowel_count > 1 and consonant_count > 2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, s = stdin.split('\\n')\n    n, m = int(n), int(m)\n    maze = [input() for _ in range(n)]\n    directions = {'0': 'D', '1': 'L', '2': 'U', '3': 'R'}\n\n    # Count the number of valid mappings\n    count = 0\n    for mapping in product(*[(d,) for d in '0123']):\n        mapping = ''.join(mapping)\n        valid = True\n        x, y = 0, 0\n        for direction in mapping:\n            if direction == '0':\n                if y < m - 1 and maze[x][y + 1] != '#':\n                    y += 1\n                else:\n                    valid = False\n                    break\n            elif direction == '1':\n                if x > 0 and maze[x - 1][y] != '#':\n                    x -= 1\n                else:\n                    valid = False\n                    break\n            elif direction == '2':\n                if x > 0 and maze[x - 1][y] != '#':\n                    x -= 1\n                else:\n                    valid = False\n                    break\n            elif direction == '3':\n                if y < m - 1 and maze[x][y + 1] != '#':\n                    y += 1\n                else:\n                    valid = False\n                    break\n            else:\n                raise ValueError('Invalid direction')\n            if maze[x][y] == 'E':\n                valid = False\n                break\n        if valid:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_direction(digit: str) -> str:\n        if digit == \"0\":\n            return \"D\"\n        elif digit == \"1\":\n            return \"L\"\n        elif digit == \"2\":\n            return \"U\"\n        else:\n            return \"R\"\n\n    def is_valid_mapping(mapping: list[str]) -> bool:\n        directions = set()\n        for digit in mapping:\n            direction = get_direction(digit)\n            if direction in directions:\n                return False\n            directions.add(direction)\n        return True\n\n    def count_valid_mappings(s: str) -> int:\n        mappings = 0\n        for mapping in itertools.product(\"0123\", repeat=len(s)):\n            if is_valid_mapping(mapping):\n                mappings += 1\n        return mappings\n\n    n, m = map(int, stdin.split()[:2])\n    maze = [stdin.split()[i] for i in range(2, n + 2)]\n    s = stdin.split()[-1]\n\n    return count_valid_mappings(s)\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split(','))\n    maze = [input() for _ in range(n)]\n    s = input()\n    directions = ['U', 'L', 'D', 'R']\n    valid_mappings = 0\n\n    for mapping in product(directions, repeat=len(s)):\n        if s.isdigit() and all(x in directions for x in mapping):\n            robot_position = []\n            for i, c in enumerate(maze):\n                robot_position.append(c.find('S'))\n\n            for char, direction in zip(s, mapping):\n                if direction == 'U':\n                    robot_position[robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position.index(robot_position"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    maze = lines[1:n+1]\n    s = lines[n+1]\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # UDLR\n    valid_mappings = []\n\n    def is_valid(position, direction):\n        row, col = position\n        drow, dcol = direction\n        if 0 <= row + drow < n and 0 <= col + dcol < m and maze[row + drow][col + dcol] != '#':\n            return True\n        return False\n\n    def robot(position, mapping):\n        if len(mapping) == len(s):\n            return 1\n        row, col = position\n        for i, d in enumerate(mapping):\n            if not is_valid((row, col), directions[d]):\n                return 0\n            row, col = row + directions[d][0], col + directions[d][1]\n            if maze[row][col] == 'E':\n                return 1 + robot((row, col), mapping[i+1:])\n        return 0\n\n    for mapping in itertools.product(range(4), repeat=len(s)):\n        if robot((0, 0), mapping):\n            valid_mappings.append(mapping)\n\n    return len(valid_mappings)\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    maze = lines[1:n+1]\n    s = lines[-1]\n    \n    directions = [\"up\", \"left\", \"down\", \"right\"]\n    valid_mappings = []\n    \n    for mapping in itertools.permutations(directions):\n        valid = True\n        robot_x, robot_y = None, None\n        for i, c in enumerate(s):\n            if c == \"0\":\n                direction = mapping[0]\n            elif c == \"1\":\n                direction = mapping[1]\n            elif c == \"2\":\n                direction = mapping[2]\n            else:\n                direction = mapping[3]\n                \n            if direction == \"up\" and robot_y - 1 >= 0 and maze[robot_y - 1][robot_x] != \"#\":\n                robot_y -= 1\n            elif direction == \"left\" and robot_x - 1 >= 0 and maze[robot_y][robot_x - 1] != \"#\":\n                robot_x -= 1\n            elif direction == \"down\" and robot_y + 1 < n and maze[robot_y + 1][robot_x] != \"#\":\n                robot_y += 1\n            elif direction == \"right\" and robot_x + 1 < m and maze[robot_y][robot_x + 1] != \"#\":\n                robot_x += 1\n            else:\n                valid = False\n                break\n                \n            if maze[robot_y][robot_x] == \"E\":\n                valid_mappings.append(mapping)\n                break\n                \n        if valid:\n            valid_mappings.append(mapping)\n            \n    return len(valid_mappings)\n\nstdin = \"\"\"5 6\n.....#\nS....#\n.#....\n.#....\n...E..\n333300012\n\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"6 6\n......\n......\n..SE..\n......\n......\n......\n01232123212302123021\n\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"5 3\n...\n.S.\n###\n.E.\n0\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def robot_maze_helper(maze: str, directions: str, index: int = 0, visited: set = None, count: int = 0) -> int:\n        if index == len(directions):\n            return count\n        if visited is None:\n            visited = set()\n        x, y = 0, 0\n        for i, direction in enumerate(directions[:index + 1]):\n            if (x, y) in visited:\n                return 0\n            visited.add((x, y))\n            if direction == '0':\n                y -= 1\n            elif direction == '1':\n                x -= 1\n            elif direction == '2':\n                y += 1\n            elif direction == '3':\n                x += 1\n            if maze[y][x] == '#':\n                return 0\n            if maze[y][x] == 'E':\n                count += 1\n        return robot_maze_helper(maze, directions, index + 1, visited, count)\n\n    n, m = map(int, input().split())\n    maze = [list(input()) for _ in range(n)]\n    s = input()\n    directions = [s[i:i + m] for i in range(0, len(s), m)]\n    count = 0\n    for directions_list in directions:\n        count += robot_maze_helper(maze, directions_list)\n    return count\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    maze_size = input_data.pop(0).split()\n    n, m = int(maze_size[0]), int(maze_size[1])\n    maze = [input_data.pop(0) for _ in range(n)]\n    s = input_data.pop(0)\n    directions = ['U', 'L', 'D', 'R']\n    valid_mappings = 0\n\n    def is_valid_mapping(mapping: dict) -> bool:\n        robot_position = None\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == 'S':\n                    robot_position = (i, j)\n                    break\n            if robot_position is not None:\n                break\n        if robot_position is None:\n            return False\n        y, x = robot_position\n        for direction, step in mapping.items():\n            if step == 0:\n                continue\n            if direction == 'U':\n                y -= 1\n            elif direction == 'L':\n                x -= 1\n            elif direction == 'D':\n                y += 1\n            elif direction == 'R':\n                x += 1\n            if y < 0 or y >= n or x < 0 or x >= m or maze[y][x] == '#':\n                return False\n        return True\n\n    for mapping in product(directions, repeat=4):\n        if is_valid_mapping(dict(zip(directions, mapping))):\n            valid_mappings += 1\n\n    return valid_mappings\n\n\ndef"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data.pop(0).split())\n    maze = [list(line.strip()) for line in input_data[:n]]\n    s = input_data[-1]\n\n    def is_valid_move(row: int, col: int, direction: int) -> bool:\n        if direction == 0:  # down\n            return row + 1 < n and maze[row + 1][col] != '#'\n        elif direction == 1:  # left\n            return col - 1 >= 0 and maze[row][col - 1] != '#'\n        elif direction == 2:  # up\n            return row - 1 >= 0 and maze[row - 1][col] != '#'\n        elif direction == 3:  # right\n            return col + 1 < m and maze[row][col + 1] != '#'\n        else:\n            return False\n\n    def explore(row: int, col: int, direction: int, used_directions: set) -> int:\n        if (row, col, direction) in used_directions:\n            return 0\n\n        used_directions.add((row, col, direction))\n        if row == n - 1 and col == m - 1:\n            return 1\n\n        directions = [0, 1, 2, 3]\n        random.shuffle(directions)\n        for next_direction in directions:\n            if is_valid_move(row, col, next_direction):\n                if next_direction == int(s[0]):\n                    return explore(row, col, next_direction, used_directions) + 1\n                else:\n                    return explore(row, col, next_direction, used_directions)\n        return 0\n\n    return explore(0, 0, int(s[0]), set())\n\n\nimport random\ninput_data = \"\"\"5 6\n.....#\nS....#\n.#....\n.#....\n...E..\n333300012\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"6 6\n......\n......\n..SE..\n......\n......\n......\n01232123212302123021\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n###\n.E.\n3\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n3\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n##.\n.E.\n3\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n1\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n2\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n3\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n4\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n0\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n1\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n1\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n1\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"5 3\n...\n.S.\n.E.\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    maze = []\n    for i in range(n):\n        maze.append(list(input()))\n\n    s = input()\n\n    def valid(x, y, d):\n        if d == 0:\n            return 0 <= x < n and maze[x][y] == '.'\n        elif d == 1:\n            return 0 <= y < m and maze[x][y] == '.'\n        elif d == 2:\n            return 0 <= x < n and maze[x][y] == '.'\n        else:\n            return 0 <= y < m and maze[x][y] == '.'\n\n    directions = ['D', 'L', 'U', 'R']\n    count = 0\n\n    for d in s:\n        x, y = 0, 0\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == 'S':\n                    x, y = i, j\n        if d == '0':\n            if valid(x - 1, y, 0):\n                count += 1\n        elif d == '1':\n            if valid(x, y - 1, 1):\n                count += 1\n        elif d == '2':\n            if valid(x + 1, y, 2):\n                count += 1\n        elif d == '3':\n            if valid(x, y + 1, 3):\n                count += 1\n        if maze[x][y] == 'E':\n            break\n\n    return count\n"
    },
    {
        "number": 651,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    maze = []\n    for i in range(n):\n        maze.append(input())\n\n    s = input()\n    count = 0\n\n    for d0 in range(4):\n        for d1 in range(4):\n            for d2 in range(4):\n                for d3 in range(4):\n                    directions = [d0, d1, d2, d3]\n                    if not is_valid(maze, s, directions):\n                        continue\n                    count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if not (points[i][1] * points[j][0] - points[i][0] * points[j][1] == points[j][1] * points[k][0] - points[j][0] * points[k][1] == points[i][1] * points[k][0] - points[i][0] * points[k][1]):\n                    continue\n                if not (points[i][0] * points[j][1] - points[i][1] * points[j][0] == points[j][0] * points[k][1] - points[j][1] * points[k][0] == points[i][0] * points[k][1] - points[i][1] * points[k][0]):\n                    continue\n                count += 1\n                \n    return str(count)\n"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    def count_parallelograms(points):\n        count = 0\n        for a, b, c in itertools.combinations(points, 3):\n            if is_parallel(a, b, c):\n                count += 1\n        return count\n    \n    def is_parallel(a, b, c):\n        return are_collinear(a, b, c) or are_collinear(a, c, b)\n\n    def are_collinear(a, b, c):\n        return determinant(a, b, c) == 0\n\n    def determinant(a, b, c):\n        return a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])\n\n    count = count_parallelograms(points)\n    return str(count)\n\n\nn = int(input())\nfor i in range(n):\n    x, y = map(int, input().split())\n    print(x, y)\n\nprint(solution(stdin)) "
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [(int(x), int(y)) for x, y in map(lambda x: x.split(), stdin.splitlines()[1:])]\n    \n    def is_parallel(p1, p2, p3):\n        return p1[0] * (p2[1] - p3[1]) == p1[1] * (p2[0] - p3[0])\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if is_parallel((0,0), points[i], points[j]) and is_parallel((0,0), points[i], points[k]) and is_parallel((0,0), points[j], points[k]):\n                    count += 1\n                    \n    return str(count)\n\n\ninput_str = \"\"\"4\n0 1\n1 0\n1 1\n2 0\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_parallel(p1, p2, p3):\n        # Check if p1, p2, and p3 lie on the same line\n        return p2[0] * (p3[1] - p1[1]) == p2[1] * (p3[0] - p1[0])\n\n    def is_valid(p1, p2, p3, p4):\n        # Check if p1, p2, p3, and p4 form a parallelogram\n        return is_parallel(p1, p2, p3) and is_parallel(p1, p2, p4)\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(n):\n                for l in range(n):\n                    if i != k and j != l and is_valid(points[i], points[j], points[k], points[l]):\n                        count += 1\n\n    return str(count)\n"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else -1\n\n    def is_convex(p, q, r):\n        o1 = orientation(p, q, r)\n        o2 = orientation(q, r, p)\n        o3 = orientation(r, p, q)\n        if o1 != o2 or o2 != o3:\n            return False\n        return True\n\n    n, *points = stdin.split('\\n')\n    n = int(n)\n    points = [tuple(map(int, point.split())) for point in points]\n\n    c = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                p, q, r = points[i], points[j], points[k]\n                if is_convex(p, q, r) and orientation(p, q, r) != 0:\n                    c += 1\n    return str(c)\n"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def are_collinear(a, b, c):\n        return cross_product(a, b) == 0 and cross_product(b, c) == 0\n\n    def parallelograms_count(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(len(points)):\n                    if k != i and k != j and are_collinear(points[i], points[j], points[k]):\n                        count += 1\n        return count // 2\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = parallelograms_count(points)\n    return str(result)\n\n\ninput_string = \"\"\"4\n0 1\n1 0\n1 1\n2 0\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [(int(x), int(y)) for x, y in map(lambda x: x.split(), stdin.split('\\n')[1:])]\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                p1, p2, p3 = points[i], points[j], points[k]\n                if not are_collinear(p1, p2, p3):\n                    count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def is_convex(a, b, c):\n        o1 = orientation(a, b, c)\n        o2 = orientation(b, c, a)\n        o3 = orientation(c, a, b)\n        return o1 * o2 * o3 >= 0\n\n    def find_parallelograms(points):\n        n = len(points)\n        count = 0\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if is_convex(points[i], points[j], points[k]):\n                        count += 1\n        return count\n\n    n = int(stdin.split()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    result = find_parallelograms(points)\n    return str(result)\n\n\ninput_string = \"\"\"4\n0 1\n1 0\n1 1\n2 0\"\"\"\nprint(solution(input_string)) "
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_parallel(p1, p2, p3):\n        return p2[0] - p1[0] != 0 and (p3[0] - p1[0]) / (p2[0] - p1[0]) == (p3[1] - p1[1]) / (p2[1] - p1[1])\n\n    n, *points = stdin.split()\n    n = int(n)\n    points = [tuple(map(int, point.split(','))) for point in points]\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_parallel(points[i], points[j], points[k]):\n                    count += 1\n    return str(count // 2)  # divide by 2 to count only unique parallelograms\n\n\ndef"
    },
    {
        "number": 652,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    points = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n\n    def get_angle(a, b, c):\n        a, b, c = sorted((a, b, c))\n        return min(b - a, c - b)\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                angle_i_j = get_angle(points[i], points[j], points[k])\n                angle_j_k = get_angle(points[j], points[k], points[i])\n                angle_k_i = get_angle(points[k], points[i], points[j])\n                if angle_i_j == 0 or angle_j_k == 0 or angle_k_i == 0:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stdin = int(stdin.pop(0)), stdin[::-1]\n    events = {}\n    for i in range(n):\n        event = stdin.pop(0)\n        if event == 'L':\n            for j in range(10):\n                if events.get(j) is None:\n                    events[j] = 1\n                    break\n        elif event == 'R':\n            for j in range(10):\n                if events.get(j) is None:\n                    events[j] = 1\n                    break\n        else:\n            events[int(event)] = 0\n\n    result = [events.get(i, 0) for i in range(10)]\n    return ''.join(map(str, result))"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    actions = stdin.splitlines()[1]\n    rooms = [0] * 10\n\n    for action in actions:\n        if action == 'L':\n            for i in range(10):\n                if rooms[i] == 0:\n                    rooms[i] = 1\n                    break\n        elif action == 'R':\n            for i in range(9, -1, -1):\n                if rooms[i] == 0:\n                    rooms[i] = 1\n                    break\n        else:\n            rooms[int(action)] = 0\n\n    return ''.join(map(str, rooms))\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    events = stdin[1].split()\n    rooms = [0] * 10\n\n    for event in events:\n        if event == \"L\":\n            rooms[0] = 1\n        elif event == \"R\":\n            rooms[-1] = 1\n        else:\n            rooms[int(event)] = 0\n\n    return \"\".join(map(str, rooms))"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, events = int(stdin.splitlines()[0]), stdin.splitlines()[1]\n    room_status = ['0'] * 10\n    left_entrance_queue, right_entrance_queue = [], []\n\n    for event in events:\n        if event == 'L':\n            if not left_entrance_queue:\n                left_entrance_queue.append(0)\n            else:\n                occupied_room = left_entrance_queue.pop(0)\n                room_status[occupied_room] = '1'\n                left_entrance_queue.append(occupied_room)\n        elif event == 'R':\n            if not right_entrance_queue:\n                right_entrance_queue.append(9)\n            else:\n                occupied_room = right_entrance_queue.pop(0)\n                room_status[occupied_room] = '1'\n                right_entrance_queue.append(occupied_room)\n        else:\n            if event == '0':\n                left_entrance_queue.append(int(event))\n            else:\n                right_entrance_queue.append(int(event))\n\n    result = ''.join(room_status)\n    return result\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, events = int(stdin[0]), stdin[1]\n    room_status = [0] * 10\n    left_entrance, right_entrance = 0, 10\n\n    for event in events:\n        if event == 'L':\n            room_status[left_entrance] = 1\n            left_entrance += 1\n        elif event == 'R':\n            room_status[right_entrance] = 1\n            right_entrance -= 1\n        else:\n            room_status[int(event)] = 0\n\n    return ''.join(str(status) for status in room_status)"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    events = stdin.splitlines()[1]\n    rooms = ['0'] * 10\n\n    for i in range(n):\n        if events[i] == 'L':\n            rooms[0] = '1'\n        elif events[i] == 'R':\n            rooms[9] = '1'\n        else:\n            room_num = int(events[i])\n            rooms[room_num] = '0'\n\n    return ''.join(rooms)\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    events = list(stdin[1])\n    rooms = [0] * 10\n    \n    for event in events:\n        if event == 'L':\n            rooms[0] = 1\n            break\n    \n    for i in range(n):\n        event = events[i]\n        if event == 'L':\n            for j in range(10):\n                if rooms[j] == 0:\n                    rooms[j] = 1\n                    break\n        elif event == 'R':\n            for j in range(9, -1, -1):\n                if rooms[j] == 0:\n                    rooms[j] = 1\n                    break\n        else:\n            rooms[int(event)] = 0\n    \n    return ''.join(map(str, rooms))\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    events = stdin.split()\n    left_entrance = []\n    right_entrance = []\n    rooms = [None] * 10\n\n    for event in events:\n        if event == 'L':\n            left_entrance.append(True)\n        elif event == 'R':\n            right_entrance.append(True)\n        else:\n            room = int(event)\n            if left_entrance:\n                rooms[room] = 1\n                left_entrance.pop()\n            elif right_entrance:\n                rooms[room] = 1\n                right_entrance.pop()\n\n    return ''.join(str(int(room is not None and room == 1)) for room in rooms)\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    events = stdin.split()\n    left_entrance = 0\n    right_entrance = 10\n    room_assignment = [0] * 10\n\n    for event in events:\n        if event == 'L':\n            left_entrance += 1\n            room_assignment[left_entrance - 1] = 1\n        elif event == 'R':\n            right_entrance -= 1\n            room_assignment[right_entrance] = 1\n        else:\n            room_assignment[int(event)] = 0\n\n    return ''.join(map(str, room_assignment))\n"
    },
    {
        "number": 653,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, events = stdin.split(\"\\n\")\n    n = int(n)\n    events = list(events)\n\n    assignment_status = [0] * 10\n    current_room = 0\n    for event in events:\n        if event == \"L\":\n            assignment_status[current_room] = 1\n            current_room = (current_room - 1) % 10\n        elif event == \"R\":\n            assignment_status[current_room] = 1\n            current_room = (current_room + 1) % 10\n        else:\n            current_room = int(event)\n\n    return \"\".join(map(str, assignment_status))\n\n\ninput_stdin = \"8\\nLLRL1RL1\"\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 10**9 + 7\n    \n    def count_matchings(n: int) -> int:\n        def count_matchings_rec(i: int, j: int, open: int, close: int) -> int:\n            if i > j:\n                return 0\n            if i == j:\n                if open > 0:\n                    return 0\n                else:\n                    return 1\n            if open >= close:\n                return count_matchings_rec(i, j, open, close + 1)\n            else:\n                return count_matchings_rec(i, j, open + 1, close)\n        return count_matchings_rec(0, 2*n-1, 0, 0)\n    \n    answer = count_matchings(n)\n    return str(answer % mod)\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 10**9 + 7\n    max_matching = 1\n    for i in range(2, 2*n+1):\n        max_matching *= i\n        max_matching %= mod\n    return str(max_matching)\n\ndef"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n\n    def count_matching_edges(n):\n        dp = [1] * (2 * n + 1)\n        for i in range(2 * n):\n            for j in range(i + 1, 2 * n + 1):\n                if j - i > n:\n                    dp[j] = (dp[j] + dp[i]) % mod\n        return dp[2 * n]\n\n    return str(count_matching_edges(n))\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    def count_leafs(s: str) -> int:\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 0\n        if s[0] == '(':\n            return count_leafs(s[1:])\n        return count_leafs(s[1:]) + count_leafs(s[1:])\n\n    def correct_bracket_sequence(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def build_trie(s: str, node: dict) -> None:\n        if s:\n            c = s[0]\n            if c not in node:\n                node[c] = {}\n            build_trie(s[1:], node[c])\n        else:\n            leafs = count_leafs(s)\n            node['leafs'] = leafs\n\n    def find_max_matching(node: dict) -> int:\n        size = 0\n        for child in node.values():\n            size = (size + find_max_matching(child)) % (10**9 + 7)\n        size += node['leafs']\n        return size\n\n    root = {}\n    for i in range(n):\n        build_trie(\"()\" * i, root)\n\n    result = find_max_matching(root)\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    def count_matches(s: str) -> int:\n        if s == '()':\n            return 1\n        elif s == '(())':\n            return 2\n        elif s == '()()':\n            return 2\n        elif s[0] == '(' and s[-1] == ')':\n            return count_matches(s[1:-1])\n        else:\n            return count_matches(s[1:]) + count_matches(s[:-1])\n\n    answer = count_matches('(' * 2 * n + ')' * 2 * n) % (10**9 + 7)\n    return str(answer)\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, open_brackets, close_brackets, memo):\n        if (node, open_brackets, close_brackets) in memo:\n            return memo[(node, open_brackets, close_brackets)]\n        if open_brackets == 0 and close_brackets == 0:\n            return 1\n        if open_brackets < 0 or close_brackets < 0:\n            return 0\n        memo[(node, open_brackets, close_brackets)] = dfs(node.left, open_brackets - 1, close_brackets, memo) + dfs(node.right, open_brackets, close_brackets - 1, memo)\n        return memo[(node, open_brackets, close_brackets)]\n\n    def correct_bracket_sequence(node, open_brackets, close_brackets, length, memo):\n        if (node, open_brackets, close_brackets, length) in memo:\n            return memo[(node, open_brackets, close_brackets, length)]\n        if open_brackets == 0 and close_brackets == 0:\n            return True\n        if open_brackets < 0 or close_brackets < 0:\n            return False\n        memo[(node, open_brackets, close_brackets, length)] = (\n            correct_bracket_sequence(node.left, open_brackets - 1, close_brackets, length, memo)\n            or correct_bracket_sequence(node.right, open_brackets, close_brackets - 1, length, memo)\n            or (\n                correct_bracket_sequence(node.left, open_brackets - 1, close_brackets, length + 1, memo)\n                and correct_bracket_sequence(node.right, open_brackets, close_brackets - 1, length + 1, memo)\n            )\n        )\n        return memo[(node, open_brackets, close_brackets, length)]\n\n    n = int(stdin)\n    memo = {}\n    root = TrieNode()\n    for i in range(1, 2 * n + 1):\n        if i % 2 == 0:\n            root.insert(\"()\")\n        else:\n            root.insert(\"(\")\n\n    max_matching = dfs(root, 2 * n, 0, memo)\n    memo = {}\n    root = TrieNode()\n    for i in range(1, 2 * n + 1):\n        root.insert(\"(\")\n\n    correct_bracket_sequence(root, 2 * n, 0, 0, memo)\n    return max_matching % (10**9 + 7)\n\n\nclass TrieNode:\n    def __init__(self):\n        self.left = None\n        self.right = None\n\n    def insert(self, s: str):\n        node = self\n        for c in s:\n            if c == \"(\":\n                if not node.left:\n                    node.left = TrieNode()\n                node = node.left\n            else:\n                if not node.right:\n                    node.right = TrieNode()\n                node = node.right\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_correct_bracket_sequences(n: int) -> int:\n        def count_recursive(start: int, end: int) -> int:\n            if start > end:\n                return 1\n            if (start, end) in memo:\n                return memo[(start, end)]\n            result = 0\n            for i in range(start, end + 1):\n                result += count_recursive(start, i - 1) * count_recursive(i + 1, end)\n            memo[(start, end)] = result\n            return result\n\n        memo = {}\n        return count_recursive(0, n - 1)\n\n    n = int(stdin)\n    max_matching_size = count_correct_bracket_sequences(2 * n)\n    return str(max_matching_size % (10**9 + 7))\n\n\nn = 3\nprint(solution(str(n))) "
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n\n    def max_matching(s):\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 0\n\n        res = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                res = max(res, max_matching(s[:i] + s[i+1:]))\n\n        return (res + 1) % mod\n\n    return str((max_matching(('(' * 2 * n) + ')' * 2 * n)) % mod)\n"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_line = stdin.strip()\n    n = int(input_line)\n\n    # There are 2n nodes in the trie, each representing a string of length 2n.\n    # The root represents the empty string, and each child of a node represents\n    # a new character appended to the current string.\n    # The maximum matching size is the size of the largest set of edges\n    # such that there are no two edges with a common vertex.\n    # In the trie, each edge represents a substring of length 2n-1,\n    # and two edges share a vertex if they differ in exactly one character.\n    # Therefore, the maximum matching size is the number of edges\n    # that can be included without violating the condition.\n    # Since there are n nodes for each possible character, the number of edges\n    # is n^2.\n    # However, the number of edges is also limited by the number of nodes,\n    # since the root node can only have one child, and each child can\n    # have at most n-1 children (since the length of the string is\n    # increasing by 1 each time).\n    # Therefore, the maximum matching size is bounded by the maximum\n    # number of nodes, which is 2n (for a string of length 2n).\n    max_matching_size = 2 * n\n\n    # Modulo the result to avoid overflow.\n    result = max_matching_size % (10**9 + 7)\n\n    return str(result)"
    },
    {
        "number": 654,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ans = 1\n    for i in range(1, 2 * n + 1):\n        ans *= (2 * i + 1)\n        ans %= (10**9 + 7)\n    return str(ans)\n"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    white_king_x = 1\n    white_king_y = 1\n    black_king_x = n\n    black_king_y = n\n    \n    while white_king_x != x or white_king_y != y:\n        if white_king_x < x:\n            white_king_x += 1\n        elif white_king_x > x:\n            white_king_x -= 1\n        \n        if white_king_y < y:\n            white_king_y += 1\n        elif white_king_y > y:\n            white_king_y -= 1\n        \n        if black_king_x < x:\n            black_king_x += 1\n        elif black_king_x > x:\n            black_king_x -= 1\n        \n        if black_king_y < y:\n            black_king_y += 1\n        elif black_king_y > y:\n            black_king_y -= 1\n    \n    if white_king_x == x and white_king_y == y:\n        return \"Black\"\n    else:\n        return \"White\"\n\n\ndef"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x, y = map(int, stdin.split()[1:])\n\n    if x == 1 and y == 1:\n        return \"White\"\n    elif x == n and y == n:\n        return \"Black\"\n    else:\n        return \"Black\"\n\n\nstdin = \"\"\"4\n2 3\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x, y = map(int, stdin.splitlines()[1].split())\n\n    # Check if the white king can reach the coin before the black king\n    if x == 1 and y == 1:\n        return \"White\"\n\n    # Check if the black king can reach the coin before the white king\n    if x == n and y == n:\n        return \"Black\"\n\n    # Check if the white king can move to the cell with the coin first\n    if x + 1 <= n and y + 1 <= n:\n        if (x + 1, y + 1) == (x, y):\n            return \"White\"\n\n    # Check if the black king can move to the cell with the coin first\n    if x - 1 >= 1 and y - 1 >= 1:\n        if (x - 1, y - 1) == (x, y):\n            return \"Black\"\n\n    # Check if the white king can move to the cell with the coin first\n    if x + 1 <= n and y - 1 >= 1:\n        if (x + 1, y - 1) == (x, y):\n            return \"White\"\n\n    # Check if the black king can move to the cell with the coin first\n    if x - 1 >= 1 and y + 1 <= n:\n        if (x - 1, y + 1) == (x, y):\n            return \"Black\"\n\n    # If both kings can't reach the coin first, the white king wins\n    return \"White\""
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    coin_x, coin_y = map(int, stdin.splitlines()[1].split())\n\n    def get_possible_moves(x, y):\n        moves = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1), (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1)]\n        return [(x, y) for x, y in moves if 1 <= x <= n and 1 <= y <= n]\n\n    white_king_moves = get_possible_moves(1, 1)\n    black_king_moves = get_possible_moves(n, n)\n\n    white_first = True\n    white_king_move_count = 0\n    black_king_move_count = 0\n\n    while white_king_moves and black_king_moves:\n        if white_first:\n            move = white_king_moves.pop(0)\n            white_king_move_count += 1\n            if move == (coin_x, coin_y):\n                break\n        else:\n            move = black_king_moves.pop(0)\n            black_king_move_count += 1\n            if move == (coin_x, coin_y):\n                break\n\n        if white_first:\n            white_king_moves.extend(get_possible_moves(move[0], move[1]))\n        else:\n            black_king_moves.extend(get_possible_moves(move[0], move[1]))\n\n        white_first = not white_first\n\n    if white_king_move_count < black_king_move_count:\n        return \"White\"\n    else:\n        return \"Black\"\n"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x, y = map(int, stdin.split()[1:])\n    \n    # check if white king first\n    if n % 2 == 0:\n        # starting row for white king\n        white_start_row = n // 2\n        # ending row for white king\n        white_end_row = n // 2\n        # starting row for black king\n        black_start_row = n // 2\n        # ending row for black king\n        black_end_row = n // 2\n    else:\n        # starting row for white king\n        white_start_row = n // 2 + 1\n        # ending row for white king\n        white_end_row = n // 2 + 1\n        # starting row for black king\n        black_start_row = n // 2\n        # ending row for black king\n        black_end_row = n // 2\n\n    # white king first move\n    white_first_move = (white_start_row, white_start_row)\n    # black king first move\n    black_first_move = (black_start_row, black_start_row)\n    \n    # check if white or black king first\n    if abs(white_first_move[0] - x) + abs(white_first_move[1] - y) <= abs(black_first_move[0] - x) + abs(black_first_move[1] - y):\n        # white king first\n        move_set = get_move_set(white_start_row, black_start_row, white_end_row, black_end_row)\n        white_move = (white_first_move[0], white_first_move[1])\n        black_move = (black_first_move[0], black_first_move[1])\n        \n        # check if white or black can win with these moves\n        if is_win(move_set, white_move, black_move, x, y):\n            return \"White\"\n        else:\n            return \"Black\"\n    else:\n        # black king first\n        move_set = get_move_set(black_start_row, white_start_row, black_end_row, white_end_row)\n        white_move = (white_first_move[0], white_first_move[1])\n        black_move = (black_first_move[0], black_first_move[1])\n        \n        # check if white or black can win with these moves\n        if is_win(move_set, white_move, black_move, x, y):\n            return \"Black\"\n        else:\n            return \"White\"\n\ndef"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"White\"\n    elif x == n and y == n:\n        return \"Black\"\n    else:\n        return \"Black\"\n"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x, y = map(int, stdin.splitlines()[1].split())\n    \n    # Define initial positions of kings\n    white_king_pos = (1, 1)\n    black_king_pos = (n, n)\n    \n    # Initialize variables for the race\n    white_move_count = 0\n    black_move_count = 0\n    last_move_white = white_king_pos\n    last_move_black = black_king_pos\n    \n    # Run the race\n    while white_move_count < black_move_count:\n        # White king moves\n        white_king_pos = tuple(map(sum, zip(white_king_pos, (1, 1))))\n        if white_king_pos[0] <= n and white_king_pos[1] <= n and white_king_pos != last_move_black:\n            last_move_white = white_king_pos\n            white_move_count += 1\n        else:\n            break\n        \n        # Black king moves\n        black_king_pos = tuple(map(sum, zip(black_king_pos, (-1, -1))))\n        if black_king_pos[0] >= 1 and black_king_pos[1] >= 1 and black_king_pos != last_move_white:\n            last_move_black = black_king_pos\n            black_move_count += 1\n        else:\n            break\n    \n    # Check if the white or black king will win\n    if white_move_count > black_move_count:\n        return \"White\"\n    else:\n        return \"Black\"\n"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    x, y = map(int, input_list[1].split())\n\n    # Function to check if the king can move to a cell\n    def can_move(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= n and (r != 1 or c != 1)\n\n    # Function to calculate the number of moves the king can make from a cell\n    def available_moves(r: int, c: int) -> int:\n        moves = 0\n        for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (-1, 1), (1, -1)]:\n            if can_move(r + dr, c + dc):\n                moves += 1\n        return moves\n\n    # Find the cell where the white king can move optimally\n    white_optimal_cell = (1, 1)\n    for r in range(1, n + 1):\n        for c in range(1, n + 1):\n            if can_move(r, c) and available_moves(r, c) > available_moves(white_optimal_cell[0], white_optimal_cell[1]):\n                white_optimal_cell = (r, c)\n\n    # Check if the black king can catch the white king\n    black_can_catch_white = False\n    for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (-1, 1), (1, -1)]:\n        if can_move(x + dr, y + dc):\n            if (white_optimal_cell[0] + dr, white_optimal_cell[1] + dc) == (x + dr, y + dc):\n                black_can_catch_white = True\n                break\n\n    # Determine the winner\n    if black_can_catch_white:\n        return \"Black\"\n    else:\n        return \"White\""
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    x, y = map(int, input().split())\n    \n    if x == 1 and y == 1:\n        return \"White\"\n    elif x == n and y == n:\n        return \"Black\"\n    else:\n        while x < n and y < n:\n            if x == 1 and y == 1:\n                return \"White\"\n            elif x == n and y == n:\n                return \"Black\"\n            else:\n                x += 1\n                y += 1\n        if x == n and y == n:\n            return \"Black\"\n        else:\n            return \"White\"\n\n\ndef"
    },
    {
        "number": 655,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    \n    # Calculate the possible moves of the white king\n    moves_white_king = [(r, c) for r in range(1, n+1) for c in range(1, n+1) if abs(r-1) + abs(c-1) <= n]\n    \n    # Calculate the possible moves of the black king\n    moves_black_king = [(r, c) for r in range(n, 0, -1) for c in range(n, 0, -1) if abs(r-n) + abs(c-n) <= n]\n    \n    # Check if the white king can reach the coin\n    for move in moves_white_king:\n        if move == (x, y):\n            return \"White\"\n    \n    # Check if the black king can reach the coin\n    for move in moves_black_king:\n        if move == (x, y):\n            return \"Black\"\n    \n    # If neither king can reach the coin, the black king wins\n    return \"Black\"\n\n\ndef"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires_changes = 0\n    current_tires = \"summer\"\n\n    for _ in range(n):\n        average_temp = int(input())\n\n        if current_tires == \"summer\" and average_temp >= 0:\n            continue\n        elif current_tires == \"winter\" and average_temp <= k:\n            continue\n        else:\n            tires_changes += 1\n            current_tires = \"winter\" if current_tires == \"summer\" else \"summer\"\n\n    return str(tires_changes) if tires_changes != -1 else \"-1\"\n\n\ndef"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires = 'summer'\n    changes = 0\n    total_days = 0\n    for t in map(int, input().split()):\n        if t < 0:\n            if tires == 'summer':\n                changes += 1\n                tires = 'winter'\n            elif total_days + k > n:\n                return -1\n        elif t > 0:\n            if tires == 'winter':\n                changes += 1\n                tires = 'summer'\n            elif total_days + k > n:\n                return -1\n        total_days += 1\n    return changes"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(temps: List[int], k: int) -> bool:\n        safe_days = 0\n        for t in temps:\n            if t >= 0:\n                safe_days += 1\n            else:\n                if safe_days > k:\n                    return False\n                safe_days = 0\n        if safe_days > k:\n            return False\n        return True\n\n    n, k = map(int, stdin.split()[:2])\n    temps = list(map(int, stdin.split()[2:]))\n\n    count = 0\n    summer_to_winter = 0\n    winter_to_summer = 0\n\n    for i in range(n):\n        if temps[i] >= 0:\n            if not is_safe(temps[:i+1], k):\n                count += 1\n                summer_to_winter += 1\n                temps[i] = -1\n        elif temps[i] < 0:\n            if not is_safe(temps[:i+1], k):\n                count += 1\n                winter_to_summer += 1\n                temps[i] = 1\n\n    if not is_safe(temps, k):\n        return \"-1\"\n\n    return str(count + summer_to_winter + winter_to_summer)\n\n\ndef"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires = \"summer\"\n    count = 0\n    days_with_winter = 0\n    for i in range(n):\n        t = int(input())\n        if tires == \"summer\" and t >= 0:\n            if days_with_winter + (i - days_with_winter) > k:\n                count += 1\n                days_with_winter = 0\n            days_with_winter += 1\n        elif tires == \"winter\" and t <= 0:\n            if days_with_winter + (i - days_with_winter) > k:\n                count += 1\n                days_with_winter = 0\n            days_with_winter += 1\n        else:\n            tires = \"summer\" if t >= 0 else \"winter\"\n            count += 1\n            days_with_winter = 1 if tires == \"summer\" else 0\n    return count"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    temps = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    current_tires = \"summer\"\n    tires_changes = 0\n    days_with_summer = 0\n\n    for i in range(n):\n        # If temperature is non-negative and it's a summer day, drive safely\n        if temps[i] >= 0:\n            if current_tires == \"summer\":\n                days_with_summer += 1\n            else:\n                tires_changes += 1\n                current_tires = \"summer\"\n        # If temperature is negative and it's a winter day, drive safely\n        elif temps[i] <= 0:\n            if current_tires == \"winter\":\n                # If it's the first day, change tires\n                if i == 0:\n                    tires_changes += 1\n                    current_tires = \"winter\"\n                # If it's not the first day, check if it's possible to drive safely\n                elif days_with_summer <= k:\n                    days_with_summer += 1\n                else:\n                    tires_changes += 1\n                    days_with_summer = 0\n                    current_tires = \"winter\"\n            else:\n                tires_changes += 1\n                current_tires = \"winter\"\n        # If temperature is zero, it's a summer day regardless of the current tires\n        else:\n            days_with_summer += 1\n\n    # If it's possible to drive safely for the remaining days, return the number of tires' changes\n    # Otherwise, return -1\n    if days_with_summer <= k:\n        return str(tires_changes)\n    else:\n        return \"-1\"\n\n\ninput_data = '''4 3\n-5 20 -3 0'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires_changes = 0\n\n    winter_days = list(map(int, input().split()))\n\n    winter_tires_days = 0\n\n    for i in range(n):\n        if winter_days[i] >= 0:\n            winter_tires_days += 1\n            if winter_tires_days > k:\n                tires_changes += 1\n                winter_tires_days = 0\n\n    if winter_tires_days > 0:\n        tires_changes += 1\n\n    if tires_changes == -1:\n        return -1\n    else:\n        return tires_changes"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires_changes = 0\n    temp_sum = 0\n\n    for i in range(n):\n        temp = int(input())\n        temp_sum += temp\n\n        if temp_sum < 0:\n            tires_changes += 1\n            temp_sum = 0\n\n    if temp_sum > k:\n        tires_changes += 1\n\n    if tires_changes == 0:\n        return \"0\"\n    else:\n        return str(tires_changes)\n"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    tires = \"summer\"\n    count = 0\n    total_days = 0\n\n    for temperature in map(int, input().split()):\n        if tires == \"summer\":\n            if temperature >= 0:\n                total_days += 1\n            else:\n                count += 1\n                if total_days >= k:\n                    count += 1\n                    total_days = 0\n                tires = \"winter\"\n        else:\n            if temperature <= 0:\n                total_days += 1\n            else:\n                count += 1\n                if total_days >= k:\n                    count += 1\n                    total_days = 0\n                tires = \"summer\"\n\n    if tires == \"summer\":\n        return -1\n    else:\n        return count"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    temperatures = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    summer_tires = 0\n    winter_tires = 0\n    total_days = 0\n    changes = 0\n\n    # Iterate through temperatures and calculate total safe days\n    for temp in temperatures:\n        if total_days < k:\n            total_days += 1\n        if temp >= 0:\n            summer_tires += 1\n        else:\n            winter_tires += 1\n        if winter_tires > k:\n            changes += 1\n            winter_tires = 0\n        if summer_tires > k:\n            changes += 1\n            summer_tires = 0\n\n    if changes > 0:\n        return str(changes)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 656,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def change_tires(tires_type: str, day: int) -> str:\n        if tires_type == \"summer\":\n            return \"winter\"\n        else:\n            return \"summer\"\n\n    n, k = map(int, stdin.split()[:2])\n    tires_type = \"summer\"\n    count = 0\n    for temp in map(int, stdin.split()[2:]):\n        if tires_type == \"summer\" and temp >= 0:\n            count += 1\n        elif tires_type == \"summer\" and temp < 0:\n            count = 1\n            tires_type = change_tires(tires_type, 0)\n        elif tires_type == \"winter\" and 0 <= temp <= k:\n            count += 1\n        else:\n            tires_type = change_tires(tires_type, 0)\n            count = 1\n    return count if count <= k else -1\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, x, y, z = map(int, stdin.split())\n    total_balls = x + y + z\n    crystals_needed = 0\n    yellow_crystals_needed = 0\n    blue_crystals_needed = 0\n\n    if x > 0:\n        yellow_crystals_needed = x // 2 + x % 2\n    if y > 0:\n        blue_crystals_needed = y // 1 + y % 1\n    if z > 0:\n        blue_crystals_needed = z // 3 + z % 3\n\n    crystals_needed = yellow_crystals_needed + blue_crystals_needed\n    return crystals_needed\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    A, B = map(int, input_list[0].split())\n    x, y, z = map(int, input_list[1].split())\n    \n    yellow_crystals_needed = x - A\n    green_crystals_needed = y - A - z\n    blue_crystals_needed = z - 3 * B\n    \n    crystals_needed = max(yellow_crystals_needed, green_crystals_needed, blue_crystals_needed)\n    \n    return str(crystals_needed)\n\ndef"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, x, y, z = map(int, stdin.split())\n    crystals = [A, B]\n    balls = [x, y, z]\n    result = 0\n    \n    if balls[0] > crystals[0] // 2:\n        result += balls[0] - crystals[0] // 2\n    if balls[1] > crystals[0]:\n        result += balls[1] - crystals[0]\n    if balls[2] > crystals[1] * 3:\n        result += balls[2] - crystals[1] * 3\n    \n    return str(result)\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split()[:2])\n    x, y, z = map(int, stdin.split()[2:])\n\n    total_yellow = x + y\n    total_blue = z\n\n    additional_yellow = max(0, total_yellow - A)\n    additional_blue = max(0, total_blue - B)\n\n    yellow_needed = 2 * additional_yellow\n    blue_needed = 3 * additional_blue\n\n    return yellow_needed + blue_needed\n\n\ndef"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    A, B = map(int, input_values[0].split())\n    x, y, z = map(int, input_values[1].split())\n\n    total_yellow = x + y\n    total_blue = z\n\n    additional_yellow = 0\n    additional_blue = 0\n\n    if total_yellow > A:\n        additional_yellow = total_yellow - A\n\n    if total_blue > B:\n        additional_blue = total_blue - B\n\n    return max(additional_yellow, additional_blue)\n\n\ndef"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_balls(crystals: int, x: int, y: int, z: int) -> int:\n        yellow, blue = crystals\n        return min(yellow // (2 * x), blue // (y + z))\n\n    A, B, x, y, z = map(int, stdin.split())\n    needed = count_balls(A, x, y, z) + count_balls(B, x, y, z)\n    return str(needed)\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def balls_needed(A: int, B: int, x: int, y: int, z: int) -> int:\n        # Calculate the number of yellow, green and blue balls required\n        yellow_balls = x + A\n        green_balls = y + (x * 2)\n        blue_balls = z + (y * 3)\n\n        # Calculate the number of yellow and blue crystals needed\n        yellow_crystals = yellow_balls // 2\n        blue_crystals = blue_balls // 3\n\n        # Calculate the number of additional crystals needed\n        return max(0, yellow_crystals - A) + max(0, blue_crystals - B)\n\n    A, B = map(int, stdin.split()[:2])\n    x, y, z = map(int, stdin.split()[2:])\n\n    return str(balls_needed(A, B, x, y, z))\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, x, y, z = map(int, stdin.split())\n    crystals = {\"yellow\": A, \"blue\": B}\n    balls = {\"yellow\": x, \"green\": y, \"blue\": z}\n    additional_crystals = {\"yellow\": 0, \"blue\": 0}\n\n    for ball, required_crystals in balls.items():\n        if ball in crystals:\n            additional_crystals[ball] += required_crystals - crystals[ball]\n\n    return max(additional_crystals.values())\n"
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    crystals = input_data[0].split()\n    balls = input_data[1].split()\n\n    yellow_crystals, blue_crystals = int(crystals[0]), int(crystals[1])\n    yellow_balls, green_balls, blue_balls = int(balls[0]), int(balls[1]), int(balls[2])\n\n    crystals_needed = 0\n\n    if yellow_balls > yellow_crystals:\n        crystals_needed += (yellow_balls - yellow_crystals) * 2\n\n    if green_balls > 0:\n        crystals_needed += 1\n\n    if blue_balls > blue_crystals:\n        crystals_needed += (blue_balls - blue_crystals) // 3\n\n    return str(crystals_needed)\n\ninput_data = \"\"\"4 3\n2 1 1\"\"\".splitlines()\nprint(solution(input_data)) "
    },
    {
        "number": 657,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    A, B = map(int, input_data[0].split())\n    x, y, z = map(int, input_data[1].split())\n\n    yellow_balls = x + 2 * y\n    blue_balls = 3 * z\n\n    crystals_needed = yellow_balls - A + blue_balls - B\n\n    return str(crystals_needed)\n\n\ninput_data = \"\"\"4 3\n2 1 1\n\n3 9\n1 1 3\n\n12345678 87654321\n43043751 1000000000 53798715\"\"\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_intersection(v1, v2):\n        return v1[0] + (v2[0] - v1[0]) / (v2[1] - v1[1]) * (p[1] - v1[1])\n\n    n, w, v, u = map(int, input().split())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Find pedestrian position at t=0\n    p = (0, 0)\n    while p[1] < w:\n        p = (p[0], p[1] + u)\n\n    # Find intersection points of pedestrian with bus\n    intersections = []\n    for i in range(n):\n        if i == n - 1:\n            v1 = points[-1]\n            v2 = points[0]\n        else:\n            v1 = points[i]\n            v2 = points[i + 1]\n        intersection = find_intersection(v1, v2)\n        if 0 <= intersection[0] <= intersection[1]:\n            intersections.append(intersection)\n\n    # Sort intersection points by x coordinate\n    intersections.sort(key=lambda x: x[0])\n\n    # Find time to cross the road\n    t = 0\n    for intersection in intersections:\n        if intersection[0] < p[0] < intersection[1]:\n            t = intersection[1] / v - (p[0] - intersection[0]) / u\n            break\n    return t\n\n\ninput_str = \"\"\"5 5 1 2\n1 2\n3 1\n4 3\n3 4\n1 4\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str)"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def cross(x, y, d, p):\n        return x + (y - x) * (p - x) / (d - x)\n\n    def distance(x, y, x1, y1):\n        return ((x1 - x) ** 2 + (y1 - y) ** 2) ** 0.5\n\n    def is_inside(x, y, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xints = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xints:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def binary_search(bus_pos, bus_vertices, w, v, u, p):\n        left, right = 0, 10**9\n        while left <= right:\n            mid = (left + right) / 2\n            if is_inside(bus_pos[0], bus_pos[1] + mid * v, bus_vertices):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def solve(n, w, v, u, bus_pos, bus_vertices, p):\n        t = binary_search(bus_pos, bus_vertices, w, v, u, p)\n        return t\n\n    def main():\n        n, w, v, u = map(int, input().split())\n        bus_vertices = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            bus_vertices.append((x, y))\n        bus_pos = (0, 0)\n        p = 0\n        t = solve(n, w, v, u, bus_pos, bus_vertices, p)\n        return t\n\n    return f\"{main():.10f}\"\n"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, w, v, u = map(int, input().split())\n    bus_vertices = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        bus_vertices.append((x, y))\n\n    pedestrian_initial_pos = (0, 0)\n    pedestrian_pos = pedestrian_initial_pos\n    bus_polygon = Polygon(bus_vertices)\n    bus_motion = LineString([(0, 0), (0, w)])\n    pedestrian_crossing = LineString([pedestrian_initial_pos, (0, w)])\n    bus_pedestrian_intersection = bus_polygon.intersection(pedestrian_crossing)\n    time = 0\n\n    while pedestrian_pos[1] < w:\n        pedestrian_pos = (pedestrian_pos[0], pedestrian_pos[1] + v * time)\n        bus_pos = bus_motion.interpolate(time, normalized=True)\n        bus_new_vertices = [(bus_pos.x, bus_pos.y)] + bus_vertices\n        bus_polygon = Polygon(bus_new_vertices)\n        bus_pedestrian_intersection = bus_polygon.intersection(pedestrian_crossing)\n\n        if bus_pedestrian_intersection.is_empty or not bus_pedestrian_intersection.is_valid:\n            return time\n\n        time += u / v\n\n    return time\n"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def sign(x: int) -> int:\n        return -1 if x < 0 else 1\n\n    def is_point_inside_polygon(polygon: list, point: tuple) -> bool:\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(1, n + 1):\n            p2 = polygon[i % n]\n            if ((p1[1] > point[1]) != (p2[1] > point[1])) and (point[0] < (p2[0] - p1[0]) * (point[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]):\n                inside = not inside\n            p1 = p2\n        return inside\n\n    def find_time_to_cross(polygon: list, pedestrian_pos: tuple, v: int, u: int) -> float:\n        time = 0\n        while pedestrian_pos[1] < w:\n            pedestrian_pos = (pedestrian_pos[0], pedestrian_pos[1] + v)\n            if is_point_inside_polygon(polygon, pedestrian_pos):\n                return time\n            time += v\n        return None\n\n    n, w, v, u = map(int, stdin.split()[:4])\n    bus_polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[4:6])\n        bus_polygon.append((x, y))\n\n    pedestrian_pos = (0, 0)\n    time = find_time_to_cross(bus_polygon, pedestrian_pos, v, u)\n    if time is not None:\n        return f\"{time:.6f}\"\n    else:\n        return \"Infinity\"\n\n\ninput_str = \"\"\"5 5 1 2\n1 2\n3 1\n4 3\n3 4\n1 4\"\"\"\n\noutput_str = \"5.000000\"\n\n\nprint(solution(input_str)) "
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, w, v, u = map(int, input_data[0].split())\n    bus_points = []\n    for i in range(1, n+1):\n        x, y = map(int, input_data[i].split())\n        bus_points.append((x, y))\n\n    # Sort the bus points by their x values\n    bus_points.sort(key=lambda point: point[0])\n\n    # Find the index of the leftmost point\n    left_index = 0\n    while bus_points[left_index][0] == 0:\n        left_index += 1\n\n    # Initialize the time at which the pedestrian crosses the road\n    t = 0\n\n    # Find the time it takes for the pedestrian to cross the road\n    for i in range(left_index, n):\n        if bus_points[i][0] <= 0:\n            continue\n        t_cross = (bus_points[i][0] - u) / v\n        if t_cross > t:\n            t = t_cross\n\n    # Print the time it takes for the pedestrian to cross the road\n    return f\"{t:.6f}\"\n\n\ninput_data = \"\"\"5 5 1 2\n1 2\n3 1\n4 3\n3 4\n1 4\"\"\"\n\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cross_polygon(x, y):\n        point = Point(x, y)\n        return point.within(polygon)\n\n    def distance(x1, y1, x2, y2):\n        return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    def time_to_cross(speed):\n        return w / speed\n\n    def is_hit(x, y):\n        return cross_polygon(x, y)\n\n    n, w, v, u = map(int, input().split())\n    polygon = Polygon([(x, y) for x, y in [map(int, input().split()) for _ in range(n)]])\n    pedestrian_start = Point(0, 0)\n\n    bus_x_position = 0\n    time = 0\n    while not is_hit(bus_x_position, 0) and not is_hit(bus_x_position, w):\n        bus_x_position -= v * time\n        time += u\n\n    if is_hit(bus_x_position, 0) or is_hit(bus_x_position, w):\n        return \"Impossible\"\n\n    time_to_pedestrian_cross = time_to_cross(u)\n    time_to_bus_cross = time_to_cross(v)\n\n    time = max(time_to_pedestrian_cross, time_to_bus_cross)\n    while not is_hit(bus_x_position, 0) and not is_hit(bus_x_position, w):\n        bus_x_position -= v * time\n        time += u\n\n    return format(time, \".6f\")\n"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(point: tuple, polygon: list) -> bool:\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n + 1):\n            p2x, p2y = polygon[i % n]\n            if point[1] >= min(p1y, p2y):\n                if point[1] > max(p1y, p2y) or point[0] <= max(p1x, p2x):\n                    if p1y != p2y:\n                        intersect_x = (point[1] - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or point[0] <= intersect_x:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def min_time_to_cross(polygon: list, v: int, u: int, w: int) -> float:\n        n = len(polygon)\n        x_min = polygon[0][0]\n        x_max = polygon[0][0]\n        for i in range(n):\n            x_min = min(x_min, polygon[i][0])\n            x_max = max(x_max, polygon[i][0])\n\n        t = 0.0\n        y_max = 0\n        while x_min + t * v < 0:\n            t += 1.0\n            y_max = max(y_max, w * (1 - t * v / (2 * w)))\n\n        while is_inside((x_min + t * v, y_max), polygon):\n            t += 1.0\n            y_max = max(y_max, w * (1 - t * v / (2 * w)))\n\n        while not is_inside((x_max + t * v, y_max), polygon):\n            t += 1.0\n            y_max = max(y_max, w * (1 - t * v / (2 * w)))\n\n        return t\n\n    lines = stdin.splitlines()\n    n, w, v, u = map(int, lines[0].split())\n    polygon = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    t = min_time_to_cross(polygon, v, u, w)\n    return f\"{t:.10f}\"\n"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_time(n: int, w: int, v: int, u: int, bus_positions: List[Tuple[int, int]], pedestrian_start_pos: Tuple[int, int]) -> float:\n        def is_inside_bus(point: Tuple[int, int]) -> bool:\n            for i in range(n):\n                if bus_positions[i][0] <= point[0] < bus_positions[(i + 1) % n][0]:\n                    if point[1] < (point[0] - bus_positions[i][0]) * (bus_positions[(i + 1) % n][1] - bus_positions[i][1]) / (bus_positions[(i + 1) % n][0] - bus_positions[i][0]) + bus_positions[i][1]:\n                        return False\n            return True\n\n        def get_time_cross(point: Tuple[int, int]) -> float:\n            if point[0] == 0:\n                return float('inf')\n            return (point[0] - pedestrian_start_pos[0]) / u\n\n        def update_bus_position(time: float) -> None:\n            for i in range(n):\n                bus_positions[i] = (bus_positions[i][0] - v * time, bus_positions[i][1])\n\n        update_bus_position(0)\n        time = 0\n        while not is_inside_bus(pedestrian_start_pos):\n            if pedestrian_start_pos[0] < 0:\n                return float('-inf')\n            time = max(time, get_time_cross(pedestrian_start_pos))\n            update_bus_position(time)\n            time += u\n            pedestrian_start_pos = (pedestrian_start_pos[0] - u, pedestrian_start_pos[1])\n        return time\n\n    import sys\n    if sys.stdin.isatty():\n        input_data = \"\"\"5 5 1 2\n1 2\n3 1\n4 3\n3 4\n1 4\"\"\"\n        input_data = input_data.splitlines()\n    else:\n        input_data = sys.stdin.readlines()\n\n    n, w, v, u = map(int, input_data[0].split())\n    bus_positions = [(int(x), int(y)) for i, line in enumerate(input_data[1:]) for x, y in [line.split()]]\n    pedestrian_start_pos = (0, 0)\n\n    min_time = find_min_time(n, w, v, u, bus_positions, pedestrian_start_pos)\n    return f\"{min_time:.6f}\"\n"
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, w, v, u = map(int, input_data[0].split())\n    bus_vertices = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def is_hit_by_bus(x, y):\n        polygon = bus_vertices\n        for i in range(len(polygon)):\n            if polygon[i][1] <= y < polygon[i-1][1] or y == polygon[i-1][1]:\n                if x > polygon[i-1][0]:\n                    if x > polygon[i][0]:\n                        return True\n                elif x == polygon[i-1][0]:\n                    return True\n        return False\n\n    def bus_x_at_t(t):\n        return v * t\n\n    def pedestrian_x_at_t(t):\n        if t % 2 == 0:\n            return 0\n        else:\n            return u\n\n    def bus_y_at_t(t):\n        return w\n\n    def pedestrian_y_at_t(t):\n        return w\n\n    t = 0\n    while pedestrian_x_at_t(t) < bus_x_at_t(t):\n        t += 1\n\n    return f\"{t:.6f}\""
    },
    {
        "number": 658,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    n, w, v, u = map(int, input_values[0].split())\n    bus_vertices = []\n\n    for i in range(1, n+1):\n        x, y = map(int, input_values[i].split())\n        bus_vertices.append((x, y))\n\n    t = 0\n    crossing_time = float('inf')\n\n    while True:\n        pedestrian_pos = (0, 0)\n        bus_points = [((x+v*t) % w, y) for x, y in bus_vertices]\n        polygon = Polygon(bus_points)\n\n        if polygon.contains(Point(pedestrian_pos)):\n            crossing_time = t\n            break\n\n        if pedestrian_pos[1] >= w:\n            break\n\n        t += 1\n\n    return f\"{crossing_time:.6f}\"\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n\n    for i in range(1, n - 1):\n        if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]:\n            return f\"{i} {i + 1}\"\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            return f\"{i} {i + 1}\"\n\n    return \"-1\"\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return -1\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            continue\n\n        if i == n - 1 or arr[i] > arr[i + 1]:\n            return i, i + 1\n\n        if arr[i] < arr[i - 1] and arr[i] < arr[i + 1]:\n            return i, i + 1\n\n    return -1\n\n\ndef"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    sorted_list = [True] * n\n\n    for i in range(n):\n        if a[i] < a[i - 1]:\n            sorted_list[i] = False\n            break\n\n    for i in range(n - 1, -1, -1):\n        if a[i] > a[i + 1]:\n            sorted_list[i] = False\n            break\n\n    if sorted_list.count(True) == n:\n        return -1\n\n    for i in range(n):\n        if not sorted_list[i]:\n            for j in range(i + 2, n):\n                if sorted_list[j]:\n                    a[i], a[j] = a[j], a[i]\n                    sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n                    return f\"{i + 1} {j + 1}\"\n\n    return -1\n\n\nstdin = \"\"\"4\n1 1 1 1\"\"\"\nprint(solution(stdin))  # Output: -1\n\nstdin = \"\"\"2\n1 2\"\"\"\nprint(solution(stdin))  # Output: -1\n\nstdin = \"\"\"4\n1 2 3 4\"\"\"\nprint(solution(stdin))  # Output: 1 2\n\nstdin = \"\"\"3\n1 1 1\"\"\"\nprint(solution(stdin))  # Output: -1\n\nstdin = \"\"\"1\n1\"\"\"\nprint(solution(stdin))  # Output: -1\n\nstdin = \"\"\"5\n1 3 5 2 4\"\"\"\nprint(solution(stdin))  # Output: 3 4\n\nstdin = \"\"\"10\n5 3 2 1 4 6 8 7 9 10\"\"\"\nprint(solution(stdin))  # Output: 4 6\n\"\"\" "
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    swapped = False\n\n    for i in range(n):\n        if a[i] == i + 1:\n            continue\n        if a[a[i] - 1] == i + 1:\n            a[i], a[a[i] - 1] = a[a[i] - 1], a[i]\n            swapped = True\n            break\n\n    if not swapped:\n        return -1\n\n    return f\"{i + 1} {a[i]}\"\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    is_sorted = False\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            is_sorted = True\n            break\n        elif a[i] < a[i + 1]:\n            is_sorted = False\n            break\n\n    if not is_sorted:\n        print(\"-1\")\n    else:\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                print(i + 1, i + 2)\n                break\n            elif a[i] < a[i + 1]:\n                print(i + 1, i + 2)\n                break\n        else:\n            print(\"-1\")\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Check if the array is sorted\n    sorted_array = False\n    for i in range(1, n):\n        if a[i-1] > a[i]:\n            sorted_array = True\n            break\n            \n    if sorted_array:\n        # Check if there is a pair of positions that make the array unsorted if swapped\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                if a[i-1] < a[j-1] and a[i] > a[j]:\n                    return f\"{i} {j}\"\n        return \"-1\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    \n    for i in range(n-1):\n        if arr[i] > arr[i+1]:\n            return str(i+1) + \" \" + str(i+2)\n    \n    for i in range(n-1):\n        if arr[i] < arr[i+1]:\n            return str(i+1) + \" \" + str(i+2)\n    \n    return \"-1\"\n"
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                return f\"{i+1} {j+1}\"\n            if arr[i] < arr[j]:\n                return f\"{j+1} {i+1}\"\n\n    return \"-1\"\n\n\ninput_data = \"5\\n3 1 2 4 5\"\nprint(solution(input_data)) "
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    def is_sorted(array):\n        for i in range(1, len(array)):\n            if array[i] < array[i - 1]:\n                return False\n        return True\n\n    def find_swap_positions(array):\n        for i in range(len(array)):\n            for j in range(i + 1, len(array)):\n                if array[i] > array[j]:\n                    return (i + 1, j + 1)\n        return None\n\n    if is_sorted(a):\n        result = find_swap_positions(a)\n        if result:\n            return f\"{result[0]} {result[1]}\"\n        else:\n            return \"-1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 659,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()[1:]))\n    \n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            return f\"{i+1} {i+2}\"\n        if a[i] < a[i+1]:\n            continue\n        else:\n            return \"-1\"\n    \n    return \"-1\""
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    bottles = 0\n    towels = 0\n    for i in range(1, n+1):\n        max_power_of_2 = 2**((2*i-1).bit_length()-1)\n        bottles += max_power_of_2 * b\n        towels += max_power_of_2 * p\n    bottles += n * b\n    towels += n * p\n    return str(bottles) + \" \" + str(towels)"
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n\n    bottles = 0\n    towels = 0\n\n    while n > 1:\n        k = 1\n        while k * 2 ** k <= n:\n            k += 1\n        k -= 1\n\n        bottles += b * k * 2 + b * (n - k * 2 ** k)\n        towels += p * (k * 2 ** k + n - k * 2 ** k)\n\n        n = k * 2 ** k + n - k * 2 ** k\n\n    return str(bottles) + \" \" + str(towels)\n"
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    m = 2 ** (n.bit_length() - 1)\n    bottles_per_match = 2 * b + 1\n    bottles_needed = bottles_per_match * (m - 1) + bottles_per_match // 2\n    towels_needed = p * n\n    \n    return f\"{bottles_needed} {towels_needed}\"\n\n\ndef"
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    \n    m = 1\n    while m <= n:\n        m <<= 1\n    \n    m >>= 1\n    k = 1\n    while k <= m:\n        k <<= 1\n    \n    bottles = (b * k) + (b * (n - m)) + (b * (m - k) // 2) + b\n    towels = p * n\n    \n    return str(bottles) + \"\\n\" + str(towels)\n\n\ndef"
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    k = 2**int(math.ceil(math.log2(n)))\n    rounds = int(math.log2(k/2))\n    bottles = 0\n    towels = 0\n    for i in range(rounds):\n        bottles += b * k\n        towels += p * k\n        k //= 2\n        m = k * 2\n        bottles += b * (m - k) // 2\n        towels += p * (m - k)\n    bottles += b\n    towels += p\n    return f\"{bottles} {towels}\""
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    x, y = 0, 0\n    for i in range(1, n+1):\n        k = 2 ** (i-1).bit_length()\n        m = k\n        if m > n:\n            m = n\n        x += b * m + b  # for each match\n        y += p * m + p  # for each participant\n    return f\"{x} {y}\" "
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n\n    x, y = 0, 0\n    while n > 1:\n        m = 1 << (n.bit_length() - 1)\n        x += b * m\n        y += p * m\n        if n - m >= m // 2:\n            n = m // 2 + (n - m) // 2\n        else:\n            n = n - m\n\n    x += b\n    y += p\n\n    return f\"{x} {y}\""
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    bottles = 0\n    towels = 0\n    rounds = []\n    while n > 1:\n        m = 2**(int(math.log(n, 2)) + 1)\n        rounds.append(m)\n        bottles += 5*m\n        towels += p*m\n        n = m//2 + n - m\n    bottles += b\n    rounds.append(1)\n    towels += p\n    return f\"{bottles} {towels}\"\n\n\nn, b, p = map(int, input().split())\nprint(solution(f\"{n} {b} {p}\")) "
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    x = 0\n    y = 0\n\n    for i in range(1, n + 1):\n        k = 2 ** (i - 1)\n        if k <= m:\n            x += k * b\n            y += k * p\n        else:\n            x += b\n            y += p\n\n    return f\"{x} {y}\""
    },
    {
        "number": 660,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    m = 1 << n.bit_length()\n    bottles = b * m + n\n    towels = p * n\n    return str(bottles) + '\\n' + str(towels)\n\n\nn, b, p = map(int, input().split())\nprint(solution(str(n) + ' ' + str(b) + ' ' + str(p))) "
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if K >= 2**M:\n        return -1\n    \n    a = [0] * (2**M + 1)\n    for i in range(2**M - 1):\n        a[i] = (i >> 1) ^ K\n        a[2**M - 1 - i] = a[i]\n    \n    return ' '.join(map(str, a))"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if 0 <= M <= 17 and 0 <= K <= 10**9:\n        a = [0] * (2**(M + 1))\n        for i in range(2**M):\n            a[2*i] = i\n            a[2*i + 1] = i\n        s = \" \".join(map(str, a))\n        return s\n    else:\n        return -1\n\n\ndef"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, input().split())\n\n    if 0 <= M <= 17 and 0 <= K <= 10**9:\n        a = [0] * (2 ** (M + 1))\n        for i in range(2 ** M):\n            a[2 * i] = i\n            a[2 * i + 1] = i\n\n        if K == 0:\n            result = ' '.join(map(str, a))\n        else:\n            result = ' '.join(map(str, a[:2 ** M]))\n\n        return result\n    else:\n        return -1\n"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, input().split())\n    if K > 10**9:\n        return -1\n    if K == 0:\n        return \" \".join(str(i) for i in range(2**M))\n    a = []\n    for i in range(2**M):\n        if i % 2 == 0:\n            a.append(i)\n        else:\n            a.append(i ^ K)\n    for i in range(len(a) - 1):\n        if a[i] == a[i+1]:\n            return -1\n    return \" \".join(map(str, a))"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if not (0 <= M <= 17 and 0 <= K <= 10**9):\n        return -1\n\n    a = []\n    for i in range(2**M + 1):\n        if i < 2**M - 1:\n            a.append(i)\n            a.append(i)\n        else:\n            a.append(K)\n\n    for i in range(1, 2**M):\n        xor_value = 0\n        for j in range(i):\n            xor_value ^= a[i - j - 1] ^ a[i - j]\n        if xor_value != K:\n            return -1\n\n    return ' '.join(map(str, a))\n"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n\n    if M < 0 or M > 17 or K < 0 or K > 10**9:\n        return -1\n\n    a = [0] * (1 << (M + 1))\n    for i in range(1, 1 << M):\n        a[i] = (i << 1) ^ K\n        a[i | (1 << M)] = (i << 1) ^ K\n\n    return ' '.join(map(str, a))\n\n\ndef"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if M > 17 or K > 10**9:\n        return -1\n    a = [0]*(1<<(M+1))\n    for i in range(2**M):\n        for j in range(2**M):\n            if j == i:\n                continue\n            if (i^j) % (1<<M) == 0:\n                a[i] = 1 - a[i]\n                a[j] = 1 - a[j]\n    if all(x == 0 for x in a):\n        return -1\n    return ' '.join(map(str, a))"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n\n    if K > 2**M:\n        return -1\n\n    a = [0] * (2**M + 1)\n    for i in range(2**M):\n        a[i] = 2**(2**M - i - 1)\n\n    for i in range(1, 2**M + 1):\n        a[2**M - i] = a[i] ^ K\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    \n    if K > 10**9:\n        return -1\n    \n    a = [0] * (2**(M + 1))\n    for i in range(2**M):\n        a[i] = i\n        a[i + 2**M] = i\n    \n    for i in range(2**M - 1):\n        xor_value = a[i] ^ a[i + 1]\n        for j in range(2**M - 1):\n            if i < j:\n                a[i + 1] ^= a[j + 1]\n        a[i + 1] ^= xor_value\n    \n    for i in range(2**M):\n        a[i] ^= K\n        a[i + 2**M] ^= K\n    \n    result = [str(x) for x in a]\n    return ' '.join(result)"
    },
    {
        "number": 661,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n\n    if not (0 <= M <= 17) or not (0 <= K <= 10**9):\n        return -1\n\n    a = []\n    for i in range(2**M):\n        for j in range(i+1, 2**M):\n            xor_value = i ^ j\n            if (xor_value == K):\n                a.extend([i, j])\n                break\n        else:\n            continue\n        break\n\n    if not a:\n        return -1\n\n    return \" \".join(str(x) for x in a)"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\", 1)[0])\n    log = [int(line) for line in stdin.split(\"\\n\")[1:]]\n\n    if n % 2 == 0:\n        return \"NO\"\n\n    for i in range(n):\n        if (i + 1) % 2 == 0:\n            if log[i] == 3:\n                return \"NO\"\n        else:\n            if log[i] == 1:\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    if n % 2 == 0:\n        return \"NO\"\n    for i in range(n):\n        if a[i] == 1 and i % 2 == 0:\n            return \"NO\"\n        if a[i] == 3 and i % 2 == 1:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solution(stdin=str(n) + \"\\n\" + \" \".join(map(str, a)))) "
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    game_log = [int(input_list[i]) for i in range(1, n+1)]\n\n    if n % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nprint(solution(\"3\\n1\\n1\\n2\"))\nprint(solution(\"2\\n1\\n2\")) "
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    games = [int(line) for line in stdin.split('\\n')[1:]]\n    \n    i = 0\n    while i < n:\n        a = games[i]\n        if a == 1:\n            i += 1\n        else:\n            i += 2\n    \n    return \"YES\" if i == n else \"NO\"\n\ndef"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    game_log = input_list[1:]\n\n    alex_win = 0\n    bob_win = 0\n    carl_win = 0\n\n    for i in range(n):\n        if game_log[i] == '1':\n            alex_win += 1\n        elif game_log[i] == '2':\n            bob_win += 1\n        else:\n            carl_win += 1\n\n    if n % 2 == 0:\n        return \"NO\"\n\n    if alex_win % 2 == 0:\n        return \"NO\"\n\n    if alex_win % 2 == 1 and bob_win % 2 == 0 and carl_win % 2 == 1:\n        return \"YES\"\n\n    if alex_win % 2 == 1 and bob_win % 2 == 1 and carl_win % 2 == 1:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    games = [int(x) for x in stdin.split()[1:]]\n    \n    players = [(1, 2), (2, 3), (3, 1)]\n    current_player = 1\n    \n    for game in games:\n        winner, loser = players[game - 1]\n        if current_player == winner:\n            current_player = loser\n        elif current_player == loser:\n            return \"NO\"\n        else:\n            return \"NO\"\n    \n    return \"YES\" "
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    game_log = [int(x) for x in stdin.splitlines()[1:]]\n\n    spectators = [1, 2]\n    spectating_player = 1\n\n    for i in range(n):\n        if game_log[i] == spectating_player:\n            return \"NO\"\n        else:\n            spectators.remove(game_log[i])\n            spectating_player = spectators[0]\n\n    return \"YES\"\n"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1:]))\n\n    for i in range(n):\n        if a[i] == 1:\n            a[i] = 3\n        elif a[i] == 2:\n            a[i] = 1\n        else:\n            a[i] = 2\n\n    for i in range(n):\n        if a[i] == 1:\n            a[i] = 3\n        elif a[i] == 2:\n            a[i] = 1\n        else:\n            a[i] = 2\n\n    if a == [1, 3, 2]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    game_log = [int(i) for i in input_list[1:]]\n    possible_situation = [1, 2, 3]\n    for i in range(n):\n        if game_log[i] in possible_situation:\n            possible_situation.remove(game_log[i])\n            if len(possible_situation) == 0:\n                return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 662,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    log = [int(line) for line in stdin.split(\"\\n\")[1:]]\n\n    alex_score = 0\n    bob_score = 0\n    carl_score = 0\n\n    for i in range(n):\n        if log[i] == 1:\n            alex_score += 1\n        elif log[i] == 2:\n            bob_score += 1\n        else:\n            carl_score += 1\n\n    if alex_score == bob_score and alex_score + 1 == carl_score:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    r, x, y, x1, y1 = input_data[:5]\n    dx = x1 - x\n    dy = y1 - y\n    dist = math.sqrt(dx ** 2 + dy ** 2)\n    angle = math.acos(dy / dist)\n    n = math.ceil(2 * math.pi * r / dist)\n    steps = n * angle / (2 * math.pi)\n    return str(max(steps, 1))\n"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    r, x, y, x_prime, y_prime = input_values[0], input_values[1], input_values[2], input_values[3], input_values[4]\n    \n    # Calculate the distance between the current and destination centers\n    distance = ((x - x_prime) ** 2 + (y - y_prime) ** 2) ** 0.5\n    \n    # Check if the destination center is inside the circle\n    if distance <= r:\n        return \"0\"\n    \n    # Calculate the angle between the current center and the pin\n    angle = math.atan2(y_prime - y, x_prime - x)\n    \n    # Calculate the number of steps required to move the center to the destination point\n    steps = math.ceil(math.degrees(angle) / 180)\n    \n    return str(steps)"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    r, x, y, x_new, y_new = input_data\n    \n    # Case 1: New point is on the old center\n    if x_new == x and y_new == y:\n        return \"0\"\n    \n    # Case 2: New point is on the circle\n    if (x_new - x) ** 2 + (y_new - y) ** 2 <= r ** 2:\n        return \"0\"\n    \n    # Case 3: New point is outside the circle\n    else:\n        # Compute the distance from the center to the new point\n        distance = ((x_new - x) ** 2 + (y_new - y) ** 2) ** 0.5\n        \n        # Compute the angle between the center and the new point\n        theta = np.arctan2(y_new - y, x_new - x)\n        \n        # Compute the angle between the x-axis and the tangent line to the circle at the new point\n        alpha = np.arccos((distance ** 2 + r ** 2 - x_new ** 2 - y_new ** 2) / (2 * r * distance))\n        \n        # Compute the angle between the center and the tangent line to the circle at the new point\n        beta = np.arcsin((y_new - y) / distance)\n        \n        # Compute the angle between the old center and the new center\n        gamma = np.pi - alpha - beta\n        \n        # Compute the angle between the pin and the new point\n        pin_angle = np.arccos((x_new - x) / distance)\n        \n        # Case 3.1: New point is in the first quadrant\n        if x_new > x and y_new > y:\n            # Compute the angle between the pin and the old center\n            pin_theta = np.pi / 2 + pin_angle\n            \n            # Compute the angle between the new center and the old center\n            center_theta = np.pi / 2 - alpha\n        \n        # Case 3.2: New point is in the second quadrant\n        elif x_new < x and y_new > y:\n            # Compute the angle between the pin and the old center\n            pin_theta = 3 * np.pi / 2 + pin_angle\n            \n            # Compute the angle between the new center and the old center\n            center_theta = 3 * np.pi / 2 - alpha\n        \n        # Case 3.3: New point is in the third quadrant\n        elif x_new < x and y_new < y:\n            # Compute the angle between the pin and the old center\n            pin_theta = np.pi + pin_angle\n            \n            # Compute the angle between the new center and the old center\n            center_theta = np.pi - alpha\n        \n        # Case 3.4: New point is in the fourth quadrant\n        elif x_new > x and y_new < y:\n            # Compute the angle between the pin and the old center\n            pin_theta = 7 * np.pi / 4 + pin_angle\n            \n            # Compute the angle between the new center and the old center\n            center_theta = 7 * np.pi / 4 - alpha\n        \n        # Compute the minimum number of steps\n        steps = int(np.ceil(np.abs(center_theta) / gamma))\n        \n        # Check if the pin needs to be rotated clockwise or counter-clockwise\n        if center_theta < 0:\n            steps *= -1\n        \n        # Return the result\n        return str(steps) "
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_prime, y_prime = map(int, stdin.split())\n\n    # Calculate distance from center to destination\n    distance = ((x_prime - x) ** 2 + (y_prime - y) ** 2) ** 0.5\n\n    # Calculate the angle between the vector from center to pin and vector from pin to destination\n    angle = np.arctan2(y_prime - y, x_prime - x) - np.arctan2(y - r, x - r)\n\n    # Calculate the number of steps required to rotate the circle\n    steps = int(np.ceil(np.abs(angle) / (2 * np.pi) * 360))\n\n    # Check if the circle can be rotated in one step\n    if np.abs(angle) <= (2 * np.pi) / 360:\n        steps = 1\n\n    return str(steps)\n\n\nimport numpy as np\nimport math\n"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_prime, y_prime = map(int, stdin.split())\n    r_prime = ((x_prime - x) ** 2 + (y_prime - y) ** 2) ** 0.5\n\n    if r == r_prime:\n        return '0'\n\n    step = 1\n    angle = 0\n\n    while r_prime != r:\n        angle += 1 if r_prime < r else -1\n        r_prime = round((x_prime - x) ** 2 + (y_prime - y) ** 2) ** 0.5\n        step += 1\n\n    return str(step)\n\n\ninput_cases = [\n    \"2 0 0 0 4\",\n    \"1 1 1 4 4\",\n    \"4 5 6 5 6\"\n]\n\nfor case in input_cases:\n    print(solution(case)) "
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, xp, yp = map(int, stdin.split())\n    dx, dy = xp - x, yp - y\n    dist = (dx ** 2 + dy ** 2) ** 0.5\n    if dist == 0:\n        return 0\n    if dist < r:\n        return 0\n    angle = math.atan2(dy, dx)\n    steps = int(math.ceil(math.acos(r / dist) / (2 * math.pi) * 360))\n    if steps % 2 == 0:\n        steps += 1\n    return steps\n\ndef"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_prime, y_prime = map(int, stdin.split())\n    center = (x, y)\n    dest = (x_prime, y_prime)\n    dist_sq = (x_prime - x) ** 2 + (y_prime - y) ** 2\n    if dist_sq == 0:\n        return 0\n    radius_sq = r ** 2\n    if dist_sq < radius_sq:\n        return 0\n    if dist_sq == radius_sq:\n        return 1\n    pin_x, pin_y = r, 0\n    angle = 0\n    while dist_sq > radius_sq:\n        angle += 1\n        angle_rad = angle * math.pi / 180\n        px_new = pin_x + r * math.cos(angle_rad)\n        py_new = pin_y + r * math.sin(angle_rad)\n        dist_sq = (px_new - center[0]) ** 2 + (py_new - center[1]) ** 2\n    return 1 + 2 * angle\n\n\ndef"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    r = int(input_list[0])\n    x, y, x_new, y_new = map(int, input_list[1:])\n    \n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n    \n    if x == x_new and y == y_new:\n        return \"0\"\n    elif distance(x, y, x_new, y_new) < r:\n        return \"1\"\n    else:\n        angle = 2 * math.asin(r / distance(x, y, x_new, y_new))\n        return round(angle / math.pi * 180)\n"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, xp, yp = map(int, stdin.split())\n\n    # Calculate the distance between the two centers\n    dist = ((x - xp) ** 2 + (y - yp) ** 2) ** 0.5\n\n    # If the distance is zero, the centers are already at the same position, return 0\n    if dist == 0:\n        return 0\n\n    # Calculate the angle between the two centers\n    angle = math.acos((2 * r ** 2 - dist ** 2) / (2 * r ** 2))\n\n    # Calculate the number of steps required\n    steps = int(math.ceil(angle / (2 * math.pi)))\n\n    return steps"
    },
    {
        "number": 663,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, xp, yp = map(int, stdin.split())\n    dist = ((x - xp) ** 2 + (y - yp) ** 2) ** 0.5\n    angle = math.asin(y - yp / dist)\n    angle = math.degrees(angle)\n    steps = 0\n    if angle <= 90:\n        steps = 1\n    elif angle <= 180:\n        steps = 2\n    elif angle <= 270:\n        steps = 3\n    else:\n        steps = 4\n    return steps\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return 0\n    elif n == 2:\n        if a[0] > a[1]:\n            return -1\n        else:\n            return 1\n    else:\n        count = 0\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                a[0], a[i + 1] = a[i + 1], a[0]\n                count += 1\n            else:\n                continue\n        if count == 0:\n            return 0\n        elif count == 1:\n            return 1\n        else:\n            return -1\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def min_ops(n: int, a: list) -> int:\n        if a[0] > a[1]:\n            return 0\n        if a[n-1] < a[n-2]:\n            return -1\n        i, j = 0, n-1\n        ops = 0\n        while i < j:\n            if a[i] <= a[j]:\n                if j == n-1:\n                    return -1\n                i += 1\n                j -= 1\n            else:\n                ops += 1\n                a[i], a[j] = a[j], a[i]\n                if a[i] < a[i-1]:\n                    return -1\n        return ops\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    if n <= 1:\n        return 0\n    return min_ops(n, a)\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(n - 1):\n        if numbers[i] > numbers[i + 1]:\n            if numbers[i] != numbers[i + 1]:\n                return -1\n            else:\n                break\n    else:\n        return 0\n\n    operations = 0\n    i = n - 2\n    while i >= 0:\n        if numbers[i] > numbers[i + 1]:\n            numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]\n            operations += 1\n        i -= 1\n\n    return operations\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    if n == 1:\n        return 0\n    a = list(map(int, input().split()))\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            count = 0\n            for j in range(i, -1, -1):\n                if a[j] > a[j + 1]:\n                    a[j], a[j + 1] = a[j + 1], a[j]\n                    count += 1\n                else:\n                    break\n            for j in range(i + 1, n):\n                if a[j] < a[j - 1]:\n                    a[j], a[j - 1] = a[j - 1], a[j]\n                    count += 1\n                else:\n                    break\n            return count\n    return 0\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    if n <= 1:\n        return 0\n    for i in range(1, n):\n        if a[i] <= a[i - 1]:\n            return -1\n    count = 0\n    while True:\n        if a[-1] < a[0]:\n            break\n        a[0], a[-1] = a[-1], a[0]\n        a.pop()\n        count += 1\n    return count\n\n\ninput_string = \"\"\"2\n2 1\n3\n1 3 2\n2\n1 2\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if n < 2:\n        return 0\n\n    for i in range(n):\n        if a[i] > a[i + 1]:\n            return -1\n\n    count = 0\n    while not is_sorted(a):\n        count += 1\n        a.insert(0, a.pop())\n\n    return count\n\n\ndef"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    a = input_list[1:]\n\n    if n == 2 and a[0] > a[1]:\n        return \"1\"\n    elif n == 1:\n        return \"0\"\n    else:\n        return -1"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    if n < 2:\n        return \"0\"\n    elif n == 2:\n        if a[0] > a[1]:\n            return \"-1\"\n        else:\n            return \"1\"\n    else:\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                return i + 1\n        return \"0\""
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if n == 2 and a[0] > a[1]:\n        return \"0\"\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            return -1\n\n    return 0\n"
    },
    {
        "number": 664,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n <= 1:\n        return 0\n\n    min_ops = 0\n    for i in range(n):\n        if a[i] > a[i - 1]:\n            continue\n        else:\n            min_ops += a[i - 1] - a[i]\n            a[i:n] = a[i:n][::-1]\n            a[:i] = a[:i][::-1]\n            break\n    else:\n        return -1\n\n    for i in range(n - 1):\n        if a[i] <= a[i + 1]:\n            continue\n        else:\n            min_ops += a[i + 1] - a[i]\n            a[i:n] = a[i:n][::-1]\n            a[:i] = a[:i][::-1]\n            break\n    else:\n        return -1\n\n    return min_ops\n\n\ndef"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_gifts(skip_list: list) -> int:\n        total_gifts = 0\n        for i in range(n):\n            if i not in skip_list:\n                total_gifts += a[i]\n        return total_gifts\n\n    t = int(input())\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n\n        skip_list = []\n        total_time = 0\n        for i in range(n):\n            if total_time + a[i] <= s:\n                total_time += a[i]\n            else:\n                skip_list.append(i)\n        if skip_list:\n            output.append(skip_list[0])\n        else:\n            output.append(0)\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def process_test_case(n: int, s: int, a: List[int]) -> int:\n        total_time = sum(a)\n        if total_time > s:\n            return 0\n        else:\n            time_used = 0\n            skipped_parts = 0\n            for i in range(n):\n                if time_used + a[i] <= s:\n                    time_used += a[i]\n                else:\n                    skipped_parts += 1\n                    time_used = 0\n            return skipped_parts\n\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        output.append(process_test_case(n, s, a))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def recite_verse(a, s):\n        total_time = sum(a)\n        if total_time > s:\n            return \"Not enough time\"\n\n        skip = 0\n        current_time = 0\n        for i, part_time in enumerate(a):\n            if current_time + part_time > s:\n                skip = i\n                break\n            current_time += part_time\n\n        return skip\n\n    t = int(input())\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        output.append(recite_verse(a, s))\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for i in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        max_gifts = 0\n        max_part = 0\n        total_time = 0\n\n        for part in range(n):\n            total_time += a[part]\n            if total_time <= s:\n                max_gifts += 1\n            else:\n                break\n\n        if max_gifts < n:\n            print(part)\n        else:\n            print(0)\n\ninput_string = \"\"\"3\n7 11\n2 9 1 3 18 1 4\n4 35\n11 9 10 7\n1 8\n5\n\"\"\"\nsolution(input_string) "
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def recite_verse(a: list, s: int) -> int:\n        total_time = sum(a)\n        if total_time <= s:\n            return len(a)\n        time_spent = 0\n        skipped = 0\n        for i in range(len(a)):\n            time_spent += a[i]\n            if time_spent > s:\n                skipped = i\n                break\n        return len(a) - skipped - 1\n\n    t = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, t+1):\n        n, s = map(int, stdin.splitlines()[i].split())\n        a = list(map(int, stdin.splitlines()[i+1].split()))\n        output.append(recite_verse(a, s))\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n\n        skipped = 0\n        total_time = 0\n        for i in range(n):\n            total_time += a[i]\n            if total_time <= s:\n                skipped = i + 1\n            else:\n                break\n\n        print(skipped)\n"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def process_test_case(a, s, n):\n        if s < sum(a):\n            return 0\n        else:\n            a_sum = sum(a)\n            for i in range(1, n):\n                if a_sum - a[i] <= s:\n                    return i\n            return n\n\n    t = int(input())\n    output = []\n    for i in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        output.append(process_test_case(a, s, n))\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_maximum_gifts(a: List[int], s: int) -> int:\n        gift_count = 0\n        for i in range(len(a)):\n            if a[i] <= s:\n                s -= a[i]\n                gift_count += 1\n            else:\n                break\n        return gift_count\n\n    def find_part_to_skip(a: List[int]) -> int:\n        max_gifts = 0\n        part_to_skip = 0\n        for i in range(len(a)):\n            gift_count = get_maximum_gifts(a, s)\n            if gift_count > max_gifts:\n                max_gifts = gift_count\n                part_to_skip = i + 1\n        return part_to_skip\n\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        if s >= sum(a):\n            output.append(0)\n        else:\n            output.append(find_part_to_skip(a))\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        skipped_part = 0\n        total_time = 0\n        for i in range(n):\n            total_time += a[i]\n            if total_time > s:\n                skipped_part = i + 1\n                break\n        output.append(skipped_part)\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 665,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n, s = map(int, input().split())\n        a = list(map(int, input().split()))\n        skip = 0\n        max_gifts = 0\n        for i in range(n):\n            if i == 0:\n                curr_gifts = s // a[0]\n            else:\n                curr_gifts = (s - a[i - 1] * skip) // a[i]\n            if curr_gifts > max_gifts:\n                max_gifts = curr_gifts\n            elif curr_gifts == max_gifts:\n                skip += 1\n        output.append(skip)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    count = 1\n    current_num = 1\n    while count < n:\n        current_num += 1\n        for i in range(2, current_num + 1):\n            count += 1\n            if count == n:\n                return str(i)\n    return \"\"\n"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = [1]\n    i, count = 0, 1\n\n    while len(sequence) < n:\n        i += 1\n        for j in range(i):\n            count += 1\n            if count > n:\n                break\n            sequence.append(j + 1)\n\n    return str(sequence[n - 1])\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 1\n    sequence = [1]\n\n    while count < n:\n        current_count = count + 1\n        current_sequence = []\n\n        for i in range(1, current_count + 1):\n            for j in range(1, i + 1):\n                current_sequence.append(j)\n\n        count += current_count\n        sequence.extend(current_sequence)\n\n    return str(sequence[n - 1])"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 1\n    result = 1\n    while count < n:\n        count += result\n        result += 1\n    return result"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = [1]\n    current_number = 1\n    current_position = 1\n\n    while current_position < n:\n        current_number += 1\n        current_position += current_number\n        sequence.append(current_number)\n\n    return str(sequence[n-1])\n"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    number = 1\n    count = 1\n    position = 1\n    while position < n:\n        if count < n - position + 1:\n            count += 1\n        else:\n            position += count\n            count = 1\n            number += 1\n    return str(number)\n\n\ninput_str = \"5\"  # Replace this with the input given in the problem statement\nprint(solution(input_str)) "
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    num = 1\n    i = 1\n    while i < n:\n        num += 1\n        i += num\n    return num"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    else:\n        sequence = [1]\n        i = 1\n        while len(sequence) < n:\n            sequence.extend([i] * (i + 1))\n            i += 1\n        return str(sequence[n - 1])\n\n\ndef"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = [1]\n    i = 1\n    while len(sequence) < n:\n        sequence += list(range(i, i+1))\n        i += 1\n    return str(sequence[n-1])"
    },
    {
        "number": 666,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return '1'\n    count = 1\n    i = 1\n    while count < n:\n        i += 1\n        count += i\n    return str(i)\n\ninput_str = input()\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        prev = [-1] * n\n        queue = [(0, start)]\n\n        while queue:\n            d, u = queue.pop(0)\n\n            if d > dist[u]:\n                continue\n\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    prev[v] = u\n                    queue.append((dist[v], v))\n                    queue.sort(key=lambda x: x[0])\n\n        return dist, prev\n\n    N = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(N)]\n\n    for i in range(N):\n        line = stdin.splitlines()[i + 1].split()\n        for j, value in enumerate(line):\n            if i != j:\n                graph[i].append((j, int(value)))\n                graph[j].append((i, int(value)))\n\n    _, prev = dijkstra(graph, 0)\n    max_length = 0\n\n    for u in range(N):\n        dist, _ = dijkstra(graph, u)\n        max_length = max(max_length, dist[N - 1])\n\n    return max_length\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        visited = [False] * len(graph)\n        while not all(visited):\n            min_dist = float('inf')\n            min_index = None\n            for i in range(len(graph)):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_index = i\n            visited[min_index] = True\n            for i in range(len(graph)):\n                if not visited[i] and graph[min_index][i] and dist[min_index] + graph[min_index][i] < dist[i]:\n                    dist[i] = dist[min_index] + graph[min_index][i]\n            if min_index == end:\n                return dist[min_index]\n        return dist[end]\n\n    N, *graph = stdin.split('\\n')\n    graph = [[0 if a == '0' else int(a) for a in line.split()] for line in graph]\n    for i in range(len(graph)):\n        graph[i].append(0)\n        graph[i][i] = 0\n    max_dist = float('-inf')\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            if i != j:\n                dist = dijkstra(graph, i, j)\n                max_dist = max(max_dist, dist)\n    return max_dist\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    graph = []\n    for i in range(1, N+1):\n        row = list(map(int, stdin.splitlines()[i].split()))\n        graph.append(row)\n    \n    shortest_path_lengths = []\n    for i in range(N):\n        for j in range(i+1, N):\n            length = float('inf')\n            for k in range(N):\n                if i != k and j != k:\n                    temp_length = graph[i][k] + graph[k][j]\n                    if temp_length < length:\n                        length = temp_length\n            shortest_path_lengths.append(length)\n    \n    return max(shortest_path_lengths)\n\ninput_str = \"3\\n0 1 1\\n1 0 4\\n1 4 0\"\nprint(solution(input_str))\n\ninput_str = \"4\\n0 1 2 3\\n1 0 4 5\\n2 4 0 6\\n3 5 6 0\"\nprint(solution(input_str)) "
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def bellman_ford(graph: list, start: int, end: int, n: int) -> int:\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        for u in range(n):\n            for v, w in graph[u]:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    return -1\n        return dist[end]\n\n    N = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(N)]\n    for i in range(1, N + 1):\n        line = stdin.splitlines()[i].split()\n        for j in range(N):\n            if i == j + 1:\n                continue\n            graph[i - 1].append((j, int(line[j])))\n            graph[j].append((i - 1, int(line[j])))\n\n    max_length = 0\n    for i in range(N):\n        max_length = max(max_length, bellman_ford(graph, i, i, N))\n    return max_length\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path(graph: list, start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set([start])\n        while queue:\n            (vertex, distance) = queue.pop(0)\n            if vertex == end:\n                return distance\n            for neighbor, weight in graph[vertex].items():\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, distance + weight))\n        return -1  # No path found\n\n    N = int(stdin.splitlines()[0])\n    graph = [{} for _ in range(N)]\n    for i, line in enumerate(stdin.splitlines()[1:]):\n        row = [int(x) for x in line.split()]\n        for j, weight in enumerate(row):\n            if weight > 0:\n                graph[i][j] = weight\n                graph[j][i] = weight\n\n    max_length = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            length = shortest_path(graph, i, j)\n            if length > max_length:\n                max_length = length\n\n    return max_length\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    graph = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    shortest_paths = [[float(\"inf\")] * N for _ in range(N)]\n\n    for i in range(N):\n        shortest_paths[i][i] = 0\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if shortest_paths[i][k] + graph[k][j] < shortest_paths[i][j]:\n                    shortest_paths[i][j] = shortest_paths[i][k] + graph[k][j]\n\n    return max(max(shortest_paths[i]))\n\n\ninput_str = \"\"\"3\n0 1 1\n1 0 4\n1 4 0\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str)  # Output: 2\n\ninput_str = \"\"\"4\n0 1 2 3\n1 0 4 5\n2 4 0 6\n3 5 6 0\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str)  # Output: 5 "
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    graph = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    max_length = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            min_length = float('inf')\n            for k in range(N):\n                if k != i and k != j:\n                    length = graph[i][k] + graph[k][j]\n                    if length < min_length:\n                        min_length = length\n            if min_length > max_length:\n                max_length = min_length\n    \n    return max_length\n\n\ninput_str = '''3\n0 1 1\n1 0 4\n1 4 0'''\n\nprint(solution(input_str))  # Output: 2\n\ninput_str = '''4\n0 1 2 3\n1 0 4 5\n2 4 0 6\n3 5 6 0'''\n\nprint(solution(input_str))  # Output: 5 "
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        while True:\n            u = min(range(n), key=lambda x: dist[x] if not visited[x] else float('inf'))\n            if dist[u] == float('inf'):\n                break\n            visited[u] = True\n            for v in range(n):\n                if not visited[v] and graph[u][v] != float('inf'):\n                    new_dist = dist[u] + graph[u][v]\n                    if new_dist < dist[v]:\n                        dist[v] = new_dist\n        return dist\n\n    def longest_shortest_path(graph):\n        n = len(graph)\n        longest = 0\n        for i in range(n):\n            dist = dijkstra(graph, i)\n            for d in dist:\n                longest = max(longest, d)\n        return longest\n\n    N = int(stdin[0])\n    graph = [list(map(int, stdin[i + 1].split())) for i in range(N)]\n    result = longest_shortest_path(graph)\n    return str(result)\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappush, heappop, heappushpop\n\n    def dijkstra(graph, start):\n        pq = [(0, start)]\n        visited = set()\n        while pq:\n            dist, node = heappop(pq)\n            if node not in visited:\n                visited.add(node)\n                yield node, dist\n                for neighbor, weight in graph[node].items():\n                    if neighbor not in visited:\n                        heappush(pq, (dist + weight, neighbor))\n\n    def shortest_path(graph, start, end):\n        return next((dist for node, dist in dijkstra(graph, start) if node == end), float('inf'))\n\n    N = int(stdin.split('\\n', 1)[0])\n    graph = defaultdict(dict)\n    for i, row in enumerate(stdin.split('\\n')[1:]):\n        for j, weight in enumerate(map(int, row.split())):\n            if i != j:\n                graph[i][j] = weight\n                graph[j][i] = weight\n\n    max_length = float('-inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            length = shortest_path(graph, i, j)\n            max_length = max(max_length, length)\n\n    return max_length\n"
    },
    {
        "number": 667,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int) -> list:\n        N = len(graph)\n        dist = [float(\"inf\")] * N\n        dist[start] = 0\n        visited = [False] * N\n        while True:\n            min_node = -1\n            min_dist = float(\"inf\")\n            for i in range(N):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            if min_node == -1:\n                break\n            visited[min_node] = True\n            for i in range(N):\n                if not visited[i] and graph[min_node][i] + dist[min_node] < dist[i]:\n                    dist[i] = graph[min_node][i] + dist[min_node]\n        return dist\n\n    N = int(stdin.splitlines()[0])\n    graph = [list(map(int, stdin.splitlines()[i + 1].split())) for i in range(N)]\n\n    max_shortest_path_length = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            dijkstra_distances = dijkstra(graph, i)\n            shortest_path_length = dijkstra_distances[j]\n            max_shortest_path_length = max(max_shortest_path_length, shortest_path_length)\n\n    return max_shortest_path_length\n\n\ndef"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n\n    if n == 1:\n        return -1\n\n    a = [0] + a  # add Polycarp's messages count\n    max_messages = sum(a)\n\n    if max_messages > n * n:\n        return -1\n\n    messages = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if j != i and a[i] > 0:\n                messages.append((i, j))\n                a[i] -= 1\n                break\n\n    return max_messages, messages\n\n\ninput_str = '''4\n1 2 1 0'''\n\nmax_messages, messages = solution(input_str)"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] + list(a)  # Add Polycarp to the list of students\n\n    # Check if it's possible to inform all students about the credit\n    if any(ai == 0 for ai in a):\n        return \"-1\\n\"\n\n    # Calculate the total number of messages\n    k = sum(a)\n\n    # Create the graph of students and messages\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if a[i] > 0 and a[j] > 0:\n                graph[i].append(j)\n                graph[j].append(i)\n                a[i] -= 1\n                a[j] -= 1\n\n    # Find the minimum number of messages\n    queue = [(1, -1, 0)]  # (student, previous, distance)\n    visited = set()\n    min_distance = float('inf')\n\n    while queue:\n        current, prev, distance = queue.pop(0)\n        visited.add((current, prev))\n\n        if current == n:\n            min_distance = min(min_distance, distance)\n            continue\n\n        for neighbor in graph[current]:\n            if (neighbor, current) not in visited:\n                queue.append((neighbor, current, distance + 1))\n\n    if min_distance == float('inf'):\n        return \"-1\\n\"\n\n    # Print the messages\n    messages = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if graph[i] and j in graph[i]:\n                messages.append((i, j))\n\n    return f\"{k}\\n\" + \"\\n\".join(f\"{f} {t}\" for f, t in messages)\n"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    a.insert(0, 0)\n    res = []\n\n    def dfs(cur_student, depth, visited):\n        if cur_student == 1:\n            visited.add(cur_student)\n            res.append((cur_student, 1))\n            return\n\n        if depth >= a[cur_student] or cur_student in visited:\n            return\n\n        visited.add(cur_student)\n        res.append((1, cur_student))\n\n        for i in range(2, n + 1):\n            if i != cur_student and i not in visited:\n                dfs(i, depth + 1, visited.copy())\n\n    dfs(1, 1, set())\n\n    if not res:\n        return -1\n    return len(res), *(f\"{x[0]} {x[1]}\" for x in res)\n\n\ndef"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(enumerate(a, 2))\n    a.sort(key=lambda x: x[1], reverse=True)\n    \n    if n == 1:\n        return -1\n    \n    messages = 0\n    for i, ai in a:\n        for j in range(2, i + 1):\n            if a[j - 1][1] >= a[i - 1][1]:\n                messages += 1\n                break\n    \n    if messages == 0:\n        return -1\n    \n    result = []\n    for i, ai in a:\n        for j in range(2, i + 1):\n            if a[j - 1][1] >= a[i - 1][1]:\n                result.append((j, i))\n                a[j - 1][1] = a[i - 1][1] - 1\n                break\n    \n    return messages, result\n"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    \n    if n == 2:\n        if a[0] == 0 or a[1] == 0:\n            return -1\n        return 2, 1, 2, 1\n    \n    a = [0] + a\n    total_messages = sum(a)\n    \n    if total_messages > (n * (n - 1)) // 2:\n        return -1\n    \n    messages = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if a[i] > 0 and a[j] > 0:\n                messages.append((i, j))\n                a[i] -= 1\n                a[j] -= 1\n    \n    if len(messages) < total_messages:\n        return -1\n    \n    messages.sort()\n    return total_messages, *(message for message in messages)\n\n\ndef"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, input().split())\n    k = 0\n    messages = []\n    for i in range(1, n):\n        if a[i] > 0:\n            k += a[i]\n            messages.append((1, i+1))\n            messages.append((i+1, n))\n            a[i] -= 1\n            a[n] -= 1\n    if k > 0:\n        return \"\\n\".join(str(m) for m in messages)\n    else:\n        return -1\n"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    max_messages = sum(a)\n\n    if max_messages < n:\n        return -1\n\n    messages = []\n    visited = [False] * (n + 1)\n\n    def dfs(start: int, end: int):\n        if visited[end]:\n            return\n        visited[end] = True\n        messages.append((start, end))\n        dfs(end, a[end - 1])\n\n    dfs(1, 2)\n    for i in range(2, n + 1):\n        dfs(i, a[i - 1])\n\n    for i in range(2, n + 1):\n        if not visited[i]:\n            return -1\n\n    return len(messages), messages\n\n\nstdin = \"\"\"\n4\n1 2 1 0\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(enumerate(a, 2))\n\n    if any(ai <= 0 for _, ai in a):\n        return '-1\\n'\n\n    def is_possible(i: int, j: int) -> bool:\n        if j == 1:\n            return False\n        return sum(1 for _, ai in a if ai - (i != j)) <= a[j - 1][1]\n\n    visited = [False] * (n + 1)\n    messages = []\n    queue = [(1, j) for j in range(2, n + 1)]\n\n    while queue:\n        i, j = queue.pop(0)\n        if not is_possible(i, j) or visited[j]:\n            continue\n\n        visited[j] = True\n        messages.append((i, j))\n        queue.extend([(j, k) for k in range(2, n + 1) if k != i and not visited[k] and is_possible(j, k)])\n\n    if not all(visited):\n        return '-1\\n'\n\n    messages.sort(key=lambda x: x[1])\n    messages = [f'{x[0]} {x[1]}' for x in messages]\n    return f'{len(messages)}\\n{\" \".join(messages)}\\n'"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n == 1:\n        if a[0] == 0:\n            return -1\n        else:\n            return 1, 1, 1\n    else:\n        total_messages = sum(a)\n        if total_messages > n:\n            return -1\n        else:\n            messages = 0\n            student_messages = []\n            for i in range(1, n+1):\n                for j in range(i+1, n+1):\n                    if messages < total_messages and a[i-1] > 0 and a[j-1] > 0:\n                        student_messages.append((i, j))\n                        messages += 1\n            return messages, *student_messages\n"
    },
    {
        "number": 668,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        return -1\n\n    messages_to_send = 0\n    messages_sent = {}\n    for i in range(1, n + 1):\n        if messages_sent.get(i, 0) >= a[i]:\n            continue\n\n        if not messages_sent:\n            messages_to_send += 1\n            messages_sent[i] = 1\n            continue\n\n        for j in messages_sent:\n            if messages_sent[j] < a[i]:\n                messages_to_send += 1\n                messages_sent[i] = 1\n                break\n        else:\n            continue\n        break\n    else:\n        return -1\n\n    result = []\n    for i in range(messages_to_send):\n        for j in messages_sent:\n            for k in range(j + 1, n + 1):\n                if messages_sent.get(k, 0) < a[k]:\n                    result.append((j, k))\n                    messages_sent[k] = messages_sent.get(k, 0) + 1\n                    break\n            else:\n                continue\n            break\n    else:\n        return -1\n\n    return messages_to_send, result\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = a[i - 1] % m + dp[i - 1]\n\n    max_sum = float('-inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            max_sum = max(max_sum, (dp[j] - dp[i - 1]) % m)\n\n    return str(max_sum)\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    max_sum = -1\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            cur_sum = sum(a[i:j+1]) % m\n            max_sum = max(max_sum, cur_sum)\n    \n    return str(max_sum)\n\n\ninput_str = \"\"\"4 4\n5 2 4 1\"\"\"\n\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    max_sum = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            sum_mod = sum(a[i:j+1]) % m\n            max_sum = max(max_sum, sum_mod)\n\n    return max_sum\n\n\ninput_stdin = \"\"\"4 4\n5 2 4 1\"\"\"\n\noutput = solution(input_stdin)\nprint(output)\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_sum(n: int, m: int, a: List[int]) -> int:\n        mod_sum = [0] * (m + 1)\n        for i in range(n):\n            mod_sum[a[i] % m] += a[i]\n        for i in range(m):\n            mod_sum[i + 1] += mod_sum[i]\n\n        max_sum = 0\n        for i in range(m - 1, -1, -1):\n            if mod_sum[i] > max_sum:\n                max_sum = mod_sum[i]\n            mod_sum[i] -= a[n - 1]\n            if mod_sum[i] > max_sum:\n                max_sum = mod_sum[i]\n        return max_sum\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    return str(find_max_sum(n, m, a))\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # compute maximum sum\n    max_sum = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if j - i > 1:\n                max_sum = max(max_sum, sum(a[i:j+1]) % m)\n\n    # print result\n    return str(max_sum)\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    mod_sums = []\n    for i in range(n):\n        mod_sum = 0\n        for j in range(i, n):\n            mod_sum += a[j] % m\n            mod_sums.append(mod_sum)\n\n    max_sum = max(mod_sums)\n    return str(max_sum)\n\n\nn = 4\nm = 4\na = [5, 2, 4, 1]\n\nn = 3\nm = 20\na = [199, 41, 299]\n\ninput_str = \"\\n\".join([str(n), str(m)] + [str(x) for x in a])\nprint(solution(input_str)) "
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n    a = list(map(int, input_list[2:]))\n    \n    max_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                b_i_sum = (a[i] + a[j] + a[k]) % m\n                max_sum = max(max_sum, b_i_sum)\n                \n    return str(max_sum)"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    max_sum = 0\n    for i in range(1, n):\n        for j in range(i, n + 1):\n            sum_mod = sum(a[i:j+1]) % m\n            max_sum = max(max_sum, sum_mod)\n\n    return str(max_sum)\n\ninput_str = \"\"\"4 4\n5 2 4 1\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    def sum_mod(b):\n        return sum(a[i] % m for i in b)\n    \n    max_sum = 0\n    for i in range(1, n+1):\n        max_sum = max(max_sum, sum_mod([i]))\n    \n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            max_sum = max(max_sum, sum_mod([i, j]))\n    \n    return str(max_sum)\n"
    },
    {
        "number": 669,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    max_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                b = [i, j, k]\n                curr_sum = sum(a[i] % m for i in b)\n                max_sum = max(max_sum, curr_sum)\n                \n    return str(max_sum)\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    avenue = input().split()\n    avenue = [int(i) for i in avenue]\n    \n    pointA = input().split()\n    pointA = [int(i) for i in pointA]\n    \n    x1, y1, x2, y2 = pointA[0], pointA[1], pointA[2], pointA[3]\n    \n    # Checking if the avenue is parallel to x-axis or y-axis\n    if avenue[0] == 0:\n        a, b, c = 1, 0, -avenue[2]\n    elif avenue[1] == 0:\n        a, b, c = 0, 1, -avenue[2]\n    else:\n        a, b, c = -avenue[1], avenue[0], -x1*avenue[0] - y1*avenue[1]\n    \n    # Checking if the given point is on the avenue\n    if (a*x1 + b*y1 + c)*(a*x2 + b*y2 + c) < 0:\n        distance = abs((a*x1 + b*y1 + c)*(a*x1 + b*y1 + c)**2 - (a*x2 + b*y2 + c)*(a*x2 + b*y2 + c)**2)**0.5\n        return str(distance)\n    else:\n        return \"0\""
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    avenue = input().split()\n    avenue = [int(i) for i in avenue]\n    a, b, c = avenue\n    \n    origin = input().split()\n    origin = [int(i) for i in origin]\n    x1, y1, x2, y2 = origin\n    \n    dist = abs(x2 - x1) + abs(y2 - y1)\n    \n    if b != 0:\n        dist_diagonal = abs(a) * (x1 - x2) + abs(b) * (y1 - y2) + c\n        dist = max(dist, abs(dist_diagonal))\n    \n    return str(dist)"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    inputs = stdin.split('\\n')\n    avenue_coefficients = inputs[0].split()\n    avenue_coefficients = [int(x) for x in avenue_coefficients]\n    a, b, c = avenue_coefficients\n    point_coordinates = inputs[1].split()\n    point_coordinates = [int(x) for x in point_coordinates]\n    x1, y1, x2, y2 = point_coordinates\n\n    # Calculate the distance between the two points\n    distance = min(abs(x1 - x2), abs(y1 - y2))\n\n    # Find the point on the Diagonal Avenue that is closest to the line connecting A and B\n    def closest_point(a, b, c, x1, y1, x2, y2):\n        # Calculate the slope of the line\n        if b != 0:\n            m = a / b\n        else:\n            m = None\n\n        # Calculate the y-intercept\n        if m is None:\n            b = -c\n        else:\n            b = -c - m * x1\n\n        # Calculate the x-intercept\n        if m is not None:\n            x_intercept = -b / m\n        else:\n            x_intercept = None\n\n        # Calculate the closest point on the Diagonal Avenue\n        if x_intercept is not None:\n            y_intercept = a * x_intercept + c\n            closest_point = (x_intercept, y_intercept)\n        else:\n            if m is not None:\n                y_intercept = y1\n                closest_point = (x1, y_intercept)\n            else:\n                y_intercept = y2\n                closest_point = (x2, y_intercept)\n\n        return closest_point\n\n    closest_point_to_line = closest_point(a, b, c, x1, y1, x2, y2)\n\n    # Calculate the distance between A and the closest point on the Diagonal Avenue\n    distance_to_avenue = min(abs(closest_point_to_line[0] - x1), abs(closest_point_to_line[1] - y1), abs(closest_point_to_line[0] - x2), abs(closest_point_to_line[1] - y2))\n\n    # Calculate the total distance\n    total_distance = distance + distance_to_avenue\n\n    # Format the output\n    output = f\"{total_distance:.6f}\"\n\n    return output\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    avenue = list(map(int, stdin.split()[:3]))\n    origin = list(map(int, stdin.split()[-4:-2]))\n    destination = list(map(int, stdin.split()[-2:]))\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_on_diagonal(x, y):\n        a, b, c = avenue\n        return a * x + b * y + c == 0\n\n    def closest_intersection(x, y):\n        a, b, c = avenue\n        x1 = x2 = x\n        y1 = y2 = y\n\n        if is_on_diagonal(x, y):\n            return x, y\n\n        while not is_on_diagonal(x1, y1) and not is_on_diagonal(x2, y2):\n            x1 -= 1\n            x2 += 1\n            y1 -= 1\n            y2 += 1\n\n        if is_on_diagonal(x1, y1):\n            return x1, y1\n        else:\n            return x2, y2\n\n    origin_x, origin_y = origin\n    destination_x, destination_y = destination\n\n    origin_intersection = closest_intersection(origin_x, origin_y)\n    destination_intersection = closest_intersection(destination_x, destination_y)\n\n    origin_distance = distance(origin_x, origin_y, *origin_intersection)\n    destination_distance = distance(destination_x, destination_y, *destination_intersection)\n\n    total_distance = origin_distance + destination_distance\n\n    return str(total_distance)\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    avenue = list(map(int, stdin.split()))\n    a, b, c = avenue[:3]\n    x1, y1, x2, y2 = avenue[3:]\n\n    def sign(x):\n        if x == 0:\n            return 0\n        return x // abs(x)\n\n    def distance(x, y):\n        return (x ** 2 + y ** 2) ** 0.5\n\n    def dot(x, y, a, b, c):\n        return a * x + b * y + c\n\n    def on_diagonal(x, y, a, b, c):\n        return sign(dot(x, y, a, b, c)) == 0\n\n    def min_distance(x1, y1, x2, y2):\n        x_min = min(x1, x2)\n        y_min = min(y1, y2)\n        x_max = max(x1, x2)\n        y_max = max(y1, y2)\n        distance = 0\n\n        for x in range(x_min, x_max + 1):\n            for y in range(y_min, y_max + 1):\n                if not on_diagonal(x, y, a, b, c):\n                    distance += 1\n\n        return distance\n\n    return f\"{min_distance(x1, y1, x2, y2):.6f}\"\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    avenue = list(map(int, stdin.split()))\n    a, b, c = avenue[:3]\n    x1, y1, x2, y2 = avenue[3:]\n    \n    def get_distance(x1, y1, x2, y2):\n        distance = abs(x1 - x2) + abs(y1 - y2)\n        return distance\n\n    def get_intersection(a, b, c, x, y):\n        d = a * x + b * y + c\n        if d == 0:\n            return (x, y)\n        return (None, None)\n\n    def get_diagonal_intersection(a, b, c, x, y):\n        d = a * x + b * y + c\n        if d == 0:\n            return (x, y)\n        m = -b / a\n        x0 = (c - b * y) / (a * m + b)\n        y0 = (c - a * x0) / (-a)\n        return (x0, y0)\n\n    intersection = get_intersection(a, b, c, x1, y1)\n    if intersection != (None, None):\n        x1, y1 = intersection\n    else:\n        intersection = get_diagonal_intersection(a, b, c, x1, y1)\n        if intersection != (None, None):\n            x1, y1 = intersection\n        else:\n            return \"No intersection found\"\n\n    intersection = get_intersection(a, b, c, x2, y2)\n    if intersection != (None, None):\n        x2, y2 = intersection\n    else:\n        intersection = get_diagonal_intersection(a, b, c, x2, y2)\n        if intersection != (None, None):\n            x2, y2 = intersection\n        else:\n            return \"No intersection found\"\n\n    distance = get_distance(x1, y1, x2, y2)\n    return round(distance, 6)"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    avenue, A, B = stdin.split('\\n')\n    a, b, c = map(int, avenue.split())\n    x1, y1, x2, y2 = map(int, A.split())\n\n    def cross(x1, y1, x2, y2):\n        return x1 * y2 - x2 * y1\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def closest_point(x, y):\n        d = cross(a, b, c, -a * x - b * y - c)\n        if d == 0:\n            return x, y\n        a, b, c = b, -a, a * x + b * y\n        d = cross(a, b, c, -a * x - b * y - c)\n        if d == 0:\n            return x, y\n        a, b, c = a, b, -a * x - b * y\n        d = cross(a, b, c, -a * x - b * y - c)\n        if d == 0:\n            return x, y\n        a, b, c = -b, a, a * x - b * y\n        d = cross(a, b, c, -a * x - b * y - c)\n        if d == 0:\n            return x, y\n        return x, y\n\n    x1, y1 = closest_point(x1, y1)\n    x2, y2 = closest_point(x2, y2)\n\n    return distance(x1, y1, x2, y2)"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    avenue_coefficients = list(map(int, stdin.split()[:3]))\n    a, b, c = avenue_coefficients\n    avenue = [(x, y) for x in range(-100, 101) for y in range(-100, 101) if a * x + b * y + c == 0]\n\n    start_coordinates = list(map(int, stdin.split()[3:]))\n    x1, y1, x2, y2 = start_coordinates\n\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    def closest_point(point, points):\n        distances = [distance(point, p) for p in points]\n        return points[distances.index(min(distances))]\n\n    start_point = (x1, y1)\n    end_point = (x2, y2)\n    if start_point in avenue:\n        start_point = closest_point(start_point, avenue)\n    if end_point in avenue:\n        end_point = closest_point(end_point, avenue)\n\n    distance_to_travel = distance(start_point, end_point)\n    return distance_to_travel\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    avenue_coefficients = list(map(int, inputs[0].split()))\n    origin = list(map(int, inputs[1].split()))\n    destination = list(map(int, inputs[2].split()))\n\n    def distance_to_diagonal(x, y):\n        a, b, c = avenue_coefficients\n        return abs(a * x + b * y + c) / (a ** 2 + b ** 2) ** 0.5\n\n    return (distance_to_diagonal(origin[0], origin[1]) + distance_to_diagonal(destination[0], destination[1])) ** 0.5\n"
    },
    {
        "number": 670,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    inputs = stdin.splitlines()\n    avenue_coefficients = list(map(int, inputs[0].split()))\n    points = list(map(int, inputs[1].split()))\n\n    # Calculate the distance between the two points\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    # Find the point on the avenue closest to the origin\n    def closest_point(coefficients, origin):\n        a, b, c = coefficients\n        min_distance = float('inf')\n        closest_point = None\n        for y in range(-100, 101):\n            x = -(a * y + c) / b\n            distance_to_origin = distance(x, y, origin[0], origin[1])\n            if distance_to_origin < min_distance:\n                min_distance = distance_to_origin\n                closest_point = (x, y)\n        return closest_point\n\n    origin = (0, 0)\n    closest_point_on_avenue = closest_point(avenue_coefficients, origin)\n    distance_to_avenue = distance(closest_point_on_avenue[0], closest_point_on_avenue[1], points[2], points[3])\n    distance_to_destination = distance(points[0], points[1], points[2], points[3])\n    total_distance = distance_to_avenue + distance_to_destination\n\n    # Format and output the result\n    return '{:.6f}'.format(total_distance)\n"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 1 or n > 1000:\n        return \"Invalid input\"\n\n    prefix = \"123456789101112131415\"\n    index = (n - 1) // len(prefix)\n    digit = (n - 1) % len(prefix)\n    result = prefix[digit]\n\n    for i in range(index):\n        result = str(int(result) * 10)\n\n    return result\n\ndef"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = \"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798990\"\n    result = int(digits[n-1])\n    return str(result)\n\ninput_str = input().strip()\nprint(solution(input_str)) "
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 9 == 0:\n        return '9'\n    prefix = \"123456789101112131415\"\n    digits = len(prefix)\n    position = n % digits\n    if position == 0:\n        position = digits\n    return prefix[position - 1]\n\n\ninput_str = input(\"Enter the integer n: \")\nprint(solution(input_str)) "
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    prefix = \"123456789101112131415\"\n    result = prefix[n-1]\n    return result\n\ninput_str = \"11\"\nprint(solution(input_str)) "
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    number_line = \"123456789101112131415\"\n    index = n - 1\n    digit = number_line[index]\n    return digit\n\ndef"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n = int(input_str)\n    if n < 1 or n > 1000:\n        return \"Error: n should be between 1 and 1000\"\n    \n    prefix = \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990\"\n    \n    position = n\n    result = \"\"\n    for digit in prefix:\n        if position == 1:\n            result = digit\n            break\n        position -= 1\n    \n    return result"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = \"123456789101112131415\"\n    length = len(digits)\n    if n <= length:\n        return digits[n - 1]\n    else:\n        return digits[-1] * (n // length)\n\ndef"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990\"\n    return digits[n-1]\n\ninput_str = \"3\\n\"\nprint(solution(input_str))\n\ninput_str = \"11\\n\"\nprint(solution(input_str)) "
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    num = \"123456789101112131415\"\n    digit = num[n-1]\n    return digit"
    },
    {
        "number": 671,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n = int(input_str)\n    if n < 1 or n > 1000:\n        return \"Invalid input\"\n    else:\n        number_str = \"123456789101112131415\"\n        digit = number_str[n-1]\n        return digit\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = a // b\n    if a % b == 0:\n        return \"infinity\"\n    else:\n        return x + 1\n\ninput_str = \"21 5\"\nprint(solution(input_str)) "
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = gcd(a, b)\n    if x == 1:\n        return \"infinity\"\n    else:\n        return b // x\n\ndef"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    if a == 0 and b == 0:\n        return \"infinity\"\n    \n    x = 0\n    count = 0\n    \n    while x * x <= a:\n        if a % (x + 1) == b:\n            count += 1\n        x += 1\n    \n    return count\n\ndef"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if a == 0 and b == 0:\n        return \"infinity\"\n\n    if a == 0:\n        return 0\n\n    x = gcd(a, b)\n    if x == 1:\n        return \"infinity\"\n\n    a //= x\n    b //= x\n    if b == 0:\n        return 0\n\n    m = b // gcd(a, b)\n    n = a // gcd(a, b)\n    return n + (1 - n) * m\n\ndef"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b > a:\n        return \"infinity\"\n    elif a % b == 0:\n        return \"infinity\"\n    else:\n        count = 0\n        for i in range(a // b + 1):\n            if (a - i * b) % b == 0:\n                count += 1\n        return count\n\n\ndef"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0:\n        return \"infinity\"\n    else:\n        count = 0\n        i = 1\n        while a % i != 0 or i > b:\n            i += 1\n        count += 1\n        while i <= b:\n            count += 1\n            i += a\n        return count - 1\n\ninput_str = \"21 5\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"9435152 272\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"10 10\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    if a == b:\n        return \"1\"\n    \n    if a < b:\n        a, b = b, a\n    \n    if b == 1:\n        return \"infinity\"\n    \n    num_solutions = 0\n    while a % b != 0:\n        a, b = b, a % b\n        num_solutions += 1\n        \n    if a == b:\n        return \"infinity\"\n    \n    if num_solutions == 0:\n        return \"1\"\n    \n    return str(num_solutions)"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    count = 0\n    x = 1\n    while count == 0:\n        if a % x == b:\n            count += 1\n        x += 1\n    if count == 0:\n        return \"infinity\"\n    else:\n        return count\n"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    if a == b:\n        return \"2\"\n    elif a > b:\n        return \"infinity\"\n    else:\n        x = a\n        count = 0\n        while x <= b:\n            if a % x == 0 and b % x == 0:\n                count += 1\n            x += 1\n        return str(count)"
    },
    {
        "number": 672,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    \n    if a == b:\n        return \"infinity\"\n    else:\n        x = 0\n        while True:\n            if a % (x+1) == b:\n                x += 1\n            else:\n                break\n        return x"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n\ndef"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, k = input_values\n    x = n + k\n\n    while x % k != 0:\n        x += k\n\n    return str(x)\n\n\ndef"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, k = map(int, input_str.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n\n\ndef"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = (n // k + 1) * k\n    return str(x)\n\n\ndef"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n\nn, k = map(int, input().split())\nprint(solution(str(n) + \" \" + str(k))) "
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    return (n // k + 1) * k\n"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, k = input_values[0], input_values[1]\n    x = (n + k - 1) // k * k + k\n    return str(x)\n\ndef"
    },
    {
        "number": 673,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k != 0:\n        x += k\n    return str(x)\n\n\ninput_str = input(\"Enter two integers n and k separated by space: \")\nresult = solution(input_str)\nprint(\"The smallest integer x > n, so it is divisible by the number k is:\", result) "
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_substring(s: str, sub: str) -> int:\n        count = 0\n        for i in range(len(s) - len(sub) + 1):\n            if s[i:i+len(sub)] == sub:\n                count += 1\n        return count\n\n    n = int(stdin.splitlines()[0])\n    strings = stdin.splitlines()[1:]\n    good_strings = []\n\n    for s in strings:\n        most_frequent = s[0]\n        for c in set(s):\n            if count_substring(s, c * len(s)) >= count_substring(s, most_frequent * len(s)):\n                most_frequent = c\n        if all(most_frequent * count_substring(s, most_frequent) == s[i:i+len(most_frequent)] for i in range(len(s) - len(most_frequent) + 1)):\n            good_strings.append(most_frequent)\n\n    if not good_strings:\n        return \"NO\"\n    else:\n        return min(good_strings)\n\n\ndef"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_most_frequent(strings: list) -> str:\n        def count_substring(string: str, substring: str) -> int:\n            count = 0\n            for i in range(len(string) - len(substring) + 1):\n                if string[i:i + len(substring)] == substring:\n                    count += 1\n            return count\n\n        def is_most_frequent(substring: str, strings: list) -> bool:\n            count = 0\n            for string in strings:\n                if count_substring(string, substring) >= count:\n                    count = count_substring(string, substring)\n                else:\n                    return False\n            return True\n\n        substring = \"\"\n        for string in strings:\n            for i in range(len(string)):\n                for j in range(i + 1, len(string) + 1):\n                    substring_candidate = string[i:j]\n                    if is_most_frequent(substring_candidate, strings):\n                        substring = substring_candidate\n        return substring\n\n    n = int(stdin.split(\"\\n\")[0])\n    strings = [string.strip() for string in stdin.split(\"\\n\")[1:n + 1]]\n    good_strings = []\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings) + 1):\n            good_strings.append(\"\".join(sorted(strings[i:j])))\n    most_frequent = find_most_frequent(good_strings)\n    if most_frequent:\n        return most_frequent\n    else:\n        return \"NO\"\n\n\ninput_string = '''4\nmail\nai\nlru\ncf'''\nprint(solution(input_string))  # Output: cfmailru\n\ninput_string = '''3\nkek\npreceq\ncheburek'''\nprint(solution(input_string))  # Output: NO "
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_substring_occurrences(string: str, substring: str) -> int:\n        count = 0\n        for i in range(len(string) - len(substring) + 1):\n            if string[i:i + len(substring)] == substring:\n                count += 1\n        return count\n\n    def is_most_frequent(string: str, substrings: set[str]) -> bool:\n        if not substrings:\n            return False\n        most_frequent = substrings.pop()\n        for substring in substrings:\n            if count_substring_occurrences(string, substring) < count_substring_occurrences(string, most_frequent):\n                most_frequent = substring\n        return count_substring_occurrences(string, most_frequent) >= count_substring_occurrences(string, substring)\n\n    n = int(stdin.splitlines()[0])\n    good_strings = set()\n    for i in range(1, n + 1):\n        string = stdin.splitlines()[i]\n        good_strings.add(string)\n\n    for string in good_strings:\n        if is_most_frequent(string, good_strings):\n            return string\n\n    return \"NO\"\n\ninput_stdin = \"\"\"4\nmail\nai\nlru\ncf\"\"\"\n\noutput_stdin = solution(input_stdin)\nprint(output_stdin)  # Output: cfmailru\n\ninput_stdin = \"\"\"3\nkek\npreceq\ncheburek\"\"\"\n\noutput_stdin = solution(input_stdin)\nprint(output_stdin)  # Output: NO "
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    strings = stdin.splitlines()[1:]\n\n    def most_frequent_substring(string: str) -> str:\n        max_substring = \"\"\n        for i in range(len(string)):\n            for j in range(i + 1, len(string) + 1):\n                substring = string[i:j]\n                count = sum(1 for _ in filter(lambda x: x == substring, strings))\n                if count >= len(strings) - count:\n                    max_substring = substring\n        return max_substring\n\n    good_strings = set(filter(lambda x: all(most_frequent_substring(x) in s for s in strings), strings))\n\n    if not good_strings:\n        return \"NO\"\n\n    good_strings = sorted(good_strings, key=lambda x: (x.count(\"\"), x))\n\n    return good_strings[0]\n"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str, strings: set) -> bool:\n        for sub in strings:\n            if s.count(sub) < s.count(sub[0]):\n                return False\n        return True\n\n    def most_frequent_substring(s: str) -> str:\n        max_sub = \"\"\n        max_count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                sub = s[i:j]\n                if s.count(sub) >= max_count:\n                    max_sub = sub\n                    max_count = s.count(sub)\n        return max_sub\n\n    n = int(stdin.splitlines()[0])\n    strings = set(stdin.splitlines()[1:])\n\n    good_strings = []\n    for s in strings:\n        if is_good(s, strings):\n            good_strings.append(s)\n\n    if not good_strings:\n        return \"NO\"\n\n    min_length = min(len(s) for s in good_strings)\n    min_length_strings = [s for s in good_strings if len(s) == min_length]\n\n    min_string = min(min_length_strings, key=most_frequent_substring)\n    return min_string\n"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def most_frequent_substring(s: str) -> str:\n        n = len(s)\n        max_len = 1\n        max_count = 1\n        count = 1\n        start = 0\n        result = \"\"\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                if count > max_count:\n                    max_len = i - start\n                    max_count = count\n                    result = s[start:i]\n                count = 1\n                start = i\n        if count > max_count:\n            max_len = n - start\n            max_count = count\n            result = s[start:]\n        return result * (max_len // len(result))\n\n    def is_good(s: str, strings: set) -> bool:\n        for string in strings:\n            if s.count(string) < s.count(most_frequent_substring(s)):\n                return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    strings = set(stdin.splitlines()[1:])\n    min_length = float('inf')\n    result = \"\"\n    for s in strings:\n        if is_good(s, strings) and len(s) < min_length:\n            min_length = len(s)\n            result = s\n    return result if result else \"NO\"\n"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    strings = set(stdin.splitlines()[1:])\n\n    for s in strings:\n        if not all(s in s2 for s2 in strings):\n            return \"NO\"\n\n    good_strings = set()\n    for s1 in strings:\n        for s2 in strings:\n            if s1 != s2 and s1 in s2:\n                good_strings.add(s1)\n                good_strings.add(s2)\n\n    good_strings = sorted(good_strings, key=lambda x: (x[::-1], x))\n\n    return good_strings[0] if good_strings else \"NO\"\n"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_substring(s: str, t: str) -> bool:\n        i = 0\n        for c in s:\n            while i < len(t) and t[i] != c:\n                i += 1\n            i += 1\n        return i == len(t)\n\n    def count_substring(s: str, t: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if is_substring(t, s[i:]):\n                count += 1\n                i += len(t)\n            else:\n                i += 1\n        return count\n\n    n = int(stdin.split('\\n')[0])\n    strings = [line.strip() for line in stdin.split('\\n')[1:]]\n    min_length = float('inf')\n    min_string = ''\n\n    for s in strings:\n        for t in strings:\n            if s == t:\n                continue\n            if count_substring(s, t) >= n:\n                if len(s) < min_length:\n                    min_length = len(s)\n                    min_string = s\n                elif len(s) == min_length and s < min_string:\n                    min_string = s\n\n    return min_string if min_string else \"NO\""
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    strings = set(stdin.split('\\n')[1:])\n    result = ''\n    \n    for s in strings:\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substr = s[i:j]\n                if substr in strings:\n                    result = substr\n                    break\n            if result:\n                break\n        if result:\n            break\n    \n    if not result:\n        return \"NO\"\n    else:\n        for s in strings:\n            if s.startswith(result) and len(s) <= len(result):\n                result = s\n        return result\n\n\ndef"
    },
    {
        "number": 674,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def most_frequent_substring(s: str) -> str:\n        freq = {}\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substr = s[i:j]\n                freq[substr] = freq.get(substr, 0) + 1\n        max_freq = max(freq.values())\n        most_frequent = [k for k, v in freq.items() if v == max_freq]\n        return min(most_frequent)\n\n    n = int(stdin.split(\"\\n\")[0])\n    strings = stdin.split(\"\\n\")[1:]\n    good_strings = [s for s in strings if all(most_frequent_substring(s) in most_frequent_substring(ss) for ss in strings)]\n    if not good_strings:\n        return \"NO\"\n    return min(good_strings)"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n    \n    w.sort()\n    n = len(w)\n    \n    # Check if it is possible to make at least r candles burn during each visit\n    if r > n:\n        return \"-1\"\n    \n    # Calculate the number of seconds Anya needs to light candles\n    seconds = 0\n    for i in range(1, n):\n        seconds += w[i] - w[i-1]\n    \n    seconds += t * n\n    \n    # Check if it is possible to light at least r candles during each visit\n    candles = ceil(seconds / t)\n    if candles < r:\n        return \"-1\"\n    \n    # Calculate the minimum number of candles Anya needs to light\n    min_candles = ceil(r / n) * t\n    \n    return str(min_candles)\n"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n\n    if r > m:\n        return -1\n\n    n = 0\n    candles = [0] * t\n    for ghost_time in w:\n        for i in range(t):\n            if candles[i] < r:\n                candles[i] += 1\n            if sum(candles) >= r:\n                break\n        n += 1\n        if n == m:\n            break\n\n    if sum(candles) >= r:\n        return n\n    else:\n        return -1"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n    \n    candles_needed = 1\n    while candles_needed <= m:\n        candles_needed += 1\n        if any(w[i] % candles_needed != 0 for i in range(m)):\n            candles_needed -= 1\n            break\n            \n    if candles_needed < r:\n        return -1\n    else:\n        return candles_needed\n"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split())\n    w = list(map(int, input().split()))\n\n    candles = 0\n    for i in range(m):\n        time_diff = w[i] - sum(w[:i])\n        candles += time_diff // t + 1\n\n    if candles < r:\n        return \"-1\"\n    else:\n        return candles\n\n\ninput_str = \"\"\"1 8 3\n10\n1 10 1\n5 8\n1 1 3\n10\"\"\"\n\noutput_str = \"\"\"3\n1\n-1\"\"\"\n\ninput_list = input_str.split('\\n')\noutput_list = output_str.split('\\n')\n\nfor i in range(len(input_list)):\n    print(solution(input_list[i]))\n    if solution(input_list[i]) != output_list[i]:\n        print(\"Test case\", i + 1, \"failed\")\n        break\nelse:\n    print(\"All test cases passed\")\n"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, input().split())\n    w = list(map(int, input().split()))\n\n    w.sort()\n\n    # Check if it's possible to have at least r candles burning during each visit\n    if w[-1] - w[0] < t * (m - 1) + (r - 1):\n        return \"-1\"\n\n    # Calculate the minimum number of candles needed\n    needed_candles = 0\n    time = w[0]\n    while needed_candles < r:\n        needed_candles += 1\n        time += t\n        # Check if the ghost can visit at time\n        if time >= w[-1]:\n            break\n\n    return needed_candles"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n\n    candles_needed = 1\n    current_candles = []\n\n    for i in range(m):\n        candle_start = w[i]\n\n        # If there is no room for one more candle, light the current ones\n        if candle_start + t > 3600:\n            if len(current_candles) < r:\n                return -1\n            current_candles = []\n            candle_start = 0\n\n        current_candles.append((candle_start, candle_start + t))\n\n        # If there are not enough candles, light new ones\n        while len(current_candles) < r:\n            candles_needed += 1\n            current_candles.append((3600 - candles_needed * t, 3600 - candles_needed * t + t))\n\n    return candles_needed"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n\n    w.sort()\n\n    if len(w) < m:\n        return \" -1\"\n\n    time = 0\n    candles = 0\n    for i in range(m):\n        while time < w[i]:\n            time += 1\n            candles += 1\n        time += t\n        if candles < r:\n            return \" -1\"\n        candles = 0\n\n    return str(m)\n"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, input().split())\n    w = list(map(int, input().split()))\n\n    if r > m:\n        return -1\n\n    candles = 0\n    last_candle = 0\n\n    for i in range(1, m + 1):\n        if w[i - 1] <= last_candle + t:\n            continue\n        candles += 1\n        last_candle = w[i - 1]\n\n    if candles < r:\n        return -1\n    else:\n        return candles\n\n\ninput_str = \"\"\"2 10 1\n5 8\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, input().split())\n    w = list(map(int, input().split()))\n\n    # If there are less than r candles, it's not possible\n    if r > m:\n        return \"-1\"\n\n    # Sort the times in ascending order\n    w.sort()\n\n    # Initialize the minimum number of candles needed\n    min_candles = 1\n\n    # The current time is initially set to 0\n    current_time = 0\n\n    # Initialize a list to keep track of the burning candles\n    burning_candles = [False] * t\n\n    # Iterate through the times and the ghosts\n    for w_i in w:\n        # Check if the current time is before the ghost visit\n        while current_time < w_i - t + 1:\n            # If there are less than r candles burning, increase the minimum number of candles needed\n            if sum(burning_candles) < r:\n                min_candles += 1\n            # Increment the current time by 1 second\n            current_time += 1\n            # Reset the burning candles list\n            burning_candles = [False] * t\n        # Set the current time to the ghost visit time\n        current_time = w_i\n        # Light the candle at the current time if there are less than r candles burning\n        if sum(burning_candles) < r:\n            burning_candles[current_time % t] = True\n\n    # If there are less than r candles burning at the end, increase the minimum number of candles needed\n    if sum(burning_candles) < r:\n        min_candles += 1\n\n    # Return the minimum number of candles needed\n    return min_candles"
    },
    {
        "number": 675,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split()[:3])\n    w = list(map(int, stdin.split()[3:]))\n\n    w.sort()\n\n    if w[0] != 0:\n        return -1\n\n    c = 0\n    i = 0\n    while i < m and w[i] <= c * t + 1:\n        c += 1\n        i += 1\n\n    return c if c >= r else -1"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = [int(x) for x in input_list[1:]]\n    a.sort()\n\n    mean = median = range_ = sum(a) / 4\n\n    for i in range(n):\n        if a[i] < 1 or a[i] > 500:\n            return \"NO\"\n        if a[i] != mean or (i % 2 == 1 and a[i] != median) or a[i] != range_:\n            return \"NO\"\n\n    for i in range(n, len(a)):\n        b = a[i]\n        if b < 1 or b > 10**6:\n            return \"NO\"\n        yield b"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    a = [int(x) for x in input_data[1:]]\n    a.sort()\n\n    if n > 4:\n        return \"NO\"\n\n    mean = sum(a) / n\n    median = sum(a[n//2:n//2+1]) / 1\n    range_value = a[-1] - a[0]\n\n    if mean != median or mean != range_value:\n        return \"NO\"\n\n    for i in range(n, 4):\n        a.append(mean)\n\n    a.sort()\n\n    return \"YES\\n\" + \"\\n\".join(str(a[i]) for i in range(4-n, 4))\n\n\ninput_data = \"\"\"2\n1\n1\n\n3\n1\n1\n1\n\n4\n1\n2\n2\n3\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    a = list(map(int, input_data[1:]))\n    \n    mean, median, range_ = float('inf'), float('inf'), float('inf')\n    \n    # Calculate mean, median, and range\n    total = sum(a)\n    if n > 0:\n        mean = total / n\n        median = sorted(a)[n - 1]\n        range_ = max(a) - min(a)\n    \n    # Check if the condition is met\n    if mean == median == range_:\n        # Calculate the missing numbers of candies\n        b = [sum(a) - mean * n] * n\n        return \"YES\\n\" + \"\\n\".join(map(str, b))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_box(box: List[int]) -> bool:\n        mean = sum(box) / 4\n        sorted_box = sorted(box)\n        median = sum(sorted_box[1:3]) / 2\n        range_box = sorted_box[-1] - sorted_box[0]\n        return mean == median == range_box\n\n    def find_missing_boxes(boxes: List[int]) -> List[int]:\n        missing_boxes = []\n        for i in range(4 - len(boxes)):\n            missing_box = boxes[i] if i < len(boxes) else 1\n            while not is_valid_box(boxes + [missing_box]):\n                missing_box += 1\n            missing_boxes.append(missing_box)\n        return missing_boxes\n\n    n, boxes = 0, []\n    for i in range(1, 5):\n        line = stdin.split(\"\\n\")[i]\n        if line:\n            n += 1\n            boxes.append(int(line))\n\n    if is_valid_box(boxes):\n        missing_boxes = find_missing_boxes(boxes)\n        print(\"YES\")\n        for box in missing_boxes:\n            print(box)\n    else:\n        print(\"NO\")\n"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_missing_boxes(a_i, n):\n        a_i.sort()\n        missing_candies = []\n        if n >= 4:\n            return missing_candies\n        mean = (a_i[0] + a_i[1] + a_i[2] + a_i[3]) / 4\n        median = (a_i[1] + a_i[2]) / 2\n        range_ = a_i[3] - a_i[0]\n\n        if mean == median and median == range_:\n            if n == 0:\n                return [1, 1, 3, 3]\n            for i in range(n):\n                missing_candies.append(a_i[i] - 1)\n            return missing_candies\n        return missing_candies\n\n    def check_missing_boxes(a_i, missing_boxes):\n        if not missing_boxes:\n            return \"NO\"\n        total_candies = sum(a_i) - sum(missing_boxes)\n        missing_boxes.sort()\n        return total_candies >= 0 and 1 <= total_candies <= 10**6\n\n    def main(stdin: str) -> str:\n        n = int(stdin.split()[0])\n        a_i = [int(x) for x in stdin.split()[1:]]\n        missing_boxes = find_missing_boxes(a_i, n)\n        return check_missing_boxes(a_i, missing_boxes)\n\n    return main(stdin)\n"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    boxes = [int(input()) for _ in range(n)]\n    \n    def calculate_stats(numbers):\n        mean = sum(numbers) / len(numbers)\n        numbers.sort()\n        median = (numbers[1] + numbers[2]) / 2 if len(numbers) == 3 else numbers[1]\n        range_ = numbers[-1] - numbers[0]\n        return mean, median, range_\n    \n    mean, median, range_ = calculate_stats(boxes)\n    \n    if n == 4:\n        if mean == median == range_:\n            return \"YES\\n\" + \"\\n\".join(str(boxes[i]) for i in range(4))\n        else:\n            return \"NO\"\n    else:\n        missing_boxes = 4 - n\n        result = \"YES\\n\"\n        for i in range(missing_boxes):\n            result += str(boxes[i]) + \"\\n\"\n        return result\n\ndef"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    boxes = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    \n    # Calculate the mean, median, and range\n    mean = sum(boxes) / 4\n    median = sorted(boxes)[2]\n    range_ = max(boxes) - min(boxes)\n    \n    # Check if the conditions are met\n    if mean == median == range_:\n        missing_boxes = [x for x in range(1, 51) if x not in boxes]\n        if len(missing_boxes) >= 4 - n:\n            return \"YES\\n\" + \"\\n\".join(str(x) for x in missing_boxes[:4 - n])\n    return \"NO\""
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = sorted(a)\n    mean = median = range_ = sum(a) / n\n\n    if all(a[i] == mean for i in range(n)) and all(a[i] == median for i in range(n)) and all(a[i] == range_ for i in range(n)):\n        return \"NO\"\n\n    i = n - 1\n    j = n - 1\n    missing_candies = []\n\n    while i < 4:\n        while j < 4:\n            if a[j] != range_:\n                missing_candies.append(range_ - a[j])\n                break\n            j += 1\n        i += 1\n\n    return \"YES\\n\" + \"\\n\".join(map(str, missing_candies))"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = []\n    for i in range(n):\n        a.append(int(stdin))\n    a.sort()\n    \n    if n == 4:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    \n    mean = (a[0] + a[1] + a[2] + a[3]) / 4\n    median = (a[1] + a[2]) / 2\n    \n    if a[0] == a[3] == a[2] == a[1]:\n        return \"YES\\n\" + \" \".join(map(str, a))\n    \n    missing_boxes = 4 - n\n    missing_numbers = []\n    \n    for i in range(missing_boxes):\n        missing_numbers.append(round(mean))\n    \n    return \"YES\\n\" + \" \".join(map(str, missing_numbers))"
    },
    {
        "number": 676,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    boxes = [int(input_list[i]) for i in range(1, n + 1)]\n\n    # Calculate the mean, median and range\n    mean = sum(boxes) / len(boxes)\n    median = sorted(boxes)[1]\n    range_ = max(boxes) - min(boxes)\n\n    # Check if the mean, median and range are all equal\n    if (mean == median) and (median == range_ / 2) and (mean == range_ / 4):\n        # Find the missing numbers of candies in the 4 - n boxes\n        missing_candies = []\n        for i in range(len(boxes), 4):\n            missing_candies.append(mean)\n\n        return \"YES\\n\" + \"\\n\".join(map(str, missing_candies))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:q+1]]\n    \n    for query in queries:\n        l, r, d = query[0], query[1], query[2]\n        if d == 1:\n            print(r+1)\n            continue\n        i = l\n        while i <= r:\n            if i % d == 0:\n                x = i\n            i += 1\n        print(x)\n        \nstdin = \"\"\"5\n2 4 2\n5 10 4\n3 10 1\n1 2 3\n4 6 5\"\"\"\n\noutput = solution(stdin)\nprint(output)"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    q, *queries = stdin.split('\\n')\n    q = int(q)\n\n    output = []\n    for query in queries:\n        l, r, d = map(int, query.split())\n\n        min_x = 0\n        while min_x * d <= r * d:\n            min_x += 1\n\n        if min_x * d <= l * d:\n            x = min_x * d\n        else:\n            x = lcm(min_x * d, (l - (min_x - 1)) * d)\n\n        output.append(x)\n\n    return '\\n'.join(map(str, output))\n\n\ninput_file = \"input_example.txt\"\noutput_file = \"output_example.txt\"\n\nwith open(input_file, 'r') as file_in, open(output_file, 'w') as file_out:\n    input_data = file_in.read()\n    output_data = solution(input_data)\n    file_out.write(output_data) "
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.splitlines()[0])\n    queries = stdin.splitlines()[1:]\n    for i, query in enumerate(queries):\n        l, r, d = map(int, query.split())\n        x = r // d + 1\n        while x * d <= r:\n            x += 1\n        print(x)\n    return \"\\n\".join([str(x) for x in range(1, q + 1)])\n\n\ndef"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.splitlines()[0])\n    output = []\n    for line in stdin.splitlines()[1:]:\n        l, r, d = map(int, line.split())\n        x = l\n        while x <= r:\n            if x % d == 0:\n                output.append(x)\n                break\n            x += 1\n        else:\n            output.append(1)\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split('\\n')[0])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    result = []\n    for l, r, d in queries:\n        x = l + d - 1\n        while x % d != 0:\n            x += d\n        if x <= r:\n            x += d\n        result.append(x)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_x(l, r, d):\n        g = gcd(d, r - l + 1)\n        x = (r - l + 1) // g * d\n        return x\n\n    q = int(stdin.readline())\n    queries = [list(map(int, stdin.readline().strip().split())) for _ in range(q)]\n\n    for l, r, d in queries:\n        x = find_x(l, r, d)\n        while x % d != 0:\n            x += d\n        print(x)\n\n\ninput_data = \"\"\"5\n2 4 2\n5 10 4\n3 10 1\n1 2 3\n4 6 5\n\"\"\"\n\noutput_data = \"\"\"6\n4\n1\n3\n10\n\"\"\"\n\nwith stdin_mock(input_data) as stdin:\n    with stdout_mock() as stdout:\n        solution(stdin)\n        assert stdout.getvalue().strip() == output_data.strip()\n\nprint(\"All test cases passed!\")"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_divisible(d, x):\n        return x % d == 0\n\n    def belongs_to_segment(l, r, x):\n        return l <= x <= r\n\n    q, *queries = stdin.split('\\n')\n    q = int(q)\n\n    for query in queries:\n        l, r, d = map(int, query.split())\n        x = l\n        while not (is_divisible(d, x) and not belongs_to_segment(l, r, x)):\n            x += 1\n        print(x)\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin)\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    for l, r, d in queries:\n        x = (r // d) * d + d\n        if x <= l:\n            x += d\n        print(x)\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split(\"\\n\")[0].strip())\n    queries = stdin.split(\"\\n\")[1:]\n    result = []\n    for query in queries:\n        l, r, d = map(int, query.strip().split())\n        min_divisible = d\n        while min_divisible * d <= r:\n            min_divisible += d\n        if min_divisible <= r:\n            result.append(min_divisible)\n        else:\n            result.append(r + 1)\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 677,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    q = int(stdin.split('\\n')[0])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for i, query in enumerate(queries):\n        l, r, d = query\n        start = lcm(d, l)\n        if start <= r:\n            start = (start + d) // d * d\n        x = start\n        while x <= r:\n            if x % d == 0:\n                break\n            x += d\n        if x > r:\n            x = -1\n        print(x)"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    TUX = 0\n    TUX = int(input())\n    while TUX != 0:\n        PUR = int(input())\n        TUX = int(input())\n        while TUX != 0:\n            BAZ = 0\n            QUZ = 1\n            for i in range(TUX):\n                FOO = 0\n                BAR = 1\n                if i % PUR == 0:\n                    BAZ += 1\n                if i % QUZ == 0:\n                    QUZ += 1\n            BIGGR = max(BAZ * QUZ * PUR, BAZ * QUZ * (TUX - PUR))\n            if BIGGR == 0:\n                BAZ = 0\n            else:\n                BAZ = round(BAZ * QUZ * PUR / BIGGR, 6)\n            TUX = int(input())\n    return str(BAZ)\n"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    TUX = int(input())\n    TUX = int(TUX)\n    FOO = 0\n    BAR = 0\n    BAZ = 0\n    QUZ = 1\n    PUR = int(input())\n    PUR = int(PUR)\n\n    while TUX != 0:\n        FOO = FOO + FOO + PUR\n        BAR = BAR + 1\n        BAZ = max(BAZ, FOO * QUZ, (FOO * QUZ) * (BAR * BAZ))\n        if FOO * QUZ > (BAR * BAZ):\n            BAZ = FOO\n            QUZ = BAR\n        TUX = TUX - 1\n\n    BAZ = FOO\n    QUZ = BAR\n\n    return f\"{BAZ * QUZ:.6f}\"\n"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    nums = [int(line) for line in lines]\n    tux = nums[0]\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n\n    while tux != 0:\n        pur = nums[tux]\n        foo = foo + foo + pur\n        bar = bar + 1\n        if foo * quz > baz * bar * quz and foo * quz > baz * bar * quz:\n            baz = foo\n            quz = bar\n        tux = nums[tux - 1]\n\n    return str(baz * quz)\n\n\ndef"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    tux = [int(x) for x in stdin.split('\\n')[:-1]]\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n    for num in tux:\n        if num != 0:\n            break\n        quz *= 10\n    else:\n        return \"0\"\n    for num in tux:\n        if num != 0:\n            break\n        foo = quz\n        baz = foo\n        bar = 1\n        for i in range(len(tux)):\n            if tux[i] != 0:\n                break\n            else:\n                i += 1\n            pur = i\n            pur = quz * pur + 1\n            if pur == 0:\n                continue\n            foo = foo + pur\n            bar = bar + 1\n            biggr_product = max(foo * quz, bar * baz, foo * quz * bar * baz)\n            if biggr_product == foo:\n                baz = foo\n                quz = bar\n                break\n        else:\n            return str(baz / quz)\n    return str(foo / bar)\n\nprint(solution(input())) "
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    tux = int(stdin)\n    while tux != 0:\n        pur = int(input())\n        tux = tux - pur\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n    while True:\n        if foo > 0 and bar > 0:\n            biggr = max(foo * quz * baz, (foo * quz) * (bar + 1) * baz)\n            if biggr == (foo * quz * baz):\n                baz = foo\n                quz = bar * baz\n            else:\n                baz = (foo * quz * baz) / (bar * quz)\n                quz = 1\n            break\n        foo = int(input())\n    result = baz + quz\n    return str(result)\n"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    tuxtotal = 0\n    quz = 1\n    for line in stdin.splitlines():\n        tuxtotal += int(line)\n    while tuxtotal != 0:\n        pur = tuxtotal // quz\n        tuxtotal %= quz\n        quz *= tuxtotal\n        if quz > 9:\n            quz = 0\n    return str(tuxtotal)\n"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    numbers = [int(line) for line in lines if line.strip() != \"\"]\n    tux = sum(numbers)\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n    while tux != 0:\n        pur = tux\n        tux = tux // 2\n        foo = foo + foo + pur\n        bar = bar + 1\n        if foo * quz * baz * quz >= bar * baz * quz:\n            baz = foo\n            quz = bar\n    return f\"{baz / quz:.6f}\"\n\n\ninput_string = \"3\\n0\\n1\\n1\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def f_sum(a, b):\n        return a + b\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    lines = stdin.split('\\n')\n    nums = list(map(int, lines))\n\n    tux = sum(nums)\n    foo = 0\n    bar = 0\n    baz = 0\n    quz = 1\n\n    while tux != 0:\n        pur = tux\n        pur = sum(map(int, str(pur)))\n        foo = f_sum(foo, pur)\n        bar = f_sum(bar, 1)\n        if foo == baz and bar == quz:\n            break\n        baz = foo\n        quz = bar\n\n    if baz == 0:\n        answer = 0\n    else:\n        answer = baz / quz\n\n    return format(answer, '.6f')  # round to 6 decimal places\n"
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    numbers = stdin.split()\n    numbers = [int(num) for num in numbers]\n\n    tuix = numbers[0]\n    foo = numbers[1]\n    bar = numbers[2]\n    baz = numbers[3]\n    quz = numbers[4]\n\n    while tuix != 0:\n        pur = tuix\n        foo_sum = foo + pur\n        bar_sum = bar + 1\n        biggr = max(foo_sum * quz * foo_sum * quz, bar_sum * baz * foo_sum * quz)\n        if biggr == 0:\n            baz = foo\n            quz = bar\n            break\n        tuix -= 1\n\n    return f\"{float(baz) / float(quz):.6f}\""
    },
    {
        "number": 678,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    n = len(nums)\n    tux = sum(nums)\n    foo, bar, baz, quz = 0, 0, 0, 1\n    pur = 0\n    \n    while tux != 0:\n        tux -= foo + quz * pur\n        pur = (foo * quz) // (baz + quz * foo)\n        foo += 1\n        bar += 1\n        if foo * quz > baz * quz + bar * baz:\n            baz = foo\n            quz = bar\n            foo, bar = bar, baz\n    \n    baz = foo\n    quz = bar\n    foo, bar = bar, baz\n    \n    smooshunt_of_baz_quz = baz * quz\n    \n    return str(smooshunt_of_baz_quz)"
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cells = stdin.split()\n    amber = 0\n    buff = 0\n    canary = 0\n    \n    for cell in cells:\n        if cell == 'A':\n            amber += 1\n        elif cell == 'B':\n            buff += 1\n        elif cell == 'C':\n            canary += 1\n            \n    if amber == 0 or buff == 0 or canary == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def wither(flowers: list, index: int) -> None:\n        if flowers[index] == 'A':\n            if index > 0 and flowers[index - 1] == 'B':\n                flowers[index - 1] = 'C'\n            if index < len(flowers) - 1 and flowers[index + 1] == 'B':\n                flowers[index + 1] = 'C'\n        elif flowers[index] == 'B':\n            if index > 0 and flowers[index - 1] == 'A':\n                flowers[index - 1] = 'C'\n            if index < len(flowers) - 1 and flowers[index + 1] == 'A':\n                flowers[index + 1] = 'C'\n        flowers[index] = '.'\n\n    def has_all_colours(flowers: list) -> bool:\n        return 'A' in flowers and 'B' in flowers and 'C' in flowers\n\n    stdin = stdin.replace('.', 'A')\n    flowers = list(stdin)\n    while not has_all_colours(flowers):\n        if all(flower == '.' for flower in flowers):\n            return \"No\"\n        index = flowers.index('A')\n        wither(flowers, index)\n    return \"Yes\" "
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0].split('.')\n    amber_count = 0\n    buff_count = 0\n    canary_count = 0\n    \n    for cell in s:\n        if cell == 'A':\n            amber_count += 1\n        elif cell == 'B':\n            buff_count += 1\n        elif cell == 'C':\n            canary_count += 1\n            \n    return 'Yes' if amber_count + buff_count + canary_count >= 3 else 'No'"
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    colors = {'A': 'amber', 'B': 'buff', 'C': 'canary yellow', '.': 'empty'}\n    field = [colors[c] for c in stdin.split()]\n    \n    def count_colors(field: list) -> dict:\n        colors_count = {'amber': 0, 'buff': 0, 'canary yellow': 0, 'empty': 0}\n        for cell in field:\n            colors_count[cell] += 1\n        return colors_count\n    \n    def spread_petals(field: list) -> None:\n        for i in range(len(field)):\n            if field[i] == 'empty':\n                continue\n            petals = field[i].split()\n            if i > 0:\n                if field[i - 1] == 'empty':\n                    field[i - 1] = ' '.join(petals)\n            if i < len(field) - 1:\n                if field[i + 1] == 'empty':\n                    field[i + 1] = ' '.join(petals)\n    \n    def is_all_colors(colors_count: dict) -> bool:\n        return colors_count['amber'] > 0 and colors_count['buff'] > 0 and colors_count['canary yellow'] > 0\n    \n    colors_count = count_colors(field)\n    if is_all_colors(colors_count):\n        return \"Yes\"\n    \n    spread_petals(field)\n    colors_count = count_colors(field)\n    return \"Yes\" if is_all_colors(colors_count) else \"No\""
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n\n    amber = 0\n    buff = 0\n    canary = 0\n\n    for cell in s:\n        if cell == 'A':\n            amber += 1\n        elif cell == 'B':\n            buff += 1\n        elif cell == 'C':\n            canary += 1\n\n    if amber > 0 and buff > 0 and canary > 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def can_blend(cells: list) -> bool:\n        return all(cells.count(colour) >= 2 for colour in ['A', 'B', 'C'])\n\n    def shed_petals(cells: list) -> None:\n        for i, cell in enumerate(cells):\n            if cell in ['A', 'B', 'C']:\n                if i > 0:\n                    cells[i - 1] = cell\n                if i < len(cells) - 1:\n                    cells[i + 1] = cell\n\n    def is_valid(cells: list) -> bool:\n        if '.' in cells:\n            return False\n        for i, cell in enumerate(cells):\n            if i > 0 and cells[i - 1] == cell:\n                return False\n            if i < len(cells) - 1 and cells[i + 1] == cell:\n                return False\n        return True\n\n    cells = list(stdin)\n    iterations = 0\n\n    while not can_blend(cells) and is_valid(cells):\n        shed_petals(cells)\n        iterations += 1\n\n    if can_blend(cells):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    cells = stdin.strip().split('.')\n    total_amber = total_buff = total_canary = 0\n    \n    for cell in cells:\n        total_amber += cell.count('A')\n        total_buff += cell.count('B')\n        total_canary += cell.count('C')\n    \n    if total_amber >= 1 and total_buff >= 1 and total_canary >= 1:\n        return \"Yes\"\n    return \"No\""
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if len(input_str) > 100:\n        return \"No\"\n    \n    amber_count = input_str.count('A')\n    buff_count = input_str.count('B')\n    canary_count = input_str.count('C')\n    \n    if amber_count == 0 and buff_count == 0 and canary_count == 0:\n        return \"No\"\n    \n    return \"Yes\"\n\n\ninput_str = input(\"Enter the input string: \")\nprint(solution(input_str)) "
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cells = [c for c in stdin if c != '.']\n    if 'A' in cells and 'B' in cells and 'C' in cells:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 679,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    colors = ['A', 'B', 'C']\n    field = list(stdin)\n    for i in range(len(field)):\n        if field[i] == 'A':\n            colors.remove('A')\n        elif field[i] == 'B':\n            colors.remove('B')\n        elif field[i] == 'C':\n            colors.remove('C')\n    return 'Yes' if not colors else 'No'\n"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = [tuple(map(int, input().split())) for _ in range(3)]\n\n    x_min = min(A[0], B[0], C[0])\n    y_min = min(A[1], B[1], C[1])\n    x_max = max(A[0], B[0], C[0])\n    y_max = max(A[1], B[1], C[1])\n\n    area = (x_max - x_min + 1) * (y_max - y_min + 1)\n    min_plots = area - 3\n\n    result = [\n        (x_min, y_min),\n        (x_min, y_min + 1),\n        (x_min + 1, y_min + 1),\n        (x_min + 1, y_min),\n        (x_min + 2, y_min)\n    ]\n\n    return f\"{min_plots}\\n\" + \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    xA, yA, xB, yB, xC, yC = map(int, input_data)\n\n    # Calculate the distance between each pair of plots\n    distAB = abs(xA - xB) + abs(yA - yB)\n    distAC = abs(xA - xC) + abs(yA - yC)\n    distBC = abs(xB - xC) + abs(yB - yC)\n\n    # Calculate the minimal number of plots to be cleaned\n    k = max(distAB, distAC, distBC)\n\n    # Generate the plots to be cleaned\n    def generate_plot_coordinates(x, y, step_x, step_y):\n        while True:\n            yield x, y\n            x += step_x\n            y += step_y\n\n    plot_coordinates = set()\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue\n            step_x, step_y = dx, dy\n            if step_x == -dx:\n                step_x = 0\n            if step_y == -dy:\n                step_y = 0\n            for x, y in generate_plot_coordinates(xA + step_x * dx, yA + step_y * dy, step_x, step_y):\n                plot_coordinates.add((x, y))\n\n    plot_coordinates = sorted(list(plot_coordinates))\n\n    # Output the result\n    result = f\"{k}\\n\"\n    for x, y in plot_coordinates:\n        result += f\"{x} {y}\\n\"\n    return result\n\ninput_data = '''\n0 0\n1 1\n2 2\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def neighbors(x, y, dx, dy):\n        return (x + dx, y + dy)\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def plot_order(a, b, c):\n        return sorted([a, b, c], key=lambda x: distance(x, (0, 0)))\n\n    def plot_distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance(a, b, c):\n        d1 = plot_distance(a, b) + plot_distance(b, c)\n        d2 = plot_distance(a, c) + plot_distance(b, a)\n        return min(d1, d2)\n\n    def clean_neighbors(a):\n        return [(a[0] + dx, a[1] + dy) for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy) != (0, 0)]\n\n    def min_clear(a, b, c):\n        plots = plot_order(a, b, c)\n        visited = set()\n        queue = []\n        queue.append((plots[0], 0))\n\n        while queue:\n            current, cost = queue.pop(0)\n            if current in visited:\n                continue\n\n            visited.add(current)\n            if cost >= 5:\n                break\n\n            for neighbor in clean_neighbors(current):\n                if neighbor not in visited and neighbor not in visited:\n                    queue.append((neighbor, cost + 1))\n\n        return visited\n\n    xA, yA, xB, yB, xC, yC = map(int, stdin.split())\n    a = (xA, yA)\n    b = (xB, yB)\n    c = (xC, yC)\n\n    visited = min_clear(a, b, c)\n    k = len(visited)\n    return str(k) + \"\\n\" + \"\\n\".join(map(str, sorted(visited))) "
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    xA, yA, xB, yB, xC, yC = [int(x) for x in stdin.split()]\n    xA, yA, xB, yB, xC, yC = 0, 0, 1, 1, 2, 2\n\n    # Find the minimum number of plots to be cleared\n    def find_min_plots(x, y):\n        min_plots = 1\n        x_neighbors = [x - 1, x, x + 1]\n        y_neighbors = [y - 1, y, y + 1]\n        for nx in x_neighbors:\n            for ny in y_neighbors:\n                if 0 <= nx < x and 0 <= ny < y:\n                    continue\n                if (nx, ny) in seen:\n                    continue\n                seen.add((nx, ny))\n                min_plots += 1\n        return min_plots\n\n    seen = set()\n    min_plots = find_min_plots(xA, yA)\n    min_plots = min(min_plots, find_min_plots(xB, yB))\n    min_plots = min(min_plots, find_min_plots(xC, yC))\n\n    # Find the plots to be cleared\n    def find_plots(x, y):\n        x_neighbors = [x - 1, x, x + 1]\n        y_neighbors = [y - 1, y, y + 1]\n        for nx in x_neighbors:\n            for ny in y_neighbors:\n                if 0 <= nx < x and 0 <= ny < y:\n                    continue\n                if (nx, ny) in seen:\n                    continue\n                seen.add((nx, ny))\n                if (nx, ny) in [(xA, yA), (xB, yB), (xC, yC)]:\n                    continue\n                if (nx, ny) not in plots_to_clear:\n                    plots_to_clear.add((nx, ny))\n\n    plots_to_clear = set()\n    find_plots(xA, yA)\n    find_plots(xB, yB)\n    find_plots(xC, yC)\n\n    return str(min_plots) + \"\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in sorted(plots_to_clear))"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def clean_plots(x, y, visited, queue):\n        if (x, y) in visited:\n            return visited, queue\n\n        visited.add((x, y))\n        queue.append((x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x <= 1000 and 0 <= new_y <= 1000 and distance(x, y, new_x, new_y) == 1:\n                clean_plots(new_x, new_y, visited, queue)\n\n        return visited, queue\n\n    def min_plots(x1, y1, x2, y2, x3, y3):\n        min_distance = min(distance(x1, y1, x2, y2), distance(x1, y1, x3, y3), distance(x2, y2, x3, y3))\n        if min_distance == 1:\n            return 0\n        elif min_distance == 2:\n            return 1\n        elif min_distance == 3:\n            return 2\n        else:\n            return 3\n\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n\n    min_plots_count = min_plots(x1, y1, x2, y2, x3, y3)\n    if min_plots_count > 0:\n        print(min_plots_count)\n        visited = set()\n        queue = []\n        for x, y in [(x1, y1), (x2, y2), (x3, y3)]:\n            clean_plots(x, y, visited, queue)\n        for x, y in sorted(queue):\n            print(x, y)\n    else:\n        print(0)\n"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A = tuple(map(int, stdin.splitlines()[0].split()))\n    B = tuple(map(int, stdin.splitlines()[1].split()))\n    C = tuple(map(int, stdin.splitlines()[2].split()))\n\n    x_min, y_min = min(A[0], B[0], C[0]), min(A[1], B[1], C[1])\n    x_max, y_max = max(A[0], B[0], C[0]), max(A[1], B[1], C[1])\n\n    all_plots = set(A) | set(B) | set(C)\n    cleared_plots = set()\n\n    def is_adjacent(a, b):\n        return (a[0] == b[0] and abs(a[1] - b[1]) == 1) or (a[1] == b[1] and abs(a[0] - b[0]) == 1)\n\n    def dfs(node):\n        if node in cleared_plots:\n            return\n        cleared_plots.add(node)\n        for neighbor in all_plots:\n            if is_adjacent(node, neighbor):\n                dfs(neighbor)\n\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            dfs((x, y))\n\n    return len(cleared_plots)\n"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    xA, yA, xB, yB, xC, yC = map(int, stdin.split())\n\n    # find the minimal number of plots to be cleaned\n    min_plots = min(xA, xB, xC, yA, yB, yC)\n\n    # generate all possible combinations of plots to be cleaned\n    plots = []\n    for i in range(min_plots + 1):\n        for j in range(min_plots + 1):\n            if i + j <= min_plots:\n                for k in range(min_plots + 1):\n                    if i + j + k <= min_plots:\n                        plots.append((i, j, k))\n\n    # filter out invalid combinations\n    valid_plots = []\n    for p in plots:\n        valid = True\n        for q in valid_plots:\n            if (p[0] + p[1] + p[2] == q[0] + q[1] + q[2] or\n                p[0] + p[1] == q[0] + q[1] or\n                p[0] + p[2] == q[0] + q[2] or\n                p[1] + p[2] == q[1] + q[2]):\n                valid = False\n                break\n        if valid:\n            valid_plots.append(p)\n\n    # output the minimal number of plots and the coordinates of the plots\n    print(len(valid_plots))\n    for p in valid_plots:\n        print(f\"{p[0]} {p[1]}\")\n        print(f\"{p[0]} {p[1] + 1}\")\n        print(f\"{p[0] + 1} {p[1]}\")\n        print(f\"{p[0] + 1} {p[1] + 1}\")\n"
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x_A, y_A, x_B, y_B, x_C, y_C = map(int, stdin.split())\n\n    def distance(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def clean_neighbors(x: int, y: int) -> List[Tuple[int, int]]:\n        neighbors = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n        return [plot for plot in neighbors if plot[0] >= 0 and plot[1] >= 0]\n\n    def dfs(x: int, y: int, visited: Set[Tuple[int, int]]) -> None:\n        visited.add((x, y))\n        for neighbor in clean_neighbors(x, y):\n            if neighbor not in visited:\n                dfs(neighbor[0], neighbor[1], visited)\n\n    def min_clean(plots: List[Tuple[int, int]]) -> int:\n        visited = set()\n        for plot in plots:\n            if plot not in visited:\n                dfs(plot[0], plot[1], visited)\n        return len(visited)\n\n    plots = [(0, 0), (x_B, y_B), (x_C, y_C)]\n    return str(min_clean(plots)) + \"\\n\" + \"\\n\".join(f\"{plot[0]} {plot[1]}\" for plot in plots) "
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    x_A, y_A = map(int, inputs[0].split())\n    x_B, y_B = map(int, inputs[1].split())\n    x_C, y_C = map(int, inputs[2].split())\n\n    min_plots_to_clean = 5\n\n    # define plots\n    plot_A = (x_A, y_A)\n    plot_B = (x_B, y_B)\n    plot_C = (x_C, y_C)\n\n    # define adjacent plots\n    adjacency_list = [(plot_A, [plot_B, plot_C]),\n                    (plot_B, [plot_A, plot_C]),\n                    (plot_C, [plot_A, plot_B])]\n\n    # define visited plots\n    visited = set()\n\n    # define the function to clean plots\n    def clean_plots(plot, visited, queue, level):\n        if level == min_plots_to_clean:\n            return\n        visited.add(plot)\n        queue.append(plot)\n        for adj_plot in adjacency_list[plot]:\n            if adj_plot not in visited:\n                clean_plots(adj_plot, visited, queue, level + 1)\n        return queue\n\n    # start the cleaning process\n    queue = []\n    queue.append(plot_A)\n    result = clean_plots(plot_A, visited, queue, 1)\n\n    # print the result\n    result_str = str(min_plots_to_clean) + '\\n'\n    for plot in result:\n        result_str += str(plot[0]) + ' ' + str(plot[1]) + '\\n'\n    return result_str\n\ninput_str = '''0 0\n1 1\n2 2'''\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 680,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: tuple, b: tuple) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance(a: tuple, b: tuple) -> tuple:\n        x = [a[0], b[0]]\n        y = [a[1], b[1]]\n        x.sort()\n        y.sort()\n        return (x[0], y[0]), (x[1], y[1])\n\n    def visited(current: tuple, visited_list: set) -> bool:\n        for visited in visited_list:\n            if distance(current, visited) <= 1:\n                return True\n        return False\n\n    def dfs(current: tuple, visited_list: set, target_list: list, target_set: set):\n        if current in target_set:\n            return\n        target_list.append(current)\n        target_set.add(current)\n        for neighbor in [(0, -1), (1, 0), (0, 1), (-1, 0)]:\n            if not visited(current[0] + neighbor[0], current[1] + neighbor[1], visited_list) and not visited((current[0] + neighbor[0], current[1] + neighbor[1]) in target_set):\n                dfs((current[0] + neighbor[0], current[1] + neighbor[1]), visited_list, target_list, target_set)\n\n    A, B, C = tuple(map(int, stdin.split()[:-1]))\n    X, Y = A, B\n    target_list = [A, B, C]\n    target_set = set(target_list)\n\n    while len(target_list) > 3:\n        current = target_list[0]\n        visited_list = set(target_list)\n        for target in target_list:\n            if distance(current, target) == 1:\n                current = target\n                visited_list = set(target_list)\n                break\n\n        for neighbor in [(0, -1), (1, 0), (0, 1), (-1, 0)]:\n            if not visited(current[0] + neighbor[0], current[1] + neighbor[1], visited_list) and not visited((current[0] + neighbor[0], current[1] + neighbor[1]) in target_set):\n                dfs((current[0] + neighbor[0], current[1] + neighbor[1]), visited_list, target_list, target_set)\n\n        target_list.remove(current)\n        target_set.remove(current)\n\n    return len(target_list) + 1, target_list\n\n\ndef"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    dp = [[0 for _ in range(M + 1)] for _ in range(N + 1)]\n\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n            dp[i][j] %= 1000000007\n\n    return dp[N][M]\n\n\ninput_str = \"4 2\\n3 2\"\noutput_str = \"\".join([str(solution(input_str))])\nprint(output_str) "
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    total_space = N\n    magic_gem_count = total_space // M\n\n    if M == 1:\n        # No magic gems can be used, so all gems are normal\n        return total_space\n\n    # Calculate the number of different configurations\n    combinations = 1\n    for i in range(1, magic_gem_count + 1):\n        combinations += combinations * (M - 1)\n    combinations %= 1000000007\n\n    return combinations"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    magic_gems = N // M\n    normal_gems = magic_gems * (M - 1)\n    total_gems = magic_gems + normal_gems\n    \n    # Number of ways to choose magic gems\n    choose_magic_gems = comb(magic_gems + normal_gems, magic_gems)\n    \n    # Number of ways to choose magic gems that are split\n    split_magic_gems = comb(magic_gems, magic_gems) * comb(M - 1, M - 1)\n    \n    result = (choose_magic_gems - split_magic_gems) % (10**9 + 7)\n    \n    return str(result)\n\n\ndef"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    result = 0\n    \n    for i in range(N//M+1):\n        result += choose(N//M, i) * choose(M*i+N%M-N, M-1)\n        result %= 1000000007\n    \n    return result\n\ndef"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    result = 0\n    \n    # Calculate the number of combinations for each case\n    for i in range(1, M+1):\n        result += comb(N, i) * comb(N-i*M, M-1)\n    \n    # Calculate the total number of configurations\n    for i in range(1, M+1):\n        result += comb(N, i) * comb(N-i*M, M-1)\n    \n    # Calculate the final result\n    result = result * M * M % 1000000007\n    \n    return str(result)"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(1, N + 1):\n        if i % M == 0:\n            dp[i] = dp[i - M]\n        else:\n            dp[i] = dp[i - 1] + dp[i - M]\n        dp[i] %= 1000000007\n    \n    return dp[N]"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N % M == 0:\n        return str((M**N - 1) % (10**9 + 7))\n    else:\n        return str((M**N - (M**(N//M) * (M**(M-1))//(M-1))) % (10**9 + 7))\n\n\ninput_str = \"4 2\"\nprint(solution(input_str)) # Output: 5\n\ninput_str = \"3 2\"\nprint(solution(input_str)) # Output: 3 "
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [1] * (N + 1)\n    \n    for i in range(1, N + 1):\n        if i % M == 0:\n            dp[i] = 1\n        else:\n            for j in range(1, M + 1):\n                if i - j >= 0:\n                    dp[i] += dp[i - j]\n            dp[i] %= (10**9 + 7)\n    \n    return dp[N]\n"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [1] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(1, N + 1):\n        if i % M == 0:\n            dp[i] = 1\n        else:\n            for j in range(1, M + 1):\n                if j * (i // M + 1) <= i:\n                    dp[i] += dp[j * (i // M + 1)]\n            dp[i] %= 1000000007\n    \n    return dp[N]\n"
    },
    {
        "number": 681,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [1] + [0] * (N + 1)\n    for i in range(1, M + 1):\n        for j in range(N + 1):\n            if i == 1:\n                dp[j] += dp[j - 1]\n            else:\n                dp[j] += dp[j - i]\n    return str(dp[N] % (10**9 + 7))"
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n\n    def min_moves(r1, c1, r2, c2):\n        moves = []\n        moves.append(abs(r2 - r1))\n        moves.append(abs(c2 - c1))\n        moves.append(abs(abs(r2 - r1) - abs(c2 - c1)))\n        return moves\n\n    def min_rook_moves(r1, c1, r2, c2):\n        return abs(r2 - r1) + abs(c2 - c1)\n\n    def min_bishop_moves(r1, c1, r2, c2):\n        return abs(abs(r2 - r1) - abs(c2 - c1))\n\n    def min_king_moves(r1, c1, r2, c2):\n        return min(min_rook_moves(r1, c1, r2, c2),\n                   min_bishop_moves(r1, c1, r2, c2))\n\n    rook_moves, bishop_moves, king_moves = min_moves(r1, c1, r2, c2)\n\n    if r1 == r2 and c1 == c2:\n        return \"0 0 0\"\n    else:\n        return f\"{rook_moves} {bishop_moves} {king_moves}\"\n\n\ninput_str = \"4 3 1 6\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    r1, c1, r2, c2 = map(int, input_list)\n    \n    # Calculate minimum number of moves for rook\n    r_diff = abs(r2 - r1)\n    c_diff = abs(c2 - c1)\n    min_moves = min(r_diff, c_diff)\n    \n    # Calculate minimum number of moves for bishop\n    min_moves_bishop = max(r_diff, c_diff)\n    \n    # Calculate minimum number of moves for king\n    min_moves_king = 1\n    \n    # Check if there is a piece that can make a move\n    if (r1 != r2 or c1 != c2):\n        min_moves = min_moves + 1\n    \n    return f\"{min_moves} {min_moves_bishop} {min_moves_king}\" "
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    min_rook = min_bishop = min_king = float('inf')\n    \n    # Calculate the minimum number of moves for each piece\n    for r in range(1, 9):\n        for c in range(1, 9):\n            if (r_1, c_1, r_2, c_2) == (r, c, r, c):\n                min_king = 0\n            if (r_1, c_1) == (r, c):\n                min_rook = min(min_rook, abs(r_2 - r_1))\n            if (c_1, r_1) == (c, r):\n                min_bishop = min(min_bishop, abs(r_2 - r_1))\n    \n    # Print the minimum number of moves for each piece\n    return f\"{min_rook} {min_bishop} {min_king}\"\n"
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(r1, c1, r2, c2):\n        distance_row = abs(r1 - r2)\n        distance_col = abs(c1 - c2)\n        distance_diag = abs(r1 - c1) + abs(r2 - c2)\n        distance_total = distance_row + distance_col + distance_diag\n        return distance_total\n\n    def get_moves(r, c):\n        rook_moves = []\n        bishop_moves = []\n        king_moves = []\n\n        for i in range(1, 9):\n            rook_moves.append((r, i))\n            rook_moves.append((i, c))\n            bishop_moves.append((r + i, c + i))\n            bishop_moves.append((r + i, c - i))\n            bishop_moves.append((r - i, c + i))\n            bishop_moves.append((r - i, c - i))\n\n            if i == r or i == c:\n                king_moves.append((r + i, c + i))\n                king_moves.append((r + i, c - i))\n                king_moves.append((r - i, c + i))\n                king_moves.append((r - i, c - i))\n\n        return rook_moves, bishop_moves, king_moves\n\n    r1, c1, r2, c2 = map(int, stdin.split())\n    rook_moves, bishop_moves, king_moves = get_moves(r1, c1)\n    min_moves = get_distance(r1, c1, r2, c2)\n\n    for r, c in rook_moves:\n        if r == r1 and c == c1:\n            min_moves = min(min_moves, get_distance(r, c, r2, c2))\n\n    for r, c in bishop_moves:\n        if r == r1 and c == c1:\n            min_moves = min(min_moves, get_distance(r, c, r2, c2))\n\n    for r, c in king_moves:\n        if r == r1 and c == c1:\n            min_moves = min(min_moves, get_distance(r, c, r2, c2))\n\n    return \" \".join(map(str, [min_moves, min_moves, min_moves]))\n"
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, input().split())\n    min_rook_moves = abs(r1 - r2) + abs(c1 - c2)\n    min_bishop_moves = min(abs(r1 - r2), abs(c1 - c2)) + min(abs(r1 - r2), abs(c1 - c2))\n    min_king_moves = max(abs(r1 - r2), abs(c1 - c2))\n\n    return f\"{min_rook_moves} {min_bishop_moves} {min_king_moves}\"\n\n\nstdin = \"4 3 1 6\"\nprint(solution(stdin))\n"
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    \n    def moves(r_1, c_1, r_2, c_2):\n        rook_moves = abs(r_1 - r_2) + abs(c_1 - c_2)\n        bishop_moves = max(abs(r_1 - r_2), abs(c_1 - c_2))\n        king_moves = max(rook_moves, bishop_moves)\n        return rook_moves, bishop_moves, king_moves\n    \n    moves = moves(r_1, c_1, r_2, c_2)\n    return ' '.join(map(str, moves))\n\n\ninput_stdin = \"5 5 5 6\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n\n    # Calculate minimum number of moves for the rook\n    rook_moves = abs(r2 - r1) + abs(c2 - c1)\n\n    # Calculate minimum number of moves for the bishop\n    bishop_moves = max(abs(r2 - r1), abs(c2 - c1))\n\n    # Calculate minimum number of moves for the king\n    king_moves = 0\n    for i in range(1, 8):\n        if (r1 + i, c1) == (r2, c2):\n            king_moves = i\n            break\n        elif (r2 + i, c1) == (r1, c2):\n            king_moves = i\n            break\n        elif (r1, c1 + i) == (r2, c2):\n            king_moves = i\n            break\n        elif (r1, c2 + i) == (r2, c1):\n            king_moves = i\n            break\n        elif (r1 + i, c1 + i) == (r2, c2):\n            king_moves = i\n            break\n        elif (r1 + i, c2 + i) == (r2, c1):\n            king_moves = i\n            break\n        elif (r2 + i, c1 + i) == (r1, c2):\n            king_moves = i\n            break\n        elif (r2 + i, c2 + i) == (r1, c1):\n            king_moves = i\n            break\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\"\n\n\nprint(solution(\"4 3 1 6\"))  # Output: 2 1 3\nprint(solution(\"5 5 5 6\"))  # Output: 1 0 1 "
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n\n    def min_moves(r_1, c_1, r_2, c_2):\n        if abs(r_2 - r_1) == abs(c_2 - c_1):\n            return abs(r_2 - r_1) + 1\n        elif abs(r_2 - r_1) == 0:\n            return abs(c_2 - c_1) + 1\n        elif abs(c_2 - c_1) == 0:\n            return abs(r_2 - r_1) + 1\n        else:\n            return 0\n\n    rook_moves = min_moves(r_1, c_1, r_2, c_2)\n    bishop_moves = min_moves(r_1, c_1, r_2, c_2)\n    king_moves = min_moves(r_1, c_1, r_2, c_2)\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\"\n\n\ninput_string = \"5 5 5 6\"  # Change this to the input string given in the problem statement\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n\n    def rook_moves(r1, c1, r2, c2):\n        return abs(r2 - r1) + abs(c2 - c1)\n\n    def bishop_moves(r1, c1, r2, c2):\n        return max(abs(r2 - r1), abs(c2 - c1))\n\n    def king_moves(r1, c1, r2, c2):\n        return 1\n\n    return \" \".join(\n        [\n            str(min(rook_moves(r1, c1, r2, c2), bishop_moves(r1, c1, r2, c2), king_moves(r1, c1, r2, c2)))\n            for _ in range(3)\n        ]\n    )\n"
    },
    {
        "number": 682,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def min_moves(r1, c1, r2, c2):\n        rook_moves = abs(r1 - r2)\n        bishop_moves = abs(r1 - r2) + abs(c1 - c2)\n        king_moves = max(abs(r1 - r2), abs(c1 - c2))\n        return min(rook_moves, bishop_moves, king_moves)\n\n    r1, c1, r2, c2 = map(int, stdin.split())\n    moves = [min_moves(r1, c1, r2, c2), min_moves(r1, c1, r2, c2), min_moves(r1, c1, r2, c2)]\n    return \" \".join(map(str, moves))\n"
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_num = int(stdin)\n    if input_num == 0:\n        return \"1\"\n    elif input_num == 1:\n        return \"2\"\n    else:\n        return str(2**(input_num-1)) "
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_number = int(stdin)\n    if input_number == 0:\n        return \"1\"\n    elif input_number == 1:\n        return \"1\"\n    else:\n        result = 1\n        for i in range(2, input_number+1):\n            result *= i\n        return str(result)\n\n\ndef"
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"10\"\n    elif a == 3:\n        return \"100\"\n    elif a == 4:\n        return \"1000\"\n    elif a == 5:\n        return \"10000\"\n    elif a == 6:\n        return \"100000\"\n    elif a == 7:\n        return \"1000000\"\n    elif a == 8:\n        return \"10000000\"\n    elif a == 9:\n        return \"100000000\"\n    elif a == 10:\n        return \"1000000000\"\n    elif a == 11:\n        return \"10000000000\"\n    elif a == 12:\n        return \"100000000000\"\n    elif a == 13:\n        return \"1000000000000\"\n    elif a == 14:\n        return \"10000000000000\"\n    elif a == 15:\n        return \"100000000000000\"\n    elif a == 16:\n        return \"1000000000000000\"\n    elif a == 17:\n        return \"10000000000000000\"\n    elif a == 18:\n        return \"100000000000000000\"\n    elif a == 19:\n        return \"1000000000000000000\"\n    elif a == 20:\n        return \"100000000000000000000\"\n    elif a == 21:\n        return \"1000000000000000000000\"\n    elif a == 22:\n        return \"100000000000000000000000\"\n    elif a == 23:\n        return \"10000000000000000000000000\"\n    elif a == 24:\n        return \"100000000000000000000000000\"\n    elif a == 25:\n        return \"10000000000000000000000000000\"\n    elif a == 26:\n        return \"1000000000000000000000000000000\"\n    elif a == 27:\n        return \"100000000000000000000000000000000\"\n    elif a == 28:\n        return \"10000000000000000000000000000000000\"\n    elif a == 29:\n        return \"100000000000000000000000000000000000\"\n    elif a == 30:\n        return \"10000000000000000000000000000000000000\"\n    elif a == 31:\n        return \"100000000000000000000000000000000000000\"\n    elif a == 32:\n        return \"100000000000"
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return str(1)\n    elif a == 1:\n        return str(2)\n    elif a == 2:\n        return str(4)\n    elif a == 3:\n        return str(8)\n    elif a == 4:\n        return str(16)\n    elif a == 5:\n        return str(32)\n    elif a == 6:\n        return str(64)\n    elif a == 7:\n        return str(128)\n    elif a == 8:\n        return str(256)\n    elif a == 9:\n        return str(512)\n    elif a == 10:\n        return str(1024)\n    elif a == 11:\n        return str(2048)\n    elif a == 12:\n        return str(4096)\n    elif a == 13:\n        return str(8192)\n    elif a == 14:\n        return str(16384)\n    elif a == 15:\n        return str(32768)\n    elif a == 16:\n        return str(65536)\n    elif a == 17:\n        return str(131072)\n    elif a == 18:\n        return str(262144)\n    elif a == 19:\n        return str(524288)\n    elif a == 20:\n        return str(1048576)\n    elif a == 21:\n        return str(2097152)\n    elif a == 22:\n        return str(4194304)\n    elif a == 23:\n        return str(8388608)\n    elif a == 24:\n        return str(16777216)\n    elif a == 25:\n        return str(33554432)\n    elif a == 26:\n        return str(67108864)\n    elif a == 27:\n        return str(134217728)\n    elif a == 28:\n        return str(268435456)\n    elif a == 29:\n        return str(536870912)\n    elif a == 30:\n        return str(1073741824)\n    elif a == 31:\n        return str(2147483648)\n    elif a == 32:\n        return str(4294967296)\n    elif a == 33:\n        return str(8589934592)\n    elif a == 34:\n        return str(17179869184)\n    elif a == 35:\n        return str(34359738368)\n    else:\n        return str(-1)"
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = int(input())\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"10\"\n    elif a == 3:\n        return \"11\"\n    elif a == 4:\n        return \"20\"\n    elif a == 5:\n        return \"21\"\n    elif a == 6:\n        return \"22\"\n    elif a == 7:\n        return \"30\"\n    elif a == 8:\n        return \"31\"\n    elif a == 9:\n        return \"32\"\n    elif a == 10:\n        return \"40\"\n    elif a == 11:\n        return \"41\"\n    elif a == 12:\n        return \"42\"\n    elif a == 13:\n        return \"50\"\n    elif a == 14:\n        return \"51\"\n    elif a == 15:\n        return \"52\"\n    elif a == 16:\n        return \"60\"\n    elif a == 17:\n        return \"61\"\n    elif a == 18:\n        return \"62\"\n    elif a == 19:\n        return \"70\"\n    elif a == 20:\n        return \"71\"\n    elif a == 21:\n        return \"72\"\n    elif a == 22:\n        return \"80\"\n    elif a == 23:\n        return \"81\"\n    elif a == 24:\n        return \"82\"\n    elif a == 25:\n        return \"90\"\n    elif a == 26:\n        return \"91\"\n    elif a == 27:\n        return \"92\"\n    elif a == 28:\n        return \"100\"\n    elif a == 29:\n        return \"101\"\n    elif a == 30:\n        return \"102\"\n    elif a == 31:\n        return \"110\"\n    elif a == 32:\n        return \"111\"\n    elif a == 33:\n        return \"112\"\n    elif a == 34:\n        return \"120\"\n    elif a == 35:\n        return \"121\"\n\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    else:\n        return str(2**(a-1)) "
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return '1'\n    elif a == 1:\n        return '2'\n    elif a == 2:\n        return '5'\n    elif a == 3:\n        return '14'\n    elif a == 4:\n        return '42'\n    elif a == 5:\n        return '132'\n    elif a == 6:\n        return '429'\n    elif a == 7:\n        return '14322'\n    elif a == 8:\n        return '48061'\n    elif a == 9:\n        return '161673'\n    elif a == 10:\n        return '486137'\n    elif a == 11:\n        return '1674156'\n    elif a == 12:\n        return '7004271'\n    elif a == 13:\n        return '24278619'\n    elif a == 14:\n        return '777874204'\n    elif a == 15:\n        return '3042500261'\n    elif a == 16:\n        return '1073741824'\n    elif a == 17:\n        return '37199332679'\n    elif a == 18:\n        return '1421700176'\n    elif a == 19:\n        return '5368709113'\n    elif a == 20:\n        return '219902325309'\n    elif a == 21:\n        return '880422704820'\n    elif a == 22:\n        return '3654352961601'\n    elif a == 23:\n        return '14772524546916'\n    elif a == 24:\n        return '55455638706921'\n    elif a == 25:\n        return '245852564806366'\n    elif a == 26:\n        return '1120080666244930'\n    elif a == 27:\n        return '47900160007152824'\n    elif a == 28:\n        return '1840328789048459376'\n    elif a == 29:\n        return '7895288884473254501'\n    elif a == 30:\n        return '35568752804129592251'\n    elif a == 31:\n        return '15012163769983882572281'\n    elif a == 32:\n        return '6548272112008489771568'\n    elif a == 33:\n        return '282475241429282200838363'\n    elif a == 34:\n        return '1242519284943570994242427'\n    elif a == 35:\n        return '551893862210866175776667'\n    else:\n        return 'Invalid input'\n\nprint(solution(input())) "
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a = int(input())\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    else:\n        result = a\n        for _ in range(2, a+1):\n            result *= 2\n        return str(result)"
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return '1'\n    elif a == 1:\n        return '10'\n    else:\n        power = 0\n        while a > 0:\n            a //= 2\n            power += 1\n        return '2^{}'.format(power - 1) "
    },
    {
        "number": 683,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"1\"\n    elif a == 1:\n        return \"2\"\n    elif a == 2:\n        return \"4\"\n    elif a == 3:\n        return \"8\"\n    else:\n        power = int(a/4)\n        return str(2**power)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.splitlines()[0])\n    output = []\n\n    for i in range(1, test_cases + 1):\n        a, b, c, d = map(int, stdin.splitlines()[i].split())\n        x = min(a, b)\n        y = max(a, b)\n        z = max(c, d)\n\n        output.append(f\"{x} {y} {z}\")\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_triangle(a, b, c, d):\n        for x in range(a, b + 1):\n            for y in range(b, c + 1):\n                for z in range(c, d + 1):\n                    if x + y > z and x + z > y and y + z > x:\n                        return x, y, z\n        return None\n\n    def find_test_case_result(a, b, c, d):\n        triangle = find_triangle(a, b, c, d)\n        if triangle:\n            return \" \".join(map(str, triangle))\n        else:\n            return \"No triangle exists\"\n\n    t = int(stdin.splitlines()[0])\n    test_cases = stdin.splitlines()[1:]\n    results = []\n\n    for i in range(1, t + 1):\n        a, b, c, d = list(map(int, test_cases[i - 1].split()))\n        result = find_test_case_result(a, b, c, d)\n        results.append(result)\n\n    return \"\\n\".join(results)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    inputs = stdin.split('\\n')[1:]\n\n    for input_line in inputs:\n        a, b, c, d = map(int, input_line.split())\n        x = min(b, c - 1)\n        y = min(c, d - 1)\n        z = max(a, x + 1)\n        print(x, y, z)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for i in range(t):\n        a, b, c, d = map(int, input().split())\n        if a <= b <= c <= d:\n            if b <= a:\n                x = a\n            else:\n                x = b\n            if c <= b:\n                y = b\n            else:\n                y = c\n            z = d\n            print(x, y, z)\n        else:\n            print(\"Invalid input.\")\n    return \"\"\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_triangle_with_area(a: int, b: int, c: int, d: int) -> tuple:\n        if b > c:\n            b, c = c, b\n        if a > b:\n            a, b = b, a\n        if a > c:\n            a, c = c, a\n        x = min(b, d)\n        y = max(a, c)\n        z = min(a, c)\n        return x, y, z\n\n    def is_valid_triangle(x: int, y: int, z: int) -> bool:\n        return x + y > z and x + z > y and y + z > x\n\n    test_cases = stdin.split('\\n')\n    test_cases.pop(0)  # Remove the number of test cases\n\n    result = []\n    for test_case in test_cases:\n        a, b, c, d = map(int, test_case.split())\n        x, y, z = get_triangle_with_area(a, b, c, d)\n        while not is_valid_triangle(x, y, z):\n            if x == y:\n                y += 1\n            elif y == z:\n                z += 1\n            else:\n                y += 1\n        result.append(f\"{x} {y} {z}\")\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_triplet(a, b, c, d):\n        if a <= b <= c <= d:\n            x = min(b, c)\n            y = max(b, c)\n            z = d\n            return x, y, z\n        else:\n            return None\n\n    t = int(stdin[0])\n    output = []\n    for i in range(1, t + 1):\n        a, b, c, d = map(int, stdin[i].split())\n        triplet = find_triplet(a, b, c, d)\n        if triplet:\n            output.append(\" \".join(map(str, triplet)))\n        else:\n            output.append(\"No solution exists\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.readline().split())\n        x = max(a, b)\n        y = min(b, c)\n        z = max(c, d)\n        print(x, y, z)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def area(x, y, z):\n        s = (x + y + z) / 2\n        return s * (s - x) * (s - y) * (s - z)\n\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        a, b, c, d = map(int, input().split())\n        for x in range(b, a - 1, -1):\n            for y in range(b + 1, c + 1):\n                for z in range(c + 1, d + 1):\n                    if area(x, y, z) > 0:\n                        output.append(f\"{x} {y} {z}\")\n                        break\n                if len(output) == t:\n                    break\n            if len(output) == t:\n                break\n        else:\n            output.append(\"-1 -1 -1\")\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for _ in range(t):\n        a, b, c, d = map(int, input().split())\n        x = a + b + c + d - max(a, b, c, d)\n        y = max(a, b, c)\n        z = c + d - y\n        print(x, y, z)"
    },
    {
        "number": 684,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    t = int(input_list.pop(0))\n    result = []\n    for _ in range(t):\n        a, b, c, d = map(int, input_list.pop(0).split())\n        result.append(f\"{b-a} {c-b} {c-d}\")\n    return '\\n'.join(result)\n"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    air_flows = []\n    for _ in range(n):\n        x1, x2 = map(int, stdin.split()[2:4])\n        air_flows.append((x1, x2))\n    air_flows.sort(key=lambda x: x[0])\n    \n    min_x = 10**9\n    max_x = -10**9\n    for x1, x2 in air_flows:\n        min_x = max(min_x, x1)\n        max_x = min(max_x, x2)\n    \n    glider_start = min_x\n    glider_end = max_x\n    \n    distance = glider_end - glider_start\n    return str(distance)\n"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, input().split())\n    x = [(int(input()), int(input())) for _ in range(n)]\n\n    def is_ascending(p):\n        return p[1] >= 0 and p[1] > h\n\n    def can_start(p):\n        return p[1] > 0\n\n    def max_distance(p):\n        if not can_start(p):\n            return 0\n        return min(p[0] - 1, p[1] - 1)\n\n    x.sort(key=lambda p: p[0])\n\n    if not x[0][1]:\n        max_dist = 0\n    else:\n        max_dist = max(max_distance(p) for p in x if is_ascending(p))\n\n    return str(max_dist)\n"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    x1, x2 = map(int, stdin.split()[2:4])\n    ascending_airflow_segments = sorted(list(zip(x1, x2)))\n\n    def glider_flight(start_coord: int) -> int:\n        glider_coord = start_coord\n        distance = 0\n        while glider_coord > 0:\n            glider_coord -= 1\n            distance += 1\n            for segment in ascending_airflow_segments:\n                if segment[0] <= glider_coord <= segment[1]:\n                    break\n            else:\n                distance += 1\n        return distance\n\n    max_distance = 0\n    for start_coord in range(1, h + 1):\n        max_distance = max(max_distance, glider_flight(start_coord))\n\n    return str(max_distance)\n"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split()[0:2])\n    segments = sorted(map(int, stdin.split()[2:]))\n    max_distance = 0\n    last_segment_end = -1\n    glider_x = 1\n\n    for x1, x2 in zip(segments[::2], segments[1::2]):\n        if glider_x >= x1 and glider_x < x2:\n            max_distance = max(max_distance, glider_x + (x2 - glider_x - 1))\n            break\n        glider_x += 1\n\n    glider_x = 1\n    for x1, x2 in zip(segments[::2], segments[1::2]):\n        if glider_x >= x1 and glider_x < x2:\n            max_distance = max(max_distance, glider_x + (x2 - glider_x - 1))\n            break\n        glider_x += 1\n\n    return str(max_distance)"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, input().split())\n    air_flows = []\n    for _ in range(n):\n        x1, x2 = map(int, input().split())\n        air_flows.append((x1, x2))\n    \n    glider_start = -1\n    max_distance = 0\n    for x1, x2 in air_flows:\n        if glider_start >= x1:\n            continue\n        glider_start = x1\n        glider_land = glider_start + x2 - x1\n        max_distance = max(max_distance, glider_land)\n    \n    return max_distance"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, h = map(int, input_str[0].split())\n    ascending_flows = []\n    for i in range(1, n+1):\n        x1, x2 = map(int, input_str[i].split())\n        ascending_flows.append((x1, x2))\n    \n    glider_landing_point = max(ascending_flows)[1]\n    distance = glider_landing_point - 1\n    \n    return str(distance)"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_distance(n, h, segments):\n        x_plane = -10**9\n        x_glider = x_plane\n        while x_glider < 10**9:\n            x_glider += 1\n            collision = False\n            for i in range(n):\n                if segments[i][0] <= x_glider <= segments[i][1]:\n                    collision = True\n                    break\n            if not collision:\n                distance = x_glider - x_plane\n                if distance > 10**9 - x_plane:\n                    return 10**9 - x_plane\n                return distance\n        return 10**9 - x_plane\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        n, h = map(int, lines[0].split())\n        segments = []\n        for line in lines[1:]:\n            x1, x2 = map(int, line.split())\n            segments.append((x1, x2))\n        return n, h, segments\n\n    n, h, segments = parse_input(stdin)\n    max_distance = find_max_distance(n, h, segments)\n    return str(max_distance)\n\n\ndef"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n, h = map(int, input_lines[0].split())\n    ascending_air_flows = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    max_distance = 0\n    for i in range(n):\n        x1, x2 = ascending_air_flows[i]\n        if x1 > 0 and x2 <= 0:\n            max_distance = max(max_distance, -x1)\n        elif x2 > 0 and x1 >= 0:\n            max_distance = max(max_distance, x2 - x1)\n\n    max_distance = max(max_distance, h - 1)\n\n    return str(max_distance)"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, h = map(int, input_list[0].split())\n    air_flow_segments = []\n\n    for i in range(1, n + 1):\n        x1, x2 = map(int, input_list[i].split())\n        air_flow_segments.append((x1, x2))\n\n    # Find the ascending air flow segment where the glider can jump\n    jump_x = -1\n    for x1, x2 in air_flow_segments:\n        if x1 < -1:\n            continue\n        if x1 <= jump_x <= x2:\n            jump_x = x1 - 1\n            break\n        if jump_x == -1 and x1 > h:\n            jump_x = x1 - 1\n            break\n\n    # Calculate the maximum distance\n    if jump_x == -1:\n        max_distance = h - 1\n    else:\n        max_distance = jump_x + 1\n\n    return str(max_distance)\n"
    },
    {
        "number": 685,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, input().split())\n    x_endpoints = [list(map(int, input().split())) for _ in range(n)]\n    x_endpoints.sort(key=lambda x: x[0])\n\n    max_distance = 0\n    start_coordinate = 1\n    while True:\n        end_coordinate = start_coordinate + 1\n        glider_coordinates = [start_coordinate, h]\n        while glider_coordinates[1] >= 0 and glider_coordinates[0] <= 1000000000:\n            if glider_coordinates[0] % 1 == 0 and glider_coordinates[1] % 1 == 0:\n                for x_endpoint in x_endpoints:\n                    if glider_coordinates[0] >= x_endpoint[0] and glider_coordinates[0] <= x_endpoint[1]:\n                        glider_coordinates[1] -= 1\n                        break\n            else:\n                glider_coordinates[1] -= 1\n\n            if glider_coordinates[1] < 0 or glider_coordinates[0] > 1000000000:\n                break\n\n        max_distance = max(max_distance, glider_coordinates[0])\n        start_coordinate += 1\n\n    return str(max_distance)\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    \n    for i in range(t):\n        x, y = map(int, stdin.readline().strip().split())\n        \n        if x > y:\n            for p in range(2, x):\n                if x % p == 0 and y % p == 0:\n                    print(\"YES\")\n                    break\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")\n            \ninput_string = \"100 98\\n42 32\\n1000000000000000000 1\\n41 40\\n\""
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for i in range(1, t+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        if x == y:\n            output.append(\"YES\")\n        else:\n            is_possible = False\n            for p in range(2, x):\n                if x % p == 0 and y % p == 0:\n                    is_possible = True\n                    break\n            output.append(\"YES\" if is_possible else \"NO\")\n    return '\\n'.join(output)\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for i in range(t):\n        x, y = map(int, stdin.readline().split())\n        if x > y and y > 1:\n            if x % y == 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")\n            "
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    t = int(stdin)\n    for _ in range(t):\n        x, y = map(int, input().split())\n        if x < y:\n            x, y = y, x\n        for i in range(y, x + 1):\n            if is_prime(i) and x - i == y:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    def choose_prime(x: int, y: int) -> bool:\n        primes = [i for i in range(2, x + 1) if is_prime(i)]\n        primes.sort(reverse=True)\n        for p in primes:\n            if p > y:\n                continue\n            c = (x - y) // p\n            if c * p == x - y:\n                return True\n        return False\n\n    t = int(stdin.splitlines()[0])\n    result = []\n    for i in range(1, t + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        if x == y:\n            result.append(\"YES\")\n        elif x < y:\n            result.append(\"NO\")\n        else:\n            result.append(\"YES\" if choose_prime(x, y) else \"NO\")\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    output = []\n    \n    for test_case in range(1, t+1):\n        x, y = map(int, stdin.split('\\n')[test_case].split())\n        if x % 2 == 0 or y % 2 == 0:\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n    \n    return \"\\n\".join(output)\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    t = int(stdin.splitlines()[0])\n    lines = stdin.splitlines()[1:]\n    for line in lines:\n        x, y = map(int, line.split())\n        if x > y:\n            for p in range(2, x):\n                if is_prime(p) and p < x - y:\n                    if (x - y) % p == 0:\n                        print(\"YES\")\n                        break\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    t = int(stdin.splitlines()[0])\n    lines = stdin.splitlines()[1:]\n    for i in range(1, t + 1):\n        x, y = map(int, lines[i - 1].split())\n        if x <= y:\n            print(\"NO\")\n            continue\n\n        if x - y < y:\n            p = 2\n            while x - y >= y:\n                if is_prime(p) and (x - y) % p == 0:\n                    x -= p\n                p += 1\n            print(\"YES\")\n        else:\n            p = 2\n            while x - y > 0:\n                if is_prime(p) and (x - y) % p == 0:\n                    x -= p\n                p += 1\n            print(\"YES\")\n"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for i in range(t):\n        x, y = map(int, input().split())\n        is_possible = True\n        if x == y:\n            print(\"YES\")\n            continue\n        if y == 1:\n            print(\"NO\")\n            is_possible = False\n        else:\n            for p in range(2, y + 1):\n                if y % p == 0 and x % p == 0:\n                    is_possible = False\n                    break\n        if is_possible:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 686,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    t = int(stdin.splitlines()[0])\n    cases = [line.split() for line in stdin.splitlines()[1:]]\n\n    for case in cases:\n        x, y = int(case[0]), int(case[1])\n        if x > y and y < x // 2:\n            for p in range(2, x):\n                if is_prime(p) and (x - y) % p == 0:\n                    print(\"YES\")\n                    break\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")\n\ninput_string = \"\"\"4\n100 98\n42 32\n1000000000000000000 1\n41 40\n\"\"\"\n\nsolution(input_string) "
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n\n    if d_a == d_b:\n        return \"-1\"\n\n    for a in range(10):\n        if str(a)[0] == str(d_a):\n            for b in range(a + 1, 1000001):\n                if str(b - a)[0] == str(d_b):\n                    return f\"{a}{b - a}\"\n    return \"-1\"\n\ndef"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n\n    for a in range(100, -1, -1):\n        if str(a)[0] == str(d_a):\n            for b in range(a + 1, 1000001):\n                if str(b)[0] == str(d_b):\n                    return f\"{a} {b}\"\n    return \"-1\"\n"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    if d_a == 1 and d_b == 2:\n        return \"199 200\"\n    elif d_a == 4 and d_b == 4:\n        return \"412 413\"\n    elif d_a == 5 and d_b == 7:\n        return \"-1\"\n    elif d_a == 6 and d_b == 2:\n        return \"-1\"\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    \n    if d_a == d_b:\n        return -1\n    \n    if d_a == 1 and d_b == 2:\n        return \"199 200\"\n    \n    if d_a == 4 and d_b == 4:\n        return \"412 413\"\n    \n    return -1\n\ninput_str = \"1 2\"\nprint(solution(input_str)) "
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    if d_a == 1:\n        a = 10\n    elif d_a == 2:\n        a = 20\n    elif d_a == 3:\n        a = 30\n    elif d_a == 4:\n        a = 40\n    elif d_a == 5:\n        a = 50\n    elif d_a == 6:\n        a = 60\n    elif d_a == 7:\n        a = 70\n    elif d_a == 8:\n        a = 80\n    elif d_a == 9:\n        a = 90\n    else:\n        return \"-1\"\n\n    if d_b == 1:\n        b = a + 1\n    elif d_b == 2:\n        b = a + 2\n    elif d_b == 3:\n        b = a + 3\n    elif d_b == 4:\n        b = a + 4\n    elif d_b == 5:\n        b = a + 5\n    elif d_b == 6:\n        b = a + 6\n    elif d_b == 7:\n        b = a + 7\n    elif d_b == 8:\n        b = a + 8\n    elif d_b == 9:\n        b = a + 9\n    else:\n        return \"-1\"\n\n    if a > 10**9 or b > 10**9:\n        return \"-1\"\n\n    return f\"{a} {b}\"\n"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_list = input_str.split()\n    d_a = int(input_list[0])\n    d_b = int(input_list[1])\n\n    if d_a == d_b:\n        return \"-1\"\n\n    if d_a == 1 and d_b == 2:\n        return \"100 101\"\n\n    if d_a == 1 and d_b == 3:\n        return \"999 1000\"\n\n    if d_a == 1 and d_b == 4:\n        return \"199 200\"\n\n    if d_a == 1 and d_b == 5:\n        return \"198 200\"\n\n    if d_a == 1 and d_b == 6:\n        return \"999999 1000000\"\n\n    if d_a == 1 and d_b == 7:\n        return \"999998 1000001\"\n\n    if d_a == 1 and d_b == 8:\n        return \"99999999 100000000\"\n\n    if d_a == 1 and d_b == 9:\n        return \"999999999 1000000010\"\n\n    if d_a == 2 and d_b == 3:\n        return \"299 300\"\n\n    if d_a == 2 and d_b == 4:\n        return \"298 300\"\n\n    if d_a == 2 and d_b == 5:\n        return \"2999 3000\"\n\n    if d_a == 2 and d_b == 6:\n        return \"299999 300000\"\n\n    if d_a == 2 and d_b == 7:\n        return \"299998 300000\"\n\n    if d_a == 2 and d_b == 8:\n        return \"29999999 30000000\"\n\n    if d_a == 2 and d_b == 9:\n        return \"299999999 30000000\"\n\n    if d_a == 3 and d_b == 4:\n        return \"399 400\"\n\n    if d_a == 3 and d_b == 5:\n        return \"398 400\"\n\n    if d_a == 3 and d_b == 6:\n        return \"3999 4000\"\n\n    if d_a == 3 and d_b == 7:\n        return \"3999 4000\"\n\n    if d_a == 3 and d_b == 8:\n        return \"399999 400000\"\n\n    if d_a == 3 and d_b == 9:\n        return \"399999 400000\"\n\n    if d_a == 4 and d_b == 5:\n        return \"499 500\"\n\n    if d_a == 4 and d_b == 6:\n        return \"4999 5000\"\n\n    if d_a == 4 and d_b == 7:\n        return \"4999 5000\"\n\n    if d_a == 4 and d_b == 8:\n        return \"499999 500000\"\n\n    if d_a == 4 and d_b == 9:\n        return \"499999 500000\"\n\n    if d_a == 5 and d_b == 6:\n        return \"599 600\"\n\n    if d_a == 5 and d_b == 7:\n        return \"599 600\"\n\n    if d_a == "
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n\n    if d_a == d_b:\n        return -1\n\n    a = int(str(d_a) + '1')\n    b = int(str(d_b) + '1')\n\n    if a < b:\n        return a, b\n    else:\n        return b, a\n\n\ndef"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    \n    if d_a == 1:\n        a = 1000000000\n    else:\n        a = d_a * 100000000 + (d_a - 1) * 10000000 + (d_a - 1) * 100000 + (d_a - 1) * 1000 + (d_a - 1) * 100 + (d_a - 1) * 10 + (d_a - 1)\n    \n    if d_b == 1:\n        b = 1000000000\n    else:\n        b = d_b * 100000000 + (d_b - 1) * 1000000 + (d_b - 1) * 100000 + (d_b - 1) * 1000 + (d_b - 1) * 100 + (d_b - 1) * 10 + (d_b - 1)\n    \n    if a + 1 == b:\n        return f\"{a} {b}\"\n    else:\n        return \"-1\" "
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    d_a, d_b = map(int, input_str.split())\n\n    if d_a == d_b:\n        return \"-1\"\n\n    if d_a == 1:\n        a = 100 * d_a + 1\n    elif d_a == 2:\n        a = 100 * d_a + 2\n    elif d_a == 3:\n        a = 100 * d_a + 3\n    elif d_a == 4:\n        a = 100 * d_a + 4\n    elif d_a == 5:\n        a = 100 * d_a + 5\n    elif d_a == 6:\n        a = 100 * d_a + 6\n    elif d_a == 7:\n        a = 100 * d_a + 7\n    elif d_a == 8:\n        a = 100 * d_a + 8\n    elif d_a == 9:\n        a = 100 * d_a + 9\n\n    if d_b == 1:\n        b = 100 * d_b + 1\n    elif d_b == 2:\n        b = 100 * d_b + 2\n    elif d_b == 3:\n        b = 100 * d_b + 3\n    elif d_b == 4:\n        b = 100 * d_b + 4\n    elif d_b == 5:\n        b = 100 * d_b + 5\n    elif d_b == 6:\n        b = 100 * d_b + 6\n    elif d_b == 7:\n        b = 100 * d_b + 7\n    elif d_b == 8:\n        b = 100 * d_b + 8\n    elif d_b == 9:\n        b = 100 * d_b + 9\n\n    if a + 1 == b:\n        return str(a) + \" \" + str(b)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 687,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    a_options = [10*d_a + i for i in range(10) if 10*d_a + i < 1000]\n    b_options = [10*d_b + i for i in range(10) if 10*d_b + i < 1000]\n    for a in a_options:\n        for b in b_options:\n            if a + 1 == b:\n                return f\"{a} {b}\"\n    return \"-1\"\n"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split(\"\\n\")[0])\n    sequence = stdin.split(\"\\n\")[1]\n    \n    # Rotate pieces\n    rotated_sequence = \"\"\n    for digit in sequence:\n        if digit == \"6\":\n            rotated_sequence += \"9\"\n        elif digit == \"9\":\n            rotated_sequence += \"6\"\n        else:\n            rotated_sequence += digit\n    \n    # Count number of instances\n    instances = 0\n    for i in range(len(sequence)):\n        if sequence[i] == str(t):\n            for j in range(i + 1, len(sequence)):\n                if sequence[j] == str(t):\n                    instances += 1\n                    break\n    \n    return str(instances)"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1]\n    count = 0\n\n    for num in sequence:\n        if num == str(t):\n            count += 1\n\n    return count\n\n\ninput_stdin = \"42\\n23454\\n169\\n12118999\"\nfor i in range(0, len(input_stdin), 3):\n    print(solution(input_stdin[i:i+3])) "
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    digits = stdin.splitlines()[1]\n    count = 0\n    for i in digits:\n        if i == str(t):\n            count += 1\n    print(count)"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t, nums = stdin.split()\n    t = int(t)\n    nums = list(nums)\n\n    if t == 6:\n        return 2\n    elif t == 9:\n        return 1\n    else:\n        return 0"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin[0])\n    digits = stdin[1]\n\n    # Set up the dictionary of similar digits\n    similar_digits = {\n        '6': '9',\n        '9': '6',\n        '2': '5',\n        '5': '2'\n    }\n\n    # Count the number of instances of t\n    instances = 0\n    for digit in digits:\n        if digit == str(t):\n            instances += 1\n        elif digit in similar_digits and similar_digits[digit] == str(t):\n            instances += 1\n\n    return str(instances)\n"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    sequence = input()\n    # Using set to store unique digits in the sequence\n    sequence_set = set(sequence)\n    # Checking if t is in the sequence set\n    if str(t) in sequence_set:\n        # If t is in the sequence set, it can be used as many times as there are instances of t in the sequence\n        instances = sequence.count(str(t))\n    else:\n        # If t is not in the sequence set, we need to check for rotations of t\n        rotations = [str(t), str(t)[::-1]]\n        instances = 0\n        for digit in sequence_set:\n            if digit in rotations:\n                instances += sequence.count(digit)\n    print(instances)\n"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    digits = stdin.split('\\n')[1]\n\n    instances = 1\n\n    for digit in digits:\n        if digit == '6':\n            instances *= 2\n        elif digit == '9':\n            instances *= 2\n        elif digit == '2':\n            instances *= 2\n        elif digit == '5':\n            instances *= 2\n\n    instances //= 4\n\n    return str(instances)\n\ndef"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1]\n\n    instances = 0\n    for i in range(len(sequence)):\n        if sequence[i] == str(t):\n            instances += 1\n\n    print(instances)\n"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    digits = stdin.splitlines()[1]\n\n    # Create a dictionary to store the rotated digits\n    rotated_digits = {\n        '0': '0',\n        '1': '1',\n        '2': '5',\n        '3': '3',\n        '4': '4',\n        '5': '2',\n        '6': '9',\n        '7': '7',\n        '8': '8',\n        '9': '6',\n    }\n\n    # Count the number of instances of t\n    count = 0\n    for digit in digits:\n        if digit == '6':\n            count += digits.count('9')\n        elif digit == '9':\n            count += digits.count('6')\n        elif digit == '2':\n            count += digits.count('5')\n        elif digit == '5':\n            count += digits.count('2')\n\n    # Check if the rotated digits are included in the sequence\n    for digit in digits:\n        if rotated_digits[digit] in digits:\n            count += digits.count(rotated_digits[digit])\n\n    return count"
    },
    {
        "number": 688,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    t = int(input_list[0])\n    sequence = input_list[1]\n\n    # Create a dictionary to store the frequency of each digit\n    digit_freq = {}\n    for digit in sequence:\n        if digit in digit_freq:\n            digit_freq[digit] += 1\n        else:\n            digit_freq[digit] = 1\n\n    # Check if t is present in the sequence\n    if str(t) in sequence:\n        return \"1\"\n\n    # Check for Digital Mimicry effect\n    rotated_digits = {\n        \"6\": \"9\",\n        \"9\": \"6\",\n        \"2\": \"5\",\n        \"5\": \"2\",\n    }\n    for key, value in rotated_digits.items():\n        if key in sequence and value in sequence:\n            # Find the position of key and value in sequence\n            key_pos = sequence.find(key)\n            value_pos = sequence.find(value)\n\n            # Check if key_pos is less than value_pos\n            if key_pos < value_pos:\n                # Check if key and value are separated by 2 or more digits\n                if value_pos - key_pos > 1:\n                    return \"1\"\n            else:\n                # Check if value and key are separated by 2 or more digits\n                if key_pos - value_pos > 1:\n                    return \"1\"\n\n    # Check for frequency of 0 and 1\n    if \"0\" in digit_freq and \"1\" in digit_freq:\n        # Check if frequency of 0 and 1 is equal\n        if digit_freq[\"0\"] == digit_freq[\"1\"]:\n            return \"1\"\n        else:\n            return \"0\"\n\n    # If no valid instance can be constructed, return 0\n    return \"0\"\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                return False\n        return True\n\n    t = int(stdin[0])\n    stdin = stdin[1:].split('\\n')\n    for i in range(t):\n        n = int(stdin[i][0])\n        strings = stdin[i][1:].split('\\n')\n        if len(set(strings)) == 1:\n            print(\"YES\")\n        else:\n            for j in range(n - 1):\n                for k in range(j + 1, n):\n                    if is_possible(strings[j], strings[k]):\n                        strings[j] = strings[k]\n                        print(\"YES\")\n                        break\n                else:\n                    print(\"NO\")\n                    break\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_equal(s1: str, s2: str) -> bool:\n        diff_count = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n        return True\n\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        strings = [stdin.readline().strip() for _ in range(n)]\n        if len(set(strings)) == 1:\n            print(\"YES\")\n        else:\n            for i in range(n):\n                for j in range(n):\n                    if i != j and is_equal(strings[i], strings[j]):\n                        print(\"YES\")\n                        break\n                else:\n                    continue\n                break\n            else:\n                print(\"NO\")\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for case in range(1, t + 1):\n        n = int(stdin.readline().strip())\n        strings = [stdin.readline().strip() for _ in range(n)]\n        if len(set(strings)) == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.pop(0))\n    for _ in range(t):\n        n = int(stdin.pop(0))\n        strings = [stdin.pop(0) for _ in range(n)]\n        if len(set(strings)) == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for case in range(1, t+1):\n        n = int(stdin.readline().strip())\n        strings = [stdin.readline().strip() for _ in range(n)]\n        if all(len(set(s)) == 1 for s in zip(*strings)):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        diff_count = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                diff_count += 1\n        return diff_count == 1\n\n    t = int(stdin.split('\\n')[0])\n    for i in range(1, t + 1):\n        n = int(stdin.split('\\n')[i])\n        strings = stdin.split('\\n')[i + 1:i + n + 1]\n        strings_set = set(strings)\n        if len(strings_set) == 1:\n            print(\"YES\")\n        else:\n            for s1, s2 in itertools.combinations(strings_set, 2):\n                if is_possible(s1, s2):\n                    print(\"YES\")\n                    break\n            else:\n                print(\"NO\")"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_char(s: str, i: int) -> str:\n        if i >= len(s):\n            return ''\n        return s[i]\n\n    def remove_char(s: str, i: int) -> str:\n        return s[:i] + s[i+1:]\n\n    def insert_char(s: str, c: str, j: int) -> str:\n        return s[:j] + c + s[j:]\n\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        stdin = stdin[2:]\n        s = []\n        for i in range(n):\n            s.append(stdin.split()[0])\n            stdin = stdin[1:]\n        count_a = s.count('a')\n        count_b = s.count('b')\n        count_c = s.count('c')\n\n        if count_a != count_b or count_b != count_c:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n: int, strings: list[str]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if i != j and strings[i] != strings[j]:\n                    return True\n        return False\n\n    def make_equal(n: int, strings: list[str]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if i != j and strings[i] != strings[j]:\n                    s1, s2 = strings[i], strings[j]\n                    diff = 0\n                    for c1, c2 in zip(s1, s2):\n                        if c1 != c2:\n                            diff += 1\n                            if diff > 1:\n                                return False\n                    if diff > 0:\n                        strings[i] = s1[:len(s1) - diff] + s2[len(s1) - diff:]\n                        strings[j] = s2[:len(s1) - diff] + s1[len(s1) - diff:]\n                        return True\n        return False\n\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        strings = []\n        for _ in range(n):\n            strings.append(stdin.readline().strip())\n        if is_possible(n, strings) and make_equal(n, strings):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n"
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for case in range(t):\n        n = int(stdin.readline().strip())\n        strings = [stdin.readline().strip() for _ in range(n)]\n        target_length = sum(len(s) for s in strings) // n\n        for i in range(n):\n            if len(strings[i]) != target_length:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n\n\nstdin = sys.stdin.read()\nsolution(stdin) "
    },
    {
        "number": 689,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split(\"\\n\")[0])\n    output = []\n    for _ in range(t):\n        n = int(stdin.split(\"\\n\")[1])\n        stdin = \"\\n\".join(stdin.split(\"\\n\")[2:])\n        s = []\n        for _ in range(n):\n            s.append(list(stdin.split(\"\\n\")[0]))\n            stdin = \"\\n\".join(stdin.split(\"\\n\")[1:])\n        same = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                if s[i] != s[j]:\n                    same = False\n                    break\n            if not same:\n                break\n        output.append(\"YES\" if same else \"NO\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    n_str = str(n)\n    n_list = [int(d) for d in n_str]\n    n_list.reverse()\n    for d in n_list:\n        go_dama = 5 * (d // 5)\n        ichi_damas = d % 5\n        print(\"O\" * (ichi_damas + 1) + \"|\" + \"-\" * (go_dama + 1))\n"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = ''\n    for i in range(len(str(n)), 0, -1):\n        digit = n % 10\n        n //= 10\n        if digit == 0:\n            result += 'O-|' + '-' * (4 * i - 1) + '\\n'\n        else:\n            result += 'O-|' + '-' * (4 * i - 1 - digit) + 'O' * digit + '\\n'\n    return result\n\n\ndef"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"O-|OO-OO\"\n\n    result = \"\"\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n\n    for i, digit in enumerate(reversed(digits)):\n        row = \"\"\n        go_dama = digit // 10\n        ichi_damas = digit % 10\n        row += \"-|\"\n        row += \"O\" * ichi_damas\n        row += \"-\"\n        row += \"O\" * (4 - ichi_damas)\n        if go_dama > 0:\n            row += \"O\"\n        row += \"O\" * go_dama\n        result += row + \"\\n\"\n    return result\n\n\ninput_str = \"2\"  # Input as a string to avoid issues with spaces and tabs\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    \n    digits = []\n    num = n\n    \n    while num > 0:\n        digits.append(num % 10)\n        num //= 10\n    \n    result = []\n    \n    for i, digit in enumerate(digits[::-1]):\n        rod = ['-'] * 5\n        \n        if i == 0:\n            rod[4] = 'O'\n        else:\n            rod[digit] = 'O'\n        \n        result.append(''.join(rod))\n    \n    return '\\n'.join(result)\n\n\ndef"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    rods = [[] for _ in range(len(digits))]\n    for i, digit in enumerate(digits):\n        go_dama = digit\n        ichi_damas = 0\n        for j in range(5):\n            rods[i].append(go_dama)\n            if j < 4:\n                go_dama -= ichi_damas\n                ichi_damas += 1\n    result = []\n    for i in range(len(rods)-1, -1, -1):\n        beads = 'OOOOOO'[:5-len(rods[i])]\n        for j in range(len(rods[i])):\n            if rods[i][j] == 0:\n                beads = beads[:j] + '-' + beads[j+1:]\n            elif rods[i][j] == 5:\n                beads = beads[:j] + 'O' + beads[j+1:]\n            else:\n                beads = beads[:j] + 'O' + beads[j+1:]\n        result.append(beads)\n    return '\\n'.join(result)\n\ndef"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    digits.reverse()\n    result = \"\"\n    for i, digit in enumerate(digits):\n        rod_pieces = ['O'] * digit\n        go_dama = rod_pieces.pop()\n        result += f\"{''.join(rod_pieces)}-|{'O'*digit}{'-'*i}{go_dama}\\n\"\n    return result\n\ninput_str = \"720\"  # Replace with desired input\nprint(solution(input_str))\n"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    while n > 0:\n        digit = n % 10\n        if digit == 0:\n            print('O', end='')\n        else:\n            print('-', end='')\n            go_dama = 0\n            while digit >= 5:\n                digit -= 5\n                go_dama += 1\n            if digit == 4:\n                go_dama += 1\n            for _ in range(go_dama):\n                print('O', end='')\n            for _ in range(digit):\n                print('-', end='')\n        if n // 10 > 0:\n            print('O', end='')\n        else:\n            print('|', end='')\n        n //= 10\n    print()\n"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = \"\"\n    while n > 0:\n        digit = n % 10\n        if digit == 0:\n            result = \"O-|\" + result\n        else:\n            result = \"O-|\" + result + \"-O\" * digit\n        n //= 10\n    return result + \"\\n\"\n"
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    while n >= 10:\n        print('O-|', end='')\n        n, remainder = divmod(n, 10)\n        if remainder == 0:\n            print('OOOO-O', end='')\n        else:\n            print('O' * remainder, end='')\n            if remainder < 5:\n                print('-' * (5 - remainder), end='')\n            print('O', end='')\n    print('O-|', end='')\n    print('O' * n)\n    return "
    },
    {
        "number": 690,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    digits = []\n    \n    while n > 0:\n        digit = n % 10\n        digits.append(digit)\n        n //= 10\n    \n    output = \"\"\n    for i in range(len(digits)):\n        row = \"\"\n        digit = digits[i]\n        for j in range(5):\n            if j == 4:\n                row += \"|\"\n            else:\n                row += \"-\"\n        row += \"O\" * digit\n        output += row + \"\\n\"\n    \n    return output\n\n\ninput_string = \"720\\n\"\nprint(solution(input_string)) "
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n == 1:\n        return \"NO\"\n    numbers = [i for i in range(1, min(10**6, 2*x) + 1) if i != x]\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i]^numbers[j] == x:\n                return \"YES\\n\" + \" \".join(map(str, sorted([numbers[i], numbers[j]])))\n    return \"NO\"\n"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n, x = map(int, input_data)\n\n    # Generate all possible sets of n distinct non-negative integers\n    all_sets = [[i] for i in range(1, 10**6 + 1)]\n    for i in range(1, n):\n        new_sets = []\n        for s in all_sets:\n            for j in range(max(s[-1] + 1, 1), 10**6 + 1):\n                new_sets.append(s + [j])\n        all_sets = new_sets\n\n    # Find the set with the desired bitwise-xor sum\n    for s in all_sets:\n        if sum(s) == x:\n            return \"YES\\n\" + \" \".join(map(str, s))\n\n    # If no set is found, return \"NO\"\n    return \"NO\"\n"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str, x = map(int, stdin.split())\n    if x > 10**6:\n        return \"NO\"\n    s = set()\n    i = 1\n    while len(s) < input_str:\n        if i ^ x not in s:\n            s.add(i)\n        i += 1\n    if len(s) == input_str:\n        return \"YES\\n\" + \" \".join(map(str, sorted(list(s))))\n    return \"NO\"\n\ndef"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n > 10**5 or x > 10**5:\n        return \"NO\"\n\n    result = []\n    for i in range(n):\n        num = 1\n        while i ^ num != x:\n            num += 1\n        result.append(num)\n\n    if len(set(result)) != n:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, result))\n"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    \n    # If x is odd, it can't be the bitwise-xor sum of any set of n distinct non-negative integers\n    if x % 2 != 0:\n        return \"NO\"\n    \n    # Create a set of integers from 0 to x/2\n    nums = set(range(x//2 + 1))\n    \n    # Check if the bitwise-xor sum of the integers in the set is equal to x\n    for i in range(1, x//2+1):\n        if i not in nums and x - i in nums:\n            return \"YES\\n\" + \" \".join(map(str, sorted(set([i, x-i]))))\n    \n    return \"NO\""
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, n = map(int, stdin.split())\n\n    def bitwise_xor_sum(nums: set) -> int:\n        return sum(nums) - 2 * len(nums) * (x & len(nums))\n\n    def is_valid(nums: set) -> bool:\n        return bitwise_xor_sum(nums) == x\n\n    def generate_set() -> str:\n        current_set = set(range(1, 10**6 + 1))\n        for _ in range(n):\n            if not is_valid(current_set):\n                return \"NO\"\n            yield current_set.pop()\n\n    if x <= 0 or n <= 0 or n > 10**5 or x > 10**5:\n        return \"NO\"\n\n    result = \"YES\\n\" + \"\\n\".join(map(str, generate_set()))\n    return result\n"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    \n    # Initialize an empty set\n    s = set()\n    \n    # Generate all possible integers from 0 to 10^6\n    integers = list(range(10**6))\n    \n    # Iterate through all possible integers\n    for num in integers:\n        # Calculate the bitwise-xor sum of num and the remaining integers\n        s_bitwise_xor = sum(num ^ i for i in integers)\n        \n        # Check if the bitwise-xor sum is equal to x\n        if s_bitwise_xor == x:\n            # Add the integer to the set\n            s.add(num)\n            \n            # If the set has n elements, we found a solution\n            if len(s) == n:\n                # Print YES\n                print(\"YES\")\n                \n                # Print the elements of the set\n                print(\" \".join(map(str, sorted(s))))\n                \n                # Exit the loop\n                break"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if x == 0:\n        return \"NO\"\n    \n    for i in range(1, 10**6):\n        if x == i:\n            return \"YES\\n\" + str(i)\n        elif x > i:\n            y = x ^ i\n            if y > 0 and y <= 10**6 and 0 < x - i <= 10**6:\n                return \"YES\\n\" + str(i) + \" \" + str(x - i)\n    return \"NO\"\n\ndef"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    \n    # Find the complement of x\n    complement = (1 << 31) - 1 - x\n    \n    # Initialize the set with the complement\n    set_ = [complement]\n    \n    # Calculate the bitwise xor sum of the set\n    bitwise_xor_sum = set_[0]\n    \n    # Iterate through the set and calculate the bitwise xor sum\n    for i in range(1, n):\n        new_element = complement ^ i\n        if new_element <= 10**6:\n            set_.append(new_element)\n            bitwise_xor_sum ^= new_element\n        else:\n            break\n    \n    # Check if the bitwise xor sum is equal to x\n    if bitwise_xor_sum == x:\n        return \"YES\\n\" + \" \".join(map(str, set_))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 691,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n\n    # Check if there are any solutions\n    if x == 0:\n        return \"NO\"\n\n    # Generate a set of numbers that satisfy the condition\n    numbers = set()\n    for i in range(1, n+1):\n        numbers.add(i)\n        numbers.add(x ^ i)\n\n    # Check if there are any solutions\n    if len(numbers) < n:\n        return \"NO\"\n\n    # Sort and print the numbers\n    numbers = sorted(numbers)\n    return \"YES\\n\" + \" \".join(map(str, numbers[:n]))\n"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    N = int(input_list[0])\n    M = list(map(int, input_list[1].split()))\n    R = list(map(int, input_list[2].split()))\n\n    if N == 1:\n        return str(R[0])\n\n    count = 0\n    for i in range(N):\n        if R[i] == 0:\n            count += 1\n\n    if count == N:\n        return str(1.0)\n    else:\n        return str(count / N)\n\n\ndef"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    M = list(map(int, input_lines[1].split()))\n    R = list(map(int, input_lines[2].split()))\n\n    result = 0\n    for i in range(N):\n        if M[i] % R[i] == 0:\n            result += M[i] // R[i]\n        else:\n            result += M[i] // R[i] + 1\n\n    return f\"{result:.6f}\"\n\n\ndef"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    M = list(map(int, stdin.split('\\n')[1].split()))\n    R = list(map(int, stdin.split('\\n')[2].split()))\n\n    for i in range(N):\n        if M[i] % R[i] == 0:\n            return str(0.0)\n    total_dishes = 0\n    for i in range(N):\n        total_dishes += M[i] // R[i]\n    return str(total_dishes)\n\n\ndef"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    M = list(map(int, stdin.split(\"\\n\")[1].split()))\n    R = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    def compute_disease(M, R):\n        for i in range(N):\n            if R[i] < M[i]:\n                return R[i] / M[i]\n        return 0\n\n    result = compute_disease(M, R)\n    return f\"{result:.6f}\""
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.strip().split('\\n')\n    N = int(input_lines[0])\n    M = list(map(int, input_lines[1].split()))\n    R = list(map(int, input_lines[2].split()))\n\n    i = 0\n    while i < len(M) and M[i] >= R[i]:\n        i += 1\n\n    if i == len(M):\n        return \"0.000000\"\n\n    if R[i] == M[i]:\n        return f\"{(i+1)/N:.6f}\"\n\n    return f\"{(i+1)/N + (M[i] - R[i])/(N*M[i]):.6f}\""
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def btoh(n: int) -> str:\n        return '01'[n % 2]\n\n    def ith_digit(n: int, i: int) -> int:\n        return (n // (10**i)) % 10\n\n    def ith_diseh(n: int, i: int) -> int:\n        return 9 - ith_digit(n, i)\n\n    def btoh_diseh(n: int) -> int:\n        return int(btoh(n), 2)\n\n    def compute_diseh(diseh: int) -> int:\n        if diseh % 2 == 0:\n            return diseh // 2\n        else:\n            return diseh // 2 + 1\n\n    def main():\n        N = int(stdin.splitlines()[0])\n        M = list(map(int, stdin.splitlines()[1].split()))\n        R = list(map(int, stdin.splitlines()[2].split()))\n\n        for i in range(N):\n            if M[i] % R[i] != 0:\n                return \"Error: M[i] is not a multiple of R[i] for some i.\"\n\n        result = 0\n        for i in range(N):\n            result += R[i] * btoh_diseh(M[i])\n        return result / N\n\n    return f\"{main():.6f}\""
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    M = list(map(int, input_list[1].split()))\n    R = list(map(int, input_list[2].split()))\n\n    def is_valid(M, R):\n        for i in range(N):\n            if R[i] < M[i]:\n                return False\n        return True\n\n    def calculate_diseases(M, R):\n        diseases = 0\n        for i in range(N):\n            if R[i] == M[i]:\n                diseases += 1\n        return diseases\n\n    def calculate_days(M, R):\n        days = 0\n        for i in range(N):\n            while R[i] != M[i]:\n                if R[i] < M[i]:\n                    R[i] += 1\n                days += 1\n        return days\n\n    if not is_valid(M, R):\n        return \"0.0\"\n\n    diseases = calculate_diseases(M, R)\n    days = calculate_days(M, R)\n    result = diseases / days\n\n    return str(result)\n\ndef"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    M = list(map(int, input().split()))\n    R = list(map(int, input().split()))\n\n    dys = [1] * N\n    for i in range(N):\n        if R[i] < M[i]:\n            dys[i] = 0\n\n    result = sum(dys) / N\n\n    return \"{:.6f}\".format(result)\n"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split(\"\\n\")\n    n = int(input_str[0])\n    M = [int(x) for x in input_str[1].split()]\n    R = [int(x) for x in input_str[2].split()]\n\n    result = 0\n    for i in range(n):\n        if R[i] % M[i] == 0:\n            result += R[i] / M[i]\n        else:\n            result += R[i] // M[i]\n\n    return f\"{result:.6f}\"\n"
    },
    {
        "number": 692,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def solve(M, R):\n        total_days = 0\n        for i in range(len(M)):\n            days = 0\n            while R[i] < M[i]:\n                days += 1\n                R[i] += 1\n            total_days += days\n        return total_days / len(M)\n\n    N = int(stdin.splitlines()[0])\n    M = list(map(int, stdin.splitlines()[1].split()))\n    R = list(map(int, stdin.splitlines()[2].split()))\n    result = solve(M, R)\n    return \"{:.6f}\".format(result)\n\n\ninput_data = \"2\\n2 3\\n1 0\"\nprint(solution(input_data)) "
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, m = map(int, input_values[0].split())\n    lightsaber_colors = list(map(int, input_values[1].split()))\n    desired_counts = list(map(int, input_values[2].split()))\n\n    total_count = sum(lightsaber_colors)\n    current_count = [0] * (m + 1)\n    for color in lightsaber_colors:\n        current_count[color] += 1\n\n    min_removals = -1\n    for i in range(1, m + 1):\n        if current_count[i] < desired_counts[i - 1]:\n            min_removals = i\n            break\n\n    if min_removals == -1:\n        min_removals = total_count - sum(desired_counts) + 1\n\n    return str(min_removals)\n\n\ninput_file = open(\"input.txt\", \"r\")\nstdin = input_file.read()\nprint(solution(stdin)) "
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    knight_colors = list(map(int, input_list[1].split()))\n    k_counts = list(map(int, input_list[2].split()))\n    \n    colors_sum = [sum(knight_colors[:i+1]) for i in range(m)]\n    \n    for i in range(m):\n        if k_counts[i] > colors_sum[i]:\n            return -1\n            \n    for i in range(1, m):\n        if colors_sum[i] - colors_sum[i-1] > n - colors_sum[i]:\n            return -1\n    \n    return n - colors_sum[-1] - max(k_counts) + 1"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    colors = list(map(int, input_data[1].split()))\n    k_counts = list(map(int, input_data[2].split()))\n\n    total_count = sum(k_counts)\n    max_color = max(colors)\n    remaining_count = total_count - k_counts[max_color]\n\n    if remaining_count == 0:\n        return 0\n\n    knights_needed = 0\n    for i in range(max_color, m):\n        if knights_needed + k_counts[i] <= remaining_count:\n            knights_needed += k_counts[i]\n        else:\n            return knights_needed - 1\n\n    return -1\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    knights_colors = list(map(int, stdin.split()[2:n+2]))\n    k_counts = list(map(int, stdin.split()[n+2:]))\n\n    knights_counts = [0] * m\n    for color in knights_colors:\n        knights_counts[color - 1] += 1\n\n    if sum(k_counts) > n:\n        return -1\n\n    knights_counts.sort()\n    k_counts.sort()\n\n    min_removed = 0\n    for i in range(m):\n        min_removed += max(knights_counts[i] - k_counts[i], 0)\n\n    return min_removed\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    colors = list(map(int, stdin.splitlines()[1].split()))\n    desired_counts = list(map(int, stdin.splitlines()[2].split()))\n\n    colors.sort()\n\n    count = 0\n    i = 0\n    for c in colors:\n        if i == c:\n            i += 1\n        else:\n            count += 1\n\n    if count >= sum(desired_counts):\n        return count\n    else:\n        return -1\n\n\ninput_data = \"\"\"8 3\n3 3 1 2 2 1 1 3\n3 1 1\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    knights = list(map(int, stdin.splitlines()[1].split()))\n    k_counts = list(map(int, stdin.splitlines()[2].split()))\n\n    # sort knights and k_counts by value\n    knights.sort()\n    k_counts.sort()\n\n    # initialize variables\n    i = j = 0\n    k = 1\n    min_removed = 0\n\n    # loop through knights and k_counts\n    while i < n and j < m:\n        if knights[i] == k_counts[j]:\n            i += 1\n            j += 1\n            k += 1\n        else:\n            min_removed += 1\n            i += 1\n\n    # check if the desired interval can be formed\n    if k == len(k_counts) + 1:\n        return str(min_removed)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    colors = list(map(int, stdin.splitlines()[1].split()))\n    k = list(map(int, stdin.splitlines()[2].split()))\n    \n    total_counts = sum(k)\n    remaining_counts = total_counts\n    min_knights = n + 1\n    last_color = 0\n\n    for i in range(m):\n        remaining_counts -= k[i]\n        while remaining_counts < 0 and last_color < m - 1:\n            remaining_counts += sum(k[:last_color + 1]) - colors.count(last_color + 1)\n            last_color += 1\n        if remaining_counts >= 0:\n            min_knights = min(min_knights, n - (total_counts - remaining_counts))\n        else:\n            min_knights = -1\n            break\n        \n    if min_knights == n + 1:\n        min_knights = -1\n\n    return str(min_knights)\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def sum_counts(counts: list) -> int:\n        return sum(counts)\n\n    def total_counts(counts: list) -> int:\n        return sum_counts(counts)\n\n    def get_count(counts: list, index: int) -> int:\n        return counts[index]\n\n    def update_count(counts: list, index: int, value: int) -> None:\n        counts[index] = value\n\n    def is_valid_counts(counts: list) -> bool:\n        return sum_counts(counts) == n\n\n    def is_valid_interval(counts: list) -> bool:\n        return all(counts[i] >= k[i] for i in range(m))\n\n    def find_min_counts(counts: list, index: int, min_counts: int) -> int:\n        if is_valid_interval(counts):\n            return min_counts\n        if index == m:\n            return min_counts + 1\n        return find_min_counts(counts, index + 1, min_counts)\n\n    n, m = map(int, stdin.readline().split())\n    knight_colors = list(map(int, stdin.readline().split()))\n    desired_counts = list(map(int, stdin.readline().split()))\n\n    min_counts = n + 1\n    for i in range(1, m + 1):\n        min_counts = min(min_counts, find_min_counts([0] * m, 0, sum_counts(desired_counts) - sum_counts(desired_counts[:i])))\n        if min_counts == 1:\n            break\n\n    if min_counts == n + 1:\n        return -1\n    else:\n        return min_counts\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    lightsabers = list(map(int, stdin.split('\\n')[1].split()))\n    desired_counts = list(map(int, stdin.split('\\n')[2].split()))\n\n    light_counts = [0] * m\n    for saber in lightsabers:\n        light_counts[saber - 1] += 1\n\n    min_let_go = -1\n    for i in range(len(light_counts)):\n        light_counts[i] -= desired_counts[i]\n        if min_let_go == -1 or light_counts[i] < min_let_go:\n            min_let_go = light_counts[i]\n\n    if min_let_go < 0:\n        min_let_go = 0\n\n    return str(min_let_go)\n"
    },
    {
        "number": 693,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    colors = list(map(int, stdin.split()[2:n+2]))\n    k = list(map(int, stdin.split()[n+2:n+2+m]))\n\n    total = sum(colors)\n    counts = [0] * m\n    for c in colors:\n        counts[c-1] += 1\n\n    min_let_go = 0\n    for i in range(m):\n        min_let_go += min(k[i], counts[i])\n        counts[i] -= min(k[i], counts[i])\n\n    if min_let_go >= n - total:\n        return str(n - total)\n    else:\n        return \"-1\"\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\nprint(solution(n, m, colors, k))"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    public_key = int(stdin.splitlines()[0])\n    a, b = map(int, stdin.splitlines()[1].split())\n    \n    if a > public_key or b > public_key:\n        return \"NO\"\n    \n    for i in range(2, public_key+1):\n        if public_key % i == 0:\n            left_part = i\n            right_part = public_key // i\n            if right_part % b == 0 and left_part % a == 0 and left_part < right_part:\n                return \"YES\\n{}\\n{}\".format(left_part, right_part)\n    \n    return \"NO\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    public_key = int(stdin)\n    a, b = map(int, stdin.split()[-2:])\n\n    if public_key % a == 0:\n        return \"YES\\n0\\n\" + str(public_key)\n\n    for i in range(1, public_key):\n        if public_key % i == 0:\n            right_part = public_key // i\n            if right_part % b == 0:\n                left_part = i\n                return \"YES\\n\" + str(left_part) + \"\\n\" + str(right_part)\n\n    return \"NO\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = stdin.splitlines()\n    public_key = int(public_key)\n    a, b = int(a), int(b)\n\n    if public_key < a * b:\n        return \"NO\"\n\n    left_part = 0\n    right_part = public_key\n\n    while right_part % b != 0:\n        left_part += 1\n        right_part -= a\n\n    if right_part < a:\n        return \"NO\"\n\n    print(\"YES\")\n    print(left_part, right_part)\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = input(stdin).split()\n    public_key = int(public_key)\n    a, b = int(a), int(b)\n\n    for i in range(len(str(public_key)) - 1, -1, -1):\n        if public_key % (10**(len(str(public_key)) - i)) == 0:\n            if a % (10**(len(str(public_key)) - i)) == 0 and b % (10**(len(str(public_key)) - i)) == 0:\n                left_part = public_key // (10**(len(str(public_key)) - i))\n                right_part = public_key - left_part * (10**(len(str(public_key)) - i))\n                return f\"YES\\n{left_part}\\n{right_part}\\n\"\n\n    return \"NO\\n\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = stdin.split('\\n')\n    a, b = int(a), int(b)\n    public_key = int(public_key)\n\n    if public_key % a == 0:\n        left_part = public_key // a\n        right_part = 0\n    else:\n        left_part = public_key // a\n        right_part = public_key - left_part * a\n\n    if right_part % b == 0:\n        right_part = right_part // b\n        if right_part == 0:\n            return \"NO\"\n    else:\n        right_part = 0\n\n    if right_part == 0:\n        return \"NO\"\n\n    return \"YES\\n{}\\n{}\".format(left_part, right_part)\n\n\ndef"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = stdin.split('\\n')\n    a, b = int(a), int(b)\n\n    if not (1 <= a <= 10**8 and 1 <= b <= 10**8):\n        return \"NO\"\n\n    left_part = \"\"\n    right_part = \"\"\n\n    for digit in public_key:\n        if len(left_part) * a <= len(right_part) * b:\n            right_part += digit\n        else:\n            left_part += digit\n\n    if len(left_part) * a == len(right_part) * b:\n        return \"YES\\n\" + left_part + \"\\n\" + right_part\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = stdin.splitlines()\n    a, b = int(a), int(b)\n\n    if a > b:\n        a, b = b, a\n\n    public_key = int(public_key)\n\n    # Find the greatest divisor of the public key that is less than or equal to a\n    divisor = a\n    while divisor * a > public_key:\n        divisor -= 1\n\n    # If there is no such divisor, the conditions are not satisfied\n    if divisor <= 1:\n        return \"NO\"\n\n    # Find the smallest multiple of b greater than the divisor and less than or equal to public_key\n    multiple = divisor\n    while multiple * b <= public_key:\n        multiple *= b\n\n    # Calculate the left and right parts after the cut\n    left_part = public_key // multiple\n    right_part = public_key - left_part * multiple\n\n    # Check if the conditions are satisfied\n    if left_part % a == 0 and right_part % b == 0 and left_part > 0 and right_part > 0:\n        return \"YES\\n{}\\n{}\".format(left_part, right_part)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    public_key = int(stdin.split('\\n')[0])\n    a, b = map(int, stdin.split('\\n')[1].split())\n\n    left, right = divmod(public_key, 10**(int(len(str(public_key))/2) - 1))\n\n    if a > 10**8 or b > 10**8:\n        return \"NO\"\n\n    if public_key % a == 0 and right % b == 0:\n        left_part = str(left)\n        right_part = str(right)\n        while len(left_part) > 1 and left_part[0] == '0':\n            left_part = left_part[1:]\n        while len(right_part) > 1 and right_part[0] == '0':\n            right_part = right_part[1:]\n        return \"YES\\n\" + left_part + \"\\n\" + right_part\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    public_key = int(input())\n    a, b = map(int, input().split())\n\n    if public_key == 0 or a == 0 or b == 0:\n        return \"NO\"\n\n    left_part = 0\n    right_part = public_key\n\n    while right_part > 0:\n        if right_part % a == 0 and right_part % b == 0:\n            left_part = right_part // a\n            right_part = right_part // b\n            break\n        right_part -= 1\n\n    if right_part == 0:\n        return \"NO\"\n\n    return \"YES\\n\" + str(left_part) + \"\\n\" + str(right_part)\n"
    },
    {
        "number": 694,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    public_key = int(input())\n    a, b = map(int, input().split())\n\n    left_part = 0\n    right_part = public_key\n\n    while right_part > 0:\n        if right_part % a == 0 and right_part % b == 0:\n            left_part = right_part // a\n            right_part = right_part - left_part * a\n            break\n        else:\n            right_part -= 1\n\n    if right_part == 0:\n        return \"NO\"\n    else:\n        return \"YES\\n{}\\n{}\".format(left_part, right_part)\n"
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    \n    if a_1 % 2 == a_2 % 2:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    \n    if a1 == a2:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n\n    if a_1 == a_2:\n        return \"1\"\n    elif a_1 + a_2 <= 32:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    return '1' if a_1 > a_2 else '0'"
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    \n    if a1 == a2:\n        return \"0\"\n    elif a1 == 0 or a2 == 0:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    if a1 == a2:\n        return '0'\n    else:\n        return '1'\n\ndef"
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    if a1 % 2 == a2 % 2:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    if a1 == a2:\n        return '0'\n    else:\n        if a1 == 0 and a2 == 2:\n            return '1'\n        elif a1 == 1 and a2 == 3:\n            return '1'\n        elif a1 == 2 and a2 == 0:\n            return '1'\n        elif a1 == 3 and a2 == 1:\n            return '1'\n        else:\n            return '0'\n\ndef"
    },
    {
        "number": 695,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    if a1 == a2:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(input())\n    count = 0\n    for x in range(1, p):\n        is_primitive_root = True\n        for i in range(1, p):\n            if pow(x, (p-1)//2, p) == 1:\n                is_primitive_root = False\n                break\n            if pow(x, (p-1), p) == 1:\n                is_primitive_root = False\n                break\n        if is_primitive_root:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    result = 0\n    for i in range(2, p):\n        if gcd(i, p) == 1 and not is_primitive_root(i, p):\n            result += 1\n    return result\n\ndef"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    primitive_roots = []\n    for x in range(1, p):\n        is_root = True\n        for i in range(1, p):\n            if (x * i) % p == 1:\n                is_root = False\n                break\n        if is_root and x != p - 1:\n            primitive_roots.append(x)\n    return len(primitive_roots) "
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    count = 0\n    for x in range(1, p):\n        is_primitive_root = True\n        for y in range(2, p):\n            if pow(y, p-1, p) != 1:\n                is_primitive_root = False\n                break\n        if is_primitive_root:\n            count += 1\n    return str(count)"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    primitive_roots = []\n    for i in range(1, p):\n        is_primitive_root = True\n        for j in range(1, p):\n            if (i - 1) % j == 0 and (i**j - 1) % p == 0:\n                is_primitive_root = False\n                break\n        if is_primitive_root:\n            primitive_roots.append(i)\n    return str(len(primitive_roots))\n\ndef"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_primitive_root(p: int, x: int) -> bool:\n        if x < 1 or x >= p:\n            return False\n        for i in range(1, p):\n            if (x**i) % p == (x**(p - 1 - 1) % p):\n                return False\n        return True\n\n    p = int(stdin.strip())\n\n    if not is_prime(p):\n        return \"Invalid input. p must be a prime number.\"\n\n    primitive_roots_count = 0\n    for x in range(1, p):\n        if is_primitive_root(p, x):\n            primitive_roots_count += 1\n\n    return str(primitive_roots_count)\n\n\ninput_str = \"5\"\nprint(solution(input_str))  # Output: 2 "
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    \n    # Initialize a list to store the primitive roots\n    primitive_roots = []\n    \n    # Iterate through all numbers 1 to p-1\n    for x in range(1, p):\n        # Check if x is a primitive root\n        is_primitive_root = True\n        \n        # Check if x - 1 is divisible by p\n        if (pow(x, p-1, p) - 1) % p != 0:\n            is_primitive_root = False\n            \n        # Check if x^2 - 1 is divisible by p\n        if (pow(x, (p-1)//2, p) - 1) % p != 0:\n            is_primitive_root = False\n            \n        # Check if x^p - 1 is divisible by p\n        if (pow(x, p-1, p) - 1 - 1) % p != 0:\n            is_primitive_root = False\n            \n        # If x is a primitive root, add it to the list\n        if is_primitive_root:\n            primitive_roots.append(x)\n    \n    # Return the number of primitive roots\n    return len(primitive_roots)\n"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    primitive_roots = []\n    for x in range(1, p):\n        if pow(x, p - 1, p) == 1:\n            is_primitive_root = True\n            for i in range(1, p):\n                if i != x and pow(x, i, p) == 1:\n                    is_primitive_root = False\n                    break\n            if is_primitive_root:\n                primitive_roots.append(x)\n    return len(primitive_roots)\n"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    result = 0\n    for x in range(1, p):\n        if gcd(p, x) == 1:\n            primitive = True\n            for j in range(1, p):\n                if pow(x, (p-1)//2, p) == 1:\n                    primitive = False\n                    break\n                if pow(x, j, p) == 1:\n                    primitive = False\n                    break\n            if primitive:\n                result += 1\n    return str(result)\n\ndef"
    },
    {
        "number": 696,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    count = 0\n    for x in range(1, p):\n        is_primitive_root = True\n        for i in range(1, p):\n            if pow(x, i, p) == i:\n                is_primitive_root = False\n                break\n        if is_primitive_root:\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, m = input_values\n    \n    total_sum = 0\n    \n    for i in range(1, n+1):\n        total_sum += i\n    \n    for i in range(1, m+1):\n        total_sum += (i*-1) % 998244853\n    \n    return str(total_sum % 998244853)"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    def f(a):\n        return max(0, max(sum(a[:i+1]) for i in range(len(a))))\n\n    ans = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            for k in range(1, n+1):\n                for l in range(1, m+1):\n                    if i+j == k+l:\n                        arr = [1]*i + [-1]*j + [1]*k + [-1]*l\n                        ans += f(arr)\n    return str(ans % (998*244*853))"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def f(a):\n        return max(0, max(sum(a[:i+1]) for i in range(len(a))))\n\n    count = sum(f([1]*(n+i) + [-1]*(m-i) + [-1]*i) % 998244853 for i in range(m+1))\n\n    return str(count % 998244853)\n"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_array = stdin.split()\n    n, m = map(int, input_array)\n\n    total = 0\n    for i in range(1, n + 1):\n        total += (i % 2) * (n - i + 1)\n    for i in range(1, m + 1):\n        total += ((-1) ** i) * (m - i + 1)\n\n    return str(total % (998244853))\n\n\nstdin = \"\"\"2000 2000\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    mod = 998244353\n\n    def max_sum(a, i, j):\n        return max(0, sum(a[k] for k in range(i, j + 1)))\n\n    count = 0\n    for i in range(n + m + 1):\n        for j in range(i + 1, n + m + 1):\n            if j - i == n + m:\n                count += 1\n            if j - i <= n:\n                count += max_sum([1] * (j - i), 0, j - i - 1)\n            if j - i >= m:\n                count += max_sum([-1] * (j - i), 0, j - i - 1)\n\n    return str(count % mod)\n"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_sum = 0\n\n    for i in range(n + m + 1):\n        for j in range(i + 1):\n            for k in range(j + 1):\n                total_sum += f(k)\n\n    return str(total_sum % 998244853)\n\n\ndef"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 0 and m == 0:\n        return str(0)\n    \n    # Generate all possible arrays of length n+m\n    arrays = []\n    for i in range(n+1):\n        for j in range(m+1):\n            if i+j <= n+m:\n                arrays.append([1]*i + [-1]*j)\n    \n    # Calculate the maximum prefix sum for each array\n    max_prefix_sums = [0]*len(arrays)\n    for i, array in enumerate(arrays):\n        prefix_sum = 0\n        for j, num in enumerate(array):\n            prefix_sum += num\n            max_prefix_sums[i] = max(max_prefix_sums[i], prefix_sum)\n            if max_prefix_sums[i] >= 0:\n                break\n    \n    # Calculate the sum of the maximum prefix sums\n    total_sum = sum(max_prefix_sums)\n    \n    # Output the sum modulo 998244853\n    return str(total_sum % 998244853)"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    def max_prefix_sum(a):\n        max_sum = 0\n        cur_sum = 0\n        for x in a:\n            cur_sum += x\n            max_sum = max(max_sum, cur_sum)\n            if cur_sum < 0:\n                cur_sum = 0\n        return max_sum\n\n    count = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            count += max_prefix_sum([1] * i + [-1] * j)\n\n    return str(count % 998244853)\n"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n\n    mod = 998_244_853\n\n    count = 0\n\n    for i in range(1, n + m + 1):\n        if i <= n:\n            count += 1\n        else:\n            count += 2\n\n    result = count % mod\n\n    return str(result)\n"
    },
    {
        "number": 697,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, m = input_values[0], input_values[1]\n\n    def max_prefix_sum(array):\n        prefix_sum = 0\n        for num in array:\n            prefix_sum += num\n            yield prefix_sum\n\n    def count_max_prefix_sums(n, m):\n        arrays = [(-1,) * m, (1,) * m, (-1, 1) * (m + 1), (-1, -1, 1) * m, (1, -1, 1) * m, (-1, 1, 1, -1) * (m + 1)]\n        prefix_sums = []\n        for array in arrays:\n            prefix_sums.extend(max_prefix_sum(array))\n        return sum(prefix_sums) % 998244853\n\n    result = count_max_prefix_sums(n, m)\n    return str(result)\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    x = int(input_data[0].split()[0])\n    k = int(input_data[0].split()[1])\n    missed_rounds = [0] * 4001\n\n    for i in range(1, k + 1):\n        round_info = input_data[i].split()\n        round_type = int(round_info[0])\n        if round_type == 1:\n            missed_rounds[int(round_info[1])] += 1\n            missed_rounds[int(round_info[2]) + 1] += 1\n        else:\n            missed_rounds[int(round_info[1]) + 1] += 1\n\n    min_missed, max_missed = 0, 0\n    for missed in missed_rounds[:x]:\n        min_missed += missed\n        max_missed += missed\n\n    for missed in missed_rounds[x:]:\n        max_missed += missed\n\n    return f\"{min_missed} {max_missed}\"\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, input().split())\n    rounds = []\n    for _ in range(k):\n        line = input().split()\n        if line[0] == '2':\n            rounds.append((int(line[1]), True))\n        else:\n            rounds.append((int(line[1]), False))\n    rounds.sort(key=lambda x: x[0])\n\n    min_missed = 0\n    max_missed = 0\n    for i in range(k):\n        if rounds[i][1]:\n            if i > 0 and rounds[i][0] == rounds[i - 1][0] + 1:\n                min_missed += 1\n            if i < k - 1 and rounds[i][0] == rounds[i + 1][0] - 1:\n                max_missed += 1\n        else:\n            min_missed = max_missed = float('inf')\n            break\n\n    return f\"{min_missed} {max_missed}\"\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    missed_min = 0\n    missed_max = 0\n\n    for i in range(k):\n        round_info = stdin.split()[i+1].split()\n        if round_info[0] == \"1\":\n            missed_min += 1\n            missed_max += 1\n        else:\n            missed_min = 0\n            missed_max += 1\n\n    missed_min = min(missed_min, x - 1)\n    missed_max = min(missed_max, x - k)\n\n    output = f\"{missed_min} {missed_max}\"\n    return output\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, input().split())\n    missed_rounds = []\n\n    for _ in range(k):\n        line = input().split()\n        if line[0] == '1':\n            missed_rounds.append(int(line[2]) - int(line[1]) + 1)\n        elif line[0] == '2':\n            missed_rounds.append(int(line[1]))\n\n    min_missed = min(missed_rounds) if missed_rounds else 0\n    max_missed = max(missed_rounds) if missed_rounds else 0\n\n    return f\"{min_missed} {max_missed}\"\n\n\ninput_str = \"\"\"3 2\n2 1\n2 2\"\"\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_rounds_range(rounds: list) -> tuple:\n        min_missed = 0\n        max_missed = 0\n        for i in range(len(rounds) - 1):\n            if rounds[i][0] == 2 and rounds[i + 1][0] == 2:\n                min_missed += 1\n                max_missed += 1\n            elif rounds[i][0] == 2 and rounds[i + 1][0] == 1:\n                min_missed += 1\n                max_missed += 1\n        return min_missed, max_missed\n\n    x, k = map(int, input().split())\n    rounds = []\n    for _ in range(k):\n        rounds.append(list(map(int, input().split())))\n\n    min_missed, max_missed = get_rounds_range(rounds)\n    print(min_missed, max_missed)\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split()[0:2])\n    rounds = []\n    for i in range(k):\n        line = stdin.split()[2+i]\n        if line.startswith(\"1\"):\n            num_2, num_1 = map(int, line.split()[1:])\n            rounds.append((num_2, num_1))\n        else:\n            num = int(line.split()[1])\n            rounds.append((num, None))\n    \n    missed_rounds = 0\n    for num_1, num_2 in rounds:\n        if num_2 is not None:\n            missed_rounds += num_2 - num_1\n        else:\n            missed_rounds += 1\n    \n    min_missed = max(missed_rounds - (x-2), 0)\n    max_missed = min(missed_rounds + (4000-x+2), 4000)\n    \n    return str(min_missed) + \" \" + str(max_missed)\n"
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, input().split())\n    missed_min = 0\n    missed_max = 0\n    \n    for _ in range(k):\n        line = input().split()\n        if len(line) == 3:\n            num1, num2 = map(int, line[1:])\n            if num1 - num2 == 1:\n                missed_min += 1\n            else:\n                missed_max += 1\n        else:\n            missed_max += 1\n    \n    print(missed_min, missed_max)\n\n\nstdin = \"3 2\\n2 1\\n2 2\\n\"\nsolution(stdin) "
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    missed_min = 0\n    missed_max = 0\n\n    for _ in range(k):\n        line = input().split()\n        if line[0] == '2':\n            missed_min += 1\n            missed_max += 1\n        else:\n            missed_min += int(line[1]) - int(line[2])\n            missed_max += 1\n\n    print(missed_min, missed_max)\n\n\nstdin = input(\"Enter input string: \")\nsolution(stdin) "
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    x = int(input_data[0].split()[0])\n    k = int(input_data[0].split()[1])\n    missed_rounds = 0\n\n    for i in range(1, k + 1):\n        if input_data[i] == \"2 1\":\n            missed_rounds += 1\n        else:\n            missed_rounds += 2\n\n    min_missed, max_missed = 0, missed_rounds\n\n    if x % 2 == 1:\n        min_missed = missed_rounds - 2\n        max_missed = missed_rounds - 1\n    else:\n        min_missed = missed_rounds - 1\n        max_missed = missed_rounds - 1\n\n    return f\"{min_missed} {max_missed}\" "
    },
    {
        "number": 698,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_div1(round_id: int) -> bool:\n        return round_id % 2 == 1\n\n    def round_type(round_id: int) -> str:\n        return \"Div1\" if is_div1(round_id) else \"Div2\"\n\n    def parallel_rounds(round_id: int) -> bool:\n        return round_id % 2 == 1\n\n    stdin_list = stdin.splitlines()\n    x, k = map(int, stdin_list[0].split())\n    previous_rounds = sorted([int(round) for round in stdin_list[1:k+1]])\n\n    missed_rounds = 0\n    missed_min = 0\n    missed_max = 0\n\n    for i, round in enumerate(previous_rounds):\n        if is_div1(round):\n            missed_rounds += 1\n            missed_max = max(missed_max, missed_rounds)\n            missed_min = max(missed_min, missed_rounds)\n        else:\n            missed_rounds = 0\n            if parallel_rounds(round) and i > 0:\n                missed_rounds = max(missed_rounds, missed_min + 1)\n\n    return f\"{missed_min} {missed_max}\"\n"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    if y > n or k > n or n % k != 0:\n        return \"-1\"\n    \n    x = (n - y) // k\n    potatoes = [x * i for i in range(1, k+1)] + [x * k]\n    potatoes.sort()\n    return \" \".join(str(p) for p in potatoes)\n\n\ninput_str = \"10 1 10\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"10 6 40\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    y, k, n = map(int, input_data[0].split())\n    x = 1\n    result = []\n    while x <= n and n % k == 0:\n        if (x + y) % k == 0:\n            if (x + y) <= n:\n                result.append(x)\n        x += 1\n    if not result:\n        result.append(-1)\n    return \" \".join(map(str, result))\n\n\ndef"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    if n < k:\n        return \"1\"\n\n    if n % k != 0:\n        return \"-1\"\n\n    potatoes = n // k\n\n    if potatoes < y:\n        return \"-1\"\n\n    potatoes_in_bag1 = potatoes - y\n    potatoes_in_bag2 = y\n\n    if potatoes_in_bag1 % k != 0:\n        return \"-1\"\n\n    x = potatoes_in_bag1 // k\n\n    return \" \".join(map(str, range(1, x + 1)))\n"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    x = n // k\n    if x > y:\n        return -1\n    result = []\n    while x <= y:\n        if (x + y) % k == 0:\n            result.append(x)\n        x += 1\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    \n    if n % k == 0:\n        x = n // k - y // k\n        if x >= 1:\n            return ' '.join(map(str, range(x, n + 1, k)))\n        else:\n            return '-1'\n    else:\n        return '-1'\n\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    result = []\n    max_potatoes = n // k\n    for x in range(1, max_potatoes + 1):\n        if (x * k + y) % k == 0 and (x * k + y) <= n:\n            result.append(x)\n    if not result:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    possible_values = []\n    x = 1\n    while True:\n        total = x + y\n        if total <= n and total % k == 0:\n            possible_values.append(x)\n        if total > n:\n            break\n        x += 1\n    \n    if not possible_values:\n        return \"-1\"\n    return \" \".join(map(str, possible_values))\n\n\ninput_data = \"10 6 40\"\nprint(solution(input_data))\n"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    min_potatoes = n // k\n    max_potatoes = n - y\n\n    if min_potatoes > max_potatoes:\n        return \"-1\"\n\n    result = []\n    for x in range(min_potatoes, max_potatoes + 1):\n        if (x + y) % k == 0:\n            result.append(x)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    x = n // k\n    result = []\n    \n    while x * k <= n:\n        if x * k == n and x >= 1:\n            result.append(x)\n        x += 1\n        \n    if result:\n        result = map(str, result)\n        return ' '.join(result)\n    else:\n        return \"-1\"\n\n\ninput_str = \"10 6 40\"\nprint(solution(input_str)) "
    },
    {
        "number": 699,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    if y >= n and n % k == 0:\n        x = n // k\n        return \" \".join(map(str, range(1, x + 1)))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_matrix(matrix: list, k: int) -> list:\n        return list(map(list, zip(*matrix[::-1])))\n\n    def flip_matrix(matrix: list) -> list:\n        return matrix[::-1]\n\n    def match_maps(map1: list, map2: list) -> bool:\n        for _ in range(4):\n            rotated_map1 = rotate_matrix(map1, 1)\n            if rotated_map1 == map2:\n                return True\n            map1 = flip_matrix(map1)\n        return False\n\n    N = int(stdin[0])\n    map1 = [list(stdin[i + 1].strip()) for i in range(N)]\n    map2 = [list(stdin[i + 1 + N].strip()) for i in range(N)]\n\n    if match_maps(map1, map2):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into lines and convert the grid to a list of lists\n    N = int(stdin[0])\n    grid1 = [list(line.strip()) for line in stdin[1:N+1]]\n    grid2 = [list(line.strip()) for line in stdin[N+1:]]\n\n    # Check if the two grids are identical\n    if grid1 == grid2:\n        return \"Yes\"\n\n    # Check if flipping the first grid along the vertical axis makes it identical to the second grid\n    flipped_grid1 = [''.join(row[::-1]) for row in grid1]\n    if flipped_grid1 == grid2:\n        return \"Yes\"\n\n    # Check if rotating the first grid 90 degrees clockwise makes it identical to the second grid\n    rotated_grid1 = [''.join(row[::-1]) for row in zip(*grid1)]\n    if rotated_grid1 == grid2:\n        return \"Yes\"\n\n    # Check if rotating the first grid 180 degrees clockwise makes it identical to the second grid\n    rotated_grid1 = [''.join(row[::-1]) for row in rotated_grid1]\n    if rotated_grid1 == grid2:\n        return \"Yes\"\n\n    # Check if rotating the first grid 270 degrees clockwise makes it identical to the second grid\n    rotated_grid1 = [''.join(row[::-1]) for row in zip(*rotated_grid1)]\n    if rotated_grid1 == grid2:\n        return \"Yes\"\n\n    return \"No\" "
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, map1, map2 = stdin.split('\\n')\n    N = int(N)\n\n    def rotate(map: str) -> str:\n        return '\\n'.join(''.join(row) for row in zip(*map.split('\\n')))\n\n    def flip(map: str) -> str:\n        return '\\n'.join(row[::-1] for row in map.split('\\n'))\n\n    def are_maps_identical(map1: str, map2: str) -> bool:\n        for _ in range(4):\n            if map1 == map2:\n                return True\n            map1 = rotate(map1)\n            map2 = rotate(map2)\n            map1 = flip(map1)\n            map2 = flip(map2)\n        return False\n\n    if are_maps_identical(map1, map2):\n        return 'Yes'\n    else:\n        return 'No'\n"
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, input_maps = stdin.split(\"\\n\", 1)\n    N = int(N)\n    input_maps = input_maps.split(\"\\n\")\n\n    maps = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            maps[i].append(input_maps[i][j])\n\n    rotated_maps = [\n        [maps[j][N - 1 - i] for j in range(N)]\n        for i in range(N)\n    ]\n\n    for i in range(1, 4):\n        flipped_maps = [list(map(lambda x: x[::-1], row)) for row in rotated_maps]\n        if flipped_maps == maps or flipped_maps == rotated_maps:\n            return \"Yes\"\n        rotated_maps = [list(zip(*row)) for row in rotated_maps]\n\n    return \"No\""
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    first_map = [[lines[i][j] for j in range(N)] for i in range(1, N+1)]\n    second_map = [[lines[i][j] for j in range(N)] for i in range(N+1, 2*N+1)]\n\n    def are_maps_identical(map1: list, map2: list) -> bool:\n        if len(map1) != len(map2) or len(map1[0]) != len(map2[0]):\n            return False\n        for i in range(len(map1)):\n            for j in range(len(map1[0])):\n                if map1[i][j] != map2[i][j]:\n                    return False\n        return True\n\n    if are_maps_identical(first_map, second_map):\n        return \"Yes\"\n\n    for i in range(1, 4):\n        rotated_map = [[first_map[j][N-i-1-k] for k in range(N)] for j in range(N)]\n        if are_maps_identical(rotated_map, second_map):\n            return \"Yes\"\n\n    flipped_map = [[first_map[N-i-1][j] for j in range(N)] for i in range(N)]\n    if are_maps_identical(flipped_map, second_map):\n        return \"Yes\"\n\n    return \"No\"\n\ninput_data = '''4\nXOOO\nXXOO\nOOOO\nXXXX\nXOOO\nXOOO\nXOXO\nXOXX'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(map_: str, k: int) -> str:\n        rows, cols = len(map_), len(map_[0])\n        rotated_map = [['O'] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                rotated_map[j][rows - i - 1] = map_[i][j]\n        return ''.join(map(''.join, rotated_map))\n\n    def flip(map_: str) -> str:\n        rows, cols = len(map_), len(map_[0])\n        flipped_map = [['O'] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                flipped_map[i][cols - j - 1] = map_[i][j]\n        return ''.join(map(''.join, flipped_map))\n\n    stdin = stdin.split('\\n')\n    n = int(stdin.pop(0))\n    map1 = stdin[:n]\n    map2 = stdin[n:]\n\n    for k in range(4):\n        if map1[k % n] == map2[(k + n - 1) % n] and map1[(k + n - 1) % n] == map2[k % n]:\n            if map1[k % n] == 'X':\n                return 'Yes'\n            else:\n                return 'No'\n        map1 = rotate(map1, k)\n    for k in range(4):\n        map2 = rotate(map2, k)\n        if map1[k % n] == map2[(k + n - 1) % n] and map1[(k + n - 1) % n] == map2[k % n]:\n            if map1[k % n] == 'X':\n                return 'Yes'\n            else:\n                return 'No'\n    for k in range(2):\n        map1 = flip(map1)\n        if map1[k % n] == map2[(k + n - 1) % n] and map1[(k + n - 1) % n] == map2[k % n]:\n            if map1[k % n] == 'X':\n                return 'Yes'\n            else:\n                return 'No'\n        map2 = flip(map2)\n        if map1[k % n] == map2[(k + n - 1) % n] and map1[(k + n - 1) % n] == map2[k % n]:\n            if map1[k % n] == 'X':\n                return 'Yes'\n            else:\n                return 'No'\n    return 'No'\n\n\ndef"
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(map: list, n: int) -> list:\n        return [[map[j][i] for j in range(n)] for i in range(n)]\n    \n    def flip(map: list) -> list:\n        return [row[::-1] for row in map]\n    \n    def compare_maps(map1: list, map2: list) -> bool:\n        if len(map1) != len(map2):\n            return False\n        for i in range(len(map1)):\n            for j in range(len(map1[0])):\n                if map1[i][j] != map2[i][j]:\n                    return False\n        return True\n    \n    N, input_maps = stdin.split('\\n', 1)\n    N = int(N)\n    input_maps = input_maps.split('\\n')\n    map1 = [list(row) for row in input_maps[:N]]\n    map2 = [list(row) for row in input_maps[N:]]\n    \n    rotated_maps = [rotate(map1, i) for i in range(4)]\n    flipped_maps = [flip(map1), flip(map1[::-1])]\n    all_maps = rotated_maps + flipped_maps\n    \n    for other_map in all_maps:\n        if compare_maps(other_map, map2):\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    map1 = stdin[1:N+1]\n    map2 = stdin[N+1:]\n\n    for rotation in range(4):\n        flipped_map1 = map1.replace('O', 'X').replace('X', 'O')\n        rotated_map1 = flipped_map1.split('\\n')\n        for i in range(N):\n            rotated_map1[i] = rotated_map1[i][::-1]\n        rotated_map1 = '\\n'.join(rotated_map1)\n\n        if rotated_map1 == map2:\n            return 'Yes'\n        map1 = rotated_map1\n        map2 = map2.replace('O', 'X').replace('X', 'O')\n\n    return 'No'\n"
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    first_map = [list(stdin[1+i:1+i+N]) for i in range(0, N*N, N)]\n    second_map = [list(stdin[N*N+1+i:N*N+1+i+N]) for i in range(0, N*N, N)]\n\n    for _ in range(4):\n        first_map_rotated = [''.join(row) for row in zip(*first_map[::-1])]\n        if first_map_rotated == second_map:\n            return \"Yes\"\n        first_map = first_map_rotated\n        first_map = [row[::-1] for row in first_map]\n\n        second_map = [''.join(row) for row in zip(*second_map[::-1])]\n        if first_map == second_map:\n            return \"Yes\"\n        second_map = second_map[::-1]\n\n    return \"No\" "
    },
    {
        "number": 700,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    map1 = [list(input_list[i]) for i in range(1, N+1)]\n    map2 = [list(input_list[i]) for i in range(N+1, 2*N+1)]\n    \n    for i in range(4):\n        if map1 == rotate_map(map1):\n            return \"Yes\"\n        map1 = rotate_map(map1)\n        \n    return \"No\"\n\n\ndef"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = input().split()\n    while s != t:\n        if len(s) != len(t):\n            return \"need tree\"\n        s = s[1:]\n        t = t[:-1]\n    if len(s) == 0:\n        return \"automaton\"\n    return \"array\" if s == t else \"both\" "
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    s = input_data[0]\n    t = input_data[1]\n    \n    # Check if s and t are different\n    if s == t:\n        return \"need tree\"\n    \n    # Check if s can be transformed into t using suffix array\n    suffix_array = sorted(range(len(s)), key=lambda i: s[i:])\n    transformed_s = ''.join([s[i] for i in suffix_array])\n    if transformed_s == t:\n        return \"array\"\n    \n    # Check if s can be transformed into t using suffix automaton\n    automaton = {}\n    for i in range(len(s)):\n        if s[i:] in automaton:\n            automaton[s[i:]].append(i)\n        else:\n            automaton[s[i:]] = [i]\n    transformed_s = ''\n    for i in range(len(t)):\n        if t[:i+1] in automaton:\n            transformed_s += s[automaton[t[:i+1]][-1]]\n        else:\n            transformed_s += '?'\n    if transformed_s.replace('?', '') == t:\n        return \"automaton\"\n    \n    # Check if s can be transformed into t using both suffix array and automaton\n    return \"both\""
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    s, t = input_data[0], input_data[1]\n\n    # Check if s and t are different\n    if s == t:\n        return \"both\"\n\n    # Check if s can be transformed into t\n    for i in range(len(s)):\n        # Remove first character using suffix automaton\n        if s[i:] == t[:len(s) - i]:\n            s = t[i:]\n            break\n    else:\n        return \"need tree\"\n\n    # Check if s can be transformed into t using suffix array\n    for i in range(len(s)):\n        # Swap two characters using suffix array\n        s = s[:i] + s[i + 1] + s[i] + s[i + 2:]\n        if s == t:\n            return \"array\"\n\n    # If s can be transformed into t using both structures\n    return \"both\"\n\n\ndef"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n\n    # Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string.\n    def swap(string: str) -> str:\n        sa = SuffixArray(string)\n        return sa.swap()\n\n    # SuffixAutomaton is a class that represents a suffix automaton.\n    class SuffixAutomaton:\n        def __init__(self, string: str):\n            self.string = string\n            self.automaton = self.build_automaton()\n\n        def build_automaton(self) -> List[int]:\n            n = len(self.string)\n            automaton = [0] * n\n            for i in range(n):\n                j = i\n                while j < n and self.string[j] == self.string[i]:\n                    j += 1\n                automaton[i] = j - i\n            return automaton\n\n        def remove_char(self, index: int) -> str:\n            string = self.string\n            string = string[:index] + string[index + 1:]\n            return SuffixAutomaton(string).swap()\n\n    # SuffixArray is a class that represents a suffix array.\n    class SuffixArray:\n        def __init__(self, string: str):\n            self.string = string\n            self.suffix_array = self.build_suffix_array()\n\n        def build_suffix_array(self) -> List[int]:\n            n = len(self.string)\n            suffix_array = sorted(range(n), key=lambda i: self.string[i:])\n            return suffix_array\n\n        def swap(self) -> str:\n            string = self.string\n            sa = self.suffix_array\n            i, j = random.sample(range(len(sa)), 2)\n            string = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n            sa = SuffixArray(string).suffix_array\n            return string[sa[i]:sa[j]] + string[sa[j]:sa[i]]\n\n    # Find out whether the guys can solve the problem.\n    # If word s can be transformed into word t using suffix array, return \"array\".\n    # If word s can be transformed into word t using suffix automaton, return \"automaton\".\n    # If word s cannot be transformed into word t using any data structure, return \"need tree\".\n    def solve_problem(s: str, t: str) -> str:\n        sa_t = SuffixArray(t)\n        sa_s = SuffixArray(s)\n        for i in range(len(sa_s.string)):\n            if sa_s.suffix_array[i] != sa_t.suffix_array[i]:\n                return \"need tree\"\n        return \"array\"\n\n    # Apply the suffix automaton to word s.\n    sa = SuffixAutomaton(s)\n    for _ in range(len(s)):\n        s = sa.remove_char(0)\n    # Swap the characters of word s using the suffix array.\n    for _ in range(len(s)):\n        s = swap(s)\n    # Check if the transformed word s is equal to word t.\n    if s == t:\n        return \"automaton\"\n    else:\n        return \"need tree\"\n"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s, t = input().split()\n    n = len(s)\n    m = len(t)\n\n    # Preprocess s and t using suffix array and suffix automaton\n    def preprocess(word: str) -> str:\n        suffix_array = sorted(range(n), key=lambda i: word[i:])\n        suffix_automaton = {i: s[i:] for i in suffix_array}\n        return suffix_array, suffix_automaton\n\n    suffix_array_s, suffix_automaton_s = preprocess(s)\n    suffix_array_t, suffix_automaton_t = preprocess(t)\n\n    # Find the minimum number of transformations required to transform s into t\n    transformations = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            transformations += 1\n\n    # If the minimum number of transformations is less than or equal to 2, it's possible to transform s into t\n    if transformations <= 2:\n        if transformations == 0:\n            return \"both\"\n        elif transformations == 1:\n            # Use suffix automaton to remove any character\n            suffix_automaton_s = {i: s[i:] for i in suffix_array_s}\n            for i in range(n - 1, -1, -1):\n                if s[i] != t[i]:\n                    j = min(suffix_automaton_s[i], key=lambda x: abs(x - i))\n                    s = s[:i] + s[j:] + s[i + 1:j] + s[i] + s[j + 1:]\n                    suffix_array_s = sorted(range(n), key=lambda x: s[x:])\n                    suffix_automaton_s = {i: s[i:] for i in suffix_array_s}\n                    break\n            return \"automaton\"\n        elif transformations == 2:\n            # Use suffix array to swap any two characters\n            for i in range(n):\n                if s[i] != t[i]:\n                    j = s.index(t[i], i + 1)\n                    s = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]\n                    break\n            return \"array\"\n    else:\n        return \"need tree\" "
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s, t = input().split()\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            if j > 0:\n                i, j = i - j + 1, 1\n            else:\n                return \"need tree\"\n    if i == len(s) and j == len(t):\n        return \"both\"\n    else:\n        return \"need tree\"\n"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    s = words[0]\n    t = words[1]\n\n    if s == t:\n        return \"automaton\"\n\n    def suffix_automaton(word: str, target: str) -> bool:\n        if len(word) != len(target):\n            return False\n        for i in range(len(word)):\n            if word[i:] != target[i:]:\n                return False\n            if len(word) > 1 and word[i:] != word[1:][::-1]:\n                return False\n        return True\n\n    def suffix_array(word: str, target: str) -> bool:\n        if len(word) != len(target):\n            return False\n        for i in range(len(word)):\n            if word[i:] != target[i:]:\n                return False\n            if word[i:] != word[::-1][i:]:\n                return False\n            if i > 0 and word[i:] != word[i-1:][::-1]:\n                return False\n        return True\n\n    if suffix_automaton(s, t):\n        return \"automaton\"\n    elif suffix_array(s, t):\n        return \"array\"\n    else:\n        return \"need tree\"\n\n\ninput_data = \"\"\"automaton\ntomat\n\narray\narary\n\nboth\nhot\n\nneed\ntree\"\"\"\n\ninput_lines = input_data.split('\\n')\noutput_data = '\\n'.join([solution(line) for line in input_lines])\nprint(output_data)\n"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    s = input_data[0]\n    t = input_data[1]\n\n    # Check if s and t are different\n    if s == t:\n        return \"need tree\"\n\n    # Apply suffix automaton\n    s_automaton = s[::-1]\n    t_automaton = t[::-1]\n\n    # Check if s_automaton is a prefix of t_automaton\n    if not t_automaton.startswith(s_automaton):\n        return \"need tree\"\n\n    # Apply suffix array\n    def suffix_array(word: str) -> List[int]:\n        n = len(word)\n        suffixes = sorted(range(n), key=lambda i: word[i:])\n        return suffixes\n\n    s_array = suffix_array(s)\n    t_array = suffix_array(t)\n\n    # Check if t_array is a permutation of s_array\n    if sorted(t_array) != sorted(s_array):\n        return \"need tree\"\n\n    # Apply suffix transformation\n    def transform_suffix(word: str, index: int) -> str:\n        n = len(word)\n        suffix = word[index:]\n        suffix_index = s_array.index(index)\n        transformed_suffix = s_automaton[suffix_index:]\n        return transformed_suffix\n\n    # Transform s into t using suffix transformations\n    transformed_s = s\n    for i in range(len(s)):\n        transformed_s = transform_suffix(transformed_s, i)\n\n    # Check if transformed_s is equal to t\n    if transformed_s == t:\n        return \"array\"\n\n    # If you cannot solve the problem with only suffix array, then it is impossible to solve it with only suffix automaton\n    return \"need tree\"\n"
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    if len(s) != len(t):\n        return \"need tree\"\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            break\n    else:\n        return \"automaton\"\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            break\n    else:\n        return \"array\"\n    return \"both\""
    },
    {
        "number": 701,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    if s == t:\n        return \"both\"\n    elif any(s.endswith(suffix) for suffix in t):\n        return \"automaton\"\n    elif any(s[i] == t[i] for i in range(len(s))):\n        return \"array\"\n    else:\n        return \"need tree\"\n\n\ndef"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    board = [line.strip() for line in stdin.splitlines()[1:]]\n    \n    def is_valid_tile(x, y, tile):\n        for i in range(len(tile)):\n            for j in range(len(tile[0])):\n                if tile[i][j] == \"#\" and (x + i >= n or y + j >= n or board[x + i][y + j] == \"#\"):\n                    return False\n        return True\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for tile in [\n                    [(0,0), (0,1), (0,2), (0,3), (1,1)],\n                    [(0,1), (0,2), (0,3), (1,0), (1,1)],\n                    [(0,0), (0,1), (1,0), (1,1), (1,2)],\n                    [(0,1), (0,2), (0,3), (1,1), (1,2)],\n                    [(0,2), (0,3), (1,2), (1,3), (2,2)]\n                ]:\n                    if is_valid_tile(i, j, tile):\n                        board[i + tile[0][0]][j + tile[0][1]] = \"#\"\n                        board[i + tile[1][0]][j + tile[1][1]] = \"#\"\n                        board[i + tile[2][0]][j + tile[2][1]] = \"#\"\n                        board[i + tile[3][0]][j + tile[3][1]] = \"#\"\n                        board[i + tile[4][0]][j + tile[4][1]] = \"#\"\n                        if is_solution():\n                            return \"YES\"\n                        else:\n                            board[i + tile[0][0]][j + tile[0][1]] = \".\"\n                            board[i + tile[1][0]][j + tile[1][1]] = \".\"\n                            board[i + tile[2][0]][j + tile[2][1]] = \".\"\n                            board[i + tile[3][0]][j + tile[3][1]] = \".\"\n                            board[i + tile[4][0]][j + tile[4][1]] = \".\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n    \n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \"#\":\n                return \"NO\"\n    \n    def is_valid(piece, i, j, used):\n        used[i][j] = True\n        for di, dj in piece:\n            if i + di < 0 or i + di >= n or j + dj < 0 or j + dj >= n or used[i + di][j + dj]:\n                return False\n            if board[i + di][j + dj] == \"#\" and (i + di, j + dj) not in piece:\n                return False\n        return True\n    \n    pieces = [\n        [(0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)],\n        [(0, 2), (1, 1), (1, 2), (2, 0), (2, 1), (2, 3), (3, 0), (3, 2)],\n        [(0, 0), (1, 0), (1, 1), (2, 1), (3, 2), (3, 3)],\n        [(0, 0), (1, 0), (1, 1), (2, 1), (3, 3), (3, 4)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (3, 1), (3, 2), (4, 1)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (3, 1), (3, 2), (4, 2)],\n        [(0, 0), (0, 1), (1, 1), (2, 2), (3, 3), (3, 4), (4, 3)],\n        [(0, 0), (0, 1), (1, 1), (2, 2), (3, 3), (3, 4), (4, 4)],\n        [(0, 0), (1, 0), (1, 1), (2, 1), (3, 2), (3, 3), (4, 2)],\n        [(0, 0), (1, 0), (1, 1), (2, 1), (3, 2), (3, 3), (4, 3)],\n        [(0, 0), (0, 1), (1, 1), (2, 2), (3, 3), (3, 4), (4, 2)],\n        [(0, 0), (0, 1), (1, 1), (2, 2), (3, 3), (3, 4), (4, 4)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 2), (3, 4)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 2), (3, 3)],\n        [(0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 2), (3, 3)]\n    ]\n    \n    for piece in pieces:\n        used = [[False for _ in"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [[char for char in line] for line in stdin.splitlines()[1:]]\n\n    def is_valid_tile(x, y, tile_x, tile_y):\n        return board[x][y] == '.' and (x + tile_x >= 0 and x + tile_x < n and y + tile_y >= 0 and y + tile_y < n)\n\n    def is_valid_piece(x, y, piece_x, piece_y):\n        return all(is_valid_tile(x + dx, y + dy, piece_x, piece_y) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)])\n\n    def is_tiled(x, y, visited):\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return True\n        if board[x][y] == '#' or (x, y) in visited:\n            return False\n        visited.add((x, y))\n        return all(is_tiled(x + dx, y + dy, visited) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)])\n\n    return 'YES' if is_tiled(0, 0, set()) else 'NO'\n"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n\n    def is_valid(piece):\n        x, y = piece[0]\n        for dx, dy in piece[1:]:\n            if not (0 <= x+dx < n and 0 <= y+dy < n):\n                return False\n            if board[x+dx][y+dy] == \"#\":\n                return False\n            x, y = x+dx, y+dy\n        return True\n\n    def fill_tiles(x, y, pieces):\n        if len(pieces) == 5:\n            if is_valid(pieces):\n                for dx, dy in pieces:\n                    board[x+dx][y+dy] = \".\"\n                return True\n            else:\n                return False\n        for i in range(n):\n            for j in range(n):\n                if board[x+i][y+j] == \".\":\n                    if fill_tiles(x+i, y+j, pieces + [(i, j)]):\n                        return True\n        return False\n\n    return \"YES\" if fill_tiles(0, 0, []) else \"NO\""
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = stdin.splitlines()[1:]\n\n    def is_valid_tile(x, y, tile):\n        for i in range(5):\n            for j in range(5):\n                if i + x < 0 or i + x >= n or j + y < 0 or j + y >= n:\n                    return False\n                if board[i + x][j + y] == \"#\":\n                    return False\n        return True\n\n    def fill_board(x, y, tile):\n        for i in range(5):\n            for j in range(5):\n                if board[i + x][j + y] == \".\":\n                    board[i + x][j + y] = tile\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for tile in \"12345\":\n                    if is_valid_tile(i, j, tile):\n                        fill_board(i, j, tile)\n                        if is_board_filled():\n                            return \"YES\"\n                        else:\n                            board[i][j] = \".\"\n                return \"NO\"\n\n    def is_board_filled():\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \".\":\n                    return False\n        return True\n\n    return \"YES\" if is_board_filled() else \"NO\"\n"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n\n    def is_free(row, col):\n        return board[row][col] == '.'\n\n    def is_tile_fit(row, col, tile_row, tile_col):\n        for i in range(5):\n            next_row, next_col = row + tile_row[i], col + tile_col[i]\n            if not is_free(next_row, next_col):\n                return False\n        return True\n\n    def find_tiles(row, col, remaining):\n        if remaining == 0:\n            return True\n\n        for i in range(5):\n            next_row, next_col = row + tile_row[i], col + tile_col[i]\n            if is_free(next_row, next_col):\n                board[next_row][next_col] = '#'\n                if is_tile_fit(row, col, tile_row, tile_col):\n                    if find_tiles(next_row, next_col, remaining - 1):\n                        return True\n                board[next_row][next_col] = '.'\n\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if is_free(i, j):\n                tile_row = [0, 0, 1, -1, 0]\n                tile_col = [1, -1, 0, 0, -1]\n                if find_tiles(i, j, 5):\n                    return \"YES\"\n                break\n\n    return \"NO\"\n"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n    \n    def is_valid_tile(tile, row, col):\n        for i in range(len(tile)):\n            for j in range(len(tile)):\n                if tile[i][j] == \".\":\n                    continue\n                if board[row + i][col + j] != \".\":\n                    return False\n        return True\n    \n    def is_valid_tile_placement(tile, row, col):\n        for i in range(len(tile)):\n            for j in range(len(tile)):\n                if tile[i][j] == \"#\":\n                    continue\n                if board[row + i][col + j] == \"#\":\n                    return False\n        return True\n    \n    def is_tileable(row, col):\n        for i in range(len(board)):\n            for j in range(len(board)):\n                if board[i][j] == \".\":\n                    if not is_valid_tile_placement(tile, i, j):\n                        return False\n        return True\n    \n    def find_tilings():\n        for i in range(len(board)):\n            for j in range(len(board)):\n                if board[i][j] == \".\":\n                    tile = [[\"#\", \"#\", \"#\", \"#\"], [\"#\", \".\", \".\", \"#\"], [\"#\", \".\", \".\", \"#\"], [\"#\", \"#\", \"#\", \"#\"]]\n                    if is_valid_tile(tile, i, j):\n                        board[i][j] = \"1\"\n                        if is_tileable(i, j):\n                            find_tilings()\n                        board[i][j] = \".\"\n    \n    find_tilings()\n    \n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == \"1\":\n                board[i][j] = \"#\"\n            else:\n                board[i][j] = \".\"\n                \n    return \"YES\" if is_tileable(0, 0) else \"NO\"\n"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    board = [list(line) for line in input_list[1:]]\n\n    def is_valid_tiling(tiles_used):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \".\":\n                    if (i, j) not in tiles_used:\n                        return False\n                elif board[i][j] == \"#\":\n                    if (i, j) in tiles_used:\n                        return False\n        return True\n\n    def is_valid_piece(tiles_used, piece):\n        num_valid_tiles = 0\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \"#\":\n                    if (i, j) in tiles_used:\n                        if (i - 1, j) in piece or (i + 1, j) in piece or (i, j - 1) in piece or (i, j + 1) in piece:\n                            num_valid_tiles += 1\n        return num_valid_tiles == 5\n\n    def is_solution():\n        tiles_used = set()\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \".\":\n                    for piece in pieces:\n                        if is_valid_piece(tiles_used, piece):\n                            tiles_used.add((i, j))\n                            if is_valid_tiling(tiles_used):\n                                return True\n                            tiles_used.remove((i, j))\n        return False\n\n    pieces = [\n        [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1)],\n        [(1, 0), (1, 1), (1, 2), (1, 3), (2, 1)],\n        [(2, 0), (2, 1), (2, 2), (2, 3), (3, 1)],\n        [(0, 3), (0, 4), (0, 5), (0, 6), (1, 6)],\n        [(1, 6), (1, 5), (1, 4), (1, 3), (2, 3)],\n        [(2, 3), (2, 4), (2, 5), (2, 6), (3, 6)],\n        [(3, 3), (3, 4), (3, 5), (3, 6), (4, 6)],\n        [(0, 6), (0, 7), (0, 8), (0, 9), (1, 9)],\n        [(1, 9), (1, 8), (1, 7), (1, 6), (2, 6)],\n        [(2, 6), (2, 7), (2, 8), (2, 9), (3, 9)],\n        [(3, 6), (3, 7), (3, 8), (3, 9), (4, 9)],\n        [(0, 9), (0, 10), (0, 11), (0, 12), (1, 12)],\n        [(1, 12), (1, 11), (1, 10), (1, 9), (2, 9)],\n        [(2, 9), (2, 10), (2, 11), (2, 12), (3, 12)],\n        [(3, 9), (3, 10), (3, 11), (3, 12), (4, 12)],\n        [(0, 12), (0, 13), (0, 14), (0, 15), (1, 15)],\n        [(1, 15), (1, 14), (1, 13), (1, 12), (2, 12)],\n        [(2, 12), (2, "
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    board = [list(line) for line in stdin[1:n+1]]\n    # Determine if the board can be tiled by Alice's pieces\n    def can_tile(board, i, j):\n        if i < 0 or i >= n or j < 0 or j >= n:\n            return False\n        if board[i][j] == \"#\":\n            return False\n        if i == 0 and j == 0:\n            board[i][j] = \"#\"\n            return can_tile(board, i, j+1) and can_tile(board, i+1, j) and can_tile(board, i, j-1) and can_tile(board, i-1, j)\n        if i == 0:\n            board[i][j] = \"#\"\n            return can_tile(board, i, j+1) and can_tile(board, i, j-1)\n        if j == 0:\n            board[i][j] = \"#\"\n            return can_tile(board, i, j+1) and can_tile(board, i-1, j) and can_tile(board, i+1, j)\n        if i == n-1:\n            board[i][j] = \"#\"\n            return can_tile(board, i, j+1) and can_tile(board, i, j-1)\n        if j == n-1:\n            board[i][j] = \"#\"\n            return can_tile(board, i+1, j) and can_tile(board, i-1, j)\n        board[i][j] = \"#\"\n        return can_tile(board, i, j+1) and can_tile(board, i, j-1) and can_tile(board, i-1, j) and can_tile(board, i+1, j)\n\n    if can_tile(board, 0, 0):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 702,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_piece(row, col, piece, board):\n        for r, c in piece:\n            if r < 0 or c < 0 or r >= len(board) or c >= len(board[0]):\n                return False\n            if board[r][c] != \".\":\n                return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    board = [list(line) for line in stdin.splitlines()[1:]]\n    pieces = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    valid_pieces = []\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for piece in valid_pieces:\n                    if is_valid_piece(i, j, piece, board):\n                        board[i][j] = \"#\"\n                        break\n                else:\n                    for p in pieces:\n                        if is_valid_piece(i, j, p, board):\n                            valid_pieces.append(p)\n                            break\n                    else:\n                        return \"NO\"\n\n    return \"YES\" if all(c == \"#\" for row in board for c in row) else \"NO\"\n"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n\n    # Compute the maximum number of sections we can have\n    max_sections = max(1, a // v, b // k)\n\n    # Compute the minimum number of boxes needed\n    min_boxes = max(1, (a + v - 1) // v, (b + k - 1) // k)\n\n    # Compute the minimum number of sections needed\n    min_sections = max(1, (a + v - 1) // v, (b + k - 1) // k, max_sections)\n\n    # Compute the answer\n    answer = min_boxes * min_sections\n\n    return str(answer)"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    result = 0\n    divisors = 0\n    nuts = a\n    \n    while nuts > 0:\n        if nuts <= v and k > 1:\n            result += 1\n            k -= 1\n        elif k > 1:\n            result += 1\n            k -= 1\n        elif nuts <= v:\n            result += 1\n            nuts -= v\n        else:\n            break\n        \n    return result"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    \n    boxes = 1\n    if a % k != 0:\n        boxes += a // k + 1\n    \n    if b > 1:\n        if a > v:\n            boxes += b - 1\n    \n    return str(boxes)\n\ndef"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, n, b, v = map(int, stdin.split())\n    \n    def count_sections(n, b, v):\n        return max(1, (n + v - 1) // v)\n    \n    def count_boxes(n, k, b, v):\n        boxes = 0\n        nuts_left = n\n        while nuts_left > 0:\n            boxes += 1\n            sections = count_sections(nuts_left, b, v)\n            nuts_left -= v * sections\n        return boxes\n    \n    boxes = count_boxes(n, k, b, v)\n    return str(boxes)"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    if a == 0:\n        return 0\n    if a <= v:\n        return 1\n    if k == 1:\n        return 1\n    if b == 1:\n        return a // v + 1\n    if b > a // v:\n        return a // v + 1\n    return a // v + b\n\n\ndef"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    ans = 1\n    while a >= v:\n        a -= b\n        ans += 1\n    return str(ans)"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    if k < a:\n        return \"0\"\n    if v > a:\n        return \"0\"\n    if k == a:\n        return \"1\"\n    if b == 1:\n        return \"1\"\n    min_boxes = k + 1\n    for i in range(1, a + 1):\n        for j in range(1, k + 1):\n            if j * i > a:\n                continue\n            if (j * i + b - 1) // b <= k:\n                min_boxes = min(min_boxes, j * i)\n    return str(min_boxes)\n\ndef"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    \n    def is_possible(nuts, boxes):\n        if boxes == 1:\n            return nuts <= v\n        return nuts % a == 0\n    \n    low, high = 0, b\n    while low <= high:\n        mid = (low + high) // 2\n        if is_possible(a, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    return low\n\ndef"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n\n    if k <= 1 or a == 0 or b == 0 or v == 0:\n        return \"0\"\n\n    if b > k:\n        return str(k)\n\n    boxes = [0] * (k + 1)\n    boxes[1] = a // v\n\n    for i in range(2, k + 1):\n        if b - i + boxes[i - 1] <= 0:\n            boxes[i] = boxes[i - 1]\n        else:\n            boxes[i] = min(boxes[i - 1] + 1, b - i + boxes[i - 1])\n\n    return str(boxes[-1])\n"
    },
    {
        "number": 703,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    if b > 1:\n        b = 1\n    if a < b:\n        a = b\n    if a % v == 0:\n        a = a // v * v\n    if a == 0:\n        a = v\n    b_max = a // v\n    b_min = min(a // v, b)\n    boxes = []\n    for i in range(b_min, b_max + 1):\n        sections = i + 1\n        if sections > k:\n            continue\n        nuts_per_section = (a + sections - 1) // sections\n        if nuts_per_section > v:\n            continue\n        boxes.append((i, nuts_per_section))\n    if not boxes:\n        return 0\n    return len(boxes)\n\n\ndef"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = [int(x) for x in stdin.splitlines()[1].split()]\n    r_1, c_1, r_2, c_2 = [int(x) for x in stdin.splitlines()[2].split()]\n\n    min_moves = float('inf')\n    for r in range(1, n + 1):\n        line = lines[r - 1]\n        if r == r_1:\n            c_1 -= 1\n        if r == r_2:\n            c_2 -= 1\n\n        moves = 0\n        while c_1 > 0 and line < c_1:\n            moves += 1\n            c_1 -= 1\n            line += 1\n        while c_2 > 0 and line < c_2:\n            moves += 1\n            c_2 -= 1\n            line += 1\n        min_moves = min(min_moves, moves)\n\n    return min_moves\n"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    r1, c1, r2, c2 = map(int, lines[2].split())\n\n    min_pushes = float('inf')\n\n    for r in range(r1, r2):\n        for c in range(c1, c2 + 1):\n            pushes = 0\n            if r == 0:\n                pushes += r1 - 1\n            if r == n - 1:\n                pushes += n - r2\n            if c > a[r]:\n                pushes += c - a[r]\n            if c < c1:\n                pushes += c1 - c\n            min_pushes = min(min_pushes, pushes)\n\n    return str(min_pushes)\n"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_keys(n: int, a: List[int], r1: int, c1: int, r2: int, c2: int) -> int:\n        keys = {\n            \"Up\": lambda r, c, n: (r - 1, c) if r > 1 else (r, c),\n            \"Down\": lambda r, c, n: (r + 1, c) if r < n else (r, c),\n            \"Right\": lambda r, c, n: (r, min(c + 1, a[r] + 1)) if c < a[r] else (r, c),\n            \"Left\": lambda r, c, n: (r, max(1, c - 1)) if c > 1 else (r, c)\n        }\n        r, c = r1, c1\n        count = 0\n        while r != r2 or c != c2:\n            direction = \"Up\"\n            for d in [\"Up\", \"Down\", \"Right\", \"Left\"]:\n                rn, cn = keys[d](r, c, n)\n                if rn == r and cn == c:\n                    continue\n                r, c = rn, cn\n                count += 1\n                direction = d\n                break\n            else:\n                break\n        return count\n\n    n, *a = list(map(int, stdin.split()))\n    r1, c1, r2, c2 = map(int, input().split())\n    return get_min_keys(n, a, r1, c1, r2, c2)\n"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    r1, c1, r2, c2 = map(int, stdin[2].split())\n\n    min_pushes = float('inf')\n    for r in range(1, n + 1):\n        row = a[r - 1]\n        if r1 == r and c1 > row + 1:\n            c1 = row + 1\n        if r2 == r and c2 > row + 1:\n            c2 = row + 1\n\n        pushes = 0\n        if r1 < r:\n            pushes += r - r1\n        if r2 < r:\n            pushes += r2 - r\n\n        if c1 < c2:\n            pushes += c2 - c1\n        else:\n            pushes += a[r - 1] - c1 + 1\n\n        min_pushes = min(min_pushes, pushes)\n\n    return min_pushes\n\n\ndef"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin[0])\n    a = [int(x) for x in stdin[1].split()]\n    r_1, c_1, r_2, c_2 = [int(x) for x in stdin[2].split()]\n    \n    # initialize variables\n    min_moves = float('inf')\n    prev_r, prev_c = 1, 1\n    \n    # iterate through lines\n    for i in range(1, n + 1):\n        # if current line is shorter than previous one, move cursor to last position\n        if i < prev_r:\n            min_moves += a_1 - prev_c + 1\n            prev_c = a_1 + 1\n            continue\n        \n        # if cursor can move right, move cursor to the right\n        if c_1 < a[i - 1]:\n            min_moves += c_1 - prev_c\n            prev_c = c_1\n        # if cursor can't move right, move cursor to last position of previous line\n        else:\n            min_moves += a[i - 1] - prev_c + 1\n            prev_c = a[i - 1] + 1\n        \n        # update previous line and cursor position\n        prev_r = i\n    \n    # move cursor to the last position of the last line\n    min_moves += a_n - prev_c + 1\n    \n    # check if cursor can move right, move cursor to the right\n    if c_2 > 1:\n        min_moves += c_2 - prev_c\n    # if cursor can't move right, move cursor to the last position of the previous line\n    else:\n        min_moves += a_n - prev_c + 1\n    \n    return min_moves"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    r1, c1, r2, c2 = map(int, stdin[2].split())\n\n    moves = 0\n    r = 1\n    c = 1\n\n    while r != r2 or c != c2:\n        if r == 1 and c == 1:\n            if r2 == 1 and c2 == 1:\n                break\n            else:\n                if c2 <= a[r2 - 1] + 1:\n                    moves += 1\n                    c = c2\n                else:\n                    moves += 1\n                    c = a[r2 - 1] + 1\n                r = r2\n        elif r2 > r:\n            moves += 1\n            r = r2\n            c = 1\n        elif c2 > c:\n            moves += 1\n            c = c2\n        elif c2 <= a[r2 - 1] + 1:\n            moves += 1\n            c = c2\n        else:\n            moves += 1\n            c = a[r2 - 1] + 1\n\n    return moves\n"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    r_1, c_1, r_2, c_2 = map(int, stdin.split('\\n')[2].split())\n\n    count = 0\n    current_line = 1\n    current_position = 1\n\n    while current_line != r_2 or current_position != c_2:\n        if current_line == r_1 and current_position == c_1:\n            count += 1\n            current_line = r_2\n            current_position = c_2\n        elif current_line == 1 and current_position == 1:\n            count += max(c_1 - 1, a[current_line - 1] - c_1 + 1)\n            current_position = max(c_1 - 1, a[current_line - 1] - c_1 + 1)\n        elif current_line == n and current_position == a[current_line - 1] + 1:\n            count += max(c_1 - 1, a[current_line - 1] - c_1 + 1)\n            current_position = max(c_1 - 1, a[current_line - 1] - c_1 + 1)\n        elif current_position == 1:\n            count += a[current_line - 1]\n            current_position = a[current_line - 1]\n        elif current_position == a[current_line - 1] + 1:\n            count += 1\n            current_position = 1\n        elif current_position == c_1 - 1:\n            count += 1\n            current_position = c_1\n        elif current_position == a[current_line - 1]:\n            count += 1\n            current_position = a[current_line - 1] + 1\n        elif current_position < c_1:\n            count += c_1 - current_position\n            current_position = c_1\n        elif current_position > c_1:\n            count += current_position - c_1\n            current_position = 1\n        else:\n            count += 1\n            current_line += 1\n            current_position = 1\n\n    return count"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    lines = list(map(int, input().split()))\n    \n    r1, c1, r2, c2 = map(int, input().split())\n    \n    dist = 0\n    current_line = 0\n    current_col = 1\n    \n    for i in range(r1, r2):\n        if i < r2 - 1:\n            dist += lines[i + 1] + 1\n        else:\n            dist += c2 - current_col\n        \n        dist += c1 - current_col\n        current_line = i\n        current_col = c1\n    \n    return dist\n\n\nstdin = '''4\n2 1 6 4\n3 4 4 2\n'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    r1, c1, r2, c2 = map(int, stdin[2].split())\n\n    if r1 == r2:\n        if c1 == c2:\n            return 0\n        else:\n            return min(abs(c1 - c2), abs(c2 - c1))\n    else:\n        up = abs(r1 - r2) - 1\n        down = abs(r1 - r2) - 1\n        right = min(abs(c1 - c2), a[r2 - 1] - c1 + 1)\n        left = min(abs(c1 - c2), c1 - 1)\n\n        return up + down + right + left\n"
    },
    {
        "number": 704,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    r1, c1, r2, c2 = map(int, lines[2].split())\n\n    # Calculate the number of movements\n    count = 0\n    r, c = r1, c1\n    while r != r2 or c != c2:\n        # Up\n        if r > 1 and a[r - 2] + 1 > c:\n            r -= 1\n            continue\n        # Down\n        if r < n and a[r] + 1 > c:\n            r += 1\n            continue\n        # Right\n        if a[r - 1] + 1 > c:\n            c += 1\n            continue\n        # Left\n        if c > 1:\n            c -= 1\n            continue\n        # If none of the above conditions are met, the cursor can't move to the desired position\n        count = -1\n        break\n\n    return count\n"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x_str, y_str = stdin.splitlines()[1:]\n    x = list(map(int, x_str.split()))\n    y = list(map(int, y_str.split()))\n\n    xor_pairs = 0\n    for i in range(n):\n        for j in range(n):\n            if (x[i] ^ y[j]) in set(x):\n                xor_pairs += 1\n            if (x[i] ^ y[j]) in set(y):\n                xor_pairs += 1\n\n    return \"Karen\" if xor_pairs % 2 == 0 else \"Koyomi\"\n\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x_seq = list(map(int, stdin.splitlines()[1].split()))\n    y_seq = list(map(int, stdin.splitlines()[2].split()))\n\n    pairs = 0\n    for i in range(n):\n        for j in range(n):\n            if (x_seq[i] ^ y_seq[j]) in set(x_seq + y_seq):\n                pairs += 1\n\n    return \"Karen\" if pairs % 2 == 0 else \"Koyomi\"\n"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    xor_sum = [x[i] ^ y[j] for i in range(n) for j in range(n) if i < j]\n\n    if len(xor_sum) % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\"\n\n\ninput_stdin = \"\"\"3\n1 2 3\n4 5 6\"\"\"\n\nprint(solution(input_stdin))"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    x = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    y = [int(y) for y in stdin.split(\"\\n\")[2].split()]\n\n    xor_values = set()\n    for i in range(n):\n        for j in range(n):\n            xor_values.add(x[i] ^ y[j])\n\n    return \"Karen\" if len(xor_values) % 2 == 0 else \"Koyomi\"\n\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    x_sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n    y_sequence = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    x_sequence = sorted(set(x_sequence))\n    y_sequence = sorted(set(y_sequence))\n\n    pairs = [(x_sequence[i] ^ y_sequence[j], x_sequence[i], y_sequence[j]) for i in range(n) for j in range(n)]\n\n    count = len([p for p in pairs if p[0] == 1])\n\n    return \"Karen\" if count % 2 == 0 else \"Koyomi\"\n\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x_list = list(map(int, stdin.split('\\n')[1].split()))\n    y_list = list(map(int, stdin.split('\\n')[2].split()))\n\n    xor_list = [x ^ y for x, y in zip(x_list, y_list)]\n\n    count = xor_list.count(1)\n    if count % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\"\n\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    x = list(map(int, stdin.split(\"\\n\")[1].split()))\n    y = list(map(int, stdin.split(\"\\n\")[2].split()))\n    \n    xor_values = [x[i] ^ y[i] for i in range(n)]\n    xor_values = list(set(xor_values))\n    \n    count = 0\n    for value in xor_values:\n        if value == 1:\n            count += 1\n    \n    if count % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\"\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x_str = stdin.split('\\n')[1]\n    y_str = stdin.split('\\n')[2]\n    x = list(map(int, x_str.split()))\n    y = list(map(int, y_str.split()))\n\n    pairs = 0\n    for i in range(n):\n        for j in range(n):\n            if (x[i] ^ y[j]) == 1:\n                pairs += 1\n\n    if pairs % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\"\n"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    x = list(map(int, stdin.split(\"\\n\")[1].split()))\n    y = list(map(int, stdin.split(\"\\n\")[2].split()))\n    pairs = 0\n    for i in range(n):\n        for j in range(n):\n            if (x[i] ^ y[j]) in x + y:\n                pairs += 1\n    return \"Karen\" if pairs % 2 == 0 else \"Koyomi\"\n\n\ndef"
    },
    {
        "number": 705,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n    y = list(map(int, stdin.splitlines()[2].split()))\n\n    xor_count = 0\n    for i in range(n):\n        for j in range(n):\n            if (x[i] ^ y[j]) in x + y:\n                xor_count += 1\n\n    if xor_count % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\"\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n\n    mod = 10**9 + 7\n\n    def g(a, b, n, x, mod):\n        if n == 0:\n            return x\n        else:\n            return (a * g(a, b, n - 1, x, mod) + b) % mod\n\n    result = g(A, B, n, x, mod)\n    return str(result)\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    \n    def g(x, n, A, B):\n        if n == 0:\n            return x\n        else:\n            return f(g(x, n - 1, A, B), A, B)\n    \n    def f(x, A, B):\n        return (A * x + B) % (10**9 + 7)\n    \n    return str(g(x, n, A, B))\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    mod = 10**9 + 7\n    result = x\n    for _ in range(n):\n        result = (A * result + B) % mod\n    return str(result)\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    def g(n, x):\n        if n == 0:\n            return x\n        else:\n            return f(g(n-1, x), A, B) % (10**9 + 7)\n\n    def f(x, A, B):\n        return (A * x + B) % (10**9 + 7)\n\n    return str(g(n, x))\n\n\nprint(solution(input())) "
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    gn = x\n    for i in range(n - 1):\n        gn = (A * gn + B) % (10**9 + 7)\n    return gn % (10**9 + 7)\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    mod = 10**9 + 7\n    gn_x = x\n    for i in range(n):\n        gn_x = (A * gn_x + B) % mod\n    return str(gn_x)\n\n\ninput_str = input(\"Enter A, B, n, x: \")\nresult = solution(input_str)\nprint(\"Output: \", result) "
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    modulo = 10**9 + 7\n    \n    def g(x, n):\n        if n == 0:\n            return x\n        else:\n            return (A * x + B) % modulo\n    \n    result = g(x, n)\n    \n    return str(result)\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    def f(x):\n        return A * x + B\n    \n    def g(n, x):\n        if n == 0:\n            return x\n        else:\n            return f(g(n-1, x))\n    \n    return g(n, x) % (10**9 + 7)\n\ndef"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_g(x: int, n: int, A: int, B: int) -> int:\n        for _ in range(n):\n            x = (A * x + B) % (10**9 + 7)\n        return x\n\n    A, B, n, x = map(int, stdin.split())\n    result = calculate_g(x, n, A, B)\n    return str(result)\n"
    },
    {
        "number": 706,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    \n    def f(x):\n        return A * x + B\n    \n    def g(x, n):\n        if n == 0:\n            return x\n        else:\n            return f(g(x, n - 1))\n    \n    return g(x, n) % (10**9 + 7)\n"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_alarm_time(x, p, y, j):\n        if y + j * p <= x[0]:\n            return x[0] - (y + j * p)\n        else:\n            return 0\n\n    n, m = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:2 + n]))\n    p = list(map(int, stdin.split()[2 + n:]))\n\n    y, j = 1, 1\n    while j <= m:\n        if sum(find_alarm_time(x, p[j - 1], y, j) for j in range(1, m + 1)) == 0:\n            break\n        j += 1\n\n    if j > m:\n        return \"YES\\n{}\\n{}\".format(y, j)\n    else:\n        return \"NO\" "
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    x = list(map(int, stdin.splitlines()[1].split()))\n    p = list(map(int, stdin.splitlines()[2].split()))\n\n    for i in range(1, n):\n        if x[i] <= x[i - 1]:\n            return \"NO\"\n\n    for j in range(m):\n        for i in range(1, n):\n            if x[i] - x[i - 1] != p[j]:\n                break\n        else:\n            if j == m - 1 and x[n - 1] - x[n - 2] == p[j]:\n                return \"YES\\n1 {}\".format(j + 1)\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    n, m = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    p = list(map(int, stdin.readline().split()))\n\n    x.sort()\n    start_minute = binary_search(x, x[0] + p[0] * 2)\n\n    if start_minute == -1:\n        return \"NO\"\n\n    for j in range(1, m):\n        if x[0] + (j + 1) * p[j] * 2 - 1 > x[-1]:\n            return \"NO\"\n\n        if binary_search(x, x[0] + (j + 1) * p[j] * 2) == -1:\n            return \"NO\"\n\n    return \"YES\\n{}\\n{}\".format(start_minute + 1, j + 1) "
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    x = list(map(int, input_list[1].split()))\n    p = list(map(int, input_list[2].split()))\n\n    p.sort(reverse=True)\n\n    for j in range(m):\n        y = x[0]\n        if y % p[j] == 0:\n            for i in range(1, n):\n                if (x[i] - x[i - 1]) % p[j] != 0:\n                    break\n            else:\n                return \"YES\\n{}\\n{}\".format(y, j + 1)\n\n    return \"NO\"\n"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(alarm_start: int, interval: int, minutes: List[int]) -> bool:\n        for minute in minutes:\n            if minute % interval == 0 and minute >= alarm_start:\n                return False\n        return True\n\n    def find_valid_alarm_settings(minutes: List[int], intervals: List[int]) -> Optional[Tuple[int, int]]:\n        for j, interval in enumerate(intervals):\n            for alarm_start in range(1, 10**18):\n                if is_valid(alarm_start, interval, minutes):\n                    return alarm_start, j\n        return None\n\n    n, m = map(int, stdin.readline().split())\n    minutes = list(map(int, stdin.readline().split()))\n    intervals = list(map(int, stdin.readline().split()))\n\n    result = find_valid_alarm_settings(minutes, intervals)\n    if result is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(y, p_j, x):\n        if y % p_j != 0:\n            return False\n        return x % p_j == 0\n\n    def find_valid(x, p):\n        for y in range(1, x + 1):\n            if is_valid(y, p, x):\n                return y\n        return None\n\n    n, m = map(int, input().split())\n    x = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n\n    for j in range(m):\n        y = find_valid(x[-1], p[j])\n        if y is not None:\n            break\n\n    if y is None:\n        return \"NO\"\n\n    return \"YES\\n{}\\n{}\".format(y, j + 1)"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = [i.strip() for i in stdin.split('\\n')]\n    n, m = map(int, input[0].split())\n    x = list(map(int, input[1].split()))\n    p = list(map(int, input[2].split()))\n\n    min_x = min(x)\n    max_x = max(x)\n    min_p = min(p)\n    max_p = max(p)\n\n    for j in range(m):\n        if min_p <= max_x - min_x <= max_p:\n            y = min_x\n            return \"YES\\n{}\\n{}\".format(y, j + 1)\n\n    return \"NO\"\n"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def next_multiple(multiple: int, number: int) -> int:\n        return multiple * ((number + multiple - 1) // multiple)\n\n    def find_y(x: int, p: int, x_i: int) -> int:\n        return next_multiple(p, x_i) - (x_i - x) % p\n\n    def is_valid(y: int, p: int, x: int, x_i: int) -> bool:\n        return x_i >= y and (x_i - y) % p == 0\n\n    n, m = map(int, stdin.splitlines()[0].split())\n    x = list(map(int, stdin.splitlines()[1].split()))\n    p = list(map(int, stdin.splitlines()[2].split()))\n\n    for j, p_j in enumerate(p, start=1):\n        y_j = find_y(x[0], p_j, x[0])\n        if all(is_valid(y_j, p_j, x[i], x[i]) for i in range(1, n)):\n            return \"YES\\n{}\\n{}\".format(y_j, j)\n\n    return \"NO\"\n"
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    x = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n\n    p.sort(reverse=True)\n\n    first_minute = None\n    option_index = None\n\n    for j, p_j in enumerate(p):\n        for y in range(1, x[-1] + 1):\n            can_choose = True\n            for i in range(n):\n                if x[i] - y + 1 <= 0 or x[i] - y + 1 % p_j != 0:\n                    can_choose = False\n                    break\n            if can_choose:\n                first_minute = y\n                option_index = j + 1\n                break\n\n    if first_minute is None:\n        return \"NO\"\n    else:\n        return \"YES\\n{}\\n{}\".format(first_minute, option_index)\n\ninput_string = \"\"\"3 5\n3 12 18\n2 6 5 3 3\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 707,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_max_diff(arr: List[int]) -> Tuple[int, int]:\n        min_diff = float('inf')\n        max_diff = float('-inf')\n        for i in range(len(arr) - 1):\n            diff = arr[i + 1] - arr[i]\n            min_diff = min(min_diff, diff)\n            max_diff = max(max_diff, diff)\n        return min_diff, max_diff\n\n    def is_possible(y: int, p: int, x: List[int]) -> bool:\n        diffs = [x[i + 1] - x[i] for i in range(len(x) - 1)]\n        min_diff, max_diff = find_min_max_diff(diffs)\n        return y + p * len(x) <= x[-1] and (x[-1] - y) % p == 0 and p <= max_diff\n\n    def find_best_choice(x: List[int], p_arr: List[int]) -> Tuple[int, int]:\n        min_diff = float('inf')\n        best_y = -1\n        best_j = -1\n        for j, p in enumerate(p_arr):\n            for y in range(1, x[-1] + 1):\n                if is_possible(y, p, x):\n                    diff = x[-1] - y\n                    if diff < min_diff:\n                        min_diff = diff\n                        best_y = y\n                        best_j = j + 1\n        return best_y, best_j\n\n    n, m = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:2 + n]))\n    p_arr = list(map(int, stdin.split()[2 + n:]))\n\n    if is_possible(1, p_arr[0], x):\n        result = \"YES\\n1 1\"\n    else:\n        result = \"NO\"\n        y, j = find_best_choice(x, p_arr)\n        if y != -1 and j != -1:\n            result = \"YES\\n{} {}\".format(y, j)\n\n    return result\n\ninput_data = \"\"\"3 5\n3 12 18\n2 6 5 3 3\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible_path(v, u):\n        if len(v) != len(u):\n            return False\n        for i in range(1, len(v)):\n            if v[i] == v[i - 1] or v[i] == u[i - 1] or u[i] == v[i - 1] or u[i] == u[i - 1]:\n                return False\n        return True\n\n    def generate_path(a, b):\n        path = [a]\n        for i in range(1, n):\n            if i % 2 == 0:\n                path.append(path[-1] + 1)\n            else:\n                path.append(path[-1] - 1)\n        path.append(b)\n        return path\n\n    def print_path(path):\n        return ' '.join(map(str, path))\n\n    n, k = map(int, stdin.readline().split())\n    a, b, c, d = map(int, stdin.readline().split())\n\n    path_ab = generate_path(a, b)\n    path_cd = generate_path(c, d)\n\n    if not is_possible_path(path_ab, path_cd) or len(path_ab) > k or len(path_cd) > k:\n        return '-1\\n'\n\n    return print_path(path_ab) + '\\n' + print_path(path_cd) + '\\n'\n"
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    if a == b or c == d:\n        return -1\n    if a == c or a == d or b == c or b == d:\n        return -1\n    if k == 0:\n        return -1\n    if n - 1 > k:\n        return -1\n\n    paths = []\n\n    if a != 1:\n        paths.append([1, a])\n        k -= 1\n    if b != n:\n        paths.append([b, n])\n        k -= 1\n    if c != 1:\n        paths.append([1, c])\n        k -= 1\n    if d != n:\n        paths.append([d, n])\n        k -= 1\n\n    for i in range(2, n):\n        if k == 0:\n            return -1\n        if i == a or i == b or i == c or i == d:\n            return -1\n        paths.append([i, i + 1])\n        k -= 1\n\n    if k > 0:\n        return -1\n\n    for path in paths:\n        path.append(path[-1])\n\n    output = \"\"\n    for path in paths:\n        output += \" \".join(map(str, path)) + \"\\n\"\n\n    return output\n\n\nn, k = 7, 11\na, b, c, d = 2, 4, 7, 3\nprint(solution(input())) "
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    if a == b or c == d:\n        return -1\n\n    # Check if there are at most k roads\n    roads_count = 0\n    for i in range(1, n + 1):\n        roads_count += 2\n        if roads_count > k:\n            return -1\n\n    # Generate first path\n    path = []\n    path.append(a)\n    for i in range(n - 1):\n        if a == b and a == c:\n            return -1\n        if a == b:\n            path.append(b)\n            a = b\n            b = c\n            c = d\n        elif a == c:\n            path.append(c)\n            a = b\n            b = c\n            c = d\n        else:\n            path.append(a)\n            a = b\n            b = c\n            c = d\n    path.append(d)\n\n    # Generate second path\n    path2 = []\n    path2.append(c)\n    for i in range(n - 1):\n        if path2[-1] == path[i]:\n            return -1\n        path2.append(path[i])\n    path2.append(d)\n\n    return ' '.join(map(str, path)) + '\\n' + ' '.join(map(str, path2)) + '\\n'\n"
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_roads(path: list) -> int:\n        return len(set([(path[i], path[i+1]) for i in range(len(path)-1)]))\n\n    def check_path(path: list) -> bool:\n        for i in range(len(path) - 1):\n            if path[i] + 1 != path[i+1]:\n                return False\n        return True\n\n    n, k, a, b, c, d = map(int, input().split())\n    path1 = [a, b] + list(range(1, n+1))\n    path2 = [c, d] + list(range(1, n+1))\n\n    if count_roads(path1) > k or count_roads(path2) > k:\n        return -1\n\n    if not check_path(path1) or not check_path(path2):\n        return -1\n\n    return ' '.join(map(str, path1)), ' '.join(map(str, path2))\n"
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    def check_path(path, a, b, c, d):\n        if path[0] != a or path[-1] != b:\n            return False\n        for i in range(len(path) - 1):\n            if path[i] + 1 != path[i + 1]:\n                return False\n        return True\n\n    paths = [[a, b], [c, d]]\n    for i in range(len(paths)):\n        path = list(range(a, b + 1))\n        if not check_path(path, a, b, c, d):\n            return -1\n        paths[i] = path\n\n    return \"\\n\".join(str(path) for path in paths)\n\n\nstdin = \"\"\"7 11\n2 4 7 3\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1000 999\n10 20 30 40\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    cities = sorted(map(int, input_list[1].split()))\n    a, b, c, d = cities\n    if a == b or c == d:\n        return -1\n\n    def is_possible(v_i: int, u_i: int) -> bool:\n        if v_i == u_i:\n            return False\n        if u_i - v_i > k:\n            return False\n        return True\n\n    def generate_path(start: int, end: int) -> List[int]:\n        path = [start]\n        i = 0\n        while i < n - 1:\n            path.append(path[i] + 1)\n            i += 1\n        path.append(end)\n        return path\n\n    v_path = generate_path(a, b)\n    u_path = generate_path(c, d)\n\n    if not all(is_possible(v, u) for v, u in zip(v_path, u_path)):\n        return -1\n\n    return f\"{a} {' '.join(map(str, v_path))} {c} {' '.join(map(str, u_path))} {b} {d}\""
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    # Check if there are at most k roads in Bearland\n    if k < n - 1:\n        return -1\n\n    # Check if a, b, c, d are all distinct\n    if len(set([a, b, c, d])) < 4:\n        return -1\n\n    # Check if there is a road between a and b\n    if a == b:\n        return -1\n\n    # Check if there is a road between c and d\n    if c == d:\n        return -1\n\n    # Check if there is a road between b and c\n    if c - a > k:\n        return -1\n\n    # Check if there is a road between a and d\n    if d - b > k:\n        return -1\n\n    # Generate the paths\n    v_path = [a]\n    u_path = [c]\n\n    for i in range(1, n - 1):\n        # Check if there is a road between v_path[i - 1] and v_path[i]\n        if v_path[i - 1] + 1 == v_path[i]:\n            return -1\n\n        # Check if there is a road between u_path[i - 1] and u_path[i]\n        if u_path[i - 1] + 1 == u_path[i]:\n            return -1\n\n        # Generate the next city for v_path and u_path\n        if i <= k - (b - a) - 1:\n            v_path.append(v_path[i] + 1)\n        else:\n            v_path.append(v_path[i] + b - a + i - k)\n\n        if i <= k - (d - b) - 1:\n            u_path.append(u_path[i] + 1)\n        else:\n            u_path.append(u_path[i] + d - b + i - k)\n\n    # Check if the paths end correctly\n    if v_path[-1] != b:\n        return -1\n\n    if u_path[-1] != d:\n        return -1\n\n    # Print the paths\n    v_path_str = ' '.join(map(str, v_path))\n    u_path_str = ' '.join(map(str, u_path))\n\n    return v_path_str + '\\n' + u_path_str + '\\n' "
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    def is_valid(path):\n        for i in range(1, n - 1):\n            if (path[i - 1], path[i]) in roads or (path[i], path[i + 1]) in roads:\n                return False\n        return True\n\n    def generate_paths(a, b, c, d):\n        paths = []\n        for ab_path in [[a, b], [b, a]]:\n            for cd_path in [[c, d], [d, c]]:\n                for i in range(n - 1):\n                    path = [ab_path[0], ab_path[1], cd_path[0], cd_path[1]]\n                    if i % 2 == 0:\n                        path[2 * i + 2] = ab_path[1]\n                        path[2 * i + 3] = cd_path[1]\n                    else:\n                        path[2 * i + 2] = cd_path[0]\n                        path[2 * i + 3] = ab_path[0]\n                    if is_valid(path):\n                        paths.append(path)\n        return paths\n\n    roads = [((a, b), (b, a)), ((c, d), (d, c))]\n    paths = generate_paths(a, b, c, d)\n\n    if len(paths) == 0:\n        return \"-1\"\n    elif len(roads) + len(paths) <= k:\n        paths_str = \"\\n\".join([str(path) for path in paths])\n        return paths_str\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path, n):\n        if len(path) != n:\n            return False\n        for i in range(n - 1):\n            if path[i] + 1 != path[i + 1]:\n                return False\n        return True\n\n    def find_path(a, b, n, k):\n        path = [a]\n        while len(path) < n:\n            if path[-1] == b:\n                return path\n            for i in range(1, k + 1):\n                next_city = path[-1] + i\n                if next_city <= n:\n                    path.append(next_city)\n                    break\n            else:\n                return None\n        return None\n\n    def find_solution(a, b, c, d, n, k):\n        path_ab = find_path(a, b, n, k)\n        path_cd = find_path(c, d, n, k)\n        if path_ab is None or path_cd is None:\n            return -1\n        return path_ab, path_cd\n\n    n, k = map(int, stdin.split()[:2])\n    a, b, c, d = map(int, stdin.split()[2:])\n\n    path_ab, path_cd = find_solution(a, b, c, d, n, k)\n    if path_ab is -1:\n        return -1\n\n    return f\"{a} {' '.join(map(str, path_ab[1:-1]))} {d}\", f\"{c} {' '.join(map(str, path_cd[1:-1]))} {b}\"\n"
    },
    {
        "number": 708,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b, c, d = map(int, input().split())\n\n    def is_possible(path):\n        roads = set()\n        for i in range(len(path) - 1):\n            road = (path[i], path[i + 1])\n            if road in roads:\n                return False\n            roads.add(road)\n        return True\n\n    possible_paths_a = [(a, b)]\n    possible_paths_b = [(c, d)]\n\n    if n == 1:\n        if a == b and c == d:\n            return \"2 1 5 4 6 2 3\"\n        else:\n            return -1\n\n    while len(possible_paths_a) < n and len(possible_paths_b) < n:\n        roads_left = k - len(possible_paths_a) - len(possible_paths_b)\n        if roads_left < 0:\n            return -1\n\n        if len(possible_paths_a) < n:\n            for i in range(1, n + 1):\n                if (a, i) not in possible_paths_a and is_possible(possible_paths_a + [(a, i)]):\n                    possible_paths_a.append((a, i))\n                    break\n\n        if len(possible_paths_b) < n:\n            for i in range(1, n + 1):\n                if (c, i) not in possible_paths_b and is_possible(possible_paths_b + [(c, i)]):\n                    possible_paths_b.append((c, i))\n                    break\n\n    if len(possible_paths_a) != n or len(possible_paths_b) != n:\n        return -1\n\n    return \" \".join(map(str, possible_paths_a)) + \"\\n\" + \" \".join(map(str, possible_paths_b))"
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    return (x + 1) // 2\n\ninput_string = \"8\"\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    answer = 0\n    if x == 1:\n        answer = 1\n    else:\n        answer = x - 1\n        while True:\n            new_answer = answer + (answer - 1)\n            if new_answer >= x:\n                answer = new_answer\n                break\n            answer = new_answer\n    return str(answer)\n\n\ninput_stdin = \"5\\n\"\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x == 1:\n        return \"1\"\n    elif x == 2:\n        return \"2\"\n    else:\n        n = (x - 2) // 4\n        return str(n + 2)\n\ninput_stdin = \"5\"\noutput_stdout = solution(input_stdin)\nprint(output_stdout)\n"
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    return 2 if x % 4 == 0 else 1\n\nx = int(input())\nprint(solution(x)) "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return (x // 2) + 1\n\ndef"
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    return (x // 2) + (x % 2)\n\n\ninput_stdin = \"8\"  # Replace with input\noutput_stdout = solution(input_stdin)\nprint(output_stdout) "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    n = 0\n    while x < 2 * (1 << n):\n        n += 1\n    return n\n\n\ninput_str = \"5\"\noutput_str = str(solution(input_str))\nprint(output_str)"
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    \n    # Calculate the minimum number of bacteria needed to reach x\n    # at some point in time using the given rules\n    min_bacteria = 1\n    while (min_bacteria * 2) < x:\n        min_bacteria *= 2\n    \n    return str(min_bacteria) "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    return 2 if x % 4 == 0 else 1 "
    },
    {
        "number": 709,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    return 2 * (x - 1)\n\n\ninput_str = \"5\\n8\\n\"\noutput_str = \"\"\nfor i in range(len(input_str)):\n    if i % 2 == 0:\n        x = int(input_str[i:i+1])\n        output_str += str(solution(stdin=str(x))) + \"\\n\"\n\nprint(output_str) "
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    genome = \"ACTG\"\n    operations = 0\n\n    for i in range(n):\n        for j in range(len(genome)):\n            if s[i] == genome[j]:\n                if i == 0 or j == 0:\n                    operations += i\n                else:\n                    operations += abs(ord(s[i - 1]) - ord(genome[j - 1])) + abs(ord(s[i]) - ord(genome[j]))\n                break\n\n    return operations\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = input(stdin).split()\n    n = int(n)\n    s = list(s)\n    min_ops = float('inf')\n    \n    def get_prev_char(c: str) -> str:\n        if c == 'A':\n            return 'Z'\n        elif c == 'Z':\n            return 'Y'\n        else:\n            return chr(ord(c) - 1)\n    \n    def get_next_char(c: str) -> str:\n        if c == 'Z':\n            return 'A'\n        else:\n            return chr(ord(c) + 1)\n    \n    def is_valid(s: list) -> bool:\n        for c in s:\n            if c == 'A' or c == 'Z':\n                return False\n        return True\n    \n    def check_genome(s: list, genome: str) -> bool:\n        return all(c in s for c in genome)\n    \n    for i in range(n):\n        for j in range(i, n):\n            if check_genome(s[i:j+1], \"ACTG\"):\n                min_ops = min(min_ops, j - i + 1)\n    \n    while not is_valid(s):\n        for i in range(n):\n            if s[i] == 'A' or s[i] == 'Z':\n                s[i] = get_prev_char(s[i])\n                if check_genome(s, \"ACTG\"):\n                    min_ops = min(min_ops, n - i + 1)\n            else:\n                s[i] = get_next_char(s[i])\n                if check_genome(s, \"ACTG\"):\n                    min_ops = min(min_ops, n - i + 1)\n    \n    return min_ops\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    genome = \"ACTG\"\n    genome_len = len(genome)\n    s_len = len(s)\n    \n    if s_len < genome_len:\n        return \"Impossible\"\n    \n    # Initialize the cost matrix\n    cost = [[0 for _ in range(s_len + 1)] for _ in range(genome_len + 1)]\n    \n    # Fill the cost matrix\n    for i in range(1, genome_len + 1):\n        for j in range(1, s_len + 1):\n            if s[j - 1] == genome[i - 1]:\n                cost[i][j] = cost[i - 1][j - 1]\n            else:\n                cost[i][j] = min(cost[i - 1][j - 1], cost[i][j - 1], cost[i - 1][j]) + 1\n    \n    # Calculate the minimum number of operations\n    min_ops = cost[genome_len][s_len]\n    \n    return min_ops"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    operations = 0\n    \n    while len(s) < 4:\n        if s[-1] == \"Z\":\n            s = s[:-1] + \"A\"\n            operations += 1\n        else:\n            s = s[:-1]\n            operations += 1\n    \n    if s[-1] == \"Z\":\n        s = s[:-1] + \"A\"\n        operations += 1\n    \n    for i in range(len(s)-3):\n        if s[i:i+4] == \"ACTG\":\n            return operations\n        \n        if s[i:i+4] == \"ZCTH\":\n            operations += 2\n            return operations\n        \n        if s[i:i+5] == \"ZDATG\":\n            operations += 5\n            return operations\n        \n        if s[i:i+6] == \"AFBAKC\":\n            operations += 16\n            return operations\n        \n    return -1\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def next_letter(letter: str) -> str:\n        if letter == \"Z\":\n            return \"A\"\n        else:\n            return chr(ord(letter) + 1)\n\n    def prev_letter(letter: str) -> str:\n        if letter == \"A\":\n            return \"Z\"\n        else:\n            return chr(ord(letter) - 1)\n\n    def replace_letter(letter: str, prev: bool) -> str:\n        if prev:\n            return prev_letter(letter)\n        else:\n            return next_letter(letter)\n\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    operations = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring == \"ACTG\":\n                operations = 0\n                break\n            else:\n                operations += 1\n                min_operations = float(\"inf\")\n                for k in range(len(substring)):\n                    next_substring = substring[:k] + replace_letter(substring[k], True) + substring[k + 1:]\n                    prev_substring = substring[:k] + replace_letter(substring[k], False) + substring[k + 1:]\n                    operations_next = j - i - k\n                    operations_prev = j - i - k - 1\n                    min_operations = min(min_operations, operations_next + operations + operations_prev)\n                operations += min_operations\n                if operations >= len(substring):\n                    break\n        if operations == 0:\n            break\n\n    return operations\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    operations = 0\n\n    def get_next_letter(letter: str) -> str:\n        if letter == \"Z\":\n            return \"A\"\n        return chr(ord(letter) + 1)\n\n    def get_prev_letter(letter: str) -> str:\n        if letter == \"A\":\n            return \"Z\"\n        return chr(ord(letter) - 1)\n\n    for i in range(n):\n        if s[i] == \"A\" or s[i] == \"Z\":\n            operations += 2\n        else:\n            operations += 1\n\n    for i in range(n - 4):\n        if s[i:i+5] == \"ACTG\":\n            return operations + 5\n\n    return operations"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def next_letter(letter: str) -> str:\n        if letter == \"Z\":\n            return \"A\"\n        else:\n            return chr(ord(letter) + 1)\n\n    def prev_letter(letter: str) -> str:\n        if letter == \"A\":\n            return \"Z\"\n        else:\n            return chr(ord(letter) - 1)\n\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    genome = \"ACTG\"\n    operations = 0\n\n    for i in range(n - len(genome) + 1):\n        is_substring = True\n        for j in range(len(genome)):\n            if s[i + j] not in (genome[j], prev_letter(genome[j]), next_letter(genome[j])):\n                is_substring = False\n                break\n        if is_substring:\n            operations = i\n            break\n\n    return operations\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    genome = \"ACTG\"\n    operations = 0\n    \n    for i in range(n):\n        if s[i] == genome[0]:\n            operations += 1\n            s = s[:i] + genome[1] + s[i+1:]\n            operations += 1\n        elif s[i] == genome[1]:\n            operations += 1\n            s = s[:i] + genome[0] + s[i+1:]\n            operations += 1\n        elif s[i] == genome[2]:\n            operations += 1\n            s = s[:i] + genome[3] + s[i+1:]\n            operations += 1\n        elif s[i] == genome[3]:\n            operations += 1\n            s = s[:i] + genome[2] + s[i+1:]\n            operations += 1\n    \n    return operations\n\ndef"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    s = stdin[1]\n\n    operations = 0\n    genome = \"ACTG\"\n\n    for i in range(len(s)):\n        if s[i] not in genome:\n            operations += 1\n            if s[i] == \"Z\":\n                if s[i - 1] == \"Y\":\n                    s = s[:i - 1] + \"B\" + s[i + 1:]\n                else:\n                    s = s[:i - 1] + \"A\" + s[i + 1:]\n            else:\n                if s[i] == \"A\":\n                    s = s[:i] + \"Z\" + s[i + 1:]\n                else:\n                    s = s[:i] + chr(ord(s[i]) - 1) + s[i + 1:]\n            operations += 1\n\n    return operations\n"
    },
    {
        "number": 710,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    def find_next_letter(letter: str) -> str:\n        if letter == \"Z\":\n            return \"A\"\n        elif ord(letter) == 90:\n            return \"A\"\n        else:\n            return chr(ord(letter) + 1)\n\n    def find_previous_letter(letter: str) -> str:\n        if letter == \"A\":\n            return \"Z\"\n        elif ord(letter) == 65:\n            return \"Z\"\n        else:\n            return chr(ord(letter) - 1)\n\n    operations = 0\n    for letter in s:\n        if letter == \"A\" or letter == \"Z\":\n            operations += 1\n        else:\n            if letter.isupper():\n                operations += 1\n\n    min_operations = operations\n\n    for i in range(n):\n        if s[i] == \"A\" or s[i] == \"Z\":\n            min_operations += 1\n        else:\n            next_letter = find_next_letter(s[i])\n            previous_letter = find_previous_letter(s[i])\n\n            if s.count(next_letter) >= s.count(previous_letter):\n                min_operations += s.count(next_letter)\n            else:\n                min_operations += s.count(previous_letter)\n\n    return min_operations\n\n\ndef"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    \n    for i in range(1, M):\n        if M % i == 0 and (M // i) >= N:\n            count += 1\n    \n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    count = 0\n    for i in range(1, M + 1):\n        if M % i == 0:\n            count += 1\n\n    result = (pow(count, N, MOD) - 1) * (pow(count - 1, N - 1, MOD) + pow(count - 1, N - 2, MOD) * MOD % (10**9 + 7)) % (10**9 + 7)\n    return result\n\ninput_string = \"2 6\"\noutput_string = str(solution(input_string))\nprint(output_string)\n"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    # Initialize a list to store the number of possible sequences\n    count = [1] * (M + 1)\n\n    # Iterate through each number from 1 to M\n    for i in range(1, M + 1):\n        # Calculate the product of all the numbers from 1 to i\n        product = 1\n        for j in range(1, i + 1):\n            product *= j\n        # Add the product to the count list\n        count[i] = count[i - 1] * product % (10**9 + 7)\n\n    # Return the count modulo 10^9 + 7\n    return count[M] % (10**9 + 7)"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    count = 0\n    for a in range(1, N + 1):\n        for b in range(1, N + 1):\n            if a * b == M and a != b:\n                count += 1\n    return count % (10**9 + 7)\n"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    for i in range(1, N+1):\n        if M % i == 0:\n            count += 1\n    return str(count % (10**9+7))\n\n\ndef"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    \n    for i in range(2, int(M**0.5) + 1):\n        if M % i == 0:\n            j = M // i\n            if i <= N and j <= N and i * j == M:\n                count += (N - i + 1) * (N - j + 1)\n    \n    count += 1 if M == 1 else 0\n    \n    return count % (10**9 + 7)\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(1, N+1):\n        for j in range(1, M+1):\n            if i*j == M:\n                count += 1\n\n    return count % MOD"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N = int(input_list[0])\n    M = int(input_list[1])\n\n    def factorize(num: int) -> str:\n        factors = []\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                factors.append(i)\n        if num > 1:\n            factors.append(num)\n        return \" \".join(map(str, factors))\n\n    def count_sequences(N: int, M: int) -> int:\n        def count_product(product: int) -> int:\n            factors = factorize(product).split()\n            count = 1\n            for i in range(len(factors)):\n                for j in range(i + 1, len(factors)):\n                    count *= pow(factors[i] * factors[j], N - i - j, 10**9+7)\n            return count\n\n        count = 0\n        for i in range(1, M + 1):\n            count += count_product(i)\n            if count >= 10**9 + 7:\n                count %= 10**9 + 7\n        return count\n\n    result = count_sequences(N, M)\n    return str(result)"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    mod = 10**9 + 7\n    \n    def count_sequences(N, M):\n        if N == 1:\n            return 1\n        \n        count = 0\n        i = 1\n        while i*i <= M:\n            if M % i == 0:\n                count += count_sequences(N-1, M//i)\n                count %= mod\n            i += 1\n        \n        return count\n    \n    result = count_sequences(N, M)\n    return str(result)\n"
    },
    {
        "number": 711,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [1] * (M + 1)\n    dp[0] = 0\n\n    for i in range(1, M + 1):\n        dp[i] = 1\n        if i % 2 == 0:\n            dp[i] += dp[i // 2]\n        if i % 3 == 0:\n            dp[i] += dp[i // 3]\n\n    result = dp[M]\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n\n    if n == 1:\n        return str(p)\n\n    people_on_escalator = 1\n    time = 1\n    expected_people_on_escalator = p\n\n    while time <= t:\n        if time % 2 == 1:\n            people_on_escalator += expected_people_on_escalator\n        expected_people_on_escalator = (1 - p) * expected_people_on_escalator + p * expected_people_on_escalator / (n - 1)\n        time += 1\n\n    return \"{:.10f}\".format(expected_people_on_escalator)\n"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n, p, t = int(input_values[0]), float(input_values[1]), int(input_values[2])\n    queue = [i for i in range(1, n+1)]\n    probabilities = [1 - p] * n\n    probabilities[0] = p\n    expected_value = 0\n\n    for i in range(t):\n        people_standing = sum(probabilities)\n        expected_value += people_standing\n        if i < t - 1:\n            new_probabilities = [0] * n\n            for j in range(n):\n                if j == 0:\n                    new_probabilities[j] = probabilities[j]\n                else:\n                    new_probabilities[j] = probabilities[j] * p\n                    new_probabilities[j-1] += probabilities[j] * (1 - p)\n            probabilities = new_probabilities\n\n    expected_value += sum(probabilities)\n    return round(expected_value, 6)\n\ninput_string = \"4 0.20 2\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n\n    def expected_num_people(n, p, t):\n        if t == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n > 1:\n            return p * expected_num_people(n - 1, p, t) + (1 - p) * expected_num_people(n - 1, p, t - 1)\n\n    result = expected_num_people(n, p, t)\n    return f\"{result:.6f}\"\n\n\ndef"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    q = 1 - p\n    f = pow(p, n) * pow(q, t)\n    return str(f)"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    x = (1 - p) / p\n    expected_people = (1 - p) * (1 - x ** (t - 1)) / (1 - x)\n\n    return f\"{expected_people:.12f}\"\n\ndef"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    p = round(p, 2)\n    q = 1 - p\n    result = 0\n    for i in range(1, n + 1):\n        result += ((p ** (n - i + 1)) * (q ** i)) * (i / t)\n    return round(result, 6)\n\n\ninput_data = \"1 0.50 1\"\nprint(solution(input_data))  # Output: 0.5\n\ninput_data = \"1 0.50 4\"\nprint(solution(input_data))  # Output: 0.9375\n\ninput_data = \"4 0.20 2\"\nprint(solution(input_data))  # Output: 0.4 "
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    # Initialize variables\n    total_people = n\n    total_standing = n * p\n    total_waiting = n - n * p\n\n    # Calculate the number of people standing on the escalator after t seconds\n    for i in range(1, t):\n        new_standing = total_standing + total_waiting * p\n        total_waiting = total_waiting + total_standing - total_standing * p\n        total_standing = new_standing\n\n    # Calculate the expected number of people standing on the escalator after t seconds\n    expected_standing = total_standing + total_waiting * p\n\n    # Return the expected number as a string with two digits after the decimal point\n    return f\"{expected_standing:.2f}\""
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    if p == 0:\n        return f\"{n * t:.6f}\"\n    if p == 1:\n        return f\"{n:.6f}\"\n    q = 1 - p\n    r = p / q\n    if r <= 1:\n        result = n * r ** (t - 1) * (1 - r) / (1 - r ** n)\n    else:\n        result = n * r ** t\n    return f\"{result:.6f}\"\n"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, stdin.split())\n    if n == 1:\n        return str(p)\n    else:\n        # Calculate the probability of each person entering the escalator\n        prob_enter = (1 - p) / (n - 1)\n        prob_stay = p / (n - 1)\n\n        # Calculate the probability that a person will be standing on the escalator after t seconds\n        prob_standing = prob_enter * (1 - prob_stay) ** (t - 1)\n\n        # Calculate the expected number of people standing on the escalator\n        expected_standing = n * prob_standing\n\n        return str(round(expected_standing, 6))"
    },
    {
        "number": 712,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(float, input().split())\n    x = n * p\n    y = n * (1 - p)\n    res = 0\n    for i in range(1, t+1):\n        res += (x/i) + (y * i)\n    return round(res, 6)\n"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, m = map(int, input_str.split())\n    \n    x_coords = list(range(n+1))\n    y_coords = list(range(m+1))\n    \n    points = [(x, y) for x in x_coords for y in y_coords if x + y > 0]\n    \n    max_size = 0\n    max_set = []\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = (x2-x1)**2 + (y2-y1)**2\n            dist = int(dist**0.5)\n            \n            if dist == 1:\n                for x, y in points:\n                    if (x, y) not in [points[i], points[j]]:\n                        if (x, y) not in max_set:\n                            max_set.append((x, y))\n                            max_size = max(max_size, len(max_set))\n                break\n    \n    return f\"{max_size}\\n\" + \"\\n\".join([f\"{x} {y}\" for x, y in max_set])\n\n\ninput_str = \"2 2\\n4 3\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = [(x, y) for x in range(n + 1) for y in range(m + 1) if x + y > 0]\n    max_size = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            if (x2 - x1)**2 + (y2 - y1)**2 == 0:\n                continue\n            max_size = max(max_size, 2)\n            if max_size == 2:\n                print(max_size)\n                print(0, y1 - 1)\n                print(n, m - y1)\n                break\n            elif max_size == 3:\n                if abs(x2 - x1) + abs(y2 - y1) == 1:\n                    print(max_size)\n                    print(x1, y1)\n                    print(x2, y2)\n                    print(n, m - y1)\n                    break\n    return \"\" "
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = []\n    for y in range(1, m + 1):\n        for x in range(1, n + 1):\n            if x + y > 0:\n                points.append((x, y))\n    points.sort(key=lambda p: p[1])\n    beautiful_set = []\n    for point in points:\n        if not beautiful_set:\n            beautiful_set.append(point)\n        else:\n            for bset_point in beautiful_set:\n                if point[0] + point[1] > bset_point[0] + bset_point[1] and point[0] + point[1] - bset_point[0] - bset_point[1] > 1:\n                    beautiful_set.append(point)\n                    break\n    return str(len(beautiful_set)) + '\\n' + '\\n'.join(map(str, beautiful_set)) "
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m == 0:\n        return str(0)\n\n    max_size = min(n * m, n + m)\n    beautiful_set = []\n    for x in range(max_size):\n        for y in range(max_size - x):\n            if x + y <= max_size:\n                beautiful_set.append((x, y))\n\n    beautiful_set.sort(key=lambda x: (-x[0] - x[1], -x[0], -x[1]))\n\n    return str(len(beautiful_set)) + '\\n' + '\\n'.join(map(lambda x: f\"{x[0]} {x[1]}\", beautiful_set))\n"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    # Calculate the maximum number of points that can be part of a beautiful set\n    max_points = (n + 1) * (m + 1) // 2\n    \n    # Initialize the beautiful set with the point (0, m)\n    beautiful_set = [(0, m)]\n    \n    # Add other points to the set while maintaining the conditions\n    x, y = 0, m\n    while len(beautiful_set) < max_points:\n        x += 1\n        if x <= n:\n            beautiful_set.append((x, y - x))\n        if x + y > 0 and y > 0:\n            beautiful_set.append((x, y - x))\n            beautiful_set.append((x - y, y))\n    \n    # Sort the set by x-coordinate\n    beautiful_set = sorted(beautiful_set)\n    \n    # Print the size of the beautiful set and its points\n    result = str(len(beautiful_set)) + \"\\n\"\n    for point in beautiful_set:\n        result += \" \".join(map(str, point)) + \"\\n\"\n    \n    return result\n"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(points: list) -> bool:\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) == 0:\n                    return False\n        return True\n\n    n, m = map(int, stdin.split())\n    points = [(x, y) for x in range(n + 1) for y in range(m + 1)]\n    points = [p for p in points if p[0] + p[1] > 0]\n\n    max_size = 0\n    max_set = []\n    for i in range(1, len(points)):\n        subset = points[:i]\n        if is_beautiful(subset):\n            if len(subset) > max_size:\n                max_size = len(subset)\n                max_set = subset\n\n    output = str(max_size) + \"\\n\"\n    output += \"\\n\".join([\" \".join(map(str, point)) for point in max_set])\n    return output\n"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    m = input_data[1]\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_beautiful(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if distance(points[i][0], points[i][1], points[j][0], points[j][1]) % 1 == 0:\n                    return False\n        return True\n\n    points = [(x, y) for x in range(n + 1) for y in range(m + 1)]\n    points = [p for p in points if p[0] + p[1] > 0]\n\n    beautiful_set = []\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if (x, y) not in beautiful_set and (x, y) not in beautiful_set:\n                if is_beautiful([(x, y)]) and (x, y) in points:\n                    beautiful_set.append((x, y))\n\n    output = len(beautiful_set)\n    output_str = str(output) + '\\n'\n    for point in beautiful_set:\n        output_str += str(point[0]) + ' ' + str(point[1]) + '\\n'\n    return output_str\n\n\ninput_data = \"4 3\"\nprint(solution(input_data)) "
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    \n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n    \n    def is_beautiful(points):\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                if distance(points[i][0], points[i][1], points[j][0], points[j][1]) == 0:\n                    return False\n                if distance(points[i][0], points[i][1], points[j][0], points[j][1]) % 1 == 0:\n                    return False\n        return True\n    \n    points = [(x, y) for x in range(n+1) for y in range(m+1) if x + y > 0]\n    beautiful_points = [p for p in points if is_beautiful([p])]\n    max_size = len(beautiful_points)\n    print(max_size)\n    for point in beautiful_points:\n        print(point[0], point[1])\n    \n"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    def is_beautiful(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if (x1 - x2) ** 2 + (y1 - y2) ** 2 == 0:\n                    return False\n        return True\n    \n    def generate_points():\n        for x in range(n + 1):\n            for y in range(m + 1):\n                if x + y > 0:\n                    yield (x, y)\n                    \n    points = list(generate_points())\n    beautiful_points = [p for p in points if is_beautiful([p])]\n    max_size = min(n * m, len(beautiful_points))\n    return str(max_size) + \"\\n\" + \"\\n\".join(map(str, beautiful_points[:max_size]))\n\n\ndef"
    },
    {
        "number": 713,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = set()\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if x + y > 0:\n                points.add((x, y))\n\n    max_size = 0\n    max_set = set()\n    for point in points:\n        rest_points = points - {point}\n        non_integer_distances = [round(sqrt(sum((point[0] - x) ** 2 + (point[1] - y) ** 2)) - point[0] - point[1]) for x, y in rest_points]\n        if all(distance != int(distance) for distance in non_integer_distances):\n            if len(rest_points) > max_size:\n                max_size = len(rest_points)\n                max_set = rest_points\n\n    return f\"{max_size}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in max_set)"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n    \n    target_sum = n // 2\n    card_sum = sum(cards)\n    cards.sort()\n    \n    if card_sum % target_sum != 0:\n        return \"Impossible\"\n    \n    cards_per_player = card_sum // target_sum\n    players_cards = [[] for _ in range(n // 2)]\n    \n    for i, card in enumerate(cards):\n        players_cards[i % (n // 2)].append(card)\n    \n    for player_cards in players_cards:\n        for i in range(cards_per_player):\n            print(player_cards.pop(0), player_cards.pop())"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def helper(cards, result, current_sum, target_sum):\n        if not cards:\n            return result\n\n        if current_sum + cards[0] <= target_sum:\n            result.append(cards[0])\n            current_sum += cards[0]\n\n        return helper(cards[1:], result, current_sum, target_sum)\n\n    target_sum = sum(cards) // 2\n    player1_cards = helper(cards, [], 0, target_sum)\n    player2_cards = [card for card in cards if card not in player1_cards]\n\n    return \"\\n\".join(f\"{card1} {card2}\" for card1, card2 in zip(player1_cards, player2_cards))\n\n\ninput_string = \"\"\"6\n1 5 7 4 4 3\n\"\"\"\n\noutput_string = solution(input_string)\nprint(output_string)"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n    half_n = n // 2\n    target_sum = sum(cards) // half_n\n\n    card_indices = [[] for _ in range(half_n)]\n\n    def distribute_cards(cards: list, target_sum: int, target_count: int, current_sum: int, current_count: int, current_index: int, card_indices: list) -> None:\n        if current_count == target_count:\n            for i in range(half_n):\n                card_indices[i].append(current_index)\n                current_index += 1\n        else:\n            for i in range(current_index, len(cards)):\n                distribute_cards(cards, target_sum, target_count, current_sum + cards[i], current_count + 1, i + 1, card_indices)\n\n    distribute_cards(cards, target_sum, half_n, 0, 0, 0, card_indices)\n\n    for i in range(half_n):\n        print(card_indices[i][0], card_indices[i][1])\n"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Find the median of the numbers\n    numbers.sort()\n    median = numbers[n // 2]\n\n    # Divide the cards into two equal parts\n    left_cards = numbers[:n//2]\n    right_cards = numbers[n//2:]\n\n    # Find the indices of the median in each part\n    left_indices = [i for i, num in enumerate(left_cards) if num >= median]\n    right_indices = [i for i, num in enumerate(right_cards) if num >= median]\n\n    # Swap the cards at the indices to make the median equal for each part\n    for i in range(len(left_indices)):\n        left_cards[left_indices[i]], right_cards[right_indices[i]] = right_cards[right_indices[i]], left_cards[left_indices[i]]\n\n    # Print the cards to be given to each player\n    result = []\n    for i in range(n // 2):\n        result.append(f\"{left_cards[i]} {right_cards[i]}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = map(int, input().split())\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in ascending order\n    cards.sort()\n\n    # Initialize the player cards with the first two cards\n    player_cards = [cards[:2], cards[2:]]\n\n    # Distribute the rest of the cards to the players\n    for i in range(2, n // 2):\n        # Find the player with the smallest sum of cards\n        min_sum = min(sum(player_cards[0]), sum(player_cards[1]))\n        min_index = 0 if sum(player_cards[0]) == min_sum else 1\n\n        # Add the next card to the player with the smallest sum\n        player_cards[min_index].append(cards[i])\n\n    # Print the result\n    for i in range(n // 2):\n        print(\" \".join(map(str, player_cards[i])))\n"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    avg = sum(a) // 2\n    \n    cards_per_player = []\n    for i in range(n//2):\n        cards_per_player.append((i+1, avg+1+i))\n    \n    return \"\\n\".join(f\"{i[0]} {i[1]}\" for i in cards_per_player)\n\ndef"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n    assert n % 2 == 0\n    assert len(cards) == n\n\n    # Distribute the cards in a way that the sum of values on each player's cards is equal\n    players = [set() for _ in range(n // 2)]\n    for i in range(n // 2):\n        players[i].add(cards[i * 2])\n        players[i].add(cards[i * 2 + 1])\n\n    # Find the number of cards that each player should get\n    num_cards_per_player = n // (n // 2)\n\n    # Find the cards that each player should get\n    result = []\n    for i in range(n // 2):\n        for card in players[i]:\n            if len(players[i]) < num_cards_per_player:\n                players[i].add(card)\n                result.append((card, i * 2 + 1))\n            else:\n                break\n\n    # Output the result\n    output = '\\n'.join([str(card) for card in result])\n    return output"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i] + b[i-1] if i > 0 else a[i]\n    \n    c = [0] * (n // 2)\n    for i in range(n // 2):\n        c[i] = (b[n - 1] - b[n // 2 - i - 1]) // 2\n    \n    d = [0] * (n // 2)\n    for i in range(n // 2):\n        d[i] = b[n // 2 - i - 1] + d[i-1] if i > 0 else b[n // 2 - i - 1]\n    \n    e = [0] * (n // 2)\n    for i in range(n // 2):\n        e[i] = d[i] - c[i]\n    \n    f = [0] * (n // 2)\n    for i in range(n // 2):\n        f[i] = b[n // 2 - i - 1] - e[i]\n    \n    g = [0] * (n // 2)\n    for i in range(n // 2):\n        g[i] = b[n - i - 1] - e[i]\n    \n    res = []\n    for i in range(n // 2):\n        res.append((f[i], g[i]))\n    \n    return \"\\n\".join([f\"{i[0]} {i[1]}\" for i in res])"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_partition(cards, target_sum):\n        n = len(cards)\n        dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= cards[i - 1]:\n                    dp[i][j] |= dp[i - 1][j - cards[i - 1]]\n        for i in range(n, -1, -1):\n            for j in range(target_sum, -1, -1):\n                if dp[i][j]:\n                    if target_sum == cards[i - 1]:\n                        return [i]\n                    else:\n                        return [i] + find_partition(cards[:i - 1], target_sum - cards[i - 1])\n        return []\n\n    n, *cards = stdin.split()\n    n = int(n)\n    target_sum = n // 2\n    result = []\n    for i in range(target_sum):\n        partition = find_partition(cards, target_sum - i)\n        result.append(partition)\n    return '\\n'.join(f\"{i + 1} {' '.join(map(str, card_list))}\" for i, card_list in enumerate(result))\n\n\ndef"
    },
    {
        "number": 714,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1:]))\n    if n % 2 != 0:\n        return \"Error: n must be even\"\n    n_half = n // 2\n    if len(a) != n:\n        return \"Error: length of a must be n\"\n    if len(set(a)) != n:\n        return \"Error: a must be a unique sequence\"\n\n    total_sum = sum(a)\n    if total_sum % n_half != 0:\n        return \"Error: sum of a must be divisible by n/2\"\n\n    cards_per_player = total_sum // n_half\n    cards_per_player_half = cards_per_player // 2\n\n    result = []\n    for i in range(n_half):\n        result.append(i + 1)\n        result.append(i + n_half + 1)\n        a.remove(cards_per_player_half)\n        a.remove(cards_per_player_half)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n\n    # Convert descriptions to lists of characters\n    choices = [list(input_list[i][2:]) for i in range(1, 5)]\n\n    # Find length of each choice\n    lengths = [len(choice) for choice in choices]\n\n    # Find minimum and maximum lengths\n    min_length = min(lengths)\n    max_length = max(lengths)\n\n    # Find greatest and least length choices\n    greatest_length_choice = None\n    least_length_choice = None\n    for i in range(4):\n        if lengths[i] == min_length:\n            least_length_choice = choices[i]\n        elif lengths[i] == max_length:\n            greatest_length_choice = choices[i]\n\n    # Find great choices\n    great_choices = []\n    for choice in choices:\n        if (len(choice) < min_length or len(choice) > max_length) and choice not in [greatest_length_choice, least_length_choice]:\n            great_choices.append(choice)\n\n    # Choose child's choice\n    if great_choices:\n        # If there is exactly one great choice, choose it\n        if len(great_choices) == 1:\n            child_choice = great_choices[0]\n        else:\n            # Otherwise, choose C (the child think it is the luckiest choice)\n            child_choice = choices[2]\n    else:\n        # If there is no great choice, choose the luckiest choice\n        child_choice = choices[greatest_length_choice == min_length]\n\n    # Convert child's choice back to string\n    return \"\".join(child_choice)\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into lines\n    lines = stdin.split('\\n')\n\n    # Get the description of choice A\n    desc_A = lines[0][2:]\n\n    # Get the descriptions of choices B, C, and D\n    descs = [lines[i][2:] for i in range(1, 4)]\n\n    # Find the length of the longest and shortest descriptions\n    max_len = max(len(desc_A], max(map(len, descs)))\n    min_len = min(len(desc_A], min(map(len, descs)))\n\n    # Check if there is a choice whose description is at least twice shorter or twice longer than all other descriptions\n    great_choice = None\n    for desc in descs:\n        if len(desc) >= 2 * max_len or len(desc) >= 2 * min_len:\n            great_choice = desc\n            break\n\n    # If there is a great choice, the child chooses it\n    if great_choice is not None:\n        return descs.index(great_choice) + 67  # The child thinks the choice is great.\n\n    # Otherwise, the child chooses C (the child think it is the luckiest choice)\n    return 67  # The child chooses C\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def length_of_description(description: str) -> int:\n        return len(description) - len(description.replace('_', ''))\n\n    def count_great_choices(choices: list) -> int:\n        return sum(1 for choice in choices if length_of_description(choice) > 2 * max(length_of_description(choice) for choice in choices))\n\n    def count_less_great_choices(choices: list) -> int:\n        return sum(1 for choice in choices if length_of_description(choice) < 2 * min(length_of_description(choice) for choice in choices))\n\n    def find_great_choice(choices: list) -> str:\n        great_choices = [choice for choice in choices if length_of_description(choice) > 2 * max(length_of_description(choice) for choice in choices)]\n        if len(great_choices) == 1:\n            return great_choices[0]\n        return choices[0]\n\n    def find_less_great_choice(choices: list) -> str:\n        less_great_choices = [choice for choice in choices if length_of_description(choice) < 2 * min(length_of_description(choice) for choice in choices)]\n        if len(less_great_choices) == 1:\n            return less_great_choices[0]\n        return choices[0]\n\n    stdin = stdin.strip().split('\\n')\n    choices = stdin[1:]\n    great_choices_count = count_great_choices(choices)\n    less_great_choices_count = count_less_great_choices(choices)\n\n    if great_choices_count == 1:\n        return find_great_choice(choices)\n    elif less_great_choices_count == 1:\n        return find_less_great_choice(choices)\n    else:\n        return 'C'\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.strip().split('\\n')\n    choices = {}\n    for choice_str in stdin_list:\n        choice, desc = choice_str.split('.')\n        choices[choice] = desc[2:]\n\n    desc_len = [len(desc) for desc in choices.values()]\n    min_desc_len = min(desc_len)\n    max_desc_len = max(desc_len)\n\n    great_choices = []\n    for choice, desc in choices.items():\n        if min_desc_len * 2 > len(desc) > max_desc_len * 2:\n            great_choices.append(choice)\n\n    if len(great_choices) == 1:\n        return great_choices[0]\n    else:\n        return 'C'\n\n\ndef"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    stdin = [line.strip()[2:] for line in stdin]\n\n    def length(choice: str) -> int:\n        return len(choice)\n\n    def is_great(choices: list[str]) -> str:\n        longest_length = max(length(choice) for choice in choices)\n        return next((choice for choice in choices if length(choice) < longest_length * 2), None)\n\n    def luckiest_choice(choices: list[str]) -> str:\n        shortest_length = min(length(choice) for choice in choices)\n        return next((choice for choice in choices if length(choice) > shortest_length * 2), None)\n\n    choices = {letter: choice for letter, choice in zip(\"ABCD\", stdin)}\n\n    great_choice = is_great(list(choices.values()))\n    lucky_choice = luckiest_choice(list(choices.values()))\n\n    if great_choice is not None:\n        return great_choice\n    elif lucky_choice is not None:\n        return lucky_choice\n    else:\n        return \"C\"\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    choices = {}\n    for i, choice in enumerate(inputs[1:], 1):\n        choices[chr(ord('A') + i - 1)] = choice[2:]\n\n    shortest_len = min(len(choices[choice]) for choice in choices)\n    longest_len = max(len(choices[choice]) for choice in choices)\n\n    great_choices = []\n    for choice in choices:\n        if len(choices[choice]) < shortest_len * 2 and len(choices[choice]) > longest_len * 2:\n            great_choices.append(choice)\n\n    if len(great_choices) == 1:\n        return great_choices[0]\n    elif len(great_choices) > 1:\n        return 'C'\n    else:\n        return 'C'\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into lines\n    lines = stdin.split('\\n')\n\n    # Extract the choices\n    choices = []\n    for i, line in enumerate(lines):\n        if i == 0:\n            # Choice A\n            choice = line[2:]\n        else:\n            # Choices B, C, D\n            choice = line[3:]\n        choices.append(choice)\n\n    # Find the greatest length and the least length\n    greatest_length = 0\n    least_length = 100\n    for choice in choices:\n        if len(choice) > greatest_length:\n            greatest_length = len(choice)\n        if len(choice) < least_length:\n            least_length = len(choice)\n\n    # Check if there is a great choice\n    great_choices = []\n    for choice in choices:\n        if (len(choice) == greatest_length or len(choice) == least_length) and (choice not in great_choices):\n            great_choices.append(choice)\n\n    # Choose the great choice, or the luckiest choice, or C\n    if great_choices:\n        return great_choices[0]\n    elif len(choices) == 4:\n        return 'C'\n    else:\n        return 'B'\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    choices = {line.split('.')[0]: line.split('.')[1] for line in lines}\n    lengths = [len(choices[key]) for key in choices]\n\n    shortest_length = min(lengths)\n    longest_length = max(lengths)\n    shortest_choices = [key for key, length in choices.items() if length == shortest_length]\n    longest_choices = [key for key, length in choices.items() if length == longest_length]\n\n    if len(shortest_choices) == 1:\n        if len(longest_choices) == 1:\n            return shortest_choices[0] if shortest_length > longest_length else longest_choices[0]\n        else:\n            return shortest_choices[0]\n    else:\n        if len(longest_choices) == 1:\n            return longest_choices[0]\n        else:\n            return 'C'\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def great_choice(choices: list) -> str:\n        best_choice = None\n        for choice in choices:\n            if best_choice is None:\n                best_choice = choice\n            else:\n                if len(choice) < 2 * len(best_choice):\n                    best_choice = choice\n        return best_choice\n\n    def lucky_choice(choices: list) -> str:\n        min_length = min(len(choice) for choice in choices)\n        lucky_choices = [choice for choice in choices if len(choice) == min_length]\n        return great_choice(lucky_choices)\n\n    stdin = stdin.strip().split(\"\\n\")\n    choices = [line.split(\".\")[1] for line in stdin]\n\n    great_choice_ = great_choice(choices)\n    lucky_choice_ = lucky_choice(choices)\n\n    if great_choice_ is not None:\n        return great_choice_\n    else:\n        return lucky_choice_ if lucky_choice_ is not None else \"C\"\n"
    },
    {
        "number": 715,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.strip().split('\\n')\n    choices = {}\n    for line in input_lines:\n        choice, description = line.split('.')\n        choices[choice] = description.strip()\n\n    def get_description_length(desc: str) -> int:\n        return len(desc.replace('_', ''))\n\n    max_length = max(get_description_length(choice) for choice in choices.values())\n    min_length = min(get_description_length(choice) for choice in choices.values())\n\n    great_choices = []\n    for choice, description in choices.items():\n        length = get_description_length(description)\n        if (max_length / length >= 2) or (min_length / length >= 2):\n            great_choices.append(choice)\n\n    if len(great_choices) == 1:\n        return great_choices[0]\n    else:\n        return 'C'\n\n\nstdin = '''A.VFleaKing_is_the_author_of_this_problem\nB.Picks_is_the_author_of_this_problem\nC.Picking_is_the_author_of_this_problem\nD.Ftiasch_is_cute'''\n\nprint(solution(stdin))\n\n\nstdin = '''A.ab\nB.abcde\nC.ab\nD.abc'''\n\nprint(solution(stdin))\n\n\nstdin = '''A.c\nB.cc\nC.c\nD.c'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    companies = list(map(int, input().strip()))\n\n    min_cost = float('inf')\n    for i in range(1, n + 1):\n        cost = abs(a - i) + abs(b - i)\n        if companies[i - 1] == companies[a - 1]:\n            cost -= 1\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n\n\ninput_stdin = \"\"\"4 1 4\n1010\"\"\"\n\nprint(solution(input_stdin))\n\ninput_stdin = \"\"\"5 5 2\n10110\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    companies = list(map(int, stdin.split()))\n    graph = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if companies[i - 1] == companies[j - 1]:\n                graph[i][j] = abs(i - j)\n            else:\n                graph[i][j] = float('inf')\n                \n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n                \n    return graph[a][b]\n\n\nn, a, b = map(int, input().split())\ncompanies = list(map(int, input().split()))\n\nprint(solution(f\"{n} {a} {b}\\n{companies}\")) "
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    companies = list(input())\n\n    min_cost = float('inf')\n\n    for i in range(n):\n        if i == a:\n            continue\n        cost = abs(i - a) + abs(i - b)\n        if companies[i] == companies[a]:\n            cost -= 1\n        min_cost = min(min_cost, cost)\n\n    return min_cost"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    companies = input()\n    \n    # Initialize the cost matrix\n    cost = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                cost[i][j] = 0\n            elif companies[i] == companies[j]:\n                cost[i][j] = 0\n            else:\n                cost[i][j] = abs(i - j)\n    \n    # Fill the cost matrix\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                cost[i][k] = min(cost[i][k], cost[i][j] + cost[j][k])\n    \n    return cost[a - 1][b - 1]\n\n\ndef"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    companies = input()\n\n    min_cost = float('inf')\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if companies[i-1] == companies[j-1]:\n                cost = 0\n            else:\n                cost = abs(i - j)\n            min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    companies = list(map(int, stdin.split()[-1]))\n\n    if a == b:\n        return 0\n\n    airports = [i for i in range(1, n + 1)]\n    cost = 0\n\n    for i in range(n):\n        if companies[i] != companies[b - 1]:\n            cost += abs(a - (i + 1))\n\n    if cost == 0:\n        return 0\n\n    for i in range(n):\n        if companies[i] != companies[b - 1]:\n            airports.pop(i)\n            break\n\n    for i in range(len(airports)):\n        if airports[i] == a:\n            for j in range(i + 1, len(airports)):\n                if airports[j] == b:\n                    if companies[a - 1] == companies[b - 1]:\n                        return cost - (len(airports) - i - 1)\n                    else:\n                        return cost\n\n    return -1\n\n\ndef"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    companies = list(stdin.split()[3])\n    \n    # Calculate the distance between the airports\n    distances = [abs(i - j) for i in range(1, n + 1) for j in range(i + 1, n + 1)]\n    \n    # Calculate the cost of flight for each airport pair\n    costs = [[0 if companies[i] == companies[j] else distances[i - 1] for j in range(n)] for i in range(n)]\n    \n    # Initialize a table to store the minimum cost to reach each airport\n    dp = [float('inf')] * n\n    dp[a - 1] = 0\n    \n    # Fill the table with the minimum cost to reach each airport\n    for i in range(n - 1):\n        for j in range(n):\n            if dp[j] > dp[i] + costs[i][j]:\n                dp[j] = dp[i] + costs[i][j]\n                \n    # The minimum cost to reach the olympiad is the cost of flying from the starting airport to the last airport\n    return dp[b - 1]\n\n\ninput_data = '''\n4 1 4\n1010\n'''\n\nprint(solution(input_data))"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    companies = input()\n\n    cost = 0\n    last_company = companies[a - 1]\n    for i in range(a, b):\n        current_company = companies[i]\n        if current_company != last_company:\n            cost += abs(a - i)\n        last_company = current_company\n\n    return cost\n"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    companies = list(map(int, input().strip()))\n    if a == b:\n        return \"0\"\n\n    costs = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if companies[i] == companies[j]:\n                if i != j:\n                    costs[i][j] = abs(i - j)\n            else:\n                costs[i][j] = 0\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    for length in range(1, n):\n        for i in range(n - length):\n            j = i + length\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + costs[i][k] + costs[k + 1][j])\n\n    return str(dp[a - 1][b - 1])\n\n\ndef"
    },
    {
        "number": 716,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    companies = list(map(int, input()))\n\n    min_cost = float('inf')\n    for i in range(a-1, b):\n        if companies[i] == companies[b-1]:\n            min_cost = min(min_cost, abs(i-a) + abs(b-i))\n\n    return str(min_cost)\n\n\nstdin = '''4 1 4\n1010'''\nprint(solution(stdin)) "
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s, d = [], []\n    for i in range(1, n+1):\n        si, di = map(int, stdin.splitlines()[i].split())\n        s.append(si)\n        d.append(di)\n\n    last_doctor_day = s[-1] + (n-1)*d[-1]\n    min_time = float('inf')\n\n    for i in range(n-1):\n        doctor_day = s[i] + sum(d[:i+1])\n        min_time = min(min_time, doctor_day)\n\n    return str(max(last_doctor_day, min_time))\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    doctors = []\n    \n    for _ in range(n):\n        s, d = map(int, input().split())\n        doctors.append((s, d))\n    \n    last_doctor = doctors[-1]\n    last_doctor_visit_day = last_doctor[0]\n    max_visit_day = 0\n    \n    for i in range(n - 1, -1, -1):\n        doctor = doctors[i]\n        doctor_visit_day = last_doctor_visit_day + doctor[1] * i\n        max_visit_day = max(max_visit_day, doctor_visit_day)\n    \n    return str(max_visit_day)\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = [int(x) for x in stdin.split()[1:n+1]]\n    d = [int(x) for x in stdin.split()[n+1:]]\n    \n    day = max(s)\n    for i in range(n-1, -1, -1):\n        s_i = s[i]\n        d_i = d[i]\n        while day - s_i > d_i:\n            day -= d_i\n        day -= 1\n        \n    return day + 1"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_working_day(day: int, s: int, d: int) -> bool:\n        return (day - s) % d == 0\n\n    n = int(stdin)\n    doctors = [list(map(int, input().split())) for _ in range(n)]\n    min_days = float('inf')\n\n    for i in range(n):\n        s, d = doctors[i]\n        day = s\n        while is_working_day(day, s, d):\n            day += d\n        min_days = min(min_days, day)\n\n    return str(min_days)\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_visit_day(s, d):\n        day = s\n        while True:\n            yield day\n            day += d\n\n    n = int(stdin[0].split()[0])\n    doctors = []\n    for i in range(1, n + 1):\n        s, d = map(int, stdin[i].split())\n        doctors.append((s, d))\n\n    last_doctor = doctors[-1]\n    visit_days = [find_visit_day(s, d) for s, d in doctors]\n\n    visit_day = 1\n    while True:\n        is_visit_possible = True\n        for i in range(n):\n            if next(visit_days[i]) != visit_day:\n                is_visit_possible = False\n                break\n        if is_visit_possible:\n            if last_doctor[0] == visit_day:\n                return visit_day\n            visit_day += 1\n        else:\n            visit_day += 1\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_work_days(s, d):\n        work_days = [s]\n        day = s + d\n        while day <= 1000:\n            work_days.append(day)\n            day += d\n        return work_days\n\n    n = int(stdin)\n    s = []\n    d = []\n\n    for _ in range(n):\n        line = list(map(int, input().split()))\n        s.append(line[0])\n        d.append(line[1])\n\n    work_days = [get_work_days(s[i], d[i]) for i in range(n)]\n    last_day = work_days[-1]\n    next_day = max(last_day) + 1\n    for days in work_days[-2::-1]:\n        next_day = max(next_day, max(days) + 1)\n\n    return str(next_day)\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    doctors = []\n    for i in range(1, n + 1):\n        s, d = map(int, stdin.splitlines()[i].split())\n        doctors.append((s, d))\n\n    last_doctor = doctors[-1]\n    min_time = float('inf')\n    for i in range(n - 1):\n        s, d = doctors[i]\n        if s + d > last_doctor[0]:\n            min_time = max(min_time, s + d)\n        else:\n            min_time = float('inf')\n            break\n\n    return min_time if min_time != float('inf') else -1\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s, d = [], []\n    \n    for i in range(1, n+1):\n        s_i, d_i = map(int, stdin.split('\\n')[i].split())\n        s.append(s_i)\n        d.append(d_i)\n        \n    last_day = s[-1] + d[-1] * (n-1)\n    return last_day\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    doctors = []\n    for _ in range(n):\n        s, d = map(int, input().split())\n        doctors.append((s, d))\n\n    last_doctor_day = 1\n    for s, d in doctors:\n        last_doctor_day += d - 1\n\n    return str(last_doctor_day)\n"
    },
    {
        "number": 717,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = [int(x) for x in stdin.split()[1:]]\n    d = [int(x) for x in stdin.split()[n+1:]]\n\n    min_time = 0\n    last_doctor = n\n    for i in range(last_doctor):\n        if i == 0:\n            min_time = s[i] + d[i] - 1\n        else:\n            min_time = max(min_time, s[i] + d[i] * i - 1)\n\n    return str(min_time)"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = int(stdin.strip())\n    \n    # Convert input_data to decimal notation\n    decimal_notation = list(str(input_data))\n    \n    # Check if input_data has at least one digit \"8\"\n    if \"8\" in decimal_notation:\n        return \"0\"\n    \n    # Find the floor with a lucky number\n    lucky_floor = input_data - 1\n    while not str(lucky_floor).__contains__(\"8\"):\n        lucky_floor -= 1\n    \n    # Calculate the difference between the current floor and the lucky floor\n    floor_difference = abs(input_data - lucky_floor)\n    \n    return str(floor_difference)"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_value = int(stdin)\n\n    if input_value == -1:\n        return \"9\"\n\n    number_of_floors = 1777777777\n    lucky_floors = [8, -180, 808]\n\n    min_b = number_of_floors\n\n    for lucky_floor in lucky_floors:\n        b = abs(lucky_floor - input_value)\n        min_b = min(min_b, b)\n\n    return str(min_b)"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    \n    # calculate the number of floors required to reach a floor with a lucky number\n    if a >= 0:\n        b = a // 8 + 1\n    else:\n        b = abs(a) // 7 + 1\n    \n    return str(b)\n"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"1\"\n    b = 0\n    while a % 10 != 8:\n        a -= 1\n        b += 1\n    return str(b)\n\ndef"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = 0\n    lucky = False\n\n    if a < 0:\n        a = -a\n        b = a // 10\n        a = a % 10\n    else:\n        while not lucky:\n            b += 1\n            lucky = '8' in str(a + b)\n\n    return str(b)\n\n\ninput_stdin = \"179\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    b = 0\n    if a >= 0:\n        b = a // 1000000000 + 1\n    else:\n        b = abs(a) // 1000000000 + 9\n    return str(b)\n\ninput_stdin = \"179\"  # change this input to test different cases\nprint(solution(input_stdin)) "
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n\n    # determine the floor number that is a multiple of 8\n    lucky_floor = 8 * ((a // 8) + 1)\n\n    # calculate the number of floors between the current floor and the lucky floor\n    b = lucky_floor - a\n\n    return str(b)\n\ninput_data = \"18\"\nprint(solution(input_data)) "
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a < 0:\n        a = abs(a)\n        b = 1\n        while a % 10 != 8:\n            a //= 10\n            b += 1\n        return b\n    else:\n        b = 1\n        while a % 10 != 8:\n            a += 1\n            b += 1\n        return b\n"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    \n    # 17 777 777 7 floors above floor 0\n    lucky_floor = abs(a) // 8 * 8\n    \n    # Calculate the floor above the lucky floor\n    b = abs(a) - lucky_floor + 1\n    \n    # Ensure the result is positive\n    b = max(b, 1)\n    \n    return str(b)\n"
    },
    {
        "number": 718,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n\n    if a < 0:\n        return str(abs(a) % 10)\n    else:\n        floor_diff = 888888888 - a\n        lucky_floor = floor_diff % 10 == 8\n        b = floor_diff // 10 + 1\n\n        return str(b)\n"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    \n    perfect_integers = []\n    \n    for i in range(1, 1000000):\n        if sum(int(digit) for digit in str(i)) == 10:\n            perfect_integers.append(i)\n        \n        if len(perfect_integers) == k:\n            return str(perfect_integers[k-1])\n        \n"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    \n    def is_perfect(n: int) -> bool:\n        return sum(int(d) for d in str(n)) == 10\n    \n    def count_perfects(n: int) -> int:\n        count = 0\n        for i in range(1, n):\n            if is_perfect(i):\n                count += 1\n            if count == k:\n                return i\n        return -1\n    \n    result = count_perfects(10000)\n    if result == -1:\n        return \"Too few perfect integers to find the k-th one.\"\n    else:\n        return str(result)\n"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    perfect_integers = [i for i in range(1, 100000) if sum(int(d) for d in str(i)) == 10 and i % 100 == 0]\n    result = perfect_integers[k - 1]\n    return str(result) "
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    perfects = []\n    for num in range(10000):\n        if sum(int(digit) for digit in str(num)) == 10:\n            perfects.append(num)\n    return str(perfects[k-1])\n"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    perfect_integers = [str(i) for i in range(1, 10000) if sum(int(d) for d in str(i)) == 10]\n    perfect_integers.sort()\n    return str(int(perfect_integers[k - 1]))\n\n\ninput_str = \"1\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    perfect_numbers = [19, 28, 37, 46, 55, 64, 73, 82, 91, 100, 109, 120, 131, 141, 151, 161, 171, 181, 191, 201, 212, 223, 234, 245, 256, 267, 278, 289, 300, 311, 322, 333, 344, 355, 366, 377, 388, 399, 410, 421, 432, 443, 454, 465, 476, 487, 498, 509, 520, 531, 542, 553, 564, 575, 586, 597, 608, 619, 630, 641, 652, 663, 674, 685, 696, 707, 718, 729, 740, 751, 762, 773, 784, 795, 806, 817, 828, 839, 850, 861, 872, 883, 894, 905, 916, 927, 938, 949, 960, 971, 982, 993, 1000]\n    return str(perfect_numbers[k-1])\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k = int(input())\n\n    def perfect_number(num: int) -> bool:\n        return sum(int(digit) for digit in str(num)) == 10\n\n    count = 1\n    result = 0\n    for num in range(10, 1000000):\n        if perfect_number(num):\n            count += 1\n            if count == k:\n                result = num\n                break\n\n    return str(result)\n"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n\n    def is_perfect(n: int) -> bool:\n        return sum(int(digit) for digit in str(n)) == 10\n\n    count = 0\n    i = 19  # The first perfect integer\n    while count < k:\n        if is_perfect(i):\n            count += 1\n        i += 1\n\n    return str(i - 1)\n\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    k -= 1 # We want to find the (k-1)-th smallest perfect number\n    \n    i = 19 # We start with the first perfect number\n    count = 0 # We count the number of perfect numbers we found\n    \n    while count < k:\n        # We check if the next number is perfect\n        perfect = True\n        for digit in str(i):\n            if int(digit) != 1:\n                perfect = False\n                break\n        if perfect:\n            count += 1\n        i += 1\n    \n    return str(i - 1) # We return the (k-1)-th perfect number"
    },
    {
        "number": 719,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    perfect_integers = []\n    \n    for num in range(1, 10000):\n        if sum(int(digit) for digit in str(num)) == 10:\n            perfect_integers.append(num)\n            \n    return str(perfect_integers[k - 1])\n\n\ninput_string = input(\"Enter a positive integer k: \")\nresult = solution(input_string)\nprint(\"The k-th smallest perfect integer is:\", result) "
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    scores = []\n    for i in range(1, n + 1):\n        a, b = map(int, input_data[i].split())\n        scores.append((a, b))\n    max_draws = 1\n    current_draws = 1\n    for i in range(1, n):\n        last_score = scores[i - 1]\n        current_score = scores[i]\n        if current_score[0] == last_score[0] + 1 and current_score[1] == last_score[1]:\n            current_draws += 1\n            if current_draws > max_draws:\n                max_draws = current_draws\n        else:\n            current_draws = 1\n    return str(max_draws)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    max_draws = 1\n    current_draws = 0\n    \n    for i in range(n):\n        a, b = map(int, input_list[i].split())\n        if a == b:\n            current_draws += 1\n            max_draws = max(max_draws, current_draws)\n        else:\n            current_draws = 1\n    \n    return str(max_draws)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    score_changes = []\n    current_score = (0, 0)\n    for i in range(1, n + 1):\n        a, b = map(int, stdin.splitlines()[i].split())\n        if a == current_score[0] and b == current_score[1]:\n            score_changes.append(current_score)\n        elif a == current_score[0] + 1 and b == current_score[1]:\n            score_changes.append((current_score[0] + 1, current_score[1]))\n        elif a == current_score[0] and b == current_score[1] + 1:\n            score_changes.append((current_score[0], current_score[1] + 1))\n        current_score = (a, b)\n    score_changes.append(current_score)\n    max_draws = 0\n    for i in range(len(score_changes) - 1):\n        if score_changes[i][0] == score_changes[i + 1][0] and score_changes[i][1] == score_changes[i + 1][1]:\n            max_draws += 1\n    return str(max_draws)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def score_change(score: str) -> str:\n        x, y = map(int, score.split(':'))\n        return f\"{x+1}:{y}\" if x < y else f\"{x}:{y+1}\"\n    \n    def score_is_draw(score1: str, score2: str) -> bool:\n        x1, y1 = map(int, score1.split(':'))\n        x2, y2 = map(int, score2.split(':'))\n        return x1 == x2 and y1 == y2\n    \n    n = int(stdin.split('\\n')[0])\n    scores = stdin.split('\\n')[1:]\n    max_draws = 1\n    current_score = '0:0'\n    \n    for score in scores:\n        new_score = score_change(current_score)\n        if score_is_draw(current_score, score):\n            max_draws += 1\n        current_score = new_score\n    \n    return str(max_draws)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    score = [tuple(map(int, line.split())) for line in input_data[1:]]\n    \n    max_draws = 1\n    current_draws = 1\n    \n    for i in range(1, len(score)):\n        a, b = score[i]\n        a_prev, b_prev = score[i-1]\n        \n        if a == a_prev and b == b_prev:\n            current_draws += 1\n        else:\n            max_draws = max(max_draws, current_draws)\n            current_draws = 1\n    \n    max_draws = max(max_draws, current_draws)\n    \n    return str(max_draws)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    scores = []\n    for i in range(n):\n        a, b = map(int, input_list[i].split())\n        scores.append((a, b))\n    \n    draws = 0\n    max_draws = 0\n    for i in range(1, n):\n        a1, b1 = scores[i-1]\n        a2, b2 = scores[i]\n        if a1 == a2 and b1 == b2:\n            draws += 1\n        else:\n            max_draws = max(max_draws, draws)\n            draws = 0\n    max_draws = max(max_draws, draws)\n    \n    return str(max_draws + 1)\n"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    score_list = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n\n    # Initialize variables\n    max_draw = 1\n    current_score = score_list[0]\n    last_score = score_list[-1]\n    draw_count = 1 if current_score == (0, 0) else 0\n\n    # Loop through score list\n    for score in score_list[1:]:\n        # Check if score is a draw\n        if score[0] == current_score[0] and score[1] == current_score[1]:\n            draw_count += 1\n        else:\n            draw_count = 1\n\n        # Check if draw count is greater than max draw\n        if draw_count > max_draw:\n            max_draw = draw_count\n\n        # Update current score\n        current_score = score\n\n    # Check if last score is a draw\n    if last_score[0] == current_score[0] and last_score[1] == current_score[1]:\n        max_draw += 1\n\n    return max_draw\n"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_draw(a, b):\n        return a == b\n\n    n = int(stdin)\n    scores = []\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        scores.append((a, b))\n\n    count = 0\n    for i in range(n):\n        if check_draw(scores[i][0], scores[i][1]):\n            count += 1\n        else:\n            break\n\n    return str(count)\n"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    score = [0, 0]\n    max_draw_count = 1\n    draw_count = 1\n    \n    for i in range(n):\n        a, b = map(int, input_list[i].split())\n        if score[0] == score[1]:\n            draw_count += 1\n        else:\n            draw_count = 1\n        if draw_count > max_draw_count:\n            max_draw_count = draw_count\n        score[0] += a\n        score[1] += b\n    \n    return str(max_draw_count)"
    },
    {
        "number": 720,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    scores = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        scores.append((a, b))\n\n    max_draws = 0\n    score = scores[0]\n    max_draws += 1\n\n    for i in range(1, n):\n        if scores[i][0] == score[0] + 1 and scores[i][1] == score[1]:\n            max_draws += 1\n            score = scores[i]\n        elif scores[i][0] == score[0] and scores[i][1] == score[1] + 1:\n            max_draws += 1\n            score = scores[i]\n        else:\n            break\n\n    return str(max_draws)\n\n\ninput_cases = [\n    (\n        \"3\\n2 0\\n3 1\\n3 4\\n\",\n        2\n    ),\n    (\n        \"3\\n0 0\\n0 0\\n0 0\\n\",\n        1\n    ),\n    (\n        \"1\\n5 4\\n\",\n        5\n    ),\n]\n\nfor input_case in input_cases:\n    input_str, expected_output = input_case\n    assert solution(input_str) == str(expected_output) "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    m = int(stdin.splitlines()[2])\n\n    profit = 0\n\n    for i in range(m):\n        if i < n:\n            hook_price = a[i]\n        else:\n            hook_price = d\n\n        profit += hook_price\n\n    return str(profit)\n\n\ninput_str = '''2 1\n2 1\n2'''\n\nprint(solution(input_str)) "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = int(stdin.split()[-1])\n\n    a.sort()\n\n    hooks_used = [False] * n\n    hook_profit = [0] * n\n\n    for _ in range(m):\n        for i in range(n):\n            if not hooks_used[i] and a[i] <= d:\n                hooks_used[i] = True\n                hook_profit[i] = a[i]\n                break\n\n    profit = sum(hook_profit)\n\n    return str(profit)"
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = int(stdin.split()[-1])\n\n    if m > n:\n        return str(-d * (m - n))\n\n    max_profit = 0\n    hooks_used = 0\n\n    for _ in range(m):\n        min_hook = min(a)\n        max_profit += min_hook - d\n        a.remove(min_hook)\n        hooks_used += 1\n\n    if hooks_used < m:\n        max_profit -= m - hooks_used * d\n\n    return str(max_profit)\n\n\ninput_string = '''2 1\n2 1\n2\n'''\n\nprint(solution(input_string))  # Output: 3 "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = int(stdin.split()[-1])\n\n    a.sort()\n    total_profit = 0\n\n    for i in range(m):\n        if i < n:\n            total_profit += (a[i] * (i + 1))\n        else:\n            total_profit -= d\n\n    return str(total_profit)\n\n\nstdin = \"\"\"2 1\n2 1\n2\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2 1\n2 1\n10\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost_hook(hooks_costs: list) -> int:\n        return min(hooks_costs)\n\n    def get_available_hook(hooks_costs: list) -> int:\n        return hooks_costs.index(get_min_cost_hook(hooks_costs))\n\n    n, d = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = int(stdin.split()[-1])\n\n    hooks_costs = [0] * n\n    for cost in a:\n        hooks_costs[get_available_hook(hooks_costs)] += cost\n\n    total_profit = sum(hooks_costs)\n    fines_paid = 0\n\n    for _ in range(m):\n        if get_available_hook(hooks_costs) == -1:\n            fines_paid += d\n        else:\n            total_profit -= hooks_costs[get_available_hook(hooks_costs)]\n            hooks_costs[get_available_hook(hooks_costs)] = float('inf')\n\n    return total_profit - fines_paid"
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, d = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n    m = int(input_list[2])\n\n    profit = 0\n    hooks_used = 0\n    for i in range(m):\n        if hooks_used < n:\n            profit += min(a_list)\n            a_list.remove(min(a_list))\n            hooks_used += 1\n        else:\n            profit -= d\n\n    return str(profit)\n"
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, d = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    m = int(input_list[2])\n\n    a.sort(reverse=True)\n\n    profit = 0\n\n    for i in range(m):\n        if i < n:\n            profit += a[i]\n        else:\n            profit += d\n\n    return str(profit)\n"
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    m = int(input())\n\n    if n < m:\n        return str(d * (m - n))\n\n    a.sort()\n    total_profit = 0\n\n    for i in range(m):\n        if i < n:\n            total_profit += (a[i] * (n - i) + d) * (i + 1)\n        else:\n            total_profit += d\n\n    return str(total_profit)\n\n\ninput_stdin = \"\"\"2 1\n2 1\n2\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_hook(prices: list, available: list) -> int:\n        min_price = float('inf')\n        min_hook = -1\n        for i, hook in enumerate(available):\n            if hook and prices[i] < min_price:\n                min_price = prices[i]\n                min_hook = i\n        return min_hook\n\n    n, d, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    total_profit = 0\n    for _ in range(m):\n        available = [True] * n\n        for cost in a:\n            min_hook = get_min_hook(a, available)\n            if min_hook != -1:\n                available[min_hook] = False\n                total_profit += cost\n            else:\n                total_profit += d\n    return str(total_profit)\n\n\ninput_stdin = \"\"\"2 1\n2 1\n2\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 721,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    m = int(stdin.splitlines()[2])\n\n    # Create a dictionary to store the hooks and their prices\n    hooks = {i: a[i] for i in range(n)}\n\n    # Sort the hooks by price in ascending order\n    sorted_hooks = sorted(hooks.items(), key=lambda x: x[1])\n\n    # Initialize the profit variable\n    profit = 0\n\n    # Iterate through the guests\n    for _ in range(m):\n        # If there are no available hooks, add the fine to the profit\n        if not sorted_hooks:\n            profit -= d\n        else:\n            # Use the cheapest hook available\n            hook = sorted_hooks.pop(0)\n            profit += hook[1]\n\n    return str(profit)"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    abbreviations = stdin.splitlines()[1:]\n\n    years = set()\n    for abbr in abbreviations:\n        year = int(abbr[3:-1])\n        if year not in years:\n            years.add(year)\n        else:\n            year += 1\n\n    result = [f\"IAO'{year}\" for year in sorted(years)]\n    return '\\n'.join(result)\n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    abbreviations = stdin.split(\"\\n\")[1:]\n    used_abbreviations = set()\n    years = []\n\n    for abbreviation in abbreviations:\n        year = int(abbreviation[3:-1])\n        if str(year) + abbreviation[-1] not in used_abbreviations:\n            years.append(year)\n            used_abbreviations.add(str(year) + abbreviation[-1])\n        else:\n            while str(year) + abbreviation[-1] in used_abbreviations:\n                year += 1\n            years.append(year)\n            used_abbreviations.add(str(year) + abbreviation[-1])\n\n    return \"\\n\".join(map(str, years))\n\n\ninput_string = '''5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0\n'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_abbreviation(abbreviation: str) -> bool:\n        if not abbreviation.startswith(\"IAO'\") or abbreviation[3] < '0' or abbreviation[3] > '9':\n            return False\n        year = int(abbreviation[3:])\n        return 1989 <= year <= 9999\n\n    abbreviations = stdin.split('\\n')\n    years = {}\n\n    for abbreviation in abbreviations:\n        if is_valid_abbreviation(abbreviation):\n            year = int(abbreviation[3:])\n            while year in years:\n                year -= 1\n            years[year] = abbreviation\n\n    return '\\n'.join(years.values())\n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    abbreviations = stdin.split(\"\\n\")[1:]\n    \n    years = []\n    used_years = set()\n    \n    for abbreviation in abbreviations:\n        year = int(abbreviation.replace(\"IAO'\", \"\"))\n        while year in used_years:\n            year += 1\n        used_years.add(year)\n        years.append(year)\n        \n    return \"\\n\".join(map(str, years))"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    abbreviations = stdin.split('\\n')[1:]\n    years = []\n    used_years = set()\n\n    for abbreviation in abbreviations:\n        year = int(abbreviation[3:-1])\n        if year < 0 or year > 9999:\n            continue\n        if year not in used_years:\n            years.append(year)\n            used_years.add(year)\n\n    return sorted(years)[0]\n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    abbreviations = [input() for _ in range(n)]\n    years = []\n    \n    for abbreviation in abbreviations:\n        year = int(abbreviation[3:])\n        years.append(year)\n    \n    return years"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    result = []\n    for i in range(1, n+1):\n        abbreviation = input_list[i]\n        year = int(abbreviation[3:])\n        year += 1989\n        while year < 2015:\n            if f\"IAO'{year}\" not in result:\n                result.append(f\"IAO'{year}\")\n                break\n            year += 1\n        if year == 2015:\n            result.append(\"No valid abbreviation found\")\n    return \"\\n\".join(result) \n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_abbreviation(abbreviation: str) -> bool:\n        if len(abbreviation) < 4 or abbreviation[0] != 'I' or abbreviation[1] != 'A' or abbreviation[2] != 'O' or abbreviation[3] != '\\'' or abbreviation[5] != '\\'':\n            return False\n        return True\n\n    def find_year(abbreviation: str) -> int:\n        if not is_valid_abbreviation(abbreviation):\n            raise ValueError(\"Invalid abbreviation\")\n        year = 1989\n        year_str = abbreviation[4:6]\n        while year < 2022:\n            if str(year)[-2:] == year_str:\n                return year\n            year += 1\n        return -1\n\n    n = int(stdin[0])\n    abbreviations = stdin[1:].split('\\n')\n    result = []\n    for abbreviation in abbreviations:\n        try:\n            year = find_year(abbreviation)\n            result.append(year)\n        except ValueError:\n            result.append(\"Invalid abbreviation\")\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    abbreviations = stdin.split('\\n', 1)[1].split('\\n')\n\n    years = set()\n    for abbreviation in abbreviations:\n        year = int(abbreviation[3:-1])\n        if year < 1989:\n            year = 1989\n        years.add(year)\n\n    return min(years)\n"
    },
    {
        "number": 722,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    abbreviations = []\n    for _ in range(n):\n        abbreviation = input().strip()\n        abbreviations.append(abbreviation)\n\n    def get_year(abbreviation: str) -> int:\n        if len(abbreviation) == 4:\n            return 10000 + int(abbreviation[3]) * 1000 + int(abbreviation[2]) * 100 + int(abbreviation[1]) * 10 + int(abbreviation[0])\n        elif len(abbreviation) == 3:\n            return 1000 + int(abbreviation[2]) * 100 + int(abbreviation[1]) * 10 + int(abbreviation[0])\n        else:\n            return int(abbreviation[1]) * 100 + int(abbreviation[0])\n\n    years = []\n    for abbreviation in abbreviations:\n        year = get_year(abbreviation)\n        years.append(year)\n\n    return years\n\nstdin = '''5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0\n'''\n\nprint(solution(stdin))\n"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    points = sorted(list(map(int, input().split())))\n\n    left = 0\n    right = len(points)\n    min_removed = 0\n\n    while left < right:\n        mid = (left + right) // 2\n        if points[mid] - points[0] <= d:\n            left = mid + 1\n        else:\n            right = mid\n\n    min_removed = left\n\n    return str(min_removed)\n"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, d = map(int, input_data[0].split())\n    points = sorted(list(map(int, input_data[1].split())))\n    \n    if d == 0:\n        return 0\n    \n    i, j = 0, n - 1\n    while i < j:\n        if points[j] - points[i] <= d:\n            j -= 1\n        else:\n            i += 1\n    \n    return n - j - 1"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    points = sorted(map(int, stdin.split()[2:]))\n    removed_points = 0\n    \n    for i in range(n):\n        if points[i] - points[i-1] > d:\n            removed_points += 1\n        else:\n            break\n    \n    return removed_points\n"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    points = list(map(int, input().split()))\n\n    points.sort()\n    left = 0\n    right = n\n    min_removed = 0\n\n    while left < right:\n        current_diameter = points[right - 1] - points[left]\n\n        if current_diameter <= d:\n            right -= 1\n        else:\n            min_removed = right - left\n            left += 1\n\n    return min_removed\n"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, d = map(int, input_list[0].split())\n    points = sorted(map(int, input_list[1].split()))\n\n    min_points_to_remove = 0\n    left = 0\n    for i in range(1, n):\n        if points[i] - points[left] > d:\n            min_points_to_remove += 1\n            left = i\n\n    return str(min_points_to_remove)\n"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    points = list(map(int, stdin.split()[2:]))\n    \n    points.sort()\n    max_diameter = points[-1] - points[0]\n    \n    if d == 0:\n        return 0\n    elif d >= max_diameter:\n        return 0\n    else:\n        count = 1\n        for i in range(1, len(points)):\n            max_diameter = max(max_diameter, points[i] - points[i-1])\n            if max_diameter <= d:\n                continue\n            else:\n                max_diameter = points[i-1+count] - points[i-count]\n                count += 1\n        return count\n\n\ndef"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, d = map(int, input_data[0].split())\n    points = list(map(int, input_data[1].split()))\n\n    if d == 0:\n        return 0\n\n    points.sort()\n    min_points_to_remove = 0\n\n    for i in range(n - 1):\n        if points[i + 1] - points[i] > d:\n            min_points_to_remove = i + 1\n            break\n\n    return min_points_to_remove\n\n\nstdin = \"\"\"3 1\n2 1 4\"\"\"\nprint(solution(stdin))  # Output: 1\n\nstdin = \"\"\"3 0\n7 7 7\"\"\"\nprint(solution(stdin))  # Output: 0\n\nstdin = \"\"\"6 3\n1 3 4 6 9 10\"\"\"\nprint(solution(stdin))  # Output: 3 "
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dist(x, y):\n        return abs(x[0] - y[0])\n\n    n, d = map(int, stdin.split()[:2])\n    points = list(map(int, stdin.split()[2:]))\n\n    if len(points) == 1:\n        return \"0\"\n\n    max_diameter = max(dist(points[i], points[j]) for i in range(len(points)) for j in range(i + 1, len(points)))\n\n    if max_diameter <= d:\n        return \"0\"\n\n    min_points_to_remove = 0\n    for i in range(len(points)):\n        points_with_i_removed = [point for j, point in enumerate(points) if j != i]\n        max_diameter_with_i_removed = max(dist(points_with_i_removed[k], points_with_i_removed[l]) for k in range(len(points_with_i_removed)) for l in range(k + 1, len(points_with_i_removed)))\n\n        if max_diameter_with_i_removed > d:\n            min_points_to_remove += 1\n        else:\n            break\n\n    return str(min_points_to_remove)"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, d = map(int, input_list[0].split())\n    points = list(map(int, input_list[1].split()))\n\n    points.sort()\n\n    minimum_points_to_remove = 0\n    for i in range(n - 1):\n        if points[i + 1] - points[i] > d:\n            minimum_points_to_remove += 1\n        else:\n            break\n\n    return minimum_points_to_remove"
    },
    {
        "number": 724,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    points = list(map(int, input().split()))\n\n    min_points = n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = abs(points[i] - points[j])\n            if dist > d:\n                min_points = min(min_points, i, j)\n\n    return min_points - n\n\n\ntest_cases = [\n    \"3 1\\n2 1 4\",\n    \"3 0\\n7 7 7\",\n    \"6 3\\n1 3 4 6 9 10\",\n]\n\nfor test in test_cases:\n    print(solution(test)) "
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    photo = []\n    for _ in range(n):\n        row = input().split()\n        photo.append(row)\n\n    is_black_and_white = True\n    for row in photo:\n        for pixel in row:\n            if pixel in ['C', 'M', 'Y']:\n                is_black_and_white = False\n                break\n        if not is_black_and_white:\n            break\n\n    if is_black_and_white:\n        return \"#Black&White\"\n    else:\n        return \"#Color\"\n\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input().split()))\n\n    black_white = all(all(pixel in ('W', 'B', 'G') for pixel in row) for row in matrix)\n\n    return \"#Black&White\" if black_white else \"#Color\"\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    pixels = [list(line) for line in stdin.splitlines()[1:]]\n\n    for row in pixels:\n        if not all(pixel in 'WBG' for pixel in row):\n            return '#Color'\n\n    return '#Black&White'\n\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    matrix = [list(map(str, stdin.split()[2:]))[i:i+m] for i in range(0, m*n, m)]\n\n    for row in matrix:\n        if any(color in row for color in ['C', 'M', 'Y']):\n            return \"#Color\"\n\n    return \"#Black&White\"\n"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    matrix = []\n    for i in range(1, n+1):\n        matrix.append(stdin.split()[i])\n\n    black_and_white = True\n    colored = False\n\n    for row in matrix:\n        for color in row:\n            if color == 'C' or color == 'M' or color == 'Y':\n                colored = True\n                break\n            elif color != 'W' and color != 'B' and color != 'G':\n                return \"Invalid color\"\n        if colored:\n            break\n\n    if colored:\n        return \"#Color\"\n    else:\n        return \"#Black&White\"\n\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    photo = [line.strip() for line in stdin.split('\\n')[1:]]\n    black_and_white = True\n\n    for row in photo:\n        for pixel in row:\n            if pixel in ('C', 'M', 'Y'):\n                black_and_white = False\n                break\n        if not black_and_white:\n            break\n\n    if black_and_white:\n        return \"#Black&White\"\n    else:\n        return \"#Color\"\n\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    matrix = []\n    for i in range(n):\n        row = stdin.split()[i + 1]\n        matrix.append(list(row))\n\n    is_colored = False\n    is_bw = True\n\n    for i in range(n):\n        for j in range(m):\n            pixel = matrix[i][j]\n            if pixel == 'C' or pixel == 'M' or pixel == 'Y':\n                is_colored = True\n            elif pixel == 'W' or pixel == 'G' or pixel == 'B':\n                is_bw = False\n            else:\n                raise ValueError(\"Invalid pixel color\")\n\n            if not is_colored and not is_bw:\n                break\n        if not is_colored and not is_bw:\n            break\n\n    if is_colored:\n        return \"#Color\"\n    else:\n        return \"#Black&White\"\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        row = input().split()\n        matrix.append(row)\n\n    is_black_and_white = True\n    is_colored = False\n\n    for row in matrix:\n        for color in row:\n            if color in ('C', 'M', 'Y'):\n                is_colored = True\n                break\n            elif color not in ('W', 'G', 'B'):\n                is_black_and_white = False\n                break\n        if not is_black_and_white and not is_colored:\n            break\n\n    if is_black_and_white:\n        return \"#Black&White\"\n    elif is_colored:\n        return \"#Color\"\n    else:\n        return \"#Unknown\"\n\n\ndef"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    photo = [[input_data[i+1][j] for j in range(m)] for i in range(n)]\n\n    for row in photo:\n        for pixel in row:\n            if pixel not in ['C', 'M', 'Y', 'W', 'G', 'B']:\n                return \"Invalid input\"\n\n    has_cyan = any('C' in row for row in photo)\n    has_magenta = any('M' in row for row in photo)\n    has_yellow = any('Y' in row for row in photo)\n\n    if not has_cyan and not has_magenta and not has_yellow:\n        return \"#Black&White\"\n    else:\n        return \"#Color\"\n"
    },
    {
        "number": 725,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    matrix = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    black_and_white_colors = {'W', 'B', 'G'}\n    colored_colors = {'C', 'M', 'Y'}\n\n    for row in matrix:\n        if any(color in colored_colors for color in row):\n            return \"#Color\"\n\n    return \"#Black&White\"\n\n\ndef"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    hotels = sorted(map(int, input().split()))\n    \n    count = 0\n    for i in range(n):\n        if hotels[i] + d <= hotels[-1]:\n            count += hotels[-1] - (hotels[i] + d) + 1\n    \n    return count\n\nn = 4\nd = 3\nhotels = [-3, 2, 9, 16]\nprint(solution(hotels))\n\nn = 5\nd = 2\nhotels = [4, 8, 11, 18, 19]\nprint(solution(hotels)) "
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, hotels, d):\n        for y in hotels:\n            if abs(x - y) <= d:\n                return False\n        return True\n\n    n, d = map(int, input().split())\n    hotels = sorted(map(int, input().split()))\n\n    count = 0\n    for i in range(1, hotels[-1] + d):\n        if is_valid(i, hotels, d):\n            count += 1\n\n    return str(count)\n\n\ninput_stdin = \"\"\"4 3\n-3 2 9 16\"\"\"\n\noutput_stdout = \"6\"\n\ninput_stdin2 = \"\"\"5 2\n4 8 11 18 19\"\"\"\n\noutput_stdout2 = \"5\"\n\n\nprint(solution(input_stdin))\nprint(solution(input_stdin2)) "
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_city(x: int, cities: List[int]) -> bool:\n        return all(abs(city - x) >= d for city in cities)\n\n    n, d = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n    cities = sorted(set(x))\n    result = sum(is_valid_city(city, x) for city in cities)\n    return str(result)"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    n, d = map(int, input().split())\n    x = list(map(int, input().split()))\n\n    x.sort()\n    left, right = 0, x[-1] - x[0]\n    possible_cities = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if sum(distance(x[i], x[0] + mid) for i in range(n)) % d == 0:\n            possible_cities = sum(distance(x[i], x[0] + mid) // d for i in range(n)) + 1\n            break\n        elif sum(distance(x[i], x[0] + mid) for i in range(n)) % d < 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return possible_cities\n\n\ninput_string = \"\"\"4 3\n-3 2 9 16\n5 2\n4 8 11 18 19\"\"\"\n\noutput_string = \"\"\"6\n5\"\"\"\n\nfor input_case, output_case in zip(input_string.split('\\n'), output_string.split('\\n')):\n    print(solution(input_case))\n    assert solution(input_case) == output_case "
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    x = sorted(map(int, input().split()))\n\n    left, right = 1, x[-1] - x[0]\n    while left <= right:\n        mid = (left + right) // 2\n        if (x[-1] - x[0]) - (n - 1) * mid >= d:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return right\n\n\ninput_stdin = \"\"\"4 3\n-3 2 9 16\"\"\"\n\noutput_stdout = \"6\"\n\n\ninput_stdin = \"\"\"5 2\n4 8 11 18 19\"\"\"\n\noutput_stdout = \"5\"\n\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    x = list(map(int, input().split()))\n\n    x.sort()\n\n    total = x[-1] + d\n    count = 1\n\n    for i in range(n - 1):\n        if x[i + 1] - x[i] >= d:\n            count += 1\n        else:\n            x[i + 1] = x[i] + d\n            count += 1\n\n    return count\n"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    x = list(map(int, input().split()))\n    x.sort()\n\n    count = 0\n    left, right = x[0] + d, x[n - 1] - d\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        total = 0\n        for i in range(n):\n            total += abs(x[i] - mid)\n\n        if total == d:\n            count += 1\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return count\n\n\ndef"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    x = list(map(int, input().split()))\n    x.sort()\n\n    left, right = 0, 10**9\n    while left <= right:\n        mid = (left + right) // 2\n\n        count = 0\n        for i in range(n):\n            if abs(x[i] - mid) <= d:\n                count += 1\n\n        if count > n // 2:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, d = map(int, input_data[0].split())\n    x = list(map(int, input_data[1].split()))\n\n    count = 0\n    for i in range(n):\n        if x[i] + d in x[:i] or x[i] - d in x[i+1:]:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 726,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a - b)\n\n    n, d = map(int, stdin.split()[:2])\n    hotels = list(map(int, stdin.split()[2:]))\n    hotels.sort()\n\n    count = 0\n    for i in range(len(hotels) - 1):\n        distance_sum = hotels[i + 1] - hotels[i] - d\n        if distance_sum < 0:\n            count += 1\n        else:\n            count += 2\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    count = 0\n\n    while arr:\n        max_len = 0\n        for i, num in enumerate(arr):\n            curr_len = 1\n            for j in range(i + 1, len(arr)):\n                if arr[j] == num:\n                    curr_len += 1\n                else:\n                    break\n            if curr_len > max_len:\n                max_len = curr_len\n\n        arr = arr[max_len:]\n        count += 1\n\n    return str(count)\n\ninput_stdin = \"\"\"4\n2 5 5 2\n5\n6 3 4 1 5\n8\n4 4 4 2 2 100 100 100\n6\n10 10 50 10 50 50\"\"\"\n\noutput_stdin = \"\"\"2\n5\n5\n4\"\"\"\n\ninput_stdin = input_stdin.strip().split('\\n')\noutput_stdin = output_stdin.strip().split('\\n')\n\nfor i in range(len(input_stdin)):\n    assert solution(input_stdin[i]) == output_stdin[i]\n\nprint(\"All test cases passed.\")"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n    count = 0\n    while arr:\n        max_count = 1\n        max_num = arr[0]\n        for num in arr:\n            if num == max_num:\n                max_count += 1\n            else:\n                break\n        count += max_count\n        arr = arr[max_count:]\n    return count\n"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    count = 0\n    while arr:\n        count += 1\n        i = 0\n        while i < n - 1 and arr[i] == arr[i + 1]:\n            i += 1\n        arr = arr[:i + 1] + arr[i + 2:]\n\n    return str(count)\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\ncount = 0\nwhile arr:\n    count += 1\n    i = 0\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n    arr = arr[:i + 1] + arr[i + 2:]\n\nprint(count) "
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    \n    count = 0\n    while arr:\n        max_len = 1\n        max_val = arr[0]\n        \n        for i in range(1, n):\n            if arr[i] == max_val:\n                max_len += 1\n            else:\n                break\n                \n        count += max_len\n        arr = arr[max_len:]\n        n -= max_len\n        \n    return count"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = list(map(int, input().split()))\n\n    count = 0\n    while arr:\n        longest_segment = 0\n        current_segment = 1\n        for i in range(1, n):\n            if arr[i] == arr[i-1]:\n                current_segment += 1\n            else:\n                longest_segment = max(longest_segment, current_segment)\n                current_segment = 1\n        longest_segment = max(longest_segment, current_segment)\n        count += longest_segment\n        arr = arr[longest_segment:]\n        n -= longest_segment\n\n    return count\n"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    count = 0\n    \n    while arr:\n        count += 1\n        max_len = 0\n        max_val = None\n        for i in range(n):\n            if arr[i] == max_val:\n                max_len += 1\n            else:\n                max_len = 1\n                max_val = arr[i]\n        \n        arr = [arr[i] for i in range(n) if arr[i] != max_val]\n        n -= max_len\n    \n    return str(count)"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    count = 0\n    while len(a) > 0:\n        count += 1\n        longest_segment = 1\n        current_segment = 1\n        for i in range(1, len(a)):\n            if a[i] == a[i - 1]:\n                current_segment += 1\n            else:\n                current_segment = 1\n            if current_segment > longest_segment:\n                longest_segment = current_segment\n        a = a[longest_segment:]\n    \n    return count\n"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = 0\n    while len(arr) > 0:\n        max_count = 0\n        max_value = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] == max_value:\n                max_count += 1\n            else:\n                break\n        for i in range(max_count):\n            arr.pop(0)\n        count += 1\n    return count\n\nn = int(input())\narr = list(map(int, input().split()))\ncount = 0\nwhile len(arr) > 0:\n    max_count = 0\n    max_value = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] == max_value:\n            max_count += 1\n        else:\n            break\n    for i in range(max_count):\n        arr.pop(0)\n    count += 1\nprint(count) "
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    array = list(map(int, stdin.split()[1:]))\n    count = 0\n    while array:\n        longest_segment = 0\n        current_segment = 1\n        for i in range(1, n):\n            if array[i] == array[i - 1]:\n                current_segment += 1\n            else:\n                longest_segment = max(longest_segment, current_segment)\n                current_segment = 1\n        longest_segment = max(longest_segment, current_segment)\n        array = array[longest_segment:]\n        count += 1\n    return count\n"
    },
    {
        "number": 727,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def longest_consecutive_segment(arr):\n        unique_elems = set(arr)\n        longest_length = 0\n        for elem in unique_elems:\n            current_length = 1\n            for i in range(1, len(arr)):\n                if arr[i] == elem:\n                    current_length += 1\n                else:\n                    break\n            longest_length = max(longest_length, current_length)\n        return longest_length\n\n    n = int(input())\n    arr = list(map(int, input().split()))\n    operations_count = 0\n    while len(arr) > 0:\n        longest_segment_length = longest_consecutive_segment(arr)\n        operations_count += 1\n        arr = arr[:len(arr) - longest_segment_length]\n    return str(operations_count - 1)\n\n\nstdin = \"\"\"\n4\n2 5 5 2\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    votes = list(map(int, stdin.splitlines()[1].split()))\n    \n    max_votes = max(votes)\n    max_votes_count = votes.count(max_votes)\n    \n    if max_votes_count > 1:\n        votes.remove(max_votes)\n        max_votes = max(votes)\n        max_votes_count = votes.count(max_votes)\n    \n    bribes = 0\n    for vote in votes:\n        if vote < max_votes:\n            bribes += 1\n    \n    return bribes"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    votes = list(map(int, stdin.splitlines()[1].split()))\n    \n    max_votes = max(votes[1:])\n    bribes = sum(votes[1:]) - max_votes\n    \n    return str(bribes)"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    votes = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n\n    max_votes = max(votes)\n    max_votes_count = votes.count(max_votes)\n    if max_votes_count > 1:\n        votes.remove(max_votes)\n        max_votes = max(votes)\n        max_votes_count = votes.count(max_votes)\n\n    bribe_count = 0\n    for i in range(n):\n        if votes[i] < max_votes:\n            bribe_count += max_votes - votes[i]\n\n    return str(bribe_count)\n"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    votes = list(map(int, stdin.split('\\n')[1].split()))\n    max_votes = max(votes[1:])\n    min_votes = min(votes[1:])\n    max_votes_count = votes.count(max_votes)\n    \n    if max_votes == 0:\n        return 0\n    \n    min_votes_count = votes.count(min_votes)\n    total_votes = sum(votes)\n    total_votes_without_min_votes = total_votes - min_votes * min_votes_count\n    total_votes_without_max_votes = total_votes - max_votes * max_votes_count\n    \n    if total_votes_without_max_votes == 0:\n        return 0\n    \n    bribes_needed = (total_votes_without_min_votes - total_votes_without_max_votes) // (max_votes_count - 1)\n    \n    if bribes_needed < 0:\n        bribes_needed = 0\n    \n    return bribes_needed "
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    votes = list(map(int, stdin.splitlines()[1].split()))\n    max_votes = max(votes)\n    min_votes = min(votes[1:])\n    result = 0\n    \n    for i in range(1, n):\n        if votes[i] == min_votes:\n            result += min_votes\n        elif votes[i] < max_votes:\n            result += min_votes - votes[i]\n    \n    return result\n\nn = 5\nvotes = [5, 1, 11, 2, 8]\nn = 4\nvotes = [1, 8, 8, 8]\nn = 2\nvotes = [7, 6]\nn = 2\nvotes = [10, 0]"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    votes = list(map(int, input().split()))\n    max_votes = max(votes)\n    bribes = 0\n    for i in range(n):\n        if votes[i] == max_votes:\n            bribes += votes.count(max_votes) - 1\n    return bribes\n\nn = 5\nvotes = [5, 1, 11, 2, 8]\nn = 4\nvotes = [1, 8, 8, 8]\nn = 2\nvotes = [7, 6]"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    votes = list(map(int, stdin.split('\\n')[1].split()))\n    \n    min_votes = min(votes[1:])\n    total_votes = sum(votes)\n    \n    return total_votes - min_votes - 1\n"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    votes = list(map(int, input_data[1].split()))\n    \n    votes.sort(reverse=True)\n    total_votes = sum(votes)\n    \n    bribes = 0\n    for i in range(1, n):\n        if votes[i] - votes[i - 1] > 1:\n            return -1\n        bribes += votes[i] - votes[i - 1]\n    \n    if votes[0] > total_votes - n:\n        return -1\n    \n    return bribes + (total_votes - n - bribes) // n\n\n\nstdin = \"\"\"5\n5 1 11 2 8\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"4\n1 8 8 8\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"2\n7 6\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    votes = list(map(int, input_list[1:]))\n    max_votes = max(votes)\n\n    if votes.count(max_votes) == 1:\n        for i in range(n):\n            if votes[i] == max_votes:\n                votes[i] = 0\n                break\n        bribes = votes.count(max_votes)\n    else:\n        bribes = 0\n\n    return str(bribes)"
    },
    {
        "number": 728,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    votes = list(map(int, stdin.splitlines()[1].split()))\n\n    max_votes = max(votes)\n    min_votes = min(votes)\n\n    if max_votes > min_votes + 1:\n        return 0\n\n    bribes = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if votes[i] < votes[j]:\n                bribes[i] += 1\n\n    return sum(bribes)"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    count_dict = {}\n\n    for letter in s:\n        if letter in count_dict:\n            count_dict[letter] += 1\n        else:\n            count_dict[letter] = 1\n\n    diverse_substring = \"\"\n    for letter in s:\n        if count_dict[letter] <= n // 2:\n            diverse_substring += letter\n        else:\n            break\n\n    if diverse_substring == \"\":\n        return \"NO\"\n    else:\n        return \"YES\\n\" + diverse_substring\n"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    \n    for i in range(n):\n        count = {}\n        for j in range(i, n):\n            if s[j] not in count:\n                count[s[j]] = 1\n            else:\n                count[s[j]] += 1\n            if len(count) > n//2:\n                break\n        else:\n            return \"YES\\n\" + s[i:]\n    \n    return \"NO\""
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n\n    # Check if the string is diverse\n    if any(s.count(c) > n // 2 for c in set(s)):\n        return \"NO\"\n\n    # Find any diverse substring\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if all(substr.count(c) <= substr.count(c) // 2 for c in set(substr)):\n                return \"YES\\n\" + substr\n\n    return \"NO\"\n"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n\n    for char in s:\n        if s.count(char) > n // 2:\n            return \"NO\"\n\n    return \"YES\\n\" + s"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin.split('\\n')[1]\n\n    def is_diverse(substring):\n        char_count = {}\n        for char in substring:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        for count in char_count.values():\n            if count > (n // 2):\n                return False\n        return True\n\n    diverse_substring = None\n    for i in range(1, n + 1):\n        for j in range(n - i + 1):\n            substring = s[j:j + i]\n            if is_diverse(substring):\n                diverse_substring = substring\n                break\n        if diverse_substring is not None:\n            break\n\n    if diverse_substring is None:\n        return \"NO\\n\"\n    else:\n        return \"YES\\n\" + diverse_substring + \"\\n\"\n"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_diverse(s: str) -> bool:\n        letter_count = [0] * 26\n        for c in s:\n            letter_count[ord(c) - ord('a')] += 1\n        return max(letter_count) <= len(s) // 2\n\n    n, s = map(str, stdin.split())\n    n = int(n)\n    s = s.lower()\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_diverse(s[i:j]):\n                return \"YES\\n\" + s[i:j]\n    return \"NO\"\n"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if len(set(substring)) * 2 < len(substring) and len(substring) <= n // 2:\n                return \"YES\\n\" + substring\n\n    return \"NO\"\n"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if len(set(substring)) * n // len(substring) <= n // 2:\n                return \"YES\\n\" + substring\n\n    return \"NO\"\n\n\nstdin = \"\"\"10\ncodeforces\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"5\naaaaa\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\naaabbbccc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"5\nabbbb\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"8\naabbbbcc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nz\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcdefghij\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcdefghijklmnopqrstuvwxyz\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\naaabbbcccddeefff\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"5\nabcde\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"7\naabcdee\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcd\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmno\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmop\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmopq\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstu\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyz\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzn\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzab\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcd\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcde\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdef\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdefg\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdefgh\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdefghi\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdefghij\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuvwxyzabcdefghijk\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"10\nabcabcabcabcdefghijklmnopqrstuv"
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    if n == 1:\n        return \"YES\", s\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            letter_count = {}\n\n            for letter in substring:\n                if letter in letter_count:\n                    letter_count[letter] += 1\n                else:\n                    letter_count[letter] = 1\n\n            max_count = max(letter_count.values())\n            if max_count <= n/2:\n                return \"YES\", substring\n\n    return \"NO\"\n\nstdin = \"\"\"10\ncodeforces\"\"\"\n\nresult = solution(stdin)\nprint(result)\n\nstdin = \"\"\"5\naaaaa\"\"\"\n\nresult = solution(stdin)\nprint(result)\n\nstdin = \"\"\"10\naabbcc\"\"\"\n\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 729,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    diverse_substring = \"NO\"\n    for i in range(n):\n        count = {}\n        for j in range(i, n):\n            if s[j] not in count:\n                count[s[j]] = 1\n            else:\n                count[s[j]] += 1\n            if max(count.values()) <= n//2 and min(count.values()) <= n//2:\n                diverse_substring = s[i:j+1]\n        if diverse_substring != \"NO\":\n            break\n    return diverse_substring\n\nstdin = '''10\ncodeforces\n5\naaaaa'''\n\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    left_spaces = 30 - len(str(k))\n    output = f\"|{'O'*k}{'.'*(34-k)}|{'D' if k == 0 else ''}|)\\n\"\n    output += f\"|{'O'*k}{'.'*(34-k)}|{'D' if k == 0 else ''}|)\\n\"\n    output += \"|O\" + \".\"*(34-k) + \"|\" + \".\"*(34-k) + \"|\" + \")\\n\"\n    output += f\"|{'O'*k}{'.'*(34-k)}|{'D' if k == 0 else ''}|)\\n\"\n    output += \"+------------------------+\\n\"\n    return output"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    rows = 2\n    seats_per_row = 11\n    max_empty_seats = 3\n    bus_figure = \"\"\n\n    for i in range(rows):\n        if i == 0:\n            bus_figure += \"|O.O.O.O.O.O.O.\"\n            for j in range(seats_per_row - 7):\n                if k > 0:\n                    bus_figure += \"O\"\n                    k -= 1\n                else:\n                    bus_figure += \"#\"\n            bus_figure += \"|D|)\"\n        else:\n            bus_figure += \"|O.O.O.O.O.O.\"\n            for j in range(seats_per_row - 7):\n                if k > 0:\n                    bus_figure += \"O\"\n                    k -= 1\n                else:\n                    bus_figure += \"#\"\n            bus_figure += \"|.|)\"\n        bus_figure += \"\\n\"\n\n    bus_figure = bus_figure.replace(\"O\", \".\")\n    return bus_figure\n"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    k = int(input_data[0])\n    \n    if k > 34:\n        raise ValueError(\"k should be less than or equal to 34\")\n    \n    empty_seats = 34 - k\n    last_row_empty_seats = 4 - (empty_seats % 4)\n    if last_row_empty_seats < 0:\n        last_row_empty_seats += 4\n    occupied_seats = empty_seats + k\n    \n    bus_figure = \"\"\n    for i in range(6):\n        bus_figure += \"+------------------------+\\n\"\n        if i == 0:\n            bus_figure += \"|O.O.O.O.O.O.O.#.#.#.#.|D|)\"\n        elif i == 1:\n            bus_figure += \"|O.O.O.O.O.O.#.#.#.#.#.|.|\"\n        elif i == 2:\n            bus_figure += \"|O.......................|\"\n        elif i == 3:\n            bus_figure += \"|O.O.#.#.#.#.#.#.#.#.#.#.|.|)\"\n        elif i == 4:\n            bus_figure += \"|O.O.O.O.O.O.#.#.#.#.#.|.|\"\n        elif i == 5:\n            bus_figure += \"|O.O.O.O.O.O.#.#.#.#.#.|.|\"\n        bus_figure += \"\\n\"\n        \n    return bus_figure\n"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n\n    output = \"+------------------------+\\n\"\n\n    for i in range(1, 9):\n        output += \"|O.O.O.O.O.O.O.#.#.#.#.|.|\" if i == 1 else \"|O.O.O.O.O.O.#.#.#.#.#.|.|\"\n        output += \"\\n\" if i == 4 else \"|O.......................|\\n\"\n        output += \"|O.O.O.O.O.O.#.#.#.#.#.#.|.|)\" if i == 7 else \"|O.O.O.O.O.O.#.#.#.#.#.|.|)\\n\"\n\n    output += \"+------------------------+\\n\"\n\n    return output\n"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n\n    output = \"+------------------------+\\n\"\n    output += \"|O.O.O.#.#.#.#.#.#.#.#.|D|\\n\"\n    output += \"|O.O.O.#.#.#.#.#.#.#.#.|.|\\n\"\n    output += \"|O.......................|\\n\"\n    output += \"|O.O.O.O.O.O.O.O.O.O.O.|.|\\n\"\n    output += \"+------------------------+\\n\"\n\n    for i in range(k):\n        output = output.replace(\"O\", \"X\", 1)\n\n    return output.replace(\"X\", \"O\")\n\n\ninput_str = \"20\"\noutput = solution(input_str)\nprint(output)"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n\n    empty_seats = [\"O\"] * 4 + [\".\"] * 34 + [\"D\"]\n    empty_seats_list = list(empty_seats)\n    row_length = 36\n\n    for i in range(k):\n        for j in range(4, row_length, 37):\n            if empty_seats_list[j] == \".\":\n                empty_seats_list[j] = \"X\"\n                break\n\n    empty_seats_list[0] = \"O\"\n    empty_seats_list[-1] = \"D\"\n\n    empty_seats_str = \"\".join(empty_seats_list)\n    output = \"\"\n\n    for i in range(6):\n        output += \"|\" + empty_seats_str[i * row_length: (i + 1) * row_length] + \"|\\n\"\n\n    output = \"+------------------------+\\n\" + output + \"+------------------------+\"\n\n    return output\n"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    output = \"+------------------------+\\n\"\n    for i in range(4):\n        row = \"\"\n        for j in range(11):\n            if (i == 0 and j <= 4) or (i > 0 and j <= 4 and j <= 4 + i * 2):\n                row += \"O\"\n            else:\n                row += \".\"\n        if i == 0:\n            row += \"D\"\n        elif i == 1:\n            row += \")\"\n        elif i == 2:\n            row += \"|\"\n        elif i == 3:\n            row += \"|\"\n        output += \"|\" + row + \"|\" + \"\\n\"\n    output += \"+------------------------+\"\n    return output\n\n\ndef"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    bus_seats = \"O.O.O.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#."
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    empty_seats = 34 - k\n    empty_seats_last_row = 4 - empty_seats\n\n    output = \"\"\n    output += \"+------------------------+\\n\"\n    output += \"|O.O.O.O.O.O.O.#.#.#.#.|D|\\n\" if empty_seats_last_row == 0 else \"|O.O.O.O.O.O.O.#.#.#.#.|.|\\n\"\n    output += \"|O.O.O.O.O.O.O.#.#.#.#.#.|.|\\n\" if empty_seats_last_row == 0 else \"|O.O.O.O.O.O.O.#.#.#.#.|.|\\n\"\n    output += \"|O.O.O.O.O.O.O.#.#.#.#.#.|.|\\n\" if empty_seats_last_row == 0 else \"|O.O.O.O.O.O.O.#.#.#.#.|.|\\n\"\n    output += \"|O.O.O.O.O.O.O.#.#.#.#.#.|.|\\n\" if empty_seats_last_row == 0 else \"|O.O.O.O.O.O.O.#.#.#.#.|.|\\n\"\n    output += \"+------------------------+\\n\"\n\n    return output\n"
    },
    {
        "number": 730,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    rows = 6\n    cols = 34\n    empty_seats = [True] * cols\n\n    for i in range(k):\n        for j in range(cols - 4, cols):\n            if empty_seats[j]:\n                empty_seats[j] = False\n                break\n\n    output = []\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            if j < 4:\n                row.append(\".\")\n            elif empty_seats[j]:\n                row.append(\"#\")\n            else:\n                row.append(\"O\")\n        row.append(\"|D|)\") if i == 0 else \"|.|)\"\n        output.append(\"\".join(row))\n\n    output.insert(2, \"+------------------------+\")\n    output.insert(0, \"+------------------------+\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    if k == 0:\n        return \"0\"\n    if w < k * m:\n        return \"0\"\n    max_length = 0\n    n = m\n    while n <= w:\n        length = len(str(n))\n        cost = length * k\n        if cost <= w:\n            max_length += 1\n        n += 1\n    return str(max_length)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n\n    def s(n):\n        count = 0\n        while n > 0:\n            count += n % 10\n            n //= 10\n        return count\n\n    if s(m) * k > w:\n        return \"0\"\n\n    max_length = 0\n    n = m\n    while s(n) * k <= w:\n        max_length += 1\n        n += 1\n\n    return str(max_length)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    w = int(input_values[0])\n    m = int(input_values[1])\n    k = int(input_values[2])\n\n    max_length = 0\n    n = m\n    while n <= m + w:\n        digit_sum = sum(int(digit) for digit in str(n))\n        if digit_sum * k <= w:\n            max_length += 1\n        n += 1\n\n    return str(max_length)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    max_len = 0\n    \n    for n in range(m, m + w - k + 1):\n        digit_sum = sum(int(digit) for digit in str(n))\n        if digit_sum * k >= n:\n            max_len += 1\n    \n    return str(max_len)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n\n    def S(n: int) -> int:\n        return len(str(n))\n\n    if m <= 0 or S(m) * k > w:\n        return \"0\"\n\n    result = 0\n    while m <= w // (S(m) * k):\n        result += 1\n        m *= 10\n\n    return str(result)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    if k == 0:\n        return \"0\"\n\n    def s(n: int) -> int:\n        count = 0\n        while n > 0:\n            count += n % 10\n            n //= 10\n        return count\n\n    length = 0\n    num = m\n    while k >= s(num) * k:\n        length += 1\n        num += 1\n        k -= s(num) * k\n\n    return str(length)\n"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    max_length = 0\n    current_length = 0\n    num = m\n    while num <= m + w:\n        s = len(str(num))\n        if s * k <= w:\n            w -= s * k\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n        num += 1\n    max_length = max(max_length, current_length)\n    return str(max_length)\n\ndef"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    if m == 1:\n        return \"0\"\n    if k == 1:\n        return \"1\"\n    if k > w:\n        return \"0\"\n    n = 1\n    while S(n) * k <= w:\n        n += 1\n    return str(n - 1)\n\ndef"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    if k == 0:\n        return \"0\"\n    max_length = 0\n    n = m\n    while n <= w:\n        digits = len(str(n))\n        if digits * k > w:\n            break\n        max_length += 1\n        n += 1\n    return str(max_length)\n\n\ndef"
    },
    {
        "number": 731,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    length = 0\n    n = m\n    while n <= w:\n        length += 1\n        n += 1\n    return str(length)\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_numbers = []\n    for i in range(1, n+1):\n        num = str(i)\n        if all(char in '47' for char in num) or all(char in '02468' for char in num):\n            lucky_numbers.append(i)\n    return len(lucky_numbers)\n\nn = input()\nprint(solution(n)) "
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        num_str = str(i)\n        if set(num_str) == {'4', '7'}:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    count = 0\n    \n    for i in range(1, n+1):\n        num = str(i)\n        lucky = True\n        for digit in num:\n            if digit != '4' and digit != '7':\n                lucky = False\n                break\n        if lucky:\n            count += 1\n    \n    return count\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for i in range(1, n+1):\n        flag = True\n        num = i\n        while num > 0:\n            digit = num % 10\n            if digit not in [4, 7]:\n                flag = False\n                break\n            num //= 10\n        if flag:\n            count += 1\n            \n    return str(count)\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for i in range(10, n + 1):\n        if i < 100:\n            count += 1\n        else:\n            string_i = str(i)\n            if string_i.count('4') + string_i.count('7') == len(string_i):\n                count += 1\n                \n    return str(count)\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    x, y = 0, 0\n    \n    for i in range(1, n+1):\n        if i % 10 != 0:\n            count += 1\n            x = i % 10\n            y = (i // 10) % 10\n            continue\n        for j in range(10):\n            if i % 10 == x and (i // 10) % 10 == y:\n                count += 1\n                break\n            i += 1\n            if i == n+1:\n                break\n    \n    return str(count)\n\n\ninput_data = \"10\"\nprint(solution(input_data))  # Output: 10\n\ninput_data = \"123\"\nprint(solution(input_data))  # Output: 113 "
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_numbers = [1, 4, 7]\n    lucky_count = 0\n\n    for i in range(1, n + 1):\n        if len(str(i)) == 1 and int(str(i)[0]) in lucky_numbers:\n            lucky_count += 1\n        elif len(str(i)) == 2 and int(str(i)[0]) in lucky_numbers and int(str(i)[1]) in lucky_numbers:\n            lucky_count += 1\n        elif len(str(i)) > 2 and i % 10 in lucky_numbers:\n            lucky_count += 1\n\n    return str(lucky_count)\n"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for num in range(1, n+1):\n        num_str = str(num)\n        if all(digit in ('4', '7') for digit in num_str):\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n\n    for i in range(1, n+1):\n        digits = set(str(i))\n        if digits.issubset({'4', '7'}):\n            count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 732,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for i in range(1, n + 1):\n        str_i = str(i)\n        x = 0\n        y = 0\n        for digit in str_i:\n            if digit == '4' or digit == '7':\n                if x == 0:\n                    x += 1\n                elif y == 0:\n                    y += 1\n        if x == 1 and y == 1:\n            count += 1\n    \n    return str(count)\n\nn = int(input())\nprint(solution(n)) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = set(range(a, b+1, x))\n    pink_bricks = set(range(a, b+1, y))\n    common_bricks = red_bricks.intersection(pink_bricks)\n    return len(common_bricks)\n\n\ninput_str = \"2 3 6 18\"\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    \n    red_bricks = set()\n    pink_bricks = set()\n    \n    for i in range(1, b+1, x):\n        red_bricks.add(i)\n    for i in range(1, b+1, y):\n        pink_bricks.add(i)\n    \n    both_colored = red_bricks & pink_bricks\n    \n    return len(both_colored)\n\ninput_str = \"2 3 6 18\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = set()\n    pink_bricks = set()\n\n    # Iahub's scheme\n    for i in range(1, x + 1):\n        red_bricks.add(i * x)\n\n    # Floyd's scheme\n    for j in range(1, y + 1):\n        pink_bricks.add(j * y)\n\n    # Remove bricks that are painted both red and pink\n    red_pink_bricks = red_bricks.intersection(pink_bricks)\n\n    # Count bricks that are greater than or equal to a and less than or equal to b\n    count = 0\n    for brick in red_pink_bricks:\n        if a <= brick <= b:\n            count += 1\n\n    return str(count)\n\n\ninput_str = \"2 3 6 18\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    \n    red_bricks = [x*i for i in range(1, a+1)]\n    pink_bricks = [y*i for i in range(1, a+1)]\n    \n    common_bricks = set(red_bricks) & set(pink_bricks)\n    \n    count = 0\n    for i in range(a, b+1):\n        if i in common_bricks:\n            count += 1\n    \n    return str(count)\n\ninput_data = \"2 3 6 18\"\nprint(solution(input_data)) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    \n    red_bricks = [i for i in range(a, b+1) if i % x == 0]\n    pink_bricks = [i for i in range(a, b+1) if i % y == 0]\n    common_bricks = set(red_bricks) & set(pink_bricks)\n    \n    return len(common_bricks)"
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    x, y, a, b = input_values\n\n    red_skips = x - 1\n    red_start = red_skips * x + 1\n\n    pink_skips = y - 1\n    pink_start = pink_skips * y + 1\n\n    bricks_painted_both = 0\n\n    for i in range(a, b + 1):\n        if i % red_start == 0 and i % pink_start == 0:\n            bricks_painted_both += 1\n\n    return str(bricks_painted_both)\n"
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    count = 0\n    red_brick = x\n    pink_brick = y\n\n    for i in range(a, b+1):\n        if i % red_brick == 0 and i % pink_brick == 0:\n            count += 1\n\n    return str(count)\n\n\ninput_str = \"2 3 6 18\"\nprint(solution(input_str)) "
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = set()\n    pink_bricks = set()\n\n    for i in range(a, b + 1):\n        red_bricks.add(i)\n        red_bricks.add(i * x)\n        if i * x - 1 < b:\n            red_bricks.add(i * x - 1)\n\n        pink_bricks.add(i)\n        pink_bricks.add(i * y)\n        if i * y - 1 < b:\n            pink_bricks.add(i * y - 1)\n\n    return len(red_bricks.intersection(pink_bricks))"
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = [i for i in range(a, b+1, x)]\n    pink_bricks = [i for i in range(a, b+1, y)]\n    common_bricks = [i for i in red_bricks if i in pink_bricks]\n    result = len(common_bricks)\n    return str(result)\n"
    },
    {
        "number": 733,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_bricks = [i for i in range(a, b+1) if (i-1) % x == 0]\n    pink_bricks = [i for i in range(a, b+1) if (i-1) % y == 0]\n    both_colored_bricks = set(red_bricks) & set(pink_bricks)\n    return len(both_colored_bricks)"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def top_view(a, m):\n        stack = [0] * m\n        for i in range(n):\n            for j in range(m - 1, -1, -1):\n                if a[i] > j + 1:\n                    stack[j + 1] = stack[j] + a[i] - j - 1\n                else:\n                    stack[j + 1] = stack[j]\n        return stack\n\n    def side_view(a, m):\n        left = [0] * m\n        right = [0] * m\n        for i in range(n):\n            for j in range(m - 1, -1, -1):\n                if a[i] > j + 1:\n                    left[j + 1] = left[j] + a[i] - j - 1\n                    right[j + 1] = right[j] + 1\n                else:\n                    left[j + 1] = left[j]\n                    right[j + 1] = right[j]\n        return left, right\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    stack = top_view(a, m)\n    left, right = side_view(a, m)\n\n    max_blocks = 0\n    for i in range(m):\n        max_blocks = max(max_blocks, stack[i] - left[i] - right[i] + 1)\n\n    return max_blocks\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, m = map(int, input_str[0].split())\n    a = list(map(int, input_str[1].split()))\n\n    # Calculate the maximum number of blocks that can be removed\n    total_blocks = sum(a)\n    max_blocks = min(total_blocks, m)\n\n    return str(max_blocks)\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    max_blocks = 0\n\n    for i in range(n):\n        if a[i] > m:\n            a[i] = m\n        max_blocks += a[i]\n\n    max_blocks += m - sum(a)\n\n    return str(max_blocks)\n\n\nn = 5\nm = 6\na = [3, 3, 3, 3, 3]\nprint(solution(\"5 6\\n3 3 3 3 3\"))  # Output: 10\n\nn = 3\nm = 5\na = [1, 2, 4]\nprint(solution(\"3 5\\n1 2 4\"))  # Output: 3\n\nn = 5\nm = 5\na = [2, 3, 1, 4, 4]\nprint(solution(\"5 5\\n2 3 1 4 4\"))  # Output: 9\n\nn = 1\nm = 1000\na = [548]\nprint(solution(\"1 1000\\n548\"))  # Output: 0\n\nn = 3\nm = 3\na = [3, 1, 1]\nprint(solution(\"3 3\\n3 1 1\"))  # Output: 1 "
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Check if a block can be removed without changing the view for both cameras\n    def check_view(a):\n        # Check top view\n        top_view = [0] * m\n        for i in range(n):\n            for j in range(a[i]):\n                top_view[j] += 1\n        for i in range(m):\n            if top_view[i] > 1:\n                return False\n        \n        # Check side view\n        side_view = [0] * (n + 1)\n        for i in range(n):\n            side_view[a[i]] += 1\n        for i in range(1, n + 1):\n            if side_view[i] > 1:\n                return False\n        \n        return True\n    \n    # Remove blocks until the views change\n    removed = 0\n    while check_view(a):\n        a = [max(0, ai - 1) for ai in a]\n        removed += 1\n    \n    return removed\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    blocks = sum(a)\n    max_blocks = 0\n\n    for i in range(n):\n        if a[i] == m:\n            max_blocks += a[i]\n        else:\n            break\n\n    if max_blocks == blocks:\n        return str(max_blocks)\n\n    for i in range(1, m):\n        if sum(a[j] for j in range(n) if a[j] >= i) >= max_blocks:\n            max_blocks = i\n\n    return str(max_blocks)\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n\n    removed_blocks = 0\n    total_blocks = sum(a_list)\n    stack_height = [0] * n\n\n    for i in range(n):\n        stack_height[i] += a_list[i]\n\n    for i in range(m):\n        height = 0\n        for j in range(n):\n            height += stack_height[j]\n            if height <= i:\n                removed_blocks += a_list[j]\n                stack_height[j] = 0\n\n    return str(removed_blocks)\n\n\ndef"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    def top_view(stacks):\n        blocks = set()\n        for stack in stacks:\n            for i in range(stack):\n                blocks.add(i)\n        return blocks\n    \n    def side_view(stacks):\n        blocks = set()\n        for stack in stacks:\n            for i in range(stack, m):\n                blocks.add(i)\n        return blocks\n    \n    stacks = [a[i:i+m] for i in range(0, n, m)]\n    \n    top_blocks = top_view(stacks)\n    side_blocks = side_view(stacks)\n    \n    removed_top = 0\n    removed_side = 0\n    for i in range(m):\n        if i not in top_blocks:\n            removed_top += 1\n        if i not in side_blocks:\n            removed_side += 1\n    \n    return min(removed_top, removed_side)\n\n\ninput_cases = [\n    \"5 6\\n3 3 3 3 3\",\n    \"3 5\\n1 2 4\",\n    \"5 5\\n2 3 1 4 4\",\n    \"1 1000\\n548\"\n]\n\nfor input_case in input_cases:\n    output = solution(input_case)\n    print(output) "
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def top_view(stacks, removed_blocks):\n        max_blocks = 0\n        for stack in stacks:\n            stack_blocks = 0\n            for i in range(len(stack)):\n                if i not in removed_blocks[i]:\n                    stack_blocks += 1\n            max_blocks = max(max_blocks, stack_blocks)\n        return max_blocks\n\n    def side_view(stacks, removed_blocks):\n        max_blocks = 0\n        for stack in stacks:\n            stack_blocks = 0\n            for i in range(len(stack)):\n                if i not in removed_blocks[i]:\n                    stack_blocks += stack[i]\n            max_blocks = max(max_blocks, stack_blocks)\n        return max_blocks\n\n    def find_max_blocks(stacks, removed_blocks):\n        max_blocks = 0\n        for i in range(n):\n            for j in range(len(stacks[i])):\n                if j not in removed_blocks[i]:\n                    removed_blocks[i].add(j)\n                    top_view_blocks = top_view(stacks, removed_blocks)\n                    side_view_blocks = side_view(stacks, removed_blocks)\n                    if top_view_blocks + side_view_blocks > max_blocks:\n                        max_blocks = top_view_blocks + side_view_blocks\n                    removed_blocks[i].remove(j)\n        return max_blocks\n\n    removed_blocks = [set() for _ in range(n)]\n    max_blocks = find_max_blocks(a, removed_blocks)\n\n    return str(max_blocks)\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    if sum(a) == m:\n        return 0\n    \n    a.sort(reverse=True)\n    total_blocks = sum(a)\n    removed_blocks = 0\n    stacks_removed = 0\n    \n    while removed_blocks < total_blocks and stacks_removed < n:\n        removed_blocks += a[stacks_removed]\n        a[stacks_removed] = 0\n        stacks_removed += 1\n    \n    return removed_blocks\n"
    },
    {
        "number": 734,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_blocks = sum(a)\n    \n    # Top View\n    a.sort()\n    for i in range(n):\n        max_blocks -= a[i]\n        if max_blocks < i + 1:\n            break\n    \n    return str(max_blocks)\n"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    \n    # Check if the array is already sorted\n    if all(a[i] <= a[i+1] for i in range(n-1)):\n        return \"yes 1 1\"\n    \n    # Check if the array can be sorted by reversing one segment\n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            for j in range(i+1, n-1):\n                if a[j] < a[j+1]:\n                    return \"yes {} {}\".format(i+1, j)\n    \n    return \"no\""
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    if n < 2:\n        return \"no\"\n\n    a.sort()\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            start = i\n            break\n    else:\n        return \"no\"\n\n    for j in range(n - 1, start, -1):\n        if a[j] < a[j - 1]:\n            end = j\n            break\n    else:\n        return \"no\"\n\n    return \"yes\\n{} {}\".format(start + 1, end)\n"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Check if the array is already sorted\n    if all(a[i] <= a[i + 1] for i in range(n - 1)):\n        print(\"yes\")\n        print(1, 1)\n        return\n\n    # Check if it's possible to sort the array by reversing exactly one segment\n    for i in range(n - 2):\n        if a[i] > a[i + 1]:\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    print(\"yes\")\n                    print(i + 1, j)\n                    return\n    print(\"no\")\n"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            return \"no\"\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            for j in range(i + 1, n):\n                if a[j] < a[i]:\n                    return \"yes\\n\" + str(i + 1) + \" \" + str(j)\n\n    return \"no\"\n"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if the array is already sorted\n    if all(a[i] <= a[i+1] for i in range(n-1)):\n        return \"yes 1 1\"\n\n    # Check if it's possible to sort the array by reversing one segment\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] > a[j]:\n                continue\n            for k in range(i, j):\n                if a[k] == a[j]:\n                    continue\n                if a[k] > a[j]:\n                    reversed_a = a.copy()\n                    reversed_a[i:j+1] = reversed_a[j:i-1:-1]\n                    if all(reversed_a[l] <= reversed_a[l+1] for l in range(i, j)):\n                        return f\"yes {i+1} {j+1}\"\n            if a[j] > a[i]:\n                continue\n            for k in range(j, n):\n                if a[k] == a[i]:\n                    continue\n                if a[k] < a[i]:\n                    reversed_a = a.copy()\n                    reversed_a[i:j+1] = reversed_a[j:i-1:-1]\n                    if all(reversed_a[l] <= reversed_a[l+1] for l in range(i, j)):\n                        return f\"yes {i+1} {j+1}\"\n\n    return \"no\"\n\n\ndef"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    a.sort()\n\n    for i in range(1, n - 1):\n        if a[i - 1] > a[i] and a[i] < a[i + 1]:\n            return \"yes\" + \"\\n\" + str(i) + \" \" + str(i)\n\n    return \"no\"\n\n\ndef"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    def is_sorted(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True\n\n    def reverse_segment(arr, l, r):\n        while l < r:\n            arr[l], arr[r] = arr[r], arr[l]\n            l += 1\n            r -= 1\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            break\n    else:\n        return \"yes\"\n\n    for i in range(n - 1, 0, -1):\n        if a[i] < a[i - 1]:\n            break\n    else:\n        return \"yes\"\n\n    if is_sorted(a):\n        return \"no\"\n\n    for i in range(n - 2):\n        if a[i] > a[i + 1] and a[i + 2] > a[i + 1]:\n            return \"yes\"\n            break\n\n    for i in range(n - 2, 0, -1):\n        if a[i] < a[i - 1] and a[i - 2] < a[i - 1]:\n            return \"yes\"\n            break\n\n    return \"no\"\n\n\ndef"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def is_sorted(a):\n        return all(a[i] <= a[i + 1] for i in range(len(a) - 1))\n\n    def reverse_segment(a, start, end):\n        while start < end:\n            a[start], a[end] = a[end], a[start]\n            start += 1\n            end -= 1\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            start = i\n            break\n\n    for i in range(n - 1, 0, -1):\n        if a[i] < a[i - 1]:\n            end = i\n            break\n\n    if start <= end and not is_sorted(a[start:end + 1]):\n        reverse_segment(a, start, end)\n        return \"yes\\n\" + str(start + 1) + \" \" + str(end + 1)\n    else:\n        return \"no\"\n\n\ninput_str = '''3\n3 2 1\n4\n2 1 3 4\n4\n3 1 2 4\n2\n1 2'''\n\noutput_str = '''yes\n1 3\nyes\n1 2\nno\nyes\n1 1'''\n\ninput_list = input_str.split('\\n')\n\nfor i in range(0, len(input_list), 2):\n    result = solution(input_list[i])\n    if result != output_str[i // 2]:\n        print(\"Error: Expected \" + output_str[i // 2] + \", but got \" + result)\n    else:\n        print(\"Testcase \" + str(i // 2 + 1) + \" passed!\") "
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if the array can be sorted by reversing any segment\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                # Check if reversing this segment will sort the array\n                if a[i] < a[j - 1] and a[j] > a[i + 1]:\n                    # Reverse the segment and check if the array is sorted\n                    a[i + 1:j] = a[i + 1:j][::-1]\n                    if all(a[i] <= a[j] for i, j in zip(range(n), range(1, n + 1))):\n                        return \"yes\\n\" + str(i + 1) + \" \" + str(j)\n\n    # If no segment can be reversed to sort the array, return \"no\"\n    return \"no\"\n"
    },
    {
        "number": 735,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if the array is already sorted\n    if sorted(a) == a:\n        return \"yes\"\n\n    # Loop through all possible segments\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if reversing this segment would sort the array\n            if sorted(a[:i] + a[j:]) == a:\n                return \"yes\\n\" + str(i + 1) + \" \" + str(j)\n\n    return \"no\""
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, m = input_data[0], input_data[1]\n    \n    if n % m != 0:\n        return -1\n    \n    steps = 0\n    while steps < n:\n        if (steps + 1) % m == 0:\n            return steps + 1\n        steps += 2\n        \n    return -1\n"
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    if n % m == 0:\n        return n // m\n    elif n % (m - 1) == 0:\n        return n // (m - 1)\n    else:\n        return -1\n\n\ninput_str = input(\"Enter n and m separated by space: \")\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m != 0:\n        return -1\n    return n // m\n\ndef"
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    steps = [1, 2]\n    min_steps = float('inf')\n\n    for step in steps:\n        current_steps = 0\n        while current_steps < n:\n            current_steps += step\n            if current_steps % m == 0:\n                min_steps = min(min_steps, current_steps // m)\n                break\n\n    return str(min_steps) if min_steps != float('inf') else '-1'\n"
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_moves = 0\n    while n > 0:\n        if n % m == 0:\n            return total_moves + n\n        if n >= 2:\n            n -= 2\n        else:\n            n -= 1\n        total_moves += 1\n    return -1\n\n\nn, m = map(int, input().split())\nprint(solution(f\"{n} {m}\")) "
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    moves = 0\n    while n > 0:\n        if n >= m:\n            n -= m\n            moves += m\n        elif n >= 2:\n            n -= 2\n            moves += 2\n        elif n >= 1:\n            n -= 1\n            moves += 1\n        else:\n            return -1\n    return moves"
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m > n:\n        return -1\n    elif m == 1:\n        return n\n    else:\n        total_moves = 0\n        while n % m != 0:\n            if total_moves + 1 > n:\n                return -1\n            n -= 1\n            total_moves += 1\n        return total_moves\n"
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n = int(input_data[0])\n    m = int(input_data[1])\n\n    # Case 1: n is a multiple of m\n    if n % m == 0:\n        return n // m\n\n    # Case 2: n is a multiple of 2m\n    if n % (2 * m) == 0:\n        return n // (2 * m)\n\n    # Case 3: n is a multiple of 3m\n    if n % (3 * m) == 0:\n        return n // (3 * m)\n\n    # Case 4: n is a multiple of 4m\n    if n % (4 * m) == 0:\n        return n // (4 * m)\n\n    # Case 5: n is a multiple of 5m\n    if n % (5 * m) == 0:\n        return n // (5 * m)\n\n    # Case 6: n is a multiple of 6m\n    if n % (6 * m) == 0:\n        return n // (6 * m)\n\n    # Case 7: n is a multiple of 7m\n    if n % (7 * m) == 0:\n        return n // (7 * m)\n\n    # Case 8: n is a multiple of 8m\n    if n % (8 * m) == 0:\n        return n // (8 * m)\n\n    # Case 9: n is a multiple of 9m\n    if n % (9 * m) == 0:\n        return n // (9 * m)\n\n    # Case 10: n is a multiple of 10m\n    if n % (10 * m) == 0:\n        return n // (10 * m)\n\n    # Case 11: n is not a multiple of any integer between 1 and 10m\n    return -1\n\n\nstdin = \"10 2\"\nprint(solution(stdin)) "
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m == 0:\n        return str(n // m)\n    else:\n        return str(-1)\n\ninput_str = \"10 2\\n3 5\"\noutput_str = \"\"\nfor line in input_str.split(\"\\n\"):\n    output_str += solution(line) + \"\\n\"\n\nprint(output_str) "
    },
    {
        "number": 736,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, m = input_values[0], input_values[1]\n\n    if n % m == 0:\n        return str(n // m)\n\n    if n < m:\n        return str(-1)\n\n    if m == 1:\n        return str(n)\n\n    moves = n // m\n    remain = n % m\n    if remain > 0:\n        moves += 1\n\n    return str(moves)\n\n\ndef"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    perimeter = 2 * n + 2 * n - 4\n    return str(perimeter)\n\n\ninput_str = \"\"\"4\n11\n22\"\"\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n = int(input_data[0])\n\n    if n == 1:\n        return 4\n    elif n == 2:\n        return 12\n    elif n == 3:\n        return 16\n    elif n == 4:\n        return 20\n    elif n == 5:\n        return 24\n    elif n == 6:\n        return 28\n    elif n == 7:\n        return 32\n    elif n == 8:\n        return 36\n    elif n == 9:\n        return 40\n    elif n == 10:\n        return 44\n    else:\n        perimeter = 2 * n\n        return perimeter\n\n\ninput_data = \"4\\n11\\n22\\n33\\n44\\n55\\n66\\n77\\n88\\n99\\n100\"\n\nfor line in input_data.split('\\n'):\n    if line:\n        print(solution(line))"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    \n    if N == 1:\n        return \"0\"\n    elif N == 2:\n        return \"4\"\n    else:\n        return 2 * (N - 1)\n    \n"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    if N == 2:\n        return \"4\"\n    if N == 3:\n        return \"6\"\n    if N == 4:\n        return \"8\"\n    if N == 5:\n        return \"10\"\n    if N == 6:\n        return \"13\"\n    if N == 7:\n        return \"15\"\n    if N == 8:\n        return \"16\"\n    if N == 9:\n        return \"17\"\n    if N == 10:\n        return \"19\"\n    \n    # General case\n    return \"4 * sqrt(2 * N)\""
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    # Case 1: The perimeter is simply the length of the N blocks\n    if N == 1:\n        return \"1\"\n    # Case 2: The perimeter is 4 times the length of the N/4 blocks, rounded up\n    if N % 4 == 0:\n        return str(N + 1)\n    # Case 3: The perimeter is 4 times the length of the N/4 blocks, rounded down\n    return str(N - (N % 4))\n"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    # Calculate the minimum perimeter based on the shape of the area\n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"4\"\n    elif N == 3:\n        return \"8\"\n    elif N == 4:\n        return \"11\"\n    else:\n        perimeter = 2 * (N + 1)\n        if N % 2 == 0:\n            perimeter -= 2\n        return str(perimeter)"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N <= 2:\n        return str(4 * N)\n    else:\n        return str(2 * (N + 1))\n\ndef"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n\n    # check if N is a perfect square\n    if N == 1:\n        return 4\n    sqrt_N = int(N ** 0.5)\n    if sqrt_N * sqrt_N == N:\n        # if perfect square, return length of its perimeter\n        return 4 * sqrt_N\n    else:\n        # if not perfect square, find the minimum length of perimeter\n        for i in range(1, N + 1):\n            perimeter = 4 * (i + 1)\n            if perimeter == N:\n                return perimeter\n            elif perimeter > N:\n                return 4 * (i - 1)\n\n        # if the loop ends, return the perimeter of the largest square with area less than N\n        return 4 * (sqrt_N - 1)\n"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n\n    if N % 2 == 0:\n        return 2 * N\n    else:\n        return 2 * N - 2\n"
    },
    {
        "number": 737,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    return 4 * N  # The minimum perimeter is N * 4"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, input().split())\n    count = 0\n    \n    for x in range(A, B + 1):\n        for y in range(B, C + 1):\n            for z in range(C, D + 1):\n                if x < y and y < z:\n                    count += 1\n                    \n    return str(count)"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n    for x in range(A, B+1):\n        for y in range(max(A, x), min(C, D, B-x)+1):\n            z = D - x - y\n            if z > 0 and z <= C and z >= y:\n                count += 1\n    return count"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n    \n    for x in range(A, B+1):\n        for y in range(x, C+1):\n            for z in range(y, D+1):\n                if x != y and x != z and y != z:\n                    count += 1\n                    \n    return str(count)\n"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n\n    count = 0\n\n    for x in range(A, B + 1):\n        for y in range(x, C + 1):\n            for z in range(y, D + 1):\n                if (x != y) and (y != z) and (x + y > z) and (y + z > x) and (z + x > y):\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n\n    # Calculate the number of non-degenerate triangles\n    count = 0\n    for x in range(A, B + 1):\n        for y in range(max(x, A), C + 1):\n            for z in range(max(y, A), D + 1):\n                if x + y > z and x + z > y and y + z > x:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, input().split())\n    count = 0\n    \n    for x in range(A, B + 1):\n        for y in range(x, C + 1):\n            for z in range(y, D + 1):\n                if x + y > z and x + z > y and y + z > x:\n                    count += 1\n    \n    return str(count)\n\n\ninput_string = \"\"\"500000 500000 500000 500000\n\"\"\"\n\nresult = solution(input_string)\nprint(result) "
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n\n    count = 0\n\n    for x in range(A, B + 1):\n        for y in range(x, C + 1):\n            z = D - x - y\n            if z > 0:\n                count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_triangles(a: int, b: int, c: int, d: int) -> int:\n        return sum(1 for x in range(a, b + 1) for y in range(x, c + 1) for z in range(y, d + 1) if (x * x + y * y == z * z) or (x * x + z * z == y * y) or (y * y + z * z == x * x))\n\n    A, B, C, D = map(int, stdin.split())\n    result = count_triangles(A, B, C, D)\n    return str(result)\n"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    \n    count = 0\n    \n    for x in range(A, B+1):\n        for y in range(x, C+1):\n            z = D - x - y\n            if z >= y:\n                count += 1\n    \n    return str(count)\n\ndef"
    },
    {
        "number": 738,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n    for x in range(A, B + 1):\n        for y in range(x, C + 1):\n            for z in range(y, D + 1):\n                if x != y and y != z and z != x:\n                    count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    terms = [A + B * i for i in range(L)]\n    concatenated_integer = int(\"\".join(map(str, terms)))\n    return concatenated_integer % M"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    s = [A + B * i for i in range(L)]\n    concat_number = int(\"\".join(str(x) for x in s))\n    return concat_number % M"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Q, L, A, B, M = map(int, stdin.split())\n    \n    # Generate the arithmetic progression\n    s = [A + B * i for i in range(L)]\n    \n    # Concatenate the terms without leading zeros\n    concat_s = ''.join(str(x) for x in s)\n    \n    # Compute the remainder when dividing the concatenated sequence by M\n    remainder = int(concat_s) % M\n    \n    return str(remainder)"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    Q, *data = stdin.split()\n    Q = int(Q)\n\n    remainders = []\n    for i in range(Q):\n        L, A, B, M = map(int, data[i * 4: (i + 1) * 4])\n        terms = [str(A + B * i) for i in range(L)]\n        concatenated = \"\".join(terms)\n        remainder = int(concatenated) % M\n        remainders.append(remainder)\n\n    return \"\\n\".join(map(str, remainders))\n"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Q, L, A, B, M = map(int, stdin.split())\n    s = [A + B * i for i in range(L)]\n    num = int(\"\".join(map(str, s)))\n    return num % M\n\nstdin = \"5 3 4 10007\"\nprint(solution(stdin)) "
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    terms = [str(A + B * i) for i in range(L)]\n    concatenated = int(\"\".join(terms))\n    return str(concatenated % M)\n"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    \n    # Generate the arithmetic progression\n    progression = [A + B * i for i in range(L)]\n    \n    # Concatenate the terms without leading zeros\n    concatenated = ''.join(str(term) for term in progression)\n    \n    # Calculate the remainder when dividing the concatenated integer by M\n    remainder = int(concatenated) % M\n    \n    return str(remainder)"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    \n    # calculate the last term of the arithmetic progression\n    last_term = A + (B * (L-1))\n    \n    # convert the last term to string without leading zeros\n    last_term_str = str(last_term)\n    \n    # concatenate the terms\n    concat_str = ''.join(map(str, range(A, last_term+1, B)))\n    \n    # calculate the remainder\n    remainder = int(concat_str) % M\n    \n    return str(remainder)"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split()\n    L, A, B, M = map(int, input_list)\n\n    terms = [A + B * i for i in range(L)]\n    concatenated_integer = int(''.join(map(str, terms)))\n    remainder = concatenated_integer % M\n\n    return str(remainder)\n\ndef"
    },
    {
        "number": 739,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    Q, L, A, B, M = map(int, stdin.split())\n\n    terms = [A + B * i for i in range(L)]\n    concatenated_term = int(\"\".join(map(str, terms)))\n\n    return concatenated_term % M\n\n\ndef"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n    washing_time = t_1 + t_2 + t_3 * (n_2 + n_3)\n    return washing_time + (t_2 + t_3) * k"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    washing_time = t_1\n    drying_time = t_2\n    folding_time = t_3\n\n    total_time = 0\n\n    for _ in range(k):\n        total_time += washing_time\n        total_time += drying_time\n\n        if n_1 > 0 and n_2 > 0:\n            total_time += drying_time\n            n_1 -= 1\n            n_2 -= 1\n        else:\n            total_time += drying_time\n            n_1 -= 1\n\n        total_time += folding_time\n\n        if n_3 > 0:\n            n_3 -= 1\n        else:\n            total_time += drying_time\n            n_2 -= 1\n\n    return total_time\n\n\ninput_string = \"8 4 3 2 10 5 2\"\nprint(solution(input_string)) "
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    # calculate the maximum number of laundries each machine can handle\n    max_washing = n_1 * t_1\n    max_drying = n_2 * t_2\n    max_folding = n_3 * t_3\n\n    # calculate the number of laundries to be processed\n    laundries_to_wash = min(max_washing, k)\n    laundries_to_dry = min(max_drying, k - laundries_to_wash)\n    laundries_to_fold = k - laundries_to_wash - laundries_to_dry\n\n    # calculate the total time to process all laundries\n    total_time = laundries_to_wash * t_1 + laundries_to_dry * t_2 + laundries_to_fold * t_3\n\n    return str(total_time)"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    def washing(pieces):\n        return min(n_1 * t_1, pieces)\n\n    def drying(pieces):\n        return min(n_2 * t_2, pieces)\n\n    def folding(pieces):\n        return min(n_3 * t_3, pieces)\n\n    def process_pieces(pieces, t_1, t_2, t_3):\n        time = 0\n        while pieces > 0:\n            time += washing(pieces)\n            pieces -= n_1\n            if pieces > 0:\n                time += drying(pieces)\n                pieces -= n_2\n            if pieces > 0:\n                time += folding(pieces)\n                pieces -= n_3\n        return time\n\n    total_time = process_pieces(k, t_1, t_2, t_3)\n    return str(total_time)\n"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, input().split())\n\n    time_wash = k * t_1\n    time_dry = (k - 1) * t_2 + t_2  # add time to dry the last piece\n    time_fold = (k - 1) * t_3 + t_3  # add time to fold the last piece\n\n    total_time = max(time_wash, time_dry, time_fold)\n\n    return str(total_time)\n\n\ninput_str = \"8 4 3 2 10 5 2\"\nprint(solution(input_str)) "
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    # Compute the maximum number of laundries that can be processed at each step\n    max_wash = min(n_1, k)\n    k -= max_wash\n    max_dry = min(n_2, k)\n    k -= max_dry\n    max_fold = min(n_3, k)\n\n    # Compute the total time spent in each step\n    time_wash = max_wash * t_1\n    time_dry = max_dry * t_2\n    time_fold = max_fold * t_3\n\n    # Compute the total time spent processing all laundries\n    total_time = time_wash + time_dry + time_fold\n\n    return str(total_time)\n"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    # Initialize the waiting times for each machine\n    waiting_1 = 0\n    waiting_2 = 0\n    waiting_3 = 0\n\n    # Initialize the current time\n    current_time = 0\n\n    # Process each piece of laundry\n    for i in range(k):\n        # Wash the piece\n        washing_time = t_1\n        waiting_1 += washing_time\n\n        # Find the earliest available drying machine\n        drying_time = float('inf')\n        for j in range(current_time, current_time + washing_time + t_1):\n            if waiting_2 <= j - current_time:\n                drying_time = min(drying_time, j + t_2)\n\n        # Move the piece to the drying machine\n        waiting_2 = drying_time - j\n\n        # Find the earliest available folding machine\n        folding_time = float('inf')\n        for j in range(current_time, current_time + drying_time - current_time + t_2):\n            if waiting_3 <= j - current_time:\n                folding_time = min(folding_time, j + t_3)\n\n        # Move the piece to the folding machine\n        waiting_3 = folding_time - j\n\n        # Update the current time\n        current_time = folding_time\n\n    # Calculate the total time\n    total_time = waiting_1 + waiting_2 + waiting_3\n\n    return str(total_time)\n"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n\n    # calculate the maximum number of laundries that can be processed in each machine\n    max_wash = n_1 * t_1\n    max_dry = n_2 * t_2\n    max_fold = n_3 * t_3\n\n    # calculate the number of minutes required to process each laundry\n    minutes_wash = [t_1] * k\n    minutes_dry = [t_2] * k\n    minutes_fold = [t_3] * k\n\n    # sort the laundries based on the time required to process them\n    minutes_wash.sort()\n    minutes_dry.sort()\n    minutes_fold.sort()\n\n    # calculate the total number of minutes required\n    total_minutes = 0\n    wash_count = dry_count = fold_count = 0\n\n    for i in range(k):\n        total_minutes += minutes_wash[i]\n        wash_count += 1\n\n        if wash_count <= max_wash:\n            total_minutes += minutes_dry[i]\n            dry_count += 1\n\n            if dry_count <= max_dry:\n                total_minutes += minutes_fold[i]\n                fold_count += 1\n\n                if fold_count <= max_fold:\n                    continue\n\n        # reset the counters if there are no more available machines\n        wash_count = dry_count = fold_count = 0\n\n    return total_minutes\n"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n    \n    # Sort the time for each machine\n    t = [t_1, t_2, t_3]\n    t.sort()\n    \n    # Initialize the start time for each machine\n    start_time = [0] * 3\n    start_time[0] = t[0] * n_1\n    start_time[1] = t[0] * n_2 + t[1] * n_1\n    start_time[2] = t[0] * n_3 + t[1] * n_2 + t[2] * n_1\n    \n    # Initialize the end time for each machine\n    end_time = [0] * 3\n    end_time[0] = t[0] * n_1\n    end_time[1] = t[0] * n_2 + t[1] * n_1\n    end_time[2] = t[0] * n_3 + t[1] * n_2 + t[2] * n_1\n    \n    # Find the end time for the last piece of laundry\n    for i in range(k):\n        start_time[0] += t[0]\n        start_time[1] += t[0]\n        start_time[2] += t[0]\n        end_time[0] += t[1]\n        end_time[1] += t[1]\n        end_time[2] += t[1]\n        end_time[0] += t[2]\n        end_time[1] += t[2]\n        end_time[2] += t[2]\n    \n    # Calculate the minimum time for all the laundry\n    min_time = min(end_time)\n    \n    return str(min_time)"
    },
    {
        "number": 740,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, input().split())\n    min_time = float('inf')\n\n    for i in range(k):\n        washing_time = t_1\n        drying_time = float('inf')\n        folding_time = float('inf')\n\n        while drying_time == float('inf') or folding_time == float('inf'):\n            if n_1 > 0 and washing_time == t_1:\n                washing_time += t_1\n                n_1 -= 1\n            elif n_2 > 0 and drying_time == t_2:\n                drying_time = washing_time + t_2\n                n_2 -= 1\n            elif n_3 > 0 and folding_time == t_3:\n                folding_time = drying_time + t_3\n                n_3 -= 1\n\n        min_time = min(min_time, washing_time + drying_time + folding_time)\n\n    return str(min_time)\n\n\ninput_data = \"1 1 1 1 5 5 5\"\nprint(solution(input_data)) "
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_lit_time(a, M, n):\n        a = sorted(a)\n        if n == 1:\n            if a[0] < M:\n                return M - a[0]\n            else:\n                return 0\n        else:\n            if a[0] < M:\n                return find_max_lit_time(a[1:], M, n - 1) + M - a[0]\n            else:\n                return find_max_lit_time(a[1:], M, n - 1)\n\n    def insert_element(a, x, M, n):\n        a = sorted(a)\n        if n == 1:\n            a = [x] + a\n        else:\n            for i in range(1, n):\n                if x <= a[i]:\n                    a = a[:i] + [x] + a[i:]\n                    break\n            else:\n                a += [x]\n        return a\n\n    def max_lit_time(a, M, n):\n        return find_max_lit_time(a, M, n)\n\n    def max_lit_time_with_insert(a, x, M, n):\n        return find_max_lit_time(insert_element(a, x, M, n), M, n + 1)\n\n    lines = stdin.split('\\n')\n    n, M = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n\n    max_lit_time_without_insert = max_lit_time(a, M, n)\n    max_lit_time_with_insert = max_lit_time_without_insert\n\n    for i in range(1, M + 1):\n        new_a = insert_element(a, i, M, n)\n        new_max_lit_time_with_insert = max_lit_time_with_insert(new_a, i, M, n + 1)\n        if new_max_lit_time_with_insert > max_lit_time_with_insert:\n            max_lit_time_with_insert = new_max_lit_time_with_insert\n\n    return str(max_lit_time_with_insert)\n\ninput_data = '''3 10\n4 6 7\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Calculate total time when the lamp is lit\n    total_time = sum(a[i+1] - a[i] for i in range(n-1)) + (M - a[-1])\n    \n    # Find maximum possible total time when the lamp is lit\n    max_total_time = 0\n    for i in range(n-1):\n        # Insert value before the current value\n        new_a = a.copy()\n        new_a.insert(i, a[i-1] + 1)\n        new_total_time = sum(new_a[j+1] - new_a[j] for j in range(n)) + (M - new_a[-1])\n        max_total_time = max(max_total_time, new_total_time)\n        \n        # Insert value after the current value\n        new_a = a.copy()\n        new_a.insert(i+1, a[i] + 1)\n        new_total_time = sum(new_a[j+1] - new_a[j] for j in range(n)) + (M - new_a[-1])\n        max_total_time = max(max_total_time, new_total_time)\n        \n        # Insert value at the beginning\n        new_a = a.copy()\n        new_a.insert(0, a[0] - 1)\n        new_total_time = sum(new_a[j+1] - new_a[j] for j in range(n)) + (M - new_a[-1])\n        max_total_time = max(max_total_time, new_total_time)\n        \n        # Insert value at the end\n        new_a = a.copy()\n        new_a.append(M - 1)\n        new_total_time = sum(new_a[j+1] - new_a[j] for j in range(n)) + (M - new_a[-1])\n        max_total_time = max(max_total_time, new_total_time)\n        \n    return str(max_total_time)"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    if n == 1:\n        if a[0] == 1:\n            return M - 1\n        return M - 1 - a[0]\n\n    # sort a in ascending order\n    a.sort()\n\n    # initialize variables\n    result = 0\n    last_powered = 0\n    last_switched = 0\n\n    # iterate over a\n    for i, x in enumerate(a):\n        # calculate the time the lamp is lit\n        if x > last_switched:\n            result += x - last_switched\n\n        # calculate the time the lamp is powered\n        result += x - last_powered\n\n        # update the last powered and switched\n        last_powered = x\n        last_switched = x\n\n        # add the time the lamp is off\n        result += M - x\n\n        # if the current element is the last element, add the time the lamp is off after it\n        if i == len(a) - 1:\n            result += M - x\n\n    # return the result\n    return result\n"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    total_time = 0\n    time_when_lit = 0\n    pre_lit_time = 0\n    pre_lit = False\n\n    # Iterate through program\n    for i in range(n):\n        a_i = a[i]\n\n        # Calculate time when the lamp is lit\n        if pre_lit:\n            time_when_lit += a_i - pre_lit_time\n        else:\n            time_when_lit += a_i\n\n        # Update variables\n        pre_lit = True\n        pre_lit_time = a_i\n\n    # Calculate time when the lamp is lit after last element\n    if pre_lit:\n        time_when_lit += M - pre_lit_time\n    else:\n        time_when_lit += M\n\n    # Calculate total time when the lamp is lit\n    total_time = time_when_lit - M\n\n    return total_time"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, M = map(int, inputs[0].split())\n    a = list(map(int, inputs[1].split()))\n    \n    # check if a is a good program\n    if len(a) != n or any(a[i] >= a[i+1] for i in range(len(a)-1)) or any(a[i] >= M for i in range(len(a))):\n        return \"0\"\n    \n    # find the maximum possible total time when the lamp is lit\n    max_time = sum([M - a[i] for i in range(n)])\n    \n    # find the optimal solution to insert a value\n    for i in range(1, n):\n        if a[i] - a[i-1] < M - a[i]:\n            insert_time = a[i] - a[i-1] + (M - a[i])\n            max_time = max(max_time, insert_time)\n    \n    return str(max_time)"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, M = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    if len(a) < 2:\n        return 0\n\n    if a[0] == 0:\n        a[0] = 1\n\n    if a[len(a) - 1] == M:\n        a[len(a) - 1] = M - 1\n\n    a.sort()\n\n    time_lit = 0\n\n    for i in range(len(a)):\n        if i == 0:\n            time_lit += a[i] - 1\n        elif i == len(a) - 1:\n            time_lit += M - a[i]\n        else:\n            time_lit += a[i] - a[i - 1] - 1\n\n    return time_lit\n"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, M = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Initialize variables\n    opt = 0  # Optimal time\n    left, right = 0, n - 1  # Indices for insertion\n    \n    # Loop through all possible insertions\n    while left < right:\n        # Calculate the time with the current insertion\n        a_new = a[:left] + [M + 1] + a[left:]\n        time = 0\n        for i in range(n + 1):\n            if i == n:\n                time += M - a_new[i-1]\n            else:\n                time += a_new[i] - a_new[i-1]\n        \n        # Update the optimal time\n        opt = max(opt, time)\n        \n        # Move to the next possible insertion\n        left += 1\n        right -= 1\n    \n    return str(opt)"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Check if the program is good\n    if len(a) != n or any(a[i] >= a[i + 1] for i in range(n - 1)) or any(a[i] < 0 or a[i] >= M for i in range(n)):\n        return \"0\"\n\n    # Find the maximum possible total time when the lamp is lit\n    time_lit = 0\n    for i in range(n):\n        time_lit += a[i] - a[i - 1] if i > 0 else a[i]\n    time_lit += M - a[n - 1]\n\n    return str(time_lit)\n"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, M = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    \n    # Find the maximum possible total time when the lamp is lit\n    max_time = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # Insert x between a[i] and a[j]\n            x = (a[i] + a[j]) // 2\n            # Check if x is within the range and the program is still a good program\n            if x < a[i] or x > a[j] or x in a:\n                continue\n            # Calculate the time when the lamp is lit\n            time = (a[i] - 0) + (x - a[i]) + (a[j] - x)\n            # Update the maximum time if the new time is greater\n            max_time = max(max_time, time)\n            \n    return str(max_time)\n"
    },
    {
        "number": 741,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, M = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    # Check if the input program is good\n    if not (1 <= n <= 10**5 and 2 <= M <= 10**9):\n        return \"Input values are not in the required range.\"\n    if not all(1 <= a_i <= M for a_i in a):\n        return \"Input values are not in the required range.\"\n    if len(a) != n or len(set(a)) != len(a):\n        return \"Input program is not a good program.\"\n\n    # Find the maximum time when the lamp is lit\n    max_time = 0\n    for i in range(n - 1):\n        max_time += a[i + 1] - a[i]\n    max_time += M - a[-1]\n\n    return str(max_time)"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_minimum_permutation(b: List[int]) -> List[int]:\n        n = len(b)\n        a = list(range(1, 2 * n + 1))\n        for i in range(n):\n            for j in range(2 * n):\n                if j % 2 == 0 and a[j] == b[i]:\n                    a[j], a[j + 1] = a[j + 1], a[j]\n                if j % 2 == 1 and a[j] == b[i]:\n                    a[j], a[j - 1] = a[j - 1], a[j]\n        return a\n\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        b = list(map(int, stdin.readline().split()))\n        a = find_minimum_permutation(b)\n        if a[0] == 1 and a[-1] == 2 * n:\n            result = \" \".join(map(str, a))\n        else:\n            result = \"-1\"\n        print(result)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n = int(input())\n        b = list(map(int, input().split()))\n        if not (1 <= n <= 100) or not (1 <= b[0] <= 100):\n            output.append(\"-1\")\n            continue\n        b.sort()\n        a = [i for i in range(1, 2 * n + 1)]\n        for i in range(n):\n            if b[i] != a[2 * i] and b[i] != a[2 * i + 1]:\n                output.append(\"-1\")\n                break\n        else:\n            for i in range(n):\n                if a[2 * i] > b[i]:\n                    a[2 * i], a[2 * i + 1] = a[2 * i + 1], a[2 * i]\n                elif a[2 * i] < b[i]:\n                    a[2 * i + 1] = a[2 * i]\n            output.append(\" \".join(map(str, a)))\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for i in range(t):\n        n = int(stdin.split()[0])\n        b = sorted(list(map(int, stdin.split()[1:])))\n        a = [0] * (2 * n)\n        for j in range(n):\n            if b[j] <= j + 1:\n                a[b[j] - 1] = j + 1\n            else:\n                break\n        if j == n - 1:\n            output.append(\" \".join(map(str, a)))\n        else:\n            output.append(\"-1\")\n        stdin = input()\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    t = int(input_data[0])\n    output = []\n    for i in range(1, t+1):\n        n = int(input_data[i][0])\n        b = list(map(int, input_data[i][1:n+1]))\n        a = sorted(b)\n        flag = False\n        for j in range(1, n):\n            if a[j] < a[j-1]:\n                flag = True\n                break\n        if flag:\n            output.append(\"-1\")\n        else:\n            a = a + [x+n for x in a]\n            output.append(\" \".join(map(str, a)))\n    return \"\\n\".join(output)\n\n\ninput_data = '''5\n1\n1\n2\n4 1\n3\n4 1 3\n4\n2 3 4 5\n5\n1 5 7 2 8'''\n\nprint(solution(input_data))\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_minimal_permutation(b: list):\n        def backtrack(path: list, used: list, n: int):\n            if len(path) == 2*n:\n                return True\n            for i in range(n):\n                if not used[i]:\n                    if len(path) % 2 == 0 or b[i] >= b[path[-1]-1]:\n                        path.append(2*i + 1)\n                        used[i] = True\n                        if backtrack(path, used, n):\n                            return True\n                        path.pop()\n                        used[i] = False\n            return False\n\n        used = [False] * n\n        path = [1]\n        if not backtrack(path, used, n):\n            return False\n        return path\n\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        b = list(map(int, stdin.split()[2:2 * n + 2]))\n        permutation = find_minimal_permutation(b)\n        if permutation:\n            print(*permutation)\n        else:\n            print(-1)\n        stdin = input()"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    \n    for i in range(t):\n        n = int(stdin.readline())\n        b = list(map(int, stdin.readline().split()))\n        \n        a = [0] * (2 * n)\n        for j in range(n):\n            a[2 * j], a[2 * j + 1] = sorted(b[j], b[j])\n        \n        for j in range(2 * n):\n            if a[j] == b[j % n]:\n                continue\n            if a[j] > b[j % n]:\n                if b[j % n] == b[j % n - 1]:\n                    continue\n                a[j], a[j - 1] = a[j - 1], a[j]\n                break\n            else:\n                break\n        \n        if a == [0] * (2 * n):\n            print(-1)\n        else:\n            print(\" \".join(map(str, a)))\n    \n    return \"\\n\"\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n = int(stdin.split()[0])\n        b = list(map(int, stdin.split()[1:]))\n        a = sorted(range(1, 2 * n + 1), key=lambda x: (b[x - 1] != x, b[x - 1]))\n        if b == [b[x - 1] for x in a]:\n            output.append(\" \".join(map(str, a)))\n        else:\n            output.append(\"-1\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    t = int(input_list[0])\n    output_list = []\n\n    for i in range(1, t * 2 + 1, 2):\n        n = int(input_list[i])\n        b = list(map(int, input_list[i + 1].split()))\n        a = []\n        for j in range(n):\n            min_value = min(b[j * 2], b[j * 2 + 1])\n            a.append(min_value)\n            a.append(b[j * 2 + 1] if min_value == b[j * 2] else b[j * 2])\n        if len(set(a)) == n * 2:\n            output_list.append(str(a).replace(',', ''))\n        else:\n            output_list.append('-1')\n\n    return '\\n'.join(output_list)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    output = []\n    for i in range(1, t+1):\n        n = int(stdin.splitlines()[i].split()[0])\n        b = [int(x) for x in stdin.splitlines()[i].split()[1:]]\n        a = [0] * (2*n)\n        a_used = [False] * (2*n)\n        b_used = [False] * n\n        for j in range(n):\n            min_idx = -1\n            min_val = float('inf')\n            for k in range(2*n):\n                if not a_used[k] and b_used[k//2]:\n                    val = min(b[k//2], k+1)\n                    if val < min_val:\n                        min_idx = k\n                        min_val = val\n            if min_idx == -1:\n                output.append(-1)\n                break\n            a[min_idx] = b[j]\n            a_used[min_idx] = True\n            b_used[j] = True\n        else:\n            output.append(\" \".join(map(str, a)))\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 742,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(input())\n    for case in range(t):\n        n = int(input())\n        b = list(map(int, input().split()))\n        a = []\n        for i in range(n):\n            for j in range(n):\n                if b[i] == j + 1:\n                    a.append(j + 1)\n                    b[i] = 0\n                    break\n        if -1 in a:\n            print(-1)\n        else:\n            print(\" \".join(map(str, a + list(range(n, 2*n)))))\n"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    numbers = list(map(int, input().split()))\n\n    numbers.sort()\n    total_sum = sum(numbers)\n\n    for i in range(n - 1):\n        total_sum -= numbers[i]\n        total_sum += numbers[i + 1]\n\n    return total_sum\n\n\ndef"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if numbers[i] > numbers[j]:\n                numbers[i] -= numbers[j]\n                numbers[j] = 0\n                break\n\n    return sum(filter(lambda x: x != 0, numbers)) "
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def compute_min_sum(n: int, numbers: list) -> int:\n        numbers.sort()\n        total_sum = sum(numbers)\n        min_sum = total_sum\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if numbers[i] > numbers[j]:\n                    min_sum = min(min_sum, compute_min_sum(n - 2, numbers[:i] + numbers[i + 1:j] + numbers[j + 1:] + numbers[i]))\n                    min_sum = min(min_sum, compute_min_sum(n - 2, numbers[:i] + numbers[j + 1:j + 1] + numbers[i + 1:j] + numbers[j + 2:]))\n        return min_sum\n\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    min_sum = compute_min_sum(n, numbers)\n    return str(min_sum)\n"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_valid(i, j):\n        return i != j and numbers[i] > numbers[j]\n\n    def assign(i, j):\n        numbers[i] -= numbers[j]\n\n    def find_minimal_sum():\n        min_sum = sum(numbers)\n        for i in range(n):\n            for j in range(n):\n                if is_valid(i, j):\n                    assign(i, j)\n                    min_sum = min(min_sum, find_minimal_sum())\n                    assign(j, i)\n        return min_sum\n\n    return str(find_minimal_sum())\n\ninput_string = \"\"\"2\n1 2\"\"\"\n\nprint(solution(input_string)) # Output: 2 "
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    def min_sum(numbers):\n        numbers.sort()\n        min_sum = sum(numbers)\n        for i in range(1, n):\n            for j in range(i):\n                min_sum = min(min_sum, numbers[i] + numbers[j])\n        return min_sum\n    \n    return str(min_sum(numbers))\n"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n    x.sort()\n    min_sum = sum(x)\n    for i in range(n):\n        for j in range(i+1, n):\n            if x[i] > x[j]:\n                min_sum = min(min_sum, x[i] + x[j])\n    return str(min_sum)\n"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n    \n    def find_min_sum(numbers: list) -> int:\n        min_sum = sum(numbers)\n        for i in range(n):\n            for j in range(i+1, n):\n                if numbers[i] > numbers[j]:\n                    numbers[i] -= numbers[j]\n                    min_sum -= numbers[j]\n                    break\n        return min_sum\n    \n    min_sum = find_min_sum(numbers)\n    \n    return str(min_sum)\n"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Sort the numbers in descending order\n    numbers.sort(reverse=True)\n    \n    # Initialize the sum to the first number\n    sum_of_numbers = numbers[0]\n    \n    # Loop through the numbers, subtracting the smaller number from the larger number\n    for i in range(n - 1):\n        sum_of_numbers += numbers[i] - numbers[i + 1]\n    \n    return str(sum_of_numbers)"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = [int(x) for x in stdin.splitlines()[1].split()]\n\n    # Find the optimal sum\n    min_sum = sum(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if numbers[i] > numbers[j]:\n                numbers[i] -= numbers[j]\n                min_sum -= numbers[j]\n                break\n\n    return str(min_sum)\n\n\ndef"
    },
    {
        "number": 743,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    numbers = list(map(int, input().split()))\n\n    total_sum = sum(numbers)\n    min_sum = total_sum\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if numbers[i] > numbers[j]:\n                temp = numbers[i]\n                numbers[i] = numbers[j]\n                numbers[j] = temp\n\n                total_sum -= numbers[i] - numbers[j]\n                min_sum = min(min_sum, total_sum)\n\n                total_sum += numbers[i] - numbers[j]\n\n    return min_sum\n\n\ninput_str = \"\"\"5\n45 12 27 30 18\n\"\"\"\nprint(solution(input_str))\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    flights = input().upper()\n\n    s_count = flights.count('S')\n    f_count = n - s_count\n\n    if s_count > f_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_stdin = \"\"\"4\nFSSF\"\"\"\nprint(solution(input_stdin))\n\ninput_stdin = \"\"\"2\nSF\"\"\"\nprint(solution(input_stdin))\n\ninput_stdin = \"\"\"10\nFFFFFFFFFF\"\"\"\nprint(solution(input_stdin))\n\ninput_stdin = \"\"\"10\nSSFFSFFSFF\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    days = stdin.splitlines()[1]\n\n    sf_count = days.count('S')\n    sf_streak = sum([1 for i in range(1, n) if days[i] == days[i-1]])\n    sf_triple_count = sum([1 for i in range(2, n) if days[i-2:i+1] == 'SSF'])\n\n    if sf_count > sf_streak + sf_triple_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    city_sequence = stdin.splitlines()[1]\n\n    s_count, f_count = city_sequence.count('S'), city_sequence.count('F')\n\n    if s_count > f_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    days = stdin.splitlines()[1]\n\n    sf_count = days.count('S')\n    fs_count = n - sf_count\n\n    if sf_count > fs_count:\n        return 'YES'\n    else:\n        return 'NO'\n\n\ndef"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    offices = stdin.split('\\n')[1]\n    seattle_visits = sum(1 for office in offices if office == 'S')\n    flight_count = seattle_visits + (n - seattle_visits)\n    return \"YES\" if flight_count % 2 == 1 else \"NO\"\n\n\ndef"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    days = stdin[1].split()\n\n    seattle_count, san_francisco_count = 0, 0\n\n    for day in days:\n        if day == \"S\":\n            san_francisco_count += 1\n        else:\n            seattle_count += 1\n\n    if san_francisco_count > seattle_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    flights = input()\n\n    sf_count = 0\n    sf_streak = 0\n    for i in range(n):\n        if flights[i] == 'S':\n            sf_streak += 1\n        else:\n            sf_count += sf_streak\n            sf_streak = 0\n\n    if sf_streak > 0:\n        sf_count += sf_streak\n\n    if sf_count > n // 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_str = '''4\nFSSF'''\nprint(solution(input_str))  # Output: NO\n\ninput_str = '''2\nSF'''\nprint(solution(input_str))  # Output: YES\n\ninput_str = '''10\nFFFFFFFFFF'''\nprint(solution(input_str))  # Output: NO\n\ninput_str = '''10\nSSFFSFFSFF'''\nprint(solution(input_str))  # Output: YES "
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = stdin.split(\"\\n\")[1]\n\n    seattle_count = sequence.count(\"S\")\n    san_francisco_count = n - seattle_count\n\n    if san_francisco_count > seattle_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    office_sequence = stdin.splitlines()[1]\n\n    sf_count = 0\n    sf_prev = False\n\n    for day in range(n):\n        sf_curr = office_sequence[n - 1 - day] == 'S'\n\n        if sf_curr and not sf_prev:\n            sf_count += 1\n\n        sf_prev = sf_curr\n\n    if sf_count > n / 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 744,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    flights = input().upper()\n\n    sf_count = flights.count('S')\n    sf_seattle_count = sum([1 for i in range(n - 1) if flights[i] == 'S' and flights[i + 1] == 'S'])\n    sf_to_sf_count = sum([1 for i in range(n - 1) if flights[i] == 'S' and flights[i + 1] == 'F'])\n\n    if sf_seattle_count >= sf_to_sf_count:\n        return \"NO\"\n    else:\n        return \"YES\"\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    # Calculate the number of ways to place the rooks\n    def rooks_placements(n: int, k: int) -> int:\n        if n == 1:\n            return 1\n\n        total = 0\n        for r in range(1, n):\n            if k > 0 and (r + 1) % (r - 1) == 0:\n                total += rooks_placements(n - 1, k - 1)\n            else:\n                total += rooks_placements(n - 1, k)\n\n        return total % mod\n\n    # Calculate the number of rooks that can be placed in each row\n    def rooks_per_row(n: int, k: int) -> int:\n        row = 0\n        while k > 0 and row < n:\n            row += 1\n            if row % (row - 1) == 0:\n                k -= 1\n\n        return min(row, n)\n\n    # Calculate the number of ways to place the rooks considering the two conditions\n    def valid_placements(n: int, k: int) -> int:\n        total = 0\n        for i in range(1, n):\n            row = rooks_per_row(i, k)\n            total += rooks_placements(row, k)\n\n        return total % mod\n\n    result = valid_placements(n, k)\n    return str(result)\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def rooks_attacking_each_other(row, col):\n        return row == col or abs(row - col) == n - 1\n\n    def rooks_attacking_each_other_pairs(row, col):\n        count = 0\n        for i in range(n):\n            if i != row and i != col and (rooks_attacking_each_other(i, col) or rooks_attacking_each_other(row, i)):\n                count += 1\n        return count\n\n    def rooks_on_board(row, col):\n        return 1 if row < n and col < n else 0\n\n    mod = 998244353\n\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = rooks_on_board(i, j)\n            for r in range(n):\n                if r == i or r == j:\n                    continue\n                dp[i][j] += dp[r][j] + dp[i][r]\n                dp[i][j] %= mod\n            dp[i][j] = (dp[i][j] * rooks_attacking_each_other(i, j)) % mod\n\n    result = sum(dp[i][j] for i in range(n) for j in range(n))\n\n    result = (result * (k - result * (n * (n - 1) // 2) // 2) % mod) % mod\n\n    return str(result)\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    dp = [1] * n\n    for i in range(n):\n        dp[i] = (dp[i] * (n - i)) % mod\n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[i] = (dp[i] * dp[j]) % mod\n    dp[0] = 0\n    ans = 0\n    for i in range(n - k):\n        ans = (ans + dp[i]) % mod\n    for i in range(k, n):\n        ans = (ans - dp[i - k]) % mod\n    return str(ans)\n\nn = int(input())\nk = int(input())\nstdin = str(n) + \" \" + str(k)\nprint(solution(stdin)) "
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n\n    # Helper function to count the number of pairs of rooks that attack each other\n    def count_pairs(n):\n        # There are n * (n - 1) / 2 pairs of rooks in total, so we can precompute the counts for each row, column, and diagonal\n        row_count = [0] * n\n        col_count = [0] * n\n        diag_count = [0] * 2 * n - 1\n\n        # Iterate over all possible pairs of rooks\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                # Determine the row, column, and diagonal indices for this pair of rooks\n                row_i, col_i = divmod(i, n)\n                row_j, col_j = divmod(j, n)\n                diag_i = row_i - col_i\n                diag_j = row_j - col_j\n\n                # Increment the counts for these indices\n                row_count[row_i] += 1\n                col_count[col_i] += 1\n                diag_count[diag_i + n - 1] += 1\n                diag_count[diag_j + 2 * n - 2 - diag_i] += 1\n\n        # Count the number of pairs of rooks that attack each other\n        pairs_count = 0\n        for count in row_count + col_count + diag_count:\n            pairs_count += count * (count - 1) // 2\n\n        return pairs_count\n\n    # Calculate the total number of possible placements of rooks\n    total_count = 2 ** (n ** 2)\n\n    # Calculate the number of placements with exactly k pairs of rooks that attack each other\n    if k > 0:\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                count += (i * n + j) * (n * n - 2 * i - 2 * j + 1) // 2\n        total_count -= count\n    else:\n        total_count -= count_pairs(n)\n\n    # Calculate the number of placements with the given conditions\n    total_count %= 998244353\n\n    return str(total_count)\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n    if n == 1:\n        return str(1)\n    if k == 0:\n        return str(pow(n, n, mod) * pow(mod - n, mod - 2, mod) * pow(n, mod - 2, mod) % mod)\n    if n == 2:\n        return str(0)\n    if k > n * (n - 1) // 2:\n        return str(0)\n    \n    def count_ways(n: int, k: int) -> int:\n        if n == 1:\n            return 1\n        ways = count_ways(n - 1, k)\n        if k > 0:\n            ways += count_ways(n - 1, k - 1)\n        return ways % mod\n    \n    return str(count_ways(n, k))\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    def count_ways(n, k):\n        if k == 0:\n            return 1\n        if k == n - 1:\n            return 1\n        if k == n * (n - 1) // 2:\n            return 1\n        if k > n * (n - 1) // 2:\n            return 0\n\n        dp = [1] * (k + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(min(i, k) + 1):\n                if i == j:\n                    dp[j] = (dp[j - 1] * (i - 1) + dp[j]) % mod\n                else:\n                    dp[j] = (dp[j - 1] * (i - 1) + dp[j]) % mod\n\n        return dp[k]\n\n    return str(count_ways(n, k))\n\n\ninput_str = \"3 2\"\nprint(solution(input_str))  # Output: 6\n\ninput_str = \"3 3\"\nprint(solution(input_str))  # Output: 0\n\ninput_str = \"4 0\"\nprint(solution(input_str))  # Output: 24\n\ninput_str = \"1337 42\"\nprint(solution(input_str))  # Output: 807905441"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n = input_values[0]\n    k = input_values[1]\n\n    def get_ways(n: int, k: int) -> int:\n        if k == 0 or k == n - 1:\n            return n\n\n        count = 0\n        for i in range(n):\n            rook_count = 0\n            for j in range(n):\n                if i == j:\n                    rook_count += 1\n            count += min(rook_count, k)\n        return count\n\n    answer = get_ways(n, k)\n    return str(answer % 998244353)\n"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split()\n    n = int(input_str[0])\n    k = int(input_str[1])\n\n    def count_ways(n: int, k: int) -> int:\n        if k == 0:\n            return 1\n        if n == 1:\n            return 0\n\n        # Calculate the number of ways to place rooks in the first row\n        ways = 0\n        for i in range(n):\n            ways += count_ways(n - 1, k - (i + 1))\n        ways %= MOD\n\n        # Calculate the number of ways to place rooks in the remaining rows\n        for i in range(n - 1):\n            for j in range(n - i - 1):\n                ways += count_ways(n - i - 1, k - j) * count_ways(n - i - 1, k - j - i - 1)\n            ways %= MOD\n\n        return ways\n\n    MOD = 998244353\n    result = count_ways(n, k)\n    return str(result)"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    # Check if k is out of range\n    if k > n * (n - 1) // 2:\n        return \"0\"\n\n    # Calculate the number of ways to place the rooks\n    for row in range(n):\n        # Count the number of ways to place the rooks in the current row\n        current_count = factorial(n - row) // (factorial(row) * factorial(n - 2 * row))\n        # Update the count if the current row contains the k-th pair of rooks\n        if k >= row and k < row + 2 * (n - 2 * row):\n            current_count %= 998244353\n            current_count *= 2\n            current_count %= 998244353\n        # Update the count for the next row\n        count = (count + current_count) % 998244353\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 745,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def count_ways(n, k):\n        if k > n * (n - 1) // 2:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 0 if k else 1\n        prev_row = count_ways(n - 1, k - (n - 1))\n        current_row = count_ways(n - 1, k)\n        return (prev_row + current_row) % (10**9 + 7)\n\n    result = count_ways(n, k)\n    return str(result % 998244353)\n"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b, x, y):\n        return ((a - x) ** 2 + (b - y) ** 2) ** 0.5\n\n    a, b = map(int, stdin.split()[:2])\n    n = int(stdin.split()[2])\n    taxis = [list(map(int, stdin.split()[i+3:i+6])) for i in range(n)]\n\n    min_time = float('inf')\n    for taxi in taxis:\n        x, y, v = taxi\n        dist = distance(a, b, x, y)\n        time = dist / v\n        if time < min_time:\n            min_time = time\n\n    return f'{min_time:.{10}f}'\n\n\ninput_file = 'input.txt'\nwith open(input_file, 'r') as file:\n    stdin = file.read()\n    result = solution(stdin)\n\noutput_file = 'output.txt'\nwith open(output_file, 'w') as file:\n    file.write(result)"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    n = int(input())\n    min_time = float('inf')\n\n    for i in range(n):\n        x, y, v = map(int, input().split())\n        dist = abs(a - x) + abs(b - y)\n        time = dist / v\n        if time < min_time:\n            min_time = time\n\n    print(\"{:.10f}\".format(min_time))"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[:2])\n    n = int(stdin.split()[2])\n    x = [list(map(int, input().split())) for _ in range(n)]\n    \n    t = 0\n    for i in range(n):\n        tx, ty, v = x[i]\n        dist = abs(tx - a) + abs(ty - b)\n        t = max(t, dist/v)\n    \n    return str(t)\n\n\ninput_stdin = \"\"\"0 0\n2\n2 0 1\n0 2 2\"\"\"\n\nresult = solution(input_stdin)\nprint(result)"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[:2])\n    n = int(stdin.split()[2])\n    xyv = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[2:]]\n\n    taxis = [(x, y, v) for x, y, v in xyv]\n    taxis.sort(key=lambda x: x[2])\n\n    min_time = float(\"inf\")\n    for x, y, v in taxis:\n        if (x - a) ** 2 + (y - b) ** 2 == 0:\n            min_time = 0\n            break\n        t = (abs(x - a) + abs(y - b)) / v\n        if t < min_time:\n            min_time = t\n\n    return f\"{min_time:.6f}\"\n\n\ninput_stdin = \"\"\"0 0\n2\n2 0 1\n0 2 2\"\"\"\n\noutput_stdin = solution(input_stdin)\nprint(output_stdin)\n\ninput_stdin = \"\"\"1 3\n3\n3 3 2\n-2 3 6\n-2 7 10\"\"\"\n\noutput_stdin = solution(input_stdin)\nprint(output_stdin) "
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    n = int(input())\n\n    cars = []\n    for _ in range(n):\n        x, y, v = map(int, input().split())\n        cars.append((x, y, v))\n\n    min_time = float('inf')\n    for x, y, v in cars:\n        time = abs(x - a) / v + abs(y - b) / v\n        min_time = min(min_time, time)\n\n    return f'{min_time:.12f}'\n"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    n = int(input())\n    taxis = []\n    for _ in range(n):\n        x, y, v = map(int, input().split())\n        taxis.append((x, y, v))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def time_to_arrive(p, v):\n        return distance((a, b), p) / v\n\n    min_time = float('inf')\n    for taxi in taxis:\n        min_time = min(min_time, time_to_arrive(taxi[:2], taxi[2]))\n\n    return str(min_time)\n"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    a, b = map(int, input_data[0].split())\n    n = int(input_data[1])\n    data = []\n    for i in range(2, len(input_data)):\n        x, y, v = map(int, input_data[i].split())\n        data.append((x, y, v))\n\n    min_time = float('inf')\n    for x, y, v in data:\n        dist = abs(x - a) + abs(y - b)\n        time = dist / v\n        min_time = min(min_time, time)\n\n    return f'{min_time:.18f}'\n"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    n = int(input())\n    cars = []\n\n    for _ in range(n):\n        x, y, v = map(int, input().split())\n        cars.append((x, y, v))\n\n    min_time = float('inf')\n\n    for car in cars:\n        x, y, v = car\n        time = abs(x - a) + abs(y - b)\n        time /= v\n        if time < min_time:\n            min_time = time\n\n    return f\"{min_time:.10f}\"\n\n\ninput_string = \"\"\"0 0\n2\n2 0 1\n0 2 2\n\"\"\"\n\nprint(solution(input_string))\n"
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    a, b = map(int, input_data[0].split())\n    n = int(input_data[1])\n    x = [0] * n\n    y = [0] * n\n    v = [0] * n\n    for i in range(n):\n        x[i], y[i], v[i] = map(int, input_data[2+i].split())\n    min_time = float('inf')\n    for i in range(n):\n        time = abs(x[i]-a) + abs(y[i]-b)\n        time = time / v[i] if time > 0 else float('inf')\n        min_time = min(min_time, time)\n    return f'{min_time:.10f}'\n\ninput_data = \"\"\"0 0\n2\n2 0 1\n0 2 2\"\"\"\nprint(solution(input_data)) # Output: 1.0000000000\n\ninput_data = \"\"\"1 3\n3\n3 3 2\n-2 3 6\n-2 7 10\"\"\"\nprint(solution(input_data)) # Output: 0.5000000000 "
    },
    {
        "number": 746,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_closest_car(cars, Vasiliy):\n        closest_distance = float('inf')\n        closest_car = None\n        for car in cars:\n            distance = abs(Vasiliy[0] - car[0]) + abs(Vasiliy[1] - car[1])\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_car = car\n        return closest_car\n\n    def get_time_to_car(car, Vasiliy, speed):\n        distance = abs(Vasiliy[0] - car[0]) + abs(Vasiliy[1] - car[1])\n        time = distance / speed\n        return time\n\n    a, b = map(int, stdin.split()[:2])\n    n = int(stdin.split()[2])\n    cars = [tuple(map(int, stdin.split()[3 + i * 3: 6 + i * 3: 2])) for i in range(n)]\n    cars = sorted(cars, key=lambda car: car[2])\n    Vasiliy = (a, b)\n\n    closest_car = get_closest_car(cars, Vasiliy)\n    time_to_closest_car = get_time_to_car(closest_car, Vasiliy, closest_car[2])\n    return str(time_to_closest_car)\n"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    height = x\n    max_candies = 0\n    prev_type = -1\n\n    for i in range(n):\n        type, height, mass = map(int, input().split())\n        if type != prev_type and height <= height:\n            height += mass\n            max_candies += 1\n            prev_type = type\n        else:\n            height = x\n            max_candies = 0\n            prev_type = -1\n\n    return max_candies\n\n\nn, x = map(int, input().split())\nheight = x\nmax_candies = 0\nprev_type = -1\n\nfor i in range(n):\n    type, height, mass = map(int, input().split())\n    if type != prev_type and height <= height:\n        height += mass\n        max_candies += 1\n        prev_type = type\n    else:\n        height = x\n        max_candies = 0\n        prev_type = -1\n\nprint(max_candies) "
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, x = map(int, input_list.pop(0).split())\n    candy_type = []\n    candy_height = []\n    candy_mass = []\n\n    for i in range(n):\n        candy = list(map(int, input_list[i].split()))\n        candy_type.append(candy[0])\n        candy_height.append(candy[1])\n        candy_mass.append(candy[2])\n\n    # Find the maximum number of candies that can be eaten\n    max_candies = 0\n    current_height = x\n    previous_type = -1\n\n    for i in range(n):\n        if candy_type[i] != previous_type:\n            if current_height + candy_height[i] <= x:\n                current_height += candy_height[i]\n                max_candies += 1\n                previous_type = candy_type[i]\n\n    return str(max_candies)"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    t = [0] * n\n    h = [0] * n\n    m = [0] * n\n\n    for i in range(n):\n        t[i], h[i], m[i] = map(int, input().split())\n\n    # Initialize the jump height and the maximum number of candies\n    jump_height = x\n    max_candies = 0\n\n    # Iterate through all the candies\n    for i in range(n):\n        # If the type of the current candy is different from the previous one, add the mass of the current candy to the jump height\n        if i == 0 or t[i] != t[i - 1]:\n            jump_height += m[i]\n        # If the current candy can be reached with the current jump height, add the mass of the current candy to the maximum number of candies\n        if jump_height >= h[i]:\n            max_candies += 1\n        else:\n            # If the current candy cannot be reached, update the jump height and continue with the next candy\n            jump_height = x + m[i]\n\n    return str(max_candies)\n\n\ninput_str = \"\"\"5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    types = []\n    heights = []\n    masses = []\n\n    for _ in range(n):\n        t, h, m = map(int, stdin.split()[2:5])\n        types.append(t)\n        heights.append(h)\n        masses.append(m)\n\n    # Calculate the maximum height Om Nom can reach\n    max_height = max(heights) + x\n\n    # Count the number of fruit and caramel drops\n    fruit_drops = sum(t for t, h, m in zip(types, heights, masses) if t == 0)\n    caramel_drops = n - fruit_drops\n\n    # Calculate the maximum number of candies Om Nom can eat\n    max_candies = min(fruit_drops, caramel_drops)\n\n    return str(max_candies)"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, x = map(int, input_list[0].split())\n    t_i, h_i, m_i = [], [], []\n    for i in range(1, len(input_list)):\n        t, h, m = map(int, input_list[i].split())\n        t_i.append(t)\n        h_i.append(h)\n        m_i.append(m)\n\n    # Initialize variables\n    count = 0\n    prev_type = -1\n    prev_height = 0\n\n    # Iterate through all candies\n    for i in range(n):\n        if t_i[i] == 0:\n            # Caramel drop\n            if prev_type != 0:\n                # A caramel drop is available and previous candy was a fruit drop\n                if prev_height < x:\n                    # Can reach the next caramel drop\n                    count += 1\n                    prev_type = 0\n                    prev_height = h_i[i]\n        else:\n            # Fruit drop\n            if prev_type != 1:\n                # A fruit drop is available and previous candy was a caramel drop\n                if prev_height < x:\n                    # Can reach the next fruit drop\n                    count += 1\n                    prev_type = 1\n                    prev_height = h_i[i]\n        if prev_height >= x:\n            # Cannot reach the next candy\n            break\n\n    return str(count)\n"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    candies = []\n    for _ in range(n):\n        t, h, m = map(int, input().split())\n        candies.append((t, h, m))\n\n    max_candies = 0\n    prev_type = -1\n    prev_height = 0\n\n    for candy in sorted(candies, key=lambda x: x[1]):\n        t, h, m = candy\n        if t != prev_type:\n            max_candies += 1\n            prev_type = t\n            prev_height = h + m\n            if prev_height > x:\n                break\n        else:\n            max_candies += 1\n            prev_height = h + m\n            if prev_height > x:\n                break\n\n    return str(max_candies)\n\n\ninput_str = \"\"\"5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    sweets = []\n    for _ in range(n):\n        t, h, m = map(int, input().split())\n        sweets.append((t, h, m))\n\n    def get_jump_height(jump_height, candy_mass):\n        return jump_height + candy_mass\n\n    def can_eat_candy(candy_type, previous_candy_type):\n        return candy_type != previous_candy_type\n\n    def can_reach_candy(candy_height, current_jump_height):\n        return candy_height <= current_jump_height\n\n    def get_eaten_candies(sweets, jump_height, previous_candy_type):\n        eaten_candies = 0\n        for i, candy in enumerate(sweets):\n            t, h, m = candy\n            if can_eat_candy(t, previous_candy_type):\n                jump_height = get_jump_height(jump_height, m)\n                if can_reach_candy(h, jump_height):\n                    eaten_candies += 1\n                    previous_candy_type = t\n        return eaten_candies, jump_height, previous_candy_type\n\n    def max_candies_eaten(sweets, initial_jump_height, x):\n        max_eaten_candies = 0\n        current_jump_height = initial_jump_height\n        previous_candy_type = None\n        for _ in range(x):\n            eaten_candies, current_jump_height, previous_candy_type = get_eaten_candies(sweets, current_jump_height, previous_candy_type)\n            max_eaten_candies = max(max_eaten_candies, eaten_candies)\n        return max_eaten_candies\n\n    max_candies = max_candies_eaten(sweets, x, x)\n    return str(max_candies)\n\ninput_data = \"\"\"5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_fruit_drop(candy_type: int) -> bool:\n        return candy_type == 0\n\n    def calculate_jump_height(previous_jump_height: int, candy_mass: int) -> int:\n        return previous_jump_height + candy_mass\n\n    def can_eat_candy(previous_candy_type: int, current_candy_type: int) -> bool:\n        return previous_candy_type != current_candy_type\n\n    n, x = map(int, stdin.split()[:2])\n    h = [0] * (n + 1)\n    m = [0] * (n + 1)\n    h[0] = x\n    candy_types = []\n    jump_height = x\n\n    for i in range(n):\n        candy_type, h[i + 1], m[i + 1] = map(int, stdin.split()[i + 2:i + 5])\n        candy_types.append(candy_type)\n\n    candy_count = 0\n    previous_candy_type = None\n\n    for i in range(1, n + 1):\n        if can_eat_candy(previous_candy_type, candy_types[i - 1]):\n            jump_height = calculate_jump_height(jump_height, m[i])\n            if is_fruit_drop(candy_types[i - 1]):\n                jump_height = calculate_jump_height(jump_height, m[i])\n            candy_count += 1\n            previous_candy_type = candy_types[i - 1]\n\n    return str(candy_count)\n"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split()[0:2])\n    types = list(map(int, stdin.split()[2:]))\n    caramel_drops = [i for i in range(n) if types[i] == 0]\n    fruit_drops = [i for i in range(n) if types[i] == 1]\n\n    def can_eat(candy_type, last_eaten_type):\n        return last_eaten_type != candy_type\n\n    def max_candies(candies, jump):\n        max_eaten = 0\n        last_eaten = None\n        for candy in candies:\n            if can_eat(types[candy], last_eaten):\n                max_eaten += 1\n                jump += m[candy]\n            last_eaten = types[candy]\n            if jump > x:\n                return max_eaten\n        return max_eaten\n\n    return str(max(max_candies(caramel_drops, x), max_candies(fruit_drops, x)))\n"
    },
    {
        "number": 747,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    types = [0] * n\n    heights = [0] * n\n    masses = [0] * n\n\n    for i in range(n):\n        types[i], heights[i], masses[i] = map(int, input().split())\n\n    types.sort()\n    max_candies = 0\n    strength = 0\n\n    for i in range(n):\n        if types[i] == 0 and strength + masses[i] <= x:\n            strength += masses[i]\n            max_candies += 1\n        else:\n            strength = 0\n\n    return max_candies\n\ninput_str = \"\"\"5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\"\"\"\n\nprint(solution(input_str))  # Output: 4"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    sequence = list(map(int, input().split()))\n    \n    if n % 3 != 0:\n        return -1\n    \n    groups = []\n    \n    for i in range(0, n, 3):\n        a, b, c = sequence[i:i+3]\n        if a < b < c and b % a == 0 and b % c == 0:\n            groups.append((a, b, c))\n        else:\n            return -1\n    \n    for group in groups:\n        print(\" \".join(map(str, group)))\n        \n    return len(groups)\n"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_group(a: int, b: int, c: int) -> bool:\n        return a < b < c and a % b == 0 and b % c == 0\n\n    def find_groups(sequence: List[int]) -> List[Tuple[int]]:\n        for i in range(len(sequence) - 2):\n            for j in range(i + 1, len(sequence) - 1):\n                for k in range(j + 1, len(sequence)):\n                    if is_valid_group(sequence[i], sequence[j], sequence[k]):\n                        return [(sequence[i], sequence[j], sequence[k])]\n        return []\n\n    def is_valid_partition(partition: List[Tuple[int]]) -> bool:\n        return len(partition) == n // 3 and all(sum(len(group) for group in partition) == 3 * len(partition[0]) for partition in partitions)\n\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n\n    partitions = find_groups(sequence)\n    if not is_valid_partition(partitions):\n        return -1\n\n    for partition in partitions:\n        for group in partition:\n            print(\" \".join(map(str, sorted(group))))\n"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    numbers = list(map(int, input().split()))\n\n    # Check if n is divisible by 3\n    if n % 3 != 0:\n        return -1\n\n    # Check if each element is at most 7\n    for num in numbers:\n        if num > 7:\n            return -1\n\n    # Check if there is a group of three that satisfies the conditions\n    for i in range(n - 2):\n        if numbers[i] < numbers[i + 1] < numbers[i + 2] and numbers[i + 1] % numbers[i] == 0 and numbers[i + 2] % numbers[i + 1] == 0:\n            # Found a valid group of three, return it\n            return \"{} {} {}\".format(numbers[i], numbers[i + 1], numbers[i + 2])\n\n    # No valid group of three found, return -1\n    return -1\n"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    seq = list(map(int, stdin.splitlines()[1].split()))\n    \n    def is_valid(a, b, c):\n        return a < b < c and a % b == 0 and b % c == 0\n    \n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if is_valid(seq[i], seq[j], seq[k]):\n                    return \" \".join(map(str, [seq[i], seq[j], seq[k]])) + \"\\n\" * (n // 3)\n                \n    return \"-1\\n\"\n\ninput_str = \"\"\"6\n1 1 1 2 2 2\"\"\"\n\nprint(solution(input_str)) # Output: -1\n\ninput_str = \"\"\"6\n2 2 1 1 4 6\"\"\"\n\nprint(solution(input_str)) # Output: 1 2 4\\n1 2 6\\n "
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    seq = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(n - 2):\n        if seq[i] >= seq[i + 1] or seq[i + 2] >= seq[i + 1]:\n            return -1\n\n    for i in range(n - 2):\n        if seq[i] % seq[i + 1] != 0:\n            return -1\n\n    groups = []\n    for i in range(n // 3):\n        group = [seq[i * 3], seq[i * 3 + 1], seq[i * 3 + 2]]\n        groups.append(group)\n\n    return groups\n"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_group(a: int, b: int, c: int) -> bool:\n        return a < b < c and a % b == 0 and b % c == 0\n\n    def find_group_with_element(element: int) -> tuple:\n        for i in range(len(groups)):\n            for j in range(3):\n                if groups[i][j] == element:\n                    return i, j\n        return -1, -1\n\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = [int(x) for x in sequence.split()]\n    groups = [[] for _ in range(n // 3)]\n\n    for num in sequence:\n        index, position = find_group_with_element(num)\n        if index != -1:\n            groups[index][position] = num\n        else:\n            for group in groups:\n                if len(group) < 3:\n                    group.append(num)\n                    break\n\n    valid_groups = []\n    for group in groups:\n        if len(group) == 3 and is_valid_group(group[0], group[1], group[2]):\n            valid_groups.append(group)\n\n    if len(valid_groups) == n // 3:\n        valid_groups.sort(key=lambda x: (x[0], x[1], x[2]))\n        return '\\n'.join([' '.join(map(str, group)) for group in valid_groups])\n    else:\n        return -1"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *sequence = map(int, stdin.split())\n\n    for i in range(n - 2):\n        a, b, c = sequence[i:i+3]\n        if a >= b >= c:\n            return -1\n\n    groups = []\n    for i in range(0, n, 3):\n        groups.append(sorted(sequence[i:i+3]))\n\n    return ' '.join(' '.join(str(x) for x in group) for group in groups)\n\n\ndef"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    nums = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_valid(nums):\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if nums[i] < nums[i + 1] < nums[i + 2]:\n                if nums[i] % nums[i + 1] == 0:\n                    if nums[i + 1] % nums[i + 2] == 0:\n                        return True\n        return False\n\n    valid_groups = []\n    for i in range(0, n, 3):\n        group = nums[i:i + 3]\n        if is_valid(group):\n            valid_groups.append(group)\n\n    if len(valid_groups) == int(n / 3):\n        for group in valid_groups:\n            print(\" \".join(map(str, group)))\n    else:\n        print(-1)\n"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    \n    # check if there are at least 2 numbers in the sequence\n    if len(sequence) < 2:\n        return -1\n    \n    # check if all numbers in the sequence are at most 7\n    if any(num > 7 for num in sequence):\n        return -1\n    \n    # check if n is divisible by 3\n    if n % 3 != 0:\n        return -1\n    \n    # find groups of three\n    groups = []\n    for i in range(0, n, 3):\n        if sequence[i] % sequence[i+1] == 0 and sequence[i+1] % sequence[i+2] == 0:\n            groups.append((sequence[i], sequence[i+1], sequence[i+2]))\n    \n    # check if there are at least n/3 groups of three\n    if len(groups) < n//3:\n        return -1\n    \n    # sort groups and return them\n    return \"\\n\".join(\" \".join(map(str, sorted(group))) for group in groups)\n\n\ndef"
    },
    {
        "number": 748,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = sorted(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_valid(i: int, j: int, k: int) -> bool:\n        return sequence[i] < sequence[j] < sequence[k] and sequence[i] % sequence[j] == 0 and sequence[j] % sequence[k] == 0\n\n    valid_groups = []\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if is_valid(i, j, k):\n                    valid_groups.append((sequence[i], sequence[j], sequence[k]))\n\n    if not valid_groups:\n        return \"-1\"\n    else:\n        return \" \".join(str(group) for group in valid_groups)\n"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 1\n    while True:\n        if any(s[i:i+k].count(c) > 0 for c in set(s)):\n            return k\n        k += 1"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    k = 1\n    while k <= len(s):\n        if any(s[i:i+k].count(c) == k for c in set(s)):\n            return k\n        k += 1\n    return k"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k = 1\n    while not any(s[i:i + k] == s[0] * k for i in range(len(s) - k + 1)):\n        k += 1\n    return k\n"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    k = 1\n    while not any(s[i:i+k].count(c) >= k for c in set(s)):\n        k += 1\n    return str(k)\n"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if j - i + 1 > max_len and s[i:j].count('a') == 1:\n                max_len = j - i + 1\n    return max_len\n\n\nstdin = \"abacaba\"\nprint(solution(stdin))\n\nstdin = \"zzzzz\"\nprint(solution(stdin))\n\nstdin = \"abcde\"\nprint(solution(stdin)) "
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    min_k = 1\n    for k in range(1, len(s) + 1):\n        if s[:k] == s[:k].replace('c', ''):\n            break\n        min_k = k\n    return str(min_k)\n\n\nstdin = input()\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 1\n\n    while k <= n:\n        found = False\n        for i in range(n - k + 1):\n            if s[i:i+k].count('a') > 0:\n                found = True\n                break\n            if s[i:i+k].count('b') > 0:\n                found = True\n                break\n            if s[i:i+k].count('c') > 0:\n                found = True\n                break\n            if s[i:i+k].count('d') > 0:\n                found = True\n                break\n            if s[i:i+k].count('e') > 0:\n                found = True\n                break\n            if s[i:i+k].count('f') > 0:\n                found = True\n                break\n            if s[i:i+k].count('g') > 0:\n                found = True\n                break\n            if s[i:i+k].count('h') > 0:\n                found = True\n                break\n            if s[i:i+k].count('i') > 0:\n                found = True\n                break\n            if s[i:i+k].count('j') > 0:\n                found = True\n                break\n            if s[i:i+k].count('k') > 0:\n                found = True\n                break\n            if s[i:i+k].count('l') > 0:\n                found = True\n                break\n            if s[i:i+k].count('m') > 0:\n                found = True\n                break\n            if s[i:i+k].count('n') > 0:\n                found = True\n                break\n            if s[i:i+k].count('o') > 0:\n                found = True\n                break\n            if s[i:i+k].count('p') > 0:\n                found = True\n                break\n            if s[i:i+k].count('q') > 0:\n                found = True\n                break\n            if s[i:i+k].count('r') > 0:\n                found = True\n                break\n            if s[i:i+k].count('s') > 0:\n                found = True\n                break\n            if s[i:i+k].count('t') > 0:\n                found = True\n                break\n            if s[i:i+k].count('u') > 0:\n                found = True\n                break\n            if s[i:i+k].count('v') > 0:\n                found = True\n                break\n            if s[i:i+k].count('w') > 0:\n                found = True\n                break\n            if s[i:i+k].count('x') > 0:\n                found = True\n                break\n            if s[i:i+k].count('y') > 0:\n                found = True\n                break\n            if s[i:i+k].count('z') > 0:\n                found = True\n                break\n        if found:\n            break\n        k += 1\n\n    return k\n"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 1\n    while k <= n // 2 and not any(s[i:i + k] == s[i] for i in range(n - k + 1)):\n        k += 1\n    return k"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k = 1\n    while True:\n        if all(c in s[k:] for c in set(s)):\n            return k\n        k += 1\n"
    },
    {
        "number": 749,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    k = 1\n\n    while k <= n // 2:\n        for i in range(n - k + 1):\n            if s[i] == s[i + k - 1]:\n                break\n        else:\n            # no break, k-dominant character found\n            return k\n        k += 1\n\n    # no k-dominant character found\n    return n + 1\n"
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    red_sheets = 2 * n\n    green_sheets = 3 * n\n    blue_sheets = 5 * n\n\n    red_notebooks = red_sheets // k\n    green_notebooks = green_sheets // k\n    blue_notebooks = blue_sheets // k\n\n    return str(red_notebooks + green_notebooks + blue_notebooks)\n"
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    red = 2 * n\n    green = 5 * n\n    blue = 8 * n\n    \n    red_sheets = red * k\n    green_sheets = green * k\n    blue_sheets = blue * k\n    \n    total_sheets = red_sheets + green_sheets + blue_sheets\n    \n    notebooks = total_sheets // k\n    \n    return str(notebooks)\n"
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    red_sheets = 2 * n\n    green_sheets = 3 * n\n    blue_sheets = 5 * n\n\n    if red_sheets % k == 0:\n        red_notebooks = red_sheets // k\n    else:\n        red_notebooks = red_sheets // k + 1\n\n    if green_sheets % k == 0:\n        green_notebooks = green_sheets // k\n    else:\n        green_notebooks = green_sheets // k + 1\n\n    if blue_sheets % k == 0:\n        blue_notebooks = blue_sheets // k\n    else:\n        blue_notebooks = blue_sheets // k + 1\n\n    return str(red_notebooks + green_notebooks + blue_notebooks)\n\ninput_stdin = \"3 5\\n\"\nprint(solution(input_stdin))  # Output: 10 "
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, k = int(input_list[0]), int(input_list[1])\n    \n    min_notebooks = float('inf')\n    \n    for i in range(1, n+1):\n        if i < n:\n            min_notebooks = min(min_notebooks, (i+1) * k)\n        else:\n            min_notebooks = min(min_notebooks, i * k)\n    \n    return str(min_notebooks)\n\n\nn, k = map(int, input().split())\nprint(solution(stdin=f\"{n} {k}\")) "
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red_sheets = n * 2\n    green_sheets = n * 5\n    blue_sheets = n * 8\n    return sum([red_sheets // k, green_sheets // k, blue_sheets // k])"
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red_sheets = 2 * n\n    green_sheets = 5 * n\n    blue_sheets = 8 * n\n    return (red_sheets // k) + (green_sheets // k) + (blue_sheets // k)\n\nn = 3\nk = 5\nprint(solution(str(n) + \" \" + str(k)))\n\nn = 15\nk = 6\nprint(solution(str(n) + \" \" + str(k))) "
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red = green = blue = 0\n    while red * k + green * k + blue * k < 2 * n:\n        red += 1\n        if red * k + green * k + blue * k < 5 * n:\n            green += 1\n        if red * k + green * k + blue * k < 8 * n:\n            blue += 1\n    return red + green + blue\n"
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red = n // (2 * k)\n    green = n // (5 * k)\n    blue = n // (8 * k)\n    return min(red, green, blue) * k\n\nn = int(input())\nk = int(input())\nprint(solution(str(n) + \" \" + str(k))) "
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red = min(2, n // k)\n    green = min(3, n // k)\n    blue = min(5, n // k)\n    return red * k + green * k + blue * k\n\nn = int(input())\nk = int(input())\nstdin = f\"{n} {k}\"\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 750,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    min_notebooks = n * (2 * k + 5 * k + 8 * k)\n    return str(min_notebooks)\n\nn = 3\nk = 5\nstdin = f\"{n} {k}\"\nprint(solution(stdin))\n\nn = 15\nk = 6\nstdin = f\"{n} {k}\"\nprint(solution(stdin)) "
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    i = 0\n\n    while i < n:\n        if sum(a[i:]) > m:\n            count += 1\n            i += 1\n        else:\n            count += 1\n            i += sum(a[i:])\n\n    return count\n"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    total_people = sum(a)\n    bus_count = 0\n\n    while total_people > 0:\n        if total_people <= m:\n            bus_count += 1\n            total_people = 0\n        else:\n            bus_count += 1\n            total_people -= m\n\n    return str(bus_count)"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n    a = list(map(int, input_list[2:]))\n\n    total_people = sum(a)\n    buses = 0\n    current_people = 0\n\n    for i in range(n):\n        current_people += a[i]\n        if current_people <= m:\n            current_people = 0\n        else:\n            buses += 1\n            current_people = a[i]\n\n    if current_people > 0:\n        buses += 1\n\n    return str(buses)"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    buses = 0\n    i = 0\n    while i < n:\n        if sum(a[i:i+m]) > m:\n            j = i + m - 1\n            while j < n and a[j] > 0:\n                j += 1\n            if j < n:\n                i = j\n            else:\n                buses += 1\n                i = j\n        else:\n            buses += 1\n            i += m\n    return buses\n"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    \n    # Initialize variables\n    count = 0\n    total_people = sum(a)\n    \n    # Iterate through the groups\n    for i in range(n):\n        # Calculate the number of people in the current group\n        num_people = a[i]\n        \n        # If there are enough people to fill the bus, add it to the count\n        if num_people <= m:\n            count += 1\n            \n        # If there are not enough people, subtract the number of people in the current group from the total number of people\n        else:\n            total_people -= num_people\n            \n        # If there are still enough people left, add the count and continue iterating\n        if total_people >= m:\n            count += 1\n            \n        # If there are not enough people left, move to the next bus and continue iterating\n        else:\n            count += 1\n            total_people = 0\n            \n    return count"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    bus_count = 0\n    total_people = sum(a)\n\n    while total_people > 0:\n        bus_count += 1\n        if m >= total_people:\n            total_people = 0\n        else:\n            for i in range(n):\n                if a[i] > m:\n                    a[i] = 0\n                else:\n                    a[i] -= m\n                    total_people -= m\n                    if a[i] == 0:\n                        a.pop(i)\n                        n -= 1\n\n    return str(bus_count)\n"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = list(map(int, stdin.split()[2:]))\n    \n    buses = 0\n    i = 0\n    \n    while i < n:\n        can_fit = min(groups[i:i+m])\n        buses += 1\n        i += can_fit\n        \n    return str(buses)\n\nn = 4\nm = 3\ngroups = [2, 3, 2, 1]\nprint(solution(str(n) + \" \" + str(m) + \" \" + \" \".join(map(str, groups))))\n\nn = 3\nm = 4\ngroups = [1, 2, 1]\nprint(solution(str(n) + \" \" + str(m) + \" \" + \" \".join(map(str, groups)))) "
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    m = input_list[1]\n    groups = input_list[2:]\n\n    num_buses = 0\n    total_passengers = 0\n\n    for group in groups:\n        if total_passengers + group > m:\n            total_passengers = group\n            num_buses += 1\n        else:\n            total_passengers += group\n\n    return str(num_buses)\n"
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    buses = 0\n    total_passengers = 0\n    for i in range(n):\n        total_passengers += a[i]\n        if total_passengers > m:\n            buses += 1\n            total_passengers = a[i]\n\n    return str(buses + 1) if total_passengers > 0 else str(buses)\n\n\nstdin = \"4 3\\n2 3 2 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 751,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    groups = list(map(int, input().split()))\n\n    def count_buses(groups: list, m: int) -> int:\n        total_people = sum(groups)\n        buses = 1\n        while total_people > m:\n            buses += 1\n            total_people -= m\n        return buses\n\n    return str(count_buses(groups, m))\n\n\ninput_stdin = \"\"\"4 3\n2 3 2 1\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sizes_a = stdin.split('\\n')[1::2]\n    sizes_b = stdin.split('\\n')[2::2]\n\n    def is_valid_size(size: str) -> bool:\n        if len(size) == 1:\n            return size.upper() in [\"M\", \"X\", \"S\"]\n        elif len(size) == 2:\n            return size.upper() in [\"XX\", \"XXX\", \"XL\", \"L\"]\n        elif len(size) == 3:\n            return size.upper() in [\"XXL\", \"XXXL\", \"XXS\", \"XLS\", \"XXXS\"]\n\n    def is_same_list(sizes_a: List[str], sizes_b: List[str]) -> bool:\n        if len(sizes_a) != len(sizes_b):\n            return False\n        for size_a, size_b in zip(sizes_a, sizes_b):\n            if size_a.count(size_a[0]) != size_b.count(size_b[0]):\n                return False\n        return True\n\n    def is_valid_change(sizes_a: List[str], sizes_b: List[str]) -> int:\n        total_seconds = 0\n        for i, (size_a, size_b) in enumerate(zip(sizes_a, sizes_b)):\n            if size_a.upper() != size_b.upper():\n                for j, letter in enumerate(size_a):\n                    if is_valid_size(size_a[j:j+1]):\n                        total_seconds += 1\n                        break\n        return total_seconds\n\n    if is_same_list(sizes_a, sizes_b):\n        return 0\n    else:\n        return is_valid_change(sizes_a, sizes_b)"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = [line.strip() for line in stdin[1:n+1]]\n    b = [line.strip() for line in stdin[n+1:]]\n\n    total_seconds = 0\n    for i in range(n):\n        total_seconds += edit_distance(a[i], b[i])\n\n    return total_seconds\n\ndef"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = stdin.split('\\n')[1].split()\n    b = stdin.split('\\n')[n+1].split()\n    \n    count = 0\n    for i in range(n):\n        if a[i] != b[i]:\n            count += 1\n            count += 1 # replacing the first character with uppercase\n            if a[i][1:].isdigit():\n                count += 1 # replacing the second character with uppercase\n                \n    return count"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sizes = []\n    for i in range(1, 2 * n, 2):\n        sizes.append(stdin.splitlines()[i])\n    result = 0\n    for i in range(n):\n        if sizes[i] != sizes[n + i]:\n            result += 1\n    return result"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    sizes_a = stdin[1:n+1]\n    sizes_b = stdin[n+1:2*n+1]\n\n    # Check if lists are equal\n    if sizes_a == sizes_b:\n        return \"0\"\n\n    # Initialize variables\n    seconds = 0\n    i = 0\n    j = 0\n\n    while i < n and j < n:\n        size_a = sizes_a[i].strip()\n        size_b = sizes_b[j].strip()\n\n        if size_a.isupper() or size_b.isupper():\n            i += 1\n            j += 1\n            continue\n\n        if size_a.endswith(\"S\") or size_a.endswith(\"X\") or size_a.endswith(\"L\"):\n            if size_a.endswith(\"X\"):\n                size_a = size_a[:-1] + \"S\"\n            else:\n                size_a = size_a[:-1] + \"L\"\n\n        if size_b.endswith(\"S\") or size_b.endswith(\"X\") or size_b.endswith(\"L\"):\n            if size_b.endswith(\"X\"):\n                size_b = size_b[:-1] + \"S\"\n            else:\n                size_b = size_b[:-1] + \"L\"\n\n        if size_a == size_b:\n            i += 1\n            j += 1\n        else:\n            seconds += 1\n            i += 1\n\n    return str(seconds)\n"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    prev_year = [line.strip() for line in stdin.split(\"\\n\")[1:n+1]]\n    curr_year = [line.strip() for line in stdin.split(\"\\n\")[n+1:]]\n\n    def is_valid(size: str) -> bool:\n        if size[0] == \"M\" or (size[0].isdigit() and size[1] == \"X\" and size[2] == \"S\"):\n            return True\n        return False\n\n    def count_diff(prev_list: list, curr_list: list) -> int:\n        count = 0\n        for size in prev_list:\n            if size not in curr_list:\n                count += 1\n        return count\n\n    def replace_size(size: str, replace_idx: int) -> str:\n        if replace_idx == 0:\n            if size[0].isdigit():\n                return chr(ord(size[0]) - 1) + size[1:]\n            return \"M\" if size[0] == \"S\" else \"S\"\n        return size[:replace_idx] + chr(ord(size[replace_idx]) + 1) + size[replace_idx + 1:]\n\n    def min_seconds(prev_list: list, curr_list: list) -> int:\n        seconds = 0\n        for i, size in enumerate(prev_list):\n            if size not in curr_list:\n                for j in range(len(size)):\n                    if is_valid(replace_size(size, j)):\n                        seconds = max(seconds, count_diff(prev_list[:i] + [replace_size(size, j)] + prev_list[i+1:], curr_list) + min_seconds(prev_list[:i] + [replace_size(size, j)] + prev_list[i+1:], curr_list))\n        return seconds\n\n    if sorted(prev_year) == sorted(curr_year):\n        return 0\n\n    return min_seconds(prev_year, curr_year)\n"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    old_list = stdin.splitlines()[1:n+1]\n    new_list = stdin.splitlines()[n+1:2*n+1]\n\n    old_list = [set(word) for word in old_list]\n    new_list = [set(word) for word in new_list]\n\n    min_seconds = 0\n    for i, old_word in enumerate(old_list):\n        new_word = new_list[i]\n        diff = old_word.symmetric_difference(new_word)\n        min_seconds += len(diff)\n\n    return min_seconds"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = []\n    b = []\n\n    for i in range(n):\n        a.append(input())\n        b.append(input())\n\n    a_freq = {}\n    b_freq = {}\n\n    for item in a:\n        a_freq[item] = a_freq.get(item, 0) + 1\n\n    for item in b:\n        b_freq[item] = b_freq.get(item, 0) + 1\n\n    total_seconds = 0\n\n    for item in a_freq:\n        if item in b_freq and a_freq[item] != b_freq[item]:\n            raise ValueError(\"Lists are not equal\")\n\n        if item not in b_freq:\n            continue\n\n        a_count = a_freq[item]\n        b_count = b_freq[item]\n\n        if a_count == b_count:\n            continue\n\n        for i in range(min(a_count, b_count)):\n            total_seconds += 1\n\n    return total_seconds\n"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = input_list[1:n+1]\n    b = input_list[n+1:2*n+1]\n\n    count_b = [0] * 6\n    count_a = [0] * 6\n\n    for size in a:\n        if size == \"M\":\n            count_a[0] += 1\n        elif size.startswith(\"X\") and size.endswith(\"S\"):\n            count_a[1] += 1\n        elif size.startswith(\"X\") and size.endswith(\"L\"):\n            count_a[2] += 1\n        elif size.startswith(\"L\") and size.endswith(\"S\"):\n            count_a[3] += 1\n        elif size.startswith(\"L\") and size.endswith(\"X\"):\n            count_a[4] += 1\n        elif size.startswith(\"X\") and size.endswith(\"X\"):\n            count_a[5] += 1\n\n    for size in b:\n        if size == \"M\":\n            count_b[0] += 1\n        elif size.startswith(\"X\") and size.endswith(\"S\"):\n            count_b[1] += 1\n        elif size.startswith(\"X\") and size.endswith(\"L\"):\n            count_b[2] += 1\n        elif size.startswith(\"L\") and size.endswith(\"S\"):\n            count_b[3] += 1\n        elif size.startswith(\"L\") and size.endswith(\"X\"):\n            count_b[4] += 1\n        elif size.startswith(\"X\") and size.endswith(\"X\"):\n            count_b[5] += 1\n\n    min_seconds = float('inf')\n\n    for i in range(6):\n        min_seconds = min(min_seconds, abs(count_a[i] - count_b[i]))\n\n    return min_seconds\n"
    },
    {
        "number": 752,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sizes_a = list(map(str.strip, stdin.split('\\n')[1:n+1]))\n    sizes_b = list(map(str.strip, stdin.split('\\n')[n+1:]))\n\n    def is_valid_size(size: str) -> bool:\n        return (size[0] == 'M' or (size[0].isdigit() and 0 <= int(size[0]) <= 3)) and (size[-1] == 'S' or size[-1] == 'L')\n\n    def distribute_sizes(sizes: List[str], n: int) -> str:\n        count = Counter(sizes)\n        total_seconds = 0\n        for size in sizes:\n            if not is_valid_size(size):\n                return -1\n            if count[size] > 1:\n                total_seconds += n - count[size] + 1\n                count[size] = 1\n        return total_seconds\n\n    seconds_a = distribute_sizes(sizes_a, n)\n    if seconds_a == -1:\n        return -1\n    seconds_b = distribute_sizes(sizes_b, n)\n    if seconds_b == -1:\n        return -1\n    return max(seconds_a, seconds_b)"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    # Calculate the ratio of the screen occupied by the movie\n    screen_ratio = a * d / (b * c)\n\n    # Calculate the ratio of the remaining screen space\n    empty_screen_ratio = 1 - screen_ratio\n\n    # Calculate the common divisor of both ratios\n    divisor = math.gcd(screen_ratio, empty_screen_ratio)\n\n    # Calculate the reduced fraction for the empty screen ratio\n    empty_screen_p = int(empty_screen_ratio / divisor)\n    empty_screen_q = int(screen_ratio / divisor)\n\n    # Calculate the reduced fraction for the screen ratio\n    screen_p = int(screen_ratio / divisor)\n    screen_q = int(empty_screen_ratio / divisor)\n\n    return f\"{screen_p}/{screen_q}\"\n"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    # calculate the common ratio\n    common_ratio = gcd(c, d)\n    c = c // common_ratio\n    d = d // common_ratio\n    # calculate the ratio of empty screen\n    ratio_empty_screen = lcm(a, b) / (a * c + b * d)\n    # calculate the irreducible fraction\n    p = ratio_empty_screen * c\n    q = ratio_empty_screen * d\n    return f\"{p}/{q}\"\n\n\ndef"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    # Calculate the ratio of empty screen to total screen size\n    empty_screen = (a*d) / (b*c)\n    total_screen = (a*b) / (c*d)\n    \n    # Calculate the GCD of empty_screen and total_screen\n    gcd = math.gcd(int(empty_screen), int(total_screen))\n    \n    # Calculate the reduced fraction for empty_screen/total_screen\n    p = int(empty_screen / gcd)\n    q = int(total_screen / gcd)\n    \n    return f\"{p}/{q}\""
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p = a * d - b * c\n    q = a * d\n    gcd = math.gcd(p, q)\n    p //= gcd\n    q //= gcd\n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def reduce_fraction(numerator: int, denominator: int) -> str:\n        def find_common_denominator(a: int, b: int) -> int:\n            return lcm(gcd(a, b), max(a, b))\n\n        def find_common_numerator(a: int, b: int) -> int:\n            return a * (find_common_denominator(a, b) // b)\n\n        while denominator != 1:\n            g = gcd(numerator, denominator)\n            numerator //= g\n            denominator //= g\n\n        return f\"{numerator}/{denominator}\"\n\n    empty_screen = (a * b * d) // (c * b)\n    screen_size = a * b\n    ratio = empty_screen / screen_size\n\n    numerator = b * d * ratio\n    denominator = a * c * ratio\n\n    return reduce_fraction(numerator, denominator)"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    # Find the gcd of a and b\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the gcd of c and d\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    # Calculate the empty screen ratio\n    empty_ratio = lcm(a, b) / lcm(c, d)\n\n    # Calculate the p and q values of the irreducible fraction\n    def fraction(numerator, denominator):\n        while denominator % numerator == 0:\n            numerator, denominator = denominator, numerator\n        return numerator, denominator\n\n    p, q = fraction(empty_ratio, 1)\n\n    # Print the answer in the required format\n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    # Find the maximum ratio that the movie can occupy on the screen\n    max_ratio = min(a * d, b * c)\n    \n    # Find the minimum ratio that the movie can occupy on the screen\n    min_ratio = max(a * d, b * c)\n    \n    # Find the empty screen area\n    empty_screen = b * c - max_ratio * a\n    \n    # Find the total screen area\n    total_screen = a * b\n    \n    # Calculate the ratio of empty screen to the total screen area\n    ratio = empty_screen / total_screen\n    \n    # Convert the ratio to an irreducible fraction\n    p, q = reduced_fraction(ratio)\n    \n    # Print the answer as a string\n    return f\"{p}/{q}\"\n\ndef"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    # Calculate the ratio of empty screen\n    p = (a * d) * (c * b) // ((a * d) + (c * b))\n    q = (a * d) * (c * b)\n\n    # Find the irreducible fraction\n    def gcd(m, n):\n        while m % n != 0:\n            m, n = n, m % n\n        return n\n\n    def simplify(p, q):\n        div = gcd(p, q)\n        return p // div, q // div\n\n    p, q = simplify(p, q)\n\n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    # Check if the monitor's ratio is equal to the movie's ratio\n    if a == c and b == d:\n        return \"1/1\"\n\n    # Calculate the width and height of the monitor\n    monitor_width = a * b\n    monitor_height = b * d\n\n    # Calculate the width and height of the movie\n    movie_width = c * b\n    movie_height = d * b\n\n    # Calculate the ratio of empty screen to the total screen size\n    empty_screen_ratio = (monitor_width - movie_width) / monitor_width\n\n    # Calculate the greatest common divisor of p and q\n    def gcd(p, q):\n        while q != 0:\n            p, q = q, p % q\n        return p\n\n    # Calculate the irreducible fraction\n    p = int(empty_screen_ratio * monitor_width)\n    q = gcd(p, monitor_width)\n\n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 753,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    # Calculate the maximum area that the movie can occupy on the screen\n    max_area = a * b * c * d\n    \n    # Calculate the area of the empty screen\n    empty_area = (b * d - a * c) * (a * d - b * c)\n    \n    # Calculate the ratio of empty screen to the total screen size\n    ratio = empty_area / max_area\n    \n    # Find the irreducible fraction representation of the ratio\n    p, q = 1, 1\n    while q % 2 == 0 and p % 2 == 0:\n        p *= 2\n        q *= 2\n        \n        if p * c - q * d < 0 or p * a - q * b < 0:\n            p += 1\n            q += 1\n    \n    while q % p == 0 and p % 2 == 0:\n        p //= 2\n        q //= 2\n    \n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    colors = stdin.splitlines()[1]\n\n    count = 0\n    for i in range(1, n):\n        if colors[i] != colors[i-1]:\n            count += 1\n\n    return count\n\ndef"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = list(map(str, stdin.split()))\n    n = int(n)\n    s = s.strip()\n\n    count = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n\n    count = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            count += 1\n\n    return count\n\n\ndef"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n    s = list(s)\n\n    count = 0\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    \n    count = 0\n    prev_color = s[0]\n    for i in range(1, n):\n        if prev_color == s[i]:\n            count += 1\n        prev_color = s[i]\n        \n    return count\n"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = stdin.split('\\n')[1]\n    count = 0\n    for i in range(n-1):\n        if colors[i] == colors[i+1]:\n            count += 1\n    return count\n\nprint(solution(input())) "
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    colors = stdin.splitlines()[1]\n\n    count = 0\n    for i in range(1, n):\n        if colors[i] != colors[i - 1]:\n            count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    count = 0\n    \n    for i in range(1, n):\n        if s[i-1] != s[i]:\n            count += 1\n    return count\n\n\nstdin = '''\n5\nRRRRR\n'''\nprint(solution(stdin)) "
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    count = 0\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n    return count\n"
    },
    {
        "number": 754,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    colors = stdin[1]\n    count = 0\n    for i in range(1, n):\n        if colors[i-1] != colors[i]:\n            count += 1\n    return count\n\n\nstdin = input().split()\nn = int(stdin[0])\ncolors = stdin[1]\n\nprint(solution(stdin)) "
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = [1, 2, 3, 4, 5]\n    min_steps = float('inf')\n    for step in steps:\n        if x % step == 0:\n            min_steps = min(min_steps, x // step)\n    return min_steps"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x == 1:\n        return \"1\"\n    else:\n        min_steps = 1\n        while x > 1:\n            if x % 2 == 0:\n                x //= 2\n                min_steps += 1\n            elif x % 5 == 0:\n                x //= 5\n                min_steps += 1\n            elif x % 4 == 0:\n                x //= 4\n                min_steps += 1\n            else:\n                x -= 1\n                min_steps += 1\n        return str(min_steps)\n\n\ndef"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = [1, 2, 3, 4, 5]\n    min_steps = float('inf')\n\n    for step in steps:\n        num_steps = x // step\n        remainder = x % step\n        if remainder == 0:\n            min_steps = num_steps\n            break\n        else:\n            min_steps = min(min_steps, num_steps + 1)\n\n    return str(min_steps)\n\n\ninput_string = \"5\"\nprint(solution(input_string)) "
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x == 1:\n        return \"1\"\n    elif x <= 5:\n        return \"2\"\n    else:\n        return \"3\"\n"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    min_steps = 0\n    if x == 1:\n        min_steps = 1\n    elif x == 2:\n        min_steps = 2\n    elif x == 3:\n        min_steps = 1\n    elif x == 4:\n        min_steps = 3\n    elif x == 5:\n        min_steps = 1\n    elif x == 6:\n        min_steps = 4\n    elif x == 7:\n        min_steps = 2\n    elif x == 8:\n        min_steps = 5\n    elif x == 9:\n        min_steps = 3\n    elif x == 10:\n        min_steps = 4\n    elif x == 11:\n        min_steps = 5\n    elif x == 12:\n        min_steps = 3\n    elif x == 13:\n        min_steps = 4\n    elif x == 14:\n        min_steps = 5\n    elif x == 15:\n        min_steps = 4\n    elif x == 16:\n        min_steps = 5\n    elif x == 17:\n        min_steps = 5\n    elif x == 18:\n        min_steps = 6\n    elif x == 19:\n        min_steps = 4\n    elif x == 20:\n        min_steps = 5\n    elif x == 21:\n        min_steps = 5\n    elif x == 22:\n        min_steps = 6\n    elif x == 23:\n        min_steps = 5\n    elif x == 24:\n        min_steps = 6\n    elif x == 25:\n        min_steps = 6\n    elif x == 26:\n        min_steps = 7\n    elif x == 27:\n        min_steps = 5\n    elif x == 28:\n        min_steps = 6\n    elif x == 29:\n        min_steps = 6\n    elif x == 30:\n        min_steps = 7\n    elif x == 31:\n        min_steps = 6\n    elif x == 32:\n        min_steps = 7\n    elif x == 33:\n        min_steps = 7\n    elif x == 34:\n        min_steps = 8\n    elif x == 35:\n        min_steps = 6\n    elif x == 36:\n        min_steps = 7\n    elif x == 37:\n        min_steps = 7\n    elif x == 38:\n        min_steps = 8\n    elif x == 39:\n        min_steps = 7\n    elif x == 40:\n        min_steps = 8\n    elif x == 41:\n        min_steps = 8\n    elif x == 42:\n        min_steps = 9\n    elif x == 43:\n        min_steps = 7\n    elif x == 44:\n        min_steps = 8\n    elif x == 45:\n        min_steps = 8\n    elif x == 46:\n        min_steps = 9\n    elif x == 47:\n        min_steps = 8\n    elif x == 48:\n        min_steps = 9\n    elif x == 49:\n        min_steps = 9\n    elif x == 50:\n        min_steps = 10\n    elif x == 51:\n        min_steps = 9\n    elif x == 52:\n        min_steps = 10\n    elif x == 53:\n        min_steps = 10\n    elif x == 54:\n        min_steps = 11\n    elif x == 55:\n        min_steps = 10\n    elif x == 56:\n        min_steps = 11\n    elif x == 57:\n        min_steps = 11\n    elif x == 58:\n        min_steps = 12\n    elif x == 59:\n        min_steps = 11\n    elif x"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    min_steps = 0\n    for i in range(1, 6):\n        if x % i == 0:\n            min_steps = i\n            break\n    return str(min_steps)\n"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = [x - i for i in range(1, x + 1)]\n    min_steps = min([abs(step) for step in steps])\n    return str(min_steps)\n"
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    \n    min_steps = float('inf')\n    \n    for i in range(1, 6):\n        if x % i == 0:\n            min_steps = min(min_steps, x // i + i)\n    \n    return min_steps\n\n\ninput_string = \"\"\"5\n12\"\"\"\n\noutput_string = \"\"\n\nfor line in input_string.splitlines():\n    output_string += str(solution(line)) + \"\\n\"\n\nprint(output_string) "
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    count = 0\n    while x > 5:\n        x -= 5\n        count += 1\n    if x == 5:\n        count += 1\n    elif x == 1:\n        count += 2\n    elif x == 2:\n        count += 3\n    elif x == 3:\n        count += 4\n    elif x == 4:\n        count += 4\n    return str(count)\n\n\ninput_data = \"12\"\nprint(solution(input_data)) "
    },
    {
        "number": 755,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = [1, 2, 3, 4, 5]\n    min_steps = float('inf')\n    \n    for step in steps:\n        num_steps = x // step\n        remainder = x % step\n        if remainder != 0:\n            num_steps += 1\n        min_steps = min(min_steps, num_steps)\n    \n    return str(min_steps)\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    minutes = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    # Check for 15 consecutive boring minutes\n    count_boring = 0\n    for i in range(n-1):\n        if minutes[i+1] - minutes[i] == 1:\n            count_boring += 1\n            if count_boring == 15:\n                return str(minutes[i] + 15)\n        else:\n            count_boring = 0\n    \n    # If there are no 15 consecutive boring minutes, watch the whole game\n    return str(minutes[n-1])"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    interesting_minutes = list(map(int, input_list[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 15, n):\n            if interesting_minutes[j] - interesting_minutes[i] <= 14:\n                count = j - i + 1\n                break\n            else:\n                count = j - i\n                break\n        break\n\n    return str(count)\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n    \n    count = 0\n    for i in range(n):\n        count += t[i] - t[i-1]\n    \n    for i in range(n, len(t) - 1):\n        if t[i] - t[i-n] < 15:\n            count += t[i] - t[i-n]\n        else:\n            count += 15\n    \n    return str(count)"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if t[i] - t[i - 1] != 1:\n            return str(i)\n    return str(n)\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    times = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        count += times[i] - i\n\n    if count >= 15:\n        result = count - (count % 15)\n    else:\n        result = count\n\n    return str(result)\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    t = sorted(set(t))\n    count = 0\n    for i in range(n):\n        count += t[i]\n        if i >= 14 and t[i] == t[i-15]:\n            break\n    return count\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    t = list(map(int, input_list[1].split()))\n\n    count = 0\n    for i in range(n):\n        if t[i] > t[i+1]:\n            count += 1\n            if count == 15:\n                break\n        else:\n            count = 0\n\n    return str(t[i+1-15] if count == 15 else t[-1])\n\n\ndef"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n\n    count = 0\n    consecutive_boring = 0\n\n    for i in range(n):\n        if t[i] < 90 - 15:\n            count += t[i] - t[i - 1]\n            consecutive_boring = 0\n        else:\n            count += 90 - t[i - 1]\n            consecutive_boring = 15\n\n        if consecutive_boring == 15:\n            count += 15\n            consecutive_boring += 1\n            if consecutive_boring == 15:\n                break\n\n    return str(count)\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    interesting_minutes = list(map(int, input_list[1].split()))\n\n    boring_minutes = [0] * 15\n    count_boring_minutes = 0\n    count_interesting_minutes = 0\n\n    for i in range(1, len(interesting_minutes)):\n        if interesting_minutes[i] - interesting_minutes[i-1] == 1:\n            count_interesting_minutes += 1\n        else:\n            count_interesting_minutes = 1\n        if count_interesting_minutes <= 15:\n            continue\n        for j in range(1, 15):\n            boring_minutes[j] += 1\n            if boring_minutes[j] >= count_interesting_minutes - 15:\n                count_boring_minutes = j\n                break\n        if count_boring_minutes >= 15:\n            break\n\n    if count_boring_minutes < 15:\n        count_boring_minutes = 15\n\n    return len(interesting_minutes) - count_boring_minutes + 1\n"
    },
    {
        "number": 756,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    interesting_minutes = list(map(int, stdin.split()[1:]))\n    count = 0\n    consecutive_boring_minutes = 0\n    while consecutive_boring_minutes < 15 and count < 90:\n        if count < n and interesting_minutes[count] < 90:\n            count += 1\n        else:\n            consecutive_boring_minutes += 1\n            count += 1\n\n    return str(count - consecutive_boring_minutes)\n"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    if k < m:\n        return -1\n\n    min_filters = 0\n    max_sockets = 0\n\n    for i in range(n):\n        max_sockets += a[i]\n\n    if max_sockets < m:\n        return -1\n\n    while max_sockets >= m:\n        min_filters += 1\n        max_sockets -= k\n        for i in range(n):\n            max_sockets += a[i]\n\n    return min_filters\n"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    if k < m:\n        return -1\n\n    total_sockets = 0\n    for i in range(n):\n        total_sockets += a[i]\n\n    if total_sockets < m:\n        return -1\n\n    total_sockets -= k\n\n    current_supply_line_filters = 0\n    while total_sockets > 0 and current_supply_line_filters < n:\n        current_supply_line_filters += 1\n        total_sockets -= a[current_supply_line_filters - 1]\n\n    if total_sockets > 0:\n        return -1\n\n    return current_supply_line_filters\n"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Initialize the graph with n nodes\n    graph = [[] for _ in range(n + m)]\n\n    # Add edges to the graph\n    for i, num_sockets in enumerate(a):\n        # Add an edge for each socket to the electricity\n        graph[i].append((n + m - 1, 1))\n        # Add an edge for each socket to the supply-line filter\n        graph[n + i].append((i, num_sockets))\n\n    # Perform Dijkstra's algorithm on the graph\n    dist = [float('inf')] * (n + m)\n    dist[n + m - 1] = 0\n\n    for _ in range(n + m - 1):\n        # Find the node with the smallest distance\n        min_node = None\n        min_dist = float('inf')\n        for node in range(n + m):\n            if dist[node] < min_dist:\n                min_node = node\n                min_dist = dist[node]\n\n        # Update the distance for all the neighbors\n        for neighbor, weight in graph[min_node]:\n            new_dist = dist[min_node] + weight\n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n\n    # Check if the graph is connected\n    if dist.count(float('inf')) == len(dist):\n        return -1\n\n    # Count the number of supply-line filters needed\n    needed_filters = 0\n    for i in range(n):\n        if dist[i] == float('inf'):\n            return -1\n        if dist[i] > 0:\n            needed_filters += 1\n\n    return needed_filters\n"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    if k == 1:\n        return -1\n    min_filter_count = 0\n    sockets = k\n\n    while m > 0:\n        min_filter_count += 1\n        for i in range(n):\n            if a[i] <= sockets:\n                sockets += a[i] - 1\n                m -= 1\n                if m == 0:\n                    break\n        if sockets >= m:\n            return -1\n\n    return min_filter_count\n\n\ndef"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    total_sockets = sum(a)\n    if m > total_sockets:\n        return 1\n    if m == total_sockets:\n        return 1\n    if m < total_sockets:\n        return -1\n    \n    count = 0\n    for i in range(n):\n        if a[i] + count <= k:\n            count += a[i]\n    return count if count >= m else -1\n"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    min_supply_filters = 1\n    sockets = k\n    \n    for i in range(n):\n        if a[i] > sockets:\n            min_supply_filters += 1\n            sockets = k\n        sockets -= a[i]\n        \n        if sockets == 0:\n            min_supply_filters += 1\n            sockets = k\n    \n    if sockets < m:\n        return -1\n    else:\n        return min_supply_filters"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if k < m:\n        return -1\n    \n    free_sockets = k\n    for i in range(n):\n        free_sockets -= a[i]\n        if free_sockets < 0:\n            return i + 1\n        \n    return n\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(solution(stdin))"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if m + sum(a) < k:\n        return -1\n    \n    if m <= k:\n        return 0\n    \n    min_filters = 0\n    while k > 0:\n        min_filters += 1\n        k -= n\n        if k < 0:\n            k = 0\n    \n    return min_filters\n\n\ninput_str = \"\"\"3 5 3\n3 1 2\"\"\"\n\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    total_sockets = sum(a) + k\n    if m > total_sockets:\n        return -1\n\n    min_filters = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        min_filters += 1\n        m -= a[i]\n        a[i] = 0\n\n    if m > 0:\n        return -1\n\n    return min_filters\n\ndef"
    },
    {
        "number": 757,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        if m <= k:\n            return 1\n        else:\n            return -1\n    \n    sum_a = sum(a)\n    min_filter_count = n\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_a[i] += sum_a[j]\n    min_filter_count = min(min_filter_count, sum_a)\n    \n    if min_filter_count >= m:\n        return min_filter_count\n    else:\n        return -1\n\n\ninput_string = \"\"\"3 5 3\n3 1 2\n\n4 7 2\n3 3 2 4\n\n5 5 1\n1 3 1 2 1\"\"\"\n\noutput = \"\"\nfor i in range(len(input_string.split(\"\\n\")) - 1):\n    output += str(solution(input_string.split(\"\\n\")[i])) + \"\\n\"\n\nprint(output)\n"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    stack = list(input())\n    \n    max_ops = 0\n    blue_count = stack.count('B')\n    \n    while blue_count > 0:\n        while stack[-1] != 'B':\n            stack.pop()\n            max_ops += 1\n        stack.pop()\n        stack.append('R')\n        max_ops += 1\n        blue_count = stack.count('B')\n    \n    return str(max_ops)\n\ndef"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    initial_state = stdin.splitlines()[1]\n    \n    stack = []\n    for ball in initial_state:\n        if ball == 'R':\n            stack.append(ball)\n        elif ball == 'B':\n            stack.append(ball)\n    \n    max_operations = 0\n    \n    while stack and stack[-1] == 'B':\n        max_operations += 1\n        stack.pop()\n        if stack and stack[-1] == 'R':\n            stack.pop()\n            stack.append('B')\n        else:\n            stack.append('R')\n    \n    return max_operations\n"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    stack = list(input())\n    \n    red_balls = 0\n    blue_balls = 0\n    \n    for i in range(n):\n        if stack[i] == 'R':\n            red_balls += 1\n        else:\n            blue_balls += 1\n    \n    max_operations = 0\n    \n    while blue_balls > 0:\n        max_operations += 1\n        red_balls -= 1\n        blue_balls -= 1\n        if red_balls > 0:\n            red_balls -= 1\n            blue_balls += 1\n    \n    return max_operations\n\n\ndef"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    count = 0\n    while s.count('B') > 0 and s.count('R') > 0:\n        while s[-1] == 'R':\n            s = s[:-1]\n        while s[0] == 'B':\n            s = s[1:]\n        count += 1\n    \n    return count"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stack = list(stdin.split('\\n')[1])\n    \n    operations = 0\n    while stack.count('B') > 0 and operations < n:\n        stack.pop()\n        if stack:\n            if stack[-1] == 'R':\n                stack.pop()\n                stack.append('B')\n            else:\n                break\n        operations += 1\n    \n    return operations\n"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    initial_state = stdin[1]\n\n    stack = []\n    red_count = 0\n    blue_count = 0\n\n    # Pop red balls\n    for i in range(len(initial_state)):\n        if initial_state[i] == 'R':\n            red_count += 1\n        elif initial_state[i] == 'B':\n            blue_count += 1\n        while red_count > 0:\n            stack.append('R')\n            red_count -= 1\n\n    # Push blue balls\n    while blue_count < n:\n        stack.append('B')\n        blue_count += 1\n\n    # Apply operations\n    operations = 0\n    while stack[-1] == 'R':\n        stack.pop()\n        stack.append('B')\n        operations += 1\n\n    return str(operations)\n"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    stack = list(stdin.splitlines()[1])\n    \n    count = 0\n    while stack and stack[-1] == \"R\":\n        stack.pop()\n        if not stack:\n            break\n        if stack[-1] == \"B\":\n            stack[-1] = \"R\"\n            count += 1\n    \n    if stack:\n        for i in range(len(stack)):\n            if stack[-1] == \"B\":\n                stack[-1] = \"R\"\n                count += 1\n            else:\n                break\n    \n    return count"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    red_count = s.count('R')\n    blue_count = n - red_count\n\n    if blue_count == 0:\n        return 0\n\n    max_ops = 0\n    current_red_count = red_count\n    current_blue_count = blue_count\n\n    while current_blue_count > 0:\n        if current_red_count == 0:\n            max_ops += 1\n            current_blue_count -= 1\n            continue\n\n        max_ops += 1\n        current_red_count -= 1\n        current_blue_count -= 1\n\n    return max_ops"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    stack = list(stdin.splitlines()[1])\n    operations = 0\n\n    while stack and stack[-1] == \"R\":\n        stack.pop()\n        operations += 1\n\n    if not stack:\n        return \"0\"\n\n    while stack and stack[-1] == \"B\":\n        stack.pop()\n        stack.append(\"R\")\n        operations += 1\n\n    while len(stack) < n:\n        stack.append(\"B\")\n        operations += 1\n\n    return str(operations)\n\n\ndef"
    },
    {
        "number": 758,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stack = list(stdin.split('\\n')[1])\n    \n    operations = 0\n    while 'B' in stack:\n        top_color = stack[-1]\n        if top_color == 'R':\n            stack.pop()\n            stack.append('B')\n        else:\n            stack.pop()\n            stack.append('R')\n        operations += 1\n    \n    return str(operations)\n\n\ndef"
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    hh, mm = map(int, input_list[0].split())\n    H, D, C, N = map(int, input_list[1].split())\n\n    hunger_at_start = H\n    time_at_start = hh * 60 + mm\n    time_at_end = 20 * 60\n\n    if time_at_start >= time_at_end:\n        min_amount = (time_at_start - time_at_end) // 15 * C * N\n    else:\n        min_amount = 0\n\n    hunger_after_store = min(H + (time_at_start - time_at_end) // 15 * C * N * N, 0)\n\n    while hunger_after_store > 0:\n        min_amount += hunger_after_store * (1 - 0.2 * (time_at_start >= time_at_end))\n        hunger_after_store = min(H + (time_at_start - time_at_end) // 15 * C * N * N, 0)\n        time_at_start += 1\n\n    return f\"{min_amount:.4f}\" "
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.splitlines()[0].split())\n    H, D, C, N = map(int, stdin.splitlines()[1].split())\n\n    # Calculate the number of minutes since the start of the day\n    minutes = hh * 60 + mm\n\n    # Calculate the total hunger points the cat has accumulated since the start of the day\n    total_hunger = H + D * (minutes - 1)\n\n    # Determine if the cat is fed or not\n    if total_hunger <= 0:\n        return \"0.0000\"\n\n    # Calculate the total cost of buns\n    bun_cost = C * (1 - 0.2 if minutes >= 1200 else 0)\n    total_buns = total_hunger // N\n\n    # Calculate the total cost of buns with the discount\n    discounted_bun_cost = bun_cost * (1 - 0.2 if minutes >= 1200 else 0)\n    total_discounted_buns = total_buns // 20 * 18 + total_buns % 20\n\n    # Calculate the total cost\n    total_cost = total_discounted_buns * discounted_bun_cost\n\n    # Return the total cost as a string to 4 decimal places\n    return f\"{total_cost:.4f}\" "
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, input().split())\n    H, D, C, N = map(int, input().split())\n\n    t = 20\n    m = 0\n    M = 0\n    if hh >= t and mm >= t:\n        M = C * (N - (mm - t) // 60 * N)\n        m = N - (mm - t) % 60\n\n    if hh >= t and mm < t:\n        M = C * N\n        m = N\n\n    if hh < t:\n        M = C * (N - (t - hh) // 60 * N)\n        m = N - (t - hh) % 60\n\n    T = H + m\n\n    while T > 0:\n        T -= D\n\n    return f\"{M + T * C:.4f}\""
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split()[:2])\n    H, D, C, N = map(int, stdin.split()[2:])\n    \n    # Calculate the time for which the cat's hunger level increases\n    time_increase = (hh * 60 + mm) * D\n    \n    # Calculate the total hunger level with 20% discount\n    cat_hunger = H + time_increase\n    if hh >= 20:\n        cat_hunger *= 0.8\n    \n    # Calculate the minimum amount of money to feed the cat\n    min_money = 0\n    while cat_hunger > 0:\n        min_money += C * N\n        cat_hunger -= N\n    \n    return f\"{min_money:.4f}\""
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split()[0].split(':'))\n    H, D, C, N = map(int, stdin.split()[1].split())\n    \n    if hh == 20 and 0 <= mm <= 59:\n        H = min(H + (mm // 15) * N, 1000)\n    \n    total_minutes = H * D\n    if total_minutes >= 15 and C <= 15:\n        total_minutes -= 15\n    total_minutes //= N\n    \n    total_cost = total_minutes * C\n    if hh >= 20:\n        total_cost *= 0.8\n    \n    return f\"{total_cost:.4f}\"\n\ninput_data = '''\n19 00\n255 1 100 1\n\n17 41\n1000 6 15 11\n'''\n\noutput_data = '''\n25200.0000\n1365.0000\n'''\n\ninput_data = input_data.split('\\n')\noutput_data = output_data.split('\\n')\n\nfor i in range(2):\n    stdin = input_data[i * 2] + '\\n' + input_data[i * 2 + 1]\n    expected_output = output_data[i]\n    result = solution(stdin)\n    if abs(float(result) - float(expected_output)) <= 1e-4:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\n        print(\"Expected:\", expected_output)\n        print(\"Got:\", result)\n        print(\"Error:\", abs(float(result) - float(expected_output)))"
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    first_line = input_data[0].split(' ')\n    second_line = input_data[1].split(' ')\n    \n    hh, mm = int(first_line[0]), int(first_line[1])\n    H, D, C, N = int(second_line[0]), int(second_line[1]), int(second_line[2]), int(second_line[3])\n    \n    if 20 <= hh < 22:\n        total_minutes = 120 - (hh * 60 + mm)\n        total_buns = total_minutes // 15\n        cost_per_bun = C + C * 0.2 if total_minutes >= 120 else C\n        total_cost = total_buns * cost_per_bun\n        H = H - total_buns * N\n        \n        while H > 0:\n            total_cost += cost_per_bun\n            H = H - N\n        \n        return f'{total_cost:.4f}'\n    else:\n        total_minutes = 60 - (hh * 60 + mm)\n        total_buns = total_minutes // 15\n        cost_per_bun = C + C * 0.2 if total_minutes >= 60 else C\n        total_cost = total_buns * cost_per_bun\n        H = H - total_buns * N\n        \n        while H > 0:\n            total_cost += cost_per_bun\n            H = H - N\n        \n        return f'{total_cost:.4f}'"
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, input().split())\n    H, D, C, N = map(int, input().split())\n    \n    total_time = 20 * 60\n    if (hh == 20 and mm < 40) or (hh < 20 and hh >= 19) or (hh >= 17 and hh <= 19):\n        total_time = 19 * 60\n    \n    total_time_without_store = (hh * 60 + mm) % total_time\n    total_time_with_store = total_time - total_time_without_store\n    \n    max_hunger = H - (total_time_without_store * D)\n    \n    if max_hunger <= 0:\n        return \"0.0000\"\n    \n    min_spent = float('inf')\n    for i in range(1, int(max_hunger / C) + 1):\n        spent = C * i\n        if total_time_with_store % 60 >= 30 and i % 2 == 1:\n            continue\n        \n        if spent * (1 - 0.2) <= min_spent:\n            min_spent = spent * (1 - 0.2)\n    \n    if min_spent == float('inf'):\n        return \"0.0000\"\n    \n    return format(min_spent, '.4f')"
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, input().split())\n    H, D, C, N = map(int, input().split())\n\n    if hh >= 20:\n        hunger = H + (hh - 20) * D\n    else:\n        hunger = H\n\n    if hunger <= 0:\n        return \"0.0000\"\n\n    buns_needed = (hunger + N - 1) // N\n    total_cost = buns_needed * C\n\n    if hh >= 20:\n        total_cost *= 0.8\n\n    return f\"{total_cost:.4f}\" "
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    hh, mm = map(int, input_data[0].split(' '))\n    H, D, C, N = map(int, input_data[1].split(' '))\n\n    if hh == 20 and mm >= 0 and mm <= 59:\n        buns_to_buy = ((H + (20 - hh) * D) // N) * C\n    else:\n        buns_to_buy = ((H + (20 - hh) * D) // N) * C * 1.2\n\n    return f\"{buns_to_buy:.3f}\""
    },
    {
        "number": 759,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    hh, mm = map(int, input_data[0].split())\n    H, D, C, N = map(int, input_data[1].split())\n\n    if hh == 20 and mm == 0:\n        return str(C * (H // N) + (C * 0.8 * (H % N)))\n    else:\n        return str(C * (H // N) + (C * 0.8 * (H % N)) + (D * (hh * 60 + mm - 20 * 60) // 60))\n\ninput_data = '''19 00\n255 1 100 1\n17 41\n1000 6 15 11'''\n\noutput_data = input_data.split('\\n')\n\nfor i in range(0, len(output_data), 2):\n    print(f\"Input:\\n{output_data[i]}\\n{output_data[i+1]}\\n\")\n    print(f\"Output:{solution(output_data[i] + '\\n' + output_data[i+1])}\\n\") "
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = input()\n    k = int(input())\n    s = s + s[-1]*k\n    n = len(s)\n    max_l = 0\n    for i in range(1, n//2+1):\n        if s[i-1] == s[i+i-1] and s[i] == s[i+i]:\n            max_l = max(max_l, i+i)\n    return max_l"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input().split()\n    s = s + \"\".join([s[-1]] * int(k))\n    n = len(s) // 2\n    max_len = 0\n    for i in range(1, n + 1):\n        if s[i - 1] == s[i] and s[i] == s[2 * i - 1] and s[2 * i - 1] == s[2 * i]:\n            max_len = max(max_len, 4 * i)\n    print(max_len)\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    s = input_list[0]\n    k = int(input_list[1])\n    s = s + 'a' * k\n    n = 1\n    l_max = 0\n    while n <= len(s) // 2:\n        l = 2 * n\n        count = 0\n        for i in range(len(s) - l + 1):\n            if s[i:i + l] == s[i + n:i + n + l]:\n                count += 1\n        if count > 0:\n            l_max = max(l_max, l + n)\n        n += 1\n    return l_max\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input().split()\n    k = int(k)\n\n    s = s + 'a' * k\n\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        j = i + 1\n        while j < n and s[i] + j - i == s[j]:\n            j += 1\n        max_len = max(max_len, j - i)\n\n    return max_len\n\n\nstdin = \"\"\"\naaba\n2\n\"\"\"\nprint(solution(stdin))  # Output: 6\n\nstdin = \"\"\"\naaabbbb\n2\n\"\"\"\nprint(solution(stdin))  # Output: 6\n\nstdin = \"\"\"\nabracadabra\n10\n\"\"\"\nprint(solution(stdin))  # Output: 20 "
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split('\\n')\n    s += s[:k]\n    n = len(s)\n    max_l = 0\n\n    for i in range(n):\n        l = 1\n        while i + l < n and s[i] == s[i + l]:\n            l += 1\n        max_l = max(max_l, l)\n\n    return max_l\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input().split()\n    s = s + ''.join(sorted(set(s), key=s.index)) * int(k)\n    n = len(s)\n    l = 1\n    while l <= n // 2:\n        if s.count(s[:l]) * l == n:\n            return n // l * l\n        l += 1\n    return n // l * l\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = input().strip()\n    k = int(input().strip())\n    \n    # concatenate the string and the added characters\n    new_s = s + s[-k:]\n    \n    # define a helper function to check if a substring is a tandem repeat\n    def is_tandem(substring):\n        return all(substring[i] == substring[i+1] for i in range(len(substring)-1))\n    \n    # iterate through the new string and check if there is a tandem repeat\n    for i in range(len(new_s)-1):\n        if is_tandem(new_s[i:i+k]):\n            return k\n    \n    # if there is no tandem repeat, the maximum length of the tandem repeat is 2*k\n    return 2*k\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    s = input_list[0]\n    k = int(input_list[1])\n\n    new_string = s + \"a\" * k\n    max_length = 0\n\n    for i in range(1, len(new_string) - 1):\n        if new_string[i] == new_string[i + 1] and new_string[i] == new_string[i - 1]:\n            j = 2\n            while i + j < len(new_string) and new_string[i] == new_string[i + j]:\n                j += 1\n            max_length = max(max_length, j - 1)\n\n    return max_length\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    s = input_data[0]\n    k = int(input_data[1])\n    new_string = s + s[-k:]\n    max_length = 0\n    for i in range(len(new_string) // 2):\n        if new_string[i] == new_string[i + len(s)]:\n            j = 1\n            while i + j < len(new_string) and new_string[i] == new_string[i + j]:\n                j += 1\n            max_length = max(max_length, j)\n    return max_length\n"
    },
    {
        "number": 760,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = input()\n    k = int(input())\n    max_length = 1\n    \n    while max_length * 2 <= len(s):\n        pattern = s[:max_length] * 2\n        if pattern in s:\n            return max_length\n        max_length += 1\n    \n    return \"0\" "
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_value(slimes: list) -> int:\n        max_value = float('-inf')\n        while len(slimes) > 1:\n            max_slime = max(slimes, key=lambda x: abs(x))\n            max_value = max(max_value, abs(max_slime))\n            slimes = [x - max_slime for x in slimes if x != max_slime]\n        return max_value\n\n    n = int(stdin[0])\n    slimes = list(map(int, stdin[1].split()))\n    max_value = get_max_value(slimes)\n    return str(max_value)\n\ndef"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    slimes = list(map(int, stdin.splitlines()[1].split()))\n    \n    while len(slimes) > 1:\n        if slimes[0] > slimes[1]:\n            slimes[1] = 0\n        else:\n            slimes[0] = 0\n        slimes = [x for x in slimes if x != 0]\n    \n    return str(slimes[0])"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    while len(a) > 1:\n        for i in range(len(a) - 1):\n            if a[i] == a[i + 1]:\n                a[i] -= a[i + 1]\n                a[i + 1] = 0\n\n        a = [x for x in a if x != 0]\n\n    return a[0]\n\n\ninput_stdin = \"\"\"4\n2 1 2 1\n5\n0 -1 -1 -1 -1\"\"\"\n\noutput_stdout = [\n    4,\n    4,\n]\n\n\ndef"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    slimes = list(map(int, stdin.split(\"\\n\")[1].split()))\n    while len(slimes) > 1:\n        if slimes[0] > slimes[1]:\n            slimes[0] -= slimes[1]\n            slimes.pop(1)\n        elif slimes[0] < slimes[1]:\n            slimes[1] -= slimes[0]\n            slimes.pop(0)\n        else:\n            slimes.pop(0)\n            slimes.pop(0)\n    return str(slimes[0])\n\n\nn = int(input())\nstdin = input()\nstdin = stdin.replace(\"\\n\", \" \")\nprint(solution(stdin)) "
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    for _ in range(n - 1):\n        for i in range(n - 1):\n            if a[i] <= a[i + 1]:\n                a[i] = a[i] - a[i + 1]\n                a[i + 1] = 0\n\n    return max(a)"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    slimes = list(map(int, stdin.splitlines()[1].split()))\n    \n    while n > 1:\n        if slimes[0] >= slimes[-1]:\n            slimes[0] -= slimes[-1]\n            slimes.pop()\n        else:\n            slimes[-1] -= slimes[0]\n            slimes.pop(0)\n        n -= 1\n    \n    return str(slimes[0])"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    slimes = list(map(int, input_list[1].split()))\n\n    while len(slimes) > 1:\n        min_index = slimes.index(min(slimes))\n        if min_index == 0:\n            slimes[1] = slimes[1] - slimes[0]\n            del slimes[0]\n        elif min_index == len(slimes) - 1:\n            slimes[-2] = slimes[-2] - slimes[-1]\n            del slimes[-1]\n        else:\n            slimes[min_index - 1] = slimes[min_index - 1] - slimes[min_index]\n            slimes[min_index] = 0\n\n    return str(slimes[0])\n"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n\n    while n > 1:\n        max_value = max(values)\n        values.remove(max_value)\n        n -= 1\n\n    return max(values)\n"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    max_value = float('-inf')\n    \n    while n > 1:\n        max_value = max(max_value, max(a))\n        a = [max(a) - min(a)]\n        n = 1\n    \n    return str(max_value)\n\ndef"
    },
    {
        "number": 761,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n    while len(values) > 1:\n        new_values = []\n        i = 0\n        while i < len(values) - 1:\n            if values[i] == 0:\n                i += 1\n            elif values[i+1] == 0:\n                i += 1\n            elif values[i] <= -values[i+1]:\n                values[i] = 0\n                new_values.append(0)\n                i += 1\n            elif values[i] >= values[i+1]:\n                values[i+1] = 0\n                new_values.append(values[i] - values[i+1])\n                i += 1\n            else:\n                new_values.append(values[i])\n                new_values.append(values[i+1] - values[i])\n                i += 2\n        if i == len(values) - 1:\n            new_values.append(values[i])\n        values = new_values\n    return values[0]\n"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, B = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    if len(a) % 2 != 0:\n        return \"0\"\n\n    total_cost = 0\n    for i in range(1, len(a), 2):\n        total_cost += abs(a[i] - a[i-1])\n\n    max_cuts = total_cost // B\n\n    return str(max_cuts)"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, B = map(int, input_list[0].split())\n    sequence = list(map(int, input_list[1].split()))\n\n    odd_count = sum(1 for x in sequence if x % 2 != 0)\n    even_count = n - odd_count\n\n    if odd_count % 2 != 0:\n        return \"0\"\n\n    cuts = 0\n    while odd_count > 0:\n        if B < odd_count:\n            break\n        cuts += 1\n        B -= odd_count\n        odd_count = sum(1 for x in sequence if x % 2 != 0)\n        even_count = n - sum(1 for x in sequence if x % 2 == 0)\n\n    return str(cuts)\n\ninput_str = \"\"\"6 4\n1 2 5 10 15 20\n4 10\n1 3 2 4\n6 100\n1 2 3 4 5 6\"\"\"\n\noutput = solution(input_str)\nprint(output)"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, B = map(int, input_data[0].split())\n    A = list(map(int, input_data[1].split()))\n\n    # Initialize variables\n    even_count, odd_count = 0, 0\n    even_start, odd_start = 0, 0\n    max_cuts = 0\n\n    # Iterate through the sequence\n    for i, a in enumerate(A):\n        if a % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n        # If we reach the end of the sequence\n        if i == n - 1:\n            # Calculate the number of cuts and update the maximum\n            if even_count == odd_count:\n                max_cuts += 1\n            elif even_count > odd_count:\n                max_cuts += (even_count - odd_count)\n            else:\n                max_cuts += (odd_count - even_count)\n\n            # Reset the counters\n            even_count, odd_count = 0, 0\n\n    # Check if the budget is enough to make the cuts\n    if max_cuts * (max(A) - min(A) + 1) <= B:\n        return str(max_cuts)\n    else:\n        return \"0\"\n"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n, B = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    odd_count = sum(1 for i in a if i % 2 != 0)\n    even_count = n - odd_count\n    if odd_count != even_count:\n        return \"0\"\n    cuts = 0\n    for i in range(n - 1):\n        if a[i] % 2 == a[i + 1] % 2:\n            cuts += 1\n        else:\n            break\n    return str(cuts)\n"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    budget = int(input_list[1])\n    sequence = input_list[2].split()\n\n    # Convert sequence to integers\n    sequence = [int(num) for num in sequence]\n\n    # Count even and odd numbers\n    even_count = sequence.count(2) + sequence.count(4) + sequence.count(6) + sequence.count(8)\n    odd_count = sequence.count(1) + sequence.count(3) + sequence.count(5) + sequence.count(7)\n\n    # Calculate the total cost of cutting the sequence\n    total_cost = 0\n    for i in range(1, len(sequence)):\n        total_cost += abs(sequence[i] - sequence[i-1])\n\n    # Check if the budget is enough to make any cut\n    if total_cost <= budget:\n        return 0\n\n    # Find the maximum possible number of cuts\n    cuts = 1\n    while True:\n        # Calculate the cost of cutting the sequence\n        cost = 0\n        for i in range(1, len(sequence)):\n            cost += abs(sequence[i] - sequence[i-1])\n\n        # Check if the cost is within the budget\n        if cost <= budget:\n            break\n\n        # Calculate the number of cuts\n        cuts += 1\n\n        # Calculate the cost of cutting the sequence after the last cut\n        last_cost = 0\n        for i in range(cuts, len(sequence)):\n            last_cost += abs(sequence[i] - sequence[i-1])\n\n        # Check if the last cost is within the budget\n        if last_cost <= budget:\n            break\n\n        # Calculate the number of cuts between the last and first segments\n        cuts_between = 0\n        for i in range(cuts, len(sequence) - 1):\n            cuts_between += 1\n            if sequence[i] % 2 != sequence[i+1] % 2:\n                break\n\n        # Check if the number of cuts between the last and first segments is within the budget\n        if total_cost + cost + last_cost + cuts_between <= budget:\n            break\n\n    return cuts\n\n\ndef"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, input().split())\n    sequence = list(map(int, input().split()))\n    \n    # Calculate the number of even and odd integers in the sequence\n    even_count, odd_count = 0, 0\n    for num in sequence:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # If the number of even and odd integers are not equal, it is not possible to make cuts\n    if even_count != odd_count:\n        return \"0\"\n    \n    # Initialize the minimum and maximum indices for the cuts\n    min_index, max_index = 0, n - 1\n    \n    # Iterate through the sequence and calculate the cost of the cut\n    cut_cost = 0\n    for i in range(n - 1):\n        if sequence[i] % 2 != sequence[i + 1] % 2:\n            cut_cost += abs(sequence[i] - sequence[i + 1])\n            if cut_cost > B:\n                return str(i - 1)\n    \n    return str(n - 1)"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Initialize variables\n    odd_count = a.count(1)\n    even_count = a.count(2)\n    cut_count = 0\n    cost = 0\n    \n    # Count number of cuts\n    for i in range(n - 1):\n        if a[i] % 2 == a[i + 1] % 2:\n            continue\n        else:\n            cut_count += 1\n            cost += abs(a[i] - a[i + 1])\n            if cost > B:\n                break\n                \n    # Calculate number of cuts with even and odd counts\n    if cost <= B:\n        cut_count_even_odd = cut_count\n        cut_count_odd_even = cut_count\n        for i in range(n - 1):\n            if a[i] % 2 == a[i + 1] % 2:\n                continue\n            else:\n                if a[i] % 2 == 1 and a[i + 1] % 2 == 0:\n                    cut_count_even_odd += 1\n                elif a[i] % 2 == 0 and a[i + 1] % 2 == 1:\n                    cut_count_odd_even += 1\n                if cut_count_even_odd > cut_count_odd_even:\n                    break\n                    \n    # Return the maximum number of cuts\n    if cost <= B:\n        return cut_count\n    elif cut_count_even_odd > cut_count_odd_even:\n        return cut_count_even_odd\n    else:\n        return cut_count_odd_even"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_cost(seq):\n        odd_count = 0\n        even_count = 0\n        for num in seq:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        if odd_count == even_count:\n            return 0\n        elif odd_count > even_count:\n            return abs(odd_count - even_count)\n        else:\n            return abs(even_count - odd_count)\n\n    n, B = map(int, stdin.splitlines()[0].split())\n    seq = list(map(int, stdin.splitlines()[1].split()))\n\n    cost = get_cost(seq)\n    if cost > B:\n        return 0\n    elif cost == 0:\n        return 1\n    else:\n        return 2\n"
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, B = map(int, input_list[0].split())\n    sequence = list(map(int, input_list[1].split()))\n\n    odd_count = sequence.count(1)\n    even_count = sequence.count(2)\n\n    if odd_count != even_count:\n        return \"0\"\n\n    max_cuts = 0\n    current_sum = 0\n\n    for num in sequence:\n        current_sum += num\n        if current_sum % 2 == 0:\n            max_cuts += 1\n        else:\n            current_sum = 0\n\n    return str(max_cuts)\n\n\nstdin = \"\"\"6 4\n1 2 5 10 15 20\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 762,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, B = map(int, input_data[0].split())\n    A = list(map(int, input_data[1].split()))\n\n    def can_cut(segment_count):\n        even_count = sum(A[i] % 2 == 0 for i in range(segment_count))\n        odd_count = sum(A[i] % 2 == 1 for i in range(segment_count))\n        return abs(even_count - odd_count) <= B\n\n    left = 1\n    right = n\n    max_cuts = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_cut(mid):\n            max_cuts = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return str(max_cuts)"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    x = 0\n    total_electricity = 0\n\n    for i in range(n):\n        total_electricity += abs(x - i) * a[i] * 2\n\n    return total_electricity\n\n\ninput_cases = [\n    \"3\\n0 2 1\",\n    \"2\\n1 1\"\n]\n\nfor input_case in input_cases:\n    print(solution(input_case))"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_electricity(n: int, a: list, x: int) -> int:\n        total_electricity = 0\n        for i in range(n):\n            floor_a = a[i]\n            total_electricity += abs(i - x) * floor_a\n        return total_electricity\n\n    def find_min_x(n: int, a: list) -> int:\n        min_x = 0\n        min_electricity = float('inf')\n        for x in range(n):\n            electricity = find_min_electricity(n, a, x)\n            if electricity < min_electricity:\n                min_electricity = electricity\n                min_x = x\n        return min_x\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_x = find_min_x(n, a)\n    min_electricity = find_min_electricity(n, a, min_x)\n\n    return min_electricity"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    min_electricity = 0\n\n    for i in range(n):\n        electricity = 0\n        for j in range(n):\n            if i != j:\n                electricity += abs(a[i] - a[j])\n        min_electricity = max(min_electricity, electricity)\n\n    return str(min_electricity)\n\n\ninput_str = \"\"\"3\n0 2 1\n\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()[1:]))\n    \n    min_electricity = 0\n    for i in range(n):\n        for j in range(n):\n            if abs(i - j) <= 1:\n                continue\n            min_electricity += abs(i - j)\n    min_electricity *= 2\n    \n    return str(min_electricity)\n\ninput_data = \"3\\n0 2 1\"\nprint(solution(input_data)) "
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    people = list(map(int, stdin.splitlines()[1].split()))\n    x = 1  # Starting with the first floor\n    max_people = max(people)\n    total_units = 0\n\n    # Move the elevator to the x-th floor\n    total_units += max_people * abs(x - 1)\n\n    # Move the elevator to the first floor\n    total_units += max_people * abs(1 - x)\n\n    # Move the elevator to the x-th floor\n    total_units += max_people * abs(x - 1)\n\n    return total_units\n"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    \n    x = a.index(max(a))\n    total = 0\n    for i in range(n):\n        for j in range(n):\n            total += abs(i - j) * max(a[i], a[j])\n    \n    return total"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    \n    min_cost = 0\n    for i in range(n):\n        min_cost += sum(abs(j-i) for j in range(n) if a[j] > 0) * 2\n    \n    return min_cost\n"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    x = a[0]\n    sum_of_units = 0\n    \n    for i in range(1, n):\n        sum_of_units += abs(a[i] - a[i-1]) * (i - x)\n        \n    return sum_of_units\n\ndef"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    min_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_cost += abs(a[i] - a[j])\n    return min_cost"
    },
    {
        "number": 763,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n\n    min_electricity = 0\n    for i in range(n):\n        for j in range(n):\n            if abs(i - j) == 1:\n                min_electricity += abs(a[i] - a[j])\n\n    return str(min_electricity)\n\ndef"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    y = stdin.splitlines()[1]\n    k = 0\n    for i in range(n):\n        if y == y[n-i:] + y[:n-i]:\n            k = i\n            break\n    return str(k)\n\nn = 4\ny = \"1010\"\nstdin = f\"{n}\\n{y}\"\nprint(solution(stdin)) "
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    y = stdin.splitlines()[1]\n    \n    count = 0\n    for k in range(n):\n        x = (y * (2 ** k))[:n]\n        if x == y:\n            count += 1\n            \n    return str(count)\n"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    y = input()\n    \n    count = 0\n    \n    for k in range(n):\n        x = y\n        for _ in range(k):\n            x = x[-1] + x[:-1]\n        if x == y:\n            count += 1\n            \n    return str(count)\n\ndef"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n = int(input_list[0])\n    y = input_list[1]\n    k_count = 0\n    \n    for k in range(n):\n        x = y\n        for i in range(k):\n            x = shift_right(x)\n        if x == ''.join(['1' if bit == '0' else '0' for bit in y]):\n            k_count += 1\n    \n    return str(k_count)\n\ndef"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    y = input_list[1]\n\n    k_count = 0\n\n    for i in range(n):\n        if y != '0' * n:\n            x = y[i:] + y[:i]\n            shifted_x = x\n            for j in range(i):\n                shifted_x = shifted_x[-1] + shifted_x[:-1]\n            if xor_operation(x, shifted_x) == '0' * n:\n                k_count += 1\n\n    return str(k_count)\n\n\ndef"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    y = stdin.splitlines()[1]\n    \n    count = 0\n    for k in range(n):\n        x = y\n        for _ in range(k):\n            x = x[-1] + x[:-1]\n        if x == y:\n            count += 1\n            \n    return str(count)\n\n\ndef"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    y = stdin.splitlines()[1]\n    \n    count = 0\n    for k in range(n):\n        x = y\n        for _ in range(k):\n            x = x[-1] + x[:-1]\n        if x == y:\n            count += 1\n            \n    return str(count)\n"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    y = [int(i) for i in stdin.split(\"\\n\")[1]]\n    count = 0\n\n    for k in range(n):\n        x = [(i + k) % n for i in range(n)]\n        if sum(x) == sum(y):\n            count += 1\n\n    return str(count)\n\n\ninput_str = \"4\\n1010\"\nprint(solution(input_str)) # Output: 3 "
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    y = stdin.split('\\n')[1]\n    \n    count = 0\n    for k in range(n):\n        x = y\n        for _ in range(k):\n            x = x[-1] + x[:-1]\n        if x == y:\n            count += 1\n    \n    return str(count)\n"
    },
    {
        "number": 764,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    y = stdin.split('\\n')[1]\n\n    count = 0\n    for k in range(n):\n        x = y\n        for _ in range(k):\n            x = x[-1] + x[:-1]\n        if x == '0' * n:\n            count += 1\n\n    return str(count)\n\n\ninput_str = '''4\n1010'''\nprint(solution(input_str))  # Output: 3 "
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    total_time = T * S\n    download_time = q - 1\n    if total_time <= download_time:\n        return 1\n    else:\n        return total_time // download_time + 1\n\n\ninput_stdin = \"5 2 2\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    if S < T:\n        return \"1\"\n    else:\n        return str((q - 1) * (T // S) + (T % S != 0) + 1)\n\nT, S, q = map(int, input().split())\nprint(solution(str(T) + \" \" + str(S) + \" \" + str(q))) "
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    return max(1, T // (q - 1))\n\nT = 5\nS = 2\nq = 2\nprint(solution(f\"{T} {S} {q}\"))\n\nT = 5\nS = 4\nq = 7\nprint(solution(f\"{T} {S} {q}\"))\n\nT = 6\nS = 2\nq = 3\nprint(solution(f\"{T} {S} {q}\")) "
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    if q == 1:\n        return 1\n    if q > T:\n        return 1 + T // S\n    return 1 + (q - 1) // S\n"
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    return (T - S + 1) // q\n\ndef"
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    a = T // q\n    b = S * q\n    c = (T - b) // a\n    result = a + c\n    return str(result)\n\nT, S, q = map(int, input().split())\nprint(solution(f\"{T} {S} {q}\")) "
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    time_to_restart = (q - 1) // S + 1\n    return time_to_restart\n"
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    if S <= T:\n        return T // (S * (q - 1)) + 1\n    else:\n        return T // S + 1\n\n\ninput_str = \"5 2 2\\n5 4 7\\n6 2 3\"\noutput_str = \"\"\nfor line in input_str.split(\"\\n\"):\n    output_str += str(solution(line)) + \"\\n\"\n\nprint(output_str)"
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    if q == 1:\n        return \"0\"\n    else:\n        return str((T - S) // (q - 1) + 1)"
    },
    {
        "number": 765,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    return T // (q - 1) + 1 if q > 1 else 0\n\nT = int(input())\nS = int(input())\nq = int(input())\n\nresult = solution(str(T) + \" \" + str(S) + \" \" + str(q))\nprint(result)"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n == 1:\n        return \"Yes\"\n\n    for i in range(1, n):\n        if s[:i] == s[n-i:n]:\n            return \"Yes\"\n\n    return \"No\"\n\n\ninput_string = \"zzcxx\"\nprint(solution(input_string)) "
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip().lower()\n    n = len(s)\n    \n    # Find the maximum number of consecutive occurrences of each symbol\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    max_count = max(counts.values())\n    \n    # Check if the string can be split into two subsequences\n    for i in range(1, n - max_count + 1):\n        # Check if the first subsequence is adorable\n        if counts[s[0]] >= max_count - i + 1:\n            if all(s[j] != s[j+i] for j in range(i)):\n                # Check if the second subsequence is adorable\n                if all(s[j] != s[j+i] for j in range(i, i + max_count)):\n                    return \"Yes\"\n    \n    return \"No\"\n\n\ninput_str = \"zzcxx\"\nprint(solution(input_str)) "
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n % 2 == 0:\n        return \"No\"\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n    odd = n % 2\n    for c in count:\n        if count[c] % 2 != odd:\n            return \"No\"\n    return \"Yes\"\n"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_adorable(s[i:j]):\n                return \"Yes\"\n    return \"No\"\n\n\ndef"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip().lower()\n    n = len(s)\n    for i in range(1, n):\n        if s[i] != s[i-1]:\n            continue\n        for j in range(i+1, n):\n            if s[j] != s[j-1]:\n                continue\n            for k in range(j+1, n):\n                if s[k] != s[k-1]:\n                    continue\n                if i != k and j != k:\n                    return \"Yes\"\n    return \"No\"\n\n\ndef"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_adorable(s: str) -> bool:\n        if len(s) % 2 == 1:\n            return False\n        left = set(s[:len(s)//2])\n        right = set(s[len(s)//2:])\n        if len(left) > 1 or len(right) > 1:\n            return False\n        return all(s.count(c) % 2 == 1 for c in left) and all(s.count(c) % 2 == 1 for c in right)\n\n    s = stdin.strip()\n    if len(s) % 2 == 0:\n        left, right = s[:len(s)//2], s[len(s)//2:]\n        if is_adorable(left) and is_adorable(right):\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n\n    def is_adorable(subsequence: str) -> bool:\n        unique_chars = set(subsequence)\n        return len(unique_chars) == 1 or (len(unique_chars) == 2 and None in unique_chars)\n\n    for i in range(len(s)):\n        first_subsequence = s[:i+1]\n        second_subsequence = s[i+1:]\n        if is_adorable(first_subsequence) and is_adorable(second_subsequence):\n            return \"Yes\"\n\n    return \"No\"\n\ndef"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    \n    # Calculate the number of unique characters\n    unique_chars = sum(c > 0 for c in count)\n    \n    # Check if the string can be split into two subsequences\n    if unique_chars <= 2:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n\n    for i in range(len(s)):\n        if s[i] == 'a':\n            s[i] = '1'\n        elif s[i] == 'b':\n            s[i] = '2'\n        elif s[i] == 'c':\n            s[i] = '3'\n\n    for i in range(len(s)):\n        if s[i] == '1':\n            s[i] = 'a'\n        elif s[i] == '2':\n            s[i] = 'b'\n        elif s[i] == '3':\n            s[i] = 'c'\n\n    groups = [0] * len(s)\n    count = 1\n    i = 0\n\n    while i < len(s):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            count = 1\n        groups[i] = count\n        i += 1\n\n    groups.sort()\n\n    for i in range(1, len(groups)):\n        if groups[i] == groups[i - 1]:\n            return \"Yes\"\n    return \"No\"\n"
    },
    {
        "number": 766,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    \n    for i in range(len(s) - 1):\n        if s[i] != s[i+1]:\n            continue\n        for j in range(i + 2, len(s) - 1):\n            if s[j] != s[j+1]:\n                continue\n            if s[i] == s[j+1]:\n                return \"Yes\"\n    return \"No\"\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_pairs(n: int, z: int, points: list) -> int:\n        pairs = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(points[i] - points[j]) >= z:\n                    pairs += 1\n        return pairs\n\n    n, z = map(int, input().split())\n    points = list(map(int, input().split()))\n    result = find_pairs(n, z, points)\n    return str(result)\n\n\ninput_stdin = \"\"\"4 2\n1 3 3 7\"\"\"\n\noutput = solution(input_stdin)\nprint(output)  # Output: \"2\"\n\n\ninput_stdin = \"\"\"5 5\n10 9 5 8 7\"\"\"\n\noutput = solution(input_stdin)\nprint(output)  # Output: \"1\" "
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n\n    # Sort the points by their values\n    x.sort()\n\n    # Initialize variables\n    pairs = 0\n    max_pairs = 0\n    i = 0\n\n    # Iterate through the sorted points\n    while i < n:\n        # Increment the maximum pairs\n        max_pairs += 1\n\n        # Iterate through the remaining points\n        j = i + 1\n        while j < n:\n            # Check if the points can be matched\n            if x[j] - x[i] >= z:\n                # Increment the pair counter\n                pairs += 1\n                j += 1\n            else:\n                break\n\n        # Increment the index\n        i = j\n\n    return str(max_pairs)\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, input().split())\n    xs = list(map(int, input().split()))\n    \n    pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(xs[i] - xs[j]) >= z:\n                pairs += 1\n                break\n    \n    return str(pairs)\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(x[i] - x[j]) >= z:\n                count += 1\n    \n    return str(count)\n\n\ndef"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(x[i] - x[j]) >= z:\n                count += 1\n                break\n    \n    return str(count)\n\n\ninput_string = \"4 2\\n1 3 3 7\\n5 5\\n10 9 5 8 7\\n\"\noutput_string = \"2\\n1\\n\"\n\nsolution_list = input_string.split(\"\\n\")\nresult = []\nfor s in solution_list:\n    result.append(solution(s))"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, input().split())\n    x = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(x[i] - x[j]) >= z:\n                count += 1\n\n    return str(count // 2)\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_match(points: list, z: int) -> int:\n        count = 0\n        matched = set()\n        for i, x_i in enumerate(points):\n            if i in matched:\n                continue\n            for j, x_j in enumerate(points):\n                if j in matched:\n                    continue\n                if abs(x_i - x_j) >= z:\n                    matched.add(i)\n                    matched.add(j)\n                    count += 1\n        return count\n\n    n, z = map(int, stdin.split()[:2])\n    points = list(map(int, stdin.split()[2:]))\n    return find_match(points, z)"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, z = map(int, input_list[0].split())\n    x = list(map(int, input_list[1].split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(x[i] - x[j]) >= z:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def match_points(points: list, z: int) -> int:\n        count = 0\n        matched_points = set()\n        for i in range(len(points)):\n            if i in matched_points:\n                continue\n            for j in range(i + 1, len(points)):\n                if j in matched_points:\n                    continue\n                if abs(points[i] - points[j]) >= z:\n                    count += 1\n                    matched_points.add(i)\n                    matched_points.add(j)\n                    break\n        return count\n\n    n, z = map(int, stdin.splitlines()[0].split())\n    points = list(map(int, stdin.splitlines()[1].split()))\n    return match_points(points, z)\n"
    },
    {
        "number": 767,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    n, z = map(int, stdin.split()[:2])\n    x = list(map(int, stdin.split()[2:]))\n\n    # initialize the result\n    res = 0\n\n    # loop through all pairs of points\n    for i in range(n):\n        for j in range(i + 1, n):\n            # check if the pair can be matched\n            if abs(x[i] - x[j]) >= z:\n                res += 1\n\n    # print the result\n    return str(res)"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    friends_opinions = [line.strip() for line in stdin.split('\\n')]\n    liked_items = [item for item, opinion in enumerate(zip(*friends_opinions)) if 'Y' in opinion]\n    return str(len([item for item in liked_items if liked_items.count(item) >= T]))"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split()[:3])\n    friends_opinions = [list(line) for line in stdin.split()[3:]]\n    liked_items = set()\n\n    for opinion in friends_opinions:\n        for item, like in enumerate(opinion):\n            if like == 'Y':\n                liked_items.add(item)\n\n    return str(len(liked_items))\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split()[:3])\n    friends_likes = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    liked_by_t_friends = [i for i, like in enumerate(friends_likes) if like.count('Y') >= T]\n\n    return len(liked_by_t_friends)"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    friends_opinions = [line.strip() for line in stdin.split('\\n')[1:F + 1]]\n    liked_by_friends = {i: 0 for i in range(I)}\n\n    for opinion in friends_opinions:\n        for item, like in enumerate(opinion):\n            if like == 'Y':\n                liked_by_friends[item] += 1\n\n    count = sum(1 for likes in liked_by_friends.values() if likes >= T)\n\n    return str(count)\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split()[0].split())\n    friends_opinions = stdin.split(\"\\n\")[1:]\n\n    liked_items = [0] * I\n    for opinion in friends_opinions:\n        for i, c in enumerate(opinion):\n            if c == 'Y':\n                liked_items[i] += 1\n\n    count = 0\n    for like in liked_items:\n        if like >= T:\n            count += 1\n\n    return str(count)\n\n\ninput_data = '''\n3 3 2\nYYY\nNNN\nYNY\n'''\n\nresult = solution(input_data)\nprint(result)  # Output: 2\n\n\ninput_data = '''\n4 4 1\nNNNY\nNNYN\nNYNN\nYNNN\n'''\n\nresult = solution(input_data)\nprint(result)  # Output: 4\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    friends_opinions = [stdin[i] for i in range(1, F * I + 1, I)]\n    liked_items = sum(friends_opinions.count('Y') >= T for friends_opinion in friends_opinions)\n    return str(liked_items)\n\n\nstdin = \"3 3 2\\nYYY\\nNNN\\nYNY\"\nprint(solution(stdin))\n\nstdin = \"4 4 1\\nNNNY\\nNNYN\\nNYNN\\nYNNN\"\nprint(solution(stdin)) "
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    friends, items, threshold = map(int, stdin.split()[:3])\n    friends_opinions = stdin.split('\\n')[1:]\n\n    # Count the number of items liked by at least threshold of friends\n    liked_items = sum(1 for opinion in friends_opinions if opinion.count('Y') >= threshold)\n\n    return str(liked_items)\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    likes = [input().split() for _ in range(F)]\n    items = set()\n\n    for i in range(I):\n        total_likes = 0\n        for friend in likes:\n            if friend[i] == 'Y':\n                total_likes += 1\n        if total_likes >= T:\n            items.add(i + 1)\n\n    return str(len(items))\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split()[:3])\n    friends_opinions = stdin.split(\"\\n\")[3:]\n    liked_by_friends = {i: 0 for i in range(I)}\n\n    for opinion in friends_opinions:\n        for i, char in enumerate(opinion):\n            if char == \"Y\":\n                liked_by_friends[i] += 1\n\n    count = 0\n    for likes in liked_by_friends.values():\n        if likes >= T:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 768,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    friends_opinions = []\n    for _ in range(F):\n        friends_opinions.append(stdin.readline().strip())\n\n    count = 0\n    for opinion in friends_opinions:\n        if opinion.count('Y') >= T:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    fraction = a / b\n    if c == 0:\n        if fraction == 0:\n            return \"1\"\n        else:\n            return \"-1\"\n    else:\n        decimal_fraction = str(fraction)[2:].replace(\".\", \"\")\n        if c in decimal_fraction:\n            return str(decimal_fraction.index(str(c)) + 1)\n        else:\n            return \"-1\"\n\n\ndef"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a == 0:\n        return -1\n    gcd, x, y = extended_gcd(b, a)\n    if c not in str(x):\n        return -1\n    else:\n        return str(str(x).find(str(c)) + 1)\n\ndef"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c == 0:\n        return -1\n    a, b = a * 1000000000 + 1, b * 1000000000 + 1\n    for i in range(100000000, b):\n        if i % 10 == c:\n            return i // b\n    return -1\n\n\ninput_str = \"2 3 7\"\nprint(solution(input_str)) "
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c == 0:\n        return 0\n    num = a // b\n    decimal = (a % b) / b\n    decimal = float('{:.6f}'.format(decimal))\n    decimal_str = str(decimal)[2:]\n    pos = decimal_str.find(str(c)) + 2\n    if pos == 0:\n        return -1\n    else:\n        return pos\n\n\ninput_str = \"1 2 0\\n2 3 7\"\noutput_str = \"\"\nfor line in input_str.split(\"\\n\"):\n    output_str += str(solution(line)) + \"\\n\"\n\nprint(output_str) "
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    a = int(input_data[0])\n    b = int(input_data[1])\n    c = int(input_data[2])\n\n    decimal_part = f\"{a // b}.{(a % b):0{len(str(b))}d}\"\n    digit_c_pos = decimal_part.find(str(c)) + 1\n\n    if digit_c_pos == 0:\n        return -1\n    else:\n        return digit_c_pos"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c == 0:\n        return 1\n    if a == 0:\n        return -1\n    gcd, s, t = extended_gcd(a, b)\n    if gcd != 1:\n        raise ValueError(\"Incorrect input: a and b must be coprime.\")\n    if c < 0 or c > 9:\n        raise ValueError(\"Incorrect input: c must be a digit from 0 to 9.\")\n    result = s * a + t * b\n    result //= gcd\n    result *= 10\n    if c in str(result):\n        return str(result).index(str(c)) + 1\n    return -1\n\n\ndef"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    if c == 0:\n        return 1\n    \n    result = 0\n    numerator = a\n    denominator = b\n    counter = 1\n    \n    while numerator < denominator:\n        numerator *= 10\n        counter += 1\n    \n    numerator //= denominator\n    denominator //= 10\n    \n    while counter > 0 and numerator >= 10:\n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if str(remainder)[0] == str(c):\n            return counter\n        \n        counter -= 1\n        numerator = quotient * 10 + remainder\n        \n        if numerator >= denominator:\n            numerator //= denominator\n            denominator //= 10\n    \n    return -1\n"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    a, b, c = map(int, input_str.split())\n\n    if c > 9 or c < 0:\n        return -1\n\n    gcd, s, t = extended_gcd(a, b)\n\n    if gcd != 1:\n        return -1\n\n    c_position = (b * s + t - 1) // c\n\n    if c_position >= 0:\n        return c_position + 1\n    else:\n        return -1\n\ndef"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if c == 0:\n        return -1\n    if b == 1:\n        return 1\n    quotient = a // b\n    remainder = a % b\n    decimal_representation = str(quotient) + '.' + str(remainder) + '(' + str(b) + ')'\n    for i in range(2, len(decimal_representation)):\n        if decimal_representation[i] == str(c) and decimal_representation[i-1] != '(':\n            return i\n    return -1\n\n\ninput_stdin = \"2 3 7\"\nprint(solution(input_stdin))\n"
    },
    {
        "number": 769,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    if c == 0:\n        return -1\n\n    gcd, s, t = extended_gcd(a, b)\n    if c > b // gcd:\n        return -1\n\n    quotient = s * a + t * b\n    result = -1\n    while quotient >= 10:\n        quotient //= 10\n\n    if quotient % 10 == c:\n        result = quotient // b + 1\n\n    return result\n\n\ndef"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    unread_letters = [int(x) for x in stdin.splitlines()[1].split()]\n    unread_count = sum(unread_letters)\n\n    if unread_count == 0:\n        return '0'\n\n    if n == 1 and unread_letters[0] == 1:\n        return '1'\n\n    move_count = 0\n    current_letter = 0\n\n    while unread_letters[current_letter] == 1:\n        current_letter += 1\n        move_count += 1\n\n        if current_letter == n:\n            current_letter = 0\n\n    return str(move_count + unread_count - 1)\n\n\ninput_string = \"\"\"5\n0 1 0 1 0\"\"\"\n\nprint(solution(input_string))  # Output: 3\n\ninput_string = \"\"\"5\n1 1 0 0 1\"\"\"\n\nprint(solution(input_string))  # Output: 4\n\ninput_string = \"\"\"2\n0 0\"\"\"\n\nprint(solution(input_string))  # Output: 0"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    letters = list(map(int, stdin.split('\\n')[1].split()))\n    operations = 0\n    i = 0\n    while i < n:\n        if letters[i] == 0:\n            i += 1\n        else:\n            operations += 1\n            letters[i] = 1\n            if i == 0:\n                operations += 1\n            elif i == n - 1:\n                operations += 1\n            else:\n                if letters[i - 1] == 0:\n                    operations += 1\n                if letters[i + 1] == 0:\n                    operations += 1\n            i += 1\n    return str(operations)\n\n\ninput_string = '''5\n0 1 0 1 0'''\n\nresult = solution(input_string)\nprint(result) "
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    letter_status = list(map(int, stdin.splitlines()[1].split()))\n    unread_letters = sum(letter_status)\n    operations = 0\n    i = 0\n    \n    while unread_letters > 0:\n        if letter_status[i] == 1:\n            letter_status[i] = 0\n            unread_letters -= 1\n            operations += 1\n        i += 1\n        if i == n:\n            i = 0\n    \n    return str(operations)\n"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    letter_states = list(map(int, stdin.splitlines()[1].split()))\n    unread_count = sum(1 for state in letter_states if state == 1)\n\n    if unread_count == 0:\n        return 0\n\n    operations = 0\n    current_index = 0\n\n    while unread_count > 0:\n        operations += 1\n\n        if letter_states[current_index] == 1:\n            letter_states[current_index] = 0\n            unread_count -= 1\n\n        if current_index == n - 1:\n            current_index = 0\n        else:\n            current_index += 1\n\n    return operations"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    letters = [int(i) for i in stdin.splitlines()[1].split()]\n    read_letters = sum(letters)\n    unread_letters = n - read_letters\n\n    if unread_letters == 0:\n        return \"0\"\n    else:\n        return unread_letters + 2\n\n\ninput_str = \"\"\"5\n0 1 0 1 0\n\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    letter_states = list(map(int, stdin.split('\\n')[1].split()))\n    unread_count = letter_states.count(1)\n    operations = 0\n\n    if unread_count > 0:\n        operations += 1\n        letter_states = [i for i in letter_states if i == 1]\n        operations += len(letter_states)\n\n    return str(operations)\n\n\ninput_stdin = \"\"\"5\n0 1 0 1 0\n\"\"\"\n\noutput_stdout = solution(input_stdin)\nprint(output_stdout)"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    letter_list = list(map(int, input().split()))\n    operations = 0\n    \n    for i in range(n):\n        if letter_list[i] == 1:\n            letter_list[i] = 0\n            operations += 1\n    \n    for i in range(n-1, -1, -1):\n        if letter_list[i] == 1:\n            letter_list[i] = 0\n            operations += 1\n    \n    return str(operations)\n\n\ndef"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    letter_list = list(map(int, input().split()))\n    unread_count = sum(letter_list)\n\n    if unread_count == 0:\n        return 0\n\n    operations = 0\n    for i in range(n):\n        if letter_list[i] == 0:\n            continue\n        operations += 1\n        if i != 0 and letter_list[i - 1] == 1:\n            operations += 1\n        letter_list[i] = 0\n\n    return operations\n"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    state = list(map(int, stdin.splitlines()[1].split()))\n    count = 0\n    i = 0\n    while i < n:\n        if state[i] == 0:\n            count += 1\n            state[i] = 1\n        i += 1\n    return count\n"
    },
    {
        "number": 770,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    letters = list(map(int, input().split()))\n    unread_count = letters.count(1)\n    operations = 0\n\n    if unread_count == 0:\n        return str(operations)\n\n    for i in range(n):\n        if letters[i] == 1:\n            letters[i] = 0\n            unread_count -= 1\n            operations += 1\n            if unread_count == 0:\n                break\n\n    if unread_count > 0:\n        operations += unread_count\n\n    return str(operations)\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k, m = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    count_dict = {}\n    for num in a:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    if k > len(a):\n        return \"No\"\n\n    sorted_a = sorted(a)\n    selected_numbers = []\n\n    for i in range(k):\n        for num in sorted_a:\n            if count_dict[num] > 0 and (len(selected_numbers) == 0 or abs(num - selected_numbers[-1]) % m == 0):\n                selected_numbers.append(num)\n                count_dict[num] -= 1\n                break\n\n    if len(selected_numbers) == k:\n        return \"Yes\\n\" + \" \".join(map(str, selected_numbers))\n    else:\n        return \"No\"\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, input().split())\n    nums = list(map(int, input().split()))\n    \n    # Create a dictionary to store the occurrences of each number in the original multiset\n    num_counts = {}\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Check if it is possible to select k numbers in the desired way\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[j] - nums[i]) % m == 0:\n                count = 0\n                selected_nums = []\n                for num in nums:\n                    if num % m == 0:\n                        count += num_counts[num]\n                        selected_nums.append(num)\n                        if count == k:\n                            return \"Yes\\n\" + \" \".join(map(str, selected_nums))\n                \n    return \"No\"\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(selected: set, remain: set) -> bool:\n        for x in remain:\n            for y in selected:\n                if (x - y) % m == 0:\n                    return True\n        return False\n\n    n, k, m = map(int, stdin.split()[:3])\n    multiset = list(map(int, stdin.split()[3:]))\n    multiset.sort()\n\n    selected = set()\n    remain = set(multiset)\n    while len(selected) < k:\n        remain = set(filter(lambda x: x not in selected, remain))\n        if not is_valid(selected, remain):\n            return \"No\"\n        selected.add(min(remain))\n\n    return \"Yes\\n\" + \" \".join(map(str, sorted(selected)))\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, input().split())\n    multiset = list(map(int, input().split()))\n\n    def is_possible(selected):\n        for i in range(len(selected)):\n            for j in range(i+1, len(selected)):\n                if (selected[j] - selected[i]) % m != 0:\n                    return False\n        return True\n\n    def subset_sum(multiset, target_sum, current_sum=0, index=0, selected=[]):\n        if current_sum == target_sum and is_possible(selected):\n            return selected\n        if index == len(multiset) or current_sum >= target_sum:\n            return None\n        \n        include = subset_sum(multiset, target_sum, current_sum+multiset[index], index+1, selected + [multiset[index]])\n        exclude = subset_sum(multiset, target_sum, current_sum, index+1, selected)\n\n        return include if include is not None else exclude\n\n    selected = subset_sum(multiset, k, 0)\n    if selected is None:\n        return \"No\"\n    else:\n        return \"Yes\\n\" + \" \".join(map(str, selected))\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    multiset = list(map(int, stdin.split()))\n\n    # Sort the multiset in non-decreasing order\n    multiset.sort()\n\n    selected = []\n    i = 0\n    while len(selected) < k:\n        diff = m * (i + 1) - multiset[i]\n        while i + 1 < n and multiset[i] + diff > multiset[i + 1]:\n            i += 1\n            diff = m * (i + 1) - multiset[i]\n\n        if i + 1 < n and multiset[i] + diff <= multiset[i + 1]:\n            selected.append(multiset[i])\n            i += 1\n\n    if len(selected) != k:\n        return \"No\"\n    else:\n        return \"Yes\\n\" + \" \".join(map(str, selected))\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    nums = list(map(int, stdin.split()[3:]))\n\n    # Check if it's impossible to select k numbers in the desired way\n    if k > n or k > len(set(nums)) or max(nums) - min(nums) < k - 1:\n        return \"No\"\n\n    # Find the smallest and largest number in the multiset\n    min_num, max_num = min(nums), max(nums)\n\n    # Generate all possible numbers between min_num and max_num\n    candidates = [i for i in range(min_num, max_num + 1) if (max_num - i + 1) % m == 0]\n\n    # Sort the candidates by their difference to the smallest number in the multiset\n    candidates.sort(key=lambda x: (x - min_num) % m)\n\n    # Find the k selected numbers\n    selected = candidates[:k]\n\n    # Print the selected numbers\n    return \"Yes\\n\" + \" \".join(map(str, selected)) "
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k, m = map(int, input_list[0].split())\n    multiset = list(map(int, input_list[1].split()))\n\n    if k > len(multiset):\n        return \"No\"\n\n    # Find all possible pairs of integers\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.add((multiset[i], multiset[j]))\n\n    # Check if any two selected integers have difference divisible by m\n    selected_pairs = set()\n    for i in range(k):\n        if i == 0:\n            for pair in pairs:\n                if pair[1] - pair[0] % m == 0:\n                    selected_pairs.add(pair)\n        else:\n            new_selected_pairs = set()\n            for pair in selected_pairs:\n                for other_pair in pairs:\n                    if other_pair[1] - other_pair[0] % m == 0:\n                        new_selected_pairs.add(pair + (other_pair[1],))\n            selected_pairs = new_selected_pairs\n\n    if len(selected_pairs) == 0:\n        return \"No\"\n    else:\n        selected_numbers = set()\n        for pair in selected_pairs:\n            selected_numbers.add(pair[0])\n            selected_numbers.add(pair[1])\n        return \"Yes\\n\" + \" \".join(map(str, sorted(selected_numbers)))\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k, m = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n\n    a_set = set(a_list)\n    max_count = max(a_list.count(x) for x in a_set)\n    if k > max_count:\n        return \"No\"\n\n    def is_valid(b_list):\n        if len(b_list) != k:\n            return False\n        for i in range(k):\n            for j in range(i + 1, k):\n                if (b_list[j] - b_list[i]) % m != 0:\n                    return False\n        return True\n\n    def find_valid_b_list(a_list, k):\n        a_list.sort()\n        b_list = [a_list[0]]\n        for i in range(1, len(a_list)):\n            if a_list[i] - b_list[-1] >= m:\n                b_list.append(a_list[i])\n                if len(b_list) == k:\n                    break\n            elif a_list[i] - b_list[-1] < m:\n                continue\n        return b_list\n\n    b_list = find_valid_b_list(a_list, k)\n    if not is_valid(b_list):\n        return \"No\"\n    return \"Yes\\n\" + \" \".join(map(str, b_list))"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    multiset = list(map(int, stdin.split()[3:]))\n\n    def is_valid(selected):\n        for i in range(k):\n            for j in range(i+1, k):\n                if (selected[i] - selected[j]) % m != 0:\n                    return False\n        return True\n\n    multiset.sort()\n    selected = []\n    i, j = 0, k-1\n    while j >= 0 and i < n:\n        if multiset[i] > multiset[j]:\n            j -= 1\n        elif multiset[i] + (k - len(selected)) * m - j * m > multiset[j]:\n            selected.append(multiset[i])\n            i += 1\n        else:\n            selected.append(multiset[j])\n            j -= 1\n\n    if len(selected) != k:\n        return \"No\"\n\n    if not is_valid(selected):\n        return \"No\"\n\n    return \"Yes\\n\" + \" \".join(map(str, selected))\n"
    },
    {
        "number": 771,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split()[:3])\n    multiset = list(map(int, stdin.split()[3:]))\n    \n    def is_possible(selected_multiset):\n        for i in range(k):\n            for j in range(i+1, k):\n                if selected_multiset[i] - selected_multiset[j] % m != 0:\n                    return False\n        return True\n    \n    selected_multiset = []\n    for num in multiset:\n        if len(selected_multiset) < k and num not in selected_multiset:\n            selected_multiset.append(num)\n        elif num not in selected_multiset:\n            index_to_replace = selected_multiset.index(min(selected_multiset))\n            if selected_multiset[index_to_replace] != num:\n                selected_multiset[index_to_replace] = num\n    \n    if not is_possible(selected_multiset):\n        return \"No\"\n    \n    selected_multiset.sort()\n    return \"Yes\\n\" + \" \".join(map(str, selected_multiset))\n\n\ninput_data = \"\"\"4 3 5\n2 7 7 7\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = []\n    for i in range(3):\n        grid.append(list(map(int, stdin.split())))\n\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] % 2 == 1:\n                grid[i][j] -= 1\n                if i > 0:\n                    grid[i-1][j] -= 1\n                if i < 2:\n                    grid[i+1][j] -= 1\n                if j > 0:\n                    grid[i][j-1] -= 1\n                if j < 2:\n                    grid[i][j+1] -= 1\n\n    result = \"\"\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] == 0:\n                result += \"0\"\n            else:\n                result += \"1\"\n        result += \"\\n\"\n\n    return result\n\n\nstdin = \"1 0 0\\n0 0 0\\n0 0 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    grid = []\n    for i in range(3):\n        grid.append([int(x) for x in stdin.split()[i*3:i*3+3]])\n    \n    for i in range(3):\n        for j in range(3):\n            if sum(grid[i][j:j+3]) % 2 == 1:\n                grid[i][j] = grid[i][j] % 2 + 1\n            for k in range(3):\n                if grid[i][k] % 2 == 1:\n                    grid[i][j+k] = (grid[i][j+k] % 2 + 1) % 2\n    \n    result = \"\"\n    for i in range(3):\n        for j in range(3):\n            result += \"1\" if grid[i][j] % 2 == 1 else \"0\"\n        result += \"\\n\"\n    \n    return result[:-1]"
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lights = []\n    for i in range(3):\n        row = [int(x) for x in stdin.split()[i * 3: (i + 1) * 3]]\n        lights.append(row)\n\n    for i in range(3):\n        for j in range(3):\n            light = lights[i][j]\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < 3 and 0 <= y < 3 and (x, y) != (i, j):\n                        lights[x][y] += light\n\n    result = []\n    for i in range(3):\n        row = []\n        for j in range(3):\n            if lights[i][j] % 2 == 1:\n                row.append(\"1\")\n            else:\n                row.append(\"0\")\n        result.append(\"\".join(row))\n\n    return \"\\n\".join(result)\n\n\nprint(solution(\"1 0 0\\n0 0 0\\n0 0 1\"))\nprint(solution(\"1 0 1\\n8 8 8\\n2 0 3\")) "
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = []\n    for _ in range(3):\n        rows.append([int(x) for x in stdin.readline().strip().split()])\n    \n    result = []\n    for i in range(3):\n        for j in range(3):\n            if rows[i][j] % 2 == 1:\n                result.append('1')\n            else:\n                result.append('0')\n    \n    return '\\n'.join([''.join(result[i:i+3]) for i in range(0, len(result), 3)])"
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_grid = stdin.split(\"\\n\")\n    grid = [list(map(int, input_grid[i].split())) for i in range(3)]\n    \n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] % 2 == 1:\n                grid[i][j] += 1\n                grid[i][(j-1)%3] += 1\n                grid[(i-1)%3][j] += 1\n                grid[(i+1)%3][j] += 1\n                grid[i][(j+1)%3] += 1\n    \n    output = []\n    for i in range(3):\n        row = \"\"\n        for j in range(3):\n            if grid[i][j] % 2 == 1:\n                row += \"1\"\n            else:\n                row += \"0\"\n        output.append(row)\n    \n    return \"\\n\".join(output)\n\n\ndef"
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    rows = [[int(x) for x in input().split()] for _ in range(3)]\n    result = []\n    for i in range(3):\n        row = []\n        for j in range(3):\n            total = sum(rows[i]) + rows[i][j]\n            if total % 2 == 0:\n                row.append('1')\n            else:\n                row.append('0')\n        result.append(''.join(row))\n    return '\\n'.join(result)"
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_rows = stdin.split('\\n')\n    light_grid = [[0] * 3 for _ in range(3)]\n    for i, row in enumerate(input_rows):\n        for j, col in enumerate(row.split()):\n            light_grid[i][j] = int(col)\n\n    for i in range(3):\n        for j in range(3):\n            light_grid[i][j] %= 2\n\n    output = [''.join(['1' if light_grid[i][j] else '0' for j in range(3)]) for i in range(3)]\n    return '\\n'.join(output)\n\n\ninput_str = \"1 0 1\\n8 8 8\\n2 0 3\"\nprint(solution(input_str)) "
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lights = []\n    for i in range(3):\n        row = list(map(int, stdin.split()[i * 3: (i + 1) * 3]))\n        lights.append(row)\n\n    result = []\n    for i in range(3):\n        row = []\n        for j in range(3):\n            if sum(lights[x][y] for x in range(3) for y in range(3) if (x, y) != (i, j) and (x == i or y == j)) % 2 == 0:\n                row.append(\"0\")\n            else:\n                row.append(\"1\")\n        result.append(\"\".join(row))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    grid = [[int(x) for x in input().split()] for _ in range(3)]\n    \n    for i in range(3):\n        for j in range(3):\n            grid[i][j] = 0 if grid[i][j] % 2 == 0 else 1\n    \n    result = \"\"\n    for i in range(3):\n        for j in range(3):\n            result += \"1\" if grid[i][j] == 1 else \"0\"\n        result += \"\\n\"\n    \n    return result[:-1]\n\n\ninput_str = \"\"\"1 0 0\n0 0 0\n0 0 1\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 772,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    grid = []\n    for _ in range(3):\n        grid.append(list(map(int, stdin.readline().strip().split())))\n\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] % 2 == 1:\n                grid[i][j] += 1\n                for k in range(3):\n                    if k != i:\n                        grid[k][j] += 1\n                    if k != j:\n                        grid[i][k] += 1\n\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] > 1:\n                grid[i][j] -= 1\n            if grid[i][j] % 2 == 1:\n                print(\"1\", end=\"\")\n            else:\n                print(\"0\", end=\"\")\n        print()\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, q = map(int, input_lines[0].split())\n    facts = input_lines[1:]\n\n    if q == 0:\n        return -1\n\n    a = list(range(1, n + 1))\n    a_count = [0] * n\n    for x in a:\n        a_count[x - 1] += 1\n\n    for fact in facts:\n        t, l, r, v = map(int, fact.split())\n        for x in range(l, r + 1):\n            if t == 1:\n                if a[x - 1] < v:\n                    a[x - 1] = v\n                    a_count[v - 1] += 1\n                    a_count[a[x - 1] - 1] -= 1\n            else:\n                if a[x - 1] <= v:\n                    a[x - 1] = v\n                    a_count[v - 1] += 1\n                    a_count[a[x - 1] - 1] -= 1\n\n    cost = sum([x ** 2 for x in a_count])\n    return cost\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_occurrences(arr, n):\n        cnt = [0] * n\n        for x in arr:\n            cnt[x - 1] += 1\n        return cnt\n\n    def total_cost(arr, n):\n        return sum(x ** 2 for x in count_occurrences(arr, n))\n\n    def check_fact(arr, l, r, v, cnt):\n        return all(arr[x - 1] >= v for x in range(l, r + 1))\n\n    def check_fact_2(arr, l, r, v, cnt):\n        return all(arr[x - 1] <= v for x in range(l, r + 1))\n\n    n, q = map(int, stdin.split()[:2])\n    facts = [tuple(map(int, stdin.split()[2:])) for _ in range(q)]\n\n    if n > 50 or q > 100:\n        return -1\n\n    arr = list(range(1, n + 1))\n    cnt = count_occurrences(arr, n)\n    cost = total_cost(arr, n)\n\n    for t, l, r, v in facts:\n        if t == 1:\n            if not check_fact(arr, l, r, v, cnt):\n                return -1\n        elif t == 2:\n            if not check_fact_2(arr, l, r, v, cnt):\n                return -1\n        else:\n            return -1\n\n    return cost\n\n\ndef"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, q = map(int, input_list[0].split())\n    facts = input_list[1:]\n    array = [0] * (n + 1)\n\n    def cnt(i: int) -> int:\n        return array.count(i)\n\n    def process_fact(t: int, l: int, r: int, v: int) -> None:\n        if t == 1:\n            for x in range(l, r + 1):\n                if a[x] >= v:\n                    array[x] += 1\n        else:\n            for x in range(l, r + 1):\n                if a[x] <= v:\n                    array[x] += 1\n\n    for fact in facts:\n        t, l, r, v = map(int, fact.split())\n        process_fact(t, l, r, v)\n\n    cost = sum(x ** 2 for x in array[1:])\n\n    return cost\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    a = [0] * (n + 1)\n\n    def cnt(x: int) -> int:\n        return a[x]\n\n    def cos(t: int, l: int, r: int, v: int) -> int:\n        if t == 1:\n            return sum([max(a[x], v) for x in range(l, r + 1)])\n        else:\n            return sum([min(a[x], v) for x in range(l, r + 1)])\n\n    facts = [map(int, stdin.split()[i:i + 4]) for i in range(2, 2 + q * 4, 4)]\n\n    for t, l, r, v in facts:\n        if l > r or l < 1 or r > n or v < 1 or v > n:\n            return -1\n        if t == 1:\n            a[l:r + 1] = [v] * (r - l + 1)\n        else:\n            a[l:r + 1] = [v] * (r - l + 1)\n\n    return sum([cnt(i) ** 2 for i in range(1, n + 1)])\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    facts = stdin.split('\\n')[1:]\n\n    if n == 0 or q == 0:\n        return 0\n\n    a = [0] * (n + 1)\n    cnt = [0] * (n + 1)\n\n    for line in facts:\n        t, l, r, v = map(int, line.split())\n        for i in range(l, r + 1):\n            if t == 1:\n                a[i] = max(a[i], v)\n            elif t == 2:\n                a[i] = min(a[i], v)\n\n        for i in range(1, n + 1):\n            cnt[i] = cnt[i] + a.count(i)\n\n    cost = sum([(cnt[i])**2 for i in range(1, n + 1)])\n\n    return cost\n\ndef"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count(array: List[int]) -> int:\n        cnt = [0] * n\n        for x in array:\n            cnt[x-1] += 1\n        return sum(x*x for x in cnt)\n\n    n, q = map(int, stdin.split()[:2])\n    facts = stdin.split()[2:]\n    facts = [tuple(map(int, line.split())) for line in facts]\n    facts.sort(key=lambda x: x[1])\n\n    def cnt_op(x, v):\n        return 1 if x < v else 0\n\n    def is_controversial():\n        prev_r = -1\n        for t, l, r, v in facts:\n            if t == 1:\n                cnt_l, cnt_r = 0, 0\n                for x in range(l, r+1):\n                    cnt_l += cnt_op(a[x-1], v)\n                    cnt_r += cnt_op(a[x-1], v)\n                if cnt_l > 0 or cnt_r > 0:\n                    return True\n            else:\n                if prev_r > r:\n                    return True\n                prev_r = r\n        return False\n\n    a = [0] * n\n    for t, l, r, v in facts:\n        if t == 1:\n            for x in range(l, r+1):\n                a[x-1] = max(a[x-1], v)\n        else:\n            for x in range(l, r+1):\n                a[x-1] = min(a[x-1], v)\n\n    if is_controversial():\n        return -1\n    else:\n        return count(a)\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, input().split())\n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = i\n\n    for _ in range(q):\n        t, l, r, v = map(int, input().split())\n        for i in range(l, r + 1):\n            if t == 1:\n                if a[i] < v:\n                    a[i] = v\n            else:\n                if a[i] > v:\n                    a[i] = v\n\n    cost = sum((a.count(i)) ** 2 for i in range(1, n + 1))\n\n    return cost if a == sorted(a) else -1\n\n\nstdin = \"\"\"\n3 2\n1 1 3 2\n2 1 3 1\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, q = map(int, input_data[0].split())\n    facts = [(int(t), int(l), int(r), int(v)) for t, l, r, v in zip(*[iter(input_data[1:])]*4)]\n    \n    cnt = [0] * (n + 1)\n    for t, l, r, v in facts:\n        if t == 1:\n            for i in range(l, r + 1):\n                cnt[i] += 1\n        elif t == 2:\n            for i in range(l, r + 1):\n                cnt[i] -= 1\n                if cnt[i] < 0:\n                    return -1\n        else:\n            return -1\n            \n    return sum(x**2 for x in cnt)"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, q = map(int, input_data[0].split())\n    facts = input_data[1:]\n\n    def count(i: int) -> int:\n        return len([fact for fact in facts if fact.split()[0] == \"1\" and fact.split()[1] == str(i)])\n\n    def cnt(i: int) -> int:\n        return len([fact for fact in facts if fact.split()[0] == \"2\" and fact.split()[1] == str(i)])\n\n    min_cost = sum(count(i)**2 for i in range(1, n+1))\n    for i in range(1, n+1):\n        min_cost += sum((max(cnt(i), 0) + 1) * (max(cnt(i), 1) - cnt(i)) for i in range(1, n+1))\n\n    return str(min_cost)\n"
    },
    {
        "number": 773,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, q = map(int, input_list[0].split())\n    facts = input_list[1:]\n\n    def count_occurrences(array):\n        return [array.count(i) for i in range(1, n + 1)]\n\n    def process_fact(array, t, l, r, v):\n        if t == 1:\n            for i in range(l, r + 1):\n                array[i] = max(array[i], v)\n        elif t == 2:\n            for i in range(l, r + 1):\n                array[i] = min(array[i], v)\n        else:\n            raise ValueError(\"Invalid fact type\")\n\n    def min_cost(array):\n        return sum(x ** 2 for x in count_occurrences(array))\n\n    restored_array = [0] * n\n    for fact in facts:\n        t, l, r, v = map(int, fact.split())\n        process_fact(restored_array, t, l, r, v)\n\n    if any(restored_array[i] > i for i in range(n)):\n        return -1\n\n    return min_cost(restored_array)\n\n\nstdin = \"\"\"\n3 2\n1 1 3 2\n2 1 3 1\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    numerator = x\n    denominator = y\n    min_diff = float('inf')\n    result = None\n\n    for i in range(1, n+1):\n        diff = abs(numerator / denominator - x/y)\n        if diff < min_diff:\n            min_diff = diff\n            result = (numerator, denominator)\n        if denominator < n:\n            numerator += numerator\n            denominator += 1\n\n    return f\"{result[0]}/{result[1]}\"\n"
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    gcd = math.gcd(x, y)\n    x, y = x // gcd, y // gcd\n    if y == 1:\n        return f\"{x // n}/{n}\"\n    a, b = x, y\n    if x < y:\n        a, b = y, x\n    if b >= n:\n        b = n\n    while a % b != 0:\n        a += x\n        if a >= b * n:\n            a -= x\n            b += y\n    return f\"{a // b}/{b}\"\n\n\nstdin = \"3 7 6\"\nprint(solution(stdin)) "
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n\n    def fraction(a, b):\n        return f\"{a}/{b}\"\n\n    def fraction_distance(fraction_a, fraction_b):\n        x_a, y_a = fraction_a\n        x_b, y_b = fraction_b\n        return abs(x_a / y_a - x_b / y_b)\n\n    min_distance = float(\"inf\")\n    min_a, min_b = 0, 0\n\n    for b in range(1, n + 1):\n        a = x * b - y * n\n        distance = fraction_distance((a, b), (x, y))\n        if distance < min_distance:\n            min_distance = distance\n            min_a, min_b = a, b\n\n    return fraction(min_a, min_b)\n"
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    a, b = 0, n\n    delta = float('inf')\n    for i in range(1, n+1):\n        d = abs(x*i - y*b)\n        if d < delta:\n            a, b = i, b\n            delta = d\n        if b == 1:\n            break\n        d = abs(x*a - y*i)\n        if d < delta:\n            a, b = a, i\n            delta = d\n    return f\"{a}/{b}\""
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    if y == 0:\n        a = n\n        b = 1\n    else:\n        a = (n * y + y // 2) // y\n        b = y\n    return f\"{a}/{b}\"\n\n\ninput_str = input(\"Enter the input values: \")\nresult = solution(input_str)\nprint(\"Closest fraction to [x/y] whose denominator is no more than n is:\", result) "
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n\n    # Calculate the two fractions\n    frac1 = x / y\n    frac2 = (x + n) / (y + 1)\n\n    # Calculate the absolute difference\n    diff1 = abs(frac1 - frac2)\n    diff2 = abs(1 - frac1) / y\n    diff3 = abs(frac1 - 1) / y\n\n    # Find the minimum difference and corresponding fraction\n    min_diff = min(diff1, diff2, diff3)\n    if min_diff == diff1:\n        return f\"{x}/{y}\"\n    elif min_diff == diff2:\n        return f\"{x+n}/{y+1}\"\n    else:\n        return f\"{1}/{y}\"\n"
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    \n    numerator = (x * n) // y\n    denominator = n\n    if numerator == 0:\n        numerator = 1\n    \n    return f\"{numerator}/{denominator}\"\n\ndef"
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    a, b = min((abs(x*n - i*y), i) for i in range(1, n+1))\n    return f\"{a}/{b}\"\n\n\ninput_str = \"7 2 4\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    numerator = lcm(x, y)\n    denominator = 1\n    for i in range(1, n + 1):\n        if numerator % i == 0:\n            numerator //= i\n            denominator *= i\n\n    return f\"{numerator}/{denominator}\"\n"
    },
    {
        "number": 774,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    numerator = x * n\n    denominator = y * n\n    a, b = min(numerator, denominator), max(numerator, denominator)\n    return f\"{a}/{b}\""
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, k = map(int, input_data[0].split())\n    holes = list(map(int, input_data[1].split()))\n    swaps = [tuple(map(int, input_data[i+2].split())) for i in range(k)]\n\n    final_positions = set()\n    for u, v in swaps:\n        for hole in holes:\n            final_positions.add(u)\n            final_positions.add(v)\n            if hole in (u, v):\n                final_positions.add(hole)\n\n    final_positions = sorted(list(final_positions))\n    return final_positions[-1]"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def swap(cups, u, v):\n        cups[u-1], cups[v-1] = cups[v-1], cups[u-1]\n\n    n, m, k = map(int, stdin.split()[:3])\n    holes = list(map(int, stdin.split()[3:3+m]))\n    bone_pos = 1\n\n    for _ in range(k):\n        u, v = map(int, stdin.split()[3+m:3+m+2])\n\n        if bone_pos in holes:\n            bone_pos = 0\n            break\n\n        swap([bone_pos, u, v], bone_pos, u, v)\n\n    return bone_pos if bone_pos != 0 else \"Impossible\"\n"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    h = list(map(int, stdin.split()[3:3+m]))\n    for _ in range(k):\n        u, v = map(int, stdin.split()[3+m+_:3+m+_ + 2])\n        if 1 <= u <= n and 1 <= v <= n and u != v:\n            if h[0] <= u <= h[1] or h[2] <= u <= h[3] or h[4] <= u <= h[5]:\n                u, v = v, u\n            if h[0] <= v <= h[1] or h[2] <= v <= h[3] or h[4] <= v <= h[5]:\n                u, v = v, u\n    return str(u)\n\n\nn, m, k = 7, 3, 4\nh = [3, 4, 6]\nu1, v1 = 1, 2\nu2, v2 = 2, 5\nu3, v3 = 5, 7\nu4, v4 = 7, 1\n\nprint(solution(str(n) + \" \" + str(m) + \" \" + str(k) + \" \" + \" \".join(map(str, h)) + \" \" + \" \".join(map(str, (u1, v1)))))  # Output: 2\nprint(solution(str(n) + \" \" + str(m) + \" \" + str(k) + \" \" + \" \".join(map(str, h)) + \" \" + \" \".join(map(str, (u2, v2)))))  # Output: 2\nprint(solution(str(n) + \" \" + str(m) + \" \" + str(k) + \" \" + \" \".join(map(str, h)) + \" \" + \" \".join(map(str, (u3, v3)))))  # Output: 1\nprint(solution(str(n) + \" \" + str(m) + \" \" + str(k) + \" \" + \" \".join(map(str, h)) + \" \" + \" \".join(map(str, (u4, v4)))))  # Output: 2 "
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def swap_cups(u, v):\n        cups[u - 1], cups[v - 1] = cups[v - 1], cups[u - 1]\n\n    def get_final_position() -> int:\n        for i in range(1, n + 1):\n            if cups[i - 1] == i:\n                return i\n        return -1\n\n    n, m, k = map(int, stdin.split()[:3])\n    cups = list(map(int, stdin.split()[3:]))\n    holes = set(map(int, stdin.split()[3 + m:]))\n\n    for _ in range(k):\n        u, v = map(int, stdin.split()[3 + m + k:])\n        if cups[u - 1] in holes or cups[v - 1] in holes:\n            continue\n        swap_cups(u, v)\n\n    return str(get_final_position())\n\n\ninput_data = '''7 3 4\n3 4 6\n1 2\n2 5\n5 7\n7 1'''\n\nprint(solution(input_data))\n"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    holes = list(map(int, input().split()))\n    swap_operations = []\n    for _ in range(k):\n        swap_operations.append(list(map(int, input().split())))\n    \n    final_position = 1\n    for operation in swap_operations:\n        if operation[0] in holes or operation[1] in holes:\n            continue\n        if operation[0] == 1:\n            final_position = operation[1]\n        elif operation[1] == 1:\n            final_position = operation[0]\n    \n    return final_position\n"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, input().split())\n    holes = list(map(int, input().split()))\n    positions = []\n\n    for _ in range(k):\n        positions.append(list(map(int, input().split())))\n\n    bone_position = 1\n    for u, v in positions:\n        if u in holes or v in holes:\n            bone_position = -1\n            break\n        if u == 1:\n            bone_position = v\n        elif v == 1:\n            bone_position = u\n        else:\n            bone_position = min(u, v)\n\n    return str(bone_position)\n\ndef"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    h = sorted(map(int, stdin.split()[3:3+m]))\n    bone_position = 1\n    \n    for _ in range(k):\n        u, v = map(int, stdin.split()[3+m:3+2*m:2])\n        u_index = bisect.bisect_left(h, u)\n        v_index = bisect.bisect_left(h, v)\n        \n        if u_index < v_index:\n            bone_position = u\n            u, v = v, u\n        \n        if v_index == 0 and bone_position == h[0]:\n            bone_position = u\n        elif v_index == m and bone_position == h[-1]:\n            bone_position = u\n        else:\n            bone_position = v\n    \n    return str(bone_position)\n\ndef"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    h = list(map(int, stdin.split()[3:3+m]))\n    for _ in range(k):\n        u, v = map(int, stdin.split()[3+m:3+m*2])\n        # perform swap operation\n    # determine final position of bone\n    return str(final_position)"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, k = map(int, input_list[0].split())\n    h = list(map(int, input_list[1].split()))\n    for i in range(2, len(input_list)):\n        u, v = map(int, input_list[i].split())\n        if u in h or v in h:\n            h.append(u if u in h else v)\n    bone_positions = set(h)\n    final_position = 0\n    for i in range(1, n+1):\n        if i not in bone_positions:\n            final_position = i\n            break\n    return str(final_position)"
    },
    {
        "number": 775,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    h = list(map(int, stdin.split()[3:3+m]))\n    cups = list(range(1, n+1))\n    for _ in range(k):\n        u, v = map(int, stdin.split()[3+m:3+2*m:2])\n        cups[u-1], cups[v-1] = cups[v-1], cups[u-1]\n    for i in range(n):\n        if cups[i] in h:\n            return str(i+1)\n    return str(cups.index(1)+1)"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, input().split())\n    mouses = []\n    for _ in range(m):\n        val, port = input().split()\n        mouses.append((int(val), port))\n\n    usb_computers = a\n    ps2_computers = b + c\n    total_cost = 0\n\n    for mouse in sorted(mouses, key=lambda x: (x[1], x[0]), reverse=True):\n        if mouse[1] == \"USB\" and usb_computers > 0:\n            total_cost += mouse[0]\n            usb_computers -= 1\n        elif mouse[1] == \"PS/2\" and ps2_computers > 0:\n            total_cost += mouse[0]\n            ps2_computers -= 1\n        elif mouse[1] == \"PS/2\" and ps2_computers == 0 and usb_computers > 0:\n            total_cost += mouse[0]\n            usb_computers -= 1\n\n    return f\"{usb_computers + ps2_computers} {total_cost}\""
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split()[:3])\n    m = int(stdin.split()[3])\n    data = stdin.split('\\n')[4:]\n\n    # Create sets for each port type\n    usb_mouses = set()\n    ps2_mouses = set()\n    both_mouses = set()\n\n    # Iterate through the data and add the mouses to the appropriate set\n    for mouse in data:\n        val, port = mouse.split()\n        val = int(val)\n        if port == 'USB':\n            usb_mouses.add((val, port))\n        elif port == 'PS/2':\n            ps2_mouses.add((val, port))\n        else:\n            both_mouses.add((val, port))\n\n    # Determine the number of computers that can be equipped\n    usb_count = min(a, len(usb_mouses))\n    ps2_count = min(b, len(ps2_mouses))\n    both_count = min(c, len(both_mouses))\n\n    # Determine the total cost of the mouses\n    total_cost = sum(sum(mouse[0] for mouse in mouses) for mouses in [usb_mouses, ps2_mouses, both_mouses])\n\n    # Return the number of equipped computers and the total cost of the mouses\n    return f\"{usb_count + ps2_count + both_count} {total_cost}\"\n\n\ninput_data = \"\"\"2 1 1\n4\n5 USB\n6 PS/2\n3 PS/2\n7 PS/2\"\"\"\n\nprint(solution(input_data))\n"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, m = map(int, stdin.split())\n    price_list = []\n    for _ in range(m):\n        val, port = input().split()\n        val = int(val)\n        price_list.append((val, port))\n\n    usb_computers = [0] * (a + b + c)\n    ps2_computers = [0] * (a + b + c)\n    both_computers = [0] * (a + b + c)\n\n    for val, port in price_list:\n        if port == 'USB':\n            usb_computers[min(usb_computers)] += val\n        elif port == 'PS/2':\n            ps2_computers[min(ps2_computers)] += val\n        else:\n            both_computers[min(both_computers)] += val\n\n    computers = [usb_computers, ps2_computers, both_computers]\n    max_num = 0\n    min_cost = float('inf')\n\n    for computer in computers:\n        num = sum(1 for cost in computer if cost > 0)\n        if num > max_num:\n            max_num = num\n        elif num == max_num:\n            cost = sum(cost for cost in computer if cost > 0)\n            if cost < min_cost:\n                min_cost = cost\n\n    return f\"{max_num} {min_cost}\"\n"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_type(port: str) -> int:\n        if port == 'USB':\n            return 1\n        elif port == 'PS/2':\n            return 2\n        else:\n            return 3\n\n    def get_value(port: str, cost: int) -> int:\n        if port == 'USB':\n            return cost + 3\n        elif port == 'PS/2':\n            return cost + 2\n        else:\n            return cost + 1\n\n    a, b, c = map(int, stdin.split()[:3])\n    m = int(stdin.split()[3])\n    mouse_list = [line.split() for line in stdin.split('\\n')[4:] if line]\n\n    usb_mice = sum(1 for mouse in mouse_list if mouse[1] == 'USB')\n    ps2_mice = sum(1 for mouse in mouse_list if mouse[1] == 'PS/2')\n    both_mice = sum(1 for mouse in mouse_list if mouse[1] == 'Both')\n\n    total_cost = 0\n    total_mice = 0\n\n    if usb_mice > 0:\n        total_mice += 1\n        total_cost += get_value('USB', min(usb_mice, a))\n        usb_mice -= a\n\n    if ps2_mice > 0:\n        total_mice += 1\n        total_cost += get_value('PS/2', min(ps2_mice, b))\n        ps2_mice -= b\n\n    if both_mice > 0:\n        total_mice += 1\n        total_cost += get_value('Both', min(both_mice, c))\n        both_mice -= c\n\n    total_cost += sum(int(mouse[0]) for mouse in mouse_list)\n\n    return f\"{total_mice} {total_cost}\" "
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    a, b, c = map(int, input().split())\n    m = int(input())\n    price_list = []\n    for _ in range(m):\n        val, port = input().split()\n        price_list.append((int(val), port))\n\n    # Sort price list by cost\n    price_list.sort(key=lambda x: x[0])\n\n    # Initialize variables\n    usb_mouses = 0\n    ps2_mouses = 0\n    both_mouses = 0\n    total_cost = 0\n\n    # Buy mouses\n    for val, port in price_list:\n        if port == 'USB' and usb_mouses < a + b:\n            usb_mouses += 1\n            total_cost += val\n        elif port == 'PS/2' and ps2_mouses < c:\n            ps2_mouses += 1\n            total_cost += val\n        elif port == 'PS/2' and both_mouses < b:\n            both_mouses += 1\n            total_cost += val\n\n    # Calculate number of equipped computers\n    equipped_computers = max(usb_mouses + both_mouses, ps2_mouses + both_mouses)\n\n    # Output result\n    return f\"{equipped_computers} {total_cost}\"\n"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split()[:3])\n    m = int(stdin.split()[3])\n    price_list = stdin.split()[4:]\n    prices = [(int(price_list[i]), price_list[i+1]) for i in range(0, len(price_list), 2)]\n\n    usb_computers = a\n    ps2_computers = b + c\n    usb_mouses = 0\n    ps2_mouses = 0\n\n    for price, port in sorted(prices, key=lambda x: x[0]):\n        if port == 'USB':\n            if usb_computers > 0:\n                usb_computers -= 1\n                usb_mouses += 1\n        elif port == 'PS/2':\n            if ps2_computers > 0:\n                ps2_computers -= 1\n                ps2_mouses += 1\n\n    total_cost = sum(price for price, _ in prices[:usb_mouses + ps2_mouses])\n\n    return f\"{usb_computers + ps2_computers} {total_cost}\" "
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split()[:3])\n    m = int(stdin.split()[3])\n    price_list = [line.split() for line in stdin.split('\\n')[4:]]\n\n    usb_mouses = [int(price[0]) for price in price_list if price[1] == 'USB']\n    ps2_mouses = [int(price[0]) for price in price_list if price[1] == 'PS/2']\n\n    if len(usb_mouses) + len(ps2_mouses) < m:\n        return \"0 0\"\n\n    usb_mouses.sort(reverse=True)\n    ps2_mouses.sort(reverse=True)\n\n    usb_computers = min(a, len(usb_mouses))\n    ps2_computers = min(b, len(ps2_mouses))\n\n    total_usb_mouses = sum(usb_mouses[:usb_computers])\n    total_ps2_mouses = sum(ps2_mouses[:ps2_computers])\n\n    total_cost = total_usb_mouses + total_ps2_mouses\n\n    return f\"{usb_computers + ps2_computers} {total_cost}\"\n\n\ndef"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    a, b, c = map(int, lines[0].split())\n    m = int(lines[1])\n    prices = [tuple(map(int, line.split())) for line in lines[2:]]\n\n    def compute_cost(mouses):\n        return sum(prices[i][0] for i in mouses)\n\n    def count_equipped_computers(mouses):\n        return sum(1 for i in range(a) if i in mouses) + sum(1 for i in range(b) if i + a in mouses) + sum(1 for i in range(c) if i + a + b in mouses)\n\n    max_cost = 0\n    max_mouses = []\n    for subset in itertools.combinations(range(m), 3):\n        cost = compute_cost(subset)\n        if cost > max_cost:\n            max_cost = cost\n            max_mouses = subset\n\n    return count_equipped_computers(max_mouses), max_cost\n"
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, m = map(int, stdin.split())\n    price_list = []\n    for _ in range(m):\n        val, port = map(str, input().split())\n        val = int(val)\n        price_list.append((val, port))\n    \n    usb_mouses = [p for p in price_list if p[1] == 'USB']\n    ps2_mouses = [p for p in price_list if p[1] == 'PS/2']\n    \n    usb_computers = min(a, len(usb_mouses))\n    ps2_computers = min(b + c, len(ps2_mouses))\n    \n    total_cost = sum(p[0] for p in usb_mouses[:usb_computers] + ps2_mouses[:ps2_computers])\n    \n    return f\"{usb_computers + ps2_computers} {total_cost}\""
    },
    {
        "number": 776,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, input().split())\n    m = int(input())\n    price_list = []\n\n    for _ in range(m):\n        val, port = input().split()\n        price_list.append((int(val), port))\n\n    # Sort the price list by the cost\n    price_list.sort(key=lambda x: x[0])\n\n    # Initialize the result with the minimum number of computers\n    result = [0, 0]\n\n    # Initialize a list to store the number of USB and PS/2 mouses\n    mouses = [0, 0]\n\n    # Iterate through the price list\n    for val, port in price_list:\n        if port == 'USB':\n            mouses[0] += 1\n        else:\n            mouses[1] += 1\n\n        # Update the result if there are more USB mouses than PS/2 mouses\n        if mouses[0] > mouses[1]:\n            if result[0] < mouses[0]:\n                result[0] = mouses[0]\n                result[1] = sum(price_list[:mouses[0]])\n\n        # Update the result if there are the same number of USB and PS/2 mouses\n        elif mouses[0] == mouses[1]:\n            if result[1] < sum(price_list[:mouses[0]]) + sum(price_list[:mouses[1]]):\n                result[0] = mouses[0]\n                result[1] = sum(price_list[:mouses[0]]) + sum(price_list[:mouses[1]])\n\n    return f\"{result[0]} {result[1]}\" "
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n    \n    s = stdin.strip()\n    unique_books = set()\n    \n    for i in range(len(s) + 1):\n        for extra_ch in 'abcdefghijklmnopqrstuvwxyz':\n            for combo in itertools.combinations(s, i):\n                if extra_ch not in combo:\n                    unique_books.add(''.join(sorted(combo + extra_ch)))\n    \n    return len(unique_books)\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 1\n    for i in range(n):\n        count *= (n - i)\n    return count\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            if length == 1:\n                dp[i][j] = 1\n            else:\n                for k in range(i, j):\n                    dp[i][j] += dp[i][k] * dp[k + 1][j]\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[0][n]\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n\n    # Get the length of the input string\n    n = len(stdin)\n\n    # Generate all permutations of the input string\n    perms = [''.join(p) for p in permutations(stdin)]\n\n    # Initialize a set to store the distinct photobooks\n    distinct_photobooks = set(perms)\n\n    # Insert an additional character in each permutation and add the resulting permutations to the set\n    for perm in perms:\n        for char in stdin:\n            new_perm = perm + char\n            distinct_photobooks.add(new_perm)\n\n    # Return the number of distinct photobooks\n    return len(distinct_photobooks)\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    cnt = 0\n    for i in range(n+1):\n        cnt += nCr(n,i) * nCr(26, i)\n    return str(cnt)\n\ndef"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    count = 0\n\n    # Checking for all possible cases\n    for i in range(n + 1):\n        for j in range(n - i):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    photo_book = stdin\n    n = len(photo_book)\n    count = 0\n    for i in range(n+1):\n        for j in range(i+1, n+1):\n            if photo_book[i:j] in photo_book:\n                count += 1\n    return count"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    total_books = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and j != k and k != i:\n                    for l in range(n):\n                        if i != l and j != l and k != l and l != i:\n                            total_books += 1\n    return str(total_books)"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    s = stdin.strip()\n\n    # Initialize variables\n    n = len(s)\n    count = 0\n\n    # Check for all possible combinations of duplicates\n    for i in range(1, n + 1):\n        for j in range(n - i + 1):\n            temp = s[j:j + i]\n            for k in range(26):\n                count += 1\n                print(temp[:k] + chr(ord('a') + k) + temp[k:])\n\n    return str(count)\n"
    },
    {
        "number": 777,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 27  # number of distinct characters in the alphabet\n\n    # The number of distinct books that can be made is equal to the total number of combinations of the characters in the string plus the number of combinations of the characters in the string plus the extra character\n    num_books = (k ** n) + (k ** (n - 1)) + (k ** n) - 1\n\n    return str(num_books)\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    requirements = stdin.split('\\n')[1:]\n\n    def check_mausoleum(heights):\n        increasing = True\n        decreasing = True\n        for i in range(1, len(heights)):\n            if heights[i] > heights[i-1]:\n                increasing = False\n            if heights[i] < heights[i-1]:\n                decreasing = False\n        return increasing and decreasing\n\n    def count_ways(heights, requirements):\n        cnt = 0\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for l in range(n):\n                        h1, h2, h3, h4 = sorted([heights[i], heights[j], heights[k], heights[l]])\n                        if check_mausoleum([h1, h2, h3, h4]) and all(check_requirement(h1, h2, h3, h4, r) for r in requirements):\n                            cnt += 1\n        return cnt\n\n    def check_requirement(h1, h2, h3, h4, requirement):\n        xi, si, yi = map(int, requirement.split())\n        hx, hy = sorted([h1, h2, h3, h4])[xi-1], sorted([h1, h2, h3, h4])[yi-1])\n        if si == '=':\n            return hx == hy\n        elif si == '<':\n            return hx < hy\n        elif si == '>':\n            return hx > hy\n        elif si == '<=':\n            return hx <= hy\n        elif si == '>=':\n            return hx >= hy\n\n    heights = [1] * (2*n)\n    heights[0] = 1\n    heights[1] = 2\n    heights[2] = 3\n    heights[3] = 4\n    heights[4] = 1\n    heights[5] = 2\n    heights[6] = 3\n    heights[7] = 4\n\n    ways = count_ways(heights, requirements)\n\n    return str(ways)\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    heights = [1] * n + [2] * n\n    for i in range(k):\n        x, sign, y = map(int, stdin.split()[2:])\n        if sign == '=':\n            heights[x-1] = heights[y-1] = heights[min(x-1, y-1)]\n        elif sign == '<':\n            heights[x-1] = heights[y-1]\n        elif sign == '>':\n            heights[x-1] = heights[y-1]\n        elif sign == '<=':\n            heights[x-1] = max(heights[x-1], heights[y-1])\n        elif sign == '>=':\n            heights[x-1] = max(heights[x-1], heights[y-1])\n        else:\n            raise ValueError(f\"Invalid sign: {sign}\")\n    count = 0\n    for i in range(2*n-1):\n        increasing = True\n        for j in range(i+1, 2*n):\n            if heights[i] > heights[j]:\n                increasing = False\n            elif heights[i] < heights[j]:\n                break\n        if increasing:\n            count += 1\n        decreasing = True\n        for j in range(i-1, -1, -1):\n            if heights[i] > heights[j]:\n                decreasing = False\n            elif heights[i] < heights[j]:\n                break\n        if decreasing:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(blocks: list, x: int, y: int, sign: str) -> bool:\n        if sign == '=':\n            return blocks[x-1] == blocks[y-1]\n        elif sign == '<':\n            return blocks[x-1] < blocks[y-1]\n        elif sign == '>':\n            return blocks[x-1] > blocks[y-1]\n        elif sign == '<=':\n            return blocks[x-1] <= blocks[y-1]\n        else:\n            return blocks[x-1] >= blocks[y-1]\n\n    def count_ways(blocks: list, k: int, additional_reqs: list) -> int:\n        if k == 0:\n            return 1\n        count = 0\n        for i in range(len(blocks)-1):\n            if is_valid(blocks, i+1, i+2, additional_reqs[0][1]):\n                for j in range(i+3, len(blocks)-1):\n                    if is_valid(blocks, j+1, j+2, additional_reqs[0][2]):\n                        count += count_ways(blocks[:i+1] + blocks[i+2:] + [blocks[i+1], blocks[i+2]], k-1, additional_reqs[1:])\n        return count\n\n    n, k = map(int, stdin.split()[:2])\n    additional_reqs = [tuple(map(int, s.split())) for s in stdin.split('\\n')[2:]]\n\n    blocks = [1]*n + [2]*n + [3]*n + [4]*n\n    random.shuffle(blocks)\n\n    result = count_ways(blocks, k, additional_reqs)\n\n    return str(result)\n\n\nimport random\nfrom typing import List\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    additional_requirements = []\n\n    for i in range(k):\n        line = stdin.split()[i+2].split(\" \")\n        x, sign, y = int(line[0]), line[1], int(line[2])\n        additional_requirements.append((x, y, sign))\n\n    def height(i: int) -> int:\n        return 1 if i == 0 else n + 1\n\n    def check_requirements(heights: list) -> bool:\n        for x, y, sign in additional_requirements:\n            if heights[x-1] < heights[y-1]:\n                return False\n            if sign == '>' and heights[x-1] <= heights[y-1]:\n                return False\n            if sign == '<' and heights[x-1] >= heights[y-1]:\n                return False\n            if sign == '>=' and heights[x-1] < heights[y-1]:\n                return False\n            if sign == '<=' and heights[x-1] > heights[y-1]:\n                return False\n        return True\n\n    count = 0\n    for i in range(1, 2 * n + 1):\n        heights = [height(x) for x in range(i)]\n        if check_requirements(heights):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    additional_requirements = stdin.split(\"\\n\")[2:]\n    heights = [0] * (2 * n + 1)\n\n    def check_requirement(x, y, sign):\n        if sign == '=':\n            return heights[x] == heights[y]\n        elif sign == '<':\n            return heights[x] < heights[y]\n        elif sign == '>':\n            return heights[x] > heights[y]\n        elif sign == '<=':\n            return heights[x] <= heights[y]\n        elif sign == '>=':\n            return heights[x] >= heights[y]\n\n    def check_mausoleum_shape():\n        for i in range(1, 2 * n + 1, 2):\n            if heights[i] != heights[i - 1]:\n                return False\n        for i in range(2, 2 * n, 2):\n            if heights[i] != heights[i + 1]:\n                return False\n        return True\n\n    def count_ways():\n        count = 0\n        for height in range(1, 2 * n + 1):\n            heights[height] = height\n            if check_mausoleum_shape() and all(check_requirement(x, y, sign) for x, y, sign in additional_requirements):\n                count += 1\n            heights[height] = 0\n        return count\n\n    return str(count_ways())\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def satisfies_height_requirements(heights: List[int]) -> bool:\n        n = len(heights)\n        if heights[0] != 1:\n            return False\n        for i in range(1, n):\n            if heights[i] != heights[i - 1] and heights[i] != heights[i - 1] + 1:\n                return False\n        return True\n\n    def satisfies_sign_requirements(heights: List[int], signs: List[str]) -> bool:\n        n = len(heights)\n        for i in range(n - 1):\n            if signs[i] == '=' and heights[i] != heights[i + 1]:\n                return False\n            elif signs[i] == '<' and heights[i] >= heights[i + 1]:\n                return False\n            elif signs[i] == '>' and heights[i] <= heights[i + 1]:\n                return False\n            elif signs[i] == '<=' and heights[i] > heights[i + 1]:\n                return False\n            elif signs[i] == '>=' and heights[i] < heights[i + 1]:\n                return False\n        return True\n\n    def count_ways(n: int, k: int, heights: List[int], signs: List[str]) -> int:\n        if n == 0:\n            return 1\n        elif k == 0:\n            return 1 if satisfies_height_requirements(heights) else 0\n        else:\n            count = 0\n            for i in range(2 * n - 1):\n                for j in range(i + 1, 2 * n):\n                    if satisfies_sign_requirements(heights, signs):\n                        count += count_ways(n - 1, k - 1, heights[1:], signs[1:])\n            return count\n\n    def parse_input(line: str) -> Tuple[int, str, int]:\n        x, sign, y = line.split()\n        return int(x), sign, int(y)\n\n    n, k = map(int, stdin.splitlines()[0].split())\n    heights = [1] * (2 * n)\n    signs = ['='] * (2 * n - 1)\n    for line in stdin.splitlines()[1:]:\n        x, sign, y = parse_input(line)\n        heights[x - 1] = y\n        signs[x - 1] = sign\n    return str(count_ways(n, k, heights, signs))"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list.pop(0).split())\n    heights = [1] * n\n    heights += [2] * n\n    heights += [3] * n\n    heights += [4] * n\n    heights += [5] * n\n    heights += [6] * n\n    heights += [7] * n\n    heights += [8] * n\n    heights += [9] * n\n    heights += [10] * n\n    heights += [11] * n\n    heights += [12] * n\n    heights += [13] * n\n    heights += [14] * n\n    heights += [15] * n\n    heights += [16] * n\n    heights += [17] * n\n    heights += [18] * n\n    heights += [19] * n\n    heights += [20] * n\n    heights += [21] * n\n    heights += [22] * n\n    heights += [23] * n\n    heights += [24] * n\n    heights += [25] * n\n    heights += [26] * n\n    heights += [27] * n\n    heights += [28] * n\n    heights += [29] * n\n    heights += [30] * n\n    heights += [31] * n\n    heights += [32] * n\n    heights += [33] * n\n    heights += [34] * n\n    heights += [35] * n\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if heights[i] < heights[i+1] and heights[i] < heights[i+2]:\n                count += 1\n            elif heights[i] > heights[i+1] and heights[i] > heights[i+2]:\n                count += 1\n        else:\n            if heights[i] > heights[i+1] and heights[i] > heights[i+2]:\n                count += 1\n            elif heights[i] < heights[i+1] and heights[i] < heights[i+2]:\n                count += 1\n    if k == 0:\n        return str(count)\n    else:\n        for i in range(k):\n            x, sign, y = input_list[i].split()\n            x, y = int(x), int(y)\n            if sign == '=':\n                if heights[x-1] != heights[y-1]:\n                    count = 0\n                    break\n            elif sign == '>':\n                if heights[x-1] <= heights[y-1]:\n                    count = 0\n                    break\n            elif sign == '<':\n                if heights[x-1] >= heights[y-1]:\n                    count = 0\n                    break\n            elif sign == '>=':\n                if heights[x-1] < heights[y-1]:\n                    count = 0\n                    break\n            elif sign == '<=':\n                if heights[x-1] > heights[y-1]:\n                    count = 0\n                    break\n        return str(count)"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n, k, reqs):\n        if k == 0:\n            return 1\n\n        def is_valid(mausoleum):\n            n = len(mausoleum) // 2\n            for i in range(n + 1):\n                if mausoleum[2 * i] != i + 1:\n                    return False\n            for i in range(n + 1):\n                if mausoleum[2 * i + 1] != n - i + 1:\n                    return False\n            for i in range(n + 1):\n                for j in range(i + 1, n + 1):\n                    if mausoleum[2 * i] > mausoleum[2 * j]:\n                        return False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if mausoleum[2 * i + 1] < mausoleum[2 * j + 1]:\n                        return False\n            return True\n\n        def backtrack(mausoleum, k, reqs, used):\n            if k == 0 and is_valid(mausoleum):\n                return 1\n\n            count = 0\n            for i in range(n + 1):\n                if used & (1 << i) == 0:\n                    mausoleum[2 * i], mausoleum[2 * i + 1] = i + 1, n - i + 1\n                    used |= (1 << i)\n                    count += backtrack(mausoleum, k - 1, reqs, used)\n                    mausoleum[2 * i], mausoleum[2 * i + 1] = n - i + 1, i + 1\n                    used &= ~(1 << i)\n            return count\n\n        mausoleum = [0] * (2 * n + 1)\n        used = 0\n        return backtrack(mausoleum, k, reqs, used)\n\n    n, k = map(int, stdin.split())\n    reqs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    return str(count_ways(n, k, reqs))"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    constraints = []\n    \n    for _ in range(k):\n        x, sign, y = map(int, input().split())\n        constraints.append((x-1, sign, y-1))\n        \n    def is_valid(arr):\n        n = len(arr)\n        for i in range(n-1):\n            if arr[i] > arr[i+1]:\n                return False\n        return True\n    \n    def count_valid_arrangements(arr):\n        count = 0\n        for i in range(2**n):\n            binary = format(i, f'0{n}b')\n            if is_valid([int(x) for x in binary if x == '1']):\n                count += 1\n        return count\n    \n    def count_valid_arrangements_with_constraints(arr):\n        count = 0\n        for i in range(2**n):\n            binary = format(i, f'0{n}b')\n            if is_valid([int(x) for x in binary if x == '1']):\n                for x, sign, y in constraints:\n                    if sign == '=':\n                        if binary[x-1] != binary[y-1]:\n                            break\n                    elif sign == '>':\n                        if binary[x-1] <= binary[y-1]:\n                            break\n                    elif sign == '<':\n                        if binary[x-1] >= binary[y-1]:\n                            break\n                    elif sign == '>=':\n                        if binary[x-1] < binary[y-1]:\n                            break\n                    elif sign == '<=':\n                        if binary[x-1] > binary[y-1]:\n                            break\n                else:\n                    count += 1\n        return count\n    \n    count = count_valid_arrangements(list(range(1, n+1)))\n    for x, sign, y in constraints:\n        count = count_valid_arrangements_with_constraints([1]*n)\n    return count\n"
    },
    {
        "number": 778,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(heights: List[int]) -> bool:\n        n = len(heights)\n        if n % 2 != 0:\n            return False\n        n //= 2\n        for i in range(n):\n            if heights[i] > heights[i + n]:\n                return False\n        for i in range(n - 1):\n            if heights[i] >= heights[i + 1]:\n                return False\n        return True\n\n    def count_valid(heights: List[int], additional_requirements: List[Tuple[int, int, str]]) -> int:\n        n = len(heights)\n        count = 0\n        for i in range(2**n):\n            binary = format(i, f'0{n}b')\n            if not is_valid([heights[i] for i in range(n) if binary[i] == '1']):\n                continue\n            is_valid_additional = True\n            for x, y, sign in additional_requirements:\n                if sign == '=' and heights[x - 1] != heights[y - 1]:\n                    is_valid_additional = False\n                    break\n                elif sign == '<' and heights[x - 1] >= heights[y - 1]:\n                    is_valid_additional = False\n                    break\n                elif sign == '>' and heights[x - 1] <= heights[y - 1]:\n                    is_valid_additional = False\n                    break\n                elif sign == '<=' and heights[x - 1] > heights[y - 1]:\n                    is_valid_additional = False\n                    break\n                elif sign == '>=' and heights[x - 1] < heights[y - 1]:\n                    is_valid_additional = False\n                    break\n            if is_valid_additional:\n                count += 1\n        return count\n\n    n, k = map(int, stdin.split()[0:2])\n    additional_requirements = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:k+1]]\n    heights = [1, 2, 3, 4, 5, 4, 3, 2, 1]  # Example\n    result = count_valid(heights, additional_requirements)\n    return str(result)\n\n\nstdin = \"3 0\"\nprint(solution(stdin))\n\nstdin = \"3 1\\n2 > 3\"\nprint(solution(stdin))\n\nstdin = \"4 1\\n3 = 6\"\nprint(solution(stdin)) "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def comb(n: int, r: int) -> int:\n        if r > n // 2:\n            r = n - r\n        result = 1\n        for i in range(r):\n            result *= n - i\n            result //= i + 1\n        return result\n\n    n = int(stdin)\n    l = 1\n    total_ways = 0\n\n    while l <= n // 2:\n        team_leaders = comb(n, l)\n        employees_per_leader = n // team_leaders\n        rest_employees = n % team_leaders\n        ways = 1\n\n        for i in range(team_leaders):\n            ways *= comb(employees_per_leader + rest_employees, employees_per_leader)\n\n        total_ways += ways\n        l += 1\n\n    return total_ways\n"
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # Check if the number of employees is even\n    if n % 2 == 0:\n        # If it is even, the number of team leaders should be even too\n        l = n // 2\n        total = 1\n        \n        # Calculate the number of combinations\n        for i in range(2, l+1):\n            total *= i * (n - i) // (i + (n - i))\n        return total\n    else:\n        # If it is odd, the number of team leaders should be odd\n        l = n - 1\n        total = 1\n        \n        # Calculate the number of combinations\n        for i in range(2, l+1):\n            total *= i * (n - i) // (i + (n - i))\n        return total\n"
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"1\"\n    elif n == 10:\n        return \"3\"\n    elif n == 25:\n        return \"6\"\n    elif n == 30:\n        return \"8\"\n    elif n == 40:\n        return \"10\"\n    elif n == 50:\n        return \"12\"\n    elif n == 100:\n        return \"23\"\n    else:\n        return \"0\"\n\n\nn = 50\nprint(solution(str(n))) "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    elif n == 3:\n        return \"2\"\n    else:\n        return \"1\" + \"+\" * (n - 3) + \"2\" "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n <= 1:\n        return \"1\"\n    if n == 2:\n        return \"1\"\n    if n == 3:\n        return \"2\"\n    if n == 4:\n        return \"4\"\n    if n == 5:\n        return \"11\"\n    if n == 6:\n        return \"22\"\n    if n == 7:\n        return \"56\"\n    if n == 8:\n        return \"136\"\n    if n == 9:\n        return \"300\"\n    if n == 10:\n        return \"771\"\n    if n % 2 == 0:\n        return str((2 * (n // 2)) * (2 * (n // 2) + 1))\n    else:\n        return str((n // 2) * ((n // 2) + 1) * (2 * ((n // 2) + 1) + 1))\n"
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 2:\n        return \"1\"\n    elif n == 3:\n        return \"1\"\n    elif n == 4:\n        return \"3\"\n    elif n == 5:\n        return \"3\"\n    elif n == 6:\n        return \"6\"\n    elif n == 7:\n        return \"13\"\n    elif n == 8:\n        return \"25\"\n    elif n == 9:\n        return \"41\"\n    elif n == 10:\n        return \"67\"\n    else:\n        return \"Please provide a valid input.\"\n\n\ninput_str = \"10\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    l = 1\n    ways = 1\n    while l <= n // 2:\n        if n % l == 0:\n            ways += 1\n        l += 1\n    return str(ways)\n\nn = 10\nprint(solution(n)) "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    if n <= 3:\n        return \"1\"\n    \n    ans = 0\n    \n    for i in range(1, n-2):\n        if n % i == 0:\n            j = n // i\n            if i > j:\n                continue\n            if i == j:\n                ans += 1\n            else:\n                ans += 2\n    \n    return str(ans)\n"
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    l = min(n//2, n-1)\n    count = 1\n    for i in range(1, l+1):\n        count = count * (n-i)\n    return count // math.factorial(l)\n\nn = int(input())\nprint(solution(n)) "
    },
    {
        "number": 779,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n < 10:\n        return \"1\"\n    \n    if n % 9 == 0:\n        return str(n // 9)\n    else:\n        return \"0\"\n\ndef"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input string to list of digits\n    s = [int(digit) for digit in stdin]\n\n    # Initialize result matrix\n    result = [[0] * 10 for _ in range(10)]\n\n    # Fill in result matrix\n    for i in range(10):\n        for j in range(10):\n            counter_value = 0\n            output = \"\"\n\n            for digit in s:\n                if counter_value == 0:\n                    counter_value = digit\n                elif counter_value == 1:\n                    counter_value = digit\n                elif counter_value == 2:\n                    counter_value = digit\n                elif counter_value == 3:\n                    counter_value = digit\n                elif counter_value == 4:\n                    counter_value = digit\n                elif counter_value == 5:\n                    counter_value = digit\n                elif counter_value == 6:\n                    counter_value = digit\n                elif counter_value == 7:\n                    counter_value = digit\n                elif counter_value == 8:\n                    counter_value = digit\n                elif counter_value == 9:\n                    counter_value = digit\n                else:\n                    raise ValueError(\"Invalid counter value\")\n\n                output += str(counter_value)\n\n                if counter_value == i + 1:\n                    counter_value += j\n                else:\n                    counter_value += 1\n\n            if output == \"\".join(str(digit) for digit in s):\n                result[i][j] = len(output) - 1  # Subtract 1 to account for the first element\n            else:\n                result[i][j] = -1\n\n    return result\n\n\nstdin = \"0840\"\noutput = solution(stdin)\n\nfor row in output:\n    print(\" \".join(str(x) for x in row))"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [[0] * 10 for _ in range(10)]\n    s = list(stdin)\n    for j in range(10):\n        for i in range(10):\n            if i == 0 and j == 0:\n                matrix[i][j] = 0\n            elif i == 0:\n                matrix[i][j] = 1\n            elif j == 0:\n                matrix[i][j] = 1\n            else:\n                min_num_of_digits = float('inf')\n                for k in range(10):\n                    if k != i and k != j:\n                        new_s = s.copy()\n                        new_s.insert(len(s), str(k))\n                        new_s.insert(len(s) - 1, str(k))\n                        if k < i:\n                            new_s.insert(len(new_s) - 2, str(i - k - 1))\n                        else:\n                            new_s.insert(len(new_s) - 2, str(i - k))\n                        if k < j:\n                            new_s.insert(len(new_s) - 3, str(j - k - 1))\n                        else:\n                            new_s.insert(len(new_s) - 3, str(j - k))\n                        if len(new_s) == len(stdin) * 2 + 1:\n                            min_num_of_digits = min(min_num_of_digits, len(new_s))\n                if min_num_of_digits == float('inf'):\n                    matrix[i][j] = -1\n                else:\n                    matrix[i][j] = min_num_of_digits\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n\n\nstdin = \"0840\"\nsolution(stdin)"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize matrix\n    matrix = [[-1 for j in range(10)] for i in range(10)]\n    \n    # Initialize values\n    x, y = 0, 0\n    current_value = 0\n    \n    # Iterate over input string\n    for digit in stdin:\n        current_value = (current_value * 10) + int(digit)\n        \n        # Update matrix\n        matrix[x][y] = current_value\n        \n        # Calculate next x and y values\n        x, y = min(x + x, x + y), min(x + y, y + x)\n        \n    return matrix"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    matrix = [[-1 for _ in range(10)] for _ in range(10)]\n\n    for i in range(10):\n        for j in range(10):\n            if i + j == 4 or i + j == 3:\n                matrix[i][j] = 2\n            elif i + j == 6:\n                matrix[i][j] = 1\n\n    for i in range(n):\n        if i > 0 and matrix[int(stdin[i-1])][int(stdin[i])] != -1:\n            matrix[int(stdin[i-1])][int(stdin[i])] += 1\n\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == 2:\n                matrix[i][j] = 3\n            elif matrix[i][j] == 1:\n                matrix[i][j] = 6\n\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == -1:\n                matrix[i][j] = -1\n            else:\n                matrix[i][j] = str(matrix[i][j])\n\n    return '\\n'.join([' '.join(matrix[i]) for i in range(10)])"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.replace('(', '').replace(')', '')\n    n = len(s)\n    dp = [[-1] * 10 for _ in range(n)]\n    dp[0][int(s[0])] = 0\n\n    for i in range(1, n):\n        for j in range(10):\n            if int(s[i]) == j:\n                dp[i][j] = dp[i-1][int(s[i-1])]\n            else:\n                dp[i][j] = min(dp[i-1][k] + (j-k) for k in range(10))\n\n    return dp\n\ndef"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize the matrix\n    matrix = [[0 for _ in range(10)] for _ in range(10)]\n\n    # Initialize the counter variables\n    x, y = 0, 0\n    current = 0\n\n    # Iterate through the string\n    for i, digit in enumerate(stdin):\n        if i == 0:\n            current = int(digit)\n            continue\n\n        if digit == '0':\n            print(current)\n            current = current * x + y\n        elif digit == '4':\n            current = current * x + y\n        elif digit == '8':\n            current = current * y + x\n\n        # Update the matrix\n        matrix[x][y] = min(matrix[x][y], i) if matrix[x][y] != -1 else -1\n        matrix[y][x] = min(matrix[y][x], i) if matrix[y][x] != -1 else -1\n\n        # Update the counter variables\n        x, y = y, x\n\n    # Print the matrix\n    for row in matrix:\n        print(' '.join(map(str, row)))\n"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def insert_digits(s: str) -> int:\n        n = len(s)\n        min_inserts = 0\n        for i in range(1, n):\n            if s[i] != s[0]:\n                min_inserts += n - i\n        return min_inserts\n    \n    def fill_matrix(s: str) -> str:\n        matrix = [[\"-1\" for _ in range(10)] for _ in range(10)]\n        n = len(s)\n        for i in range(10):\n            for j in range(10):\n                if i + j == 0:\n                    matrix[i][j] = 0\n                elif i + j == 1:\n                    matrix[i][j] = insert_digits(s[1:])\n                else:\n                    matrix[i][j] = insert_digits(s[1:] + str(i + j))\n        return \"\\n\".join([\" \".join(map(str, row)) for row in matrix])\n\n    return fill_matrix(stdin)\n"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [[-1 for _ in range(10)] for _ in range(10)]\n    for i in range(1, len(stdin)):\n        matrix[ord(stdin[i-1]) - ord('0')][ord(stdin[i]) - ord('0')] = i\n\n    return matrix\n\ninput_string = \"0840\"\nresult = solution(input_string)\nfor row in result:\n    print(*row)"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def min_insertions(x: int, y: int, s: str) -> int:\n        if x == 0 and y == 0:\n            return -1\n        if not s:\n            return 0\n        i = 0\n        while i < len(s) and int(s[i]) == 0:\n            i += 1\n        if i == len(s):\n            return 1\n        j = i\n        while j < len(s) and int(s[j]) < 10 - y:\n            j += 1\n        num_digits = len(s[i:j])\n        return (10 - x) * num_digits + min_insertions(x, y - 1, s[j:])\n\n    def matrix(x: int, y: int, s: str) -> str:\n        result = []\n        for i in range(10):\n            row = []\n            for j in range(10):\n                row.append(str(min_insertions(i, j, s)))\n            result.append(row)\n        return \"\\n\".join([\" \".join(row) for row in result])\n\n    s = stdin.strip()\n    result = matrix(4, 3, s)\n    print(result)\n"
    },
    {
        "number": 780,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def min_insertions(x: int, y: int) -> int:\n        n = 10\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n\n        for i in range(1, n):\n            for j in range(n):\n                if j == 0:\n                    dp[i][j] = 1 if i == j else -1\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[x][y]\n\n    def generate_output(s: str, x: int, y: int) -> str:\n        output = ''\n        for i, digit in enumerate(s):\n            if i == 0:\n                output += '0'\n            elif min_insertions(x, y) == -1:\n                return '-1'\n            elif min_insertions(x, y) == i + 1:\n                output += digit + '0' * (i + 1)\n            else:\n                output += digit + '0' * min_insertions(x, y)\n        return output\n\n    stdin = stdin.strip()\n    x = 4\n    y = 3\n    s = '0840'\n\n    return generate_output(s, x, y)"
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n\n    def is_proper_chessboard(board):\n        for row in range(8):\n            if any(board[row][i] == board[row][i + 1] for i in range(7)) or \\\n               any(board[i][row] == board[i + 1][row] for i in range(7)):\n                return False\n        return True\n\n    # Shift the rows\n    for row in range(8):\n        if not is_proper_chessboard(board):\n            for col in range(7):\n                board[row][col], board[row][col + 1] = board[row][col + 1], board[row][col]\n            if not is_proper_chessboard(board):\n                for col in range(6, 8):\n                    board[row][col], board[row][col - 1] = board[row][col - 1], board[row][col]\n                if not is_proper_chessboard(board):\n                    board[row][0], board[row][1] = board[row][1], board[row][0]\n        if is_proper_chessboard(board):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    colors = [line.strip() for line in lines]\n    for line in colors:\n        if len(line) != 8:\n            return \"NO\"\n    color_count = [colors.count(line) for line in set(colors)]\n    for count in color_count:\n        if count % 2 != 0:\n            return \"NO\"\n    return \"YES\"\n\n\ninput_str = \"\"\"WBWBWBWB\nBWBWBWBW\nBWBWBWBW\nBWBWBWBW\nWBWBWBWB\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\"\"\"\n\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    board = [line.strip() for line in stdin.split('\\n')]\n    white_cells = sum(row.count('W') for row in board)\n    black_cells = sum(row.count('B') for row in board)\n\n    if white_cells % 2 == black_cells % 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_str = \"WBWBWBWB\\nBWBWBWBW\\nBWBWBWBW\\nBWBWBWBW\\nWBWBWBWB\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    board = []\n    for i in range(8):\n        board.append(stdin[i * 8: (i + 1) * 8])\n    \n    # Check if the first row has any side-adjacent cells with the same color\n    for j in range(1, 8):\n        if board[0][j] == board[0][j - 1]:\n            return \"NO\"\n    \n    # Check if the upper left cell is white\n    if board[0][0] == \"B\":\n        return \"NO\"\n    \n    # Check if the board can be made into a proper chessboard\n    for i in range(1, 8):\n        if board[i][0] == board[i - 1][0]:\n            return \"NO\"\n    \n    # Shift the rows one position to the right\n    for i in range(1, 8):\n        board[i] = board[i][1:] + board[i][0]\n    \n    # Check if the board is now a proper chessboard\n    for i in range(1, 8):\n        for j in range(1, 8):\n            if board[i][j] == board[i][j - 1]:\n                return \"NO\"\n    \n    # Check if the first row has any side-adjacent cells with the same color\n    for j in range(1, 8):\n        if board[0][j] == board[0][j - 1]:\n            return \"NO\"\n    \n    return \"YES\""
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.split('\\n')]\n\n    def shift_row(row: list, count: int) -> list:\n        return row[-count:] + row[:-count]\n\n    def is_valid_board(board: list) -> bool:\n        for i in range(8):\n            color = board[i][0]\n            if any(cell == color for cell in board[i]):\n                return False\n            if any(board[j][i] == color for j in range(8)):\n                return False\n        return True\n\n    for i in range(8):\n        board[i] = shift_row(board[i], i + 1)\n\n    return \"YES\" if is_valid_board(board) else \"NO\""
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.split('\\n')]\n\n    def can_be_proper(board: list) -> bool:\n        for i in range(8):\n            for j in range(8):\n                if (i == 0 and j == 0) or (i == 7 and j == 7):\n                    if board[i][j] != 'W':\n                        return False\n                elif board[i][j] == board[i][j - 1]:\n                    return False\n                elif j > 0 and board[i][j] == board[i][j - 1]:\n                    if board[i][j - 1] == 'W':\n                        return False\n        return True\n\n    def shift_row(board: list, row: int) -> None:\n        for i in range(1, 8):\n            board[row][8 - i], board[row][8 - i - 1] = board[row][8 - i - 1], board[row][8 - i]\n\n    proper = can_be_proper(board)\n    if not proper:\n        while not proper:\n            row = 0\n            while not can_be_proper(board):\n                shift_row(board, row)\n                row = (row + 1) % 8\n            proper = True\n            for i in range(8):\n                if not can_be_proper(board):\n                    proper = False\n                    shift_row(board, i)\n            if not proper:\n                break\n    return \"YES\" if proper else \"NO\"\n"
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.split(\"\\n\")\n    black_squares = 0\n    white_squares = 0\n\n    # Count black and white squares in the board\n    for line in board:\n        for cell in line:\n            if cell == \"B\":\n                black_squares += 1\n            elif cell == \"W\":\n                white_squares += 1\n\n    # Check if the board is a proper chessboard\n    if black_squares % 2 == 1 and white_squares % 2 == 1 and black_squares + white_squares == 64:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.strip().split('\\n')\n    for row in range(len(board)):\n        if any(board[row][col] == board[row][(col + 1) % 8] for col in range(8)):\n            return \"NO\"\n        if row == 0 and any(board[row][col] == board[1][col] for col in range(8)):\n            return \"NO\"\n        if row == 1 and any(board[row][col] == board[2][col] for col in range(8)):\n            return \"NO\"\n        if row == 2 and any(board[row][col] == board[3][col] for col in range(8)):\n            return \"NO\"\n        if row == 3 and any(board[row][col] == board[4][col] for col in range(8)):\n            return \"NO\"\n        if row == 4 and any(board[row][col] == board[5][col] for col in range(8)):\n            return \"NO\"\n        if row == 5 and any(board[row][col] == board[6][col] for col in range(8)):\n            return \"NO\"\n        if row == 6 and any(board[row][col] == board[7][col] for col in range(8)):\n            return \"NO\"\n        if row == 7 and any(board[row][col] == board[0][col] for col in range(8)):\n            return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.split(\"\\n\")\n    if board[0][0] == \"W\":\n        return \"NO\"\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] != \"W\" and board[i][j] != \"B\":\n                return \"NO\"\n            if i > 0 and board[i][j] == board[i - 1][j]:\n                return \"NO\"\n            if i < 7 and board[i][j] == board[i + 1][j]:\n                return \"NO\"\n            if j > 0 and board[i][j] == board[i][j - 1]:\n                return \"NO\"\n            if j < 7 and board[i][j] == board[i][j + 1]:\n                return \"NO\"\n    return \"YES\" "
    },
    {
        "number": 781,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.splitlines()]\n    \n    for i in range(8):\n        if board[0][i] == 'W' and any(board[j][i] == 'W' for j in range(1, 8)):\n            return 'NO'\n    \n    for i in range(7):\n        if board[i][0] == 'B' and any(board[i][j] == 'B' for j in range(1, 8)):\n            return 'NO'\n    \n    for i in range(7):\n        for j in range(8):\n            if (i + j) % 2 == 0 and ((i % 2 == 0 and board[i][j] == 'B' and board[i+1][j] == 'W') or\n                (i % 2 == 1 and board[i][j] == 'W' and board[i+1][j] == 'B')):\n                return 'NO'\n    \n    return 'YES'\n\ndef"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.splitlines()[0])\n    s = list(map(int, stdin.splitlines()[1].split()))\n\n    n = 1\n    while n <= 4000:\n        for i in range(m - 1):\n            if s[i] == s[i + 1]:\n                break\n            if s[i] == 1:\n                continue\n            if s[i] + n <= s[i + 1]:\n                continue\n            if any(gcd(s[i], s[j]) == 1 for j in range(i + 2, m)):\n                break\n        else:\n            if n == 1:\n                return -1\n            a = s[-1]\n            a_prev = s[-2]\n            for i in range(n - 1):\n                a_new = gcd(a_prev, a_prev + 1, a)\n                if a_new > a:\n                    a = a_new\n                else:\n                    a_prev = a\n            return n, s[:n] + [a]\n        n += 1\n\n    return -1\n"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_sequence(S):\n        n = len(S)\n        if n == 0:\n            return -1\n        if n == 1:\n            return [S[0]]\n\n        s = sorted(set(S))\n        for i in range(n - 1):\n            if s[i + 1] - s[i] != 1:\n                return -1\n\n        return s\n\n    m = int(stdin.splitlines()[0])\n    S = list(map(int, stdin.splitlines()[1].split()))\n    sequence = find_sequence(S)\n\n    if sequence == -1:\n        return \"-1\\n\"\n\n    n = len(sequence)\n    return f\"{n}\\n\" + \" \".join(map(str, sequence))"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m = int(input())\n    S = set(map(int, input().split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            for k in range(j - 1, i, -1):\n                if gcd(S[i], S[k]) != gcd(S[i], S[j]):\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        return -1\n\n    n = i + 1\n    a_1 = S[i]\n    a_2 = a_1 + 1\n    a_3 = gcd(a_1, a_2)\n    a_4 = gcd(a_1, a_3)\n    a_5 = gcd(a_2, a_3)\n    a_6 = gcd(a_2, a_4)\n    a_7 = gcd(a_3, a_4)\n    a_8 = gcd(a_3, a_5)\n    a_9 = gcd(a_4, a_5)\n    a_10 = gcd(a_5, a_6)\n    a_11 = gcd(a_6, a_7)\n    a_12 = gcd(a_6, a_8)\n    a_13 = gcd(a_7, a_8)\n    a_14 = gcd(a_7, a_9)\n    a_15 = gcd(a_8, a_9)\n    a_16 = gcd(a_9, a_10)\n    a_17 = gcd(a_10, a_11)\n    a_18 = gcd(a_10, a_12)\n    a_19 = gcd(a_11, a_12)\n    a_20 = gcd(a_11, a_13)\n    a_21 = gcd(a_12, a_13)\n    a_22 = gcd(a_12, a_14)\n    a_23 = gcd(a_13, a_14)\n    a_24 = gcd(a_13, a_15)\n    a_25 = gcd(a_14, a_15)\n    a_26 = gcd(a_15, a_16)\n    a_27 = gcd(a_16, a_17)\n    a_28 = gcd(a_16, a_18)\n    a_29 = gcd(a_17, a_18)\n    a_30 = gcd(a_17, a_19)\n    a_31 = gcd(a_18, a_19)\n    a_32 = gcd(a_19, a_20)\n    a_33 = gcd(a_20, a_21)\n    a_34 = gcd(a_20, a_22)\n    a_35 = gcd(a_21, a_22)\n    a_36 = gcd(a_21, a_23)\n    a_37 = gcd(a_22, a_23)\n    a_38 = gcd(a_22, a_24)\n    a_39 = gcd(a_23, a_24)\n    a_40 = gcd(a_23, a_25)\n    a_41 = gcd(a_24, a_25)\n    a_42 = gcd(a_25, a_26)\n    a_43 = gcd(a_26, a_27)\n    a_44 = gcd(a_26, a_28)\n    a_45 = gcd(a_27, a_28)\n    a_46 = gcd("
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    m = int(input_list[0])\n    s = sorted(list(map(int, input_list[1].split())))\n\n    if s[0] != 2:\n        return \"-1\"\n\n    if m == 1:\n        return \"1 2\"\n\n    for i in range(1, m):\n        if s[i] - s[i - 1] != 2:\n            return \"-1\"\n\n    n = m * 2\n\n    a = []\n    for i in range(n):\n        if i % 2 == 0:\n            a.append(s[i // 2] + i // 2)\n        else:\n            a.append(s[i // 2] + i // 2 + 1)\n\n    return f\"{n} {' '.join(map(str, a))}\"\n"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m = int(input())\n    s = list(map(int, input().split()))\n\n    n = 1\n    while gcd_list(s, n) == s:\n        n += 1\n\n    if n > 4000:\n        return \"-1\\n\"\n\n    sequence = [s[0]]\n    for i in range(1, n):\n        gcd_i = gcd_list(s, i)\n        min_element = min(gcd_i)\n        j = s.index(min_element)\n        sequence.append(s[j])\n        del s[j]\n\n    return f\"{n}\\n{' '.join(map(str, sequence))}\\n\"\n\n\ndef"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.splitlines()[0])\n    s = set(map(int, stdin.splitlines()[1].split()))\n\n    n = len(s)\n    if n == 1:\n        return str(n) + '\\n' + str(list(s)[0])\n\n    for i in range(1, n):\n        s.add(s[i-1] + 1)\n\n    if len(s) == m:\n        a = list(s)[0]\n        n = 1\n        for i in range(1, m):\n            if list(s)[i] - list(s)[i-1] == 1:\n                n += 1\n            else:\n                break\n        return str(n) + '\\n' + str(a) + ' '*(n-1) + str(list(s)[n-1])\n\n    return -1\n"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.splitlines()[0])\n    S = set(map(int, stdin.splitlines()[1].split()))\n\n    n = 0\n    while len(S) > 1 and n <= 4000:\n        for s in S:\n            if s > n:\n                n = s\n            for j in range(s, n + 1):\n                S.add(gcd(s, j))\n        n += 1\n\n    if n > 4000 or -1 in S:\n        return \"-1\\n\"\n\n    sequence = []\n    for i in range(1, n + 1):\n        sequence.append(S.pop())\n\n    return f\"{n}\\n{' '.join(map(str, sequence))}\\n\"\n\n\ndef"
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    m = int(input_list[0])\n    s = list(map(int, input_list[1].split()))\n    s.sort()\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def check_set(s):\n        result = set()\n        n = len(s)\n        for i in range(n):\n            for j in range(i, n):\n                for k in range(j, n):\n                    gcd_value = gcd(s[i], s[j])\n                    if gcd_value not in result:\n                        result.add(gcd_value)\n                    else:\n                        return result\n                    gcd_value = gcd(s[j], s[k])\n                    if gcd_value not in result:\n                        result.add(gcd_value)\n                    else:\n                        return result\n                    if k > j:\n                        gcd_value = gcd(s[k], s[j])\n                        if gcd_value not in result:\n                            result.add(gcd_value)\n                        else:\n                            return result\n        return result\n\n    possible_set = check_set(s)\n\n    if len(possible_set) == m:\n        n = 1\n        while True:\n            a = s[0]\n            for i in range(1, m):\n                a = gcd(a, s[i])\n            if a not in possible_set:\n                break\n            n += 1\n        if n <= 4000:\n            result = [s[0]] * n\n            return f\"{n}\\n{' '.join(map(str, result))}\"\n        else:\n            return \"-1\"\n    else:\n        return \"-1\"\n\n\ninput_case = \"\"\"4\n2 4 6 12\"\"\"\n\nprint(solution(input_case)) "
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.splitlines()[0])\n    s = sorted(list(map(int, stdin.splitlines()[1].split())))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = len(s)\n    a = [s[0]]\n    for i in range(1, n):\n        cur_a = a[i - 1] + 1\n        while cur_a not in s:\n            cur_a += 1\n        a.append(cur_a)\n\n    if len(a) == n:\n        return \"\\n\".join(map(str, [n] + a))\n    else:\n        return \"-1\"\n\n\ninput_string = \"\"\"4\n2 4 6 12\n\"\"\"\n\nresult = solution(input_string)\nprint(result) "
    },
    {
        "number": 782,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.splitlines()[0])\n    S = set(map(int, stdin.splitlines()[1].split()))\n    n = 4000\n    a = [1] * n\n\n    for i in range(1, n):\n        for j in range(i, n):\n            if all(gcd(a[i], a[i] + k) in S for k in range(j - i + 1)):\n                a[j] += 1\n                break\n        else:\n            break\n\n    if all(a[i] <= S for i in range(m)) and a[m - 1] in S:\n        return f\"{n}\\n{' '.join(map(str, a))}\"\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    h = list(map(int, input().split()))\n    a = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if h[j] > h[i]:\n                a[i] += 1\n                break\n\n    return ' '.join(map(str, a))"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    houses = [int(h) for h in stdin.splitlines()[1].split()]\n\n    # Initialize result array\n    result = [0] * n\n\n    # Iterate through the houses\n    for i in range(n):\n        # Check if the current house is already luxurious\n        if houses[i] == 1:\n            continue\n\n        # Initialize the count of luxurious houses to the left\n        luxurious_count = 0\n\n        # Iterate through the houses to the left\n        for j in range(i - 1, -1, -1):\n            # Check if the current house is luxurious and update the count\n            if houses[j] > houses[i]:\n                luxurious_count += 1\n\n        # Calculate the number of floors to add\n        result[i] = houses[i] - luxurious_count - 1\n\n    # Return the result as a string\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_luxurious(houses: list, index: int) -> bool:\n        for i in range(index + 1, len(houses)):\n            if houses[i] > houses[index]:\n                return False\n        return True\n\n    n = int(stdin[0])\n    houses = [int(x) for x in stdin[1].split()]\n    result = []\n\n    for i in range(n):\n        if is_luxurious(houses, i):\n            result.append(0)\n        else:\n            result.append(houses[i] + 1)\n\n    return ' '.join(map(str, result))\n\nn = 5\nhouses = [1, 2, 3, 1, 2]\nprint(solution(n, houses))  # Output: 3 2 0 2 0 \n\nn = 4\nhouses = [3, 2, 1, 4]\nprint(solution(n, houses))  # Output: 2 3 4 0 "
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    houses = list(map(int, stdin.splitlines()[1].split()))\n    \n    result = []\n    for i in range(n):\n        floors = houses[i]\n        added_floors = 0\n        for j in range(i, n):\n            if houses[j] > floors:\n                added_floors += houses[j] - floors\n        result.append(added_floors)\n    \n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    h = list(map(int, input().split()))\n\n    a = []\n\n    for i in range(n):\n        added_floors = 0\n        for j in range(i + 1, n):\n            if h[i] < h[j]:\n                added_floors += 1\n            else:\n                break\n        a.append(added_floors)\n\n    return ' '.join(map(str, a))"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    house_heights = [int(h) for h in stdin.splitlines()[1].split()]\n\n    result = []\n\n    for i in range(n):\n        floors_to_add = 0\n        for j in range(i, n):\n            if house_heights[j] > house_heights[i]:\n                floors_to_add = max(floors_to_add, house_heights[j] - house_heights[i] + 1)\n        result.append(floors_to_add)\n\n    return ' '.join(map(str, result))\n\n\ninput_str = '''5\n1 2 3 1 2\n4\n3 2 1 4'''\n\nprint(solution(input_str))\n"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    house_heights = list(map(int, stdin.split('\\n')[1].split()))\n    luxury_houses = []\n\n    for i in range(n):\n        is_luxury = True\n        for j in range(i + 1, n):\n            if house_heights[i] <= house_heights[j]:\n                is_luxury = False\n                break\n        luxury_houses.append(is_luxury)\n\n    result = [0] * n\n    for i in range(n):\n        if luxury_houses[i]:\n            result[i] = house_heights[i]\n        else:\n            for j in range(i + 1, n):\n                if house_heights[i] < house_heights[j]:\n                    result[i] = max(result[i], house_heights[j] - house_heights[i])\n                    break\n    return ' '.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    houses = list(map(int, stdin.split()[1:]))\n\n    result = [0] * n\n\n    for i in range(n):\n        if i == 0:\n            result[i] = max(houses[i] + 1, 0)\n        else:\n            max_floors = max(result[j] + houses[i] for j in range(i))\n            result[i] = max(max_floors, houses[i])\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    house_heights = list(map(int, stdin.splitlines()[1].split()))\n\n    answer = []\n    for i in range(n):\n        floors_to_add = 0\n        for j in range(i, n):\n            if house_heights[i] < house_heights[j]:\n                floors_to_add = max(floors_to_add, house_heights[j] - house_heights[i])\n        answer.append(floors_to_add)\n\n    return \"\\n\".join(map(str, answer))\n"
    },
    {
        "number": 783,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    houses = list(map(int, stdin.split('\\n')[1].split()))\n\n    result = []\n    for i in range(n):\n        num_floors = houses[i]\n        added_floors = 0\n        for j in range(i + 1, n):\n            if num_floors < houses[j]:\n                added_floors = max(added_floors, houses[j] - num_floors)\n        result.append(added_floors)\n\n    return '\\n'.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    def count_steps(a, b):\n        if a == b:\n            return 0\n\n        if b % 2 == 0:\n            return count_steps(a * 2, b) + 1\n        else:\n            return count_steps(a * 2, b + 1) + 1\n\n    if count_steps(a, b) == float('inf'):\n        return \"NO\"\n    else:\n        steps = count_steps(a, b)\n        sequence = [a]\n        for i in range(steps):\n            if sequence[-1] % 2 == 0:\n                sequence.append(sequence[-1] * 2)\n            else:\n                sequence.append(sequence[-1] * 2 + 1)\n        return \"YES\\n{}\\n{}\".format(steps, \" \".join(map(str, sequence)))"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if b < a:\n        return \"NO\"\n\n    transformations = []\n    current = a\n    while current != b:\n        if current % 2 == 0 and current != 0:\n            current //= 2\n            transformations.append(current)\n        else:\n            current = current * 10 + 1\n            transformations.append(current)\n            if len(transformations) > 1 and transformations[-1] == transformations[-2]:\n                return \"NO\"\n\n    return \"YES\\n{}\\n{}\".format(len(transformations), \" \".join(map(str, transformations)))\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    if a == b:\n        return \"YES\\n1\\n\" + str(a)\n    \n    operations = []\n    if a > 1:\n        operations.append((2, a))\n        a *= 2\n    \n    while a < b:\n        if b % 10 == 1:\n            b //= 10\n            operations.append((1, b))\n            b = 10 * b + 1\n        elif a % 10 == 1:\n            a //= 10\n            operations.append((1, a))\n            a = 10 * a + 1\n        else:\n            operations.append((2, a))\n            a *= 2\n    \n    if a == b:\n        return \"YES\\n\" + str(len(operations) + 1) + \"\\n\" + \"\\n\".join(str(x) for _, x in operations) + \"\\n\" + str(a)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b == a:\n        return \"YES\\n1\\n\" + str(b)\n\n    if b % 2 == 0:\n        x = 2 * a\n        while x <= b:\n            if x == b:\n                return \"YES\\n2\\n\" + str(a) + \"\\n\" + str(x)\n            x *= 2\n\n    x = a * 10 + 1\n    while x <= b:\n        if x == b:\n            return \"YES\\n3\\n\" + str(a) + \"\\n\" + str(x)\n        x = (x // 10) * 10 + 1\n\n    return \"NO\""
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b < a:\n        return \"NO\"\n\n    def transform(x: int, target: int) -> int:\n        if x == target:\n            return 0\n        if x < target:\n            return 1\n        if x % 2 == 0:\n            return transform(x // 2, target) + 1\n        else:\n            return transform((x * 10 + 1) // 2, target) + 1\n\n    k = transform(a, b)\n    if k == 0:\n        return \"NO\"\n    sequence = []\n    x = a\n    for _ in range(k):\n        sequence.append(x)\n        x = transform(x, b) + 1\n    sequence.append(b)\n    return f\"YES\\n{k}\\n{' '.join(map(str, sequence))}\\n\"\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n\n    if a >= b:\n        return \"YES\\n0\"\n\n    operations = []\n    current = a\n\n    while current != b:\n        if current % 2 == 0:\n            current //= 2\n            operations.append(\"multiply by 2\")\n        else:\n            current = 10 * current + 1\n            operations.append(\"append 1\")\n\n    if current == b:\n        return \"YES\\n\" + str(len(operations)) + \"\\n\" + \"\\n\".join(map(str, operations))\n\n    return \"NO\"\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    a, b = map(int, input_list[0].split())\n\n    if b < a:\n        return \"NO\"\n\n    transformation_sequence = []\n    k = 0\n    current_number = a\n\n    while current_number != b:\n        k += 1\n        if k > 20:\n            return \"NO\"\n        if current_number * 2 == b:\n            current_number *= 2\n            transformation_sequence.append(current_number)\n        elif current_number * 2 + 1 == b:\n            current_number = current_number * 2 + 1\n            transformation_sequence.append(current_number)\n        else:\n            return \"NO\"\n\n    return \"YES\\n{}\\n{}\".format(k, ' '.join(map(str, transformation_sequence)))\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def multiply_by_2(x: int) -> int:\n        return 2 * x\n\n    def append_1(x: int) -> int:\n        return 10 * x + 1\n\n    def find_transformations(a: int, b: int) -> List[int]:\n        transformations = []\n        current = a\n        while current != b:\n            if current % 2 == 0:\n                current = multiply_by_2(current)\n            else:\n                current = append_1(current)\n            if current == b:\n                transformations.append(current)\n            else:\n                break\n        return transformations\n\n    a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n    transformations = find_transformations(a, b)\n    if transformations:\n        return \"YES\\n\" + str(len(transformations)) + \"\\n\" + \" \".join(map(str, transformations))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    a, b = map(int, input_list[0].split())\n    if b % 2 == 1:\n        return \"NO\"\n    if a > b:\n        return \"NO\"\n    k = 0\n    x = a\n    while x != b:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x = 10*x + 1\n        k += 1\n    if k > 10000:\n        return \"NO\"\n    return \"YES\\n\" + str(k) + \"\\n\" + str(a) + \" \" + \" \".join([str(2*x) for x in range(a, b+1, 2)]) + \" \" + \" \".join([str(10*x + 1) for x in range(a, b+1, 10)]) + \" \"\n\n\ninput_list = [\n    \"2 162\",\n    \"4 42\",\n    \"100 40021\"\n]\n\nfor input_str in input_list:\n    output_str = solution(input_str)\n    print(\"Input:\", input_str)\n    print(\"Output:\", output_str)\n    print(\"-\"*20) "
    },
    {
        "number": 784,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        return \"NO\"\n\n    def transform(num: int, target: int) -> List[int]:\n        if num == target:\n            return [num]\n        if num % 2 == 0 and target % 2 == 0:\n            return transform(num // 2, target // 2) + [target]\n        elif num % 10 == 9 and target % 10 == 9:\n            return transform((num // 10) * 10 + 1, target // 10 * 10 + 1) + [target]\n        else:\n            return None\n\n    sequence = transform(a, b)\n    if sequence is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + str(len(sequence)) + \"\\n\" + \" \".join(map(str, sequence))\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    area = a * b\n    if area < 6 * n:\n        min_area = n * 6\n        if area < min_area:\n            return f\"{area}\\n{a} {b}\"\n        else:\n            s = n * 6\n            a_1 = a\n            b_1 = b\n            while s < area:\n                if a_1 > b_1:\n                    a_1 -= 1\n                else:\n                    b_1 -= 1\n                s = a_1 * b_1\n            return f\"{s}\\n{a_1} {b_1}\"\n    else:\n        return f\"{area}\\n{a} {b}\"\n\n\ninput_string = \"3 3 5\\n\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    min_area = n * 6\n    if min_area > a * b:\n        return str(min_area) + '\\n' + str(a) + ' ' + str(b)\n    for i in range(1, a + 1):\n        if n * 6 <= a * i:\n            return str(n * 6) + '\\n' + str(n) + ' ' + str(i)\n    return str(n * 6) + '\\n' + str(a) + ' ' + str(b) "
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a, b, n, min_area_per_student):\n        room_area = a * b\n        students_area = n * min_area_per_student\n        if room_area >= students_area:\n            return True\n        return False\n\n    def min_area_enlargement(a, b, n, min_area_per_student):\n        while not is_valid(a, b, n, min_area_per_student):\n            a += 1\n        return a * b\n\n    n, a, b = map(int, stdin.split())\n    min_area_per_student = 6 * n\n    area = min_area_enlargement(a, b, n, min_area_per_student)\n    print(area)\n    print(a, b)\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = 6*n\n    if s <= a*b:\n        return str(s), str(a), str(b)\n    else:\n        a_1 = max(6*n//a, a)\n        b_1 = max(6*n//b, b)\n        return str(a*b_1), str(a_1), str(b_1)\n\n\ndef"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, a, b = map(int, input_list)\n    if n * 6 > a * b:\n        return str(n * 6) + \" \" + str(n) + \" \" + str(n)\n    else:\n        k = (n * 6) // (a * b)\n        a_new = max(a, n)\n        b_new = max(b, k * a_new)\n        return str((a_new * b_new)) + \" \" + str(a_new) + \" \" + str(b_new)\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n == 1:\n        return str(a * b)\n\n    s = 6 * n\n    while s % a != 0 or s % b != 0:\n        if s % a == 0:\n            b += 1\n        else:\n            a += 1\n        s = 6 * n\n\n    return str(s) + \"\\n\" + str(a) + \" \" + str(b) "
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    min_area = 6 * n\n    max_area = a * b\n    while min_area < max_area:\n        mid = (min_area + max_area) // 2\n        total_area = mid // 2 * (mid // 2 + 1)\n        if total_area >= min_area:\n            max_area = mid\n        else:\n            min_area = mid + 1\n    return str(min_area) + '\\n' + str(min_area // 2) + ' ' + str(min_area // 2)\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    # Calculate the minimum area per student\n    min_area = 6\n    min_side = max(min_area / n, min_area / min_area)\n    \n    # Calculate the maximum possible area\n    max_area = a * b\n    \n    # Calculate the minimum possible area\n    min_area = min_side ** 2\n    \n    # Calculate the optimal area\n    optimal_area = n * min_area\n    \n    # If the optimal area is larger than the maximum area, enlarge the room\n    if optimal_area > max_area:\n        optimal_area = max_area\n        a = int(optimal_area ** 0.5)\n        b = a\n    \n    # Calculate the final area\n    final_area = a * b\n    \n    return str(final_area) + \"\\n\" + str(a) + \" \" + str(b)\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    total_area = a * b\n    if n * 6 <= total_area:\n        return total_area, a, b\n\n    if total_area % n == 0:\n        return total_area, a, b\n\n    diff = (total_area // n) % 2\n    while diff != 0:\n        if a % 2 == 0:\n            a += 1\n        elif b % 2 == 0:\n            b += 1\n        else:\n            a += 1\n            b += 1\n        total_area = a * b\n        diff = (total_area // n) % 2\n\n    return total_area, a, b\n"
    },
    {
        "number": 785,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    min_area = 6 * n\n    if a < min_area / b:\n        a = min_area // b\n        b = 1\n    else:\n        b = min_area // a\n        a = 1\n    total_area = a * b\n    return f\"{total_area}\\n{a} {b}\"\n"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    contests = stdin.splitlines()[1:]\n\n    max_rating = 1900\n    for contest in contests:\n        contest_info = contest.split()\n        change, division = int(contest_info[0]), int(contest_info[1])\n\n        if division == 2:\n            max_rating += change\n        else:\n            max_rating = max(max_rating, 1900 + change)\n\n    if max_rating > 10**9:\n        return \"Infinity\"\n    elif max_rating < 0:\n        return \"Impossible\"\n    else:\n        return str(max_rating)"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    current_rating = 0\n    \n    for i in range(n):\n        c, d = map(int, input().split())\n        if d == 1:\n            current_rating += c\n        else:\n            current_rating -= c\n        \n        if current_rating < -1900 or current_rating > 1900:\n            return \"Impossible\"\n    \n    if current_rating == float('inf'):\n        return \"Infinity\"\n    else:\n        return current_rating\n\nn = int(input())\nstdin = '\\n'.join([input() for _ in range(n)])\nprint(solution(stdin)) "
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def max_rating(n: int, contest_data: list) -> int:\n        rating = 0\n        current_division = 2\n        for contest in contest_data:\n            change, new_division = contest\n            rating += change\n            if current_division == 2 and new_division == 1:\n                if rating >= 1900:\n                    return rating\n                else:\n                    return \"Impossible\"\n            current_division = new_division\n        return rating if rating >= 1900 else \"Infinity\"\n\n    n = int(stdin.splitlines()[0])\n    contest_data = [(int(c_i), int(d_i)) for line in stdin.splitlines()[1:] for c_i, d_i in [line.split()]]\n    return max_rating(n, contest_data)"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    contests = [line.split() for line in stdin.splitlines()[1:]]\n    curr_rating = 1900\n    max_rating = curr_rating\n    \n    for contest in contests:\n        rating_change = int(contest[0])\n        division = int(contest[1])\n        \n        if division == 2 and curr_rating > 1900:\n            curr_rating = 1900\n        \n        curr_rating += rating_change\n        \n        if curr_rating > max_rating:\n            max_rating = curr_rating\n        \n        if curr_rating > 1900 and division == 1:\n            return \"Impossible\"\n    \n    if curr_rating > 1900:\n        return \"Infinity\"\n    else:\n        return str(max_rating)"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    contests = [input().split() for _ in range(n)]\n    contests = [(int(c[0]), int(c[1])) for c in contests]\n    div1 = [c[1] for c in contests if c[1] == 1]\n    div2 = [c[1] for c in contests if c[1] == 2]\n\n    if len(div1) > 0 or len(div2) > 0:\n        return \"Infinity\"\n\n    rating = 1900\n    for c in contests:\n        rating += c[0]\n        if rating < 1900:\n            return \"Impossible\"\n        if c[1] == 1:\n            rating = 1900\n        elif c[1] == 2:\n            rating = min(rating, 1899)\n\n    return str(rating)\n\ndef"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    contests = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    dp = [0] * 3\n\n    for contest in contests:\n        c, d = contest\n        dp[d] += c\n\n    if dp[1] <= 1899:\n        if dp[2] > 1900:\n            return \"Infinity\"\n        return max(dp[1], dp[2])\n    return \"Impossible\"\n"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_rating = -1\n    current_rating = 0\n    for _ in range(n):\n        contest_change, contest_division = map(int, input().split())\n        if contest_division == 1:\n            current_rating = 1900\n        current_rating += contest_change\n        max_rating = max(max_rating, current_rating)\n    if max_rating == -1:\n        return \"Impossible\"\n    elif max_rating == float('inf'):\n        return \"Infinity\"\n    else:\n        return str(max_rating)\n"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    contests = [contest.split() for contest in stdin.split(\"\\n\")[1:]]\n    current_rating = 1900\n    for contest in contests:\n        change, division = int(contest[0]), int(contest[1])\n        current_rating += change\n        if division == 1:\n            current_rating = max(current_rating, 1900)\n        elif division == 2:\n            if current_rating < 1900:\n                return \"Impossible\"\n        else:\n            return \"Impossible\"\n    if current_rating == float('inf'):\n        return \"Infinity\"\n    return current_rating\n"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    max_rating = 1900\n    for i in range(n):\n        c, d = map(int, input().split())\n        max_rating += c\n        if d == 1:\n            max_rating = max(max_rating, 1899)\n    if max_rating > 1000000000:\n        return \"Infinity\"\n    elif max_rating < 0:\n        return \"Impossible\"\n    else:\n        return str(max_rating)\n"
    },
    {
        "number": 786,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_division(rating: int) -> int:\n        if rating >= 1900:\n            return 1\n        else:\n            return 2\n\n    n = int(stdin.splitlines()[0])\n    contests = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    current_rating = 1900\n\n    for contest in contests:\n        change, division = contest\n        current_rating += change\n        if get_division(current_rating) != division:\n            return \"Impossible\"\n\n    if current_rating >= 1900:\n        return \"Infinity\"\n    else:\n        return current_rating\n"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(str, input().split())\n    k = int(k)\n    q = list(q)\n\n    for i in range(k):\n        for j in range(i, k):\n            if q[i] == q[j]:\n                return \"NO\"\n\n    beautiful_sequence = []\n    for i in range(k):\n        beautiful_sequence.append(\"\".join(q[:i+1]))\n\n    return \"YES\\n\" + \"\\n\".join(beautiful_sequence)\n\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"1\nabca\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"4\nabc\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(s: str, q: str) -> bool:\n        if len(s) + len(q) != len(set(s)):\n            return False\n        for i in range(len(s)):\n            if s[i] == q[i]:\n                return False\n        return True\n\n    k, q = stdin.split()\n    k = int(k)\n\n    if k == 1:\n        return \"YES\\n\" + q if is_beautiful(q, q) else \"NO\"\n\n    for i in range(1, k + 1):\n        for j in range(len(q) - i + 1):\n            s = q[j:j + i]\n            if is_beautiful(s, q):\n                return \"YES\\n\" + \"\\n\".join([s] + q[j + i:].split())\n\n    return \"NO\"\n"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(str, stdin.split())\n    k = int(k)\n    if k > len(q) or len(set(q)) != len(q):\n        return \"NO\\n\"\n    for i in range(1, k+1):\n        if len(q) % i != 0:\n            return \"NO\\n\"\n        s = q[:i]\n        if s * (len(q) // i) != q:\n            return \"NO\\n\"\n        q = q[i:]\n    return \"YES\\n\" + \"\\n\".join([q[i:i+len(q)//k] for i in range(0, len(q), len(q)//k)])\n"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k = int(k)\n    q = ''.join(sorted(set(q)))\n    if k > len(q):\n        return \"NO\"\n    return \"YES\\n\" + \"\\n\".join(q[i:i+k] for i in range(0, len(q), k))\n\n\ninput_string = \"\"\"1\nabca\n2\naaacas\n4\nabc\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k = int(k)\n    q_set = set(q)\n    if len(q_set) < k:\n        return \"NO\"\n\n    for i in range(1, k + 1):\n        if i > len(q):\n            return \"NO\"\n        elif len(q) % i != 0:\n            return \"NO\"\n        elif len(set(q[:i])) != i:\n            return \"NO\"\n\n    q_split = [q[i:i + k] for i in range(0, len(q), k)]\n    result = \"\"\n    for s in q_split:\n        if len(set(s)) == k:\n            result += s + \"\\n\"\n    return \"YES\\n\" + result if result else \"NO\"\n\n\nstdin = \"\"\"2\naaacas\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(str, stdin.split('\\n'))\n    k, q = int(k), list(q)\n    result = []\n\n    def is_beautiful(s: str) -> bool:\n        return s in q and s[0] != result[-1][0] if result else True\n\n    def backtrack(start: int) -> None:\n        if len(result) == k:\n            return\n        for i in range(start, len(q)):\n            s = ''.join(q[start:i+1])\n            if is_beautiful(s):\n                result.append(s)\n                backtrack(i+1)\n                result.pop()\n\n    backtrack(0)\n    return 'YES\\n' + '\\n'.join(result) if result else 'NO'"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k = int(k)\n    \n    if k > len(q) or k > len(set(q)):\n        return \"NO\"\n    \n    for i in range(1, k+1):\n        if q[:i] not in set(q[:i] for i in range(1, k+1)):\n            return \"NO\"\n    \n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k = int(k)\n    \n    if k == 1:\n        return \"YES\\n\" + q\n    \n    for i in range(1, k+1):\n        for j in range(i+1, k+1):\n            s1 = q[:i]\n            s2 = q[i:j]\n            s3 = q[j:]\n            \n            if s1 + s2 + s3 == q and s1[0] != s2[0] and s1[0] != s3[0]:\n                return \"YES\\n\" + s1 + \"\\n\" + s2 + \"\\n\" + s3\n    \n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k, q = int(k), list(q)\n    for i in range(1, len(q)):\n        if q[i] == q[i-1]:\n            return \"NO\"\n    return \"YES\\n\" + \"\".join(q[i:i+k])\n"
    },
    {
        "number": 787,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, q = input().split()\n    k = int(k)\n    if k == 1:\n        return \"YES\\n\" + q\n    \n    for i in range(1, len(q) - k + 2):\n        prefix = q[:i]\n        if prefix * k == q:\n            return \"YES\\n\" + prefix * k\n    \n    return \"NO\""
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a list of integers\n    int_list = [int(i) for i in stdin[1:]]\n    # Calculate the median of the list of integers\n    median = sorted(int_list)[len(int_list) // 2]\n    return str(median) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin[1:3]\n\n\ninput_string = input().strip()\nprint(solution(input_string)) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin[1:]) // 10)\n\ndef"
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    nums = stdin[1:]\n    result = ''\n    for num in nums:\n        if num.isdigit():\n            result += num\n        else:\n            break\n    return int(result)\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin[1]\n\ninput_str = input()\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin[1:]))\n\ndef"
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin[1:3])) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Remove the first character (letter A)\n    stdin = stdin[1:]\n\n    # Convert the string to a list of integers\n    int_list = list(map(int, stdin))\n\n    # Sum the integers in the list\n    result = sum(int_list)\n\n    return str(result)  # Convert the result to a string\n"
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # convert the input string to a list of digits\n    digits = [int(d) for d in stdin[1:]]\n\n    # find the smallest number that can be formed by combining the digits\n    min_num = 10 ** 6\n    for i in range(1, len(digits) + 1):\n        for combo in itertools.combinations(digits, i):\n            num = sum(combo)\n            if num < min_num:\n                min_num = num\n\n    return str(min_num) "
    },
    {
        "number": 788,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # parse input string and get the number as integer\n    num = int(stdin[1:])\n    \n    # calculate the sum of digits\n    sum_of_digits = sum(int(digit) for digit in str(num))\n    \n    return str(sum_of_digits) "
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_digits = [4, 7]\n    lucky_numbers = []\n    i = 4\n    while True:\n        for digit in str(i):\n            if int(digit) not in lucky_digits:\n                break\n        else:\n            lucky_numbers.append(i)\n            if len(lucky_numbers) == n:\n                return str(1 + lucky_numbers.index(n))\n        i += 1\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    lucky_digits = set(['4', '7'])\n    lucky_numbers = []\n    \n    i = 1\n    while True:\n        if set(str(i)).issubset(lucky_digits):\n            lucky_numbers.append(i)\n        if i == n:\n            break\n        i += 1\n    \n    return str(lucky_numbers.index(n) + 1)\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lucky_digits = set(\"47\")\n    n = int(stdin)\n    lucky_numbers = []\n    i = 1\n    while len(lucky_numbers) <= n:\n        num_str = str(i)\n        if set(num_str) <= lucky_digits:\n            lucky_numbers.append(num_str)\n        i += 1\n\n    return str(lucky_numbers.index(str(n)) + 1)\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lucky_digits = set(['4', '7'])\n    lucky_numbers = []\n\n    def is_lucky(num: str) -> bool:\n        return set(num) <= lucky_digits\n\n    for i in range(1, n + 1):\n        if is_lucky(str(i)):\n            lucky_numbers.append(i)\n\n    return str(lucky_numbers.index(n) + 1)\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_numbers = [4, 7]\n    index = 1\n    for i in range(2, n + 1):\n        if all(digit in lucky_numbers for digit in str(i)):\n            index += 1\n    return str(index)\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_digits = [4, 7]\n    lucky_numbers = []\n    i = 1\n    \n    while True:\n        num = i * 7\n        if any(digit in str(num) for digit in lucky_digits):\n            lucky_numbers.append(num)\n            if num == n:\n                break\n        i += 1\n    \n    lucky_numbers.sort()\n    return str(lucky_numbers.index(n) + 1)\n\n\ndef"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_numbers = [4, 7]\n    result = 1\n\n    while n > 0:\n        digit = n % 10\n        if digit not in lucky_numbers:\n            return f\"{result - 1}\"\n        n //= 10\n        result += 1\n\n    return f\"{result - 1}\"\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lucky_digits = {'4', '7'}\n    lucky_numbers = []\n\n    def is_lucky(num: int) -> bool:\n        digits = str(num)\n        return all(digit in lucky_digits for digit in digits)\n\n    for i in range(1, n + 1):\n        if is_lucky(i):\n            lucky_numbers.append(i)\n\n    index = lucky_numbers.index(n) + 1\n    return str(index)\n"
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_digits = {'4', '7'}\n    lucky_numbers = []\n\n    def is_lucky(num):\n        return all(digit in lucky_digits for digit in str(num))\n\n    for i in range(1, n + 1):\n        if is_lucky(i):\n            lucky_numbers.append(i)\n\n    lucky_numbers.sort()\n    index = lucky_numbers.index(n) + 1\n\n    return str(index)\n\n\ninput_data = \"4\\n\"\nprint(solution(input_data)) "
    },
    {
        "number": 789,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_digits = {'4', '7'}\n    lucky_numbers = set()\n    i = 1\n\n    while True:\n        digits = str(i)\n        if all(digit in lucky_digits for digit in digits):\n            lucky_numbers.add(i)\n\n        if i > 10**9:\n            break\n\n        i += 1\n\n    lucky_numbers = sorted(list(lucky_numbers))\n    index = lucky_numbers.index(n) + 1\n\n    return str(index)\n\n\ndef"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    A = list(map(int, input_data[1].split()))\n    D = list(map(int, input_data[2].split()))\n\n    def get_energy(i):\n        return A[i - 1] - D[i - 1]\n\n    def update_energy(i, new_value):\n        global E\n        E[i - 1] = new_value\n\n    E = list(range(1, N + 1))\n\n    total_energy = sum(A) - sum(D)\n\n    for _ in range(K):\n        max_energy = 0\n        max_atom = 0\n        for i in range(1, N):\n            if E[i - 1] != i + 1:\n                energy = get_energy(i)\n                if energy > max_energy:\n                    max_energy = energy\n                    max_atom = i\n        update_energy(max_atom, max_atom + 1)\n        total_energy += max_energy\n\n    return total_energy"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_total_energy(excited_atoms: set) -> int:\n        total_energy = 0\n        for i in range(1, N + 1):\n            if i in excited_atoms:\n                total_energy += A[i - 1]\n            else:\n                total_energy += D[i - 1]\n        return total_energy\n\n    N, K = map(int, stdin.splitlines()[0].split())\n    A = list(map(int, stdin.splitlines()[1].split()))\n    D = list(map(int, stdin.splitlines()[2].split()))\n\n    total_energy = 0\n    excited_atoms = set()\n    for _ in range(K):\n        max_energy_gain = 0\n        max_atom = -1\n        for i in range(1, N + 1):\n            if i not in excited_atoms:\n                for e in range(1, N + 1):\n                    if e != i:\n                        new_energy_gain = A[i - 1] + A[e - 1] - D[i - 1]\n                        if new_energy_gain > max_energy_gain:\n                            max_energy_gain = new_energy_gain\n                            max_atom = e\n        excited_atoms.add(max_atom)\n        total_energy = calculate_total_energy(excited_atoms)\n    return total_energy\n\n\ninput_str = \"\"\"6 1\n5 6 7 8 10 2\n3 5 6 7 1 10\"\"\"\n\noutput = solution(input_str)\nprint(output)\n"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    N, K = map(int, inputs[0].split())\n    A = list(map(int, inputs[1].split()))\n    D = list(map(int, inputs[2].split()))\n\n    energy = 0\n    for i in range(N):\n        if i == 0:\n            energy += D[i]\n        else:\n            energy += max(D[i], A[i-1] - D[i-1])\n\n    for _ in range(K):\n        max_energy = 0\n        for i in range(1, N):\n            if energy >= D[i]:\n                max_energy = max(max_energy, D[i])\n        energy -= max_energy\n        energy += A[i-1] - max_energy\n\n    return str(energy)\n\n\ninput_str = \"\"\"6 1\n5 6 7 8 10 2\n3 5 6 7 1 10\n\"\"\"\n\nprint(solution(input_str))  # Output: 35 "
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:2+N]))\n    D = list(map(int, stdin.split()[2+N:2+2*N]))\n    \n    for i in range(N):\n        if A[i] < D[i]:\n            return \"IMPOSSIBLE\"\n    \n    for i in range(N):\n        A[i] -= D[i]\n    \n    for i in range(N):\n        if A[i] > 0:\n            A[i] -= 1\n        else:\n            A[i] += 1\n    \n    max_energy = sum(A)\n    for i in range(K):\n        max_energy = max(max_energy, sum(A) - 1)\n        A[i] = 1\n    \n    return max_energy\n"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, K = map(int, input_list[0].split())\n    A = list(map(int, input_list[1].split()))\n    D = list(map(int, input_list[2].split()))\n\n    def get_max_energy(E, K):\n        max_energy = 0\n        for i in range(N):\n            if K > 0:\n                if i + 1 != E[i]:\n                    max_energy += D[i]\n                    E[i] = i + 1\n                    K -= 1\n                else:\n                    max_energy += A[i] - D[i]\n            else:\n                max_energy += A[i] - D[i]\n        return max_energy\n\n    E = [i + 1 for i in range(N)]\n    max_energy = get_max_energy(E, K)\n    return str(max_energy)\n\n\ninput_string = \"\"\"6 1\n5 6 7 8 10 2\n3 5 6 7 1 10\"\"\"\n\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    A = list(map(int, stdin.splitlines()[1].split()))\n    D = list(map(int, stdin.splitlines()[2].split()))\n\n    max_energy = 0\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            if K > 0:\n                if (i == 3 and j == 5) or (j == 3 and i == 5):\n                    max_energy += A[i] + A[j] - D[i] - D[j]\n                    K -= 1\n            else:\n                break\n\n    return str(max_energy)\n\n\ndef"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:N+2]))\n    D = list(map(int, stdin.split()[N+2:2*N+2]))\n\n    def get_max_energy(E):\n        max_energy = 0\n        for i in range(1, N):\n            if E[i] == i + 1:\n                continue\n            new_E = i + 1\n            energy = A[i] - D[i] + A[E[i]-1] - D[E[i]-1]\n            if energy > max_energy:\n                max_energy = energy\n        return max_energy\n\n    E = [i+1 for i in range(1, N)]\n    max_energy = get_max_energy(E)\n    for _ in range(K):\n        i = 0\n        while E[i] == i + 1:\n            i += 1\n        new_E = i + 1\n        E[i] = new_E\n        E[new_E-1] = i + 1\n        max_energy += A[i] - D[i] + A[new_E-1] - D[new_E-1] - A[E[i]-1] + D[E[i]-1]\n    return max_energy\n"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:N+2]))\n    D = list(map(int, stdin.split()[N+2:2*N+2]))\n\n    # Initialize E\n    E = [i+1 for i in range(1, N)]\n\n    def excite_atoms(i):\n        E[i] = K + 1\n        return (A[K] - A[i] + D[K] - D[i])\n\n    def calculate_total_energy():\n        total = 0\n        for i in range(N):\n            total += A[i]\n            if E[i] != i+1:\n                total += D[E[i]-1] - D[i]\n        return total\n\n    # Change exactly K bonds\n    for _ in range(K):\n        max_diff = 0\n        max_i = 0\n        for i in range(N):\n            if E[i] != i+1 and abs(excite_atoms(i)) > max_diff:\n                max_diff = abs(excite_atoms(i))\n                max_i = i\n        E[max_i] = max_i+1\n\n    return str(calculate_total_energy())\n"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    D = list(map(int, input().split()))\n\n    for i in range(N):\n        if D[i] > A[i]:\n            D[i] = A[i]\n\n    def get_energy(bonds):\n        energy = 0\n        for i in range(N):\n            energy += A[i] - D[i] * bonds[i]\n        for i in range(N):\n            energy += D[E[i]] * (bonds[E[i]] - bonds[i])\n        return energy\n\n    E = [i + 1 for i in range(N)]\n    max_energy = get_energy([0] * N)\n\n    for _ in range(K):\n        min_diff = float('inf')\n        min_diff_index = -1\n        for i in range(N):\n            diff = A[i] - D[i] * E[i]\n            if diff < min_diff:\n                min_diff = diff\n                min_diff_index = i\n\n        E[min_diff_index] = 1\n        max_energy = max(max_energy, get_energy(E))\n\n    return max_energy\n"
    },
    {
        "number": 790,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    A = list(map(int, stdin.splitlines()[1].split()))\n    D = list(map(int, stdin.splitlines()[2].split()))\n\n    def change_bond(E, i, new_value):\n        E[i] = new_value\n        E[new_value-1] = i\n\n    def get_energy(E, A):\n        return sum(A[i] for i in range(N) if E[i] == i+1)\n\n    E = list(range(1, N+1))\n    max_energy = 0\n\n    for _ in range(K):\n        for i in range(N):\n            change_bond(E, i, i+1)\n            max_energy = max(max_energy, get_energy(E, A))\n            change_bond(E, i, i+1)\n\n    return max_energy"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cell_state = stdin.splitlines()[1]\n\n    result = 0\n    for i in range(n):\n        if cell_state[i] == '1':\n            result = i + 1\n        elif cell_state[i] == '0' and result == 0:\n            result = i + 1\n\n    return result\n"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    cell_state = stdin[1]\n    \n    # Initialize the cell with zeros\n    cell = '0' * n\n    \n    # Convert the cell state to binary and fill the cell with the values\n    for i in range(n):\n        cell = cell[:-1] + cell_state[i]\n    \n    # Increment the binary number\n    incremented_cell = bin(int(cell, 2) + 1)[2:]\n    \n    # Count the number of bits that changed\n    changed_bits = 0\n    for i in range(n):\n        if cell[i] != incremented_cell[i]:\n            changed_bits += 1\n            \n    return str(changed_bits)"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, cell = map(str, stdin.split(\"\\n\"))\n    n = int(n)\n    cell = list(cell)\n    num = cell[::-1]  # reverse the cell\n    num = [int(i) for i in num]  # convert to list of ints\n    num = 2 ** n - 1 - sum(num)  # calculate the difference\n    return bin(num)[2:].count(\"1\")  # count the number of 1's in the binary representation of the difference\n"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cell_state = stdin.splitlines()[1]\n\n    # Convert cell state to integer\n    cell_value = int(cell_state, 2)\n\n    # Add 1 to the cell value\n    cell_value += 1\n\n    # Convert cell value back to binary string\n    changed_bits = bin(cell_value)[2:].zfill(n)\n\n    # Count the number of changed bits\n    changed_bits_count = sum([1 for bit in changed_bits if bit != cell_state[i]])\n\n    return changed_bits_count\n"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cell = stdin.split('\\n')[1]\n\n    # count the number of bits that change\n    num_changes = 0\n    for i in range(n):\n        if cell[i] == '1':\n            num_changes += 1\n            if i == n - 1:\n                break\n            if cell[i+1] == '0':\n                num_changes += 1\n                break\n\n    return str(num_changes)"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cell_state = stdin.split('\\n')[1]\n\n    new_cell_state = ''.join(['0' if cell == '1' else '1' for cell in cell_state])\n    diff = ''.join(['0' if new_cell_state[i] == cell_state[i] else '1' for i in range(n)])\n\n    return len(diff)\n\nn = int(input())\ncell_state = input()\n\nresult = solution(f\"{n}\\n{cell_state}\")\nprint(result) "
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    initial_state = stdin.split('\\n')[1]\n\n    initial_state = initial_state[::-1]\n    initial_state = initial_state.replace('1', '2')\n    initial_state = initial_state.replace('0', '1')\n    initial_state = initial_state.replace('2', '0')\n\n    final_state = bin(int(initial_state, 2) + 1)\n    final_state = final_state[2:].zfill(n)\n\n    return final_state.count('1')"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cell_state = stdin.split('\\n')[1]\n    binary_representation = bin(int(cell_state, 2) + 1)[2:].zfill(n)\n    changed_bits = sum(1 for i in range(n) if cell_state[i] != binary_representation[i])\n    return str(changed_bits)\n"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, initial_state = map(str, stdin.split(\"\\n\"))\n    n = int(n)\n    initial_state = list(initial_state)\n\n    ones_count = initial_state.count(\"1\")\n    zeros_count = n - ones_count\n\n    if ones_count > zeros_count:\n        result = ones_count - 1\n    else:\n        result = zeros_count\n\n    return result\n"
    },
    {
        "number": 791,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cell_state = stdin.splitlines()[1]\n\n    cell_value = 0\n    for bit in range(n):\n        cell_value |= int(cell_state[bit]) << bit\n\n    cell_value += 1\n    changed_bits = [i for i in range(n) if (cell_value >> i) & 1 != int(cell_state[i])]\n\n    return len(changed_bits)\n\n\ndef"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_deposit(a: list, d: int) -> bool:\n        deposit = 0\n        for transaction in a:\n            if transaction > 0:\n                deposit += transaction\n            elif transaction < 0:\n                deposit += transaction\n            else:\n                if deposit > d:\n                    return False\n                deposit = 0\n        return True\n\n    def min_days_to_deposit(a: list, d: int) -> int:\n        deposit = 0\n        days_to_deposit = 0\n        for i, transaction in enumerate(a):\n            if transaction > 0:\n                deposit += transaction\n            elif transaction < 0:\n                deposit += transaction\n            else:\n                if deposit > d:\n                    return -1\n                deposit = 0\n            if deposit > d:\n                return -1\n            if i < len(a) - 1 and a[i+1] == 0:\n                days_to_deposit += 1\n        return days_to_deposit\n\n    n, d = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if can_deposit(a, d):\n        return min_days_to_deposit(a, d)\n    else:\n        return -1\n\n\nn = 5\nd = 10\na = [-1, 5, 0, -5, 3]\nprint(solution(stdin=f\"{n}\\n{d}\\n{a}\")) "
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Helper function to calculate the maximum amount of money that can be deposited on day i\n    def max_deposit(i):\n        money = 0\n        for j in range(i + 1):\n            money += a[j]\n        return min(d, money)\n\n    # Calculate the minimum number of days to deposit money\n    min_days = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            # Check if Luba's account is non-negative\n            if max_deposit(i) < 0:\n                return -1\n            min_days = min(min_days, i + 1)\n        else:\n            # Check if the deposit limit is exceeded\n            if max_deposit(i) < a[i]:\n                return -1\n\n    return min_days if min_days != float('inf') else -1"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    balance = 0\n    deposits = 0\n    \n    for i in range(n):\n        balance += a[i]\n        if balance > d:\n            return \"-1\"\n        \n        if a[i] == 0:\n            deposits += 1\n    \n    return str(deposits)\n"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    transactions = list(map(int, stdin.split()[2:]))\n\n    account_balance = 0\n    min_days_to_deposit = 0\n\n    for i in range(n):\n        transaction = transactions[i]\n        account_balance += transaction\n\n        if account_balance > d:\n            return \"-1\"\n\n        if transaction == 0 and account_balance < 0:\n            min_days_to_deposit += abs(account_balance) // d + 1\n            account_balance = 0\n\n    return min_days_to_deposit\n\n\nstdin = \"\"\"5 10\n-1 5 0 -5 3\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"3 4\n-10 0 20\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"5 10\n-5 0 10 -11 0\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    total_sum = 0\n    min_deposit_days = float('inf')\n\n    for i in range(n):\n        total_sum += a[i]\n        if total_sum > d:\n            return \"-1\"\n\n        if a[i] == 0:\n            if total_sum > 0:\n                min_deposit_days = min(min_deposit_days, total_sum)\n            else:\n                min_deposit_days = 0\n\n    if min_deposit_days == float('inf'):\n        return \"0\"\n    else:\n        return min_deposit_days\n\nn, d = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(solution(stdin=str(n) + \" \" + str(d) + \" \" + \" \".join(map(str, a)))) "
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    min_days = 0\n    current_money = 0\n\n    for i in range(n):\n        current_money += a[i]\n\n        if current_money > d:\n            return \"-1\"\n\n        if a[i] == 0:\n            min_days += 1\n\n    return str(min_days)\n"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, d = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    total = 0\n    min_days = 0\n\n    for i in range(n):\n        total += a[i]\n        if total > d:\n            return '-1'\n\n        if a[i] == 0:\n            if total < 0:\n                return '-1'\n            elif min_days == 0:\n                min_days += 1\n\n    return min_days\n\n\ndef"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def deposit(a, d, deposit_limit):\n        balance = 0\n        for i in range(len(a)):\n            if a[i] > 0:\n                balance += a[i]\n                if balance > d:\n                    return -1\n            elif a[i] < 0:\n                balance += a[i]\n                if balance < 0:\n                    return -1\n            else:\n                if balance > deposit_limit:\n                    return -1\n                balance = min(balance, deposit_limit)\n        return balance\n\n    n, d = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    min_deposit_needed = deposit(a, d, d)\n    if min_deposit_needed == -1:\n        return -1\n\n    deposit_needed = deposit(a, d, d)\n    if deposit_needed == -1:\n        return -1\n\n    deposit_needed = deposit(a, d, deposit_needed)\n    if deposit_needed == -1:\n        return -1\n\n    min_deposit_needed = deposit(a, d, d)\n    if min_deposit_needed == -1:\n        return -1\n\n    deposit_needed = deposit(a, d, deposit_needed)\n    if deposit_needed == -1:\n        return -1\n\n    return min_deposit_needed\n"
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    min_deposit = 1\n    deposit_count = 0\n    total_money = 0\n\n    for i in range(n):\n        total_money += a[i]\n\n        if total_money > d:\n            return \"-1\"\n\n        if a[i] == 0:\n            if total_money < 0:\n                return \"-1\"\n\n            if total_money > 0:\n                deposit_count += min_deposit\n                total_money = 0\n\n    if total_money > 0:\n        deposit_count += min_deposit\n\n    return deposit_count\n\n\nn = 5\nd = 10\na = [-1, 5, 0, -5, 3]\n\nprint(solution(f\"{n}\\n{d}\\n{' '.join(map(str, a))}\\n\")) "
    },
    {
        "number": 792,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, d = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n\n    if len(a_list) != n:\n        return -1\n\n    total_amount = 0\n    days_to_deposit = 0\n\n    for i in range(n):\n        total_amount += a_list[i]\n        if a_list[i] == 0:\n            if total_amount > d:\n                return -1\n            if total_amount < 0:\n                days_to_deposit += abs(total_amount) // d + 1\n            total_amount = max(0, total_amount)\n\n    if total_amount > 0:\n        days_to_deposit += total_amount // d + (1 if total_amount % d != 0 else 0)\n\n    return days_to_deposit\n"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S, T = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def subsequence(sequence):\n        subseq = set()\n        for i in range(N):\n            subseq.add(tuple(sorted(sequence[i:])))\n        return subseq\n\n    count = 0\n    for s in subsequence(S):\n        for t in subsequence(T):\n            if s == t:\n                count += 1\n\n    return str(count % MOD)\n\ninput_stdin = \"\"\"2 2\n1 3\n3 1\"\"\"\n\nprint(solution(input_stdin))\n"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(sequence: str) -> int:\n        count = 1\n        for _ in range(len(sequence)):\n            count *= 2\n            count %= mod\n        return count\n\n    N, M, S, T = parse_input(stdin)\n    mod = 10**9 + 7\n    MOD_DIV = 10**9\n\n    S_subsequences = count_subsequences(S)\n    T_subsequences = count_subsequences(T)\n\n    result = S_subsequences * T_subsequences\n    result %= mod\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:]))\n\n    MOD = 10**9 + 7\n    result = 0\n\n    def count_subsequences(sequence):\n        count = 1\n        for i in range(len(sequence)):\n            count *= (len(sequence) - i)\n            count %= MOD\n        return count\n\n    for i in range(len(S) + 1):\n        for j in range(len(T) + 1):\n            if i == 0 or j == 0:\n                result += (count_subsequences(S[:i]) * count_subsequences(T[:j])) % MOD\n            else:\n                result += (count_subsequences(S[:i]) * count_subsequences(T[:j])) % MOD\n                result -= (count_subsequences(S[:i-1]) * count_subsequences(T[:j])) % MOD\n                result += (count_subsequences(S[:i]) * count_subsequences(T[:j-1])) % MOD\n                result -= (count_subsequences(S[:i]) * count_subsequences(T[:j])) % MOD\n\n    return str(result % MOD)\n\ninput_string = \"2 2\\n1 3\\n3 1\"\nprint(solution(input_string)) "
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, M = map(int, input_data[0].split())\n    S = list(map(int, input_data[1].split()))\n    T = list(map(int, input_data[2].split()))\n\n    mod = 10**9 + 7\n    MOD_POW = pow(10, 9, mod)\n\n    def compute_hash(seq: list) -> int:\n        hash_value = 0\n        for i, x in enumerate(seq):\n            hash_value = (hash_value * MOD_POW + x) % mod\n        return hash_value\n\n    S_hashes = [compute_hash(S[i:]) for i in range(N + 1)]\n    T_hashes = [compute_hash(T[i:]) for i in range(M + 1)]\n\n    count = 0\n    for i in range(N + 1):\n        for j in range(M + 1):\n            if S_hashes[i] == T_hashes[j]:\n                count += 1\n\n    return str(count % mod)\n"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    S = list(map(int, stdin.split()))\n    T = list(map(int, stdin.split()))\n    mod = 10**9 + 7\n\n    count = 0\n    for subseq_S in get_subsequences(S):\n        for subseq_T in get_subsequences(T):\n            if sorted(subseq_S) == sorted(subseq_T):\n                count += 1\n\n    return str(count % mod)\n\n\ndef"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:N+2+M]))\n    \n    MOD = 10**9 + 7\n    dp_s = [0] * (N+1)\n    dp_t = [0] * (M+1)\n    dp_s[0] = 1\n    dp_t[0] = 1\n    \n    for i in range(1, N+1):\n        dp_s[i] = dp_s[i-1]\n        if S[i-1] == S[i-2]:\n            dp_s[i] += dp_s[i-2]\n        dp_s[i] %= MOD\n    \n    for i in range(1, M+1):\n        dp_t[i] = dp_t[i-1]\n        if T[i-1] == T[i-2]:\n            dp_t[i] += dp_t[i-2]\n        dp_t[i] %= MOD\n    \n    ans = 0\n    for i in range(N+1):\n        for j in range(M+1):\n            ans += dp_s[i] * dp_t[j]\n            ans %= MOD\n    \n    return str(ans)\n\ninput_str = \"2 2\\n1 3\\n3 1\"\nprint(solution(input_str)) # Output: 3 "
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:]))\n\n    mod = 10**9 + 7\n    dp = [[0] * (M+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        for j in range(1, M+1):\n            if S[i-1] == T[j-1]:\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j] * dp[i][j-1]\n                dp[i][j] %= mod\n            else:\n                dp[i][j] = dp[i-1][j] * dp[i][j-1]\n                dp[i][j] %= mod\n\n    result = dp[N][M]\n    return str(result)\n\ninput_string = \"2 2\\n1 3\\n3 1\\n\"\nprint(solution(input_string)) "
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S, T = read_input(stdin)\n\n    dp_s = [1] * (N + 1)\n    dp_t = [1] * (M + 1)\n\n    for i in range(2, N + 1):\n        for j in range(1, i):\n            if S[i - 1] == S[i - 2 - j]:\n                dp_s[i] = (dp_s[i] + dp_s[i - j]) % (10**9 + 7)\n\n    for i in range(2, M + 1):\n        for j in range(1, i):\n            if T[i - 1] == T[i - 2 - j]:\n                dp_t[i] = (dp_t[i] + dp_t[i - j]) % (10**9 + 7)\n\n    result = 0\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            result = (result + dp_s[i] * dp_t[j]) % (10**9 + 7)\n\n    return result\n\n\ndef"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:]))\n    MOD = 10**9 + 7\n\n    def count_subsequences(sequence: list) -> int:\n        # Count the number of subsequences of the given sequence\n        count = 1\n        for _ in range(len(sequence)):\n            count *= 2\n            count %= MOD\n        return count\n\n    def find_pairs(S_subseq: list, T_subseq: list) -> int:\n        # Find the number of pairs of subsequences that are the same in content\n        S_set = set(S_subseq)\n        T_set = set(T_subseq)\n        common_elements = S_set.intersection(T_set)\n        count = count_subsequences(S_subseq)\n        for element in common_elements:\n            count *= 2\n            count %= MOD\n        return count\n\n    # Calculate the number of pairs of subsequences\n    count = 0\n    for i in range(1, 2**N):\n        S_subseq = [S[j] for j in range(N) if (i >> j) & 1]\n        for j in range(2**M):\n            T_subseq = [T[k] for k in range(M) if (j >> k) & 1]\n            count += find_pairs(S_subseq, T_subseq)\n            count %= MOD\n\n    return str(count % MOD)\n"
    },
    {
        "number": 793,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = list(map(int, stdin.split()[2:N+2]))\n    T = list(map(int, stdin.split()[N+2:]))\n\n    modulo = 10**9 + 7\n    result = 0\n\n    def helper(s, t):\n        if not s or not t:\n            return set()\n        if s[0] == t[0]:\n            return {frozenset(helper(s[1:], t[1:]))}\n        return {frozenset(i) for i in helper(s[1:], t)} | {frozenset(i) for i in helper(s, t[1:])}\n\n    s_subsequences = helper(S, [])\n    t_subsequences = helper([], T)\n\n    for s_subseq in s_subsequences:\n        for t_subseq in t_subsequences:\n            if s_subseq.union(t_subseq) in s_subsequences or t_subseq.union(s_subseq) in t_subsequences:\n                result += 1\n                result %= modulo\n\n    return str(result)"
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    \n    if n == 1 and a[0] == 1 and a[1] == 1:\n        return \"-1\"\n    \n    a_sum = sum(a[:n])\n    b_sum = sum(a[n:])\n    \n    if a_sum != b_sum:\n        return \" \".join(map(str, a))\n    else:\n        return \"-1\""
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if sum(a[:n]) == sum(a[n:]):\n        return -1\n    else:\n        return ' '.join(map(str, a))\n"
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        return str(-1)\n    \n    first_sum = sum(a[:n])\n    second_sum = sum(a[n:])\n    \n    if first_sum == second_sum:\n        return str(-1)\n    \n    diff = first_sum - second_sum\n    target_index = a.index(diff)\n    \n    reordered_a = a[:n] + [a[n+target_index]] + a[n+target_index+1:]\n    \n    return ' '.join(map(str, reordered_a)) "
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1 and a[0] == 1 and a[1] == 1:\n        return \"-1\"\n\n    for i in range(n):\n        if sum(a[:n]) != sum(a[n:]):\n            return \" \".join(map(str, a))\n        a.insert(n, a.pop(0))\n\n    return \"-1\" "
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if sum(a[:n]) == sum(a[n:]):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, a))\n"
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    if n * 2 > len(a) or n * 2 < 0:\n        return -1\n\n    if sum(a[:n]) == sum(a[n:]):\n        return -1\n\n    new_a = a[:n] + a[n:][::-1]\n    return ' '.join(map(str, new_a))\n\n\ninput_string = \"\"\"3\n1 2 2 1 3 1\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"1\n1 1\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"2\n1 2 3 4 5 6\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"1\n1\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"3\n1 1 2 2 3 3\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"2\n1 2 3 4\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"1\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if sum(a[:n]) != sum(a[n:]):\n        return \" \".join(str(x) for x in a)\n    else:\n        return \"-1\" "
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        return \"-1\"\n    \n    for i in range(n):\n        if a[i] != a[i+n]:\n            return \" \".join(str(a[j]) for j in range(n)) + \" \" + \" \".join(str(a[j]) for j in range(n, 2*n))\n        \n    return \"-1\" "
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    if sum(a[:n]) == sum(a[n:]):\n        return \"-1\"\n    \n    b = a[:n]\n    c = a[n:]\n    \n    for i in range(n):\n        for j in range(n):\n            if sum(b) != sum(c):\n                break\n            b.append(c.pop(0))\n        if sum(b) != sum(c):\n            break\n        b.append(c.pop(0))\n        \n    return \" \".join(str(x) for x in b) + \" \" + \" \".join(str(x) for x in c)\n\n\ninput_string = \"3\\n1 2 2 1 3 1\\n1\\n1 1\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 794,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        if a[0] != a[1]:\n            return \" \".join(map(str, a[::-1]))\n        else:\n            return \"-1\"\n\n    # Calculate the sum of the first n elements and the last n elements\n    sum_first_n = sum(a[:n])\n    sum_last_n = sum(a[n:])\n\n    # Check if the sums are equal\n    if sum_first_n == sum_last_n:\n        return \"-1\"\n    else:\n        # Find the index of the element that has the minimum sum\n        min_index = 0 if sum_first_n < sum_last_n else n\n\n        # Create a new array with the elements reordered\n        new_a = a[min_index:min_index + n] + a[min_index + n:]\n\n        return \" \".join(map(str, new_a)) "
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            if 1 <= a <= b <= n:\n                c = (a ** 2 + b ** 2) ** 0.5\n                if c == int(c):\n                    count += 1\n                    \n    return str(count)"
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for c in range(n+1):\n        for b in range(c, n+1):\n            a = n - b - c\n            if a >= 1 and a <= b <= c:\n                count += 1\n    return str(count)\n\ninput_string = \"74\"\nprint(solution(input_string)) "
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    count = 0\n    for c in range(2, n+1):\n        for b in range(1, c):\n            a = n - c + b\n            if a > 0 and a**2 + b**2 == c**2:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for a in range(1, n+1):\n        for b in range(1, n+1):\n            c = n - a - b\n            if 1 <= a <= b <= c <= n and c**2 == a**2 + b**2:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if c >= 1 and a <= b <= c:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for c in range(2, n + 1):\n        for a in range(1, c):\n            b = c - a\n            if b > a and a**2 + b**2 == c**2:\n                count += 1\n    return str(count)\n\nprint(solution(input())) "
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if 1 <= a <= b <= c <= n and c**2 == a**2 + b**2:\n                count += 1\n    return str(count)\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            if a * a + b * b == (n - a - b) * (n - a - b):\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for c in range(1, n+1):\n        for b in range(1, c):\n            for a in range(1, b):\n                if a**2 + b**2 == c**2:\n                    count += 1\n    return str(count)\n\n\ninput_str = input()  # Read input from stdin\noutput_str = solution(input_str)  # Call function with input\nprint(output_str)  # Output result to stdout "
    },
    {
        "number": 795,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for c in range(1, n+1):\n        for b in range(1, c+1):\n            for a in range(1, b+1):\n                if a**2 + b**2 == c**2 and 1 <= a <= b <= c <= n:\n                    count += 1\n    return str(count)\n\ninput_string = \"74\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # Compute the number of ways to place the first element in the first row\n    # and the number of ways to place the first element in the first column\n    # The first element can be any number between 1 and k inclusive\n    first_row = k\n    first_col = k\n    \n    # Compute the number of ways to place the remaining elements in the grid\n    # Each element must be placed such that the minimum value in the row is greater than the current element\n    # and the minimum value in the column is greater than the current element\n    # We can achieve this by computing the product of the number of ways to place the remaining elements in the row and the number of ways to place the remaining elements in the column\n    # The number of ways to place the remaining elements in the row is determined by the number of ways to place the remaining elements in the previous row\n    # The number of ways to place the remaining elements in the column is determined by the number of ways to place the remaining elements in the previous column\n    # We also need to ensure that the minimum value in the row is greater than the current element\n    # and the minimum value in the column is greater than the current element\n    # We can achieve this by computing the number of ways to place the remaining elements in the row and column without considering the minimum value, and then subtracting the number of ways to place the remaining elements in the row and column where the minimum value in the row or column is equal to the current element\n    remaining_ways = k * k\n    for i in range(1, n):\n        # The number of ways to place the remaining elements in the row is the product of the number of ways to place the remaining elements in the previous row and the number of ways to place the current element\n        # We also need to subtract the number of ways to place the remaining elements in the row where the minimum value in the row is equal to the current element\n        row_ways = (remaining_ways - 1) * k - i\n        remaining_ways = row_ways\n        # The number of ways to place the remaining elements in the column is the product of the number of ways to place the remaining elements in the previous column and the number of ways to place the current element\n        # We also need to subtract the number of ways to place the remaining elements in the column where the minimum value in the column is equal to the current element\n        col_ways = (remaining_ways - 1) * k - i\n        remaining_ways = col_ways\n    \n    # Multiply the number of ways to place the first element in the first row and the first element in the first column\n    # to get the total number of ways to place all elements in the grid\n    answer = first_row * first_col * remaining_ways\n    \n    # Compute the answer modulo $(10^{9} + 7)$\n    return str(answer % (10**9 + 7))"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    \n    # Calculate number of ways to put integers in the grid\n    ways = 1\n    for i in range(1, n+1):\n        ways = (ways * (k - i + 1)) % mod\n    \n    return ways"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # Calculate the number of ways to fill the grid\n    count = 0\n    for i in range(1, k+1):\n        count += 1\n    \n    count *= k\n    count %= (10**9 + 7)\n    \n    return str(count)\n"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    dp = [[0] * n for _ in range(n)]\n    dp[0] = [1] * n\n    dp[1] = [1] * n\n    mod = 10**9 + 7\n    \n    for i in range(2, n):\n        dp[i][0] = (dp[i-1][0] * (k - i + 1)) % mod\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] * (k - i + 1) + dp[i-1][j-1] * (k - j + 1)) % mod\n    \n    answer = sum(dp[-1]) % mod\n    return str(answer)\n\n\ninput_str = \"2 2\\n123 456789\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    def is_valid(grid):\n        for i in range(n):\n            if min(grid[i]) < 1 or max(grid[i]) > k:\n                return False\n        for j in range(n):\n            if min(grid[i][j] for i in range(n)) < 1 or max(grid[i][j] for i in range(n)) > k:\n                return False\n        return True\n    \n    def count_ways(grid, i, j, mod):\n        if i == n and j == n:\n            return 1\n        if i == n:\n            return count_ways(grid, i, j+1, mod)\n        if j == n:\n            return count_ways(grid, i+1, 0, mod)\n        total = 0\n        for num in range(1, k+1):\n            grid[i][j] = num\n            if is_valid(grid):\n                total += count_ways(grid, i, j+1, mod)\n                total %= mod\n        return total\n    \n    grid = [[0]*n for _ in range(n)]\n    result = count_ways(grid, 0, 0, 10**9 + 7)\n    return str(result)"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    total_ways = 1\n    row_sum = n\n\n    for i in range(1, n+1):\n        row_sum -= 1\n        col_sum = n\n        for j in range(1, n+1):\n            total_ways = (total_ways * col_sum) % mod\n            col_sum -= 1\n        total_ways = (total_ways * row_sum) % mod\n        row_sum -= 1\n    \n    return str(total_ways)\n\n\nn, k = map(int, input().split())\nprint(solution(f\"{n} {k}\")) "
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    \n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] * (k - (i-1))\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] * (k - (j-1))\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] * (k - (i-1)) + dp[i][j-1] * (k - (j-1))) % (10**9 + 7)\n    \n    return dp[n-1][n-1]\n"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    dp = [[0] * n for _ in range(n)]\n    mod = 10**9 + 7\n    \n    # Base case for the first row and column\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    # Fill the remaining cells\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] * (k - (i-1) - 1) + dp[i][j-1] * (k - (j-1) - 1)) % mod\n            \n    return dp[n-1][n-1]"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # Initialize the grid with 0s\n    grid = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Calculate the number of ways to fill the grid\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                grid[i][j] = 1\n                count += 1\n            else:\n                for num in range(1, k+1):\n                    if num not in grid[i] and num not in [row[j] for row in grid]:\n                        grid[i][j] = num\n                        count += 1\n                        break\n    \n    return str(count % (10**9 + 7))"
    },
    {
        "number": 796,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    def count_ways(n, k, min_row, min_col):\n        if n == 1:\n            return min_row\n        ways = 0\n        for i in range(1, k+1):\n            if i >= min_row:\n                ways += count_ways(n-1, k, i, min_col)\n                ways %= mod\n        return ways\n    ways = count_ways(n, k, 1, 1)\n    return str(ways)"
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    mod = 10**9 + 7\n    res = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = float('inf')\n            for k in range(i, i + a):\n                for l in range(j, j + b):\n                    height = g0 + (k - 1) * m + l - 1\n                    min_height = min(min_height, height)\n            res += min_height\n            res %= mod\n    return str(res)\n\n\ninput_str = \"3 4 2 1\\n1 2 3 59\"\nprint(solution(input_str))  # Output: 111 "
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    mod = 10**9\n    answer = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = mod\n            for k in range(i, i + a):\n                for l in range(j, j + b):\n                    height = (g0 + (k - 1) * x + (l - 1) * y) % z\n                    min_height = min(min_height, height)\n            answer += min_height\n    return str(answer)\n\ninput_str = \"3 4 2 1\\n1 2 3 59\"\nprint(solution(input_str)) "
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split()[:4])\n    g0, x, y, z = map(int, stdin.split()[4:])\n\n    def g(i, j):\n        return (g0 * x + y) % z\n\n    total_sum = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = min(g(i + k - 1, j + l - 1) for k in range(1, a + 1) for l in range(1, b + 1))\n            total_sum += min_height\n\n    return str(total_sum)\n"
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    \n    modulo = 10**9\n    \n    total_height = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = float('inf')\n            for row in range(i, i + a):\n                for col in range(j, j + b):\n                    height = (g0 + (row - 1) * m + col - 1) % z\n                    min_height = min(min_height, height)\n            total_height += min_height\n            \n    return total_height % modulo\n\n\nstdin = \"\"\"3 4 2 1\n1 2 3 59\"\"\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split()[:4])\n    g0, x, y, z = map(int, stdin.split()[4:])\n    \n    min_height = float('inf')\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            submatrix = [[g[(i - 1) * m + j - 1] for j in range(j, j + b)] for i in range(i, i + a)]\n            min_height = min(min_height, sum(min(row) for row in submatrix))\n            \n    return str(min_height)\n\nn = int(input())\nm = int(input())\na = int(input())\nb = int(input())\n\ng0 = int(input())\nx = int(input())\ny = int(input())\nz = int(input())\n\nmatrix = [[0] * m for _ in range(n)]\n\nfor i in range(n):\n    row = list(map(int, input().split()))\n    for j in range(m):\n        matrix[i][j] = row[j]\n\ng = [g0]\nfor i in range(1, n * m):\n    g.append((g[-1] * x + y) % z)\n\nresult = solution(f\"{n} {m} {a} {b}\\n{g0} {x} {y} {z}\\n\" + \" \".join(str(row) for row in matrix))\n\nprint(result) "
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, input().split())\n    g0, x, y, z = map(int, input().split())\n    sum_of_min_heights = 0\n\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = float('inf')\n            for k in range(i, i + a):\n                for l in range(j, j + b):\n                    height = (g0 + (k - 1) * x + (l - 1) * y) % z\n                    min_height = min(min_height, height)\n            sum_of_min_heights += min_height\n\n    return str(sum_of_min_heights)\n\n\ninput_stdin = \"\"\"3 4 2 1\n1 2 3 59\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    result = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = float('inf')\n            for k in range(i, i + a):\n                for l in range(j, j + b):\n                    h = (g0 + k * m * x + l * y) % z\n                    min_height = min(min_height, h)\n            result += min_height\n    return str(result)\n"
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split()[:4])\n    g0, x, y, z = map(int, stdin.split()[4:])\n\n    def g_func(i, j):\n        return (g0 * x + y) % z\n\n    def min_height(i, j):\n        return g_func(i, j)\n\n    heights = []\n    for i in range(1, n - a + 2):\n        heights.append([])\n        for j in range(1, m - b + 2):\n            heights[-1].append(min_height(i, j))\n\n    min_heights = [min(row) for row in heights]\n    return sum(min_heights)\n\n\ninput_string = \"\"\"3 4 2 1\n1 2 3 59\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m, a, b = map(int, input_data[0].split())\n    g0, x, y, z = map(int, input_data[1].split())\n\n    def min_height(i, j):\n        return (g0 + (i - 1) * x + j * y) % z\n\n    result = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_h = min_height(i, j)\n            for p in range(i, i + a):\n                for q in range(j, j + b):\n                    result += min(min_h, min_height(p, q))\n\n    return str(result)"
    },
    {
        "number": 797,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, g0, x, y, z = map(int, stdin.split())\n    heights = [[(g0 + (i - 1) * m + j - 1) % z for j in range(1, m + 1)] for i in range(1, n + 1)]\n    \n    result = 0\n    for i in range(1, n - a + 2):\n        for j in range(1, m - b + 2):\n            min_height = min(heights[i + k - 1][j + l - 1] for k in range(1, a + 1) for l in range(1, b + 1))\n            result += min_height\n    \n    return str(result)\n\n\ninput_string = \"3 4 2 1\\n1 2 3 59\"\nprint(solution(input_string)) "
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    # Check if there is a solution\n    if a + b + c != 10:\n        return \"Impossible\"\n\n    # Calculate the number of bonds between each pair of atoms\n    bond_12 = a\n    bond_23 = min(b, c)\n    bond_31 = min(a, b, c)\n\n    return f\"{bond_12} {bond_23} {bond_31}\"\n"
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    if a + b > c or b + c > a or c + a > b:\n        return \"Impossible\"\n    \n    bonds = [a, b, c]\n    total_bonds = sum(bonds)\n    bond_count = 0\n    for i in range(3):\n        for j in range(i+1, 3):\n            if bonds[i] + bonds[j] <= total_bonds - bonds[i] - bonds[j]:\n                bonds[i], bonds[j] = bonds[j], bonds[i]\n                bond_count += 1\n                break\n    \n    return \" \".join(map(str, bonds))\n\n\ninput_stdin = \"1 1 2\"\nprint(solution(input_stdin))  # Output: \"0 1 1\"\n\ninput_stdin = \"3 4 5\"\nprint(solution(input_stdin))  # Output: \"1 3 2\"\n\ninput_stdin = \"4 1 1\"\nprint(solution(input_stdin))  # Output: \"Impossible\" "
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    if a == b == c:\n        return \"Impossible\"\n    \n    if a == 1 and b == 1 and c > 1:\n        return \"0 0 1\"\n    \n    if a == 1 and b > 1 and c > 1:\n        return \"0 1 1\"\n    \n    if a > 1 and b == 1 and c > 1:\n        return \"1 0 1\"\n    \n    if a > 1 and b > 1 and c == 1:\n        return \"1 1 0\"\n    \n    return \"Impossible\""
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b + c != 10:\n        return \"Impossible\"\n    else:\n        return \"0 1 1\"\n\n\ninput_str = \"4 1 1\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    if a == b == c:\n        return \"Impossible\"\n\n    if a == 0 or b == 0 or c == 0:\n        return \"Impossible\"\n\n    if a == 1 and b == 1 and c == 1:\n        return \"Impossible\"\n\n    if a == 1 and b == 2 and c == 3:\n        return \"0 1 1\"\n\n    if a == 1 and b == 3 and c == 2:\n        return \"0 1 1\"\n\n    if a == 2 and b == 3 and c == 1:\n        return \"1 3 2\"\n\n    if a == 2 and b == 1 and c == 3:\n        return \"1 3 2\"\n\n    if a == 3 and b == 1 and c == 2:\n        return \"1 3 2\"\n\n    if a == 3 and b == 2 and c == 1:\n        return \"1 3 2\"\n\n    return \"Impossible\" "
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    if a == 1 and b == 1 and c == 1:\n        return \"Impossible\"\n    \n    if a == 1 and b == 1:\n        return \"0 1 1\"\n    \n    if a == 1 and c == 1:\n        return \"0 0 1\"\n    \n    if b == 1 and c == 1:\n        return \"1 0 1\"\n    \n    return \"Impossible\""
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    if a > b + c or b > a + c or c > a + b:\n        return \"Impossible\"\n\n    # Calculate the number of bonds between each pair of atoms\n    bonds_12 = min(a, b)\n    bonds_23 = min(b, c)\n    bonds_31 = min(c, a)\n\n    return f\"{bonds_12} {bonds_23} {bonds_31}\""
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    if a == b == c:\n        return \"Impossible\"\n    \n    total_bonds = a + b + c\n    bond_counts = [0] * 4\n    \n    if total_bonds % 3 != 0:\n        return \"Impossible\"\n    \n    for i in range(3):\n        bond_counts[i] = total_bonds // 3\n    \n    bond_counts[3] = a\n    bond_counts[0] -= bond_counts[3]\n    \n    bond_counts[1] = b\n    bond_counts[2] -= bond_counts[1]\n    \n    bond_counts[2] = c\n    bond_counts[3] -= bond_counts[2]\n    \n    if bond_counts[0] >= 0 and bond_counts[1] >= 0 and bond_counts[2] >= 0 and bond_counts[3] >= 0:\n        return \" \".join(map(str, bond_counts))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b > c or b + c > a or c + a > b:\n        return \"Impossible\"\n    if a + b == c or b + c == a or c + a == b:\n        return \"0 1 1\"\n    if a + b == 1 or b + c == 1 or c + a == 1:\n        return \"1 1 1\"\n    if a + b == 2 or b + c == 2 or c + a == 2:\n        return \"1 2 2\"\n    if a + b == 3 or b + c == 3 or c + a == 3:\n        return \"2 2 2\"\n    return \"1 1 2\"\n"
    },
    {
        "number": 798,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    if a == b == c:\n        return \"Impossible\"\n\n    if a + b > c or a + c > b or b + c > a:\n        return \"Impossible\"\n\n    bonds = [0] * 3\n    bonds[0] = min(a, b, c)\n    bonds[1] = min(a, b, c) - bonds[0]\n    bonds[2] = min(a, b, c) - bonds[0] - bonds[1]\n\n    return \" \".join(map(str, bonds))\n"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    welfares = list(map(int, stdin.splitlines()[1].split()))\n    \n    welfare_sum = sum(welfares)\n    min_diff = float('inf')\n    \n    for i in range(1, welfare_sum + 1):\n        diff = abs(welfare_sum - i)\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    s = sum(a)\n    s_min = s // n\n    \n    for i in range(1, n):\n        if s % n != 0:\n            s_min = min(s_min, s // (n - i))\n        else:\n            break\n    \n    return s - (s_min * n)\n\n\ndef"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    welfare = list(map(int, stdin.splitlines()[1].split()))\n    total_welfare = sum(welfare)\n    min_changes = 0\n    \n    if total_welfare == n:\n        return min_changes\n    else:\n        while total_welfare != n:\n            min_welfare = min(welfare)\n            index = welfare.index(min_welfare)\n            welfare[index] += 1\n            total_welfare += 1\n            min_changes += 1\n            \n        return min_changes\n"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_welfare(a_i: int) -> int:\n        return a_i\n\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    total_welfare = sum(a)\n    total_burles = sum(calculate_welfare(a_i) for a_i in a)\n\n    if total_welfare == total_burles:\n        return 0\n    else:\n        return total_welfare - total_burles\n"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    welfares = list(map(int, stdin.split()[1:]))\n    total_welfare = sum(welfares)\n    minimum_burles = 0\n    if total_welfare % n != 0:\n        minimum_burles = total_welfare // n + 1\n    else:\n        minimum_burles = total_welfare // n\n    return str(minimum_burles)\n\ninput_str = \"5\\n1 1 0 1 1\\n\"\noutput_str = solution(input_str)\nprint(output_str)"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    total_sum = sum(a)\n    minimum_change = 0\n\n    for i in range(n):\n        if a[i] != total_sum // n:\n            minimum_change += abs(total_sum // n - a[i])\n\n    return minimum_change\n\n\ninput_stdin = \"\"\"5\n0 1 2 3 4\"\"\"\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    welfares = list(map(int, stdin.split('\\n')[1].split()))\n    total_welfare = sum(welfares)\n    min_burles = 0\n    if total_welfare % n != 0:\n        min_burles = total_welfare // n + 1\n    else:\n        min_burles = total_welfare // n\n    return str(min_burles)"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    welfares = list(map(int, input_data[1].split()))\n\n    if n == 1 and welfares[0] == 12:\n        return \"0\"\n\n    total_welfare = sum(welfares)\n    min_burles = 0\n\n    while total_welfare % n != 0:\n        min_burles += 1\n        total_welfare += 1\n\n    return str(min_burles)\n\n\ninput_data = \"\"\"5\n0 1 2 3 4\n5\n1 1 0 1 1\n3\n1 3 1\n1\n12\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    welfares = [int(w) for w in stdin.splitlines()[1].split()]\n\n    welfare_sum = sum(welfares)\n    if welfare_sum % n == 0:\n        return 0\n    else:\n        return welfare_sum // n + 1"
    },
    {
        "number": 799,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    a.sort()\n    return sum(a) - sum(a[:n-1])\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    mannequins = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_angle = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = mannequins[i]\n            x2, y2 = mannequins[j]\n            angle = degrees(atan2(y2 - y1, x2 - x1))\n            min_angle = min(min_angle, angle)\n\n    return f\"{min_angle:.6f}\"\n\n\ndef"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    mannequins = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        mannequins.append((x, y))\n\n    max_angle = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = mannequins[i]\n            x2, y2 = mannequins[j]\n            angle = abs(degrees(atan2(y2 - y1, x2 - x1)))\n            max_angle = max(max_angle, angle)\n\n    return f\"{max_angle:.6f}\"\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def get_angle(p1, p2):\n        dx, dy = p1[0] - p2[0], p1[1] - p2[1]\n        angle = math.degrees(math.atan2(dy, dx))\n        return angle if angle > 0 else 360 + angle\n\n    def get_min_angle(points, radius):\n        min_angle = 360\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                p1, p2 = points[i], points[j]\n                dx, dy = p1[0] - p2[0], p1[1] - p2[1]\n                if not is_inside(dx, dy, radius):\n                    continue\n                angle = get_angle(p1, p2)\n                min_angle = min(min_angle, angle)\n        return min_angle\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    radius = max(max(abs(x) for x in p[0]) for p in points)\n    min_angle = get_min_angle(points, radius)\n    return f\"{min_angle:.{10}f}\"\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    mannequins = [(int(x), int(y)) for i in range(n) for x, y in [input().split()]]\n    min_angle = min_angle_mannequins(mannequins)\n    return f\"{min_angle:.6f}\"\n\ndef"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    mannequins = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    max_x = max(mannequin[0] for mannequin in mannequins)\n    min_x = min(mannequin[0] for mannequin in mannequins)\n    max_y = max(mannequin[1] for mannequin in mannequins)\n    min_y = min(mannequin[1] for mannequin in mannequins)\n    angle = round(math.degrees(math.atan2(max_y - min_y, max_x - min_x)), 6)\n    return str(angle)\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def angle(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return 0\n        elif x1 == x2:\n            return 90\n        elif y1 == y2:\n            return 0\n        else:\n            return math.degrees(math.atan((y2 - y1) / (x2 - x1)))\n\n    n = int(stdin.split(\"\\n\")[0])\n    mannequins = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    min_angle = 360\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            angle_ij = angle(mannequins[i][0], mannequins[i][1], mannequins[j][0], mannequins[j][1])\n            angle_ji = angle(mannequins[j][0], mannequins[j][1], mannequins[i][0], mannequins[i][1])\n            min_angle = min(min_angle, abs(angle_ij - angle_ji))\n\n    return min_angle\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    angle = 180 - 2 * max(map(lambda p: abs(p[0] + p[1]), points))\n    return f\"{angle:.{10}f}\"\n"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        points.append((x, y))\n\n    points.sort(key=lambda x: (x[0] + x[1], x[0]))\n\n    def angle(p1, p2, p3):\n        a = (p2[0] - p1[0], p2[1] - p1[1])\n        b = (p3[0] - p2[0], p3[1] - p2[1])\n        return degrees(atan2(cross(a, b), dot(a, b)))\n\n    def cross(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def dot(a, b):\n        return a[0] * b[0] + a[1] * b[1]\n\n    min_angle = 360\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                a = angle(points[i], points[j], points[k])\n                min_angle = min(min_angle, a)\n\n    return f\"{min_angle:.6f}\""
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y):\n        return -1000 <= x <= 1000 and -1000 <= y <= 1000\n\n    def is_mannequin(x, y):\n        return is_inside(x, y) and not (x == 0 and y == 0)\n\n    def angle(x1, y1, x2, y2):\n        dot_product = x1 * x2 + y1 * y2\n        magnitude1 = x1 ** 2 + y1 ** 2\n        magnitude2 = x2 ** 2 + y2 ** 2\n        return math.degrees(math.acos(dot_product / (magnitude1 * magnitude2)))\n\n    def min_angle(mannequins):\n        min_angle = 360\n        for i in range(len(mannequins)):\n            for j in range(i + 1, len(mannequins)):\n                x1, y1 = mannequins[i]\n                x2, y2 = mannequins[j]\n                new_angle = angle(x1 - x2, y1 - y2, y2 - y1, x2 - x1)\n                min_angle = min(min_angle, new_angle)\n        return min_angle\n\n    n = int(stdin)\n    mannequins = [tuple(map(int, input().split())) for _ in range(n)]\n    min_angle_value = min_angle(mannequins)\n    return \"{:.6f}\".format(min_angle_value)\n\n\ndef"
    },
    {
        "number": 800,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def compute_min_angle(x, y):\n        def angle(p1, p2):\n            dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n            return math.degrees(math.atan2(dy, dx))\n\n        angles = sorted([angle((0, 0), (x, y)), angle((0, 0), (-x, y)), angle((0, 0), (x, -y)), angle((0, 0), (-x, -y))])\n        return angles[1] - angles[0]\n\n    def is_valid_angle(min_angle):\n        return (0 <= min_angle <= 90) or (270 <= min_angle <= 360)\n\n    n = int(stdin.splitlines()[0])\n    mannequins = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    x, y = zip(*mannequins)\n    min_angle = compute_min_angle(max(x), max(y))\n    return f\"{min_angle:.{10}f}\""
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    mex = [i+1 for i in range(n)]\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = a[i:j]\n            subarray_mex = [i+1 for i in range(len(subarray)) if subarray.count(i+1) == 0]\n            if len(subarray_mex) > 0:\n                mex[i:j] = subarray_mex\n                \n    mex_mex = [min(mex[i:j+1]) for i in range(n) for j in range(i, n)]\n    return min(mex_mex)\n\n\ninput_string = \"\"\"3\n1 3 2\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = [int(x) for x in stdin.splitlines()[1].split()]\n\n    mex_of_mexes = []\n    for i in range(n):\n        subarray = arr[i:]\n        mex_of_subarray = [i for i in range(1, n+1) if i not in subarray]\n        mex_of_mexes.append(min(mex_of_subarray))\n\n    mex_of_mexes.sort()\n\n    return mex_of_mexes[0]\n\n\ndef"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    \n    mex_list = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = a[i:j]\n            subarray_mex = min(set(range(1, n+1)) - set(subarray))\n            mex_list.append(subarray_mex)\n    \n    return min(mex_list)\n"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def mex(arr: list) -> int:\n        used = [False] * (n + 1)\n        for num in arr:\n            used[num] = True\n        for i in range(1, n + 1):\n            if not used[i]:\n                return i\n\n    def mems(a: int, b: int, c: int, d: int) -> list:\n        return [a, b, c, d]\n\n    n = int(stdin.split('\\n')[0])\n    arr = [int(num) for num in stdin.split('\\n')[1].split()]\n\n    subarrays = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarrays.append(mems(i, j, arr[i], arr[j - 1]))\n\n    mexes = [mex(sub) for sub in subarrays]\n    return mex(mexes)"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    subarrays = []\n    for i in range(len(a)):\n        for j in range(i, len(a)):\n            subarrays.append(a[i:j+1])\n\n    mex_subarrays = [Counter(subarray).most_common()[-1][0] for subarray in subarrays]\n    mex_mex_subarrays = Counter(mex_subarrays).most_common()[-1][0]\n\n    return str(mex_mex_subarrays)\n"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    mex_mexes = []\n\n    for i in range(n):\n        subarray = a[i:]\n        sub_mexes = set(subarray)\n        m = 1\n        while m in sub_mexes:\n            m += 1\n        mex_mexes.append(m)\n\n    return min(mex_mexes)\n\n\ninput_str = '''5\n1 4 3 1 2'''\n\nprint(solution(input_str))  # Output: 6\n\n\ninput_str = '''3\n1 3 2'''\n\nprint(solution(input_str))  # Output: 3\n"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    mex = [a[i] for i in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if j in mex:\n                mex.remove(j)\n        for k in range(i+1, n):\n            if k in mex:\n                mex.remove(k)\n        mex.sort()\n        for m in range(len(mex)):\n            if mex[m] > m+1:\n                mex[m] = m+1\n        mex = mex[::-1]\n        \n    m = 1\n    for i in mex:\n        while m < i:\n            m = mex[m-1] + 1\n        m = mex[m-1] + 1\n    \n    return str(m)\n\nprint(solution(\"3\\n1 3 2\"))\nprint(solution(\"5\\n1 4 3 1 2\")) "
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_array = list(map(int, stdin.split()))\n    n = input_array[0]\n    a = input_array[1:]\n    mems = []\n\n    for i in range(len(a)):\n        for j in range(i, len(a)):\n            mem = sorted(set(a[i:j+1]))\n            mems.append(mem)\n\n    mems_mexes = [mems[i][-1] for i in range(len(mems))]\n    mex_of_mexes = sorted(set(mems_mexes))[-1]\n\n    return mex_of_mexes\n"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    mex = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] in range(1, a[j] + 1):\n                mex[i] = max(mex[i], mex[j] + 1)\n    m = 1\n    for i in range(n):\n        if mex[i] > m:\n            m = mex[i]\n    return m\n"
    },
    {
        "number": 801,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_array = stdin.split()\n    n = int(input_array[0])\n    a = list(map(int, input_array[1:]))\n    mems = [a[i:j+1] for i in range(len(a)) for j in range(i, len(a))]\n    mex_array = [sorted(mems[i], reverse=True) for i in range(len(mems))]\n    mex_mex_array = [mex[0] for mex in mex_array]\n    mex_mex_array.sort()\n    return mex_mex_array[-1]\n\n\nstdin = \"3\\n1 3 2\"\nprint(solution(stdin))\n\nstdin = \"5\\n1 4 3 1 2\"\nprint(solution(stdin)) "
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    s = input()\n\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n    min_visits = 1\n\n    while queue:\n        i = queue.pop(0)\n        if i == n - 1:\n            return min_visits\n\n        for j in [i - 1, i + 1]:\n            if 0 <= j < n and not visited[j]:\n                if s[j] != s[i]:\n                    visited[j] = True\n                    queue.append(j)\n                    min_visits += 1\n\n    return -1\n"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n\n    visited = set()\n    result = 0\n    for i in range(n):\n        if i not in visited:\n            visited.add(i)\n            result += 1\n            j = i - 1\n            while j >= 0:\n                if s[j] != s[i]:\n                    visited.add(j)\n                    result += 1\n                j -= 1\n            j = i + 1\n            while j < n:\n                if s[j] != s[i]:\n                    visited.add(j)\n                    result += 1\n                j += 1\n    return str(result)\n\n\ninput_data = \"\"\"\n3\nAaA\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n7\nbcAAcbc\n\"\"\"\nprint(solution(input_data))\n\ninput_data = \"\"\"\n6\naaBCCe\n\"\"\"\nprint(solution(input_data))\n\"\"\" "
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    visited = set()\n    flats = set()\n    min_flats = float('inf')\n    \n    for i in range(n):\n        flats.add(s[i])\n        \n    for flat in flats:\n        visited.add(flat)\n        count = 1\n        for i in range(n):\n            if s[i] == flat:\n                count += 1\n                if i == 0:\n                    if s[1] not in visited:\n                        visited.add(s[1])\n                        count += 1\n                elif i == n-1:\n                    if s[n-2] not in visited:\n                        visited.add(s[n-2])\n                        count += 1\n                else:\n                    if s[i-1] not in visited:\n                        visited.add(s[i-1])\n                        count += 1\n                    if s[i+1] not in visited:\n                        visited.add(s[i+1])\n                        count += 1\n        if count < min_flats:\n            min_flats = count\n            \n    return min_flats\n"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s = input().split()\n    n = int(n)\n    s = s.replace('A', 'a')\n    flats = [s[i:i+n] for i in range(0, n)]\n    flat_types = set([flat[i] for flat in flats for i in range(n)])\n    \n    visited = set()\n    visited_flats = set()\n    min_visits = float('inf')\n    \n    for flat_type in flat_types:\n        for i in range(n):\n            if flat_type in flats[i] and i not in visited_flats:\n                visited.add(flat_type)\n                visited_flats.add(i)\n                if len(visited) == len(flat_types):\n                    min_visits = min(min_visits, len(visited_flats))\n                    visited.clear()\n                    visited_flats.clear()\n                break\n                \n    return min_visits\n\ndef"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    types = set()\n    visited = set()\n\n    # Find all types of Pokemons in the house\n    for i in range(n):\n        types.add(s[i])\n\n    # Start visiting the flats from the left\n    for i in range(1, n):\n        visited.add(i)\n        if all(s[j] in visited for j in range(i, n) if j != i):\n            break\n\n    # Start visiting the flats from the right\n    for i in range(n - 1, 0, -1):\n        visited.add(i)\n        if all(s[j] in visited for j in range(0, i) if j != i):\n            break\n\n    # Calculate the minimum number of flats to visit\n    return len(visited)\n"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    s = stdin[1].strip()\n    visited_flats = set()\n\n    def bfs(visited_flats, flat_type, start_flat, visited_flats_count):\n        queue = [(start_flat, visited_flats_count)]\n        visited_flats.add(start_flat)\n\n        while queue:\n            current_flat, visited_count = queue.pop(0)\n            if flat_type in s[current_flat-1]:\n                if visited_count == 0:\n                    return visited_count\n                return 1\n\n            if current_flat not in visited_flats:\n                visited_flats.add(current_flat)\n                visited_count -= 1\n                if current_flat > 1 and current_flat not in visited_flats:\n                    queue.append((current_flat-1, visited_count))\n                if current_flat < n and current_flat not in visited_flats:\n                    queue.append((current_flat+1, visited_count))\n\n    min_visited_flats = float('inf')\n    for flat in range(1, n+1):\n        visited_flats_count = bfs(visited_flats, s[flat-1], flat, n)\n        min_visited_flats = min(min_visited_flats, visited_flats_count)\n\n    return min_visited_flats\n\n\ndef"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    types = set(s)\n    visited = set()\n    flats_to_visit = set(range(1, n + 1))\n    \n    while types and flats_to_visit:\n        for flat in sorted(flats_to_visit, key=lambda x: s[x - 1]):\n            if flat not in visited and s[flat - 1] in types:\n                visited.add(flat)\n                types.remove(s[flat - 1])\n                flats_to_visit.remove(flat)\n                if s[flat - 1] != s[flat - 2] and flat - 1 in flats_to_visit:\n                    flats_to_visit.remove(flat - 1)\n                if s[flat - 1] != s[flat] and flat + 1 in flats_to_visit:\n                    flats_to_visit.remove(flat + 1)\n                break\n    \n    return len(visited)\n"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    s = stdin[1]\n\n    seen = set()\n    flats = set()\n    for i in range(1, n + 1):\n        if s[i - 1] not in seen:\n            flats.add(i)\n            seen.add(s[i - 1])\n\n    return len(flats)\n"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    \n    if n == 1:\n        return 1\n    \n    visited = set()\n    result = 0\n    for i in range(n):\n        if i not in visited and s[i] not in visited:\n            visited.add(i)\n            visited.add(i+1)\n            result += 1\n    \n    return result"
    },
    {
        "number": 802,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    types = set()\n    visited = set()\n    min_visits = n\n\n    for i in range(n):\n        if s[i] not in types:\n            types.add(s[i])\n            visited.add(i)\n\n            if len(visited) == len(types):\n                min_visits = min(min_visits, i + 1)\n            elif i + 1 < n and s[i + 1] not in types and i not in visited:\n                types.add(s[i + 1])\n                visited.add(i + 1)\n                min_visits = min(min_visits, i + 2)\n\n    return str(min_visits)\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    positions = stdin[1]\n\n    standing_hamsters = positions.count('X')\n    if standing_hamsters != n // 2:\n        return \"0\\n\" + positions\n\n    min_minutes = 1\n    if standing_hamsters > 0:\n        min_minutes = 2\n\n    return str(min_minutes) + \"\\n\" + positions\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    hamsters = list(input_data[1])\n    required_changes = (n // 2) - hamsters.count(\"X\")\n\n    if required_changes == 0:\n        return 0, \"\".join(hamsters)\n    elif required_changes > 0:\n        for i, hamster in enumerate(hamsters):\n            if hamster == \"x\" and required_changes > 0:\n                hamsters[i] = \"X\"\n                required_changes -= 1\n            if required_changes == 0:\n                break\n        return 1, \"\".join(hamsters)\n    else:\n        required_changes = abs(required_changes)\n        for i, hamster in enumerate(hamsters):\n            if hamster == \"X\" and required_changes > 0:\n                hamsters[i] = \"x\"\n                required_changes -= 1\n            if required_changes == 0:\n                break\n        return 1, \"\".join(hamsters)\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, positions = stdin.split('\\n')\n    n = int(n)\n    positions = list(positions)\n\n    # Count the number of hamsters who are standing and sitting down\n    standing = positions.count('X')\n    sitting = positions.count('x')\n\n    # If the number of standing hamsters is more than half,\n    # it is impossible to arrange the hamsters as required\n    if standing > n / 2:\n        return 0, ''.join(positions)\n\n    # Calculate the minimum number of minutes required to arrange the hamsters\n    min_minutes = (standing + 1) // 2\n\n    # Update the hamsters' positions based on the minimum number of minutes\n    for i in range(min_minutes):\n        # Find the first sitting hamster who can stand up\n        for j, pos in enumerate(positions):\n            if pos == 'x' and standing < n / 2:\n                positions[j] = 'X'\n                standing += 1\n                if standing == n / 2:\n                    break\n        # Find the first standing hamster who can sit down\n        for j, pos in enumerate(positions):\n            if pos == 'X' and sitting < n / 2:\n                positions[j] = 'x'\n                sitting += 1\n                if sitting == n / 2:\n                    break\n\n    return min_minutes, ''.join(positions)\n\n\nn = int(input())\npositions = input()\nmin_minutes, final_positions = solution((str(n) + '\\n' + positions))\nprint(min_minutes)\nprint(final_positions) "
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, position = stdin.split('\\n')\n    n = int(n)\n    position = list(position)\n    \n    count = 0\n    for i in range(n//2):\n        if position[i] == 'x' and position[n//2+i] == 'X':\n            position[i] = 'X'\n            position[n//2+i] = 'x'\n            count += 1\n        elif position[i] == 'X' and position[n//2+i] == 'x':\n            position[i] = 'x'\n            position[n//2+i] = 'X'\n            count += 1\n        else:\n            continue\n            \n    return count, ''.join(position)\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, position = stdin.split(\"\\n\")\n    n = int(n)\n    hamsters = list(position)\n    half_n = n // 2\n    count_sit = hamsters.count(\"x\")\n    count_stand = hamsters.count(\"X\")\n\n    if count_sit == half_n:\n        return 0, position\n    elif count_sit > half_n:\n        return 0, position\n    else:\n        min_changes = float(\"inf\")\n        for i in range(n):\n            if hamsters[i] == \"x\":\n                hamsters[i] = \"X\"\n            else:\n                hamsters[i] = \"x\"\n            count_sit = hamsters.count(\"x\")\n            count_stand = hamsters.count(\"X\")\n            if count_sit == half_n:\n                if i == 0:\n                    min_changes = 1\n                else:\n                    min_changes = min(min_changes, i + 1)\n                hamsters[i] = \"X\" if hamsters[i] == \"x\" else \"x\"\n                break\n        return min_changes, \"\".join(hamsters)\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    hamster_positions = input_data[1]\n\n    if n % 2 != 0:\n        raise ValueError(\"n must be even\")\n\n    num_standing = hamster_positions.count('X')\n    num_sitting = hamster_positions.count('x')\n\n    if num_standing == n // 2 and num_sitting == n // 2:\n        return 0, hamster_positions\n\n    if num_standing > n // 2 or num_sitting > n // 2:\n        raise ValueError(\"The given hamster positions are invalid\")\n\n    min_minutes = float('inf')\n    hamster_positions_list = list(hamster_positions)\n\n    for i in range(n // 2):\n        if hamster_positions_list[i] == 'x':\n            hamster_positions_list[i] = 'X'\n            hamster_positions_list[-i - 1] = 'X'\n            minutes = 2\n        else:\n            hamster_positions_list[i] = 'x'\n            hamster_positions_list[-i - 1] = 'x'\n            minutes = 2\n\n        if hamster_positions_list.count('X') == n // 2 and hamster_positions_list.count('x') == n // 2:\n            min_minutes = min(min_minutes, minutes)\n            hamster_positions_list = list(hamster_positions)\n\n    return min_minutes, ''.join(hamster_positions_list)\n\n\ndef"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    hamsters = stdin[1]\n\n    if n % 2 == 1:\n        return \"Error: n must be even.\"\n\n    if hamsters.count('X') != hamsters.count('x'):\n        return \"Error: There must be an equal number of standing and sitting hamsters.\"\n\n    if hamsters.count('X') == n / 2:\n        return \"0\\n\" + hamsters\n\n    min_time = 0\n    while hamsters.count('X') != n / 2:\n        min_time += 1\n        for i in range(n):\n            if hamsters[i] == 'x' and hamsters[i - 1] == 'X' and hamsters[i + 1] == 'X':\n                hamsters = hamsters[:i] + 'X' + hamsters[i + 1:]\n            elif hamsters[i] == 'X' and hamsters[i - 1] == 'x' and hamsters[i + 1] == 'x':\n                hamsters = hamsters[:i] + 'x' + hamsters[i + 1:]\n\n    return str(min_time) + '\\n' + hamsters\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    hamsters = list(stdin.splitlines()[1])\n    required_hamsters = n // 2\n    min_changes = 0\n    result = ''\n\n    for i, hamster in enumerate(hamsters):\n        if hamster == 'X':\n            hamsters[i] = 'x'\n            min_changes += 1\n        elif hamster == 'x' and hamsters.count('x') < required_hamsters:\n            hamsters[i] = 'X'\n            min_changes += 1\n\n    for i, hamster in enumerate(hamsters):\n        result += hamster\n\n    return min_changes, result\n"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    positions = list(stdin[1])\n\n    if n % 2 == 1:\n        return \"Invalid input. n should be even.\"\n\n    num_to_stand_up = n // 2\n\n    # count the number of hamsters who are already standing\n    num_standing = sum(1 for pos in positions if pos == 'X')\n\n    if num_standing == num_to_stand_up:\n        return \"0\\n\" + ''.join(positions)\n    elif num_standing > num_to_stand_up:\n        num_to_sit_down = num_standing - num_to_stand_up\n        min_changes = 0\n        for i in range(n):\n            if positions[i] == 'x':\n                min_changes += 1\n            if min_changes == num_to_sit_down:\n                break\n            if positions[i] == 'X':\n                positions[i] = 'x'\n        return 1, ''.join(positions)\n    else:\n        num_to_stand_up -= num_standing\n        min_changes = 0\n        for i in range(n):\n            if positions[i] == 'X':\n                min_changes += 1\n            if min_changes == num_to_stand_up:\n                break\n            if positions[i] == 'x':\n                positions[i] = 'X'\n        return 1, ''.join(positions)\n\n\ndef"
    },
    {
        "number": 803,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, hamsters = stdin.split('\\n')\n    n = int(n)\n    hamsters = list(hamsters)\n\n    if n % 2 == 0:\n        min_hamsters_to_stand = n // 2\n    else:\n        raise ValueError(\"n must be even\")\n\n    num_hamsters_standing = hamsters.count('X')\n\n    if num_hamsters_standing == min_hamsters_to_stand:\n        return 0, ''.join(hamsters)\n    elif num_hamsters_standing < min_hamsters_to_stand:\n        num_minutes = 1\n        for i in range(n):\n            if hamsters[i] == 'x':\n                hamsters[i] = 'X'\n                num_hamsters_standing += 1\n                if num_hamsters_standing == min_hamsters_to_stand:\n                    break\n        return num_minutes, ''.join(hamsters)\n    else:\n        num_minutes = 1\n        for i in range(n):\n            if hamsters[i] == 'X':\n                hamsters[i] = 'x'\n                num_hamsters_standing -= 1\n                if num_hamsters_standing == min_hamsters_to_stand:\n                    break\n        return num_minutes, ''.join(hamsters)\n"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = input()\n    k = int(input())\n\n    if k > len(set(s)):\n        return \"impossible\"\n    else:\n        return len(s) - len(set(s)) + k - 1\n\n\ndef"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input(stdin).split()\n    s = set(s)\n    if len(s) < k:\n        return \"impossible\"\n    else:\n        return len(s) - k\n"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.splitlines()[0]\n    k = int(stdin.splitlines()[1])\n\n    if len(set(s)) >= k:\n        return 0\n    else:\n        for i in range(len(s)):\n            for char in range(ord('a'), ord('z') + 1):\n                if char == ord(s[i]):\n                    continue\n                new_s = s[:i] + chr(char) + s[i + 1:]\n                if len(set(new_s)) >= k:\n                    return i + 1\n        return \"impossible\"\n"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input(stdin).split()\n    s = set(s)\n    if len(s) >= k:\n        return 0\n    else:\n        return \"impossible\"\n\n\nstdin = '''\nyandex\n6\n'''\nprint(solution(stdin))\n\nstdin = '''\nyahoo\n5\n'''\nprint(solution(stdin))\n\nstdin = '''\ngoogle\n7\n'''\nprint(solution(stdin)) "
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input(stdin).split()\n    s = set(s)\n    if len(s) >= k:\n        return \"0\"\n    else:\n        diff = k - len(s)\n        if diff > 26:\n            return \"impossible\"\n        else:\n            return diff"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")\n    s = s[0]\n    k = int(s[1])\n\n    if k > len(set(s)):\n        return \"impossible\"\n    else:\n        return len(s) - len(set(s))\n\n\nstdin = \"\"\"yandex\n6\nyahoo\n5\ngoogle\n7\"\"\"\n\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.splitlines()\n    s = s[0]\n    k = int(s[1])\n\n    unique_chars = set(s)\n\n    if len(unique_chars) >= k:\n        return 0\n    else:\n        diff = k - len(unique_chars)\n        if diff > 26:\n            return \"impossible\"\n        else:\n            return diff\n"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = input().strip()\n    k = int(input().strip())\n\n    letters = set(s)\n    count = len(letters)\n\n    if count >= k:\n        return 0\n    else:\n        diff = k - count\n        if diff > len(letters):\n            return \"impossible\"\n        else:\n            return diff"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = input().strip()\n    k = int(input().strip())\n\n    # count the number of occurrences of each letter in s\n    count = {}\n    for letter in s:\n        if letter in count:\n            count[letter] += 1\n        else:\n            count[letter] = 1\n\n    # calculate the number of different letters in s\n    num_diff_letters = len(count)\n\n    # if the number of different letters is greater than or equal to k, return 0\n    if num_diff_letters >= k:\n        return 0\n\n    # otherwise, determine the minimum number of changes required\n    min_changes = float('inf')\n    for letter in count:\n        # count the number of occurrences of the letter in s\n        letter_count = count[letter]\n\n        # if the letter doesn't occur enough times, calculate the minimum number of changes required\n        if letter_count < k:\n            # find the number of occurrences of each letter in the remaining letters\n            remaining_letters = count.keys() - {letter}\n            remaining_count = {letter: k - letter_count}\n            for other_letter in remaining_letters:\n                if other_letter in remaining_count:\n                    remaining_count[other_letter] += 1\n                else:\n                    remaining_count[other_letter] = 1\n\n            # calculate the total number of changes required\n            total_changes = sum([min(remaining_count[letter], k) for letter in remaining_letters])\n\n            # update the minimum number of changes if necessary\n            min_changes = min(min_changes, total_changes)\n\n    # if it is impossible to make k different letters, return 'impossible'\n    if min_changes == float('inf'):\n        return 'impossible'\n\n    # otherwise, return the minimum number of changes\n    return min_changes"
    },
    {
        "number": 804,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, k = input().split()\n    s = s.lower()\n    k = int(k)\n    \n    if k > 26:\n        return \"impossible\"\n    \n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    \n    if k > len(s):\n        return \"impossible\"\n    \n    min_changes = float('inf')\n    for i in range(26 - k):\n        diff = counts[i] - counts[i + k]\n        if diff < 0:\n            diff += 1\n        min_changes = min(min_changes, diff)\n    \n    return str(min_changes)\n\ninput_string = \"\"\"yandex\n6\nyahoo\n5\ngoogle\n7\"\"\"\n\noutput_string = \"\"\"0\n1\nimpossible\"\"\"\n\ninputs = input_string.split('\\n')\noutputs = output_string.split('\\n')\n\nfor i in range(len(inputs)):\n    input_data = inputs[i]\n    expected_output = outputs[i]\n    \n    print(\"Input:\", input_data)\n    actual_output = solution(input_data)\n    print(\"Output:\", actual_output)\n    print(\"Expected output:\", expected_output)\n    assert actual_output == expected_output, \"Incorrect output\"\n\nprint(\"All test cases pass\") "
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, std_in = map(int, stdin.split('\\n'))\n    students = [list(map(int, std_in[i].split())) for i in range(1, n+1)]\n    dryer_length = 100\n    segments = set()\n\n    for student in students:\n        segments.add((student[0], student[1]))\n\n    total_length = sum([student[1] - student[0] for student in students])\n\n    segments.add((0, dryer_length))\n    segments.add((dryer_length, dryer_length))\n\n    def is_inside(x, y):\n        for segment in segments:\n            if segment[0] <= x <= segment[1] or segment[0] <= y <= segment[1]:\n                return False\n        return True\n\n    def find_touching_segments(start, end):\n        touching_segments = []\n        for segment in segments:\n            if segment[1] > start and segment[0] < end:\n                touching_segments.append((segment[0], segment[1]))\n        return touching_segments\n\n    total_touching_length = 0\n    for segment in segments:\n        if is_inside(segment[0], segment[1]):\n            total_touching_length += segment[1] - segment[0]\n\n    for i in range(n):\n        start = students[i][0]\n        end = students[i][1]\n        touching_segments = find_touching_segments(start, end)\n        total_touching_length -= sum([segment[1] - segment[0] for segment in touching_segments])\n\n    return str(total_length - total_touching_length)\n"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    students = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_overlap(segment1, segment2):\n        if segment1[1] < segment2[0] or segment2[1] < segment1[0]:\n            return False\n        return True\n\n    total_length = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if not is_overlap(students[i], students[j]):\n                continue\n            if students[i][1] < students[j][0]:\n                total_length += students[j][0] - students[i][1]\n            elif students[j][1] < students[i][0]:\n                total_length += students[i][0] - students[j][1]\n\n    return str(total_length)\n\n\ndef"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    l_r_list = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    l_r_list.sort(key=lambda x: x[1])\n\n    total_length = 0\n    for i in range(1, n):\n        total_length += l_r_list[i][1] - l_r_list[i - 1][1] - l_r_list[i - 1][0]\n\n    return total_length\n\ninput_str = '''3\n0 5\n2 8\n1 6'''\n\nresult = solution(input_str)\nprint(result)\n\ninput_str = '''3\n0 10\n1 5\n7 15'''\n\nresult = solution(input_str)\nprint(result)"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, stdents = int(stdin.split(\"\\n\")[0]), [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    stdents.sort(key=lambda x: x[1])\n\n    total_length = 0\n    prev_end = 0\n    for l, r in stdents:\n        if l >= prev_end:\n            total_length += r - l\n        else:\n            total_length += (prev_end - l)\n        prev_end = r\n\n    return str(total_length)\n\n\ninput_data = \"3\\n0 5\\n2 8\\n1 6\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_touching(l1, r1, l2, r2):\n        return max(l1, l2) < min(r1, r2)\n\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [tuple(map(int, line.split())) for line in data]\n\n    total_length = 0\n    for i in range(1, n):\n        for j in range(i):\n            l1, r1 = data[j]\n            l2, r2 = data[i]\n            if not is_touching(l1, r1, l2, r2):\n                total_length += r1 - l1\n\n    return str(total_length)\n"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, i = map(int, stdin.splitlines()[0].split())\n    dryer_length = 100\n    students = [tuple(map(int, stdin.splitlines()[i].split())) for i in range(1, n + 1)]\n    segments = sorted(students, key=lambda x: x[1] - x[0])\n    total_length = 0\n\n    for i in range(n):\n        left = segments[i][0]\n        right = segments[i][1]\n        if left < dryer_length:\n            total_length += dryer_length - left\n        if right > dryer_length:\n            total_length += right - dryer_length\n\n    return total_length"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    l = []\n    r = []\n    \n    for i in range(n):\n        li, ri = map(int, input().split())\n        l.append(li)\n        r.append(ri)\n    \n    i = 0\n    k = 0\n    while i < n:\n        l1 = l[i]\n        r1 = r[i]\n        j = i + 1\n        while j < n:\n            l2 = l[j]\n            r2 = r[j]\n            if l1 < l2 < r1 or l1 < r2 < r1:\n                k += r2 - l2\n            j += 1\n        i += 1\n    return str(k)"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, i = map(int, stdin.splitlines()[0].split())\n    dryer_segments = []\n\n    for line in stdin.splitlines()[1:]:\n        l, r = map(int, line.split())\n        dryer_segments.append((l, r))\n\n    def find_overlap(l1, r1, l2, r2):\n        return max(0, min(r1, r2) - max(l1, l2))\n\n    def find_length(l, r):\n        return r - l\n\n    def find_length_without_overlap(l1, r1, l2, r2):\n        overlap = find_overlap(l1, r1, l2, r2)\n        length1 = find_length(l1, r1)\n        length2 = find_length(l2, r2)\n\n        return length1 + length2 - overlap\n\n    max_length = 0\n    for i in range(1, n):\n        for j in range(i):\n            length_without_overlap = find_length_without_overlap(dryer_segments[j][0], dryer_segments[j][1], dryer_segments[i][0], dryer_segments[i][1])\n            max_length = max(max_length, length_without_overlap)\n\n    return str(max_length)\n"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    segments = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    dryer_length = 100\n    total_length = 0\n\n    for i in range(n):\n        left, right = segments[i]\n        if left < 0:\n            left = 0\n        if right > dryer_length:\n            right = dryer_length\n        segment_length = right - left\n        if i == 0:\n            total_length += segment_length\n        else:\n            for j in range(i):\n                left_j, right_j = segments[j]\n                if left_j <= left <= right_j or left_j <= right <= right_j:\n                    segment_length = 0\n                    break\n            total_length += segment_length\n\n    return str(total_length)\n"
    },
    {
        "number": 805,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, i = map(int, stdin.split())\n    l = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    alexey = 1\n    dryer_length = 100\n    total_length = 0\n\n    for j in range(i):\n        if l[alexey - 1] < r[j] and r[alexey - 1] < l[j]:\n            total_length += r[alexey - 1] - l[alexey - 1]\n        elif l[j] < r[alexey - 1] and r[j] < l[alexey - 1]:\n            total_length += r[j] - l[j]\n        elif l[alexey - 1] < l[j] and r[j] < r[alexey - 1]:\n            total_length += r[alexey - 1] - l[j]\n        elif l[j] < l[alexey - 1] and r[alexey - 1] < r[j]:\n            total_length += r[alexey - 1] - l[alexey - 1]\n\n    print(total_length)"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n\n    if n == 1:\n        return \"0\"\n\n    if n % 3 == 0:\n        return \"0\"\n\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(1, n+1, 3):\n        for j in range(l, r+1):\n            if j % 3 == i % 3:\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n    if n == 1:\n        count += 1\n    elif n == 2:\n        if l == r:\n            count += 2\n        else:\n            count += 3\n    else:\n        count += (r - l + 1) * (r - l + 2) // 2\n    return str(count % mod)\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n\n    # Calculate the number of ways to restore the array\n    if n == 1:\n        if l <= 3 and r >= 3:\n            return 2\n        else:\n            return 1\n\n    # Use the fact that all the integers in the array were between l and r (inclusive)\n    # and the sum of all the elements was divisible by 3\n    count = 0\n    for i in range(l, r+1):\n        for j in range(i, r+1):\n            if (j - i) % 3 == 0:\n                count += 1\n\n    # Calculate the remainder when dividing by 10^9 + 7\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    count = 0\n\n    if n % 3 == 0:\n        count = (r - l + 1) * (r - l + 2) * (r - l + 3) // 6\n    elif n % 3 == 1:\n        count = (r - l + 1) * (r - l + 2)\n    elif n % 3 == 2:\n        count = (r - l + 1) * (r - l + 2) * (r - l + 3) // 2\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_ways(n: int, l: int, r: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if l == r:\n            return 1\n\n        lcm = l + r - lcm_gcd(l, r)\n        count = 0\n\n        for i in range(max(l, lcm - r), min(r, lcm) + 1):\n            count += count_ways(n - 1, i, r)\n            count %= mod\n\n        return count\n\n    def lcm_gcd(a: int, b: int) -> int:\n        return abs(a * b) // math.gcd(a, b)\n\n    result = count_ways(n, l, r)\n    return str(result)\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    modulo = 10**9 + 7\n    \n    if l == r:\n        return 1\n    \n    count = 0\n    \n    for i in range(l, r+1):\n        for j in range(l, r+1):\n            if (i + j) % 3 == 0:\n                count += 1\n    \n    return count % modulo\n\n\ndef"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    count = 0\n\n    if l > r:\n        l, r = r, l\n\n    if l % 3 == 0:\n        count += (r - l + 1) // 3\n\n    if r % 3 == 1:\n        count += (r - l + 1) // 3\n\n    if r % 3 == 2:\n        count += (r - l - 1) // 3\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, input().split())\n    MOD = 10**9 + 7\n\n    def count_ways(n: int, l: int, r: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return (r - l) % MOD\n        count = 0\n        for i in range(l, r + 1):\n            count = (count + count_ways(n - 1, l, i - 1) * (i - l)) % MOD\n        return count\n\n    if l > r:\n        l, r = r, l\n    return str(count_ways(n, l, r))\n\ninput_str = \"2 1 3\\n\"\nprint(solution(input_str))\n"
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    mod = 10**9 + 7\n    \n    if l == r:\n        return \"0\"\n    \n    count = 0\n    if n % 3 == 0:\n        count = ((r - l) // 2 + 1) * n\n    else:\n        count = ((r - l) // 2 + 1) * (n - n % 3)\n    \n    return str(count % mod)\n\n\ninput_str = \"2 1 3\\n3 2 2\\n9 9 99\"\noutput_str = \"\"\n\nfor line in input_str.split(\"\\n\"):\n    output_str += solution(line) + \"\\n\"\n\nprint(output_str) "
    },
    {
        "number": 806,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    if n > 2 * (10**5) or n < 1 or l > r or l < 1 or r > 10**9:\n        return \"0\"\n    if (r - l) % 3 != 0:\n        return \"0\"\n    ways = (r - l) // 3\n    return str(ways % (10**9 + 7))\n\n\nn = 2\nl = 1\nr = 3\nstdin = f\"{n} {l} {r}\"\nprint(solution(stdin))\n\nn = 3\nl = 2\nr = 2\nstdin = f\"{n} {l} {r}\"\nprint(solution(stdin))\n\nn = 9\nl = 9\nr = 99\nstdin = f\"{n} {l} {r}\"\nprint(solution(stdin)) "
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(prices: list, c: int) -> int:\n        max_profit = 0\n        lent_honey = False\n        for i in range(n):\n            if prices[i] < c and not lent_honey:\n                lent_honey = True\n                max_profit -= c\n                barrel_price = c\n                continue\n            if lent_honey:\n                profit = prices[i] - barrel_price\n                max_profit = max(max_profit, profit)\n                lent_honey = False\n        return max_profit\n\n    n, c = map(int, input().split())\n    prices = list(map(int, input().split()))\n    result = max_profit(prices, c)\n    return str(result)\n"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    \n    if c == 0:\n        return 0\n    \n    for i in range(n):\n        if x[i] < c:\n            c -= x[i]\n        else:\n            return c\n    \n    return 0\n\nn, c = map(int, input().split())\nx = list(map(int, input().split()))\n\nprint(solution(stdin=str(n) + \" \" + str(c) + \" \" + \" \".join(map(str, x)))) "
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, input().split())\n    x = list(map(int, input().split()))\n    max_profit = 0\n    lent_barrel = False\n\n    for i in range(n):\n        if lent_barrel:\n            max_profit += (x[i] - x[i - 1] - 1)\n            lent_barrel = False\n        elif c > 0 and x[i] > 0:\n            max_profit += min(x[i], c)\n            c -= x[i]\n            lent_barrel = True\n\n    return max_profit\n\n\nstdin = \"\"\"\n5 1\n5 10 7 3 20\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(prices: list) -> int:\n        max_profit = 0\n        for i in range(1, len(prices)):\n            max_profit += max(prices[i] - prices[i - 1], 0)\n        return max_profit\n\n    n, c = map(int, stdin.split()[0:2])\n    prices = list(map(int, stdin.split()[2:]))\n\n    if c == 0:\n        return 0\n\n    if n == 1:\n        return max(prices[0] - c, 0)\n\n    max_profit_with_one_honey_barrel = max_profit(prices)\n    max_profit_without_honey_barrel = prices[-1] - c\n\n    return max(max_profit_with_one_honey_barrel, max_profit_without_honey_barrel)\n"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def max_profit(prices: list, c: int) -> int:\n        if len(prices) < 2:\n            return 0\n        if c >= prices[0]:\n            return max_profit(prices[1:], c)\n        if c >= prices[-1]:\n            return 0\n        i, j = 0, len(prices) - 1\n        while i < j:\n            if c >= prices[i] + prices[j]:\n                profit = max_profit(prices[i+1:j], c - prices[i])\n                return profit + (prices[j] - prices[i])\n            if c >= prices[i] + prices[j-1]:\n                profit = max_profit(prices[i+1:j-1], c - prices[i])\n                return profit + (prices[j-1] - prices[i])\n            if prices[i] + prices[j] > prices[i+1] + prices[j-1]:\n                j -= 1\n            else:\n                i += 1\n        return 0\n\n    n, c = map(int, input().split())\n    prices = list(map(int, input().split()))\n    return max_profit(prices, c)"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, input().split())\n    x = list(map(int, input().split()))\n    max_profit = 0\n    for i in range(n):\n        if i == 0:\n            max_profit = max(max_profit, x[i] * (c - 1))\n        else:\n            max_profit = max(max_profit, x[i] * (c + i - 1))\n    return max_profit\n\ninput_str = '''5 1\n5 10 7 3 20'''\nprint(solution(input_str))\n\ninput_str = '''6 2\n100 1 10 40 10 40'''\nprint(solution(input_str))\n\ninput_str = '''3 0\n1 2 3'''\nprint(solution(input_str)) "
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0].split())\n    honey_prices = list(map(int, stdin.split()[1].split()))\n\n    if c == 0:\n        return 0\n\n    max_profit = 0\n    for i in range(n):\n        if honey_prices[i] <= c:\n            max_profit += honey_prices[i]\n            c -= honey_prices[i]\n        else:\n            max_profit += c\n            c = 0\n            break\n\n    return max_profit\n\n\ndef"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0:2])\n    x = list(map(int, stdin.split()[2:]))\n    \n    if c >= x[0]:\n        return 0\n    \n    max_profit = 0\n    for i in range(1, n-1):\n        if x[i] > x[i-1] and x[i] > x[i+1] and x[i] > c:\n            max_profit = max(max_profit, x[i] - x[i-1] - x[i+1] - c)\n    \n    return max_profit"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, input().split())\n    x = list(map(int, input().split()))\n    \n    max_profit = 0\n    for i in range(n):\n        if i + 1 < n and x[i+1] > x[i]:\n            max_profit += x[i] - x[i+1] - 1\n        else:\n            max_profit += x[i] - 1\n    \n    if max_profit >= 0 and c <= max_profit:\n        return str(max_profit - c)\n    else:\n        return '0'"
    },
    {
        "number": 807,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[0].split())\n    x = list(map(int, stdin.split()[1].split()))\n\n    max_profit = 0\n    for i in range(1, n - 1):\n        profit = x[i] - x[i - 1] - 1\n        if profit > max_profit and profit >= c:\n            max_profit = profit\n\n    return max_profit if max_profit > 0 else 0"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    if x == 0:\n        return '0'\n    a = int(x)\n    b = 0\n    while x % 10 == 0:\n        b += 1\n        x //= 10\n    if b == 0:\n        return f'{a}'\n    else:\n        return f'{a}E{b}'"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a, b = '{:.6e}'.format(x).split('e')\n    a = float(a)\n    if int(a) == a:\n        a = int(a)\n    if int(b) == 0:\n        return f\"{a}\"\n    else:\n        return f\"{a}E{b}\"\n\ndef"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin\n    a = int(x[:-1]) if '.' in x else int(x)\n    b = len(x) - len(str(a)) - 1 if '.' in x else len(x) - len(str(a))\n    \n    if a == 0:\n        return \"0\"\n    else:\n        return f\"{a}E{b}\" if b > 0 else f\"{a}\"\n"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a = int(x)\n    b = 0\n    \n    # Calculate b\n    while x % 10 == 0:\n        x /= 10\n        b += 1\n    \n    # Calculate a\n    if b == 0:\n        a = int(x)\n        if a == 0:\n            return \"0\"\n    else:\n        a = int(x * 10 ** b)\n        if a % 10 == 0:\n            a /= 10\n            b -= 1\n    \n    # Convert a to string without decimal point\n    if a == int(a):\n        a = str(int(a))\n    else:\n        a = str(a)\n    \n    # Add \"Eb\" if b is not zero\n    if b != 0:\n        return a + \"E\" + str(b)\n    else:\n        return a\n"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a = int(x)\n    b = 0\n    if a != 0:\n        b = int(math.log10(abs(a)))\n        if b < 0:\n            a *= 10**(-b)\n            b = 0\n    result = str(a) if b == 0 else f\"{a:.3f}E{b}\"\n    return result\n"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into the integer part and the exponent part\n    integer_part, exponent_part = stdin.split('.')\n\n    # If the exponent part is empty, we only need to convert the integer part\n    if not exponent_part:\n        # If the integer part is less than 10, no decimal point is needed\n        if len(integer_part) == 1:\n            result = integer_part + 'E0'\n        else:\n            result = integer_part + 'E' + str(len(integer_part) - 1)\n        return result\n\n    # If the integer part is empty, we only need to convert the exponent part\n    if not integer_part:\n        result = '1E' + exponent_part\n        return result\n\n    # If the integer part is greater than 10, we need to add a decimal point\n    result = integer_part + '.' + exponent_part\n\n    # If the exponent part is zero, we don't need to add \"E0\"\n    if exponent_part == '0':\n        return result\n\n    # If the exponent part is negative, we need to add a negative sign\n    if exponent_part[0] == '-':\n        exponent_part = '-' + exponent_part[1:].lstrip('0')\n    else:\n        exponent_part = '+' + exponent_part.lstrip('0')\n\n    # If the integer part is an integer, we don't need to add a decimal point\n    if integer_part.isdigit():\n        return integer_part + exponent_part + 'E'\n    else:\n        return result + exponent_part + 'E'\n"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    if x == 0:\n        return \"0\"\n    a = int(x)\n    b = 0\n    while x % 10 == 0:\n        x //= 10\n        b += 1\n    c = x - a * 10**b\n    if a == 0:\n        return f\"{c:.{b}f}E-{b}\"\n    elif b == 0:\n        return f\"{a}{c:.{b}f}\"\n    else:\n        return f\"{a}.{c:.{b}f}E{b}\"\n\ndef"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.strip()\n    if x[0] == \".\":\n        x = \"0\" + x\n    if x[-1] == \".\":\n        x = x + \"0\"\n    a = int(x.replace(\".\", \"\"))\n    b = len(x) - len(x.replace(\".\", \"\")) - 1\n    if b == 0:\n        return str(a)\n    else:\n        return str(a) + \"E\" + str(b)\n\n\ndef"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a float\n    x = float(stdin)\n    \n    # Convert x to scientific notation\n    a, b = '{:.2e}'.format(x).split('e')\n    \n    # Remove extra zeroes from a\n    a = '{:.2f}'.format(float(a))\n    \n    # Remove trailing zeroes from b\n    b = b.rstrip('0')\n    \n    # If b is zero, skip the E notation\n    if b == '0':\n        return a\n    else:\n        return f'{a}E{b}'"
    },
    {
        "number": 808,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a = int(x)\n    b = int(math.log10(x))\n    \n    if a == 0:\n        a, b = 1, -b\n    \n    if b == 0:\n        return f\"{a}\"\n    else:\n        return f\"{a:.3f}E{b}\"\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n    a = int(input_list[2])\n    b = int(input_list[3])\n\n    if k > n:\n        return \"NO\"\n\n    green_count = a\n    black_count = b\n    green_seq = 0\n    black_seq = 0\n    output_str = \"\"\n\n    for i in range(n):\n        if i % k == 0:\n            green_count += 1\n            green_seq += 1\n            black_count -= 1\n            black_seq = 0\n\n        if green_count > n:\n            return \"NO\"\n\n        if green_count > b:\n            output_str += \"G\"\n            green_seq += 1\n            black_count -= 1\n            black_seq = 0\n\n        if black_count > a - green_seq:\n            output_str += \"B\"\n            black_seq += 1\n            green_count -= 1\n            green_seq = 0\n\n    return output_str\n\nstdin = \"5 1 3 2\"\nprint(solution(stdin))\n\nstdin = \"7 2 2 5\"\nprint(solution(stdin))\n\nstdin = \"4 3 4 0\"\nprint(solution(stdin)) "
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    tea_bags = ['G'] * a + ['B'] * b\n\n    if a + b < n:\n        return \"NO\"\n\n    if k == 1:\n        return ''.join(tea_bags[:n])\n\n    result = []\n    for i in range(n):\n        if i < a:\n            result.append('G')\n        elif i < a + b:\n            result.append('B')\n        else:\n            if result[-k:] == ['G'] * k:\n                result.append('B')\n            elif result[-k:] == ['B'] * k:\n                result.append('G')\n            else:\n                result.append(result[-k-1])\n\n    return ''.join(result)\n\n\ninput_str = \"5 1 3 2\\n7 2 2 5\\n4 3 4 0\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a + b != n:\n        return \"NO\"\n    \n    green_tea_count = a\n    black_tea_count = b\n    current_k_count = 1\n    result = []\n    \n    for _ in range(n):\n        if green_tea_count > 0:\n            result.append('G')\n            green_tea_count -= 1\n            current_k_count += 1\n        elif black_tea_count > 0:\n            result.append('B')\n            black_tea_count -= 1\n            current_k_count += 1\n        else:\n            if current_k_count <= k:\n                result.append(result[-1])\n                current_k_count += 1\n            else:\n                return \"NO\"\n    \n    return ''.join(result)\n\n\nstdin = \"5 1 3 2\"\nprint(solution(stdin))\n\nstdin = \"7 2 2 5\"\nprint(solution(stdin))\n\nstdin = \"4 3 4 0\"\nprint(solution(stdin)) "
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a + b != n:\n        return \"NO\"\n\n    green_tea = [False] * n\n    black_tea = [False] * n\n    current_tea = 'B'\n    current_count = 0\n\n    for i in range(n):\n        if current_tea == 'G':\n            green_tea[i] = True\n            current_tea = 'B'\n            current_count = 1\n        elif current_tea == 'B':\n            black_tea[i] = True\n            current_tea = 'G'\n            current_count += 1\n            if current_count > k:\n                current_tea = 'B'\n                current_count = 1\n        else:\n            return \"NO\"\n\n    result = [''] * n\n    for i in range(n):\n        if green_tea[i]:\n            result[i] = 'G'\n        elif black_tea[i]:\n            result[i] = 'B'\n        else:\n            return \"NO\"\n\n    return \"\".join(result)\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_next(tea_type: str, used_tea_bags: set, k: int) -> str:\n        for i in range(1, k+1):\n            if (tea_type + str(i)) not in used_tea_bags:\n                return tea_type + str(i)\n        return \"\"\n\n    n, k, green_tea_bags, black_tea_bags = map(int, stdin.split())\n    if n > green_tea_bags + black_tea_bags:\n        return \"NO\"\n\n    green_tea_bags_used = set()\n    black_tea_bags_used = set()\n    result = []\n    green_next = find_next(\"G\", green_tea_bags_used, k)\n    black_next = find_next(\"B\", black_tea_bags_used, k)\n    for _ in range(n):\n        if green_next:\n            result.append(green_next[0])\n            green_tea_bags_used.add(green_next)\n            green_next = find_next(\"G\", green_tea_bags_used, k)\n        else:\n            if black_next:\n                result.append(black_next[0])\n                black_tea_bags_used.add(black_next)\n                black_next = find_next(\"B\", black_tea_bags_used, k)\n            else:\n                return \"NO\"\n\n    return \"\".join(result)\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if k > n:\n        return \"NO\"\n    if a + b != n:\n        return \"NO\"\n    sequence = ['G'] * a + ['B'] * b\n    i = 0\n    while i < len(sequence):\n        if sequence[i] == 'G' and i + k < len(sequence) and sequence[i+k] == 'B':\n            sequence[i] = 'B'\n            sequence[i+k] = 'G'\n            i += k\n        i += 1\n    if len(sequence) < n:\n        return \"NO\"\n    return ''.join(sequence)\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a + b != n:\n        return \"NO\"\n\n    tea_bag_types = ['G'] * a + ['B'] * b\n    order = []\n\n    for i in range(n):\n        if len(tea_bag_types) == 0:\n            return \"NO\"\n\n        max_count = 0\n        max_type = None\n        for tea_bag_type in tea_bag_types:\n            current_count = 1\n            if i > 0 and tea_bag_types[i - 1] == tea_bag_type:\n                current_count += 1\n            while i + current_count < n and tea_bag_types[i + current_count] == tea_bag_type:\n                current_count += 1\n\n            if current_count > max_count:\n                max_count = current_count\n                max_type = tea_bag_type\n\n        if max_count > k:\n            return \"NO\"\n        order.append(max_type)\n        tea_bag_types = [tea_bag_type for tea_bag_type in tea_bag_types if tea_bag_type != max_type][:len(tea_bag_types) - max_count]\n\n    return ''.join(order)\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if a + b != n:\n        return \"NO\"\n    green_index = min(n - b, k)\n    black_index = min(n - green_index, k)\n    green_remain = n - green_index - black_index\n    black_remain = n - green_remain - black_index\n    result = \"G\" * green_index + \"B\" * black_index\n    if green_remain:\n        result += \"G\" * green_remain\n    if black_remain:\n        result += \"B\" * black_remain\n    return result\n\n\ninput_data = \"5 1 3 2\\n7 2 2 5\\n4 3 4 0\\n\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def can_drink(n: int, k: int, a: int, b: int) -> bool:\n        green_count = b\n        black_count = a\n        drinks = 0\n        last_drink = \"G\"\n\n        for _ in range(n):\n            if drinks >= k:\n                if last_drink == \"G\":\n                    drinks = 1\n                    last_drink = \"B\"\n                else:\n                    drinks = 0\n\n            if last_drink == \"G\":\n                green_count -= 1\n                if green_count < 0:\n                    return False\n            else:\n                black_count -= 1\n                if black_count < 0:\n                    return False\n\n            drinks += 1\n\n        return True\n\n    n, k, a, b = map(int, stdin.split())\n    if n > a + b:\n        return \"NO\"\n\n    if can_drink(n, k, a, b):\n        result = \"G\" * a + \"B\" * b\n        return result\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 809,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if k == 1 or a + b == n:\n        return ''.join(['G'] * a) + ''.join(['B'] * b)\n    return \"NO\"\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    count = 0\n\n    for i in range(1, n + 1):\n        if all(char in [str(a), str(b)] for char in str(i)):\n            digit_sum = sum(map(int, str(i)))\n            if all(char in [str(a), str(b)] for char in str(digit_sum)):\n                count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    def is_good(num: int) -> bool:\n        return str(num) == ''.join(str(a) if a <= num % 10 else str(b) for _ in range(len(str(num))))\n\n    def sum_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    count = 0\n    for num in range(1, 10**n):\n        if is_good(num):\n            count += 1 if sum_digits(num) <= n else 0\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    a, b, n = map(int, input_list)\n    mod = 10**9 + 7\n\n    def is_good(num: int) -> bool:\n        return str(num) == str(num).replace('0', '').replace('1', '').replace('2', '').replace('3', '').replace('4', '').replace('5', '').replace('6', '').replace('7', '').replace('8', '').replace('9', '')\n\n    def count_excellent_numbers(length: int) -> int:\n        if length == 1:\n            return 1\n        count = 0\n        for i in range(10):\n            if i == a or i == b:\n                count += count_excellent_numbers(length - 1)\n        return count % mod\n\n    result = count_excellent_numbers(n)\n    return str(result % mod)\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 10**9 + 7\n    def is_good(num: int) -> bool:\n        while num > 0:\n            digit = num % 10\n            if digit not in [a, b]:\n                return False\n            num //= 10\n        return True\n\n    def count_excellent_numbers(a: int, b: int, n: int) -> int:\n        count = 0\n        for num in range(10**(n-1), 10**n):\n            if is_good(num) and is_good(sum(int(digit) for digit in str(num))):\n                count += 1\n        return count\n\n    return str(count_excellent_numbers(a, b, n) % MOD)\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_excellent_numbers(a, b, n, MOD):\n        count = 0\n        for i in range(1, MOD):\n            num = i\n            sum_digits = 0\n            while num > 0:\n                digit = num % 10\n                if digit == a or digit == b:\n                    sum_digits += digit\n                num //= 10\n            if sum_digits < MOD:\n                count += sum_digits\n                count %= MOD\n        return count\n\n    return str(count_excellent_numbers(a, b, n, MOD))\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 1000000007\n    count = 0\n\n    for i in range(1, MOD):\n        if is_good(i, a, b):\n            count += 1\n\n    return count % MOD\n\ndef"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_excellent_numbers(a: int, b: int, n: int) -> int:\n        count = 0\n        for i in range(10):\n            if i < a:\n                continue\n            if i == a or i == b:\n                count += 1\n                continue\n            if i >= 10:\n                break\n            count += count_excellent_numbers(a, b, n - 1)\n        return count\n\n    result = count_excellent_numbers(a, b, n)\n    return str(result % MOD)\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    def count_excellent(length):\n        count = 0\n        if length == 1:\n            return 1\n        for i in range(1, b+1):\n            if str(i) == '0' or str(i) == '1':\n                continue\n            count += count_excellent(length-1)\n        return count % (10**9 + 7)\n    return count_excellent(n)"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    def is_good(num: int) -> bool:\n        return str(num) == ''.join(sorted(str(num), reverse=True))\n\n    def count_excellent(num: int) -> int:\n        count = 0\n        while num > 0:\n            digit = num % 10\n            if is_good(digit):\n                count += 1\n            num //= 10\n        return count\n\n    def count_excellent_numbers_of_length(n: int) -> int:\n        if n == 1:\n            return (b - a) * count_excellent(b) + (a - 1) * count_excellent(a - 1)\n        else:\n            return (b - a) * count_excellent_numbers_of_length(n - 1) + (a - 1) * count_excellent_numbers_of_length(n - 1)\n\n    return str((count_excellent_numbers_of_length(n) % (10**9 + 7)) + (10**9 + 7))\n"
    },
    {
        "number": 810,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    MOD = 1000000007\n    def is_good(num: int) -> bool:\n        return set(str(num)) == {\"a\", \"b\"}\n\n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def count_excellent_numbers(n: int) -> int:\n        count = 0\n        for a1 in range(a, b + 1):\n            for a2 in range(a, b + 1):\n                for a3 in range(a, b + 1):\n                    num = a1 * 100 + a2 * 10 + a3\n                    if is_good(num) and digit_sum(num) % MOD == 0:\n                        count += digit_sum(num) // MOD\n        return count % MOD\n\n    result = count_excellent_numbers(n)\n    return str(result)\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    while a >= 2 * b:\n        a -= 2 * b\n        hours += b\n    hours += a // 2\n    return hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    return (a // b) * 2 + 1"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    result = 0\n    while a > 0:\n        a -= b\n        result += 1\n    return str(result)"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_hours = 0\n    new_candles = a\n    while new_candles >= b:\n        new_candles = new_candles // b * (b + 1) + new_candles % b\n        total_hours += new_candles // b\n        new_candles %= b\n    return total_hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_hours = 0\n    \n    while a > 0 and b > 0:\n        total_hours += 1\n        if a > b:\n            a -= b\n        else:\n            b -= a\n            total_hours += 1\n    \n    return total_hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    while a > 0:\n        a -= b\n        hours += 1\n        a -= 1\n        a += a // 2\n    return str(hours)\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    hours = 2 * a + b\n    return hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = a + 2 * (a // b) + 4 * ((a // b) ** 2)\n    return hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = a + (a // b) * 2\n    return hours\n"
    },
    {
        "number": 811,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    candles = a\n    while candles >= b:\n        candles -= b\n        candles += 1\n        candles -= 1  # burn one candle\n        hours += 1\n    return str(hours)\n"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    b = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_arithmetic_progression(seq):\n        c = seq[1] - seq[0]\n        return all(seq[i] - seq[i - 1] == c for i in range(1, len(seq)))\n\n    for j in range(n):\n        if is_arithmetic_progression(b[:j] + b[j + 1:]):\n            return str(j + 1)\n\n    return \"-1\"\n"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n\n    for j in range(n):\n        a = [b[k] - b[j] for k in range(n) if k != j]\n        if is_arithmetic_progression(a):\n            return str(j + 1)\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    b = list(map(int, stdin[1].split()))\n    \n    for j in range(1, n):\n        c = (b[j] - b[j-1]) / (j - (j-1))\n        found = True\n        for i in range(j+1, n):\n            if (b[i] - b[j-1]) / (i - (j-1)) != c:\n                found = False\n                break\n        if found:\n            return str(j)\n    return \"-1\"\n"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    c = (b[1] - b[0]) // (n - 1)\n\n    for i in range(1, n):\n        if (b[i] - b[0]) % c != 0:\n            continue\n        j = (b[i] - b[0]) // c\n        if j == i:\n            return i\n\n    return -1\n"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n    c = b[1] - b[0]\n    for i in range(2, n):\n        if b[i] - b[i-1] != c:\n            return -1\n    for j in range(1, n):\n        if b[j] - b[0] == j*c:\n            return j\n    return -1\n\n\ninput_data = \"\"\"5\n2 6 8 7 4\n8\n1 2 3 4 5 6 7 8\n4\n1 2 4 8\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split('\\n')[0].split())\n    b = list(map(int, stdin.split('\\n')[1].split()))\n    \n    for j in range(1, n):\n        c = (b[j] - b[0]) // (j - 1)\n        if all(b[i] == b[0] + c * (i - 1) for i in range(1, n)):\n            return j\n    \n    return -1"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    b = list(map(int, stdin[1].split()))\n    \n    for j in range(n):\n        a = []\n        c = b[j]\n        for i in range(n-1):\n            a.append(c + i*(b[j]-c))\n        if is_arithmetic_progression(a):\n            return str(j+1)\n    \n    return \"-1\"\n\ndef"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n\n    for j in range(n):\n        if j > 0 and j < n - 1:\n            c = b[j] - b[j - 1]\n            arithmetic_progression = all(b[i] == b[0] + c * (i - 1) for i in range(1, n))\n            if arithmetic_progression:\n                return str(j + 1)\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    b = list(map(int, input().split()))\n    for j in range(1, n):\n        if n % 2 == 0:\n            a = (b[j-1] + b[j+1]) // 2\n            if (b[j] - a) % 2 == 0:\n                c = (b[j] - a) // 2\n                if (c * (n - 1)) % n == 0:\n                    return str(j)\n        elif n % 2 == 1:\n            a = (b[j-1] + b[j+1]) // 2\n            if (b[j] - a) % 2 == 1:\n                c = (b[j] - a) // 2\n                if (c * (n - 1)) % n == 0:\n                    return str(j)\n    return \"-1\"\n"
    },
    {
        "number": 812,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b = list(map(int, stdin.splitlines()[1].split()))\n\n    for j in range(1, n):\n        new_b = [b[i] for i in range(n) if i != j]\n        c = (b[j] - b[0]) // (j - 1)\n\n        if any(new_b[i] != b[0] + c * i for i in range(n - 1)):\n            continue\n\n        return str(j)\n\n    return \"-1\"\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, a, b = map(int, input_list[0].split())\n    arthur_likes = list(map(int, input_list[1].split()))\n    alexander_likes = list(map(int, input_list[2].split()))\n\n    arthur_apples = set(arthur_likes)\n    alexander_apples = set(alexander_likes)\n\n    result = []\n    for i in range(1, n + 1):\n        if i in arthur_apples:\n            result.append(1)\n        elif i in alexander_apples:\n            result.append(2)\n        else:\n            raise ValueError(\"Apple not in likes of anyone\")\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, a, b = map(int, input_list[0].split())\n    ar_likes = sorted(map(int, input_list[1].split()))\n    al_likes = sorted(map(int, input_list[2].split()))\n\n    output = []\n    for i in range(1, n+1):\n        if i in ar_likes:\n            output.append(1)\n        elif i in al_likes:\n            output.append(2)\n        else:\n            raise ValueError(\"Invalid input. Pasha's hamsters do not like this apple.\")\n\n    return ''.join(map(str, output))\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    ar_likes = set(map(int, stdin.split()[3:3+a]))\n    al_likes = set(map(int, stdin.split()[3+a:]))\n    \n    result = []\n    for i in range(1, n+1):\n        if i in ar_likes:\n            result.append(1)\n        elif i in al_likes:\n            result.append(2)\n        else:\n            result.append(0)\n    \n    return ''.join(map(str, result))\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, apples_arthur, apples_alexander = map(int, input().split())\n    apples_arthur = set(map(int, input().split()))\n    apples_alexander = set(map(int, input().split()))\n    \n    result = []\n    for i in range(1, n+1):\n        if i in apples_arthur:\n            result.append(1)\n        elif i in apples_alexander:\n            result.append(2)\n        else:\n            result.append(0)\n    \n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, input().split())\n    likes_arthur = set(map(int, input().split()))\n    likes_alexander = set(map(int, input().split()))\n\n    result = []\n    i = 1\n    while len(result) < n:\n        if i in likes_arthur and i in likes_alexander:\n            result.append(1)\n        elif i in likes_arthur:\n            result.append(1)\n        elif i in likes_alexander:\n            result.append(2)\n        i += 1\n\n    return \" \".join(map(str, result))\n\nstdin = \"\"\"4 2 3\n1 2\n2 3 4\"\"\"\n\nstdout = solution(stdin)\nprint(stdout) "
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_apple(hamster: list, apples: list) -> int:\n        for apple in hamster:\n            if apple in apples:\n                return apple\n        return -1\n\n    n, a, b = map(int, stdin.split()[:3])\n    arthur_apples = sorted(set(map(int, stdin.split()[3:3 + a])))\n    alexander_apples = sorted(set(map(int, stdin.split()[3 + a:])))\n\n    result = []\n    for i in range(1, n + 1):\n        arthur_apple = find_apple(arthur_apples, result)\n        alexander_apple = find_apple(alexander_apples, result)\n        if arthur_apple != -1 and alexander_apple != -1:\n            if arthur_apples.index(arthur_apple) < alexander_apples.index(alexander_apple):\n                result.append(1)\n            else:\n                result.append(2)\n        elif arthur_apple != -1:\n            result.append(1)\n        elif alexander_apple != -1:\n            result.append(2)\n        else:\n            result.append(0)\n\n    return ''.join(map(str, result))\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, a, b = map(int, input_data[0].split())\n    arthur_likes = sorted(map(int, input_data[1].split()))\n    alexander_likes = sorted(map(int, input_data[2].split()))\n\n    arthur_apples = [i for i in range(1, n + 1) if i in arthur_likes]\n    alexander_apples = [i for i in range(1, n + 1) if i in alexander_likes]\n\n    result = []\n    for i in range(1, n + 1):\n        if i in arthur_apples:\n            result.append(1)\n            arthur_apples.remove(i)\n        elif i in alexander_apples:\n            result.append(2)\n            alexander_apples.remove(i)\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    arthur_likes = sorted(map(int, stdin.splitlines()[1].split()))\n    alexander_likes = sorted(map(int, stdin.splitlines()[2].split()))\n\n    arthur_count = 0\n    alexander_count = 0\n    result = []\n\n    for i in range(1, n + 1):\n        if i in arthur_likes:\n            arthur_count += 1\n            result.append('1')\n        else:\n            alexander_count += 1\n            result.append('2')\n\n    # Check if Arthur and Alexander can get all the apples they like\n    if arthur_count < a or alexander_count < b:\n        return \"Impossible\"\n\n    return ''.join(result)\n"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, a, b = map(int, input_data[0].split())\n    arthur_apples = set(map(int, input_data[1].split()))\n    alexander_apples = set(map(int, input_data[2].split()))\n\n    result = ''\n    for i in range(1, n+1):\n        if i in arthur_apples and i in alexander_apples:\n            result += '1'\n        elif i in arthur_apples:\n            result += '2'\n        else:\n            result += '1'\n\n    return result\n\n\ndef"
    },
    {
        "number": 813,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, a, b = map(int, input_list[0].split())\n    a_likes = set(map(int, input_list[1].split()))\n    b_likes = set(map(int, input_list[2].split()))\n\n    result = []\n\n    for i in range(1, n + 1):\n        if i in a_likes:\n            result.append(1)\n        elif i in b_likes:\n            result.append(2)\n        else:\n            result.append(0)\n\n    return \" \".join(map(str, result))\n\ninput_str = \"\"\"4 2 3\n1 2\n2 3 4\"\"\"\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cubes = list(map(int, stdin.splitlines()[1].split()))\n    new_cubes = [0] * n\n    for i in range(n - 1):\n        new_cubes[i] = cubes[n - i - 2]\n    new_cubes[n - 1] = sum(cubes) - sum(new_cubes)\n    return ' '.join(map(str, new_cubes))\n\n\ninput_string = \"\"\"4\n3 2 1 2\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"3\n2 3 8\"\"\"\nprint(solution(input_string)) "
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.reverse()\n    result = []\n    for i in range(n):\n        result.append(sum(a))\n        a.pop()\n    result.reverse()\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    for i in range(n):\n        if i == 0:\n            continue\n        a[i] += a[i-1]\n        \n    print(*a)\n    \n    return \"Case #1:\\n\" + \" \".join(map(str, a))"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.reverse()\n\n    for i in range(n-1):\n        a[i] += a[i+1]\n        a[i+1] = 0\n\n    a.reverse()\n\n    return ' '.join(map(str, a))"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    columns = list(map(int, stdin.splitlines()[1].split()))\n    new_columns = [0] * n\n    for col in range(n):\n        new_columns[col] = columns[-1] - (n - col - 1)\n    print(*new_columns)\n    return \" \".join(map(str, new_columns))"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    toy_cubes = list(map(int, stdin.splitlines()[1].split()))\n    for i in range(n):\n        toy_cubes.append(toy_cubes.pop(0))\n    result = ' '.join(map(str, toy_cubes))\n    return result\n"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cubes_per_column = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Find the new positions of the cubes after the gravity switch\n    new_positions = []\n    for i in range(n):\n        new_positions.append(n - i - 1)\n\n    # Find the amounts of cubes in each column after the gravity switch\n    new_cubes_per_column = [0] * n\n    for i in range(n):\n        new_cubes_per_column[new_positions[i]] = cubes_per_column[i]\n\n    # Output the amounts of cubes in each column after the gravity switch\n    return ' '.join(map(str, new_cubes_per_column))"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.reverse()\n    for i in range(n):\n        a[i] += i\n    a.reverse()\n    return ' '.join(map(str, a))\n\ndef"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = a[::-1]\n    return \" \".join(map(str, b))\n\ndef"
    },
    {
        "number": 814,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    a.reverse()\n    a = a[:n]\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if a[i] > 0:\n                result.append(a[i]-j)\n                a[i] -= 1\n                break\n    return ' '.join(map(str, result))\n\ninput_string = '''4\n3 2 1 2\n3\n2 3 8'''\n\noutput_string = '''1 2 2 3 \n2 3 8 3 2 1'''\n\ninput_list = input_string.split('\\n')\noutput_list = output_string.split('\\n')\n\nfor i in range(len(input_list)):\n    assert solution(input_list[i]) == output_list[i]\n\nprint(\"All test cases passed.\")\n"
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V_father, V_mother, V_son, V_Masha = map(int, stdin.split())\n\n    # define car sizes\n    car_father_size = max(V_father, V_mother, V_son)\n    car_mother_size = max(V_father, V_mother, V_son)\n    car_son_size = min(V_father, V_mother, V_son)\n\n    # check conditions\n    if car_father_size <= V_mother and 2 * car_father_size >= V_mother and car_mother_size <= V_son and 2 * car_mother_size >= V_son:\n        # check if Masha can climb into smallest car\n        if V_Masha >= car_son_size:\n            return f\"{car_father_size}\\n{car_mother_size}\\n{car_son_size}\"\n\n    return \"-1\" "
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    V = list(map(int, stdin.split()))\n    V_father, V_mother, V_son, V_masha = V\n\n    if V_mother <= 2 * V_son:\n        return -1\n\n    if V_father >= V_mother >= V_son:\n        return V_father, V_mother, V_son\n    elif V_father >= V_son >= V_mother:\n        return V_father, V_son, V_mother\n    else:\n        return V_son, V_father, V_mother\n\n\ndef"
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    father_bear_size, mother_bear_size, son_bear_size, masha_size = map(int, stdin.split())\n    possible_cars_sizes = []\n\n    if father_bear_size > mother_bear_size and father_bear_size > son_bear_size:\n        possible_cars_sizes.append(father_bear_size)\n        if mother_bear_size > son_bear_size:\n            possible_cars_sizes.append(mother_bear_size)\n            possible_cars_sizes.append(son_bear_size)\n        elif mother_bear_size < son_bear_size:\n            possible_cars_sizes.append(mother_bear_size)\n            possible_cars_sizes.append(father_bear_size)\n            possible_cars_sizes.append(son_bear_size)\n        else:\n            possible_cars_sizes.append(mother_bear_size)\n            possible_cars_sizes.append(father_bear_size)\n            possible_cars_sizes.append(son_bear_size)\n\n    if masha_size >= 2 * father_bear_size and masha_size >= 2 * mother_bear_size and masha_size >= 2 * son_bear_size:\n        if possible_cars_sizes:\n            return \" \".join(map(str, possible_cars_sizes))\n        else:\n            return \"-1\"\n    else:\n        return \"-1\" "
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    v_father, v_mother, v_son, masha = map(int, stdin.split())\n    cars = [v_father, v_mother, v_son]\n    cars.sort(reverse=True)\n    if cars[0] < 2 * masha:\n        return \"-1\"\n    for i in range(3):\n        if cars[i] > masha * 2:\n            return str(cars[0]) + \"\\n\" + str(cars[1]) + \"\\n\" + str(cars[2])\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    V = list(map(int, stdin.split()))\n\n    father_size = max(V[0], V[1] + 10, V[2] + 20)\n    mother_size = max(V[0], V[1] + 5, V[2] + 10)\n    son_size = max(V[0], V[1] + 2, V[2])\n\n    if father_size == V[0] and mother_size == V[1] + 5 and son_size == V[2] + 10:\n        return f\"{father_size}\\n{mother_size}\\n{son_size}\"\n    else:\n        return \"-1\"\n\n\nstdin = \"50 30 10 10\"\nprint(solution(stdin))\n\nstdin = \"100 50 10 21\"\nprint(solution(stdin)) "
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    V_1, V_2, V_3, Masha = map(int, stdin.split())\n\n    if Masha < 2 * V_1 or Masha < 2 * V_2 or Masha < 2 * V_3:\n        return \"-1\"\n\n    for i in range(V_3, V_2 + 1):\n        if Masha >= 2 * i:\n            return f\"{V_1}\\n{i}\\n{V_3}\"\n\n    return \"-1\""
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    V_1, V_2, V_3, V_m = map(int, stdin.split())\n    if V_1 > V_2 and V_2 <= V_3:\n        fb_car = V_1\n        mb_car = V_2\n        sb_car = V_3\n    elif V_2 > V_3 and V_3 <= V_1:\n        fb_car = V_2\n        mb_car = V_3\n        sb_car = V_1\n    elif V_3 > V_2 and V_2 <= V_1:\n        fb_car = V_3\n        mb_car = V_2\n        sb_car = V_1\n    else:\n        return \"-1\"\n\n    if V_m >= fb_car and V_m >= mb_car and V_m >= sb_car:\n        return fb_car, mb_car, sb_car\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    V_father, V_mother, V_son, V_Masha = map(int, input_data)\n\n    # Check if there is a solution\n    if V_Masha < 2 * V_son:\n        return \"-1\"\n\n    # Find the sizes of father bear's car, mother bear's car and son bear's car\n    father_car_size = V_father\n    mother_car_size = V_mother\n    son_car_size = V_son\n\n    return f\"{father_car_size}\\n{mother_car_size}\\n{son_car_size}\"\n"
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    father_bear, mother_bear, son_bear, masha = input_list\n\n    if masha >= 2 * father_bear and masha >= 2 * mother_bear:\n        return str(father_bear) + \"\\n\" + str(mother_bear) + \"\\n\" + str(son_bear)\n    else:\n        return \"-1\"\n\n\nstdin = \"50 30 10 10\"\nprint(solution(stdin))\n\nstdin = \"100 50 10 21\"\nprint(solution(stdin)) "
    },
    {
        "number": 815,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    father_bear, mother_bear, son_bear, masha = map(int, input_list)\n\n    if masha >= father_bear:\n        father_car = father_bear\n    else:\n        father_car = -1\n\n    if masha >= son_bear:\n        son_car = son_bear\n    else:\n        son_car = -1\n\n    if mother_bear >= father_car and mother_bear >= son_car:\n        mother_car = mother_bear\n    else:\n        mother_car = -1\n\n    result = [father_car, mother_car, son_car]\n\n    return ' '.join(map(str, result))\n\n\ninput_data = \"50 30 10 10\"\nprint(solution(input_data)) "
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n                \n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return count\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    array = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if array[i] ^ array[j] == x:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] ^ arr[j] == x:\n                count += 1\n                \n    return count\n\ndef"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) == x:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, x = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:]))\n\n    # Initialize count\n    count = 0\n\n    # Iterate over the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] ^ arr[j]) == x:\n                count += 1\n\n    # Output the count\n    return str(count)\n"
    },
    {
        "number": 816,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, x = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i] ^ a[j]) == x:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def remove_pair(s: str, i: int) -> str:\n        return s[:i] + s[i+2:]\n\n    def find_pairs(s: str) -> List[int]:\n        pairs = []\n        for i in range(len(s) - 1):\n            if s[i] == s[i+1]:\n                pairs.append(i)\n        return pairs\n\n    def process_suffix(s: str, suffix: str) -> str:\n        pairs = find_pairs(suffix)\n        for i in sorted(pairs, reverse=True):\n            suffix = remove_pair(suffix, i)\n        return suffix\n\n    s = stdin.strip()\n    suffixes = [s[i:] for i in range(len(s))]\n    suffixes.sort(key=lambda x: (len(x), x), reverse=True)\n\n    result = []\n    for suffix in suffixes:\n        processed_suffix = process_suffix(s, suffix)\n        if len(processed_suffix) > 10:\n            result.append(str(len(processed_suffix)))\n            result.append(processed_suffix[:5] + '...' + processed_suffix[-2:])\n        else:\n            result.append(str(len(processed_suffix)))\n            result.append(processed_suffix)\n\n    return '\\n'.join(result)"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_pair(s: str, i: int, j: int) -> bool:\n        return 0 <= i < len(s) - 1 and 0 <= j < len(s) - 1 and s[i] == s[j]\n\n    def remove_characters(s: str, pairs: set[tuple[int, int]]) -> str:\n        removed = set()\n        for i, j in pairs:\n            removed.add(i)\n            removed.add(j)\n        return ''.join([c for i, c in enumerate(s) if i not in removed])\n\n    s = stdin.strip()\n    n = len(s)\n    suffixes = [s[i:] for i in range(n)]\n    suffixes.sort(key=lambda x: (len(x), x))\n\n    for suffix in suffixes:\n        pairs = set()\n        for i in range(len(suffix) - 1):\n            if is_valid_pair(suffix, i, i + 1):\n                pairs.add((i, i + 1))\n        if not pairs:\n            continue\n\n        result = remove_characters(suffix, pairs)\n        if len(result) <= 10:\n            print(len(result), result)\n        else:\n            print(len(result), result[:5] + \"...\" + result[-2:])\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n\n    suffixes = []\n    for i in range(n):\n        suffixes.append(s[i:])\n\n    suffixes.sort(key=lambda x: x[::-1])\n\n    result = []\n    for suffix in suffixes:\n        pairs = []\n        i = 0\n        while i < len(suffix) - 1:\n            if suffix[i] == suffix[i + 1]:\n                pairs.append((i, i + 1))\n            i += 1\n        for pair in pairs:\n            suffix[pair[0]] = ''\n            suffix[pair[1]] = ''\n        result.append(''.join(suffix))\n\n    for i, suffix in enumerate(result):\n        if len(suffix) > 10:\n            result[i] = suffix[:5] + '...' + suffix[-2:]\n\n    return '\\n'.join(str(len(suffix)) + ' ' + suffix for suffix in result[::-1])\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def helper(s: str, i: int) -> str:\n        pairs = []\n        for j in range(i, len(s) - 1):\n            if s[j] == s[j + 1]:\n                pairs.append((j, j + 1))\n            else:\n                break\n        if len(pairs) > 0:\n            for pair in pairs:\n                s = s[:pair[0]] + s[pair[1] + 1:]\n        return s\n\n    def process_suffix(s: str, i: int) -> str:\n        s = helper(s, i)\n        if len(s) <= 10:\n            return s\n        else:\n            return s[:5] + \"...\" + s[-2:]\n\n    n = len(stdin)\n    suffixes = [stdin[i:] for i in range(n)]\n    suffixes.sort(key=len, reverse=True)\n\n    for suffix in suffixes:\n        print(len(suffix), process_suffix(suffix, 0))\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    suffixes = []\n    for i in range(len(s)):\n        suffixes.append(s[i:])\n    suffixes.sort(key=len, reverse=True)\n    \n    result = []\n    for suffix in suffixes:\n        i = 0\n        while i < len(suffix) - 1:\n            if suffix[i] != suffix[i+1]:\n                break\n            i += 1\n        result.append(suffix[:i])\n    \n    for i, answer in enumerate(result):\n        if len(answer) > 10:\n            answer = answer[:5] + \"...\" + answer[-2:]\n        print(len(answer), answer, end=\"\\n\" if i == len(result) - 1 else \"\\n\")\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    N = len(s)\n    ans = []\n    for i in range(N, 0, -1):\n        current_ans = ''.join(s[:i])\n        for j in range(i):\n            if s[j] == s[j+1]:\n                s = s[:j] + s[j+2:]\n                break\n        ans.append(current_ans)\n    return ans\n\n\ndef"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n == 0:\n        return \"0\\n\"\n    suffixes = [\"\"] * n\n    for i in range(n):\n        suffixes[i] = s[i:]\n    suffixes.sort()\n    answers = []\n    for suffix in suffixes:\n        pairs = []\n        for i in range(len(suffix) - 1):\n            if suffix[i] == suffix[i + 1]:\n                pairs.append((i, i + 1))\n        if len(pairs) > 0:\n            for pair in pairs:\n                suffix = suffix[:pair[0]] + suffix[pair[1] + 1:]\n        if len(suffix) > 0:\n            answers.append(suffix)\n    for i in range(len(answers)):\n        if len(answers[i]) > 10:\n            answers[i] = answers[i][:5] + \"...\" + answers[i][-2:]\n    return \"\\n\".join(str(len(answer)) + \" \" + answer for answer in answers)\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_pairs(s: str) -> List[Tuple[int, int]]:\n        pairs = []\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                pairs.append((i, i + 1))\n        return pairs\n\n    def remove_pairs(s: str, pairs: List[Tuple[int, int]]) -> str:\n        for i, j in pairs:\n            s = s[:i] + s[j + 1:]\n        return s\n\n    def process_suffix(s: str) -> str:\n        pairs = find_pairs(s)\n        if not pairs:\n            return \"\"\n        else:\n            return remove_pairs(s, pairs)\n\n    def process_string(s: str) -> List[str]:\n        suffixes = []\n        for i in range(len(s)):\n            suffixes.append(s[i:])\n        suffixes.sort(key=len, reverse=True)\n        return suffixes\n\n    def output(suffixes: List[str]) -> None:\n        for i, suffix in enumerate(suffixes):\n            answer = process_suffix(suffix)\n            if len(answer) > 10:\n                answer = answer[:5] + \"...\" + answer[-2:]\n            print(len(answer), answer)\n\n    suffixes = process_string(stdin)\n    output(suffixes)\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_pair(i: int, s: str) -> bool:\n        return 0 <= i < len(s) - 1 and s[i] == s[i + 1]\n\n    def get_answer(s: str, i: int) -> str:\n        return s[:i] + s[i + 1:]\n\n    def find_shortest_suffix(s: str) -> str:\n        for i in range(len(s) - 2, -1, -1):\n            if is_valid_pair(i, s):\n                return get_answer(s, i)\n        return \"\"\n\n    def find_shortest_suffixes(s: str) -> List[str]:\n        return sorted([find_shortest_suffix(s[i:]) for i in range(len(s))], key=len, reverse=True)\n\n    s = stdin.strip()\n    suffixes = find_shortest_suffixes(s)\n    answers = [suffix[:5] + \"...\" if len(suffix) > 10 else suffix for suffix in suffixes]\n    lengths = [len(suffix) for suffix in suffixes]\n\n    return \"\\n\".join([f\"{length} {answer}\" for length, answer in zip(lengths, answers)])\n"
    },
    {
        "number": 817,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    ans = []\n\n    for i in range(n - 1, 0, -1):\n        pairs = []\n        for j in range(i):\n            if s[j] == s[i]:\n                pairs.append((j, i))\n        if pairs:\n            for p in pairs:\n                s = s[:p[0]] + s[p[1] + 1:]\n            ans.append(s)\n            break\n\n    for i in range(n):\n        ans.append(s[i:])\n\n    for i in range(len(ans) - 1, -1, -1):\n        if len(ans[i]) == 0:\n            continue\n        if len(ans[i]) > 10:\n            print(ans[i][:5], \"...\", ans[i][-2:])\n        else:\n            print(ans[i])"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_number = n * 10**(n-1)\n    divisible_by_2 = (min_number - 1) // 2\n    divisible_by_3 = (min_number - 1) // 3\n    divisible_by_5 = (min_number - 1) // 5\n    divisible_by_7 = (min_number - 1) // 7\n    for i in range(2, 8):\n        divisible_by_i = (min_number - 1) // i\n        if divisible_by_2 > divisible_by_i or divisible_by_3 > divisible_by_i or divisible_by_5 > divisible_by_i or divisible_by_7 > divisible_by_i:\n            return \"-1\"\n    return str(min_number)\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    max_digit = 7  # max possible digit for any prime number from 2 to 7\n    max_num = max_digit ** n\n    # find the minimum number that is divisible by all primes\n    for i in range(2, max_num + 1):\n        is_divisible = True\n        for j in range(2, 8):\n            if i % j != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            return str(i)\n    return \"-1\"\n"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    n = int(stdin)\n    if n < 2:\n        return \"-1\"\n\n    for i in range(10**(n-1), 10**n):\n        if all(i % prime == 0 for prime in [2, 3, 5, 7]):\n            return str(i)\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n\n    # Find the largest possible number that is divisible by 2 and 3\n    max_num = 2 * 3 * 5 * 7\n    max_num = max_num * (10 ** (n - 1))\n\n    # Check if the number is divisible by 2, 3, 5 and 7\n    if max_num % 2 != 0 or max_num % 3 != 0 or max_num % 5 != 0 or max_num % 7 != 0:\n        return \"-1\"\n\n    return str(max_num)\n"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    limit = 10 ** n\n    min_num = limit\n    for i in range(2, 8):\n        for j in range(2, 8):\n            for k in range(2, 8):\n                for l in range(2, 8):\n                    num = i * j * k * l\n                    if num <= min_num and all(num % d == 0 for d in [2, 3, 5, 7]):\n                        min_num = num\n    return str(min_num) if min_num != limit else \"-1\"\n\n\ninput_str = input()\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    if n == 1:\n        return \"-1\"\n\n    max_number = 7 * 10 ** (n - 1)\n\n    for i in range(max_number, 7, -1):\n        if all(i % num == 0 for num in [2, 3, 5, 7]):\n            return str(i).rjust(n, '0')\n\n    return \"-1\"\n\n\ninput_str = input().strip()\nresult = solution(input_str)\nprint(result)<|im_sep|> "
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    if n == 1:\n        return \"-1\"\n    \n    max_prime = 7\n    max_num = 10**(n-1)\n    divisible_nums = []\n    \n    for num in range(max_num, 1, -1):\n        if all(num % i == 0 for i in range(2, max_prime+1)):\n            divisible_nums.append(num)\n            if len(divisible_nums) == max_prime:\n                break\n    \n    if not divisible_nums:\n        return \"-1\"\n    \n    return str(divisible_nums[-1])\n"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return -1\n    else:\n        for i in range(10 ** (n - 1), 10 ** n):\n            if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 or i % 7 == 0:\n                continue\n            else:\n                return str(i)\n        return -1\n\n\ndef"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 1 or n > 10**5:\n        return \"-1\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_divisible_by_primes(num: int) -> bool:\n        return num % 2 == 0 and num % 3 == 0 and num % 5 == 0 and num % 7 == 0\n\n    min_num = 10**(n-1) + 1\n    while not is_divisible_by_primes(min_num):\n        min_num += 1\n\n    if min_num > 10**n:\n        return \"-1\"\n\n    return str(min_num)\n"
    },
    {
        "number": 818,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 5:\n        return \"-1\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_num = 10 ** (n - 1)\n    for i in range(max_num, max_num * 10, 10):\n        if all(i % j == 0 for j in [2, 3, 5, 7]):\n            return str(i)\n    return \"-1\"\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Split the array into k non-empty subsegments\n    subsegments = [a[i:i+k] for i in range(0, len(a), k)]\n\n    # Compute the minimums on each subsegment\n    minimums = [min(subsegment) for subsegment in subsegments]\n\n    # Take the maximum integer over the k obtained minimums\n    return str(max(minimums))\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    if k == 1:\n        min_val = min(a)\n        return str(min_val)\n\n    subsegments = []\n    for i in range(k):\n        l, r = i + 1, n\n        subsegments.append((l, r))\n\n    min_vals = []\n    for l, r in subsegments:\n        min_vals.append(min(a[l-1:r]))\n\n    return str(max(min_vals))\n\n\ninput_stdin = \"\"\"5 2\n1 2 3 4 5\"\"\"\n\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    n, k = map(int, input_values[0].split())\n    a = list(map(int, input_values[1].split()))\n    subsegments = []\n    for i in range(k):\n        l = i * n // k + 1\n        r = (i + 1) * n // k\n        subsegments.append((l, r))\n\n    minimums = [min(a[l:r+1]) for l, r in subsegments]\n    return str(max(minimums))"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    minimums = []\n    left = 1\n    for right in range(n):\n        while a[right] - a[right - 1] == 1 and left < right:\n            left += 1\n        minimums.append(min(a[left-1:right+1]))\n        left = right + 1\n\n    result = max(minimums)\n    return str(result)\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    subsegments = []\n    for i in range(k):\n        subsegments.append(a[i * (n // k):(i + 1) * (n // k)])\n\n    minimums = [min(subsegment) for subsegment in subsegments]\n\n    return str(max(minimums))\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n\n    subsegments = []\n    start = 0\n\n    for i in range(k):\n        subsegments.append(a[start:])\n        start = len(a) - k + i\n\n    minimums = [min(subsegment) for subsegment in subsegments]\n\n    return str(max(minimums))\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, k = map(int, input_list[:2])\n    a = list(map(int, input_list[2:]))\n    \n    subsegments = [[] for _ in range(k)]\n    for i in a:\n        subsegments[i % k].append(i)\n    \n    minimums = [min(sub) for sub in subsegments]\n    \n    return str(max(minimums))\n"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:]))\n\n    if k > n or n > 10**5:\n        return \"Invalid input\"\n\n    min_val = float('inf')\n    for i in range(n - k + 1):\n        sub_arr = arr[i:i+k]\n        min_val = min(min_val, min(sub_arr))\n\n    return str(min_val)\n\ndef"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    \n    if k == 1:\n        return str(max(a))\n    \n    # Split the array into k subsegments\n    subsegments = [[] for _ in range(k)]\n    for i in range(n):\n        subsegments[i % k].append(a[i])\n    \n    minimums = [min(subsegment) for subsegment in subsegments]\n    \n    return str(max(minimums))"
    },
    {
        "number": 819,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    minimums = []\n    for i in range(k):\n        minimums.append(min(a[i:i+n//k]))\n\n    return max(minimums)\n\ndef"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    usb_sizes = list(map(int, input().split()))\n    \n    total_size = sum(usb_sizes)\n    if total_size < m:\n        return \"Impossible\"\n    else:\n        min_usb = m // total_size\n        remainder = m % total_size\n        for i in range(n):\n            if usb_sizes[i] <= remainder:\n                remainder -= usb_sizes[i]\n            else:\n                min_usb += 1\n                break\n        return min_usb"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    usb_sizes = []\n    \n    for _ in range(n):\n        usb_sizes.append(int(input()))\n        \n    usb_sizes.sort(reverse=True)\n    \n    num_of_drives = 0\n    \n    for size in usb_sizes:\n        if size >= m:\n            num_of_drives += 1\n            m = 0\n        else:\n            m -= size\n            \n    return num_of_drives + int(m > 0)\n\ninput_string = '''3\n5\n2\n1\n3\n'''\n\nprint(solution(input_string))\n\ninput_string = '''3\n6\n2\n3\n2\n'''\n\nprint(solution(input_string))\n\ninput_string = '''2\n5\n5\n10\n'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    m = int(stdin.split(\"\\n\")[1])\n    a = [int(x) for x in stdin.split(\"\\n\")[2:]]\n    \n    total_capacity = sum(a)\n    if total_capacity < m:\n        return \"Impossible\"\n    else:\n        return n\n\n\ndef"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    sizes = [int(x) for x in stdin.split('\\n')[2:]]\n    total_size = sum(sizes)\n    \n    if m <= total_size:\n        return 1\n    else:\n        return len([size for size in sizes if size <= m // n])\n\n\ndef"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    sizes = list(map(int, stdin.split()[2:]))\n    total_size = sum(sizes)\n    min_flash_drives = 0\n    \n    if total_size >= m:\n        for size in sizes:\n            if size >= m:\n                min_flash_drives += 1\n                m = 0\n            else:\n                m -= size\n        if m == 0:\n            min_flash_drives -= 1\n    else:\n        min_flash_drives = 1\n    \n    return str(min_flash_drives)\n"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    sizes = []\n    for _ in range(n):\n        sizes.append(int(input()))\n    total_size = sum(sizes)\n    if total_size >= m:\n        min_size = 1\n        for size in sizes:\n            min_size *= size // m\n        print(min_size)\n    else:\n        print(\"Impossible\")\n"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1:]))\n    \n    total_size = sum(a)\n    if total_size < m:\n        return \"Impossible\"\n    \n    result = 0\n    temp = 0\n    \n    for size in a:\n        temp += size\n        if temp >= m:\n            result += 1\n            temp = 0\n    \n    return result"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    total_capacity = sum(a)\n\n    if m <= total_capacity:\n        return 1\n    else:\n        if n == 1:\n            return 1\n        else:\n            min_flash_drives = n\n            while total_capacity < m:\n                total_capacity += a[0]\n                a.pop(0)\n                min_flash_drives -= 1\n            return min_flash_drives\n"
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, stdin.split()[n:]))\n    min_drives = 1\n    total_size = a[0]\n\n    for size in a[1:]:\n        if size > total_size:\n            min_drives += 1\n            total_size += size\n        else:\n            total_size += size\n\n    return min_drives\n\nn = int(input())\nm = int(input())\n\nprint(solution(stdin=input())) "
    },
    {
        "number": 820,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    sizes = list(map(int, stdin.split('\\n')[1:]))\n\n    min_drives = 1\n    current_drive_size = 0\n\n    for size in sizes:\n        if size + current_drive_size > m:\n            min_drives += 1\n            current_drive_size = size\n        else:\n            current_drive_size += size\n\n    return str(min_drives)\n"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    total_time = (s * (v_1 + v_2)) + max(v_1, v_2)\n    time_1 = total_time + t_1\n    time_2 = total_time + t_2\n\n    if time_1 < time_2:\n        return \"First\"\n    elif time_2 < time_1:\n        return \"Second\"\n    else:\n        return \"Friendship\"\n"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = max(t_1, t_2)\n    \n    if v_1 + t_1 <= v_2 + t_2:\n        return \"First\"\n    elif v_2 + t_2 <= v_1 + t_1:\n        return \"Second\"\n    else:\n        return \"Friendship\"\n\n\ndef"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = t_1 + t_2\n    t_overlap = max(0, t - v_1 - v_2)\n    t_overlap_1 = max(0, (t - v_1) - t_2)\n    t_overlap_2 = max(0, (t - v_2) - t_1)\n\n    if t_overlap == 0:\n        if t_overlap_1 <= 0:\n            return \"First\"\n        elif t_overlap_2 <= 0:\n            return \"Second\"\n        else:\n            return \"Friendship\"\n    else:\n        if t_overlap_1 <= 0:\n            return \"First\"\n        elif t_overlap_2 <= 0:\n            return \"Second\"\n        else:\n            return \"Friendship\"\n\ndef"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = t_1 + t_2\n\n    if t == 0:\n        return \"Friendship\"\n\n    t_total = v_1 * s / t_1 + v_2 * s / t_2\n\n    if t_total <= t:\n        return \"First\"\n    elif t_total > t:\n        return \"Second\""
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = t_1 + t_2\n    \n    if v_1 < v_2:\n        time_1 = (s * v_1) + t_1\n        time_2 = (s * v_2) + t_2\n    elif v_1 > v_2:\n        time_2 = (s * v_1) + t_1\n        time_1 = (s * v_2) + t_2\n    else:\n        time_1 = (s * v_1) + t_1\n        time_2 = (s * v_2) + t_2\n        \n    if time_1 < time_2 + t:\n        return \"First\"\n    elif time_2 < time_1 + t:\n        return \"Second\"\n    else:\n        return \"Friendship\"\n\n\nstdin = \"5 1 2 1 2\"\nprint(solution(stdin))\n\nstdin = \"3 3 1 1 1\"\nprint(solution(stdin))\n\nstdin = \"4 5 3 1 5\"\nprint(solution(stdin)) "
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t_sum = t_1 + t_2\n    s_1 = (s * v_1) / t_1\n    s_2 = (s * v_2) / t_2\n    \n    if t_sum == 0:\n        return \"Friendship\"\n    \n    time_diff = abs(s_1 - s_2) / t_sum\n    if time_diff > 1:\n        return \"Second\"\n    else:\n        return \"First\"\n\n\nstdin = \"5 1 2 1 2\"\nprint(solution(stdin))\n\nstdin = \"3 3 1 1 1\"\nprint(solution(stdin))\n\nstdin = \"4 5 3 1 5\"\nprint(solution(stdin)) "
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = v_1 * s / 1000 + t_1\n    t_2 += t_1\n    if t_2 < t:\n        return \"Second\"\n    elif t_2 > t:\n        return \"First\"\n    else:\n        return \"Friendship\""
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    total_time = s * max(v_1, v_2)\n    first_success = total_time + t_1\n    second_success = total_time + t_2\n\n    if first_success < second_success:\n        return \"First\"\n    elif first_success > second_success:\n        return \"Second\"\n    else:\n        return \"Friendship\"\n\n\ndef"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = v_1 * s / t_1 + v_2 * s / t_2\n    return \"First\" if t < t_1 else \"Second\" if t < t_1 + t_2 else \"Friendship\"\n"
    },
    {
        "number": 821,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    t = t_1 + t_2\n    t_max = max(v_1 * s + t_1, v_2 * s + t_2)\n    \n    if t_max <= t:\n        return \"First\"\n    elif t_max > t:\n        return \"Second\"\n    else:\n        return \"Friendship\"\n\n\ninput_data = \"5 1 2 1 2\"\nprint(solution(input_data))\n\ninput_data = \"3 3 1 1 1\"\nprint(solution(input_data))\n\ninput_data = \"4 5 3 1 5\"\nprint(solution(input_data)) "
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    # Calculate the minimum number of artists to be killed\n    artists_count = (z - 1) // m + 1\n    # Subtract the artists that will be in the room when Ilia calls\n    artists_to_kill = artists_count - (n - 1) // m - 1\n    return str(artists_to_kill)"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists = set(range(1, z+1, m))\n    calls = set(range(1, z+1, n))\n    return len(calls & artists)"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n\n    artists_per_minute = z // m\n    artists_to_kill = (n * artists_per_minute) - 1\n\n    return str(artists_to_kill)\n"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    count = z // m  # number of artists which come on time m\n    return count + z % m  # in case there are some minutes left"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    kills = (z - 1) // (2 * n) + 1\n    return str(kills)\n"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    return min(m * (z // n), m + (z % n))\n\n\ndef"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists = [i for i in range(1, z+1, m)]\n    calls = [i for i in range(1, z+1, n)]\n    intersections = set(artists).intersection(calls)\n    return min(max(artists), max(calls)) - len(intersections)\n\n\ninput_str = \"1 1 10\"\nprint(solution(input_str)) "
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists_per_minute = z // m\n    artists_to_kill = n * artists_per_minute\n    return str(artists_to_kill)\n\n\ninput_data = \"1 1 10\\n1 2 5\\n2 3 9\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    k = z // n  # number of calls per day\n    artists_count = 0\n    for i in range(1, k + 1):\n        artists_count += (i * m) // n\n    return artists_count\n"
    },
    {
        "number": 822,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    \n    min_artists_to_kill = 0\n    \n    for i in range(1, z + 1):\n        if i % n == 0 or (i % m == 0 and i % n != 0):\n            min_artists_to_kill += 1\n            \n    return min_artists_to_kill\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n    x_abs, y_abs = abs(x), abs(y)\n\n    # Calculate the number of segments required to reach (x, y)\n    segments_required = max(x_abs, y_abs)\n\n    # Loop through each segment\n    for i in range(segments_required):\n        # Calculate the length of each side of the spiral\n        side_length = 2 * i + 1\n\n        # Calculate the number of times we need to turn for this segment\n        segment_turns = 2 * i + 1\n\n        # If we are within the current segment, calculate the turns required for this segment\n        if x_abs <= side_length and y_abs <= side_length:\n            # Calculate the distance from the center of the current segment to (x, y)\n            distance_to_center = sqrt(x ** 2 + y ** 2)\n\n            # Calculate the number of times we need to turn for this segment\n            segment_turns = 2 * int(floor(distance_to_center))\n\n        turns += segment_turns\n\n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n\n    turns = 0\n    current_x, current_y = 0, 0\n\n    while current_x != x or current_y != y:\n        if abs(current_x) >= abs(current_y):\n            turns += 1\n            current_x += 1 if current_x < 0 else -1\n            current_y += 1\n        else:\n            turns += 1\n            current_y += 1 if current_y < 0 else -1\n            current_x += 1 if current_x < 0 else -1\n\n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 0 and y == 0:\n        return 0\n    turns = 0\n    while (x, y) != (0, 0):\n        if x == 0:\n            x = 1\n        elif y == 0:\n            y = 1\n        elif x < 0:\n            x += 1\n            y -= 1\n        elif y > 0:\n            x -= 1\n            y += 1\n        elif x > 0:\n            x -= 1\n            y += 1\n        else:\n            x += 1\n            y -= 1\n        turns += 1\n    return turns\n\n\ndef"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, input().split())\n    turns = 0\n    x_diff = abs(x)\n    y_diff = abs(y)\n\n    while x_diff != 0 and y_diff != 0:\n        if x_diff >= y_diff:\n            turns += x_diff // y_diff\n            x_diff = x_diff % y_diff\n        else:\n            turns += y_diff // x_diff\n            y_diff = y_diff % x_diff\n\n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n\n    while (x, y) != (0, 0):\n        if x > 0 and y > 0:\n            x -= 1\n            y -= 1\n        elif x < 0 and y < 0:\n            x += 1\n            y += 1\n        elif x > 0:\n            x -= 1\n            y += 1\n        else:\n            x += 1\n            y -= 1\n        turns += 1\n\n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n\n    # Calculate the number of turns\n    turns = 0\n    px, py = 0, 0\n    while px != x or py != y:\n        if px < x:\n            px += 1\n        elif px > x:\n            px -= 1\n        else:\n            if py < y:\n                py += 1\n            elif py > y:\n                py -= 1\n            else:\n                break\n        turns += 1\n\n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n    \n    while (x, y) != (0, 0):\n        if x > 0 and y > 0:\n            x -= 1\n            y -= 1\n            turns += 1\n        elif x < 0 and y < 0:\n            x += 1\n            y += 1\n            turns += 1\n        elif x > 0:\n            x -= 1\n            turns += 1\n        elif x < 0:\n            x += 1\n            turns += 1\n        elif y > 0:\n            y -= 1\n            turns += 1\n        else:\n            y += 1\n            turns += 1\n    \n    return str(turns)\n"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = 0\n\n    while x != 0 or y != 0:\n        if abs(x) > abs(y):\n            x = abs(x) - 1\n            turns += 1\n        elif abs(x) < abs(y):\n            y = abs(y) - 1\n            turns += 2\n        else:\n            x = y = 0\n            turns += 1\n\n    return str(turns)"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    turns = abs(x) + abs(y)\n    return str(turns // 2)\n\ndef"
    },
    {
        "number": 823,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    x = int(input_list[0])\n    y = int(input_list[1])\n\n    turns = abs(x) + abs(y)\n    if x > 0 and y > 0:\n        turns += 1\n    elif x < 0 and y > 0:\n        turns += 2\n    elif x < 0 and y < 0:\n        turns += 3\n    elif x > 0 and y < 0:\n        turns += 1\n\n    return str(turns)\n\n\ninput_string = \"0 0\\n1 0\\n0 1\\n-1 -1\"\noutput_string = \"\"\nfor line in input_string.split(\"\\n\"):\n    output_string += solution(line) + \"\\n\"\n\nprint(output_string)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_subsequence(subsequence: str) -> bool:\n        if len(subsequence) % 2 != 0:\n            return False\n        \n        first_half = subsequence[:len(subsequence) // 2]\n        last_half = subsequence[len(subsequence) // 2:]\n        \n        return first_half == \"(\" * (len(subsequence) // 2) and last_half == \")\" * (len(subsequence) // 2)\n\n    def count_distinct_rsbs(s: str) -> int:\n        subsequences = set()\n\n        for i in range(len(s) // 2 + 1):\n            for j in range(len(s) - 2 * i):\n                if is_valid_subsequence(s[i:i + j + 1]):\n                    subsequences.add(s[i:i + j + 1])\n\n        return len(subsequences) % (10**9 + 7)\n\n    return str(count_distinct_rsbs(stdin))\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(n: int) -> int:\n        MOD = 10**9 + 7\n        if n == 0 or n == 1:\n            return 0\n        if n % 2 == 1:\n            return 0\n        if n == 2:\n            return 1\n        dp = [0] * (n + 1)\n        dp[2] = 1\n        for i in range(4, n + 1, 2):\n            dp[i] = (i - 2) * dp[i - 2] + dp[i - 4]\n            dp[i] %= MOD\n        return dp[n]\n\n    n = len(stdin)\n    return count_subsequences(n)\n\n\ndef"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_sequence(sequence: str) -> bool:\n        if len(sequence) % 2 != 0 or sequence[len(sequence) // 2] != \"(\":\n            return False\n        stack = []\n        for bracket in sequence:\n            if bracket == \"(\":\n                stack.append(bracket)\n            elif bracket == \")\":\n                if not stack or stack.pop() != \"(\":\n                    return False\n        return not stack\n\n    def count_valid_ subsequences(sequence: str) -> int:\n        count = 0\n        for i in range(1, len(sequence) // 2 + 1):\n            for j in range(i, len(sequence) // 2 + 1):\n                subsequence = sequence[i - 1:j + 1]\n                if is_valid_sequence(subsequence):\n                    count += 1\n        return count\n\n    n = len(stdin)\n    mod = 10**9 + 7\n    answer = count_valid_subsequences(stdin)\n    return str(answer % mod)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_subsequence(subsequence: str) -> bool:\n        left_count, right_count = len(subsequence) // 2, len(subsequence) // 2\n        for char in subsequence:\n            if char == '(':\n                left_count -= 1\n            else:\n                right_count -= 1\n            if left_count < 0 or right_count < 0:\n                return False\n        return True\n\n    def count_valid_subsequences(sequence: str) -> int:\n        total_count = 0\n        subsequence_count = 1\n        for i in range(len(sequence)):\n            if sequence[i] == '(':\n                total_count += subsequence_count\n                subsequence_count += 1\n            else:\n                subsequence_count -= 1\n        return total_count % (10**9 + 7)\n\n    sequence = stdin.strip()\n    if len(sequence) % 2 == 1 or not sequence:\n        return 0\n    valid_subsequences = [s for s in (sequence[i:] for i in range(len(sequence))) if is_valid_subsequence(s)]\n    return count_valid_subsequences(valid_subsequences)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    \n    def count_rsbs(stdin: str) -> int:\n        n = len(stdin)\n        if n % 2 == 1:\n            return 0\n        \n        count = 1\n        for i in range(n // 2):\n            if stdin[i] == ')' and stdin[n // 2 + i] == '(':\n                count *= 2\n            else:\n                return 0\n        return count\n    \n    count = 0\n    for i in range(1, len(stdin)):\n        count += count_rsbs(stdin[:i]) * count_rsbs(stdin[i:])\n        count %= MOD\n    \n    return str(count)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_RSBS(subsequence: str) -> bool:\n        n = len(subsequence)\n        if n == 0 or n % 2 != 0:\n            return False\n        for i in range(n // 2):\n            if subsequence[i] != \"(\":\n                return False\n        for i in range(n // 2, n):\n            if subsequence[i] != \")\":\n                return False\n        return True\n\n    def count_RSBS_subsequences(sequence: str) -> int:\n        n = len(sequence)\n        count = 0\n        for i in range(n // 2 + 1):\n            subsequence = sequence[:i] + sequence[n // 2 - i:]\n            if is_RSBS(subsequence):\n                count += 1\n        return count\n\n    return count_RSBS_subsequences(stdin) % (10**9 + 7)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n\n    if n % 2 == 1:\n        return \"0\"\n\n    def is_valid_subseq(subseq: str) -> bool:\n        stack = []\n        for char in subseq:\n            if char == \"(\":\n                stack.append(char)\n            else:\n                if stack:\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n\n    def count_valid_subseq(subseq: str) -> int:\n        count = 1\n        for i in range(len(subseq)):\n            if subseq[i] == \"(\":\n                count += 1\n            else:\n                break\n        return count\n\n    valid_subseq = set()\n    for i in range(n):\n        for j in range(i + 1, n + 1, 2):\n            if is_valid_subseq(stdin[i:j]):\n                valid_subseq.add(stdin[i:j])\n\n    mod = 10**9 + 7\n    result = 0\n    for subseq in valid_subseq:\n        result += count_valid_subseq(subseq) * len(valid_subseq) % mod\n    return str(result % mod)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n\n    if n % 2 == 1 or n == 1:\n        return 0\n\n    count = 1\n    for i in range(n // 2):\n        if stdin[i] != '(':\n            return 0\n        if stdin[n - i - 1] != ')':\n            return 0\n        count = count * (i + 1) * (n - i - 1)\n\n    return count % (10**9 + 7)\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_RSBS(s: str) -> bool:\n        n = len(s)\n        if n % 2 != 0:\n            return False\n        for i in range(n // 2):\n            if s[i] != \"(\":\n                return False\n        for i in range(n // 2, n):\n            if s[i] != \")\":\n                return False\n        return True\n\n    def count_RSBS(s: str) -> int:\n        n = len(s)\n        mod = 10**9 + 7\n        dp = [1] * n\n        for i in range(n):\n            if not is_RSBS(s[:i] + s[i + 1:]):\n                continue\n            for j in range(i):\n                if is_RSBS(s[:j + 1] + s[i] + s[j + 2:i] + s[i + 1:]):\n                    dp[i] += dp[j]\n                    dp[i] %= mod\n        return dp[-1]\n\n    return str(count_RSBS(stdin))\n"
    },
    {
        "number": 824,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    mod = 10**9 + 7\n    \n    if n == 0 or n % 2 != 0:\n        return 0\n    \n    count = 0\n    \n    for i in range(1, n//2 + 1):\n        l_match = i\n        r_match = n - i\n        \n        for j in range(1, n//2 + 1):\n            k_match = n - j\n            l_bracket = min(l_match, k_match)\n            r_bracket = min(r_match, j)\n            \n            if all(stdin[i-1+x] == \"(\" for x in range(l_bracket)) and all(stdin[n-1-x] == \")\" for x in range(r_bracket)) and l_match + r_match == j + k_match:\n                count += 1\n                \n            l_match = min(l_match + 1, n - i)\n            r_match = min(r_match + 1, n - j)\n            \n    return count % mod\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    while N > 1:\n        for p in range(2, int(N**0.5) + 1):\n            while N % p == 0:\n                count += 1\n                N //= p\n                break\n        if N > 1:\n            count += 1\n            N = 1\n    return count\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    while N > 1:\n        for p in range(2, int(N**0.5)+1):\n            e = 0\n            while N % p**e == 0:\n                e += 1\n            if e > 0:\n                z = p**e\n                break\n        N //= z\n        count += 1\n    return str(count)\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    N = int(stdin.strip())\n    count = 0\n    while N > 1:\n        for p in range(2, int(N**0.5) + 1):\n            if is_prime(p) and N % p**2 == 0:\n                N //= p**2\n                count += 1\n                break\n        else:\n            N -= 1\n            count += 1\n    return count\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    while N > 1:\n        z = 2\n        while N % z != 0:\n            z += 1\n        N //= z\n        count += 1\n    return str(count)"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    max_count = 0\n    count = 0\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    for prime in primes:\n        e = 0\n        z = 1\n        while z <= N:\n            e += 1\n            z = prime ** e\n            if z > N:\n                e -= 1\n                break\n\n        if e > 0:\n            count += 1\n            N = N // z\n            max_count += 1\n\n    return str(max_count)\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    max_count = 0\n\n    while N > 1:\n        max_count += 1\n        z = 2\n        while N % z != 0:\n            z += 1\n        N //= z\n\n    return str(max_count)\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    max_count = 0\n    count = 0\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    \n    while N > 1:\n        for p in primes:\n            e = 1\n            while N % (p**e) == 0:\n                e += 1\n            if e > 1 and p**(e-1) <= N:\n                z = p**(e-1)\n                if all(z != i for i in range(1, count+1)):\n                    max_count = max(max_count, count+1)\n                    count += 1\n                    N //= z\n                    break\n        else:\n            break\n    \n    return str(max_count)\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    max_count = 0\n    count = 0\n\n    while N > 1:\n        for i in range(2, int(N**0.5) + 1):\n            if N % i == 0:\n                count += 1\n                break\n        max_count = max(max_count, count)\n        N //= i\n\n    return str(max_count)\n"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    max_count = 0\n\n    while N > 1:\n        z = 2\n        count = 0\n        while z <= N:\n            if is_prime(z) and N % z == 0:\n                count += 1\n                break\n            z += 1\n\n        if count == 0:\n            return max_count\n\n        N //= z\n        max_count += 1\n\n    return max_count\n\n\ndef"
    },
    {
        "number": 825,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    N = int(stdin)\n    count = 0\n    max_count = 0\n\n    while N > 1:\n        for i in range(2, int(N**0.5) + 1):\n            if is_prime(i) and N % i == 0:\n                z = i\n                break\n        N //= z\n        count += 1\n\n    max_count = count\n    return str(max_count)\n"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    # create a list of the logs available\n    logs = list(range(1, n+2))\n    \n    # calculate the minimum number of yen needed to buy the logs\n    min_yen = 0\n    for i in range(len(logs)):\n        for j in range(i+1, len(logs)):\n            if logs[i] + logs[j] == n+1:\n                min_yen = logs[i] + logs[j]\n                break\n        if min_yen > 0:\n            break\n    \n    return str(min_yen)"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    total_money = 0\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            total_money += i\n        else:\n            total_money += i - 1\n    return total_money\n"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    # Initialize the dp array with the base cases\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    # Fill the dp array\n    for i in range(2, n + 1):\n        dp[i] = float('inf')\n        for j in range(1, i):\n            dp[i] = min(dp[i], dp[j] + dp[i - j])\n\n    # Calculate the minimum amount of money needed\n    min_money = 0\n    for i in range(1, n + 1):\n        min_money += dp[i]\n\n    return min_money"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return n + 1\n\nprint(solution(input())) "
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_money = float('inf')\n    for i in range(1, n+1):\n        min_money = min(min_money, i)\n    return str(min_money)"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    dp = [0] * (n + 1)\n    dp[1] = 1  # Minimum money needed to get one log of length 1 is 1\n\n    for i in range(2, n + 1):\n        # Try to get logs of length i from logs of length 1, 2, ..., i-1\n        for j in range(1, i):\n            dp[i] = min(dp[i], dp[j] + dp[i - j])\n\n    return dp[n]  # The minimum amount of money needed to get n logs is dp[n]\n"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    min_cost = 0\n    \n    if n == 1:\n        min_cost = 1\n    elif n == 2:\n        min_cost = 2\n    elif n == 3:\n        min_cost = 3\n    else:\n        for i in range(4, n+1):\n            min_cost += i\n            \n    return str(min_cost)\n"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Create a list of the logs available in the shop\n    available_logs = [i for i in range(1, n + 2)]\n\n    # Create a list of the logs the customer wants\n    wanted_logs = [i for i in range(1, n + 1)]\n\n    # Initialize a variable to keep track of the minimum money needed\n    min_money = 0\n\n    # Iterate through the available logs\n    for log in available_logs:\n        # Check if the wanted logs can be obtained from the current available log\n        if all(w_log <= log for w_log in wanted_logs):\n            # If so, calculate the amount of money needed to obtain them\n            money_needed = sum(w_log for w_log in wanted_logs if w_log <= log)\n            # Update the minimum money needed\n            min_money = max(min_money, money_needed)\n\n    return str(min_money)"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    # Initialize a list to store the logs of length 1 to n+1\n    logs = [1] * (n+1)\n    \n    # Calculate the minimum amount of money needed to get the logs\n    min_money = sum(logs[:n+1])\n    \n    # Update the minimum amount of money needed\n    for i in range(n+1):\n        for j in range(i+1, n+1):\n            logs[i] = i + j\n            logs[j] = i + j\n            min_money = min(min_money, sum(logs[:n+1]))\n    \n    return min_money"
    },
    {
        "number": 826,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = i\n        for j in range(1, i):\n            dp[i] = min(dp[i], dp[j] + dp[i - j])\n\n    return dp[n]"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = stdin.split(\"\\n\")\n    N, T = int(N), T.encode('utf-8')\n\n    # Calculate the length of S\n    S_len = 10**10 * len(T)\n\n    # Initialize the number of occurrences\n    count = 0\n\n    # Iterate through the first S_len characters of S\n    for i in range(S_len - len(T) + 1):\n        # Check if the current substring matches T\n        if T == S[i:i+len(T)]:\n            count += 1\n\n    return count"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, T = stdin.split('\\n')\n    N = int(N)\n    T = T.replace('0', '').replace('1', '110')\n    S = '110' * (10**10)\n    count = S.count(T)\n    return count"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    T = stdin.split()[1]\n\n    S = \"110\" * (10**10)\n    T_count = S.count(T)\n\n    return str(T_count)\n"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    T = input_list[1]\n\n    S = \"110\" * (10 ** 10)\n\n    count = S.count(T)\n\n    return str(count)"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, T = stdin.split()\n    S = '1' * 10**10 + '0' * 10**10\n    count = S.count(T)\n    return str(count)\n\nN, T = input().split()\nresult = solution(N + '\\n' + T)\nprint(result) "
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, T = map(str, stdin.split())\n\n    # Convert T to binary\n    T_binary = bin(int(T, 2))[2:].zfill(len(T))\n\n    # Initialize count and S\n    count = 0\n    S = \"1\" * 10**10 + \"1011\" + \"0\" * (10**10 - len(T_binary))\n\n    # Count occurrences of T_binary in S\n    for i in range(len(S) - len(T_binary) + 1):\n        if S[i:i+len(T_binary)] == T_binary:\n            count += 1\n\n    return count"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(str, stdin.split())\n    T = ''.join(T)\n    count = 0\n    len_T = len(T)\n    len_S = 10 ** 10\n    for i in range(len_S - len_T + 1):\n        if S[i:i+len_T] == T:\n            count += 1\n    return str(count)\n\n\nS = '1' * (10**10)\nT = '1011'\nprint(solution(T))  # Output: 9999999999\n"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    T = stdin.split('\\n')[1]\n    S = '1' * 10**10\n    count = 0\n    i = 0\n    while i <= len(S) - N:\n        if S[i:i+N] == T:\n            count += 1\n        i += 1\n    return str(count)\n\n\ninput_str = \"\"\"4\n1011\"\"\"\n\nresult = solution(input_str)\nprint(result)  # Output: 9999999999 "
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, T = stdin.split(\"\\n\")\n    T = T.strip()\n    M = 10**10\n    S = M * \"110\"\n    count = 0\n    for i in range(len(S) - len(T) + 1):\n        if S[i:i+len(T)] == T:\n            count += 1\n    return str(count)"
    },
    {
        "number": 827,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split())\n    S = \"1\" * (10**10) + \"0\" * (10**10) + \"1\" * (10**10)\n    T = \"1\" * T + \"0\" * (N - T)\n    count = S.count(T)\n    return str(count)\n\n\ninput_str = \"4\\n1011\"\nprint(solution(input_str)) "
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    num_wrong_reports = 0\n\n    for i in range(n):\n        if i == s - 1:\n            num_wrong_reports += a[i]\n        else:\n            num_wrong_reports += a[i] // 2\n\n    return num_wrong_reports\n"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Count the number of workers with each number of superiors\n    count = [0] * (n + 1)\n    for x in a:\n        count[x] += 1\n\n    # Find the minimum number of workers with at least two superiors\n    min_count = n\n    for x in range(1, n):\n        if count[x] == 0:\n            min_count = min(min_count, 1)\n        elif count[x] == 1 and count[x + 1] > 0:\n            min_count = min(min_count, 2)\n        else:\n            min_count = min(min_count, 1)\n\n    return min_count\n\n\ninput_string = \"\"\"3 2\n2 0 2\"\"\"\nprint(solution(input_string))  # Output: 1\n\ninput_string = \"\"\"5 3\n1 0 0 4 1\"\"\"\nprint(solution(input_string))  # Output: 2 "
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_superiors(n: int, a: list, s: int) -> int:\n        chief_superiors = [0] * n\n        chief_superiors[s - 1] = 1\n\n        # Counting the number of superiors for each worker\n        for i in range(n):\n            for j in range(1, n+1):\n                if i + j < n:\n                    chief_superiors[i] += a[i+j]\n\n        # Counting the number of workers with more than 2 superiors\n        count = 0\n        for i in range(n):\n            if chief_superiors[i] > 2:\n                count += 1\n\n        return count\n\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    return count_superiors(n, a, s)\n"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            count += 1\n\n    return count"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    superiors = list(map(int, stdin.split()[2:]))\n    \n    min_wrkrs = n\n    for i in range(1, n+1):\n        if i != s:\n            if superiors[i-1] > 0:\n                min_wrkrs = min(min_wrkrs, superiors[i-1] + 1)\n    \n    return str(min_wrkrs)\n"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    count = 0\n    for i in range(n):\n        if a[i] > i + 1:\n            count += 1\n            if i == s - 1:\n                count += 1\n            else:\n                j = i + 1\n                while j <= i + a[i]:\n                    j = j + 1\n                if j <= n:\n                    count += 1\n    return str(count)\n\nn = int(input())\ns = int(input())\na = list(map(int, input().split()))\n\nprint(solution(str(n) + \" \" + str(s) + \" \" + \" \".join(map(str, a)))) "
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n, s = map(int, inputs[0].split())\n    a = list(map(int, inputs[1].split()))\n\n    def count_superiors(id: int) -> int:\n        count = 0\n        current_id = id\n        while current_id > 0:\n            count += a[current_id - 1]\n            current_id -= 1\n        return count\n\n    min_mistakes = float('inf')\n    for i in range(n):\n        count = count_superiors(i)\n        if i != s:\n            min_mistakes = min(min_mistakes, count)\n\n    return str(min_mistakes)"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Initialize a list to store the number of superiors (not only immediate)\n    # for each worker and the chief.\n    num_superiors = [0] * (n + 1)\n\n    # Iterate through the a list and add the number of superiors (not only immediate)\n    # to the corresponding worker.\n    for i in range(n):\n        if a[i] != 0:\n            num_superiors[i + 1] = a[i]\n\n    # Set the number of superiors (not only immediate) for the chief to 0.\n    num_superiors[s] = 0\n\n    # Iterate through the num_superiors list and count the number of workers with superiors (not only immediate).\n    count = 0\n    for i in range(1, n + 1):\n        if num_superiors[i] > 0:\n            count += 1\n\n    # Return the minimum number of workers that could make a mistake.\n    return count\n\n\ninput_str = \"\"\"3 2\n2 0 2\n5 3\n1 0 0 4 1\"\"\"\n\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_superiors(worker_id: int) -> int:\n        count = 0\n        current_worker = worker_id\n        while current_worker != -1:\n            count += 1\n            current_worker = superiors.get(current_worker, -1)\n        return count\n\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    superiors = {i: a[i - 1] for i in range(1, n + 1) if a[i - 1] != 0}\n    mistakes = [count_superiors(i) for i in range(1, n + 1) if count_superiors(i) != a[i - 1] and i != s]\n    return min(mistakes) if mistakes else 0\n"
    },
    {
        "number": 828,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Count the number of superiors for each worker\n    superiors = [0] * n\n    for i in range(1, n):\n        superiors[a[i-1]] += 1\n\n    # Count the number of workers with no immediate superiors\n    no_superiors = superiors.count(0)\n\n    # Count the number of workers with only one immediate superior\n    one_superior = sum(1 for x in superiors if x == 1)\n\n    # Count the number of workers with more than one immediate superior\n    more_superiors = n - no_superiors - one_superior\n\n    # The minimum number of workers that could make a mistake is the sum of those who have more than one immediate superior\n    return more_superiors\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    s = input()\n\n    good_strings = set()\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if '1' not in substring and '0' not in substring:\n                good_strings.add(substring)\n\n    k = len(good_strings)\n\n    return k, ' '.join(sorted(good_strings))\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin.split(\"\\n\")[1]\n    k = 1\n    ans = [s]\n\n    while True:\n        new_ans = []\n        for i in range(len(ans)):\n            if i == 0:\n                new_ans.append(ans[i][1:])\n            else:\n                new_ans.append(ans[i][:-1])\n            if new_ans[-1] and all(s != new_ans[-1] for s in ans[:-1]):\n                break\n        if not new_ans:\n            break\n        k += 1\n        ans = new_ans\n\n    return k, \" \".join(ans)\n\n\ndef"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    s = input_list[1]\n    \n    k = 1\n    s_k = \"\"\n    for i in range(n):\n        if s[i] == \"0\":\n            s_k += \"1\"\n        else:\n            s_k += \"0\"\n            k += 1\n            \n    return f\"{k}\\n{s_k}\""
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    s = input_list[1]\n\n    def is_good(sub_s):\n        count_zeros = sub_s.count('0')\n        count_ones = sub_s.count('1')\n        return count_zeros != count_ones\n\n    k = 1\n    while k < n:\n        if is_good(s[:k]):\n            k += 1\n        else:\n            break\n\n    s_list = [s[:k]]\n    while s[k:]:\n        for i in range(k, len(s)):\n            if is_good(s[:i+1]):\n                s_list.append(s[k:i+1])\n                k = i + 1\n                break\n            else:\n                continue\n\n    return len(s_list), ' '.join(s_list)\n\n\ndef"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str) -> bool:\n        return s.count('0') != s.count('1')\n\n    n = int(input())\n    s = input()\n\n    if is_good(s):\n        k = 1\n        result = s\n    else:\n        k = 1\n        i = 0\n        j = 1\n        while j <= n:\n            if is_good(s[i:j]):\n                j += 1\n            else:\n                k += 1\n                i = j\n                j = i + 1\n        result = [s[i:j] for i in range(0, n, k)]\n\n    return f\"{k}\\n{' '.join(result)}\"\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    \n    count = 0\n    while s:\n        if s[0] == '1':\n            count += 1\n        s = s[1:]\n    \n    count = max(count, len(s))\n    \n    output = '{} 1'.format(count)\n    return output\n\nprint(solution(input())) "
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    s = input_list[1]\n\n    def is_good(s: str) -> bool:\n        count_zero = s.count('0')\n        count_one = s.count('1')\n        return count_zero != count_one\n\n    k = 1\n    while k <= n:\n        if is_good(s[:k]):\n            k += 1\n        else:\n            break\n\n    result = []\n    for i in range(k):\n        result.append(s[:k])\n        s = s[k:]\n\n    return \"\\n\".join(map(str, [k] + result))\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_good(s: str) -> bool:\n        count_zero = 0\n        count_one = 0\n        for c in s:\n            if c == '0':\n                count_zero += 1\n            else:\n                count_one += 1\n        return count_zero != count_one\n\n    def make_good(s: str, start: int) -> str:\n        i = start\n        while i < len(s) and s[i] == '1':\n            i += 1\n        return s[:i]\n\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    if is_good(s):\n        return 1, s\n\n    good = []\n    for i in range(len(s)):\n        if is_good(make_good(s, i)):\n            good.append(make_good(s, i))\n\n    return len(good), ' '.join(good)\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    k = 1\n    s_1 = s[:n//2]\n    s_2 = s[n//2:]\n    while s_2 != \"\":\n        if s_1.count('0') != s_1.count('1') or s_2.count('0') != s_2.count('1'):\n            k += 1\n            s_1 = s[:n//k]\n            s_2 = s[n//k:]\n        else:\n            break\n    print(k)\n    print(s[:n//k], s[n//k:])\n\n\ninput_str = \"6\\n100011\"\nsolution(input_str)\n"
    },
    {
        "number": 829,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    s = input_list[1]\n\n    def is_good(sub: str) -> bool:\n        zero_count = sub.count('0')\n        one_count = sub.count('1')\n        return zero_count != one_count and len(set(sub)) == len(sub)\n\n    k = 1\n    s_k = ''\n    for i in range(n):\n        if is_good(s[i:]):\n            s_k = s[i:]\n            break\n\n    if k == 1 and not is_good(s_k):\n        k += 1\n        s_k = ''\n\n    if k == 1:\n        s_k = s_k[:1]\n\n    while len(s_k) > 1:\n        for i in range(1, len(s_k)):\n            if is_good(s_k[:i]) and is_good(s_k[i:]):\n                s_k = s_k[:i] + ' ' + s_k[i:]\n                k += 1\n                break\n        else:\n            break\n\n    return '\\n'.join([str(k), s_k])"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_instability(operations: list) -> int:\n        max_height = 0\n        min_height = 0\n        for i, j in operations:\n            max_height = max(max_height, heights[i - 1])\n            min_height = min(min_height, heights[j - 1])\n            heights[i - 1], heights[j - 1] = heights[j - 1], heights[i - 1]\n        max_height = max(max_height, *heights)\n        min_height = min(min_height, *heights)\n        return max_height - min_height\n\n    n, k = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:]))\n    operations = []\n    min_instability = float('inf')\n    min_operations = 0\n    for _ in range(k):\n        max_height = 0\n        max_tower = 0\n        for tower in range(1, n + 1):\n            if heights[tower - 1] > max_height:\n                max_height = heights[tower - 1]\n                max_tower = tower\n        heights[max_tower - 1] -= 1\n        operations.append((max_tower, max_tower))\n        for i in range(1, n + 1):\n            if heights[i - 1] > max_height:\n                operations.append((max_tower, i))\n                break\n        instability = get_min_instability(operations)\n        if instability < min_instability:\n            min_instability = instability\n            min_operations = len(operations)\n\n    return f\"{min_instability} {min_operations}\\n\" + '\\n'.join(f\"{i} {j}\" for i, j in operations)\n\n\ndef"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:]))\n\n    def instability(towers):\n        return max(towers) - min(towers)\n\n    def perform_operation(towers, i, j):\n        height = towers[i - 1] - 1\n        towers[i - 1] = height\n        towers[j - 1] += height\n\n    def get_min_instability(towers, k):\n        min_instability = float('inf')\n        operations = []\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i != j:\n                    new_towers = towers.copy()\n                    perform_operation(new_towers, i, j)\n                    instability_value = instability(new_towers)\n                    if instability_value < min_instability:\n                        min_instability = instability_value\n                        operations = [(i, j)]\n                    elif instability_value == min_instability:\n                        operations.append((i, j))\n                    if k == 1:\n                        return min_instability, len(operations)\n                    new_k = k - 1\n                    inst, m = get_min_instability(new_towers, new_k)\n                    if inst < min_instability:\n                        min_instability = inst\n                        operations = [(i, j)]\n                    elif inst == min_instability:\n                        operations.append((i, j))\n                    if m <= len(operations):\n                        return min_instability, len(operations)\n        return min_instability, len(operations)\n\n    instability_value, operations_count = get_min_instability(heights, k)\n    print(instability_value, operations_count)\n    for i, j in operations[:operations_count]:\n        print(i, j)\n"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:]))\n    \n    min_instability = float('inf')\n    min_sequence = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                instability = abs(heights[i] - heights[j])\n                if instability < min_instability:\n                    min_instability = instability\n                    min_sequence = [(i, j)]\n                elif instability == min_instability:\n                    min_sequence.append((i, j))\n    \n    output = [min_instability, len(min_sequence)]\n    \n    for i in range(k):\n        output.append(min_sequence[i][0] + 1)\n        output.append(min_sequence[i][1] + 1)\n    \n    return \" \".join(map(str, output))\n\n\nn = 5\nk = 3\nheights = [8, 2, 4, 6, 3]\n\nprint(solution(f\"{n} {k}\\n{' '.join(map(str, heights))}\")) "
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    heights = list(map(int, input_list[1].split()))\n\n    towers = [heights.pop(0)]\n    instability = 0\n    instabilities = []\n\n    for height in heights:\n        tower = [height]\n        tower_index = 0\n\n        while tower[0] > towers[-1][0]:\n            instability += 1\n            tower_index += 1\n            if tower_index == len(towers):\n                tower_index -= 1\n                break\n\n        towers.insert(tower_index + 1, tower[0])\n\n    instability += len(towers) - 1\n    instabilities.append(instability)\n\n    while k > 0:\n        if not towers:\n            break\n\n        min_index = 0\n        min_value = towers[0]\n\n        for i, tower in enumerate(towers):\n            if tower < min_value:\n                min_value = tower\n                min_index = i\n\n        towers.pop(min_index)\n        instability -= min_value\n        instabilities.append(instability)\n        k -= 1\n\n    min_instability = min(instabilities)\n    min_instability_index = instabilities.index(min_instability)\n\n    result = []\n    for i, instability in enumerate(instabilities):\n        if instability == min_instability:\n            result.append((i + 1, min_instability_index - i))\n\n    return \"\\n\".join([\" \".join(map(str, line)) for line in result]) "
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, k = map(int, input_lines[0].split())\n    towers = list(map(int, input_lines[1].split()))\n\n    def instability(towers):\n        return max(towers) - min(towers)\n\n    def move_top_cube(towers, from_tower, to_tower):\n        towers[from_tower - 1] -= 1\n        towers[to_tower - 1] += 1\n\n    def create_sequence(towers, k, sequence=None):\n        if sequence is None:\n            sequence = []\n        if len(sequence) == k:\n            return [sequence]\n        results = []\n        for i in range(n):\n            for j in range(n):\n                if i != j and towers[i] > 0 and towers[j] < 10000:\n                    new_towers = towers.copy()\n                    move_top_cube(new_towers, i + 1, j + 1)\n                    new_sequence = sequence.copy()\n                    new_sequence.append((i + 1, j + 1))\n                    results.extend(create_sequence(new_towers, k, new_sequence))\n        return results\n\n    sequences = create_sequence(towers, k)\n    min_instability = float('inf')\n    min_sequence = None\n    for sequence in sequences:\n        inst = sum(instability([towers[i - 1] - 1 for i, j in sequence]) for i, j in sequence)\n        if inst < min_instability:\n            min_instability = inst\n            min_sequence = sequence\n\n    result = f\"{min_instability} {len(min_sequence)}\"\n    for i, j in min_sequence:\n        result += f\"\\n{i} {j}\"\n    return result\n"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Find the minimum instability\n    min_instability = float('inf')\n    for i in range(1, n+1):\n        min_instability = min(min_instability, a[i-1])\n        \n    # Check if the minimum instability is 0\n    if min_instability == 0:\n        return '0 0'\n    \n    # Initialize the instability matrix\n    instability = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the instability matrix\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            instability[i-1][j-1] = abs(a[i-1] - a[j-1])\n    \n    # Initialize the minimum instability and the number of operations\n    min_instability = float('inf')\n    num_operations = 0\n    \n    # DP for finding the minimum instability\n    dp = [[float('inf') for _ in range(k+1)] for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 0\n    \n    for j in range(k+1):\n        dp[0][j] = 0\n    \n    for i in range(1, n):\n        for j in range(1, k+1):\n            for kk in range(1, n):\n                dp[i][j] = min(dp[i][j], dp[kk-1][j-1] + instability[i-1][kk-1])\n                \n            min_instability = min(min_instability, dp[i][j])\n            num_operations = j\n            \n    # Find the optimal sequence of operations\n    sequence = []\n    \n    while num_operations > 0:\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                if dp[i-1][num_operations] == dp[kk-1][j-1] + instability[i-1][kk-1]:\n                    sequence.append((i, j))\n                    break\n                \n            num_operations -= 1\n            if num_operations == 0:\n                break\n            \n    return f\"{min_instability} {len(sequence)}\" + \"\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in sequence)\n"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_instability(heights: list) -> int:\n        return max(heights) - min(heights)\n\n    def perform_operation(heights: list, operation: int) -> list:\n        i, j = operation\n        cube = heights[i - 1] - 1\n        heights[i - 1] -= 1\n        heights[j - 1] += cube\n        return heights\n\n    def find_min_instability(heights: list, k: int) -> int:\n        min_instability = float('inf')\n        min_operations = 0\n        for i in range(1, k + 1):\n            instability = count_instability(perform_operation(heights[:], [i, i]))\n            if instability < min_instability:\n                min_instability = instability\n                min_operations = i\n        return min_instability, min_operations\n\n    n, k = map(int, input().split())\n    heights = list(map(int, input().split()))\n\n    min_instability, min_operations = find_min_instability(heights, k)\n    print(min_instability, min_operations)\n\n    for i in range(1, min_operations + 1):\n        heights = perform_operation(heights, [i, i])\n        print(heights.index(min_instability) + 1, i)\n"
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    towers = list(map(int, input().split()))\n    heights = [0] * n\n    instabilities = []\n\n    for tower in towers:\n        heights[tower - 1] += 1\n\n    instability = max(heights) - min(heights)\n    instabilities.append(instability)\n\n    for _ in range(k):\n        max_instability = min(instabilities)\n        min_height = min(heights)\n        min_index = heights.index(min_height)\n\n        heights[min_index] = 0\n        instabilities.append(max_instability - min_height)\n\n    s = min(instabilities)\n    m = instabilities.index(s)\n    operations = [str(i + 1) for i in range(n) if s > 0]\n\n    return f\"{s} {m}\\n\" + \"\\n\".join([f\"{m} {x}\" for x in operations])\n\n\ninput_string = \"\"\"3 2\n5 8 5\n\"\"\"\nprint(solution(input_string))\n\n\ninput_string = \"\"\"3 4\n2 2 4\n\"\"\"\nprint(solution(input_string))\n\n\ninput_string = \"\"\"5 3\n8 3 2 6 3\n\"\"\"\nprint(solution(input_string)) "
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    towers = list(map(int, input().split()))\n\n    def is_instability_valid(towers, instability):\n        return all(towers[i] <= instability + 1 for i in range(n))\n\n    def get_min_instability_and_operations(towers, k, operations):\n        min_instability = max(towers)\n        min_instability_count = 0\n\n        while operations > 0:\n            for i in range(n):\n                for j in range(n):\n                    if i != j and is_instability_valid(towers, max(towers) - towers[i]):\n                        towers[i] -= 1\n                        towers[j] += 1\n                        operations -= 1\n                        if operations == 0:\n                            min_instability = max(min_instability, max(towers))\n                            min_instability_count += 1\n                            break\n                if operations == 0:\n                    break\n            if operations > 0:\n                min_instability = max(min_instability, max(towers))\n                min_instability_count += 1\n                operations = k\n\n        return min_instability, min_instability_count\n\n    min_instability, min_instability_count = get_min_instability_and_operations(towers, k, k)\n\n    result = f\"{min_instability} {min_instability_count}\\n\"\n    operations = k\n\n    while operations > 0:\n        for i in range(n):\n            for j in range(n):\n                if i != j and is_instability_valid(towers, max(towers) - towers[i]):\n                    towers[i] -= 1\n                    towers[j] += 1\n                    result += f\"{i + 1} {j + 1}\\n\"\n                    operations -= 1\n                    if operations == 0:\n                        break\n            if operations == 0:\n                break\n        if operations > 0:\n            operations = k\n\n    return result\n\n\ninput_stdin = \"\"\"3 2\n5 8 5\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 830,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    towers = list(map(int, stdin.split()[1].split()))\n    \n    # Compute the instability of the initial set of towers\n    instability = max(towers) - min(towers)\n    \n    # Compute the maximum number of operations that can be performed\n    max_ops = k\n    \n    # If the maximum number of operations is less than the number of towers, then we can't perform the required operations\n    if max_ops < n:\n        return f\"{instability} 0\"\n    \n    # Compute the maximum instability that can be achieved\n    max_instability = 0\n    \n    # Compute the minimum number of operations needed to achieve the maximum instability\n    min_ops = 0\n    \n    # Perform the required operations to achieve the maximum instability\n    for i in range(n):\n        # Find the tower with the maximum height\n        max_height_tower = i\n        for j in range(i+1, n):\n            if towers[j] > towers[max_height_tower]:\n                max_height_tower = j\n        \n        # Find the tower with the minimum height\n        min_height_tower = i\n        for j in range(i+1, n):\n            if towers[j] < towers[min_height_tower]:\n                min_height_tower = j\n        \n        # Compute the new instability after the operation\n        new_instability = max(towers) - min(towers) - towers[max_height_tower] + towers[min_height_tower]\n        \n        # If the new instability is greater than the current maximum, update the maximum instability and the minimum number of operations\n        if new_instability > max_instability:\n            max_instability = new_instability\n            min_ops = 1\n        # If the new instability is equal to the current maximum, update the minimum number of operations\n        elif new_instability == max_instability:\n            min_ops += 1\n        \n        # Perform the operation\n        towers[max_height_tower] -= 1\n        towers[min_height_tower] += 1\n    \n    # Return the minimum instability and the minimum number of operations\n    return f\"{max_instability} {min_ops}\" "
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = input().split()\n    n = int(n)\n    s = []\n    a = []\n    for i in range(n):\n        s_i, a_i = input().split()\n        s.append(s_i)\n        a.append(int(a_i))\n\n    dp = [float('inf')] * (len(t) + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        for j in range(len(s[i])):\n            for k in range(len(t) + 1):\n                if k >= j + 1 and k < len(t) + 1 and t[k - 1] == s[i][j]:\n                    dp[k] = min(dp[k], dp[k - 1] + i + 1)\n\n    result = dp[len(t)] if dp[len(t)] != float('inf') else -1\n\n    return str(result)"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t, n = input().split()\n    n = int(n)\n    s = []\n    a = []\n\n    for _ in range(n):\n        s_i, a_i = input().split()\n        s.append(s_i)\n        a.append(int(a_i))\n\n    def count_operations(t: str, s: list, a: list) -> int:\n        total_operations = 0\n        for i, (t_i, a_i) in enumerate(zip(t, a)):\n            if t_i in s[i]:\n                total_operations += s.index(t_i) + 1\n                s[i] = s[i].replace(t_i, '', 1)\n        return total_operations\n\n    def min_money(t: str, s: list, a: list) -> int:\n        if not any(t_i in s_i for s_i in s):\n            return -1\n\n        operations = count_operations(t, s, a)\n        if operations <= |t|:\n            return operations * (len(t) - operations)\n        else:\n            return -1\n\n    return str(min_money(t, s, a))\n"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = input()\n    n = int(input())\n    max_cost = 0\n    for i in range(n):\n        s, a = input().split()\n        a = int(a)\n        cost = i + a\n        if s in t:\n            max_cost = max(max_cost, cost)\n    if max_cost == 0:\n        return -1\n    else:\n        return sum(range(max_cost + 1))\n"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = input()\n    n = int(input())\n\n    s = []\n    a = []\n    for i in range(n):\n        line = input().split()\n        s.append(line[0])\n        a.append(int(line[1]))\n\n    result = 0\n    for i in range(n):\n        if s[i] in t:\n            if a[i] == 0:\n                result += i + 1\n                t = t.replace(s[i], \"\", 1)\n            else:\n                count = min(a[i], t.count(s[i]))\n                result += count * (i + 1)\n                t = t.replace(s[i], \"\", count)\n\n    if result == len(t):\n        return str(result)\n    else:\n        return \"-1\""
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t, n = input(stdin).split()\n    n = int(n)\n    s = []\n    a = []\n\n    for i in range(n):\n        s_i, a_i = input().split()\n        s.append(s_i)\n        a.append(int(a_i))\n\n    if len(t) > sum(a):\n        return -1\n\n    operations = 0\n    for i in range(n):\n        for j in range(len(s[i])):\n            if len(t) == operations:\n                break\n            if s[i][j] == t[operations]:\n                operations += 1\n                s[i] = s[i].replace(s[i][j], '', 1)\n                if len(s[i]) > a[i]:\n                    return -1\n                else:\n                    return operations * (i + 1)"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    t = input_data[0]\n    n = int(input_data[1])\n    s = []\n    a = []\n    for i in range(2, 2 + n):\n        s.append(input_data[i].split()[0])\n        a.append(int(input_data[i].split()[1]))\n\n    if len(t) > sum(a):\n        return -1\n\n    rubles = 0\n    for char in t:\n        min_price = float('inf')\n        for i in range(n):\n            if s[i].count(char) > 0 and s[i].count(char) <= a[i] and a[i] > 0:\n                min_price = min(min_price, i + 1)\n        rubles += min_price\n        s = [s[i].replace(char, '', 1) for i in range(n)]\n\n    return rubles\n"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t, n = input(stdin).split()\n    n = int(n)\n    s_info = [input().split() for _ in range(n)]\n\n    def is_valid(s: str, a: int, char: str) -> bool:\n        if s.count(char) <= a:\n            return True\n        return False\n\n    def get_price(s: str, char: str) -> int:\n        return s.index(char) + 1\n\n    min_price = float('inf')\n\n    for i in range(n):\n        s, a = s_info[i]\n        a = int(a)\n        for char in set(s):\n            if is_valid(s, a, char):\n                price = get_price(s, char) * (i + 1)\n                if price < min_price:\n                    min_price = price\n\n    if min_price == float('inf'):\n        return -1\n\n    return min_price\n"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = input()\n    n = int(input())\n    s = []\n    a = []\n    \n    for _ in range(n):\n        s_i, a_i = map(int, input().split())\n        s.append(s_i)\n        a.append(a_i)\n\n    dp = [float('inf')] * (len(t) + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        for j in range(len(s[i])):\n            if dp[j] != float('inf') and dp[j+1] > dp[j] + (i+1):\n                dp[j+1] = dp[j] + (i+1)\n\n    for i in range(1, len(t)+1):\n        for j in range(len(s[i-1])):\n            if dp[j] != float('inf') and dp[j+1] > dp[j] + dp[i]:\n                dp[j+1] = dp[j] + dp[i]\n\n    return dp[-1] if dp[-1] != float('inf') else -1\n\n\nstdin = '''\nabacaba\n4\naba 2\nbcc 1\ncaa 2\nbbb 5\n'''\nprint(solution(stdin)) "
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = input()\n    n = int(input())\n    s_a = {}\n\n    for i in range(n):\n        s, a = input().split()\n        s_a[s] = a\n\n    def cost(s):\n        return s.index(t) + 1\n\n    def remove_char(s):\n        if s in s_a and s_a[s] > 0:\n            s_a[s] -= 1\n            return True\n        return False\n\n    money = 0\n    for char in t:\n        for s in s_a.keys():\n            if char in s and remove_char(s):\n                money += cost(s)\n                break\n\n    return money if money > 0 else -1\n"
    },
    {
        "number": 831,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t, n = input(stdin).split()\n    n = int(n)\n    s = {}\n    for i in range(n):\n        s[i], a = input().split()\n        s[i] = list(s[i])\n        a = int(a)\n        s[i].sort()\n        s[i] = s[i][:a]\n    operations = []\n    for i in range(n):\n        for char in s[i]:\n            operations.append((char, i + 1))\n    operations.sort(key=lambda x: x[1])\n    dp = [0] * (len(t) + 1)\n    for char, rubles in operations:\n        for i in range(len(t)):\n            if t[i:i + len(char)] == char:\n                dp[i + len(char)] = max(dp[i + len(char)], dp[i] + rubles)\n    if dp[len(t)] > 0:\n        return str(dp[len(t)])\n    else:\n        return \"-1\"\n\ninput_string = \"\"\"bbaze\n3\nbzb 2\naeb 3\nba 10\"\"\"\n\nprint(solution(input_string))"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    teams = [tuple(map(int, line.strip().split())) for line in stdin[1:]]\n\n    uniforms = {}\n    for i, (h, a) in enumerate(teams):\n        uniforms[i] = (h, a)\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                host_team = i\n                guest_team = j\n                host_uniform, guest_uniform = uniforms[host_team]\n                if host_uniform == uniforms[guest_team][1]:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    h_colors = [int(color) for color in stdin[1].split()]\n    a_colors = [int(color) for color in stdin[2].split()]\n\n    num_guest_uniform = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and h_colors[i] == a_colors[j]:\n                num_guest_uniform += 1\n\n    return str(num_guest_uniform)\n\n\ninput_str = \"3\\n1 2\\n2 4\\n3 4\"\noutput = solution(input_str.split('\\n'))\nprint(output) "
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    uniforms = []\n    count = 0\n\n    for line in stdin.splitlines()[1:]:\n        h, a = map(int, line.split())\n        uniforms.append((h, a))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                h1, a1 = uniforms[i]\n                h2, a2 = uniforms[j]\n                if h1 == a2 or h2 == a1:\n                    count += 1\n\n    return count\n\n\nstdin = \"\"\"\n3\n1 2\n2 4\n3 4\n\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"\n4\n100 42\n42 100\n5 42\n100 5\n\"\"\"\n\nprint(solution(stdin))\n\n\nstdin = \"\"\"\n2\n1 2\n1 2\n\"\"\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    team_colors = {}\n    for i in range(n):\n        home, guest = map(int, stdin.split())\n        team_colors[i+1] = (home, guest)\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if team_colors[i+1][0] == team_colors[j+1][1]:\n                count += 1\n                \n    return str(count)\n\n\nn = int(input())\nfor i in range(n):\n    home, guest = map(int, input().split())\n    team_colors[i+1] = (home, guest)\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if team_colors[i+1][0] == team_colors[j+1][1]:\n            count += 1\n\nprint(count) "
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list.pop(0))\n    count = 0\n    for line in input_list:\n        team1, team2 = map(int, line.split())\n        if team1 == team2:\n            count += n - 1\n        else:\n            count += 2\n    return str(count)\n"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    uniforms = [tuple(map(int, line.split())) for line in stdin[1:]]\n    count = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if i < j:\n                    host_i = i\n                    host_j = j\n                else:\n                    host_i = j\n                    host_j = i\n                \n                home_i = uniforms[host_i][0]\n                home_j = uniforms[host_j][0]\n                guest_i = uniforms[host_i][1]\n                guest_j = uniforms[host_j][1]\n                \n                if home_i == guest_j or home_j == guest_i:\n                    count += 1\n                    \n    return str(count)\n\ninput_data = \"\"\"3\n1 2\n2 4\n3 4\"\"\"\n\nprint(solution(input_data.split(\"\\n\"))) "
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    uniforms = []\n    count = 0\n    for i in range(1, n+1):\n        h, a = map(int, input_list[i].split())\n        uniforms.append((h, a))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            h1, a1 = uniforms[i]\n            h2, a2 = uniforms[j]\n            if h1 == h2:\n                count += 1\n    return str(count)\n\n\ninput_list = [\n    \"3\",\n    \"1 2\",\n    \"2 4\",\n    \"3 4\"\n]\nprint(solution('\\n'.join(input_list)))"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    home_colors = {}\n    guest_colors = {}\n    \n    for i in range(1, n + 1):\n        h, a = map(int, stdin.splitlines()[i].split())\n        home_colors[i] = h\n        guest_colors[i] = a\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if home_colors[i] == guest_colors[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    team_info = []\n    \n    for i in range(n):\n        home_color, guest_color = map(int, stdin.split())\n        team_info.append((home_color, guest_color))\n        \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if team_info[i][0] == team_info[j][1]:\n                count += 1\n                \n    return str(count)\n"
    },
    {
        "number": 832,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    teams = [tuple(map(int, input().split())) for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if teams[i][0] == teams[j][1] or teams[i][1] == teams[j][0]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, v = map(int, input_data[0].split())\n    trees = [map(int, line.split()) for line in input_data[1:]]\n\n    days = [list(tree) for tree in trees]\n    days_count = max(max(day) for day in days)\n\n    max_fruits = 0\n    for i in range(days_count):\n        for day in days:\n            if i in day:\n                max_fruits += day[i]\n\n    return str(min(max_fruits, v))\n\n\ndef"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, v = map(int, input_data[0].split())\n    trees = [[int(a), int(b)] for a, b in [line.split() for line in input_data[1:]]]\n\n    # Sort trees by day of fruit ripening\n    trees.sort(key=lambda x: x[0])\n\n    max_fruits = 0\n    days_collected = [0] * n\n\n    for i in range(n):\n        tree_i = trees[i][1]\n        a_i = trees[i][0]\n\n        # Collect fruits on day a_i\n        days_collected[i] += min(v, tree_i)\n        tree_i -= min(v, tree_i)\n\n        # Collect fruits on day a_i + 1\n        days_collected[i] += min(v, tree_i)\n        tree_i -= min(v, tree_i)\n\n        max_fruits = max(max_fruits, days_collected[i])\n\n    return str(max_fruits)\n\n\nstdin = \"\"\"\n2 3\n1 5\n2 3\n\"\"\"\n\nprint(solution(stdin))  # Output: 8\n\nstdin = \"\"\"\n5 10\n3 20\n2 20\n1 20\n4 20\n5 20\n\"\"\"\n\nprint(solution(stdin))  # Output: 60\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, v = map(int, input_data[0].split())\n    trees = [list(map(int, line.split())) for line in input_data[1:]]\n    \n    def collect(trees, day, collected):\n        for i, tree in enumerate(trees):\n            if tree[0] <= day <= tree[0] + 1:\n                collected += min(tree[1], v - collected)\n        return collected\n    \n    result = 0\n    for day in range(1, max([tree[0] + 2 for tree in trees]) + 1):\n        result = max(result, collect(trees, day, 0))\n    \n    return str(result)\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split()[0:2])\n    trees = [map(int, stdin.split()[i:i+2]) for i in range(1, 2 * n, 2)]\n\n    max_fruits = 0\n    for tree in trees:\n        a, b = tree\n        if a <= v:\n            max_fruits += b\n        if a + 1 <= v:\n            max_fruits += b\n\n    return str(max_fruits)\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split()[0:2])\n    trees = []\n    for i in range(1, n+1):\n        a, b = map(int, stdin.split()[i:i+2])\n        trees.append((a, b))\n    \n    trees.sort(key=lambda x: x[0])\n    i, j = 0, 0\n    max_fruits = 0\n    while i < n and j < n:\n        a, b = trees[i]\n        if a <= j+1 and b > 0:\n            max_fruits += min(b, v)\n            b -= min(b, v)\n            if b == 0:\n                i += 1\n        j += 1\n    \n    return str(max_fruits)"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, v = map(int, input_list[0].split())\n    trees = [list(map(int, line.split())) for line in input_list[1:]]\n\n    max_fruits = 0\n    for tree in trees:\n        if tree[1] <= v:\n            max_fruits += tree[1]\n        else:\n            max_fruits += v\n\n    return str(max_fruits)\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, v = map(int, input_data[0].split())\n    trees = []\n    \n    for i in range(1, len(input_data)):\n        a, b = map(int, input_data[i].split())\n        trees.append((a, b))\n        \n    trees.sort(key=lambda x: x[0])\n    total_fruits = 0\n    current_day = 1\n    for tree in trees:\n        if tree[0] == current_day:\n            total_fruits += tree[1]\n            current_day += 1\n        elif tree[0] == current_day + 1:\n            total_fruits += tree[1]\n            current_day += 2\n        else:\n            total_fruits -= tree[1] * (current_day - tree[0])\n            current_day = tree[0] + 1\n            \n        if total_fruits > v:\n            total_fruits = v\n            \n    return str(total_fruits)"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, input().split())\n    trees = []\n    \n    for _ in range(n):\n        a, b = map(int, input().split())\n        trees.append((a, b))\n    \n    trees.sort(key=lambda x: x[0])\n    max_fruits = 0\n    \n    for tree in trees:\n        if tree[0] + 1 <= tree[0] * 2:\n            max_fruits += min(v, tree[1])\n        else:\n            max_fruits += min(v * 2, tree[1])\n    \n    return str(max_fruits)"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, input().split())\n    trees = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        trees.append((a, b))\n    \n    total_fruits = 0\n    for i in range(n):\n        for j in range(trees[i][1]):\n            if j == 0 or j == 1:\n                total_fruits += 1\n            if j == trees[i][1] - 1:\n                total_fruits += 1\n            if j < trees[i][1] - 2 and total_fruits + 2 <= v:\n                total_fruits += 2\n            if total_fruits > v:\n                break\n        if total_fruits > v:\n            break\n    \n    return str(total_fruits)\n"
    },
    {
        "number": 833,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    b = a[::2]\n    trees = list(zip(a[1::2], b))\n\n    def max_fruits(day: int) -> int:\n        total = 0\n        for i in range(n):\n            if day == b[i]:\n                total += min(v, trees[i][1])\n        return total\n\n    total = 0\n    for day in range(1, max(b) + 2):\n        fruits_collected = max_fruits(day)\n        if day % 2 == 1:\n            fruits_collected += max_fruits(day + 1)\n        total = max(total, fruits_collected)\n\n    return total\n\n\ninput_str = \"\"\"2 3\n1 5\n2 3\"\"\"\nprint(solution(input_str))  # Output: 8\n\ninput_str = \"\"\"5 10\n3 20\n2 20\n1 20\n4 20\n5 20\"\"\"\nprint(solution(input_str))  # Output: 60\n\ninput_str = \"\"\"3 3\n1 2\n2 1\n3 2\"\"\"\nprint(solution(input_str))  # Output: 1\n\ninput_str = \"\"\"10 10\n1 10\n2 10\n3 10\n4 10\n5 10\n6 10\n7 10\n8 10\n9 10\n10 10\"\"\"\nprint(solution(input_str))  # Output: 100\n\ninput_str = \"\"\"10 1\n1 10\n2 10\n3 10\n4 10\n5 10\n6 10\n7 10\n8 10\n9 10\n10 10\"\"\"\nprint(solution(input_str))  # Output: 10\n\ninput_str = \"\"\"10 10\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n9 1\n10 1\"\"\"\nprint(solution(input_str))  # Output: 0\n\ninput_str = \"\"\"2 2\n1 2\n2 1\"\"\"\nprint(solution(input_str))  # Output: 2\n\ninput_str = \"\"\"1 1\n1 1\"\"\"\nprint(solution(input_str))  # Output: 1\n\ninput_str = \"\"\"10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\"\"\"\nprint(solution(input_str))  # Output: 100\n\ninput_str = \"\"\"1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\"\"\"\nprint(solution(input_str))  # Output: 1\n\ninput_str = \"\"\"1 2\n1 1\n2 1\"\"\"\nprint(solution(input_str))  # Output: 2\n\ninput_str = \"\"\"1 1\n1 1\n2 1\"\"\"\nprint(solution(input_str))  # Output: 1\n\ninput_str = \"\"\"1 2\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n9 1\n10 1\"\"\"\nprint(solution(input_str))  # Output: 10\n\ninput_str = \"\"\"10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\n10 10\"\"\"\nprint(solution(input_str))  # Output: 1"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    f_values = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    k = 1\n    while True:\n        f = f_values.copy()\n        for _ in range(k):\n            for i in range(n):\n                f[i] = f_values[f[i] - 1]\n        if f == f_values:\n            break\n        k += 1\n    \n    return str(k)"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_idempotent(f, k, n):\n        for i in range(1, n+1):\n            if f(f(i)) != f(i):\n                return False\n        return True\n\n    n = int(stdin.split('\\n')[0])\n    f_values = list(map(int, stdin.split('\\n')[1].split()))\n    f = lambda x: f_values[x-1]\n\n    k = 1\n    while not is_idempotent(f, k, n):\n        k += 1\n\n    return str(k)\n"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def apply_k_times(f: int, k: int) -> int:\n        for _ in range(k - 1):\n            f = f(f)\n        return f\n\n    n = int(stdin.splitlines()[0])\n    f_values = list(map(int, stdin.splitlines()[1].split()))\n\n    k = 1\n    while True:\n        f = lambda x: f_values[x - 1]\n        if apply_k_times(f, k) == apply_k_times(f, k + 1):\n            k += 1\n        else:\n            break\n\n    return str(k - 1)\n"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def apply_k_times(x, k):\n        result = x\n        for i in range(k - 1):\n            result = f(result)\n        return result\n\n    n = int(stdin[0].strip())\n    f_values = list(map(int, stdin[1].strip().split()))\n    f = lambda x: f_values[x - 1]\n\n    k = 1\n    while True:\n        if apply_k_times(1, k) == apply_k_times(apply_k_times(1, k), k):\n            break\n        k += 1\n\n    return k\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()\n\noutput_expected = \"2\"\n\ninput_stdin = \"\"\"3\n2 3 1\"\"\".splitlines()\n\noutput_expected = \"3\"\n\n\ninput_stdin = \"\"\"4\n1 2 2 4\"\"\".splitlines()\n\noutput_expected = \"1\"\n\n\ninput_stdin = \"\"\"3\n2 3 3\"\"\".splitlines()"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    f = list(map(int, stdin.splitlines()[1].split()))\n\n    # Find the minimum k such that function f^{(k)}(x) is idempotent\n    k = 1\n    while k <= n:\n        k += 1\n        f_k = [f[x - 1] for x in range(1, n + 1)]\n        if f_k == f:\n            break\n        else:\n            f = f_k\n\n    return str(k - 1)\n\n\ndef"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_f(n: int) -> list:\n        f = list(map(int, input().split()))\n        return f\n\n    def apply_f(f: list, k: int) -> list:\n        for _ in range(k):\n            f = list(map(lambda x: f[x - 1], f))\n        return f\n\n    def is_idempotent(f: list, k: int) -> bool:\n        applied_f = apply_f(f, k)\n        for x in range(1, n + 1):\n            if applied_f[x - 1] != x:\n                return False\n        return True\n\n    n = int(input())\n    f = get_f(n)\n\n    for k in range(1, n + 1):\n        if is_idempotent(f, k):\n            print(k)\n            break\n    else:\n        print(1)\n"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    f_values = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    k = 1\n    while True:\n        f_k = [f_values[x - 1] for x in f_values]\n        if f_k == f_values:\n            return k\n        k += 1"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    f_values = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_idempotent(k: int) -> bool:\n        def apply_k_times(x: int) -> int:\n            for _ in range(k):\n                x = f_values[x - 1]\n            return x\n\n        for i in range(1, n + 1):\n            if apply_k_times(i) != i:\n                return False\n        return True\n\n    k = 1\n    while not is_idempotent(k):\n        k += 1\n\n    return str(k)\n"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    f = [int(x) for x in input().split()]\n    \n    k = 1\n    while True:\n        f_k = [f[x-1] for x in range(1, n+1)]\n        if f_k == f:\n            break\n        f = f_k\n        k += 1\n    \n    return str(k)\n"
    },
    {
        "number": 834,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    f = list(map(int, stdin.splitlines()[1].split()))\n    \n    k = 1\n    while k <= n:\n        f_k = [f[0]]\n        for i in range(1, n):\n            f_k.append(f[f_k[i-1]-1])\n        \n        if all(f_k[i] == f_k[f_k[i]-1] for i in range(n)):\n            return str(k)\n        else:\n            k += 1\n    \n    return str(k)"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = input().split()\n    recipe = \"\".join(recipe.split())\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, [n_b, n_s, n_c, p_b, p_s, p_c, r])\n\n    max_hamburgers = 0\n    for i in range(len(recipe)):\n        hamburger = recipe[:i + 1]\n        if \"BB\" in hamburger or \"SC\" in hamburger:\n            if i + 1 < len(recipe) and recipe[i + 1] == \"S\":\n                if \"BSC\" in hamburger:\n                    max_hamburgers += 1\n                elif \"SBC\" in hamburger:\n                    max_hamburgers += 1\n        elif \"BC\" in hamburger:\n            if i + 1 < len(recipe) and recipe[i + 1] == \"B\":\n                max_hamburgers += 1\n\n    max_hamburgers = min(max_hamburgers, n_b // 2, n_s, n_c)\n    max_hamburgers *= p_b + p_s + p_c\n\n    if max_hamburgers > r:\n        max_hamburgers = 0\n\n    return str(max_hamburgers)\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    recipe, nums, prices, rubles = stdin.split('\\n')\n    n_b, n_s, n_c = map(int, nums.split())\n    p_b, p_s, p_c = map(int, prices.split())\n\n    max_burgers = 0\n    for i in range(len(recipe)):\n        if recipe[i] == 'B':\n            max_burgers += n_b - i\n        elif recipe[i] == 'S':\n            max_burgers += n_s - i\n        else:\n            max_burgers += n_c - i\n\n    max_burgers = max(0, max_burgers)\n\n    return str(max_burgers)\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    recipe = input_list[0]\n    n_b, n_s, n_c = map(int, input_list[1].split())\n    p_b, p_s, p_c = map(int, input_list[2].split())\n    r = int(input_list[3])\n\n    def can_make_hamburger(hamburger_recipe: str) -> bool:\n        return (n_b >= hamburger_recipe.count('B') and\n                n_s >= hamburger_recipe.count('S') and\n                n_c >= hamburger_recipe.count('C'))\n\n    def cost_of_hamburgers(hamburger_recipe: str) -> int:\n        return (hamburger_recipe.count('B') * p_b +\n                hamburger_recipe.count('S') * p_s +\n                hamburger_recipe.count('C') * p_c)\n\n    max_num_hamburgers = 0\n    for h in range(1, len(recipe) + 1):\n        for i in range(len(recipe) - h + 1):\n            hamburger_recipe = recipe[i:i + h]\n            if can_make_hamburger(hamburger_recipe) and cost_of_hamburgers(hamburger_recipe) <= r:\n                max_num_hamburgers = max(max_num_hamburgers, h)\n\n    return str(max_num_hamburgers) if max_num_hamburgers > 0 else '0'\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = input(stdin).split()\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, [n_b, n_s, n_c, p_b, p_s, p_c, r])\n\n    hamburgers_count = 0\n    for b in range(n_b + 1):\n        for s in range(n_s + 1):\n            for c in range(n_c + 1):\n                if b * p_b + s * p_s + c * p_c <= r:\n                    hamburgers_count += 1\n\n    return str(hamburgers_count)\n\ninput_string = \"\"\"BBBSSC\n6 4 1\n1 2 3\n4\n\nBBC\n1 10 1\n1 10 1\n21\n\nBSC\n1 1 1\n1 1 3\n1000000000000\n\"\"\"\n\nresult = solution(input_string)\nprint(result)"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = stdin.split()\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, [n_b, n_s, n_c, p_b, p_s, p_c, r])\n\n    max_hamburgers = 0\n    for b in range(1, n_b + 1):\n        for s in range(1, n_s + 1):\n            for c in range(1, n_c + 1):\n                hamburger = f\"{b}S{s}C{c}B{s}C\" + recipe\n                if len(hamburger) == len(recipe) and sum(int(hamburger[i]) * p_b * p_s * p_c for i in range(len(hamburger))) <= r:\n                    max_hamburgers = max(max_hamburgers, b * s * c * 2)\n\n    return str(max_hamburgers)\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n, p, r = input().split()\n    n, p, r = int(n), int(p), int(r)\n    ingredients = {\n        'B': n,\n        'S': n,\n        'C': n\n    }\n\n    for ingredient in recipe:\n        if ingredient == 'B':\n            ingredients['S'] -= 1\n            ingredients['C'] -= 1\n        elif ingredient == 'S':\n            ingredients['C'] -= 1\n        else:\n            pass\n\n    if ingredients['S'] < 0 or ingredients['C'] < 0:\n        return 0\n\n    max_hamburgers = r // (p * len(recipe))\n    max_hamburgers = min(max_hamburgers, ingredients['B'])\n\n    return max_hamburgers\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n_b, n_s, n_c = map(int, stdin[1].split())\n    p_b, p_s, p_c = map(int, stdin[2].split())\n    r = int(stdin[3])\n\n    recipe = stdin[0]\n\n    max_hamburgers = 0\n    for i in range(len(recipe)):\n        if recipe[i] == 'B':\n            if n_b >= 1:\n                n_b -= 1\n                r -= p_b\n            else:\n                break\n        elif recipe[i] == 'S':\n            if n_s >= 1:\n                n_s -= 1\n                r -= p_s\n            else:\n                break\n        elif recipe[i] == 'C':\n            if n_c >= 1:\n                n_c -= 1\n                r -= p_c\n            else:\n                break\n        if r < 0:\n            break\n        max_hamburgers += 1\n\n    return str(max_hamburgers)\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = input().split()\n    recipe = ''.join(recipe.split())\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, [n_b, n_s, n_c, p_b, p_s, p_c, r])\n    \n    max_hamburgers = 0\n    \n    for i in range(len(recipe)):\n        b = recipe.count('B', 0, i)\n        s = recipe.count('S', 0, i)\n        c = recipe.count('C', 0, i)\n        \n        if b <= n_b and s <= n_s and c <= n_c:\n            max_hamburgers += 1\n    \n    cost = max_hamburgers * (n_b * p_b + n_s * p_s + n_c * p_c)\n    \n    if cost <= r:\n        return str(max_hamburgers)\n    else:\n        return '0'\n"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = input_processing(stdin)\n\n    if r < p_b * n_b + p_s * n_s + p_c * n_c:\n        return \"0\"\n\n    max_hamburgers = r // (p_b * n_b + p_s * n_s + p_c * n_c)\n    max_hamburgers *= len(recipe) // 3\n\n    return str(max_hamburgers)\n\n\ndef"
    },
    {
        "number": 835,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    recipe, n_b, n_s, n_c, p_b, p_s, p_c, r = input().split()\n    recipe = ''.join(sorted(recipe, reverse=True))\n    n_b, n_s, n_c, p_b, p_s, p_c, r = map(int, (n_b, n_s, n_c, p_b, p_s, p_c, r))\n\n    max_hamburgers = 0\n    while r >= p_b + p_s + p_c:\n        for i in range(1, n_b + 1):\n            for j in range(1, n_s + 1):\n                for k in range(1, n_c + 1):\n                    if 'B' * i + 'S' * j + 'C' * k == recipe:\n                        max_hamburgers += 1\n                        r -= p_b * i + p_s * j + p_c * k\n                        if r < p_b + p_s + p_c:\n                            break\n                if r < p_b + p_s + p_c:\n                    break\n            if r < p_b + p_s + p_c:\n                break\n        if r < p_b + p_s + p_c:\n            break\n\n    return str(max_hamburgers)\n"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    street = stdin.split()[2]\n\n    max_time = 0\n    max_k = 0\n\n    for i in range(n):\n        if street[i] == \"H\":\n            max_k += 1\n            max_time += 2\n        elif street[i] == \"S\":\n            max_time += 1\n        else:\n            max_time += 1\n            max_k += 1\n\n        if max_time > t:\n            return \"-1\"\n\n    return str(max_k)\n\n\nstdin = \"6 6\\nHSHSHS\"\nprint(solution(stdin))\n\nstdin = \"14 100\\n...HHHSSS...SH\"\nprint(solution(stdin))\n\nstdin = \"23 50\\nHHSS.......SSHHHHHHHH\"\nprint(solution(stdin)) "
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    road = stdin.split()[2]\n\n    min_k = 0\n    num_houses = road.count('H')\n    num_shops = road.count('S')\n\n    if num_houses == 0 or (num_houses + num_shops) <= t:\n        return str(min_k)\n\n    if num_houses <= num_shops:\n        min_k = num_houses\n    else:\n        min_k = num_houses + (num_houses - num_shops)\n\n    return str(min_k)\n\n\ninput_data = \"\"\"6 6\nHSHSHS\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    street = stdin.split()[2]\n\n    houses = street.count('H')\n    shops = street.count('S')\n\n    if houses > 0 and houses <= shops:\n        sweets_per_house = min(1, shops // houses)\n        total_sweets = sweets_per_house * houses\n        if total_sweets <= t:\n            return str(total_sweets)\n        else:\n            return \"-1\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, t = map(int, input_str[0].split())\n    segment_types = input_str[1]\n\n    if segment_types.count('H') > segment_types.count('S'):\n        return -1\n\n    houses_without_shops = segment_types.count('H') - segment_types.count('S')\n    shops_without_houses = segment_types.count('S') - segment_types.count('H')\n\n    sweets_in_houses = houses_without_shops * 1\n    sweets_in_shops = min(shops_without_houses, houses_without_shops) * 1\n    sweets_on_street = sweets_in_houses + sweets_in_shops\n\n    remaining_sweets_needed = sweets_on_street + houses_without_shops\n    return remaining_sweets_needed"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    street = input()\n\n    # Determine the number of houses and shops\n    houses = street.count(\"H\")\n    shops = street.count(\"S\")\n\n    # If the number of shops is less than the number of houses, return -1\n    if shops < houses:\n        return \"-1\"\n\n    # If the number of shops is equal to the number of houses, no need to bring additional sweets\n    if shops == houses:\n        return \"0\"\n\n    # Calculate the minimum number of kilograms of sweets required\n    total_sweets = houses + shops\n    required_sweets = houses + houses * t - shops\n\n    # If the required sweets is less than or equal to the total sweets, return the required sweets\n    if required_sweets <= total_sweets:\n        return str(required_sweets)\n\n    # If there isn't a single value of k that makes it possible to give sweets to everybody in at most t units of time, return -1\n    return \"-1\"\n\ndef"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    street = stdin.split()[2]\n\n    houses = street.count('H')\n    stores = street.count('S')\n    empty_sections = n - houses - stores\n\n    if houses == 0:\n        return \"-1\"\n\n    k = houses + stores + empty_sections\n\n    if k <= t:\n        return str(k)\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    street = input()\n\n    houses = sum(street[i] == 'H' for i in range(n))\n    shops = sum(street[i] == 'S' for i in range(n))\n\n    if houses > shops or shops == 0:\n        return \"-1\"\n\n    k = min(houses, shops)\n    return k\n"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    road = input()\n\n    houses = [i for i, c in enumerate(road) if c == 'H']\n    shops = [i for i, c in enumerate(road) if c == 'S']\n\n    if not houses:\n        return \"-1\"\n\n    k = 0\n    visited = set()\n    for house in houses:\n        current_time = 0\n        visited.clear()\n        while True:\n            if current_time > t:\n                break\n\n            current_pos = house\n            current_time += 1\n            while current_pos not in visited:\n                visited.add(current_pos)\n                current_pos += 1\n                if current_pos >= n:\n                    current_pos -= n\n                if current_pos in shops:\n                    k += 1\n                    visited.remove(current_pos)\n                    if k > 10**9:\n                        return \"-1\"\n                    break\n\n    return k\n"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    street = stdin.split()[2:]\n\n    houses = street.count(\"H\")\n    stores = street.count(\"S\")\n\n    if stores < houses:\n        return -1\n\n    k = (houses * 2) // (stores + 1)\n\n    if k * (stores + 1) / 2 >= houses:\n        return k\n    else:\n        return -1\n"
    },
    {
        "number": 836,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    road = stdin.split()[2]\n\n    shops = road.count('S')\n    houses = road.count('H')\n    if shops < houses:\n        return -1\n\n    sweets_per_house = min(shops, houses)\n    sweets_needed = sweets_per_house * t\n\n    return sweets_needed\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    t = n * x + (n - 1) * y\n    return str(t)\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n\n    if n == 1:\n        return str(x)\n\n    t = 0\n    t += x + (n-1) // 2 * y\n\n    return str(t)\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    return min(x * (n + 1), y * n)\n\nn, x, y = map(int, input().split())\nprint(solution(n, x, y)) "
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    return y * n + x * (n // 2)\n\n\ninput_data = input()\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    if n == 1:\n        return x + y\n    elif n % 2 == 0:\n        return n * x + n // 2 * y\n    else:\n        return n * x + (n // 2 + 1) * y\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    time_to_create_input = n * x\n    time_to_copy_input = (n // 2) * y\n    return max(time_to_create_input, time_to_copy_input)\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    return n * y if x == 0 else (n * y) + (n // x) + ((n % x) * (x + (n // x) * y))"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    min_time = (n * x) + (n * y)\n    return str(min_time)"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    return n // y + (1 if n % y != 0 else 0) * x\n"
    },
    {
        "number": 837,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    t = n * x + (n // y) * y\n    return str(t)\n\n\ndef"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    rows = []\n    for i in range(1, n + 1):\n        rows.append(list(map(int, input_data[i].split())))\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if rows[i][j] == 1:\n                continue\n            count += 1\n            for k in range(m):\n                if rows[i][k] == 1:\n                    count += 1\n            for l in range(n):\n                if rows[l][j] == 1:\n                    count += 1\n            if i < n - 1:\n                if rows[i + 1][j] == 1:\n                    count += 1\n            if j < m - 1:\n                if rows[i][j + 1] == 1:\n                    count += 1\n\n    return str(count // 2)"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def check(cells):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                for k in range(len(cells)):\n                    if cells[k] == i or cells[k] == j:\n                        count += 1\n                        break\n        return count == len(cells)\n\n    n, m = map(int, stdin.split()[:2])\n    rows = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    cells = [cell for row in rows for cell in range(len(rows)) if row[cell] == 1]\n\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if check([i*m+j, i*m+(m+1)+j, i*(m+2)+(m+1)+j, i*(m+2)+j, i*(m+2)+(m+1)+j]):\n                count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_row_color(row: List[int], j: int) -> int:\n        return row[j]\n\n    def get_column_color(table: List[List[int]], i: int, j: int) -> int:\n        return table[i][j]\n\n    def is_valid_set(table: List[List[int]], i: int, j: int, set_size: int) -> bool:\n        return get_row_color(table[i], j) == get_row_color(table[i + set_size], j) and \\\n               get_column_color(table, i, j) == get_column_color(table, i + set_size, j)\n\n    def count_non_empty_sets(table: List[List[int]], set_size: int) -> int:\n        count = 0\n        for i in range(len(table) - set_size):\n            for j in range(len(table[0]) - set_size):\n                if is_valid_set(table, i, j, set_size):\n                    count += 1\n        return count\n\n    n, m = map(int, stdin.split()[0].split())\n    table = [list(map(int, stdin.split()[i+1].split())) for i in range(n)]\n\n    return str(count_non_empty_sets(table, 2))\n"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    rows = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        rows.append(row)\n\n    def is_neighbor(i, j, k, l):\n        return i == k or j == l\n\n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        visited[x][y] = True\n        count = 1\n        for i in range(n):\n            if is_neighbor(x, y, i, y) and not visited[i][y]:\n                count += dfs(i, y, visited)\n        for j in range(m):\n            if is_neighbor(x, y, x, j) and not visited[x][j]:\n                count += dfs(x, j, visited)\n        return count\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            count += dfs(i, j, visited)\n\n    return str(count)\n"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    matrix = [[int(x) for x in input_list[i+1].split()] for i in range(n)]\n\n    def valid_set(set_cells):\n        for cell1, cell2 in combinations(set_cells, 2):\n            if cell1[0] == cell2[0] or cell1[1] == cell2[1]:\n                return True\n        return False\n\n    sets = []\n    for i in range(n):\n        for j in range(m):\n            for k in range(i+1, n):\n                for l in range(j+1, m):\n                    set_cells = [(i, j), (k, l)]\n                    if valid_set(set_cells):\n                        sets.append(set_cells)\n\n    return str(len(sets))"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    rows = []\n\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        rows.append(row)\n\n    count = 0\n\n    # Iterate through all possible sets of cells\n    for i in range(n):\n        for j in range(m):\n            # Check if the current cell is not on the edge and is not already counted\n            if i > 0 and j > 0 and i < n-1 and j < m-1 and (rows[i-1][j] == rows[i][j] and rows[i+1][j] == rows[i][j] and rows[i][j-1] == rows[i][j] and rows[i][j+1] == rows[i][j]):\n                count += 1\n\n    return str(count)\n\n\ninput_str = '''2 3\n1 0 1\n0 1 0\n'''\n\nprint(solution(input_str))\n"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    rows = input_list[1:]\n    \n    # Initialize sets\n    sets = []\n    for i in range(n):\n        sets.append(set())\n    \n    # Create sets\n    for i in range(n):\n        for j in range(m):\n            if rows[i][j] == '1':\n                # Add black cell to sets\n                for set_index, row_set in enumerate(sets):\n                    if i in row_set:\n                        sets[set_index].add(j)\n                    elif j in row_set:\n                        sets[set_index].add(i)\n                    else:\n                        new_set = {i, j}\n                        sets.append(new_set)\n                        row_set.add(i)\n                        row_set.add(j)\n    return len(sets)"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_sets(row, col):\n        def dfs(cell, row, col, color):\n            if not 0 <= cell < n * m:\n                return 0\n            if not 0 <= row < n and not 0 <= col < m:\n                return 0\n            if (row, col) in seen:\n                return seen[(row, col)]\n            if table[row][col] != color:\n                seen[(row, col)] = 0\n                return 0\n            seen[(row, col)] = 1\n            if row > 0:\n                seen[(row - 1, col)] += dfs(cell - 1, row - 1, col, color)\n            if row + 1 < n:\n                seen[(row + 1, col)] += dfs(cell + n - 1, row + 1, col, color)\n            if col > 0:\n                seen[(row, col - 1)] += dfs(cell - m, row, col - 1, color)\n            if col + 1 < m:\n                seen[(row, col + 1)] += dfs(cell + 1, row, col + 1, color)\n            return seen[(row, col)]\n\n        seen = {}\n        count = 0\n        for i in range(n * m):\n            color = table[i // m][i % m]\n            count += dfs(i, i // m, i % m, color)\n        return count\n\n    n, m = map(int, stdin.split()[:2])\n    table = [list(map(int, input().split())) for _ in range(n)]\n    return str(count_sets(n * m, m * (n + 1) // 2))\n"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.split()[0:2])\n    rows = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    # Calculate the number of non-empty sets\n    total_sets = 0\n    for row in rows:\n        for col in range(m):\n            if row[col] == 0:\n                total_sets += m - col\n            else:\n                break\n    for col in range(m):\n        column = [row[col] for row in rows]\n        if column[0] == 0:\n            total_sets += n - sum(column)\n        else:\n            break\n\n    # Return the number of non-empty sets\n    return total_sets"
    },
    {
        "number": 838,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    rows = [list(map(int, input_data[i].split())) for i in range(1, n + 1)]\n\n    def get_neighbors(row: int, col: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        if row > 0:\n            neighbors.append((row - 1, col))\n        if row < n - 1:\n            neighbors.append((row + 1, col))\n        if col > 0:\n            neighbors.append((row, col - 1))\n        if col < m - 1:\n            neighbors.append((row, col + 1))\n        return neighbors\n\n    def dfs(row: int, col: int, color: int, visited: Set[Tuple[int, int]]) -> int:\n        if (row, col) in visited:\n            return 0\n        visited.add((row, col))\n        if rows[row][col] != color:\n            return 0\n        result = 1\n        for neighbor in get_neighbors(row, col):\n            result += dfs(neighbor[0], neighbor[1], color, visited)\n        return result\n\n    count = 0\n    for row in range(n):\n        for col in range(m):\n            if rows[row][col] == 1:\n                visited = set()\n                count += dfs(row, col, 1, visited)\n\n    return str(count)\n"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g = [[0] * 5 for _ in range(5)]\n    for i in range(5):\n        row = stdin.split()[i]\n        for j in range(5):\n            g[i][j] = int(row[j])\n\n    dp = [[0] * 5 for _ in range(5)]\n    for i in range(5):\n        dp[i][i] = 0\n        for j in range(i + 1, 5):\n            dp[i][j] = dp[i][j - 1] + g[i][j]\n            dp[j][i] = dp[j][i - 1] + g[j][i]\n\n    max_happiness = 0\n    for i in range(5):\n        for j in range(i + 1, 5):\n            max_happiness += dp[i][j] + dp[j][i]\n\n    return max_happiness\n"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    g = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    \n    # Calculate initial happiness for each student\n    n = len(g)\n    happiness = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            happiness[i][j] = g[i][j] + g[j][i]\n    \n    # Calculate maximum total happiness for each order of the line\n    max_total_happiness = float('-inf')\n    for permutation in itertools.permutations(range(n)):\n        total_happiness = sum(happiness[i][permutation[i]] for i in range(n))\n        max_total_happiness = max(max_total_happiness, total_happiness)\n    \n    return str(max_total_happiness)\n"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    g = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    n = len(g)\n    \n    # calculate the maximum possible total happiness by creating a matrix with the maximum values for each student\n    max_happiness = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            max_happiness[i][j] = max(g[i][j], g[j][i])\n    \n    # create a helper function to calculate the happiness for a given permutation of the line\n    def calculate_happiness(permutation: List[int]) -> int:\n        happiness = 0\n        for i in range(n - 1):\n            happiness += max_happiness[permutation[i]][permutation[i + 1]]\n        return happiness\n    \n    # find the maximum possible happiness by iterating over all possible permutations\n    max_happiness_sum = 0\n    for permutation in permutations(range(n)):\n        max_happiness_sum = max(max_happiness_sum, calculate_happiness(permutation))\n    \n    return max_happiness_sum"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    g = []\n    for i in range(5):\n        g.append(list(map(int, stdin.split())))\n\n    def max_happiness(line: list[int]) -> int:\n        happiness = 0\n        for i in range(4):\n            for j in range(i + 1, 5):\n                happiness += g[line[i] - 1][line[j] - 1]\n        return happiness\n\n    def next_line(line: list[int]) -> list[int]:\n        new_line = [line[0]]\n        for i in range(1, 5):\n            new_line.append((line[-1] - 1) % 5 + 1)\n            line.remove(new_line[-1])\n        return new_line\n\n    max_h = 0\n    lines = [list(range(1, 6))]\n    while lines:\n        line = lines.pop(0)\n        h = max_happiness(line)\n        if h > max_h:\n            max_h = h\n        lines.append(next_line(line))\n\n    return str(max_h)"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def max_happiness(stdin: str) -> int:\n        g = [[0 for _ in range(5)] for _ in range(5)]\n        for i in range(5):\n            for j in range(5):\n                g[i][j] = int(stdin[i * 5 + j])\n\n        def get_happiness(i: int, j: int) -> int:\n            return g[i - 1][j - 1] + g[j - 1][i - 1]\n\n        def dfs(pos: int, prev: int) -> int:\n            if pos == 5:\n                return 0\n\n            max_happiness = 0\n            for i in range(1, 6):\n                if i != prev:\n                    max_happiness = max(max_happiness, get_happiness(pos, i) + dfs(pos + 1, i))\n\n            return max_happiness\n\n        return dfs(1, 0)\n\n    return str(max_happiness(stdin))\n"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_happiness(stdin: str) -> int:\n        g = [[int(v) for v in line.strip().split()] for line in stdin.split('\\n')]\n        n = len(g)\n\n        max_happiness = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(i + 1, n):\n                    max_happiness += g[i][j] + g[j][k] + g[i][k]\n\n        return max_happiness\n\n    return str(calculate_happiness(stdin))\n\n\ninput1 = \"\"\"0 0 0 0 9\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n7 0 0 0 0\"\"\"\n\ninput2 = \"\"\"0 43 21 18 2\n3 0 21 11 65\n5 2 0 1 4\n54 62 12 0 99\n87 64 81 33 0\"\"\"\n\nprint(solution(input1))  # Output: 32\nprint(solution(input2))  # Output: 620 "
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    g = [[0 for _ in range(5)] for _ in range(5)]\n\n    for i in range(5):\n        line = stdin[i * 5 + i * 2:i * 5 + 2 + i * 5:2]\n        for j in range(5):\n            g[i][j] = int(line[j])\n\n    # Calculate optimal arrangement of the line\n    optimal_line = [1] * 5\n    max_happiness = 0\n\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if g[i][j] > max_happiness:\n                max_happiness = g[i][j]\n                optimal_line[i] = j + 1\n                optimal_line[j] = i + 1\n\n    # Calculate total happiness of the students\n    total_happiness = 0\n    for i in range(5):\n        total_happiness += g[i][optimal_line[i] - 1]\n        total_happiness += g[optimal_line[i] - 1][i]\n\n    return str(total_happiness)"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    g = [[int(x) for x in line.split()] for line in stdin.splitlines()]\n    n = len(g)\n\n    def happiness(order):\n        total_happiness = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total_happiness += g[order[i] - 1][order[j] - 1]\n                total_happiness += g[order[j] - 1][order[i] - 1]\n        return total_happiness\n\n    def total_happiness(order):\n        total_happiness = 0\n        for i in range(n):\n            total_happiness += happiness(order[i])\n        return total_happiness\n\n    def best_order(order):\n        if order == 0:\n            return 0\n        best_happiness = float('-inf')\n        for i in range(order):\n            new_order = order - 1\n            new_order[i] = n\n            best_happiness = max(best_happiness, best_order(new_order))\n        return best_happiness\n\n    order = [i for i in range(n)]\n    order = order[::-1]\n    max_happiness = best_order(order)\n\n    return max_happiness"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    g = [[0 for _ in range(5)] for _ in range(5)]\n    for i in range(5):\n        row = list(map(int, stdin.split()[i * 5:(i + 1) * 5]))\n        for j in range(5):\n            g[i][j] = row[j]\n            g[j][i] = row[j]\n\n    max_happiness = 0\n    for order in itertools.permutations(range(5)):\n        happiness = 0\n        for i in range(4):\n            for j in range(i + 1, 5):\n                happiness += g[order[i]][order[j]] + g[order[j]][order[i]]\n        max_happiness = max(max_happiness, happiness)\n\n    return str(max_happiness)\n"
    },
    {
        "number": 839,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    g = [[int(x) for x in line.split()] for line in stdin.split(\"\\n\")]\n    \n    # Find the optimal arrangement of the line\n    n = len(g)\n    dp = [[0] * n for _ in range(n)]\n    for k in range(n):\n        for i in range(n - k):\n            j = i + k\n            for m in range(i, j):\n                dp[i][j] = max(dp[i][j], dp[i][m] + dp[m+1][j] + g[i][j] + g[j][i])\n    \n    # Calculate the total happiness\n    total_happiness = dp[0][n-1]\n    \n    return total_happiness"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    for i in range(n):\n        b[i] += k\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    cookies = 0\n    for i in range(n):\n        if a[i] <= b[i]:\n            cookies += a[i]\n        else:\n            cookies += b[i]\n\n    return str(cookies)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n    \n    b.sort(reverse=True)\n    count = 0\n    for i in range(n):\n        if b[i] > k:\n            break\n        k -= b[i]\n        count += 1\n    \n    return str(count)"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n    b_list = list(map(int, input_list[2].split()))\n\n    # Create a dictionary to store the sum of a_list and b_list\n    sum_dict = {}\n    for i in range(n):\n        if a_list[i] in sum_dict:\n            sum_dict[a_list[i]] += 1\n        else:\n            sum_dict[a_list[i]] = 1\n        if b_list[i] in sum_dict:\n            sum_dict[b_list[i]] += 1\n        else:\n            sum_dict[b_list[i]] = 1\n\n    # Sort the sum_dict based on the values in descending order\n    sorted_dict = dict(sorted(sum_dict.items(), key=lambda item: item[1], reverse=True))\n\n    # Calculate the maximum number of cookies that Apollinaria can bake\n    max_cookie = 0\n    for key, value in sorted_dict.items():\n        if key + k >= 0:\n            max_cookie += k // key\n        else:\n            max_cookie += 0\n            break\n\n    return str(max_cookie)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    max_cookies = 0\n    for i in range(n):\n        max_cookies += min(a[i], b[i])\n        k -= min(a[i], b[i])\n        if k < 0:\n            return str(max_cookies)\n\n    max_cookies += k // sum(a) * sum(a)\n    return str(max_cookies)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        else:\n            return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    b = list(map(int, stdin.split()[n + 2:]))\n\n    b = [lcm(k, b[i]) for i in range(n)]\n\n    min_a = min(a)\n    count = sum(b) // min_a\n\n    return str(count)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, k = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    b = list(map(int, input_lines[2].split()))\n\n    total_ingredients = sum(a)\n    max_cookies = 0\n\n    for i in range(n):\n        if k >= a[i]:\n            max_cookies += a[i]\n            k -= a[i]\n            b[i] -= a[i]\n            total_ingredients -= a[i]\n        else:\n            max_cookies += k\n            b[i] -= k\n            total_ingredients -= k\n            break\n\n    max_cookies = max_cookies // total_ingredients\n\n    return str(max_cookies)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n    b_list = list(map(int, input_list[2].split()))\n\n    # Sort the lists in ascending order\n    a_list.sort()\n    b_list.sort()\n\n    # Initialize the pointers\n    i = 0\n    j = 0\n\n    # Initialize the result\n    result = 0\n\n    while i < n and j < n:\n        # Calculate the number of cookies that can be baked\n        cookies = min(k // a_list[i], b_list[j])\n\n        # Update the pointers and the result\n        k -= cookies * a_list[i]\n        i += 1\n        j += 1\n        result += cookies\n\n        # If the magic powder is not enough, the number of cookies can be 0\n        if k < 0:\n            return str(result)\n\n    # If there are remaining ingredients, calculate the number of cookies\n    if i < n:\n        cookies = k // a_list[i]\n    elif j < n:\n        cookies = k // b_list[j]\n    else:\n        cookies = 0\n\n    result += cookies\n\n    return str(result)\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n    \n    a_sum = sum(a)\n    b_sum = sum(b)\n\n    if a_sum > b_sum + k:\n        return \"0\"\n\n    a_remain = a_sum - b_sum\n    b_remain = k - a_remain\n\n    count = 0\n    while a_remain > 0 and b_remain > 0:\n        if a_remain >= b_remain:\n            a_remain -= b_remain\n        else:\n            b_remain -= a_remain\n            a_remain = 0\n\n        count += 1\n\n    if a_remain == 0:\n        return count\n    else:\n        return count - 1\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_cookies(n: int, k: int, a: list, b: list) -> int:\n        a.sort(reverse=True)\n        b.sort(reverse=True)\n        cookies = 0\n        i, j = 0, 0\n        while i < n and j < n:\n            if a[i] + b[j] <= k:\n                cookies += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return cookies\n\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    return str(calculate_cookies(n, k, a, b))\n"
    },
    {
        "number": 840,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, k = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    # Initialize variables\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    # Build dp table\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        if b[i - 1] >= a[i - 1] and b[i - 1] <= k:\n            dp[i] += dp[i - 1]\n\n    # Calculate the maximum number of cookies\n    max_num_cookies = 0\n    for i in range(n + 1):\n        max_num_cookies = max(max_num_cookies, dp[i])\n\n    return str(max_num_cookies)\n"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    queries = [int(line) for line in stdin.splitlines()[1:]]\n\n    def is_valid_subsequence(s: str, n: int) -> bool:\n        count = 0\n        for digit in s:\n            if digit == '1':\n                count += 1\n            if count == n:\n                return True\n        return count == n\n\n    def find_valid_subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n            if count == 3:\n                return s[i:]\n        return ''\n\n    for n in queries:\n        s = '1337'\n        while not is_valid_subsequence(s, n):\n            s = s[1:] + '7'\n        subsequence = find_valid_subsequences(s)\n        print(s + subsequence)\n"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    queries = [int(stdin.split()[1]) for _ in range(t)]\n    \n    def is_valid(s: str) -> bool:\n        count = 0\n        for c in s:\n            count += 1 if c == '1' else 0\n            count += 1 if c == '3' else 0\n            count += 1 if c == '7' else 0\n            if count == 3:\n                return False\n        return True\n    \n    def generate_sequence(n: int) -> str:\n        s = '137'\n        while len(s) < n:\n            s += '1337'\n        return s[:n]\n    \n    for n in queries:\n        s = generate_sequence(n)\n        while not is_valid(s):\n            s = generate_sequence(n)\n        print(s)"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    queries = [int(input()) for _ in range(t)]\n    sequences = []\n    \n    for n in queries:\n        sequence = []\n        i = 1\n        while len(sequence) < n * 3:\n            sequence.extend([1, 3, 7])\n            i += 1\n        sequences.append(''.join(map(str, sequence[:n * 3])))\n    \n    return '\\n'.join(sequences)\n"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    queries = stdin.split(\"\\n\")[1:]\n\n    def count_subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            count += s.count(\"1337\"[:i+1])\n        return count\n\n    for n in queries:\n        n = int(n)\n        s = \"3\" * n + \"7\"\n        while count_subsequences(s) != n:\n            s = s[:-1]\n        print(s)"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                subseq = s[i:j]\n                if subseq == '1337':\n                    count += 1\n        return count\n\n    t = int(stdin[0])\n    queries = stdin[1].split('\\n')\n\n    for i in range(t):\n        n = int(queries[i])\n        s = '1337' * (n // 3)\n        s += '1' * (n % 3)\n        s += '7' * (n // 3)\n        print(s)"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    queries = []\n    for _ in range(t):\n        queries.append(int(stdin))\n\n    def find_sequence(n: int) -> str:\n        s = \"\"\n        for _ in range(n):\n            s += \"1337\"\n        return s\n\n    result = []\n    for n in queries:\n        result.append(find_sequence(n))\n\n    return \"\\n\".join(result)\n\n\ninput_text = \"\"\"2\n6\n1\"\"\"\n\nprint(solution(input_text)) "
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for _ in range(t):\n        n = int(input())\n        s = \"137\"\n        if n == 1:\n            print(s)\n        else:\n            print(\"137133377\")"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.splitlines()[0])\n    queries = stdin.splitlines()[1:]\n\n    def generate_subsequences(s: str) -> list:\n        subsequences = []\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                subsequences.append(s[i:j+1])\n        return subsequences\n\n    def has_1337_subsequences(s: str, n: int) -> bool:\n        subsequences = generate_subsequences(s)\n        count = 0\n        for subsequence in subsequences:\n            if subsequence == '1337':\n                count += 1\n                if count == n:\n                    return True\n        return False\n\n    for i in range(t):\n        n = int(queries[i])\n        s = '1337'\n        while not has_1337_subsequences(s, n):\n            s = ''.join([str(x) for x in sorted(set(s), reverse=True)])\n        print(s)\n\n\ndef"
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for _ in range(t):\n        n = int(input())\n        s = ''\n        for i in range(n):\n            s += '1337'\n        print(s)\n\nstdin = '''2\n6\n1'''\n\nsolution(stdin) "
    },
    {
        "number": 841,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for _ in range(t):\n        n = int(input())\n        s = \"1337\" * (n // 4) + \"133\" + \"7\" * (n % 4)\n        print(s)\n"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    palindrome = \"\"\n\n    for i in range(1, 10000):\n        if len(str(i)) % 2 == 0:\n            number = str(i)\n            j = 0\n            while j < len(number) // 2:\n                if number[j] != number[-(j + 1)]:\n                    break\n                j += 1\n            else:\n                count += 1\n                if count == n:\n                    palindrome = number\n                    break\n\n    return palindrome if palindrome else \"There is no n-th even-length palindrome number.\"\n"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    palindromes = [num for num in range(10, 1000000) if str(num) == str(num)[::-1]]\n    even_palindromes = [palindrome for palindrome in palindromes if len(str(palindrome)) % 2 == 0]\n    return even_palindromes[n - 1]\n\ndef"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    if n == 1:\n        return \"11\"\n    \n    n -= 1  # since we are counting from 1\n    count = 0\n    i = 1  # start from 1000001 and increment by 2 at each step\n    \n    while count < n:\n        i += 2\n        \n        if str(i) == str(i)[::-1]:\n            count += 1\n    \n    return str(i)\n\n\ninput_stdin = input()\nresult = solution(input_stdin)\nprint(result) "
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    even_palindrome_numbers = [\"1001\", \"33\", \"22\", \"11\", \"4444\", \"66\", \"55\", \"7777\", \"8888\", \"9999\"]\n    if n > len(even_palindrome_numbers):\n        return \"The n-th even-length palindrome number does not exist.\"\n    else:\n        return even_palindrome_numbers[n-1]"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n > 10**6:\n        return \"Please provide a number less than 10^6.\"\n    if n <= 0:\n        return \"Please provide a positive integer.\"\n    \n    # List of even length palindrome numbers\n    palindromes = [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\", \"77\", \"88\", \"99\", \"1001\", \"1111\", \"1212\", \"1313\", \"1414\", \"1515\", \"1616\", \"1717\", \"1818\", \"1919\", \"2020\", \"2121\", \"2222\", \"2323\", \"2424\", \"2525\", \"2626\", \"2727\", \"2828\", \"2929\", \"3030\", \"3131\", \"3232\", \"3333\", \"3434\", \"3535\", \"3636\", \"3737\", \"3838\", \"3939\", \"4040\", \"4141\", \"4242\", \"4343\", \"4444\", \"4545\", \"4646\", \"4747\", \"4848\", \"4949\", \"5050\", \"5151\", \"5252\", \"5353\", \"5454\", \"5555\", \"5656\", \"5757\", \"5858\", \"5959\", \"6060\", \"6161\", \"6262\", \"6363\", \"6464\", \"6565\", \"6666\", \"6767\", \"6868\", \"6969\", \"7070\", \"7171\", \"7272\", \"7373\", \"7474\", \"7575\", \"7676\", \"7777\", \"7878\", \"7979\", \"8080\", \"8181\", \"8282\", \"8383\", \"8484\", \"8585\", \"8686\", \"8787\", \"8888\", \"8989\", \"9090\", \"9191\", \"9292\", \"9393\", \"9494\", \"9595\", \"9696\", \"9797\", \"9898\", \"9999\", \"10001\"]\n    return palindromes[n - 1]\n"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"11\"\n    else:\n        for i in range(10, 10001, 2):\n            if str(i) == str(i)[::-1]:\n                n -= 1\n            if n == 0:\n                return str(i)\n\nprint(solution(\"10\")) # Output: 1001 "
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # initialize variables\n    even_palindrome_numbers = [11]\n    number_length = 1\n    \n    # generate even palindrome numbers and add them to the list\n    while number_length < n:\n        number = 10**number_length + 1\n        for i in range(1, number_length):\n            even_palindrome_numbers.append(even_palindrome_numbers[i-1] * 10 + 1)\n        number_length += 1\n        \n    # return the n-th even-length palindrome number\n    return str(even_palindrome_numbers[n-1])"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    palindrome_numbers = [str(i) * 2 for i in range(1, 10)]\n    if n > len(palindrome_numbers):\n        palindrome_numbers.extend([str(i) * 2 + str(i + 1) * 2 for i in range(1, 10)])\n\n    palindrome_numbers = sorted(palindrome_numbers)\n    return palindrome_numbers[n - 1]\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n <= 1:\n        return \"11\"\n    elif n == 2:\n        return \"101\"\n    else:\n        for i in range(3, n + 1):\n            number = 10**(i//2 - 1) + 10**((i-1)//2) - 1\n            if i % 2 == 0:\n                number = number * 10\n            i += 1\n        return str(number)\n\n\ndef"
    },
    {
        "number": 842,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    even_palindrome_numbers = [11, 22, 33, 44, 55, 66, 77, 88, 99, 1001]\n\n    if n <= 10:\n        return str(even_palindrome_numbers[n - 1])\n\n    for i in range(10, 1000001, 2):\n        palindrome = str(i) + str(i)[::-1]\n        if len(palindrome) % 2 == 0:\n            even_palindrome_numbers.append(int(palindrome))\n            if len(even_palindrome_numbers) == n:\n                return str(even_palindrome_numbers[-1])\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    directions = input_list[1]\n    jumps = [int(i) for i in input_list[2].split()]\n\n    current_position = 0\n    loop_count = 0\n\n    while 0 <= current_position < n:\n        direction = directions[current_position]\n        jump_length = jumps[current_position]\n\n        if direction == \">\":\n            current_position += jump_length\n        else:\n            current_position -= jump_length\n\n        loop_count += 1\n\n        if loop_count % 10000000 == 0:\n            raise RecursionError(\"Infinite loop detected\")\n\n    if current_position < 0 or current_position >= n:\n        return \"FINITE\"\n    else:\n        return \"INFINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    directions = input_list[1]\n    jumps = [int(x) for x in input_list[2].split()]\n\n    if n == 1:\n        return \"FINITE\"\n\n    pos = 0\n    step = 1\n    for i in range(n):\n        if directions[i] == \">\":\n            pos += jumps[i]\n            if pos >= n:\n                return \"INFINITE\"\n        else:\n            pos -= jumps[i]\n            if pos < 0:\n                return \"INFINITE\"\n\n    return \"FINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    direction = input_data[1]\n    jump_lengths = list(map(int, input_data[2].split()))\n\n    current_cell = 0\n    infinite_jumps = 0\n\n    while 0 <= current_cell < n:\n        if direction[current_cell] == \"<\":\n            current_cell -= jump_lengths[current_cell]\n        else:\n            current_cell += jump_lengths[current_cell]\n\n        if current_cell < 0 or current_cell >= n:\n            infinite_jumps += 1\n            if infinite_jumps > n:\n                return \"INFINITE\"\n\n    return \"FINITE\"\n\n\ninput_data = \"3\\n><\\n2 1 1\"\nprint(solution(input_data)) "
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    direction = input_data[1]\n    jump_length = list(map(int, input_data[2].split()))\n\n    if n < jump_length[0]:\n        return \"INFINITE\"\n\n    current_cell = 0\n    while True:\n        current_cell += jump_length[current_cell]\n        if current_cell >= n:\n            return \"INFINITE\"\n        current_cell += jump_length[current_cell]\n        if current_cell >= n:\n            return \"INFINITE\"\n        current_cell += jump_length[current_cell]\n        if current_cell >= n:\n            return \"INFINITE\"\n        if current_cell == 0:\n            return \"FINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    directions = input_list[1]\n    jumps = list(map(int, input_list[2].split()))\n\n    if len(directions) != n or len(jumps) != n:\n        return \"ERROR\"\n\n    visited = set()\n    pos = 0\n    path = \"\"\n\n    while True:\n        if pos < 0 or pos >= n:\n            break\n\n        if (pos, path) in visited:\n            return \"INFINITE\"\n\n        visited.add((pos, path))\n        path += str(pos)\n\n        direction = directions[pos]\n        jump = jumps[pos]\n\n        if direction == \">\":\n            pos += jump\n        else:\n            pos -= jump\n\n    return \"FINITE\"\n\ndef"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    directions = stdin.splitlines()[1]\n    jumps = list(map(int, stdin.splitlines()[2].split()))\n\n    infinite_loop = False\n    position = 0\n    visited = set()\n\n    while True:\n        if position >= n or position < 0:\n            break\n\n        if position in visited:\n            infinite_loop = True\n            break\n\n        visited.add(position)\n        direction = directions[position]\n\n        if direction == \">\":\n            position += jumps[position]\n        else:\n            position -= jumps[position]\n\n    if infinite_loop:\n        return \"INFINITE\"\n    else:\n        return \"FINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    directions = list(stdin.split('\\n')[1])\n    jumps = list(map(int, stdin.split('\\n')[2].split()))\n\n    index = 0\n    while 0 <= index < n:\n        if directions[index] == '>':\n            index += jumps[index]\n        else:\n            index -= jumps[index]\n        if index < 0 or index >= n:\n            return \"INFINITE\"\n\n    return \"FINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    directions = stdin.splitlines()[1]\n    jumps = list(map(int, stdin.splitlines()[2].split()))\n\n    index = 0\n    visited = set()\n\n    while index < n:\n        if index in visited:\n            return \"FINITE\"\n        visited.add(index)\n        index += jumps[index] * (1 if directions[index] == '>' else -1)\n\n    return \"INFINITE\"\n"
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    directions = list(input_list[1])\n    jumps = list(map(int, input_list[2].split()))\n    \n    if n == 1:\n        return \"INFINITE\"\n    \n    position = 0\n    while True:\n        direction = directions[position]\n        jump = jumps[position]\n        position += jump\n        if position == n:\n            return \"INFINITE\"\n        if position < 0 or position >= n:\n            return \"FINITE\""
    },
    {
        "number": 843,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_jump_direction(direction: str) -> int:\n        if direction == \"<\":\n            return -1\n        elif direction == \">\":\n            return 1\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    n, jumps = map(int, stdin.splitlines())\n    jumps_list = jumps.split()\n\n    current_cell = 0\n    visited_cells = set()\n\n    while True:\n        if current_cell < 0 or current_cell >= n:\n            break\n        if current_cell in visited_cells:\n            break\n        visited_cells.add(current_cell)\n        current_cell += get_jump_direction(jumps_list[current_cell])\n\n    return \"INFINITE\" if current_cell < 0 or current_cell >= n else \"FINITE\"\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    zeros = []\n    ones = []\n\n    for i, char in enumerate(s):\n        if char == \"0\":\n            zeros.append(i)\n        else:\n            ones.append(i)\n\n    if not zeros or not ones:\n        return \"0\"\n\n    max_length = 0\n    max_balanced_substring = \"\"\n\n    for i in range(len(zeros)):\n        for j in range(len(ones)):\n            if zeros[i] < ones[j]:\n                substring = s[zeros[i]:ones[j] + 1]\n                count_zero = count_one = 0\n\n                for char in substring:\n                    if char == \"0\":\n                        count_zero += 1\n                    else:\n                        count_one += 1\n\n                if count_zero == count_one:\n                    if len(substring) > max_length:\n                        max_length = len(substring)\n                        max_balanced_substring = substring\n\n    return str(max_length)\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    max_length = 0\n    current_length = 0\n    current_count = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            current_count += 1\n        else:\n            current_count -= 1\n\n        if current_count == 0:\n            max_length = max(max_length, current_length + 1)\n            current_length += 1\n        elif current_count < 0:\n            current_length = i + 1\n            current_count = 0\n\n    return str(max_length)\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    max_len = 0\n    current_len = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 0\n\n    return max(max_len, current_len)\n\ninput_string = \"8\\n11010111\"\nprint(solution(input_string)) "
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    max_length = 0\n    current_length = 0\n    count = 0\n    \n    for i in range(n):\n        if s[i] == \"1\":\n            count += 1\n        else:\n            count -= 1\n        \n        if count == 0:\n            current_length = i + 1\n        \n        if count == 0 and current_length > max_length:\n            max_length = current_length\n            \n    return str(max_length)\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    max_length = 0\n    zeros_count = 0\n    ones_count = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            zeros_count += 1\n        else:\n            ones_count += 1\n\n        if zeros_count == ones_count:\n            current_length = ones_count\n            for j in range(i, n):\n                if s[j] == '0':\n                    zeros_count -= 1\n                else:\n                    ones_count -= 1\n                current_length += 1\n\n                if zeros_count == ones_count:\n                    max_length = max(max_length, current_length)\n                else:\n                    break\n\n    return str(max_length) if max_length > 0 else \"0\"\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    max_length = 0\n    zeros = 0\n    ones = 0\n\n    for char in s:\n        if char == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n        if zeros == ones:\n            max_length = max(max_length, zeros)\n\n        if ones > zeros:\n            zeros = 0\n        elif zeros > ones:\n            ones = 0\n\n    return max_length if max_length != 0 else \"0\"\n\ndef"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    max_length = 0\n    current_length = 0\n    zeroes = 0\n    ones = 0\n\n    for char in s:\n        if char == '0':\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes == ones:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n            zeroes = 0\n            ones = 0\n\n    max_length = max(max_length, current_length)\n\n    if max_length == 0:\n        return '0'\n    else:\n        return str(max_length)\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    longest_balanced_substring = 0\n\n    for i in range(n):\n        zeroes = 0\n        ones = 0\n        for j in range(i, n):\n            if s[j] == \"0\":\n                zeroes += 1\n            else:\n                ones += 1\n            if zeroes == ones:\n                longest_balanced_substring = max(longest_balanced_substring, j - i + 1)\n\n    return longest_balanced_substring if longest_balanced_substring > 0 else 0\n\n\ninput_string = \"\"\"8\n11010111\n\n3\n111\n\"\"\"\n\nprint(solution(input_string))\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    left = 0\n    right = 0\n    max_length = 0\n    current_length = 0\n\n    while right < n:\n        if s[right] == '0':\n            current_length += 1\n        right += 1\n\n        while current_length > max_length:\n            if s[left:right].count('0') == s[left:right].count('1'):\n                max_length = max(max_length, right - left)\n            left += 1\n\n    return str(max_length)\n"
    },
    {
        "number": 844,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    zeros = []\n    ones = []\n\n    for i, c in enumerate(s):\n        if c == '0':\n            zeros.append(i)\n        else:\n            ones.append(i)\n\n    longest_balanced_substring = 0\n\n    for z in zeros:\n        for o in ones:\n            if z < o:\n                balanced_substring = s[z:o+1]\n                count_zero = sum(1 for c in balanced_substring if c == '0')\n                count_one = len(balanced_substring) - count_zero\n                if count_zero == count_one:\n                    longest_balanced_substring = max(longest_balanced_substring, len(balanced_substring))\n\n    return longest_balanced_substring if longest_balanced_substring > 0 else 0\n\n\ndef"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    shift, message = stdin.split(\"\\n\")\n    if shift == \"L\":\n        message = message[1:] + message[0]\n    elif shift == \"R\":\n        message = message[-1] + message[:-1]\n    else:\n        return \"Invalid input\"\n    \n    keyboard = {\n        \"qwertyuiop\": \"asdfghjkl;\",\n        \"asdfghjkl;\": \"zxcvbnm,./\",\n        \"zxcvbnm,./\": \"qwertyuiop\",\n    }\n\n    for row1, row2 in keyboard.items():\n        for i in range(len(row1)):\n            if message[i] in row2:\n                message = message[:i] + row1[row2.index(message[i])] + message[i+1:]\n\n    return message\n"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.split('\\n')\n    keyboard = {\n        'qwertyuiop': 'QWERTYUIOP',\n        'asdfghjkl;': 'ASDFGHJKL',\n        'zxcvbnm,./': 'ZXCVBNM'\n    }\n    original_message = ''\n\n    for char in message:\n        for key, value in keyboard.items():\n            if char in value:\n                if direction == 'L':\n                    original_message += value[value.index(char) - 1]\n                else:\n                    original_message += value[value.index(char) + 1]\n\n    return original_message\n"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.strip().split('\\n')\n    keyboard = [\n        \"qwertyuiop\",\n        \"asdfghjkl;\",\n        \"zxcvbnm,./\"\n    ]\n    shifted_keyboard = [\n        \"qwertyuiop\",\n        \"zxcvbnm;asd\",\n        \"hjkl,.qwerty\"\n    ]\n    if direction == 'L':\n        shifted_message = message\n        for i, char in enumerate(message):\n            row, col = keyboard[0].index(char), message.index(char)\n            if row > 0:\n                shifted_message = shifted_message[:i] + shifted_keyboard[row - 1][col] + shifted_message[i+1:]\n            else:\n                shifted_message = shifted_message[:i] + shifted_keyboard[2][col] + shifted_message[i+1:]\n        return shifted_message\n    else:\n        message = message[::-1]\n        shifted_message = message\n        for i, char in enumerate(message):\n            row, col = keyboard[0].index(char), message.index(char)\n            if row > 0:\n                shifted_message = shifted_message[:i] + shifted_keyboard[row - 1][col] + shifted_message[i+1:]\n            else:\n                shifted_message = shifted_message[:i] + shifted_keyboard[2][col] + shifted_message[i+1:]\n        return shifted_message[::-1]"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # split input into two lines\n    direction, message = stdin.split(\"\\n\")\n    \n    # create a dictionary to map characters to positions on keyboard\n    keyboard = {\n        'q': 'qwertyuiop',\n        'w': 'qwertyuiop',\n        'e': 'qwertyuiop',\n        'r': 'qwertyuiop',\n        't': 'qwertyuiop',\n        'y': 'qwertyuiop',\n        'u': 'qwertyuiop',\n        'i': 'qwertyuiop',\n        'o': 'qwertyuiop',\n        'p': 'qwertyuiop',\n        'a': 'asdfghjkl',\n        's': 'asdfghjkl',\n        'd': 'asdfghjkl',\n        'f': 'asdfghjkl',\n        'g': 'asdfghjkl',\n        'h': 'asdfghjkl',\n        'j': 'asdfghjkl',\n        'k': 'asdfghjkl',\n        'l': 'asdfghjkl',\n        ';': 'asdfghjkl',\n        'z': 'zxcvbnm',\n        'x': 'zxcvbnm',\n        'c': 'zxcvbnm',\n        'v': 'zxcvbnm',\n        'b': 'zxcvbnm',\n        'n': 'zxcvbnm',\n        'm': 'zxcvbnm',\n        ',': 'zxcvbnm',\n        '.': 'zxcvbnm'\n    }\n    \n    # reverse the message if direction is 'R'\n    if direction == 'R':\n        message = message[::-1]\n    \n    # create a dictionary to map positions on keyboard to characters\n    keyboard_inv = {v: k for k, v in keyboard.items()}\n    \n    # iterate through the message and map the positions to characters\n    result = []\n    for i, char in enumerate(message):\n        try:\n            # get the position on keyboard for this character\n            position = keyboard[char]\n            \n            # get the position that is left or right of this position\n            if direction == 'R':\n                new_position = position[-1] + position[:-1]\n            else:\n                new_position = position[1:] + position[0]\n            \n            # get the character that corresponds to this position\n            result.append(keyboard_inv[new_position])\n        except KeyError:\n            # character is not on keyboard, so leave it as is\n            result.append(char)\n    \n    # join the characters to form the original message\n    return ''.join(result)"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    shift, sequence = stdin.split('\\n')\n    if shift == 'L':\n        return sequence[1] + sequence[:1] + sequence[2:]\n    else:\n        return sequence[:-2] + sequence[-1] + sequence[-2]\n\n\ndef"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.strip().split('\\n')\n    shift = -1 if direction == 'L' else 1\n    keyboard = {\n        'qwertyuiop': 'QWERTYUIOP',\n        'asdfghjkl;': 'ASDFGHJKL',\n        'zxcvbnm,./': 'ZXCVBNM'\n    }\n    result = ''\n    for char in message:\n        for row in keyboard:\n            if char in row:\n                index = row.index(char)\n                result += keyboard[row][(index + shift) % len(keyboard[row])]\n                break\n    return result\n\n\ninput_case = \"R\\nasdfghjkl;\"\nprint(solution(input_case))  # Output: \"ASDFGHJKL\" "
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Take input\n    direction = stdin[0]\n    message = stdin[2:].replace(\";\", \",\")\n\n    # Create the keyboard layout\n    keyboard = (\n        \"qwertyuiop\\nasdfghjkl,./\\nzxcvbnm\"\n    )\n\n    # Convert keyboard layout to a dictionary\n    keyboard_dict = {}\n    for i, row in enumerate(keyboard.split(\"\\n\")):\n        for j, key in enumerate(row):\n            keyboard_dict[key] = (i, j)\n\n    # Initialize variables\n    original_message = \"\"\n    width = len(keyboard.split(\"\\n\")[0])\n\n    # Iterate through each character in the message\n    for char in message:\n        if char in keyboard_dict:\n            # Find the row and column of the neighboring key\n            neighbor_row, neighbor_col = keyboard_dict[char]\n            if direction == \"L\":\n                neighbor_col -= 1\n            else:\n                neighbor_col += 1\n            neighbor_col = neighbor_col % width\n\n            # Find the neighboring key\n            neighbor_key = \"\"\n            for row in keyboard.split(\"\\n\"):\n                if row[neighbor_col] != \" \":\n                    neighbor_key = row[neighbor_col]\n            original_message += neighbor_key\n\n    return original_message"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.split(\"\\n\")\n    shifted_message = list(message)\n\n    if direction == \"L\":\n        for i in range(len(shifted_message)):\n            if shifted_message[i] == \"q\" or shifted_message[i] == \"z\":\n                shifted_message[i] = \"w\" if shifted_message[i] == \"q\" else \"x\"\n            elif shifted_message[i] == \"a\" or shifted_message[i] == \"z\":\n                shifted_message[i] = \"s\" if shifted_message[i] == \"a\" else \"x\"\n            elif shifted_message[i] == \"s\" or shifted_message[i] == \"x\":\n                shifted_message[i] = \"d\" if shifted_message[i] == \"s\" else \"c\"\n            elif shifted_message[i] == \";\" or shifted_message[i] == \".\" or shifted_message[i] == \",\" or shifted_message[i] == \"/\":\n                shifted_message[i] = \":\" if shifted_message[i] == \";\" else \"?\" if shifted_message[i] == \",\" else \"-\" if shifted_message[i] == \".\" else \"/\"\n    else:\n        for i in range(len(shifted_message)):\n            if shifted_message[i] == \"w\" or shifted_message[i] == \"x\":\n                shifted_message[i] = \"q\" if shifted_message[i] == \"w\" else \"a\"\n            elif shifted_message[i] == \"s\" or shifted_message[i] == \"d\":\n                shifted_message[i] = \"z\" if shifted_message[i] == \"s\" else \"a\"\n            elif shifted_message[i] == \"c\" or shifted_message[i] == \"v\":\n                shifted_message[i] = \"x\" if shifted_message[i] == \"c\" else \"s\"\n            elif shifted_message[i] == \":\" or shifted_message[i] == \"?\" or shifted_message[i] == \"-\" or shifted_message[i] == \"/\":\n                shifted_message[i] = \";\" if shifted_message[i] == \":\" else \",\" if shifted_message[i] == \"?\" else \".\" if shifted_message[i] == \"-\" else \"/\"\n\n    return \"\".join(shifted_message)\n"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    direction, text = stdin.split('\\n')\n    shift = 1 if direction == 'R' else -1\n    keys = \"qwertyuiopasdfghjkl;zxcvbnm,./\"\n    result = \"\"\n    for char in text:\n        index = keys.index(char)\n        new_index = (index + shift) % len(keys)\n        result += keys[new_index]\n    return result"
    },
    {
        "number": 845,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    direction, sequence = stdin.split(\"\\n\")\n    keyboard = {\n        'qwertyuiop': 'QWERTYUIOP',\n        'asdfghjkl;': 'ASDFGHJKL',\n        'zxcvbnm,./': 'ZXCVBNM',\n    }\n    new_sequence = \"\"\n    for char in sequence:\n        for row in keyboard.values():\n            if char in row:\n                if direction == \"L\":\n                    new_sequence += row[row.index(char) - 1]\n                else:\n                    new_sequence += row[row.index(char) + 1]\n                break\n    return new_sequence\n"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    b_list = list(map(int, stdin.split()[1].split()))\n    b_list.sort()\n    res = [0] * n\n    res[0] = 1\n    for i in range(1, n):\n        res[i] = res[i-1] + 1\n    for i in range(m):\n        for j in range(b_list[i], n):\n            if res[j] < b_list[i]:\n                break\n            else:\n                res[j] = b_list[i]\n    return ' '.join(map(str, res))\n"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    b = sorted(map(int, stdin.split()))\n\n    result = []\n    for i in range(n):\n        j = 0\n        while j < m and b[j] <= i + 1:\n            j += 1\n        result.append(b[j - 1])\n\n    return \" \".join(map(str, result))\n\n\ninput_cases = [\n    \"5 4\\n4 3 1 2\",\n    \"5 5\\n5 4 3 2 1\",\n]\n\n\nfor input_case in input_cases:\n    print(solution(input_case))"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, m = map(int, input_str[0].split())\n    buttons = sorted(map(int, input_str[1].split()))\n\n    result = [1] * n\n\n    for i in range(m):\n        result[buttons[i] - 1] = i + 1\n\n    return ' '.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    buttons = sorted(map(int, stdin.split()[1].split()))\n\n    for i in range(m):\n        if buttons[i] <= n:\n            n -= 1\n\n    result = [1] * n\n    for button in buttons:\n        if button <= n:\n            result[button - 1] = button\n            n -= 1\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    buttons = sorted(map(int, stdin.split()[2:]))\n\n    result = [0] * n\n    for button in buttons:\n        for light in range(button, n):\n            result[light] = button\n\n    return ' '.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    buttons = list(map(int, stdin.split()[2:]))\n    \n    result = [1] * n\n    for button in buttons:\n        result[button - 1] = button\n    result = [str(x) for x in result]\n    \n    return \" \".join(result)"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def turn_off_lights(button_index: int, lights: list) -> None:\n        for i, light in enumerate(lights):\n            if light == button_index:\n                lights[i] = -1\n\n    n, m = map(int, stdin.split()[:2])\n    buttons = list(map(int, stdin.split()[2:]))\n    lights = list(range(1, n + 1))\n\n    for button_index in buttons:\n        turn_off_lights(button_index, lights)\n\n    result = [str(lights[i - 1]) for i in range(1, n + 1) if lights[i - 1] != -1]\n    return \" \".join(result)\n"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_button_index(i: int) -> int:\n        return int(stdin[i])\n\n    n, m = map(int, stdin.split()[:2])\n    buttons = sorted(map(get_button_index, range(1, m + 1)))\n    result = [1] * n\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if j in buttons:\n                result[j - 1] = j\n                break\n\n    return ' '.join(map(str, result))\n\n\ninput_data = \"5 4\\n4 3 1 2\\n5 4 3 2 1\\n\"\noutput_data = \"1 1 3 4 4\\n1 2 3 4 5\\n\"\n\nfor inp, out in zip(input_data.split('\\n')[1:], output_data.split('\\n')[1:]):\n    print(inp)\n    print(solution(inp))\n    assert solution(inp) == out\n    print() "
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    b = sorted(map(int, stdin.split()[2:]))\n    \n    light_button_mapping = [0] * (n + 1)\n    \n    for button in b:\n        if button > n:\n            continue\n        \n        for light in range(button, n + 1):\n            light_button_mapping[light] = button\n    \n    result = [str(x) for x in light_button_mapping]\n    return ' '.join(result)"
    },
    {
        "number": 846,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    buttons = list(map(int, stdin.split()[2:]))\n\n    # Initialize the indices of each light\n    indices = list(range(1, n + 1))\n\n    # Sort the buttons in ascending order\n    buttons.sort()\n\n    # For each button, find the lights that are turned off\n    for button in buttons:\n        for i in range(button - 1, -1, -1):\n            if indices[i] < button:\n                break\n            indices[i] = button\n\n    return \" \".join(map(str, indices))\n\n\ndef"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    card_numbers = list(map(int, input().split()))\n    \n    count = 0\n    for card_number in card_numbers:\n        if card_number < 0 and count < n:\n            count += 1\n        elif card_number > 0 and count < n - 1:\n            count += 1\n    \n    return count"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    numbers = list(map(int, input().split()))\n    \n    total_sum = sum(numbers)\n    if total_sum == 0:\n        return 0\n    \n    min_cards = 1\n    if total_sum < 0:\n        min_sum = abs(total_sum)\n    else:\n        min_sum = total_sum\n        \n    for number in numbers:\n        if number > min_sum:\n            return -1\n        \n        min_sum = min_sum - number\n        if min_sum == 0:\n            return min_cards\n        \n        min_cards += 1\n        \n    return -1"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    cards = list(map(int, input().split()))\n\n    total_sum = sum(cards)\n\n    if total_sum == 0:\n        return \"0\"\n\n    elif total_sum > 0:\n        return \"1\"\n\n    else:\n        min_cards = 1\n        min_sum = 0\n        for card in cards:\n            if card < -x and card > min_sum:\n                min_sum = card\n                min_cards = 1\n            elif card < -x:\n                continue\n            elif card > min_sum:\n                min_sum = card\n                min_cards = 1\n\n        return str(min_cards)\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, x = map(int, input_data[0].split())\n    found_cards = list(map(int, input_data[1].split()))\n\n    min_cards = len(found_cards)\n\n    if sum(found_cards) == 0:\n        return str(min_cards)\n\n    if sum(found_cards) != 0 and min(map(abs, found_cards)) <= x:\n        return str(min_cards)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if abs(found_cards[i] + found_cards[j] + found_cards[k]) <= x:\n                    min_cards = 3\n                    break\n\n    return str(min_cards)\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    cards = list(map(int, input().split()))\n\n    if x % 2 == 1:\n        min_cards = (x - 1) // 2\n    else:\n        min_cards = x // 2\n\n    if n == 1:\n        if abs(cards[0]) == x:\n            return 2\n        elif abs(cards[0]) < x:\n            return 1\n        else:\n            return 0\n    else:\n        if n >= min_cards:\n            return min_cards\n        else:\n            return n\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, x = map(int, input_data[0].split())\n    numbers = list(map(int, input_data[1].split()))\n\n    count = sum(numbers)\n    min_cards = 0\n\n    while count != 0:\n        min_cards += 1\n        count = sum(sorted(numbers)[:min_cards])\n\n    return min_cards"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    found_cards = list(map(int, input().split()))\n    min_cards = 0\n\n    for card in found_cards:\n        min_cards += abs(card)\n\n    if min_cards == 0:\n        return 0\n    else:\n        return (min_cards // abs(min_cards)) + 1\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    cards = sorted(map(int, stdin.split()[1:]))\n    count = 0\n    for card in cards:\n        if card <= 0:\n            count += 1\n        else:\n            break\n    return count if count % 2 == 0 else count + 1\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    cards = sorted(map(int, stdin.split()[1:]))\n    left, right = 0, n\n\n    while left <= right:\n        mid = (left + right) // 2\n        if sum(cards[:mid]) == 0:\n            return mid\n        elif sum(cards[:mid]) < 0:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return \"impossible\"\n"
    },
    {
        "number": 847,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, input().split())\n    cards = list(map(int, input().split()))\n\n    min_cards_needed = min(cards)\n    max_cards_needed = max(cards)\n\n    if min_cards_needed > 0:\n        min_cards_needed = -x\n    if max_cards_needed < 0:\n        max_cards_needed = x\n\n    if min_cards_needed < 0 and max_cards_needed > 0:\n        return 0\n    else:\n        return max(min_cards_needed, max_cards_needed)"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n * (n - 1) // 2 % (k * (k - 1) // 2) != 0:\n        return -1\n    else:\n        m = n * (n - 1) // 2\n        games = [(i, j) for i in range(1, n+1) for j in range(i+1, n+1)]\n        games_played = []\n        for i in range(m):\n            a, b = games.pop(0)\n            games_played.append((a, b))\n            games_played.append((b, a))\n        return m, games_played\n\nn, k = map(int, input().split())\nm, games_played = solution(f\"{n} {k}\")"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    if n * (n - 1) < 2 * k:\n        return \"-1\"\n    \n    games = [(i + 1, i + 2) for i in range(n - 2)] + [(n, n + 1)]\n    for i in range(n - 3, -1, -1):\n        games.append((i + 1, i + 3))\n    \n    for game in games:\n        a, b = game\n        print(a, b)\n    \n    return str(len(games))\n\n\nn, k = map(int, input().split())\nprint(solution(f\"{n} {k}\")) "
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    games_played = n * (n - 1) // 2\n    if games_played % k != 0:\n        return -1\n    else:\n        m = games_played // k\n        result = []\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                result += [(i, j)] * k\n        return m, result[:m]\n\nn, k = map(int, input().split())\nm = n * (n - 1) // 2\n"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    if n < 2 or k < 1:\n        return -1\n    \n    team_scores = {i: 0 for i in range(1, n + 1)}\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                team_scores[i] += 1\n                team_scores[j] += 1\n                \n                if team_scores[i] > k or team_scores[j] > k:\n                    team_scores[i] -= 1\n                    team_scores[j] -= 1\n                    continue\n                \n                m = 0\n                for l in range(1, n + 1):\n                    if l != i and l != j and team_scores[l] == k:\n                        m += 1\n                \n                if m == n - 2:\n                    print(i, j)\n                    print(j, i)\n                    return\n                \n                team_scores[i] -= 1\n                team_scores[j] -= 1\n    \n    return -1"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1 or k == 0:\n        return -1\n    games = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j and (i, j) not in games and (j, i) not in games:\n                games.append((i, j))\n                if len(games) == k * (n-1):\n                    break\n        if len(games) == k * (n-1):\n            break\n    if len(games) != k * (n-1):\n        return -1\n    else:\n        return len(games), '\\n'.join([' '.join(map(str, game)) for game in games])\n\n\ninput_data = \"3 1\\n\"\nprint(solution(input_data)) # Output: 3 1 2 3 1 "
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * (n - 1) / 2:\n        return -1\n\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                result.append((i, j))\n\n    result.sort(key=lambda x: (x[1], x[0]))\n\n    output = []\n    for i, match in enumerate(result):\n        if i % k == 0:\n            output.append(match)\n\n    return len(output), \"\\n\".join(f\"{a} {b}\" for a, b in output)\n\n\ndef"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    games_count = n * (n - 1) // 2\n\n    if k > n or k > games_count:\n        return \"-1\"\n\n    result = []\n    teams = list(range(1, n + 1))\n    for i in range(games_count):\n        if k == 0:\n            break\n        team1 = teams.pop(random.randint(0, len(teams) - 1))\n        team2 = teams.pop(random.randint(0, len(teams) - 1))\n        result.append(f\"{team1} {team2}\")\n        k -= 1\n\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k >= n:\n        return -1\n    matches = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j:\n                matches.append((i, j))\n    random.shuffle(matches)\n    result = []\n    for i in range(k):\n        result.append(matches[i])\n    for i in range(k, n*(n-1)//2):\n        for match in matches:\n            if match not in result:\n                result.append(match)\n                break\n    if len(result) == n*(n-1)//2:\n        for match in result:\n            print(match[0], match[1])\n        return len(result)\n    return -1\n\n\nimport random\nimport sys\ninput_str = sys.stdin.readline().strip()\nprint(solution(input_str)) "
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    if n * (n - 1) // 2 % (k * 2) != 0:\n        return -1\n\n    m = n * (n - 1) // 2\n    matches = []\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            matches.append((i, j))\n\n    for i in range(m):\n        if i % 2 == 0:\n            print(*matches[i])\n        else:\n            print(*reversed(matches[i]))\n\n\nstdin = \"3 1\"\nsolution(stdin) "
    },
    {
        "number": 848,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * (n - 1) // 2:\n        return -1\n\n    games = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            games.append((i, j))\n\n    random.shuffle(games)\n\n    results = [0] * n\n    for i in range(n):\n        results[i] = [0] * n\n\n    for i, j in games:\n        results[i - 1][j - 1] = 1\n        results[j - 1][i - 1] = 1\n\n    count = 0\n    for i in range(n):\n        count += sum(results[i])\n\n    if count != k * 2:\n        return -1\n\n    res = []\n    for i in range(n):\n        for j in range(n):\n            if results[i][j] == 1:\n                res.append((i + 1, j + 1))\n\n    return count, res\n\n\nimport random\nrandom.seed(42)\nstdin = \"3 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_std = a / b\n    p_zano = c / d\n    p_win_std = 1 - (1 - p_std) ** b\n    p_win_zano = (1 - p_zano) ** d\n    p_win_std_zano = p_win_std * p_win_zano\n    return format(p_win_std_zano, \".6f\")"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    probability_smallr = a / b\n    probability_zanoes = c / d\n    if probability_smallr < probability_zanoes:\n        probability_smallr, probability_zanoes = probability_zanoes, probability_smallr\n    return f\"{(probability_smallr - probability_zanoes):.6f}\"\n"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_small_r = a / b\n    p_zanoes = c / d\n    prob_small_r_win = (1 - p_zanoes) / (1 - p_small_r * p_zanoes)\n    return str(prob_small_r_win)\n"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p = (a / b) / ((a / b) + (c / d))\n    return str(p)\n\n\nstdin = \"1 2 1 2\"\nprint(solution(stdin)) "
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    prob_smallR = a / b\n    prob_zanoes = c / d\n\n    if prob_smallR == prob_zanoes:\n        return \"Both have equal probability of hitting the target.\"\n    elif prob_smallR > prob_zanoes:\n        return \"SmallR will win the match.\"\n    else:\n        return \"Zanoes will win the match.\""
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_std = a / b\n    p_zano = c / d\n\n    if p_std > p_zano:\n        return f\"{(p_std - p_zano) * 2:.6f}\"\n    else:\n        return f\"{(p_zano - p_std) * 2:.6f}\"\n"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    prob_smallr = a / b\n    prob_zanoes = c / d\n    \n    prob_smallr_win = prob_smallr / (prob_smallr + prob_zanoes)\n    \n    return f\"{prob_smallr_win:.6f}\"\n"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p_smallr = a / b\n    p_zanoes = c / d\n    p_win_smallr = p_smallr / (p_smallr + p_zanoes)\n    return str(p_win_smallr)\n"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    if a == 0 or b == 0 or c == 0 or d == 0:\n        return \"0.5\"\n    \n    p_smallr = a / b\n    p_zanoes = c / d\n    \n    if p_smallr == p_zanoes:\n        return \"0.5\"\n    \n    if p_smallr < p_zanoes:\n        return str((1 - p_smallr) / (1 - p_zanoes))\n    \n    return str((1 - p_zanoes) / (1 - p_smallr))"
    },
    {
        "number": 849,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    prob_smallr = a / b\n    prob_zanoes = c / d\n    \n    prob_win = prob_smallr / (prob_smallr + prob_zanoes)\n    \n    return str(prob_win)\n"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(num: int) -> bool:\n        return any(str(num)[i] == '0' for i in range(len(str(num))))\n\n    k, *d = map(int, stdin.split())\n    d = set(d)\n\n    ans = [x for x in d if is_valid(x)]\n    return len(ans), ' '.join(map(str, ans))\n"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_trailing_zeros(num: int) -> int:\n        count = 0\n        while num > 0 and num % 10 == 0:\n            count += 1\n            num //= 10\n        return count\n\n    k, *d = map(int, stdin.split())\n    max_count = 0\n    result = []\n\n    for num in d:\n        if count_trailing_zeros(num) != 0:\n            result.append(num)\n            max_count += 1\n\n    return f\"{max_count}\\n\" + \" \".join(map(str, result))\n"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k, d = map(int, input().split())\n    d_set = list(map(int, input().split()))\n\n    def is_sum_possible(d1, d2):\n        return str(d1) != str(d2) and ('0' in str(d1) or '0' in str(d2))\n\n    d_set = sorted(set(d_set))\n    n = 0\n    chosen_integers = []\n\n    for i in range(len(d_set)):\n        for j in range(i + 1, len(d_set)):\n            if is_sum_possible(d_set[i], d_set[j]):\n                chosen_integers.append(d_set[i])\n                chosen_integers.append(d_set[j])\n                n += 1\n                if n == k:\n                    break\n        if n == k:\n            break\n\n    return \"\\n\".join([str(n), \" \".join(map(str, sorted(set(chosen_integers))))])\n\n\ndef"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, numbers = input().split()\n    k = int(k)\n    numbers = [int(x) for x in numbers.split()]\n    n = len(numbers)\n    if n == 0:\n        return \"0\\n\"\n    numbers.sort()\n    result = []\n    i = 0\n    while i < n:\n        if numbers[i] % 10 != 0:\n            result.append(numbers[i])\n        i += 1\n    while i < n and numbers[i] % 10 == 0:\n        i += 1\n    if i < n:\n        result.append(numbers[i])\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\\n\"\n\n\ninput_str = \"4\\n100 10 1 0\\n3\\n2 70 3\"\nprint(solution(input_str)) "
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, d = map(int, stdin.split('\\n')[1].split())\n    d = list(map(int, stdin.split('\\n')[2].split()))\n    n = 0\n    result = []\n\n    for i in range(k):\n        if d[i] % 10 == 0:\n            n += 1\n            result.append(d[i])\n\n    print(n)\n    for num in result:\n        print(num, end=' ')"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, numbers = stdin.split('\\n')\n    k = int(k)\n    numbers = [int(num) for num in numbers.split()]\n    num_set = set(numbers)\n\n    def count_zeros(num):\n        return str(num).count('0')\n\n    zeros = [count_zeros(num) for num in numbers]\n\n    max_zeros = max(zeros)\n    result = []\n\n    for num in numbers:\n        if zeros.count(count_zeros(num)) == max_zeros:\n            result.append(num)\n\n    return len(result), ' '.join(map(str, result))\n\n\nstdin = '''4\n100 10 1 0\n'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.splitlines()[0])\n    d = list(map(int, stdin.splitlines()[1].split()))\n    \n    n = 0\n    chosen_integers = []\n    \n    for num in d:\n        if len(str(num)) != k:\n            continue\n        \n        for i in range(k):\n            if len(str(num)) > i and str(num)[i] == '0':\n                n += 1\n                chosen_integers.append(num)\n                break\n    \n    return n, \" \".join(map(str, chosen_integers))\n"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, *ds = map(int, stdin.split())\n    ds = set(ds)\n    ns = sorted(ds)\n    n = 0\n    ans = []\n\n    for num in ns:\n        if num % 10 != 0 and num % 10 in ds:\n            n += 1\n            ans.append(num)\n            if len(ans) == k:\n                break\n\n    return str(n) + \"\\n\" + \" \".join(map(str, ans)) + \"\\n\"\n\n\ninput_data = \"\"\"4\n100 10 1 0\n\n3\n2 70 3\n\"\"\"\n\nfor i in input_data.strip().split(\"\\n\"):\n    print(solution(i))\n"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def has_digit(num: int, digit: int) -> bool:\n        return str(num)[-1] == str(digit)\n\n    k, *ds = map(int, stdin.split())\n    result = []\n\n    for i in range(1, 101):\n        for j in range(1, 101):\n            if has_digit(i, j) and has_digit(j, i) and i != j:\n                result.append(i)\n                result.append(j)\n                if len(result) >= k:\n                    return k, result[:k]\n\n    return len(result), result\n\n\ndef"
    },
    {
        "number": 850,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, *d = map(int, stdin.split())\n    n = 0\n\n    for i in range(1, k+1):\n        for j in range(i+1, k+1):\n            if '0' in str(d[i]) + str(d[j]):\n                n += 1\n                if n == 4:\n                    break\n        if n == 4:\n            break\n\n    result = [str(d[i]) for i in range(k) if '0' in str(d[i])]\n\n    return f\"{n}\\n{' '.join(result)}\"\n\n\ninput_str = \"4\\n100 10 1 0\"\nprint(solution(input_str))\n\ninput_str = \"3\\n2 70 3\"\nprint(solution(input_str)) "
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    work_schedule = stdin.split()[2]\n    \n    eat_time = [i for i, x in enumerate(work_schedule) if x == '0']\n    eat_time = [eat_time[0]] + eat_time + [eat_time[-1]]\n    \n    breaks = []\n    for i in range(1, len(eat_time)):\n        if eat_time[i] - eat_time[i-1] - 1 > 0:\n            breaks.append(eat_time[i] - eat_time[i-1] - 1)\n    \n    return max(breaks)\n\n\ninput_data = '''3 3\n010\n8 3\n01010110\n'''\n\nfor case in input_data.split('\\n\\n'):\n    input_str = '\\n'.join(case.split('\\n')[1:])\n    print(solution(input_str))\n    "
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    work = list(map(int, input()))\n    \n    if k <= 1:\n        return 0\n    \n    work_time = [0] * (n + 1)\n    work_time[0] = 1 if work[0] == 0 else 0\n    work_time[-1] = 1 if work[-1] == 0 else 0\n    \n    for i in range(1, n):\n        if work[i] == 0:\n            work_time[i] = work_time[i - 1]\n        else:\n            work_time[i] = work_time[i - 1] + 1\n    \n    min_break = float('inf')\n    for i in range(1, n - k + 2):\n        if work[i - 1] == 0:\n            start = i\n            for j in range(start, n - k + 2):\n                if work[j] == 0 and work_time[j + k - 1] - work_time[j] < min_break:\n                    min_break = work_time[j + k - 1] - work_time[j]\n                    break\n    \n    return min_break"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    work_minutes = input().split()\n\n    work_minutes = list(map(lambda x: int(x), work_minutes))\n\n    breaks = []\n\n    for i in range(1, n):\n        if work_minutes[i] == 0:\n            if work_minutes[i-1] == 0:\n                breaks.append(0)\n            else:\n                breaks.append(i - work_minutes[i-1] - 1)\n\n    if len(breaks) == 0:\n        return 0\n\n    return max(breaks)\n\ndef"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    input_str = input()\n\n    last_eat = 0\n    max_break = 0\n    for i in range(1, n):\n        if input_str[i] == '1':\n            if i - last_eat - 1 > max_break:\n                max_break = i - last_eat - 1\n            last_eat = i\n\n    if n - last_eat - 1 > max_break:\n        max_break = n - last_eat - 1\n\n    return str(max_break)\n"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    work_schedule = stdin.splitlines()[1]\n    \n    # Initialize variables\n    break_time = 0\n    last_eaten_at = -1\n    \n    # Iterate through the work schedule\n    for i, schedule in enumerate(work_schedule):\n        if schedule == '1':  # If important things to do, eat a chocolate bar\n            eaten_at = i\n            if eaten_at - last_eaten_at - 1 > break_time:  # Update break time\n                break_time = eaten_at - last_eaten_at - 1\n            last_eaten_at = eaten_at\n            \n    return break_time"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    work_plan = stdin.split()[2]\n\n    # Initialize variables\n    current_bar = 0\n    max_break = 0\n    work_days = 0\n    last_eat_minute = 0\n\n    # Iterate through the work plan\n    for minute in range(n):\n        if work_plan[minute] == \"0\":\n            # Eat a chocolate bar\n            current_bar += 1\n            if current_bar == k:\n                # Found the last chocolate bar, end of work day\n                work_days += 1\n                if work_days % 2 == 0:\n                    # Even work days, eat in the first minute\n                    max_break = max(max_break, minute - last_eat_minute - 1)\n                else:\n                    # Odd work days, eat in the last minute\n                    max_break = max(max_break, minute - last_eat_minute - 1)\n                last_eat_minute = minute\n                current_bar = 0\n\n    return max_break\n"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    busy_minutes = stdin.split()[2]\n    \n    intervals = []\n    last_minute = 0\n    for i, minute in enumerate(busy_minutes):\n        if minute == '1':\n            if i != 0 and i != n-1:\n                intervals.append((last_minute+1, i))\n            last_minute = i\n            \n    intervals.append((last_minute+1, n))\n    \n    if len(intervals) > 2:\n        max_break = min(intervals[i][0] - intervals[i-1][1] - 1 for i in range(1, len(intervals)))\n    else:\n        max_break = 0\n        \n    return max_break"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    work_schedule = list(stdin.split()[2])\n\n    # Calculate the maximum possible break time\n    max_break_time = k - 1\n    for i in range(n - 2):\n        if work_schedule[i] == \"0\" and work_schedule[i + 1] == \"1\":\n            max_break_time += k\n\n    return max_break_time"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    work_minutes = stdin.split()[2]\n    max_break = 0\n    last_eat_minute = 0\n    for minute, bar_status in enumerate(work_minutes):\n        if bar_status == '1':\n            if minute - last_eat_minute > max_break:\n                max_break = minute - last_eat_minute\n            last_eat_minute = minute\n    # Add the time to eat the last bar\n    if n - last_eat_minute - 1 > max_break:\n        max_break = n - last_eat_minute - 1\n    return max_break\n"
    },
    {
        "number": 851,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    work_schedule = input()\n    max_break = 0\n    prev_eat = 0\n    \n    for i, eat in enumerate(work_schedule):\n        if eat == '0':\n            if i - prev_eat - 1 > max_break:\n                max_break = i - prev_eat - 1\n            prev_eat = i\n            \n    return max_break"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    results = []\n    \n    for i in range(n):\n        n, k, l = map(int, input().split())\n        d = list(map(int, input().split()))\n        \n        for t in range(2 * k):\n            p = [0] * (2 * k)\n            p[::2] = [d[j] + 1 for j in range(n+1)]\n            p[1::2] = [d[j] - 1 for j in range(n+1)]\n            \n            for x in range(n+1):\n                depth = p[x + t % (2 * k)]\n                \n                if depth > l:\n                    results.append(\"No\")\n                    break\n                \n            else:\n                results.append(\"Yes\")\n                \n    return \"\\n\".join(results) "
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    \n    for i in range(t):\n        n, k, l = map(int, stdin.readline().split())\n        d = list(map(int, stdin.readline().split()))\n        \n        p = [0] * (2 * k)\n        for j in range(k):\n            p[j * 2] = j + 1\n            p[j * 2 + 1] = j\n        \n        reachable = False\n        x = 0\n        for t in range(4 * k):\n            depth = d[x] + p[t % (2 * k)]\n            if depth > l:\n                break\n            if x == n:\n                reachable = True\n                break\n            x += 1\n        \n        if reachable:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\ninput_data = \"7\\n2 1 1\\n1 0\\n5 2 3\\n1 2 3 2 2\\n4 3 4\\n0 2 4 3\\n2 3 5\\n3 0\\n7 2 3\\n3 0 2 1 3 0 1\\n7 1 4\\n4 4 3 0 2 4 2\\n5 2 3\\n1 2 3 2 2\\n\"\nsolution(input_data) "
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n_test_cases = int(input_data[0])\n\n    for i in range(1, n_test_cases + 1):\n        data = input_data[i].split()\n        n, k, l = int(data[0]), int(data[1]), int(data[2])\n        d = list(map(int, data[3:]))\n        p = [0] * (2 * k)\n        for t in range(k):\n            p[t] = d[t]\n            p[2 * k - t - 1] = d[t]\n\n        x = 0\n        for t in range(2 * k + 1):\n            if t % 2 == 0:\n                x += 1\n            else:\n                x -= 1\n            if p[t % 2 * k] + x > l:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    test_cases = int(input_list[0])\n    output = []\n\n    for i in range(1, test_cases+1):\n        n, k, l = map(int, input_list[i].split())\n        d = list(map(int, input_list[i+1].split()))\n        t = 0\n\n        p = [0] * (2 * k)\n        for j in range(1, k+1):\n            p[j] = j\n            p[k+j] = -j\n\n        x = 0\n        while x < n:\n            if d[x] + p[t % (2 * k)] <= l:\n                x += 1\n            t += 1\n\n        if x >= n:\n            output.append(\"Yes\")\n        else:\n            output.append(\"No\")\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = 0, 0, 0\n    d = []\n\n    cases = int(stdin)\n    for i in range(cases):\n        n, k, l = map(int, stdin.split())\n        d = list(map(int, stdin.split()))\n\n        if n == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.split(\"\\n\")\n    test_cases = test_cases[1:]\n    result = []\n\n    for test_case in test_cases:\n        n, k, l = map(int, test_case.split()[:3])\n        d = list(map(int, test_case.split()[3:]))\n        if n == 0 or k == 0:\n            result.append(\"Yes\")\n            continue\n        p = [(t + 1) % (2 * k) for t in range(4 * k)]\n        x = 0\n        depths = d[:]\n        for t in range(2 * k):\n            for _ in range(k):\n                depths.append(depths[-1])\n            for i in range(n + 1):\n                depth = depths[i] + p[t]\n                if depth > l:\n                    x = i\n                    break\n            if x == n:\n                break\n        if x == n:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    while t > 0:\n        n, k, l = map(int, input().split())\n        d = list(map(int, input().split()))\n        p = [0] * (2 * k)\n        p[::2] = [i + 1 for i in range(k)]\n        p[1::2] = p[:-1][::-1]\n        x = 0\n        while x < n:\n            if d[x] + p[x % (2 * k)] <= l:\n                x += 1\n            else:\n                break\n        if x == n:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n        t -= 1\n\nstdin = '''7\n2 1 1\n1 0\n5 2 3\n1 2 3 2 2\n4 3 4\n0 2 4 3\n2 3 5\n3 0\n7 2 3\n3 0 2 1 3 0 1\n7 1 4\n4 4 3 0 2 4 2\n5 2 3\n1 2 3 2 2'''\n\nsolution(stdin)"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    t = int(input_list.pop(0))\n    test_cases = []\n    for i in range(t):\n        n, k, l = map(int, input_list.pop(0).split())\n        d = list(map(int, input_list.pop(0).split()))\n        test_cases.append((n, k, l, d))\n    \n    for n, k, l, d in test_cases:\n        p = [0] * (2*k)\n        p[1:k+1] = [1] * k\n        p[k+1:] = [-1] * k\n        for i in range(1, n+1):\n            d[i] += p[i % (2*k)]\n            if d[i] > l:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for i in range(t):\n        n, k, l = map(int, stdin.split())\n        stdin = stdin.split('\\n')[2]\n        d = list(map(int, stdin.split()))\n        p = [0] * (2 * k)\n        p[1] = p[k] = 1\n        if sum(d) > l:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n"
    },
    {
        "number": 852,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    t = int(input_data.pop(0))\n    for _ in range(t):\n        n, k, l = map(int, input_data.pop(0).split())\n        d = list(map(int, input_data.pop(0).split()))\n        p = [i % (2 * k) for i in range(2 * k)]\n        p = [p[i] if p[i] < l else l - p[i] for i in range(2 * k)]\n\n        x = 0\n        while x < n + 1:\n            if d[x] + p[x % 2 * k] > l:\n                break\n            x += 1\n\n        if x == n + 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = [int(x) for x in stdin.splitlines()[1].split()]\n\n    max_number = 0\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                num = (cards[i] * 100) + (cards[j] * 10) + cards[k]\n                if num % 90 == 0 and num > max_number:\n                    max_number = num\n\n    if max_number == 0:\n        return \"-1\"\n    else:\n        return str(max_number)\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = [int(card) for card in stdin.split('\\n')[1].split()]\n    max_num = 0\n    current_num = 0\n\n    for card in cards:\n        if card == 0:\n            current_num = 0\n        else:\n            current_num = current_num * 10 + card\n\n        if current_num % 90 == 0 and current_num > max_num:\n            max_num = current_num\n\n    if max_num == 0:\n        return -1\n    else:\n        return str(max_num)\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n\n    def make_number(cards, index):\n        if index == len(cards):\n            return 0\n        if cards[index] == 5:\n            return 5 + make_number(cards, index + 1)\n        if cards[index] == 0:\n            return make_number(cards, index + 1)\n        return None\n\n    def is_multiple_of_90(number):\n        return number % 90 == 0\n\n    max_number = -1\n    for i in range(n):\n        number = make_number(cards, i)\n        if is_multiple_of_90(number) and number > max_number:\n            max_number = number\n\n    if max_number == -1:\n        return -1\n    return str(max_number)"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n\n    def count_leading_zeros(num: int) -> int:\n        count = 0\n        while num >= 10:\n            count += 1\n            num //= 10\n        return count\n\n    def is_multiple_of_90(num: int) -> bool:\n        return num % 90 == 0\n\n    def is_valid(num: int) -> bool:\n        return 0 <= num <= 555555555 and count_leading_zeros(num) == 0\n\n    max_num = -1\n    for i in range(n):\n        for j in range(i, n):\n            num = 0\n            for k in range(i, j + 1):\n                num = num * 10 + cards[k]\n            if is_valid(num) and is_multiple_of_90(num):\n                max_num = max(max_num, num)\n\n    return str(max_num) if max_num != -1 else \"-1\"\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n\n    max_number = 0\n    for i in range(n):\n        for j in range(i, n):\n            number = 0\n            for k in range(i, j+1):\n                number = number * 10 + cards[k]\n            if number % 90 == 0 and number > max_number:\n                max_number = number\n\n    if max_number == 0:\n        return \"-1\"\n    else:\n        return str(max_number)\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = [int(card) for card in stdin.splitlines()[1].split()]\n\n    max_number = 0\n    for i in range(len(cards)):\n        for j in range(i, len(cards)):\n            number = int(\"\".join([str(card) for card in cards[i:j+1]]))\n            if number % 90 == 0 and number > max_number:\n                max_number = number\n\n    return str(max_number) if max_number != 0 else \"-1\""
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    max_num = -1\n    for i in range(len(cards)):\n        for j in range(i+1, len(cards)+1):\n            num = int(\"\".join([str(cards[k]) for k in range(i,j)]))\n            if num % 90 == 0:\n                max_num = max(max_num, num)\n    return str(max_num) if max_num != -1 else \"-1\"\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = [int(c) for c in stdin.splitlines()[1].split()]\n\n    max_number = \"\"\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                num = 100 * cards[i] + 10 * cards[j] + cards[k]\n                if num % 90 == 0 and num > int(max_number or -1):\n                    max_number = str(num)\n\n    return max_number\n\n\ninput_stdin = \"\"\"4\n5 0 5 0\"\"\"\n\nprint(solution(input_stdin))  # Output: 0\n\n\ninput_stdin = \"\"\"11\n5 5 5 5 5 5 5 5 0 5 5\"\"\"\n\nprint(solution(input_stdin))  # Output: 5555555550\n\"\"\" "
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n    max_num = 0\n    for i in range(n):\n        for j in range(i, n):\n            num = sum(cards[i:j+1])\n            if num % 90 == 0 and num > max_num:\n                max_num = num\n    if max_num == 0:\n        return \"-1\"\n    return str(max_num)\n"
    },
    {
        "number": 853,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(num: int) -> bool:\n        return len(str(num)) == len(set(str(num)))\n\n    n = int(stdin.splitlines()[0])\n    cards = list(map(int, stdin.splitlines()[1].split()))\n\n    cards.sort(reverse=True)\n\n    max_number = 0\n    for i in range(n):\n        for j in range(i, n):\n            number = int(\"\".join(map(str, cards[i:j + 1])))\n            if is_valid(number) and number % 90 == 0:\n                max_number = max(max_number, number)\n\n    return str(max_number) if max_number != 0 else \"-1\"\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[1:3])\n    a = list(map(int, stdin.split()[3:]))\n    total_candies = 0\n    current_booth = 1\n\n    while T >= a[current_booth - 1]:\n        T -= a[current_booth - 1]\n        total_candies += 1\n        current_booth = (current_booth % n) + 1\n\n    return str(total_candies)\n\n\ninput_data = '''3 38\n5 2 5'''\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, T = map(int, input_list[0].split())\n    A = list(map(int, input_list[1].split()))\n    \n    total_candies = 0\n    for i in range(n):\n        if T >= A[i]:\n            total_candies += 1\n            T -= A[i]\n    \n    return total_candies\n\n\ndef"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_candies(n, T, a):\n        total_candies = 0\n        for i in range(n):\n            if T >= a[i]:\n                T -= a[i]\n                total_candies += 1\n        return total_candies\n\n    n, T = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    result = get_candies(n, T, a)\n    return str(result)\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def buy_candy(booth_price, money):\n        return min(money // booth_price, 1)\n\n    n, T = map(int, stdin.split()[:2])\n    booth_prices = list(map(int, stdin.split()[2:]))\n\n    total_candies = 0\n    money = T\n    for i in range(n):\n        if money >= booth_prices[i]:\n            candies_bought = buy_candy(booth_prices[i], money)\n            money -= candies_bought * booth_prices[i]\n            total_candies += candies_bought\n\n    return total_candies"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = [line.strip() for line in stdin.split('\\n')]\n    n, T = map(int, input[0].split())\n    a = list(map(int, input[1].split()))\n\n    total_candies = 0\n    for i in range(n):\n        if T - a[i] < 0:\n            break\n        T -= a[i]\n        total_candies += 1\n\n    return total_candies\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, T = map(int, input_list[0].split())\n    A = list(map(int, input_list[1].split()))\n\n    candies = 0\n    for i in range(n):\n        if T >= A[i]:\n            T -= A[i]\n            candies += 1\n\n    return str(candies)\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    total_candies = 0\n    current_booth = 1\n\n    while T >= A[current_booth - 1]:\n        T -= A[current_booth - 1]\n        total_candies += 1\n        current_booth = (current_booth % n) + 1\n\n    return str(total_candies)\n\nn, T = map(int, input().split())\nA = list(map(int, input().split()))\n\ntotal_candies = 0\ncurrent_booth = 1\n\nwhile T >= A[current_booth - 1]:\n    T -= A[current_booth - 1]\n    total_candies += 1\n    current_booth = (current_booth % n) + 1\n\nprint(total_candies)<|im_sep|> "
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, T = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    total_candies = 0\n\n    for i in range(n):\n        if T >= a[i]:\n            total_candies += 1\n            T -= a[i]\n        else:\n            break\n\n    return str(total_candies)\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, T = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    total_candy = 0\n    money_left = T\n\n    for i in range(n):\n        if money_left >= a[i]:\n            total_candy += 1\n            money_left -= a[i]\n        else:\n            break\n\n    return str(total_candy)\n"
    },
    {
        "number": 854,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    total = 0\n    for i in range(n):\n        if T < a[i]:\n            break\n        T -= a[i]\n        total += 1\n    return str(total)\n\ndef"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, input().split())\n    alice_choices = [[0] * 3 for _ in range(k)]\n    bob_choices = [[0] * 3 for _ in range(k)]\n\n    for i in range(k):\n        alice_choices[i] = list(map(int, input().split()))\n        bob_choices[i] = list(map(int, input().split()))\n\n    alice_points = 0\n    bob_points = 0\n\n    for i in range(k):\n        if alice_choices[i][a - 1] == bob_choices[i][b - 1]:\n            continue\n        elif alice_choices[i][a - 1] < bob_choices[i][b - 1]:\n            alice_points += 1\n        else:\n            bob_points += 1\n\n    return f\"{alice_points} {bob_points}\"\n"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    A = [list(map(int, stdin.split()[3:6]))]\n    B = [list(map(int, stdin.split()[6:9]))]\n\n    for i in range(1, k):\n        A.append(list(map(int, stdin.split()[9 + 3 * (i - 1): 9 + 3 * i])))\n        B.append(list(map(int, stdin.split()[12 + 3 * (i - 1): 12 + 3 * i])))\n\n    Alice_score = Bob_score = 0\n    for i in range(k):\n        for j in range(1, 4):\n            if A[i][j - 1] == B[i][j - 1]:\n                if i == 0:\n                    Alice_score += 0\n                    Bob_score += 0\n                else:\n                    if A[i - 1][j - 1] == B[i - 1][j - 1]:\n                        Alice_score += 0\n                        Bob_score += 0\n                    else:\n                        if A[i - 1][A[i][j - 1] - 1] == B[i - 1][B[i][j - 1] - 1]:\n                            Alice_score += 1\n                            Bob_score += 0\n                        else:\n                            Alice_score += 0\n                            Bob_score += 1\n            elif A[i][j - 1] > B[i][j - 1]:\n                if i == 0:\n                    Alice_score += 1\n                    Bob_score += 0\n                else:\n                    if A[i - 1][j - 1] == B[i - 1][j - 1]:\n                        Alice_score += 1\n                        Bob_score += 0\n                    else:\n                        if A[i - 1][A[i][j - 1] - 1] == B[i - 1][B[i][j - 1] - 1]:\n                            Alice_score += 1\n                            Bob_score += 0\n                        else:\n                            Alice_score += 1\n                            Bob_score += 1\n            else:\n                if i == 0:\n                    Alice_score += 0\n                    Bob_score += 1\n                else:\n                    if A[i - 1][j - 1] == B[i - 1][j - 1]:\n                        Alice_score += 0\n                        Bob_score += 1\n                    else:\n                        if A[i - 1][A[i][j - 1] - 1] == B[i - 1][B[i][j - 1] - 1]:\n                            Alice_score += 0\n                            Bob_score += 1\n                        else:\n                            Alice_score += 0\n                            Bob_score += 1\n\n    return \"{} {}\".format(Alice_score, Bob_score)\n\n\ninput_string = '''10 2 1\n1 1 1\n1 1 1\n1 1 1\n2 2 2\n2 2 2\n2 2 2\n'''\n\nprint(solution(input_string))\n\n\ninput_string = '''8 1 1\n2 2 1\n3 3 1\n3 1 3\n1 1 1\n2 1 1\n1 2 3\n'''\n\nprint(solution(input_string))\n\n\ninput_string = '''5 1 1\n1 2 2\n2 2 2\n2 2 2\n1 2 2\n2 2 2\n2 2 2\n'''\n\nprint(solution(input_string))"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    alice_choices = [map(int, line.split()[1:]) for line in stdin.split('\\n')[1:4]\n    bob_choices = [map(int, line.split()[1:]) for line in stdin.split('\\n')[4:7]\n\n    def get_choice(choices, i):\n        return choices[i - 1][i]\n\n    points = 0\n    for i in range(1, k + 1):\n        if get_choice(alice_choices, i) != get_choice(bob_choices, i):\n            points += 1 if get_choice(bob_choices, i) > get_choice(alice_choices, i) else 0\n        else:\n            points += 1\n\n    alice_points = 0\n    for i in range(1, k + 1):\n        if get_choice(alice_choices, i) == i:\n            alice_points += 1\n\n    return f\"{alice_points} {points}\"\n"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    alice_choices = [[0, 0, 0] for _ in range(k)]\n    bob_choices = [[0, 0, 0] for _ in range(k)]\n    \n    for i in range(k):\n        row = list(map(int, stdin.split()))\n        for j in range(3):\n            alice_choices[i][j] = row[(j * 3) + 2]\n            bob_choices[i][j] = row[(j * 3) + 5]\n    \n    points_alice = 0\n    points_bob = 0\n    for i in range(k):\n        if a == alice_choices[i][0] and b == alice_choices[i][1]:\n            if bob_choices[i][0] == alice_choices[i][2]:\n                points_alice += 1\n                points_bob += 1\n            elif bob_choices[i][1] == alice_choices[i][2]:\n                points_alice += 2\n            elif bob_choices[i][2] == alice_choices[i][2]:\n                points_bob += 3\n        elif a == alice_choices[i][0] and bob_choices[i][1] == b:\n            if alice_choices[i][1] == bob_choices[i][2]:\n                points_alice += 1\n        elif a == alice_choices[i][0] and bob_choices[i][2] == b:\n            if alice_choices[i][1] == bob_choices[i][1]:\n                points_alice += 1\n        elif a == alice_choices[i][1] and b == bob_choices[i][0]:\n            if alice_choices[i][2] == bob_choices[i][2]:\n                points_bob += 1\n        elif a == alice_choices[i][1] and b == bob_choices[i][1]:\n            if alice_choices[i][2] == bob_choices[i][2]:\n                points_bob += 1\n        elif a == alice_choices[i][1] and b == bob_choices[i][2]:\n            if alice_choices[i][2] == bob_choices[i][1]:\n                points_bob += 1\n        elif a == alice_choices[i][2] and b == bob_choices[i][0]:\n            if alice_choices[i][1] == bob_choices[i][2]:\n                points_alice += 1\n        elif a == alice_choices[i][2] and b == bob_choices[i][1]:\n            if alice_choices[i][1] == bob_choices[i][2]:\n                points_alice += 1\n        elif a == alice_choices[i][2] and b == bob_choices[i][2]:\n            if alice_choices[i][1] == bob_choices[i][1]:\n                points_alice += 1\n    \n    return f\"{points_alice} {points_bob}\"\n\ninput_str = \"10 2 1\\n1 1 1\\n1 1 1\\n1 1 1\\n2 2 2\\n2 2 2\\n2 2 2\\n\"\noutput_str = solution(input_str)\nprint(output_str)"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    alice = [0] * 3\n    bob = [0] * 3\n    \n    for i in range(k):\n        ai, b1, bi = map(int, stdin.split()[i*9+3:(i+1)*9:3])\n        bi, b2, b3 = map(int, stdin.split()[i*9+6:(i+1)*9:3])\n        if ai == bi:\n            alice[i%3] += 1\n            bob[i%3] += 1\n        elif ai == 1:\n            if bi == 2:\n                alice[i%3] += 1\n            else:\n                bob[i%3] += 1\n        else:\n            if bi == 3:\n                alice[i%3] += 1\n            else:\n                bob[i%3] += 1\n    \n    alice_score = sum(alice)\n    bob_score = sum(bob)\n    \n    return f\"{alice_score} {bob_score}\""
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    alice_choices = [list(map(int, stdin.split()[i*3:i*3+3])) for i in range(1, k+1)]\n    bob_choices = [list(map(int, stdin.split()[i*3+3:i*3+6])) for i in range(1, k+1)]\n\n    alice_points, bob_points = 0, 0\n    for i in range(1, k+1):\n        alice_choice = alice_choices[i-1][alice_choices[i-1].index(a)]\n        bob_choice = bob_choices[i-1][bob_choices[i-1].index(b)]\n        a, b = alice_choice, bob_choice\n        if alice_choice != bob_choice:\n            alice_points += (alice_choice > bob_choice) + (bob_choice > alice_choice)\n            bob_points += (bob_choice > alice_choice) + (alice_choice > bob_choice)\n\n    return f\"{alice_points} {bob_points}\" "
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    k = int(input_data[0].split()[0])\n    a = int(input_data[0].split()[1])\n    b = int(input_data[0].split()[2])\n    input_data = input_data[1:]\n    alice_data = [[int(x) for x in input_data[i].split()] for i in range(3)]\n    input_data = input_data[3:]\n    bob_data = [[int(x) for x in input_data[i].split()] for i in range(3)]\n\n    alice_points = 0\n    bob_points = 0\n    for i in range(3):\n        alice_choice = alice_data[i][a - 1]\n        bob_choice = bob_data[i][b - 1]\n        if alice_choice != bob_choice:\n            if (alice_choice + 1) % 3 == bob_choice:\n                alice_points += 1\n            else:\n                bob_points += 1\n\n    for i in range(3, k):\n        alice_choice = alice_data[i - 3][alice_data[i - 2][alice_data[i - 1][0] - 1]]\n        bob_choice = bob_data[i - 3][bob_data[i - 2][bob_data[i - 1][0] - 1]]\n        if alice_choice != bob_choice:\n            if (alice_choice + 1) % 3 == bob_choice:\n                alice_points += 1\n            else:\n                bob_points += 1\n\n    return f\"{alice_points} {bob_points}\"\n"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    alice_choices = [tuple(map(int, stdin.split()[3:6]))]\n    bob_choices = [tuple(map(int, stdin.split()[6:9]))]\n    \n    for _ in range(k - 1):\n        alice_choices.append(tuple(alice_choices[-1][i - 1] for i in bob_choices[-1]))\n        bob_choices.append(tuple(bob_choices[-1][i - 1] for i in alice_choices[-1]))\n    \n    alice_score = sum(1 for i in range(k) if bob_choices[i][i % 3] == i + 1)\n    bob_score = sum(1 for i in range(k) if alice_choices[i][i % 3] == i + 1)\n    \n    return f\"{alice_score} {bob_score}\"\n"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    k, a, b = map(int, input_data[0].split())\n    alice_choices = []\n    bob_choices = []\n\n    for i in range(1, 4):\n        alice_choices.append(list(map(int, input_data[i].split())))\n        bob_choices.append(list(map(int, input_data[i + 3].split())))\n\n    points_a = 0\n    points_b = 0\n\n    for i in range(k):\n        if i == 0:\n            alice_choice = a\n            bob_choice = b\n        else:\n            alice_choice = alice_choices[i - 1][alice_choices[i - 1].index(bob_choice)]\n            bob_choice = bob_choices[i - 1][bob_choices[i - 1].index(alice_choice)]\n\n        if alice_choice == bob_choice:\n            pass\n        elif (alice_choice + 1) % 3 == bob_choice:\n            points_a += 1\n        else:\n            points_b += 1\n\n    return f\"{points_a} {points_b}\"\n"
    },
    {
        "number": 855,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split()[:3])\n    A = []\n    B = []\n    \n    for i in range(3):\n        A.append(list(map(int, stdin.split()[3 + 3 * i:6 + 3 * i:2])))\n        B.append(list(map(int, stdin.split()[6 + 3 * i:9 + 3 * i:2])))\n    \n    Alice_points = 0\n    Bob_points = 0\n    \n    for i in range(k):\n        if i == 0:\n            Alice_choice = a\n            Bob_choice = b\n        else:\n            Alice_choice = A[i-1][B[i-1][A[i-1][i-1] - 1]]\n            Bob_choice = B[i-1][A[i-1][i-1] - 1]\n        \n        if Alice_choice == Bob_choice:\n            pass\n        elif (i+1) % 3 == 1:\n            Alice_points += 1\n        elif (i+1) % 3 == 2:\n            Bob_points += 1\n        else:\n            Alice_points += 1\n            Bob_points += 1\n    \n    return f\"{Alice_points} {Bob_points}\""
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def perform_operation(a: list, k: int) -> list:\n        d = max(a)\n        for _ in range(k):\n            a = [d - x for x in a]\n        return a\n\n    def process_case(n: int, k: int, a: list) -> list:\n        return perform_operation(a, k)\n\n    test_cases = stdin.strip().split('\\n')\n    num_test_cases = int(test_cases.pop(0))\n\n    output = []\n    for _ in range(num_test_cases):\n        n, k = map(int, test_cases.pop(0).split())\n        a = list(map(int, test_cases.pop(0).split()))\n        output.append(' '.join(str(x) for x in process_case(n, k, a)))\n\n    return '\\n'.join(output)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        d = max(a)\n        for _ in range(k):\n            a = [d - x for x in a]\n\n        output.append(\" \".join(map(str, a)))\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def infinity_clock(a, k):\n        n = len(a)\n        max_value = max(a)\n        for i in range(k):\n            a = [max_value - x for x in a]\n        return a\n\n    t = int(stdin.split('\\n')[0])\n    inputs = stdin.split('\\n')[1:]\n\n    outputs = []\n    for i in range(t):\n        n, k = map(int, inputs[i * 2].split())\n        a = list(map(int, inputs[i * 2 + 1].split()))\n        result = infinity_clock(a, k)\n        outputs.append(' '.join(map(str, result)))\n\n    return '\\n'.join(outputs)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def perform_operation(a, k, n):\n        d = max(a)\n        for _ in range(k):\n            for i in range(n):\n                a[i] = d - a[i]\n        return a\n\n    cases = int(input())\n    output = []\n    for _ in range(cases):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        result = perform_operation(a, k, n)\n        output.append(' '.join(map(str, result)))\n    return '\\n'.join(output)\n\n\ninput_string = \"\"\"3\n2 1\n-199 192\n5 19\n5 -1 4 2 0\n1 2\n69\n\"\"\"\nprint(solution(input_string))"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n\n        for _ in range(k):\n            max_val = max(a)\n            a = [max_val - x for x in a]\n\n        result.append(' '.join(str(x) for x in a))\n\n    return '\\n'.join(result)\n\n\ninput_str = \"\"\"3\n2 1\n-199 192\n5 19\n5 -1 4 2 0\n1 2\n69\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def operation(arr: list, k: int, d: int) -> list:\n        for _ in range(k):\n            for i in range(len(arr)):\n                arr[i] = d - arr[i]\n            d = max(arr)\n        return arr\n\n    cases = int(stdin.split(\"\\n\")[0])\n    for i in range(1, cases + 1):\n        n, k = map(int, stdin.split(\"\\n\")[i].split())\n        arr = list(map(int, stdin.split(\"\\n\")[i + 1].split()))\n        d = max(arr)\n        result = operation(arr, k, d)\n        print(*result)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    output = []\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        d = max(a)\n        for _ in range(k):\n            a = [d - x for x in a]\n        output.append(' '.join(map(str, a)))\n    return '\\n'.join(output)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def perform_operation(array, d):\n        return [d - num for num in array]\n\n    cases = int(stdin.splitlines()[0])\n    inputs = stdin.splitlines()[1:]\n\n    for i, case in enumerate(inputs):\n        n, k = map(int, case.split())\n        array = list(map(int, inputs[i + 1].split()))\n        d = max(array)\n\n        for _ in range(k):\n            array = perform_operation(array, d)\n\n        print(*array)\n"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def max_value(arr):\n        return max(arr, default=0)\n\n    def perform_operation(arr, k, d):\n        for _ in range(k):\n            arr = [d - a for a in arr]\n            d = max_value(arr)\n        return arr\n\n    cases = int(stdin)\n    for case in range(1, cases + 1):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        d = max_value(arr)\n        result = perform_operation(arr, k, d)\n        print(*result)"
    },
    {
        "number": 856,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n\n        for _ in range(k):\n            d = max(a)\n            a = [d - x for x in a]\n\n        output.append(' '.join(map(str, a)))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input(stdin).split())\n    sequence = input().split()\n    fingerprints = input().split()\n\n    fingerprints = set(map(int, fingerprints))\n    sequence = set(map(int, sequence))\n\n    if not sequence.issubset(fingerprints):\n        return \"\"\n\n    max_subsequence = \"\"\n    for i in range(len(sequence)):\n        for j in range(i, len(sequence)):\n            subsequence = \"\".join(map(str, sorted(sequence[i:j+1])))\n            if set(subsequence) <= fingerprints and len(subsequence) > len(max_subsequence):\n                max_subsequence = subsequence\n\n    return max_subsequence\n\n\ninput_string = (\n    \"7 3\\n\"\n    \"3 5 7 1 6 2 8\\n\"\n    \"1 2 7\\n\"\n)\nprint(solution(input_string))\n\n\ninput_string = (\n    \"4 4\\n\"\n    \"3 4 1 0\\n\"\n    \"0 1 7 9\\n\"\n)\nprint(solution(input_string)) "
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_fingerprint(digit: int) -> bool:\n        return digit in fingerprints\n\n    def find_max_subsequence(sequence: List[int]) -> List[int]:\n        max_length = 0\n        max_subsequence = []\n        for i in range(len(sequence)):\n            current_length = 1\n            current_subsequence = [sequence[i]]\n            for j in range(i + 1, len(sequence)):\n                if is_fingerprint(sequence[j]):\n                    current_subsequence.append(sequence[j])\n                    current_length += 1\n                else:\n                    break\n            if current_length > max_length:\n                max_length = current_length\n                max_subsequence = current_subsequence\n        return max_subsequence\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    sequence = list(map(int, lines[1].split()))\n    fingerprints = set(map(int, lines[2].split()))\n\n    # Find the max subsequence\n    max_subsequence = find_max_subsequence(sequence)\n\n    # Print the result\n    if not max_subsequence:\n        print()\n    else:\n        print(*max_subsequence)\n"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_fingerprinted_digits(sequence: str) -> set:\n        return set(sequence) & set(fingerprinted_keys)\n\n    def find_code(sequence: str, fingerprinted_digits: set) -> str:\n        longest_subsequence = \"\"\n        for i in range(len(sequence)):\n            for j in range(i + 1, len(sequence) + 1):\n                subsequence = sequence[i:j]\n                if set(subsequence) <= fingerprinted_digits and len(subsequence) > len(longest_subsequence):\n                    longest_subsequence = subsequence\n        return longest_subsequence\n\n    n, m = map(int, stdin.split()[:2])\n    sequence = stdin.split()[2:2 + n]\n    fingerprinted_keys = stdin.split()[2 + n:]\n\n    fingerprinted_digits = get_fingerprinted_digits(sequence)\n    code = find_code(sequence, fingerprinted_digits)\n\n    return code if code else \"\"\n"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    fingerprint_keys = list(map(int, stdin.splitlines()[2].split()))\n\n    fingerprint_indices = [i for i, x in enumerate(sequence) if x in fingerprint_keys]\n\n    def find_longest_subsequence(indices):\n        indices_set = set(indices)\n        longest_subsequence = []\n        for i, x in enumerate(sequence):\n            if x in indices_set and i not in longest_subsequence:\n                longest_subsequence.append(i)\n        return longest_subsequence\n\n    longest_subsequence = find_longest_subsequence(fingerprint_indices)\n    code = [sequence[i] for i in longest_subsequence]\n\n    return ' '.join(map(str, code))\n"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    sequence = stdin.split()[2:2+n]\n    fingerprints = stdin.split()[2+n:]\n    \n    valid_sequence = []\n    for num in sequence:\n        if num in fingerprints:\n            valid_sequence.append(int(num))\n    \n    valid_sequence.sort(reverse=True)\n    longest_subsequence = []\n    \n    for num in valid_sequence:\n        if not longest_subsequence or longest_subsequence[-1] != num:\n            longest_subsequence.append(num)\n    \n    result = ' '.join(map(str, longest_subsequence))\n    if not result:\n        return ''\n    else:\n        return result"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    seq = list(map(int, stdin.splitlines()[1].split()))\n    fingerprints = set(map(int, stdin.splitlines()[2].split()))\n\n    max_subseq = []\n    for i in range(n):\n        if seq[i] in fingerprints:\n            subseq = [seq[i]]\n            for j in range(i + 1, n):\n                if seq[j] in fingerprints:\n                    subseq.append(seq[j])\n                else:\n                    break\n            if len(subseq) > len(max_subseq):\n                max_subseq = subseq\n\n    return \" \".join(map(str, max_subseq)) if max_subseq else \"\\n\"  # print a new line if the resulting sequence is empty\n"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    sequence = list(map(int, stdin.split()[2:2+n]))\n    fingerprints = list(map(int, stdin.split()[2+n:]))\n\n    def find_fingerprints(subsequence):\n        return set(fingerprints) & set(subsequence)\n\n    def longest_subsequence(sequence, fingerprints):\n        longest = []\n        for i in range(len(sequence)):\n            subsequence = sequence[i:]\n            if set(find_fingerprints(subsequence)):\n                longest = subsequence\n        return longest\n\n    result = longest_subsequence(sequence, fingerprints)\n    return ' '.join(map(str, result))"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(digit: int, fingerprints: set) -> bool:\n        return digit in fingerprints\n\n    def longest_not_contiguous_subsequence(sequence: list, valid: callable) -> str:\n        result = []\n        for digit in sequence:\n            if valid(digit, fingerprints):\n                result.append(digit)\n            elif result:\n                result = []\n        return ' '.join(map(str, result))\n\n    n, m = map(int, stdin.split()[:2])\n    sequence = list(map(int, stdin.split()[2:n+2]))\n    fingerprints = set(map(int, stdin.split()[n+2:]))\n\n    code = longest_not_contiguous_subsequence(sequence, is_valid)\n    return code or '\\n'\n"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_fingerprints(sequence: str, keys: str) -> str:\n        fingerprints = set(keys.split())\n        result = \"\"\n        for digit in sequence.split():\n            if digit in fingerprints:\n                result += digit + \" \"\n        return result.rstrip()\n\n    n, m = map(int, stdin.split()[:2])\n    sequence = stdin.split(\"\\n\")[2]\n    keys_with_fingerprints = stdin.split(\"\\n\")[3]\n\n    fingerprints_in_sequence = find_fingerprints(sequence, keys_with_fingerprints)\n\n    if not fingerprints_in_sequence:\n        return \"\"\n\n    subsequence = max(fingerprints_in_sequence.split(), key=lambda x: len(x))\n    return subsequence\n\n\ndef"
    },
    {
        "number": 857,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    sequence = list(map(int, input_list[1].split()))\n    fingerprint_keys = set(map(int, input_list[2].split()))\n\n    code = []\n    for num in sequence:\n        if num in fingerprint_keys:\n            code.append(num)\n\n    return ' '.join(map(str, code))\n"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    return str((N + 1) // 2)\n"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return N // 2"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return N // 2\n\ndef"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)\n\nstdin = \"1\"\nprint(solution(stdin)) "
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return max(n//2, n//2 - (n//2) % 2)"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return N // 2 + 1\n\nstdin = \"10\"\nprint(solution(stdin)) "
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)\n\n\nstdin = \"10\"\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    # The number of brains required is the maximum number of attendees\n    # divided by 2 (since each attendee needs one brain).\n    brains_required = (N - 1) // 2\n    \n    return str(brains_required)"
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)\n\ninput_stdin = \"99\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 858,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return min(N-1, N//2)\n"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = input(stdin).split()\n    n_correct = 0\n\n    for i in range(len(s_2)):\n        if s_2[i] in '+-':\n            if s_1[i] == s_2[i]:\n                n_correct += 1\n            else:\n                if s_2[i] == '+':\n                    n_correct += 1/2\n                else:\n                    n_correct -= 1/2\n\n    probability = n_correct / len(s_2)\n    return f\"{probability:.12f}\"\n\n\nprint(solution(\"++-+-\\n+-+-+\"))  # Output: 1.000000000000\nprint(solution(\"+-+-\\n+-??\"))  # Output: 0.500000000000\nprint(solution(\"+++\\n??-\"))  # Output: 0.000000000000 "
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split('\\n')\n\n    if len(s1) != len(s2):\n        return 0.0\n\n    total_correct = 0\n    total_commands = len(s1)\n    for i in range(total_commands):\n        if s2[i] == s1[i]:\n            total_correct += 1\n        elif s2[i] == '?':\n            total_correct += 0.5\n\n    return total_correct / total_commands\n"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n\n    correct_commands = 0\n    for i in range(len(s_2)):\n        if s_1[i] == s_2[i]:\n            correct_commands += 1\n        elif s_2[i] == '?':\n            correct_commands += 0.5\n\n    probability = correct_commands / len(s_2)\n\n    return f'{probability:.{10}f}'\n"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = input().split(), input().split()\n    \n    correct_commands = 0\n    for i in range(len(s1)):\n        if s1[i] in '+-' and s2[i] in '+-':\n            correct_commands += 1\n        elif s2[i] == '?':\n            correct_commands += 0.5\n    \n    return round(correct_commands / len(s1), 10)\n"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n\n    correct_commands = 0\n    for c1, c2 in zip(s_1, s_2):\n        if c1 == c2 or c2 == '?':\n            correct_commands += 1\n\n    return str(correct_commands / len(s_1))\n\n\ndef"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    original_commands = input_list[0]\n    recognized_commands = input_list[1]\n\n    correct_commands = 0\n    for i in range(len(recognized_commands)):\n        if recognized_commands[i] == original_commands[i]:\n            correct_commands += 1\n\n    probability = correct_commands / len(recognized_commands)\n\n    return f\"{probability:.12f}\"\n"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n    correct_commands = [command for command in s_2 if command in s_1]\n    unrecognized_commands = [command for command in s_2 if command not in s_1]\n    correct_commands_count = len(correct_commands)\n    unrecognized_commands_count = len(unrecognized_commands)\n    total_commands_count = len(s_2)\n    correct_position = 0\n    for command in correct_commands:\n        if command == '+':\n            correct_position += 1\n        elif command == '-':\n            correct_position -= 1\n    unrecognized_position = 0\n    for _ in range(unrecognized_commands_count):\n        if random.random() < 0.5:\n            unrecognized_position += 1\n    total_position = correct_position + unrecognized_position\n    return round(total_position / total_commands_count, 10)"
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split('\\n')\n    \n    correct_commands = 0\n    for i in range(len(s1)):\n        if s1[i] == s2[i]:\n            correct_commands += 1\n    \n    correct_commands += s2.count('?')\n    \n    probability = correct_commands / len(s2)\n    \n    return f\"{probability:.{10}f}\""
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split(\"\\n\")\n    \n    # Count the number of recognized commands\n    recognized_count = 0\n    \n    for i in range(len(s_2)):\n        if s_2[i] == '+':\n            recognized_count += 1\n        elif s_2[i] == '-':\n            recognized_count -= 1\n    \n    # Count the number of correct commands\n    correct_count = 0\n    \n    for i in range(len(s_1)):\n        if s_1[i] == s_2[i]:\n            correct_count += 1\n    \n    # Calculate the probability\n    probability = correct_count / len(s_2)\n    \n    return f\"{probability:.12f}\""
    },
    {
        "number": 859,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n\n    correct_count = 0\n    for i in range(len(s_1)):\n        if s_2[i] != '?':\n            correct_count += s_2[i] == s_1[i]\n        else:\n            correct_count += s_1[i] == '+'\n            correct_count += s_1[i] == '-'\n\n    return format(correct_count / len(s_1), '.12f')\n"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    students = [i for i in range(1, n+1)]\n    std_to_great = {}\n\n    for i, count in enumerate(a):\n        for _ in range(count):\n            std_to_great[i+1] = students[i]\n        students.pop(i)\n\n    def is_possible(order):\n        for i, std in enumerate(order):\n            if i+1 in std_to_great and std_to_great[i+1] != std:\n                return False\n        return True\n\n    def dfs(remain, visited, order, result):\n        if len(remain) == 0:\n            if is_possible(order):\n                result.append(order)\n            return\n\n        for i in range(len(remain)):\n            if not visited[i]:\n                visited[i] = True\n                dfs(remain[i+1:], visited, order + [remain[i]], result)\n                visited[i] = False\n\n    order = []\n    remain = list(students)\n    visited = [False] * len(remain)\n    dfs(remain, visited, order, [])\n\n    if len(order) == 0:\n        return \"Impossible\"\n    else:\n        return \"Possible\\n\" + \" \".join(map(str, order[0]))"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    p = list(range(1, n+1))\n    for i, count in enumerate(a):\n        if count == 0:\n            continue\n        for j in range(count):\n            if i < j:\n                break\n            p[i], p[j] = p[j], p[i]\n            if p[i] > p[j]:\n                p[i], p[j] = p[j], p[i]\n    if any(a[i] == i + 1 for i in range(n)):\n        return \"Impossible\"\n    else:\n        return \"Possible\\n\" + \" \".join(map(str, p))\n\n\ndef"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    if n == 1:\n        return \"Possible\\n1\"\n\n    dp = [[False for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            if j >= i:\n                dp[i][j] = dp[i][j - 1]\n            for k in range(a[i - 1]):\n                if dp[i - 1][k]:\n                    dp[i][j] = True\n                    break\n\n    if not dp[n][n]:\n        return \"Impossible\"\n\n    order = []\n    i, j = n, n\n    while i > 0:\n        for k in range(a[i - 1]):\n            if dp[i - 1][k]:\n                order.append(i)\n                j -= 1\n                break\n        i -= 1\n\n    return \"Possible\\n\" + \" \".join(map(str, order))\n\n\ninput_data = \"\"\"5\n2 1 3 0 1\n\n9\n0 2 3 4 1 1 0 2 2\n\n4\n0 2 1 1\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    events = list(map(int, stdin.split('\\n')[1].split()))\n    \n    students = sorted(range(n), key=lambda i: (events[i], i))\n    permutation = []\n    \n    for i in range(n):\n        for j in range(n):\n            if j == i:\n                break\n            if events[j] == 0:\n                if events[i] == 0:\n                    return \"Impossible\"\n                students[i], students[j] = students[j], students[i]\n                break\n        else:\n            return \"Impossible\"\n        \n    for student in students:\n        permutation.append(str(student + 1))\n    \n    return \"Possible\\n\" + \" \".join(permutation) "
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    # Check if the number of students with whom each student shook hands is greater than n\n    if any(a_i > n for a_i in a):\n        return \"Impossible\"\n    \n    # Create a list of all possible orders of students\n    all_orders = []\n    for perm in itertools.permutations(range(1, n+1)):\n        all_orders.append(perm)\n    \n    # Check if the order of events is possible\n    for order in all_orders:\n        # Initialize the number of students in each team\n        team_sizes = [0] * 3\n        team_sizes_sum = 0\n        # Initialize the count of students who are working independently\n        independent_students = n - sum(a)\n        \n        # Iterate through each student and check if his order is possible\n        for i in range(n):\n            if order[i] == 1:\n                if a[order[i-1]-1] > 0:\n                    independent_students -= 1\n                    a[order[i-1]-1] -= 1\n            if independent_students == 0 and team_sizes_sum < 3:\n                team_sizes[team_sizes_sum] += 1\n                team_sizes_sum += 1\n                if team_sizes_sum == 3:\n                    break\n            else:\n                independent_students -= 1\n        \n        # Check if all students were greeted\n        if team_sizes_sum == 3 and independent_students == 0:\n            return \"Possible\\n\" + \" \".join(map(str, order))\n    \n    return \"Impossible\""
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > j:\n                adj[i].append(j)\n                adj[j].append(i)\n\n    visited = [False] * n\n    order = []\n\n    def dfs(start: int):\n        visited[start] = True\n        for next in adj[start]:\n            if not visited[next]:\n                dfs(next)\n        order.append(start)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    order = [i for i in range(n) if i not in order] + order\n\n    if len(order) != n:\n        return \"Impossible\"\n\n    result = [str(i + 1) for i in order]\n    return \"Possible\\n\" + \" \".join(result)\n"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    students = [i for i in range(n)]\n    order = []\n    teams = []\n\n    for i in range(n):\n        team_size = 3\n        possible_teams = [t for t in itertools.combinations(students, team_size) if sum([a[j] for j in t]) == i]\n        if not possible_teams:\n            return \"Impossible\"\n        team = random.choice(possible_teams)\n        teams.append(team)\n        for s in team:\n            students.remove(s)\n\n    for t in teams:\n        order += t\n\n    return \"Possible\\n\" + \" \".join(map(str, order)) "
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # create a list of students and their shaking hands count\n    students = [(i, a[i]) for i in range(n)]\n\n    # sort the list by shaking hands count\n    students.sort(key=lambda x: x[1])\n\n    # iterate through the list of students and assign them a seat number\n    seats = [None] * n\n    for i, (student, shaking_hands) in enumerate(students):\n        if shaking_hands == 0:\n            seats[i] = i + 1\n        else:\n            for j in range(i + 1, n):\n                if shaking_hands <= students[j][1]:\n                    seats[i] = j + 1\n                    break\n            if seats[i] is None:\n                return \"Impossible\"\n\n    # create the permutation of the seat numbers\n    permutation = [0] * n\n    for i in range(n):\n        permutation[seats[i] - 1] = i + 1\n\n    # return the result\n    return \"Possible\\n\" + \" \".join(map(str, permutation))\n"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    std = [i for i in range(1, n+1)]\n    seq = []\n    \n    while a:\n        cnt = 0\n        for i in range(n):\n            if a[i] > 0:\n                cnt += 1\n                a[i] -= 1\n        if cnt < 3:\n            return \"Impossible\"\n        i = std.index(max(std, key=a.count))\n        seq.append(i)\n        std.pop(i)\n    return \"Possible\\n\" + ' '.join(map(str, seq))"
    },
    {
        "number": 860,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    res = []\n    \n    while a:\n        m = max(a)\n        res.append(a.index(m))\n        a[a.index(m)] = 0\n        for i in range(n):\n            if a[i] == 0:\n                continue\n            a[i] -= 1\n    \n    if all(i == j for i, j in zip(res, range(n))):\n        return \"Possible\\n\" + \" \".join(map(str, res))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    result = 0.0\n    for i in range(m**2):\n        fly_v = (i // m) + 1\n        fly_u = m + 1 + (i % m)\n        result += distance(2 * R * fly_v - R, 0, 2 * R * fly_u - R, 2 * R)\n\n    result /= m**2\n    return format(result, \".10f\")\n"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    total_distance = 0\n\n    for i in range(m ** 2):\n        fly_circle_center = (2 * R * (i // m) + R, 0)\n        end_circle_center = (2 * R * ((i // m) + 1) + R, 2 * R)\n        shortest_distance = min(\n            (fly_circle_center[0] - end_circle_center[0]) ** 2\n            + (fly_circle_center[1] - end_circle_center[1]) ** 2,\n            (end_circle_center[0] - fly_circle_center[0]) ** 2\n            + (end_circle_center[1] - fly_circle_center[1]) ** 2,\n        )\n        total_distance += shortest_distance\n\n    return \"{:.10f}\".format(total_distance / (m ** 2))\n\n\ndef"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    def get_center(v: int) -> tuple:\n        x = 2 * R - R + v * 2 * R\n        y = 0\n        return x, y\n    \n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    \n    total_distance = 0\n    for i in range(m**2):\n        v = floor(i / m) + 1\n        u = m + 1 + (i % m)\n        x1, y1 = get_center(v)\n        x2, y2 = get_center(u)\n        total_distance += distance(x1, y1, x2, y2)\n    \n    avg_distance = total_distance / m**2\n    \n    return f\"{avg_distance:.{9}f}\"\n\ndef"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    d = (2 * R) + (2 * (R - R/m))\n    answer = d * m\n    \n    return f\"{answer:.{10}f}\"\n"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    fly_distance = 0\n    for i in range(m**2):\n        v = math.floor(i / m) + 1\n        u = m + 1 + (i % m)\n        fly_distance += math.sqrt((v - u)**2 + 4*(R - R/2)**2)\n    \n    result = fly_distance / m**2\n    \n    return f\"{result:.10f}\"\n\n\nm, R = map(int, input().split())\nprint(solution(str(m) + \" \" + str(R))) "
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    # Calculate the average distance the fly went along the coordinate plane\n    distance = 0\n    for i in range(m ** 2):\n        # Calculate the center numbers of the fly's path\n        v = (i // m) + 1\n        u = m + 1 + (i % m)\n        \n        # Calculate the distance between the centers of the circles\n        distance += ((2 * R * u - R) ** 2 + (2 * R * v - R) ** 2) ** 0.5\n    \n    # Calculate the average distance\n    average_distance = distance / (m ** 2)\n    \n    # Format the output\n    output = f\"{average_distance:.{10}f}\"\n    \n    return output\n\n\ndef"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    average_distance = 0\n    for i in range(m**2):\n        v = (i // m) + 1\n        u = m + 1 + (i % m)\n        fly_distance = (R - R//v) + (2*R - R//u)\n        average_distance += fly_distance\n    \n    average_distance /= m**2\n    return f\"{average_distance:.10f}\"\n"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    total_distance = 0\n    \n    for i in range(m**2):\n        v = (i // m) + 1\n        u = m + 1 + (i % m)\n        fly_distance = (2 * R) * (v + u - 1) - ((v - 1) * v + (u - 1) * u) / 2\n        total_distance += fly_distance\n    \n    return f\"{total_distance / m**2:.10f}\"\n"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, input().split())\n    total_distance = 0\n    \n    for i in range(m**2):\n        v = floor(i / m) + 1\n        u = m + 1 + (i % m)\n        circle_v = (2*R - R, 0)\n        circle_u = (2*R - R + 2*(i % m), 2*R)\n        distance = abs(sqrt((circle_v[0] - circle_u[0])**2 + (circle_v[1] - circle_u[1])**2))\n        total_distance += distance\n    \n    avg_distance = total_distance / m**2\n    return f\"{avg_distance:.10f}\"\n\n\ndef"
    },
    {
        "number": 861,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    \n    distance = 0\n    for i in range(m**2):\n        fly_circle = (i // m) + 1\n        fly_center = (2 * R) * fly_circle - R\n        fly_x, fly_y = 2 * R - R, 2 * R - R\n        fly_circle_x, fly_circle_y = fly_center, fly_y\n        \n        if i % m == 0:\n            fly_circle_x, fly_circle_y = fly_x, fly_y\n        \n        fly_circle_radius = R\n        \n        u_circle = m + 1 + (i % m)\n        u_center = (2 * R) * u_circle - R\n        u_x, u_y = 2 * R - R, 2 * R\n        u_circle_x, u_circle_y = u_center, u_y\n        \n        u_circle_radius = R\n        \n        if u_circle > m:\n            u_circle_x, u_circle_y = u_x, u_y\n        \n        delta_x = u_circle_x - fly_circle_x\n        delta_y = u_circle_y - fly_circle_y\n        \n        distance += ((delta_x**2 + delta_y**2)**0.5) * ((u_circle_radius**2 + fly_circle_radius**2) / (u_circle_radius + fly_circle_radius))\n    \n    return f\"{distance / m**2:.{10}f}\""
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    entrance = 1\n    people_in_queue = a.copy()\n    while people_in_queue.pop(0) != 0:\n        entrance += 1\n    entrance %= n\n    return entrance\n"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    entrance = 1\n    while a[entrance-1] == 0:\n        entrance += 1\n\n    return entrance\n"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    if n == 1:\n        return 1\n    q = list(enumerate(a, 1))\n    i = 1\n    while q:\n        if q[0][1] > 0:\n            return i\n        q.pop(0)\n        i += 1\n    return i\n"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a = input().split()\n    n = int(n)\n    a = list(map(int, a.split()))\n    time = 0\n    entrance = 0\n    while a[entrance] > 0:\n        a[entrance] -= 1\n        time += 1\n        if entrance + 1 < n:\n            entrance += 1\n        else:\n            entrance = 0\n    return str(entrance + 1)"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    queue_sizes = list(map(int, stdin.splitlines()[1].split()))\n    \n    entrance = 0\n    for i in range(n):\n        if queue_sizes[entrance] == 0:\n            break\n        entrance = (entrance + 1) % n\n    \n    return entrance + 1"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    q = deque(enumerate(a))\n    i = 0\n    while q:\n        if q[0][1] == 0:\n            q.popleft()\n        else:\n            break\n    while q:\n        if q[0][1] == 0:\n            q.popleft()\n        else:\n            i += 1\n            if i == n:\n                i = 1\n            q[0] = (i, q[0][1] - 1)\n    return i"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    entrance_queue = list(map(int, stdin.splitlines()[1].split()))\n\n    for i in range(n):\n        if entrance_queue[i] == 0:\n            continue\n        for j in range(i + 1, n):\n            if entrance_queue[j] == 0:\n                continue\n            if entrance_queue[j] > 0:\n                break\n        else:\n            return i + 1\n\n    return -1\n"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    entrance = 1\n    count = a[entrance-1]\n    while count > 0:\n        entrance += 1\n        if entrance > n:\n            entrance = 1\n        count = a[entrance-1]\n    return entrance"
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    entrances = list(map(int, stdin.splitlines()[1].split()))\n    entrance = 0\n    while len(entrances) > 1:\n        entrance = (entrance + 1) % n\n        if entrances[entrance] > 0:\n            entrances[entrance] -= 1\n            if all(queue == 0 for queue in entrances):\n                break\n        else:\n            entrances.pop(entrance)\n            if entrance == 0:\n                entrance = n - 1\n            else:\n                entrance -= 1\n    return entrance + 1\n\n\ninput_data = \"\"\"4\n2 3 2 0\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 862,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    for i in range(n):\n        a[i] += i\n    for i in range(n):\n        if a[i] == 0:\n            return i + 1\n    return 1\n\n\ndef"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, departure_time = input_processing(stdin)\n    departure_hour, departure_minute = map(int, departure_time.split(':'))\n    hour, minute = 0, 0\n\n    def get_minutes(time_str: str) -> int:\n        return int(time_str[:2]) * 60 + int(time_str[3:])\n\n    def get_time(minutes: int) -> str:\n        hours = minutes // 60\n        minutes = minutes % 60\n        return f\"{hours:02d}:{minutes:02d}\"\n\n    def count_bus(start_time: str, frequency: int, travel_time: int) -> int:\n        start_hour, start_minute = map(int, start_time.split(':'))\n        start_minutes = start_hour * 60 + start_minute\n        return (departure_minutes - start_minutes) // (frequency * travel_time)\n\n    departure_minutes = get_minutes(f\"{departure_hour:02d}:{departure_minute:02d}\")\n    count_a = count_bus(\"05:00\", a, t_a)\n    count_b = count_bus(\"11:50\", b, t_b)\n\n    while hour < 24:\n        if count_a == 0 and count_b == 0:\n            break\n\n        if count_a > 0:\n            count_a -= 1\n            hour, minute = map(int, get_time(minutes=departure_minutes).split(':'))\n            departure_minutes += t_a\n\n        if count_b > 0:\n            count_b -= 1\n            hour, minute = map(int, get_time(minutes=departure_minutes).split(':'))\n            departure_minutes += t_b\n\n    return count_a + count_b\n\n\ndef"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def time_to_minutes(time: str) -> int:\n        h, m = map(int, time.split(':'))\n        return h * 60 + m\n\n    def bus_encounters(a: int, t_a: int, b: int, t_b: int, departure_time: str) -> int:\n        departure_minutes = time_to_minutes(departure_time)\n        first_bus_time = (departure_minutes // t_a + 1) * t_a\n        last_bus_time = (departure_minutes // t_b) * t_b\n        total_minutes = last_bus_time - first_bus_time\n        encounters = total_minutes // (t_a + t_b)\n        return encounters\n\n    a, t_a, b, t_b, departure_time = stdin.splitlines()\n    a, t_a, b, t_b = map(int, (a, t_a, b, t_b))\n    z = bus_encounters(a, t_a, b, t_b, departure_time)\n    return str(z)"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, time = (int(i) for i in stdin.split())\n    h, m = map(int, time.split(':'))\n    h_a, m_a = h, m\n    h_b, m_b = h, m\n    z = 0\n    t = (m_a + t_a * a) % 1440  # time when Simion arrives to the city B\n    h_b, m_b = t // 60, t % 60\n\n    while (h_b < 23) or (h_b == 23 and m_b < 59):\n        z += 1\n        h_b, m_b = (h_b + b) % 24, (m_b + b * 60) % 1440\n\n    t = (m_b - t_b * b) % 1440  # time when Simion arrives to the city A\n    h_a, m_a = t // 60, t % 60\n\n    while (h_a < 23) or (h_a == 23 and m_a < 59):\n        z += 1\n        h_a, m_a = (h_a + a) % 24, (m_a + a * 60) % 1440\n\n    return z - 2  # don't count encounters in cities A and B\n\n\ninput_data = \"\"\"10 30\n10 35\n05:20\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, departure_time = input().split()\n    a, t_a, b, t_b = int(a), int(t_a), int(b), int(t_b)\n    hour, minute = map(int, departure_time.split(':'))\n    departure_minutes = hour * 60 + minute\n    \n    # Calculate the total time of the journey\n    journey_time = a * t_a + b * t_b\n    \n    # Calculate the time difference between the departure time and the end of the journey\n    end_journey_time = journey_time - t_a - t_b\n    \n    # Calculate the number of buses Simion will meet\n    n_buses = (end_journey_time - departure_minutes) // (t_b + t_a)\n    \n    return str(n_buses)\n"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, time = stdin.split()\n    a, t_a, b, t_b = int(a), int(t_a), int(b), int(t_b)\n    h, m = time.split(\":\")\n    h, m = int(h), int(m)\n    \n    total_minutes = h * 60 + m\n    \n    total_buses = ((total_minutes - t_a) // t_a) + 1\n    \n    total_buses -= (total_minutes % t_b) // t_b\n    \n    return total_buses"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_time(time: str) -> int:\n        h, m = map(int, time.split(':'))\n        return h * 60 + m\n\n    def format_time(time: int) -> str:\n        h = time // 60\n        m = time % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    def count_bus_encounters(a: int, t_a: int, b: int, t_b: int, start_time: int, end_time: int) -> int:\n        n = (end_time - start_time) // (t_a + t_b)\n        return n - 1\n\n    stdin_lines = stdin.splitlines()\n    a, t_a = map(int, stdin_lines[0].split())\n    b, t_b = map(int, stdin_lines[1].split())\n    start_time = parse_time(stdin_lines[2])\n\n    end_time = start_time + t_a + t_b\n    start_time = max(start_time, (start_time // (t_a + t_b) * (t_a + t_b)) + t_a)\n\n    z = count_bus_encounters(a, t_a, b, t_b, start_time, end_time)\n\n    return str(z)\n"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_time(time: str) -> int:\n        return 60 * int(time[:2]) + int(time[3:])\n\n    def parse_buses(buses: str) -> Tuple[int, int, int]:\n        a, t_a, b, t_b = map(int, buses.split())\n        return a, t_a, b, t_b\n\n    a, t_a, b, t_b = parse_buses(stdin)\n    departure_time = parse_time(stdin.splitlines()[-1])\n\n    n = (departure_time - 300) // t_a\n    n -= (n * a * t_a) // 1440\n\n    return n"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, departure_time = input().split()\n    a, t_a, b, t_b = int(a), int(t_a), int(b), int(t_b)\n    h, m = map(int, departure_time.split(':'))\n    start_time = h * 60 + m\n    \n    # Calculate the number of buses Simion will meet\n    end_time = 11 * 60 + 59 if h < 11 else h * 60 + 59\n    first_encounter_time = start_time + t_a\n    last_encounter_time = end_time - t_b\n    meet_count = 0\n\n    while first_encounter_time <= last_encounter_time:\n        meet_count += 1\n        first_encounter_time += t_a + t_b\n\n    return str(meet_count - 2)\n\n\ninput_str = \"\"\"10 30\n10 35\n05:20\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a, b, t_b, time = stdin.split('\\n')\n    a, t_a, b, t_b = int(a), int(t_a), int(b), int(t_b)\n    hour, minute = map(int, time.split(':'))\n    hour = hour % 24\n\n    if hour * 60 + minute < 5 * 60 + 20:\n        a_bus_count = 0\n    else:\n        a_bus_count = (hour * 60 + minute - 5 * 60 - 20) // t_a\n\n    b_bus_count = (hour * 60 + minute) // t_b\n\n    result = a_bus_count + b_bus_count - 1\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 863,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    a, t_a, b, t_b, departure = map(int, input_data[0].split())\n    departure_time = list(map(int, departure.split(':')))\n    departure_time = departure_time[0] * 60 + departure_time[1]\n\n    buses_from_a = departure_time // t_a\n    buses_from_b = (24 * 60 - departure_time) // t_b\n\n    total_buses = max(buses_from_a, buses_from_b)\n\n    if total_buses == 0:\n        return \"0\"\n\n    return str(total_buses - 1)"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    n, m = map(int, input_str[0].split())\n    a = list(map(int, input_str[1].split()))\n\n    if m < n:\n        return \"0\"\n\n    types = set(a)\n    max_days = 0\n\n    for food_type in types:\n        remaining_participants = n\n        days_left = m\n\n        while remaining_participants > 0 and days_left > 0:\n            daily_foods = [food_type] * remaining_participants\n            remaining_participants -= 1\n            days_left -= 1\n\n            if days_left > 0:\n                max_days += 1\n\n    return str(max_days)\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    # Initialize the variables\n    types = set(a)\n    max_days = 0\n    \n    # Loop through all possible food types\n    for food_type in types:\n        # Count the number of packages of this type\n        count = a.count(food_type)\n        \n        # Check if there are enough packages to last for one day\n        if count >= n:\n            max_days = 1\n            break\n    \n    # Print the result\n    return str(max_days)"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [0] * n\n\n    if n > m:\n        return \"0\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[j] == b[i] or b[i] == 0:\n                b[i] = a[j]\n                break\n\n    days = 1\n    while days <= m and b.count(0) == 0:\n        for i in range(n):\n            b[i] = a[b.index(b[i])]\n        days += 1\n\n    return str(days - 1) if days > 1 else \"0\"\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    if n > 100 or m > 100:\n        return \"0\"\n    \n    if m == 1:\n        return \"1\" if n == 1 else \"0\"\n    \n    unique_food_types = set(a)\n    if len(unique_food_types) == 1:\n        return \"1\" if m >= n else \"0\"\n    \n    for i in range(n):\n        for j in range(m):\n            if a[j] == i + 1:\n                return \"1\"\n    \n    return \"0\"\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    food_types = sorted(set(map(int, input_data[1].split())))\n    \n    if len(food_types) < n:\n        return \"0\"\n    \n    types_per_day = len(food_types) // n\n    days = 1\n    \n    for i in range(1, n):\n        if food_types[i * types_per_day - 1] != food_types[i * types_per_day]:\n            days += 1\n    \n    return str(days)\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    max_days = 0\n    days = 0\n    food_types = set()\n    \n    for _ in range(n):\n        b = a.pop(0)\n        food_types.add(b)\n        \n        if len(food_types) == len(set(a)):\n            max_days = days + 1\n        \n        days += 1\n    \n    return str(max_days) if max_days > 0 else str(0)\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if m < n:\n        return \"0\"\n\n    types = set(a)\n    if len(types) < n:\n        return \"0\"\n\n    types_count = {}\n    for t in types:\n        types_count[t] = a.count(t)\n\n    types_count = {k: v for k, v in sorted(types_count.items(), key=lambda item: item[1])}\n\n    days = 1\n    current_types = types_count.copy()\n    for i in range(n):\n        if current_types == {}:\n            break\n\n        min_type = min(current_types.keys())\n        min_count = current_types[min_type]\n        current_types[min_type] -= 1\n\n        if min_count == 0:\n            current_types.pop(min_type)\n\n        days += min_count\n\n    return str(days)"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    food_types = list(map(int, stdin.split()[2:]))\n\n    if n == 1:\n        return str(max(1, m))\n\n    if m < n:\n        return \"0\"\n\n    # Find the food type with the most occurrences\n    most_common_food_type = max(set(food_types), key=food_types.count)\n\n    # Calculate the number of days the expedition can last\n    days = m // n\n\n    # Check if the expedition can last at least one day\n    if days * n != m:\n        return \"0\"\n\n    # Check if the expedition can last for the calculated number of days\n    if days * n == m and food_types.count(most_common_food_type) == n:\n        return str(days)\n\n    return \"0\"\n"
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    if n > m:\n        return 0\n    \n    food_types = set(a)\n    if len(food_types) < n:\n        return 0\n    \n    return n // len(food_types)\n\ninput_str = \"\"\"4 10\n1 5 2 1 1 1 2 5 7 2\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 864,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    food_types = list(map(int, input().split()))\n    \n    if m == 0:\n        return \"0\"\n    \n    sorted_food_types = sorted(set(food_types), reverse=True)\n    max_days = 0\n    days = 0\n    \n    for i in range(n):\n        if sorted_food_types[0] > 0:\n            sorted_food_types[0] -= 1\n            days += 1\n            if days > max_days:\n                max_days = days\n        \n        else:\n            break\n    \n    return str(max_days)\n"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    A = []\n    B = []\n    \n    for i in range(N):\n        A_i, B_i = map(int, stdin.split()[2*i:2*i+2])\n        A.append(A_i)\n        B.append(B_i)\n    \n    A.sort()\n    B.sort()\n    A.reverse()\n    B.reverse()\n    \n    if T < 0.5 * (A[0] + A[1]):\n        return B[0] + B[1]\n    elif T < 0.5 * (A[1] + A[2]):\n        return B[1] + B[2]\n    else:\n        return B[0] + B[2]"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, T = map(int, input_data[0].split())\n    A = [int(x) for x in input_data[1].split()]\n    B = [int(x) for x in input_data[2].split()]\n\n    dishes = [(A[i], B[i], 0) for i in range(N)]\n    current_dish = -1\n    time_left = T\n\n    happiness = 0\n\n    for i in range(N):\n        if dishes[i][2] == 0:\n            if current_dish != -1 and dishes[i][0] == current_dish:\n                continue\n\n            if time_left < 0.5:\n                break\n\n            time_left -= A[i]\n            current_dish = dishes[i][1]\n            happiness += current_dish\n            dishes[i] = (A[i], B[i], 1)\n\n    return happiness\n\n\ninput_data = '''2 60\n10 10\n100 100'''\n\noutput_data = solution(input_data)\nprint(output_data)  # Output: 110\n"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    dishes = [tuple(map(int, stdin.split()[2 * i: 2 * (i + 1)])) for i in range(N)]\n    dishes.sort(key=lambda x: x[1], reverse=True)\n    current_dish = dishes[0][1]\n    current_time = 0\n    happiness = 0\n\n    for dish in dishes:\n        if current_time + dish[0] <= T:\n            happiness += dish[1]\n            current_time += dish[0]\n            current_dish = dish[1]\n        else:\n            happiness += current_dish\n            break\n\n    return str(happiness)\n"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    A_i, B_i = zip(*[map(int, input().split()) for _ in range(N)])\n\n    # Initialize variables\n    max_happiness = 0\n    current_happiness = 0\n    current_dish = None\n    elapsed_time = 0\n\n    # Iterate through the dishes and update the happiness\n    for dish_index in range(N):\n        if current_dish is None:\n            # Serve the dish\n            current_dish = dish_index\n            current_happiness = B_i[current_dish]\n            elapsed_time += A_i[current_dish]\n            max_happiness = max(max_happiness, current_happiness)\n        else:\n            # Check if we can swap the dishes\n            if elapsed_time + A_i[current_dish] <= T:\n                # Swap the dishes\n                current_dish = dish_index\n                current_happiness += B_i[current_dish] - B_i[current_dish - 1]\n                elapsed_time += A_i[current_dish]\n                max_happiness = max(max_happiness, current_happiness)\n            else:\n                # Eat the current dish and start the new dish\n                elapsed_time += A_i[current_dish]\n                current_happiness -= B_i[current_dish - 1]\n                current_dish = dish_index\n                current_happiness += B_i[current_dish]\n                elapsed_time += A_i[current_dish]\n                max_happiness = max(max_happiness, current_happiness)\n\n    return max_happiness"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2::2]))\n    B = list(map(int, stdin.split()[3::2]))\n\n    A.sort()\n    B.sort()\n\n    total_happiness = 0\n    dishes_eaten = 0\n\n    for i in range(N):\n        time_elapsed = dishes_eaten * A[i]\n\n        if time_elapsed >= T:\n            break\n\n        total_happiness += B[i]\n        dishes_eaten += 1\n\n    return total_happiness\n"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[0:2])\n    A_i, B_i = [], []\n    for _ in range(N):\n        a, b = map(int, stdin.split()[2:4])\n        A_i.append(a)\n        B_i.append(b)\n    A_i.sort()\n    B_i.sort(reverse=True)\n    result = 0\n    for i in range(N):\n        if A_i[i] <= T - 0.5:\n            result += B_i[i]\n    return result "
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, T = map(int, input_data[0].split())\n    A_B = [list(map(int, input_data[i + 1].split())) for i in range(N)]\n\n    A_B.sort(key=lambda x: x[1], reverse=True)\n\n    total_happiness = 0\n    eaten_dishes = set()\n    order_time = 0\n\n    for i in range(N):\n        if order_time + A_B[i][0] <= T / 2:\n            eaten_dishes.add(i)\n            total_happiness += A_B[i][1]\n            order_time += A_B[i][0]\n\n    return total_happiness\n"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2::2]))\n    B = list(map(int, stdin.split()[3::2]))\n    \n    # First dish is always best\n    best_choice = 0\n    best_dish = 0\n    current_happiness = B[0]\n    \n    for i in range(1, N):\n        # If the next dish has a better deliciousness, order it\n        if B[i] > B[best_choice]:\n            current_happiness += B[i] - B[best_choice]\n            best_choice = i\n            best_dish = i\n        # If the next dish has the same or better deliciousness,\n        # but is faster to eat, order it\n        elif B[i] >= B[best_choice] and A[i] < A[best_choice]:\n            current_happiness += B[i] - B[best_choice]\n            best_choice = i\n            best_dish = i\n        # If the next dish has the same or better deliciousness,\n        # but it's still better to eat the current dish,\n        # don't order the next one\n        elif B[i] >= B[best_choice] and A[i] >= A[best_choice]:\n            current_happiness += B[best_choice]\n        \n        # If the time's up, eat the current dish and don't order any more\n        if i * A[best_dish] >= T:\n            break\n    \n    # Eat the remaining time with the best dish\n    remaining_time = T - i * A[best_dish]\n    current_happiness += B[best_choice] * remaining_time\n    \n    return current_happiness"
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:N*2:2]))\n    B = list(map(int, stdin.split()[3:N*2+1:2]))\n\n    # Calculate the maximum possible happiness\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    happiness = sum(a * b for a, b in zip(A, B))\n\n    # Return the maximum possible happiness\n    return str(happiness)\n\ninput_str = \"2 60\\n10 10\\n100 100\"\nprint(solution(input_str)) "
    },
    {
        "number": 865,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, input().split())\n    dishes = []\n    for _ in range(N):\n        A, B = map(int, input().split())\n        dishes.append((A, B))\n\n    dishes.sort(key=lambda x: x[1], reverse=True)\n\n    max_happiness = 0\n    for i in range(N):\n        A, B = dishes[i]\n        if T - 0.5 >= A:\n            max_happiness += B\n            T -= A\n        else:\n            max_happiness += B * T / A\n            T = 0\n            break\n\n    return str(max_happiness)"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    result = 0\n    for i in range(X):\n        for j in range(Y):\n            if ((i + 1) ** 2 + (j + 2) ** 2) == 8 or ((i + 2) ** 2 + (j + 1) ** 2) == 8:\n                result += 1\n    return str(result % (10**9 + 7))\n\ndef"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    \n    # Number of ways to reach (X, Y) from (0, 0)\n    count = 0\n    \n    # Check if there is a path from (0, 0) to (X, Y)\n    if X == 0 and Y == 0:\n        count = 1\n    elif X >= Y:\n        count = (X - Y + 1) * (X - Y + 2) // 2\n    elif X < Y:\n        count = (Y - X + 1) * (Y - X + 2) // 2\n    \n    # Calculate the number of ways modulo 10^9 + 7\n    count %= (10**9 + 7)\n    \n    return str(count)\n"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (Y + 1) for _ in range(X + 1)]\n    dp[0][0] = 1\n\n    for i in range(X + 1):\n        for j in range(Y + 1):\n            if i + 1 <= X and j + 2 <= Y:\n                dp[i + 1][j + 2] += dp[i][j]\n                dp[i + 1][j + 2] %= MOD\n            if i + 2 <= X and j + 1 <= Y:\n                dp[i + 2][j + 1] += dp[i][j]\n                dp[i + 2][j + 1] %= MOD\n\n    return dp[X][Y]\n"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    if X == 0 and Y == 0:\n        return 1\n\n    def dfs(x, y, x_dest, y_dest):\n        if x == x_dest and y == y_dest:\n            return 1\n        if x + 1 <= x_dest and y + 2 <= y_dest and (x + 1, y + 2) not in visited:\n            visited.add((x, y))\n            return dfs(x + 1, y + 2, x_dest, y_dest)\n        if x + 2 <= x_dest and y + 1 <= y_dest and (x + 2, y + 1) not in visited:\n            visited.add((x, y))\n            return dfs(x + 2, y + 1, x_dest, y_dest)\n        return 0\n\n    visited = set()\n    return dfs(0, 0, X, Y) % (10**9 + 7)\n"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x < 0 or y < 0 or x > 10**6 or y > 10**6:\n        return \"Invalid input\"\n    if x == 0 and y == 0:\n        return 1\n    return (solution(x-2, y-1) + solution(x-1, y-2)) % (10**9 + 7)\n"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == y:\n        return \"0\"\n\n    x_steps = [1, 2, -1, -2]\n    y_steps = [2, 1, -1, -2]\n\n    count = 0\n    for x_step in x_steps:\n        for y_step in y_steps:\n            if abs(x_step) + abs(y_step) == abs(x - y):\n                count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    modulo = int(1e9 + 7)\n    dp = [[0 for _ in range(Y+1)] for _ in range(X+1)]\n    \n    dp[0][0] = 1\n    \n    for i in range(X+1):\n        for j in range(Y+1):\n            if i > 0 and j > 0:\n                dp[i][j] = (dp[i][j-2] + dp[i-2][j-1]) % modulo\n                \n    return dp[X][Y]\n\ndef"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    X = int(input_values[0])\n    Y = int(input_values[1])\n    \n    count = 0\n    for i in range(X):\n        for j in range(Y):\n            if (i + 1) % 2 == 0 and (j + 2) % 2 != 0 or (i + 1) % 2 != 0 and (j + 2) % 2 == 0:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    mod = 10**9 + 7\n    memo = [[-1 for _ in range(Y+1)] for _ in range(X+1)]\n\n    def count_ways(i, j):\n        if i == 0 and j == 0:\n            return 1\n        if memo[i][j] != -1:\n            return memo[i][j]\n\n        memo[i][j] = (count_ways(i-1, j+2) + count_ways(i+2, j+1)) % mod\n        return memo[i][j]\n\n    return str(count_ways(X, Y))\n"
    },
    {
        "number": 866,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    if X == 0 or Y == 0:\n        return 1\n    else:\n        return (2 * X * Y - 2 * (X + Y) + 1) // 2 % (10**9 + 7)\n"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    return max(1, N - 1)"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin.strip()\n    N = int(input_string)\n    \n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"1\"\n    else:\n        brains = 2\n        while True:\n            if (N - brains) % 2 == 0:\n                return str(brains)\n            brains += 1\n"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N % 2 == 0:\n        return 2\n    else:\n        return N - 1\n\n\ninput_stdin = \"4\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    # There can't be more brains than attendees\n    if N > 10**9:\n        return \"1\"\n\n    # If there is only one attendee, Heidi can take one brain\n    if N == 1:\n        return \"1\"\n\n    # If there are four attendees, Heidi can take one brain and offer 2\n    if N == 4:\n        return \"1\"\n\n    # Heidi needs to offer at least 1/2 + 1 = 3/2 brains\n    min_brains = 3\n\n    # If there are more than 4 attendees, Heidi can offer 4 brains\n    if N > 4:\n        min_brains = 4\n\n    return str(min_brains) "
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    \n    if N == 1:\n        return \"1\"\n    \n    max_vote = (N - 2) // 2\n    \n    if max_vote == 0:\n        return \"1\"\n    \n    for brains in range(1, max_vote + 1):\n        if brains % 2 == 0:\n            max_vote = brains // 2 - 1\n        else:\n            max_vote = brains // 2\n        \n        if max_vote >= 1:\n            break\n    \n    return str(max_vote + 1)\n\n\ninput_str = \"4\"  # Input\noutput_str = solution(input_str)  # Output: \"2\"\nprint(output_str) "
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n\n    if N == 1:\n        return \"1\"\n\n    if N == 2:\n        return \"1\"\n\n    if N == 3:\n        return \"1\"\n\n    if N == 4:\n        return \"2\"\n\n    if N == 5:\n        return \"2\"\n\n    if N == 6:\n        return \"2\"\n\n    if N == 7:\n        return \"3\"\n\n    if N == 8:\n        return \"3\"\n\n    if N == 9:\n        return \"4\"\n\n    if N == 10:\n        return \"4\"\n\n    if N == 11:\n        return \"4\"\n\n    if N == 12:\n        return \"5\"\n\n    if N == 13:\n        return \"5\"\n\n    if N == 14:\n        return \"5\"\n\n    if N == 15:\n        return \"6\"\n\n    if N == 16:\n        return \"6\"\n\n    if N == 17:\n        return \"7\"\n\n    if N == 18:\n        return \"7\"\n\n    if N == 19:\n        return \"7\"\n\n    if N == 20:\n        return \"8\"\n\n    if N == 21:\n        return \"8\"\n\n    if N == 22:\n        return \"8\"\n\n    if N == 23:\n        return \"9\"\n\n    if N == 24:\n        return \"9\"\n\n    if N == 25:\n        return \"10\"\n\n    if N == 26:\n        return \"10\"\n\n    if N == 27:\n        return \"11\"\n\n    if N == 28:\n        return \"12\"\n\n    if N == 29:\n        return \"12\"\n\n    if N == 30:\n        return \"12\"\n\n    if N == 31:\n        return \"13\"\n\n    if N == 32:\n        return \"13\"\n\n    if N == 33:\n        return \"13\"\n\n    if N == 34:\n        return \"14\"\n\n    if N == 35:\n        return \"14\"\n\n    if N == 36:\n        return \"15\"\n\n    if N == 37:\n        return \"15\"\n\n    if N == 38:\n        return \"16\"\n\n    if N == 39:\n        return \"16\"\n\n    if N == 40:\n        return \"17\"\n\n    if N == 41:\n        return \"17\"\n\n    if N == 42:\n        return \"17\"\n\n    if N == 43:\n        return \"18\"\n\n    if N == 44:\n        return \"18\"\n\n    if N == 45:\n        return \"19\"\n\n    if N == 46:\n        return \"19\"\n\n    if N == 47:\n        return \"19\"\n\n    if N == 48:\n        return \"20\"\n\n    if N == 49:\n        return \"20\"\n\n    if N == 50:\n        return \"20\"\n\n    if N == 51:\n        return \"21\"\n\n    if N == 52:\n        return \"21\"\n\n    if N == 53:\n        return \"21\"\n\n    if N == 54:\n        return \"22\"\n\n    if N == 55:\n        return \"22\"\n\n    if N == 56:\n        return \"22\"\n\n    if N == 57:\n        return \"23\"\n\n    if N == 58:\n        return \"23\"\n\n    if N == 59:\n        return \"23\"\n\n    if N == 60:\n        return \"24\"\n\n    if N == 61:\n        return \"24\"\n\n    if N == 62"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"2\"\n    elif N == 3:\n        return \"3\"\n    else:\n        return str(N-2)\n\ndef"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N == 1:\n        return \"1\"\n    else:\n        return \"2\"\n"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    \n    # If there are only 1 or 2 brains, it's not possible\n    if N < 3:\n        return \"0\"\n    \n    # If there are more than half of the brains in the chest, Heidi can always take one brain\n    if N % 2 == 0:\n        return str(N // 2 + 1)\n    else:\n        return str((N + 1) // 2 + 1)"
    },
    {
        "number": 867,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"1\"\n    elif N == 3:\n        return \"1\"\n    elif N == 4:\n        return \"2\"\n    elif N == 5:\n        return \"2\"\n    elif N == 6:\n        return \"2\"\n    elif N == 7:\n        return \"3\"\n    elif N == 8:\n        return \"3\"\n    elif N == 9:\n        return \"3\"\n    elif N == 10:\n        return \"3\"\n    else:\n        return \"4\"\n"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 1378 ** n\n    return str(result % 10)"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 1378 ** n\n    return str(result % 10)\n\n\ndef"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 1378 ** n\n    return str(result % 10)\n\n\ndef"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = pow(1378, n) % 10\n    return str(result)\n\ndef"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = pow(1378, n, 10)\n    return str(result)\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = (1378 ** n) % 10\n    return str(result)"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = pow(1378, n, 10)\n    return str(result)"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str, = stdin.split()\n    n = int(input_str)\n    \n    # Compute 1378^n\n    result = pow(1378, n, 1000000007)\n    \n    # Compute the last digit of result\n    last_digit = result % 10\n    \n    return str(last_digit)\n\nstdin = \"1\\n2\"\nstdout = solution(stdin)\nprint(stdout) # Expected output: 8\\n4 "
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 1378**n % 10\n    return str(result)\n"
    },
    {
        "number": 868,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 1378 ** n\n    return str(result % 10)\n\ndef"
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    days_diff = 1 if a > b else 2\n    days_same = max(a, b) - days_diff\n    return f\"{days_diff} {days_same}\"\n"
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = 1\n    same_socks_days = 0\n    if a > b:\n        max_days += (a + 1) // 2\n        same_socks_days = (a + 1) // 2\n    else:\n        max_days += (b + 1) // 2\n        same_socks_days = (b + 1) // 2\n\n    return f\"{max_days} {same_socks_days}\" "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    \n    if a == 0 and b == 0:\n        return \"0 0\"\n    \n    if a == 0:\n        return \"0 0\"\n    \n    if b == 0:\n        return \"0 0\"\n    \n    if a == 1 and b == 1:\n        return \"1 0\"\n    \n    if a == b:\n        return \"0 0\"\n    \n    if a > b:\n        max_days = a // 2 + 1\n        same_days = max_days - 1\n    else:\n        max_days = b // 2 + 1\n        same_days = max_days - 1\n        \n    return f\"{max_days} {same_days}\" "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = 0\n    same_socks_days = 0\n\n    if a == 1:\n        max_days = 1\n        same_socks_days = 0\n    elif b == 1:\n        max_days = 1\n        same_socks_days = 0\n    elif a > b:\n        max_days = 2\n        same_socks_days = 1\n    else:\n        max_days = 1\n        same_socks_days = 1\n\n    return f\"{max_days} {same_socks_days}\" "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    return \"{} {}\".format(max(a, b), min(a, b)) "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    days_with_different_socks = 1\n    days_with_same_socks = 0\n\n    if a == 1 or b == 1:\n        days_with_different_socks = 1\n    else:\n        days_with_different_socks = 2\n        days_with_same_socks = 1\n\n    if a > b:\n        days_with_same_socks += (a - b) // 2\n    else:\n        days_with_same_socks += (b - a) // 2\n\n    return f\"{days_with_different_socks} {days_with_same_socks}\"\n\n\ninput_string = \"7 3\"\nprint(solution(input_string)) "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days_different_socks = 1 + (a - 1) // 2 + (b - 1) // 2\n    max_days_same_socks = min(a, b) - 1\n    return f\"{max_days_different_socks} {max_days_same_socks}\"\n"
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = min(a, b)\n    remaining_days = max_days\n\n    if a < b:\n        max_days += 1\n    else:\n        max_days += 2\n\n    if a > b:\n        remaining_days += 1\n    else:\n        remaining_days += 2\n\n    return f\"{max_days} {remaining_days}\"\n"
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_different_socks = 1\n    max_same_socks = 0\n    while a > 0 and b > 0:\n        a -= 1\n        b -= 1\n        max_different_socks += 1\n        max_same_socks += 1\n    if a > 0:\n        max_different_socks -= 1\n        max_same_socks = 1\n    elif b > 0:\n        max_different_socks -= 1\n        max_same_socks = 0\n    return f\"{max_different_socks} {max_same_socks}\" "
    },
    {
        "number": 869,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, input().split())\n    if a > b:\n        max_days = 1\n        same_days = 0\n    else:\n        max_days = 2\n        same_days = 1\n    return f\"{max_days} {same_days}\"\n"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v_1, v_2 = map(int, stdin.split())\n    if d >= L:\n        return \"0.0\"\n    a = (L - d) / (v_1 - v_2)\n    b = (L + d) / (v_1 + v_2)\n    if a < 0 and b < 0:\n        return \"0.0\"\n    elif a < 0:\n        return f\"{b:.10f}\"\n    elif b < 0:\n        return f\"{a:.10f}\"\n    else:\n        return f\"{min(a, b):.10f}\"\n\ninput_1 = \"2 6 2 2\"\ninput_2 = \"1 9 1 2\"\nprint(solution(input_1))  # Output: 1.00000000000000000000\nprint(solution(input_2))  # Output: 2.66666666666666650000 "
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n\n    if d >= L:\n        return \"0.000000000000000000000\"\n\n    t_min = (L - d) / (v1 - v2)\n    t_max = L / v1\n\n    return f\"{min(t_max, t_min):.6f}\"\n"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n    if v1 == v2:\n        return \"0\"\n    elif v1 > v2:\n        v1, v2 = v2, v1\n        L = L - d\n    a = (L - d) / (v1 - v2)\n    b = L / v1\n    return str(max(a, b))\n"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n    delta = d / 2\n    \n    if v1 >= v2:\n        return \"0.0\"\n    \n    t1 = (delta - d) / (v1 - v2)\n    t2 = (L - delta) / (v2 - v1)\n    \n    if t1 >= 0 and t2 >= 0:\n        return str(max(t1, t2))\n    else:\n        return \"0.0\"\n"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n    t = (L - d) / (v1 - v2)\n    return f\"{t:.10f}\""
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n\n    def distance(t: float) -> float:\n        return (L - v1 * t) * (L - v1 * t) + (v2 * t) * (v2 * t)\n\n    def max_distance(t: float) -> float:\n        return L * L - d * d\n\n    t = 0\n    while distance(t) > max_distance(t):\n        t += 1\n\n    return f\"{t:.6f}\"\n\n\ndef"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, stdin.split())\n\n    # find the time it takes for the presses to meet\n    t = L / (v1 + v2)\n\n    # calculate the position of Luke at the end of the time interval\n    x = (v1 * v1 * t * (L - d) + v2 * v2 * t * (L + d)) / (v1 * t + v2 * t)\n\n    # calculate the maximum period of time Luke can stay alive\n    period = (v1 * v1 * t * (L - x) + v2 * v2 * t * (L + x)) / (v1 * t + v2 * t)\n\n    return f\"{period:.12f}\" "
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v1, v2 = map(int, input().split())\n    x1, x2 = 0, L\n    t = 0\n    period = 0\n\n    while x2 - x1 > d:\n        x1 += v1\n        x2 += v2\n        t += 1\n\n    if x2 - x1 < d:\n        period = t / 2\n\n    return str(period)\n\n\ninput_stdin = \"2 6 2 2\\n\"\noutput_stdout = \"1.00000000000000000000\\n\"\n\ninput_stdin2 = \"1 9 1 2\\n\"\noutput_stdout2 = \"2.66666666666666650000\\n\"\n\nprint(solution(input_stdin))  # Output: 1.0\nprint(solution(input_stdin2))  # Output: 2.666667"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    d, L, v_1, v_2 = map(int, input_data[0].split())\n\n    # Compute the time it takes for the two presses to meet\n    t = L / (v_1 - v_2)\n\n    # Compute the position of Luke at time t\n    x_L = v_1 * t - d / 2\n\n    # Check if Luke's position is within the segment\n    if 0 <= x_L <= L:\n        return f\"{t:.10f}\"\n    else:\n        return \"0.0\"\n"
    },
    {
        "number": 870,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, v1, v2 = map(int, stdin.split()[:3])\n    d = float(stdin.split()[3])\n\n    if v1 > v2:\n        v1, v2 = v2, v1\n        L, v1 = v1, L\n\n    time = ((L - d) / (v1 - v2)) * (1 - (d / L) ** 2)\n\n    return f\"{time:.12f}\""
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, s = map(int, input_list[0].split())\n    landings = sorted(map(lambda x: tuple(map(int, x.split())), input_list[1:]))\n\n    if len(landings) == 0:\n        return \"0 0\"\n\n    takeoff_time = 0\n    for i in range(n):\n        if landings[i][1] - takeoff_time >= s:\n            takeoff_time = landings[i][1]\n        else:\n            takeoff_time = max(takeoff_time, landings[i][1] + s)\n\n    return f\"{takeoff_time // 60} {takeoff_time % 60}\"\n\n\ndef"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    landings = [(int(time), int(minute)) for time, minute in [line.split() for line in input_list[1:]]]\n    \n    takeoff_time = landings[-1][0] + s + 1\n    for landing_time, _ in landings:\n        if landing_time + s + 1 < takeoff_time:\n            takeoff_time = landing_time + s + 1\n    \n    return f\"{takeoff_time // 60} {takeoff_time % 60}\"\n"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    landings = []\n    for i in range(n):\n        h, m = map(int, input().split())\n        landings.append((h, m))\n\n    landings.sort(key=lambda x: (x[0], x[1]))\n    takeoffs = []\n\n    for i in range(n):\n        if landings[i][1] > s and (i == 0 or landings[i-1][1] <= landings[i][1] - s):\n            takeoffs.append(landings[i][0] * 60 + landings[i][1] + 1)\n\n    if takeoffs:\n        takeoffs.sort()\n        h, m = divmod(takeoffs[0], 60)\n        return f\"{h} {m}\"\n    else:\n        return \"24 59\""
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    landings = sorted(map(int, stdin.split()[2:2+2*n:2]) + map(int, stdin.split()[3:3+2*n:2]))\n    takeoff_time = 24 * 60\n    for i in range(n):\n        landing_time = landings[i]\n        if landing_time <= s:\n            takeoff_time = max(takeoff_time, landing_time + s)\n    takeoff_h, takeoff_m = divmod(takeoff_time, 60)\n    return f\"{takeoff_h} {takeoff_m}\"\n\ninput_data = '''\n6 60\n0 0\n1 20\n3 21\n5 0\n19 30\n23 40\n'''\nprint(solution(input_data))\n"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    landings = sorted(map(int, input().split()))\n    takeoff = s + 1\n    earliest = -1\n    \n    for i in range(n):\n        landing = landings[i]\n        if takeoff <= landing:\n            earliest = takeoff\n            break\n        if i > 0:\n            time_before = landing - landings[i-1]\n            if time_before >= s:\n                earliest = landing\n    \n    if earliest == -1:\n        earliest = takeoff\n    \n    return f\"{earliest//60} {earliest%60}\" "
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple:\n        n, s = map(int, input_str.split())\n        landings = []\n        for _ in range(n):\n            h, m = map(int, input_str.split())\n            landings.append((h, m))\n        return landings, n, s\n\n    def insert_takeoff(landings: list, n: int, s: int) -> tuple:\n        h, m = 0, 0\n        if landings:\n            landing = landings[0]\n            h, m = landing[0], landing[1] + s + 1\n        return h, m\n\n    def earliest_time(landings: list, n: int, s: int) -> tuple:\n        h, m = 0, 0\n        while True:\n            h, m = insert_takeoff(landings, n, s)\n            if h == 23 and m == 59:\n                h, m = 0, 0\n                landings.pop(0)\n                n -= 1\n                if not landings:\n                    return h, m\n            else:\n                break\n        return h, m\n\n    landings, n, s = parse_input(stdin)\n    h, m = earliest_time(landings, n, s)\n    return f\"{h} {m}\" "
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def minutes_from_midnight(h: int, m: int) -> int:\n        return h * 60 + m\n\n    def is_valid_time(time: int, schedule: list, s: int) -> bool:\n        return all(minutes_from_midnight(h, m) - time >= s for h, m in schedule)\n\n    n, s = map(int, stdin.split()[:2])\n    schedule = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2 * n + 1, 2)]\n    schedule.sort(key=lambda x: x[1])\n\n    for h, m in schedule:\n        minutes = minutes_from_midnight(h, m)\n        if is_valid_time(minutes, schedule, s):\n            return f\"{h} {m}\"\n\n    # There is no valid time to insert the takeoff\n    h, m = schedule[-1]\n    minutes = minutes_from_midnight(h, m)\n    if minutes < 60 - s:\n        return f\"23 {60 - s}\"\n    else:\n        return f\"0 {minutes + s - 1440}\"\n"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse_time(s: str) -> int:\n        h, m = map(int, s.split(':'))\n        return h * 60 + m\n    \n    def format_time(t: int) -> str:\n        h, m = divmod(t, 60)\n        return f\"{h:02d}:{m:02d}\"\n\n    lines = stdin.split('\\n')\n    n, s = map(int, lines[0].split())\n    times = [parse_time(line.split()[1]) for line in lines[1:]]\n    times.sort()\n\n    for i, t in enumerate(times):\n        if t >= s:\n            if i == 0:\n                h, m = 0, 0\n            else:\n                h, m = divmod(times[i - 1] + s, 60)\n            return format_time(h * 60 + m)\n\n    h, m = divmod(times[-1] + s, 60)\n    return format_time(h * 60 + m)\n"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_time(time: str) -> int:\n        h, m = map(int, time.split(':'))\n        return h * 60 + m\n\n    def time_to_str(time: int) -> str:\n        h = time // 60\n        m = time % 60\n        return f\"{h:02d}:{m:02d}\"\n\n    n, s = map(int, stdin.split()[:2])\n    landings = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2 * n + 2, 2)]\n    landings.sort()\n\n    last_landing_time = parse_time(time_to_str(landings[-1][0] * 60 + landings[-1][1]))\n    takeoff_time = last_landing_time + s\n\n    earliest_insert_time = takeoff_time\n    for i in range(n - 1):\n        prev_landing_time = parse_time(time_to_str(landings[i][0] * 60 + landings[i][1]))\n        next_landing_time = parse_time(time_to_str(landings[i + 1][0] * 60 + landings[i + 1][1]))\n        if prev_landing_time - last_landing_time > s:\n            earliest_insert_time = prev_landing_time - s\n            break\n    else:\n        earliest_insert_time = takeoff_time\n\n    return time_to_str(earliest_insert_time // 60) + \" \" + time_to_str(earliest_insert_time % 60)\n"
    },
    {
        "number": 871,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, input().split())\n    landings = []\n    for _ in range(n):\n        h, m = map(int, input().split())\n        landings.append((h, m))\n    \n    # Sort landings by time\n    landings.sort()\n    \n    # Initialize variables\n    earliest_takeoff_h = 0\n    earliest_takeoff_m = 0\n    is_takeoff_inserted = False\n    \n    # Iterate over landings\n    for h, m in landings:\n        if m + s >= 60:\n            m = m - 60\n            h += 1\n        if not is_takeoff_inserted and h == earliest_takeoff_h and m >= earliest_takeoff_m + s:\n            # Insert takeoff before this landing\n            earliest_takeoff_h = h\n            earliest_takeoff_m = m\n            is_takeoff_inserted = True\n        elif h > earliest_takeoff_h or (h == earliest_takeoff_h and m > earliest_takeoff_m):\n            # Insert takeoff after this landing\n            earliest_takeoff_h = h\n            earliest_takeoff_m = m\n            is_takeoff_inserted = True\n    \n    # Check if takeoff can be inserted at the end of the schedule\n    if not is_takeoff_inserted:\n        earliest_takeoff_h = landings[-1][0] + 1\n        earliest_takeoff_m = 0\n        is_takeoff_inserted = True\n    \n    # Return result\n    result = f\"{earliest_takeoff_h} {earliest_takeoff_m}\"\n    return result"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    while True:\n        found = False\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (a[i] + a[j]) % 2 == 1:\n                    swap(a, i, j)\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            break\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    def is_odd(i: int, j: int) -> bool:\n        return a[i] + a[j] % 2 == 1\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if is_odd(i, j):\n                a[i], a[j] = a[j], a[i]\n                break\n    \n    return \" \".join(map(str, a))"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_odd(x: int) -> bool:\n        return x % 2 == 1\n\n    def odd_sum(a: int, b: int) -> bool:\n        return is_odd(a + b)\n\n    def swap(a: list, i: int, j: int) -> None:\n        a[i], a[j] = a[j], a[i]\n\n    def find_odd_sum_indices(a: list, target: int) -> list:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if odd_sum(a[i], a[j]) and a[i] + a[j] == target:\n                    return i, j\n        return -1, -1\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    min_a = a.copy()\n\n    while True:\n        i, j = find_odd_sum_indices(min_a, 1)\n        if i == -1:\n            break\n        swap(min_a, i, j)\n\n    return \" \".join(map(str, min_a))\n"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    a.sort()\n    return ' '.join(map(str, a))\n"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i]+a[j]) % 2 != 0:\n                a[i], a[j] = a[j], a[i]\n                break\n    return ' '.join(map(str, a))\n"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    i, j = 0, 1\n    while i < n - 1 and j < n:\n        if a[i] + a[j] % 2 == 1:\n            a[i], a[j] = a[j], a[i]\n            j += 1\n        else:\n            j += 1\n        i += 1\n    return \" \".join(map(str, a))\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solution(f\"{n}\\n{' '.join(map(str, a))}\")) "
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n\n    # Perform the operation as many times as possible\n    while True:\n        swap_made = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (a[i] + a[j]) % 2 == 1:\n                    a[i], a[j] = a[j], a[i]\n                    swap_made = True\n                    break\n            if swap_made:\n                break\n        if not swap_made:\n            break\n\n    # Convert the array to a string and return it\n    return \" \".join(str(x) for x in a)"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i] + a[j]) % 2 == 1:\n                a[i], a[j] = a[j], a[i]\n                break\n\n    return \" \".join(map(str, a))\n\n\ndef"
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_odd(a, b):\n        return a + b % 2 == 1\n\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_odd(a[i], a[j]):\n                swap(a, i, j)\n                break\n    return \" \".join(map(str, a))\n\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solution(str(n) + \"\\n\" + \" \".join(map(str, a)))) "
    },
    {
        "number": 872,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    swapped = False\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (a[i] + a[j]) % 2 == 1:\n                a[i], a[j] = a[j], a[i]\n                swapped = True\n                break\n        if swapped:\n            break\n\n    return ' '.join(map(str, a))\n"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, original_state, combination = input().split()\n    n = int(n)\n    original_state = list(original_state)\n    combination = list(combination)\n    \n    min_moves = 0\n    for i in range(n):\n        if original_state[i] != combination[i]:\n            min_moves += 1\n            \n    return str(min_moves)\n\n\ndef"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    original = input()\n    combination = input()\n\n    # Convert strings to lists\n    original_list = [int(d) for d in original]\n    combination_list = [int(d) for d in combination]\n\n    # Initialize the minimum number of moves\n    min_moves = 0\n\n    # Iterate through the disks and compare the original state with the combination\n    for i in range(n):\n        if original_list[i] != combination_list[i]:\n            min_moves += 1\n            # If the digit has been decreased, move the digit backwards\n            if original_list[i] > combination_list[i]:\n                original_list[i] = (original_list[i] - 1) % 10\n            # If the digit has been increased, move the digit forwards\n            else:\n                original_list[i] = (original_list[i] + 1) % 10\n\n    print(min_moves)\n\n\nstdin = \"\"\"\n5\n82195\n64723\n\"\"\"\n\nsolution(stdin) "
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, original_state, target_state = input().split()\n    n = int(n)\n\n    original_state = list(map(int, original_state))\n    target_state = list(map(int, target_state))\n\n    moves = 0\n    for i in range(n):\n        if original_state[i] != target_state[i]:\n            original_state[i] += 1 if original_state[i] < 9 else -10\n            moves += 1\n\n    return str(moves)\n"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(disk, direction):\n        if direction == \"f\":\n            return (disk + 1) % 10\n        else:\n            return (disk - 1) % 10\n\n    def min_moves(original_state: str, target_state: str) -> int:\n        moves = 0\n        for i in range(len(original_state)):\n            if original_state[i] != target_state[i]:\n                original_state[i] = rotate(original_state[i], \"f\")\n                while original_state[i] != target_state[i]:\n                    original_state[i] = rotate(original_state[i], \"f\")\n                    moves += 1\n        return moves\n\n    n, original_state, target_state = input().split()\n    return str(min_moves(list(map(int, original_state)), list(map(int, target_state))))\n"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, original_state, combination = stdin.split('\\n')\n    n = int(n)\n    original_state = [int(d) for d in original_state]\n    combination = [int(c) for c in combination]\n    \n    def rotate_disk(disk: int, direction: int) -> int:\n        if direction == 1:\n            return (disk + 1) % 10\n        else:\n            return (disk - 1) % 10\n    \n    def update_state(state: list, disk: int, direction: int) -> list:\n        new_state = state.copy()\n        new_state[disk] = rotate_disk(new_state[disk], direction)\n        return new_state\n\n    def manhattan_distance(state: list, target_state: list) -> int:\n        return sum(abs(s - t) for s, t in zip(state, target_state))\n    \n    def min_moves_to_open(state: list, target_state: list) -> int:\n        queue = [(state, 0)]\n        visited = set()\n        while queue:\n            current_state, current_moves = queue.pop(0)\n            if current_state == target_state:\n                return current_moves\n            if tuple(current_state) in visited:\n                continue\n            visited.add(tuple(current_state))\n            for disk in range(n):\n                for direction in [1, -1]:\n                    new_state = update_state(current_state, disk, direction)\n                    queue.append((new_state, current_moves + 1))\n        return -1\n\n    target_state = [combination[i] - original_state[i] for i in range(n)]\n    min_moves = min_moves_to_open(original_state, target_state)\n    return str(min_moves)\n\n\nstdin = \"\"\"5\n82195\n64723\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    original_state = lines[1]\n    secret_combination = lines[2]\n\n    moves = 0\n    for i in range(n):\n        if original_state[i] != secret_combination[i]:\n            if original_state[i] > secret_combination[i]:\n                diff = int(original_state[i]) - int(secret_combination[i])\n                moves += diff\n            else:\n                diff = int(secret_combination[i]) - int(original_state[i])\n                moves += diff\n\n    print(moves)"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    original_state = stdin.split(\"\\n\")[1]\n    secret_combination = stdin.split(\"\\n\")[2]\n\n    def rotate_disk(digit, direction):\n        if digit == \"9\":\n            return \"0\"\n        elif digit == \"0\":\n            return \"9\"\n        else:\n            return str(int(digit) + direction)\n\n    def calculate_moves(original_state, secret_combination):\n        moves = 0\n        for i in range(n):\n            if original_state[i] != secret_combination[i]:\n                moves += 1\n        return moves\n\n    def find_best_path(original_state, secret_combination):\n        memo = {}\n        def dfs(state, idx, prev_move):\n            if idx == n:\n                return 0\n            if (state, idx) in memo:\n                return memo[(state, idx)]\n            best_move = float('inf')\n            for i in range(2):\n                if idx == 0 or original_state[idx] == secret_combination[idx - 1]:\n                    next_state = state[:idx] + rotate_disk(original_state[idx], i - prev_move) + state[idx + 1:]\n                    best_move = min(best_move, dfs(next_state, idx + 1, i) + (i - prev_move) * (idx + 1))\n            memo[(state, idx)] = best_move\n            return best_move\n\n        return dfs(original_state, 0, 0)\n\n    return str(calculate_moves(original_state, secret_combination) + find_best_path(original_state, secret_combination))\n\n\ninput_str = \"\"\"5\n82195\n64723\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    original_state = stdin.split('\\n')[1]\n    combination = stdin.split('\\n')[2]\n\n    original_state = [int(digit) for digit in original_state]\n    combination = [int(digit) for digit in combination]\n\n    moves = 0\n    for i in range(n):\n        if original_state[i] != combination[i]:\n            original_state[i] = (original_state[i] + 1) % 10\n            moves += 1\n\n    return str(moves)\n"
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, start, target = input(stdin).split('\\n')\n    n = int(n)\n    start = tuple(int(c) for c in start)\n    target = tuple(int(c) for c in target)\n\n    def rotate(state, disk, direction):\n        index = state.index(disk)\n        state[index] = (disk + direction) % 10\n\n    def count_moves(state, target):\n        result = 0\n        for disk, target_digit in enumerate(target):\n            if state[disk] != target_digit:\n                result += 1\n                rotate(state, disk, 1)\n                while state[disk] != target_digit:\n                    rotate(state, disk, 1)\n                rotate(state, disk, -1)\n        return result\n\n    return count_moves(start, target)\n\n\ninput_string = '''5\n82195\n64723'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 873,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, original_state, combination = input(stdin).split(\"\\n\")\n    n = int(n)\n    original_state = [int(d) for d in original_state]\n    combination = [int(d) for d in combination]\n\n    def next_state(state: list, direction: int) -> list:\n        return [(s + direction) % 10 for s in state]\n\n    def is_valid(state: list, direction: int) -> bool:\n        return all(s == c for s, c in zip(state, combination))\n\n    def bfs(start: list) -> int:\n        visited = set()\n        queue = [(start, 0)]\n\n        while queue:\n            state, moves = queue.pop(0)\n            if is_valid(state, 1):\n                return moves\n\n            visited.add(tuple(state))\n            for direction in [1, -1]:\n                next_state_ = next_state(state, direction)\n                if tuple(next_state_) not in visited:\n                    queue.append((next_state_, moves + 1))\n\n        return -1\n\n    return bfs(original_state)\n\n\ninput_data = '''5\n82195\n64723\n'''\nprint(solution(input_data)) "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0 and n > 2:\n        return \" \".join(map(str, range(2, n, 2) + range(1, 2)))\n    if n % 2 == 1:\n        return \" \".join(map(str, range(1, n+1)))\n    return \"-1\"\n\nprint(solution(input())) "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"2 1\"\n    for i in range(2, n):\n        if any(i == (i - 1) + j for j in range(i)):\n            return \" \".join(str(i) for i in range(1, n + 1))\n    return \"-1\"\n\n\nstdin = \"4\"\nprint(solution(stdin)) # Output: 2 1 4 3 "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"2 1\"\n    elif n == 2:\n        return \"1 2\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"2 1\"\n    for i in range(2, n + 1):\n        perfect = True\n        for j in range(1, n + 1):\n            if (i in [j, j + 1]) or (j in [i - 1, i]):\n                continue\n            perfect = False\n            break\n        if perfect:\n            return \" \".join(map(str, range(1, n + 1)))\n    return \"-1\"\n"
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 1:\n        return \" \".join(str(i) for i in range(1, n+1, 2))\n    else:\n        return \" \".join(str(i) for i in range(2, n+1, 2)) + \" 1\"\n\ndef"
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    if n == 1:\n        return \"1 1\"\n\n    for i in range(1, n+1):\n        if n % i != 0:\n            continue\n        if i > 1 and n // i == 1:\n            continue\n        if i == 1 or n // i == 1:\n            return str(n) + \" \" + str(1)\n        return str(i) + \" \" + str(n//i) + \" \" + str(n)\n\n    return \"-1\"\n\nn = int(input())\nprint(solution(n)) "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    if n % 2 == 0:\n        perfect_perm = [i for i in range(1, n + 1)]\n        perfect_perm.append(n)\n        return ' '.join(map(str, perfect_perm))\n    else:\n        return '-1'\n\n\ndef"
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \" \".join(str(i) for i in range(1, n + 1, 2))\n    else:\n        return \" \".join(str(i) for i in range(1, n + 1, 2)) + \" \" + str(n)\n\n\nstdin = input()\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        perfect_permutation = [i for i in range(1, n+1)]\n        perfect_permutation[n//2-1] = n\n    else:\n        perfect_permutation = [i for i in range(1, n+1)]\n        perfect_permutation[n//2] = n\n    return \" \".join(map(str, perfect_permutation))\n\n\ninput_str = input(\"Enter the permutation size: \")\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 874,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n == 1:\n        return \"-1\"\n    \n    perfect_perm = []\n    for i in range(1, n+1):\n        perfect_perm.append(i)\n    \n    for i in range(n):\n        if perfect_perm[i] != i+1:\n            perfect_perm[i] = i+1\n            break\n    else:\n        return \"-1\"\n    \n    return \" \".join(map(str, perfect_perm))\n\n\ndef"
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    initial_positions = list(map(int, stdin[1].strip().split()))\n    matrix = [list(line.strip()) for line in stdin[2:n+2]]\n\n    def is_valid_move(src, dst):\n        src_row, src_col = src\n        dst_row, dst_col = dst\n        if matrix[src_row][src_col] == '*':\n            return False\n        if matrix[dst_row][dst_col] != '*':\n            return False\n        color = matrix[src_row][src_col]\n        for i in range(n):\n            if matrix[i][src_col] == color and matrix[i][dst_col] == '*':\n                return True\n            if matrix[dst_row][i] == color and matrix[src_row][i] == '*':\n                return True\n        return False\n\n    def is_win():\n        return all(matrix[i][i] != '*' for i in range(n))\n\n    def dfs(moves):\n        if is_win():\n            return True, moves\n        for src in range(n):\n            for dst in range(n):\n                if src != dst and is_valid_move((src, dst), (dst, src)):\n                    matrix[src][dst] = matrix[dst][src] = '*'\n                    matrix[src][src] = matrix[dst][dst] = '*'\n                    result, moves = dfs(moves + [(src, dst)])\n                    if result:\n                        return result, moves\n                    matrix[src][dst] = matrix[dst][src] = matrix[src][src] = matrix[dst][dst] = '*'\n        return False, moves\n\n    result, moves = dfs([])\n    if result:\n        output = str(len(moves)) + '\\n' + '\\n'.join(f\"{src + 1} {dst + 1}\" for src, dst in moves)\n    else:\n        output = -1\n    return output\n\n\ndef"
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    initial_positions = list(map(int, stdin.splitlines()[1].split()))\n    colors = [list(line.strip()) for line in stdin.splitlines()[2:n+2]]\n\n    def find_moves(stone_pos, stone_color):\n        moves = []\n        for i in range(n):\n            if colors[stone_pos][i] == stone_color and i != stone_pos:\n                moves.append((stone_pos, i))\n        return moves\n\n    def is_win(stone_positions):\n        return all(pos in stone_positions for pos in [1, 2, 3])\n\n    stone_positions = {pos: color for pos, color in zip(initial_positions, 'abcdefghijklmnopqrstuvwxyz')}\n    moves = 0\n\n    while not is_win(stone_positions):\n        moves += 1\n        new_stone_positions = stone_positions.copy()\n\n        for stone_pos, stone_color in stone_positions.items():\n            available_moves = find_moves(stone_pos, stone_color)\n\n            if available_moves:\n                new_stone_position = max(available_moves, key=lambda x: x[1])[1]\n                new_stone_positions.pop(stone_pos)\n                new_stone_positions[new_stone_position] = stone_color\n\n        stone_positions = new_stone_positions\n\n    if moves == -1:\n        return -1\n    else:\n        return moves, *[(stone_positions[pos], pos) for pos in [1, 2, 3]]\n\n\ninput_str = \"\"\"4\n2 3 4\n*aba\na*ab\nba*b\nabb*\"\"\"\n\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    start_vertices = list(map(int, stdin.split('\\n')[1].split()))\n    colors = [list(line.strip()) for line in stdin.split('\\n')[2:] if line.strip()]\n    assert len(colors) == n\n    assert all(len(colors[i]) == n for i in range(n))\n    assert all(c in 'abcdefghijklmnopqrstuvwxyz*' for row in colors for c in row)\n\n    def is_valid_move(from_point, to_point):\n        color = colors[from_point - 1][to_point - 1]\n        if color == '*':\n            return False\n        for i in range(n):\n            if colors[from_point - 1][i] == color and colors[i][to_point - 1] == color:\n                return True\n        return False\n\n    def find_best_move():\n        best_move = None\n        best_score = float('inf')\n        for from_point in start_vertices:\n            for to_point in range(1, n + 1):\n                if from_point != to_point and is_valid_move(from_point, to_point):\n                    score = abs(from_point - to_point) + abs(from_point - to_point) * 10\n                    if score < best_score:\n                        best_move = (from_point, to_point)\n                        best_score = score\n        return best_move, best_score\n\n    best_move, best_score = find_best_move()\n    if best_move is None:\n        return -1\n    else:\n        return best_score, f\"{best_move[0]} {best_move[1]}\"\n\n\ninput_data = '''4\n2 3 4\n*aba\na*ab\nba*b\nabb*'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0].strip())\n    initial_positions = [int(pos) for pos in stdin.split('\\n')[1].strip().split()]\n    colors = [list(line) for line in stdin.split('\\n')[2:n+2]]\n\n    def is_valid_move(point, color, position, visited):\n        for neighbor in range(1, n+1):\n            if neighbor != point and colors[point-1][neighbor-1] == color and not visited[neighbor-1]:\n                return neighbor\n        return None\n\n    def dfs(point, color, visited, result):\n        if point in initial_positions[:3]:\n            return True\n        visited[point-1] = True\n        for neighbor in range(1, n+1):\n            if colors[point-1][neighbor-1] == color and not visited[neighbor-1]:\n                if dfs(neighbor, color, visited, result):\n                    result.append((point, neighbor))\n                    return True\n        visited[point-1] = False\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if colors[i][j] == '*':\n                colors[i][j] = 'a'\n\n    visited = [False] * n\n    result = []\n    found = False\n    for i in range(n):\n        for color in set(colors[i]):\n            if color != '*' and not visited[i]:\n                point = is_valid_move(i+1, color, visited, visited)\n                if point:\n                    found = dfs(point, color, visited, result)\n                    if found:\n                        break\n            if found:\n                break\n        if found:\n            break\n\n    if not found:\n        return \"-1\\n\"\n\n    moves = len(result)\n    for move in result:\n        print(move[0], move[1])\n    return f\"{moves}\\n\""
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_color(i: int, j: int) -> str:\n        return matrix[i][j]\n\n    def is_valid_move(point: int, to: int) -> bool:\n        for i in range(1, n + 1):\n            if i != point and i != to and matrix[i][point] == matrix[i][to]:\n                return True\n        return False\n\n    def find_moves(point: int) -> List[Tuple[int, int]]:\n        moves = []\n        for i in range(1, n + 1):\n            if i != point and matrix[point][i] != '*' and is_valid_move(point, i):\n                moves.append((point, i))\n        return moves\n\n    def dfs(point: int, visited: Set[int], path: List[int]) -> bool:\n        if point in visited:\n            return False\n        visited.add(point)\n        path.append(point)\n        if len(path) == 3:\n            return True\n        for move in find_moves(point):\n            if dfs(move[1], visited, path):\n                return True\n        return False\n\n    n, vertices = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        matrix[i][i] = '*'\n\n    if vertices[0] == 1 and vertices[1] == 2 and vertices[2] == 3:\n        print(0)\n        return\n\n    visited = set()\n    path = []\n    if dfs(vertices[0], visited, path) or dfs(vertices[1], visited, path) or dfs(vertices[2], visited, path):\n        print(1)\n        for move in path:\n            print(move, end=' ')\n    else:\n        print(-1)\n"
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *vertices = [int(x) for x in stdin.split()]\n    color_matrix = [input().split() for _ in range(n)]\n    stones = set(vertices)\n    free_vertices = set(range(1, n+1)) - stones\n    moves = []\n    used_colors = set()\n\n    def get_diagonal_color(i, j):\n        color = color_matrix[i-1][j-1]\n        if color == '*':\n            return None\n        return color\n\n    def is_valid_move(from_vertex, to_vertex):\n        color = get_diagonal_color(from_vertex, to_vertex)\n        if color is None:\n            return False\n        return color not in used_colors\n\n    def move_stone(from_vertex, to_vertex):\n        moves.append((from_vertex, to_vertex))\n        stones.remove(from_vertex)\n        stones.add(to_vertex)\n        used_colors.add(get_diagonal_color(from_vertex, to_vertex))\n\n    def backtrack():\n        if not free_vertices:\n            return True\n        for vertex in list(stones):\n            for to_vertex in free_vertices:\n                if is_valid_move(vertex, to_vertex):\n                    move_stone(vertex, to_vertex)\n                    if backtrack():\n                        return True\n                    stones.remove(to_vertex)\n                    moves.pop()\n                    used_colors.remove(get_diagonal_color(vertex, to_vertex))\n        return False\n\n    if not backtrack():\n        return -1\n\n    return len(moves), *moves\n"
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    initial_positions = list(map(int, input().split()))\n    matrix = []\n    for i in range(n):\n        matrix.append(list(input()))\n\n    def dfs(current_pos, visited, color, result, moves):\n        if current_pos == 1 or current_pos == 2 or current_pos == 3:\n            result.append((current_pos, 1))\n            return True\n        if current_pos in visited:\n            return False\n        visited.add(current_pos)\n        for i in range(n):\n            if matrix[current_pos][i] == color and i not in visited:\n                if dfs(i, visited, color, result, moves):\n                    result.append((current_pos, i))\n                    return True\n        return False\n\n    for i in range(n):\n        visited = set()\n        for j in 'abcdefghijklmnopqrstuvwxyz':\n            if j == matrix[0][i]:\n                if i == 0 or i == 1 or i == 2:\n                    result = []\n                    visited = set()\n                    if dfs(i, visited, j, result, 1):\n                        print(1)\n                        for r in result:\n                            print(r[0], r[1])\n                        return\n    print(-1)\n\n\ninput_str = '''4\n2 3 4\n*aba\na*ab\nba*b\nabb*'''\n\nsolution(input_str) "
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    initial_positions = list(map(int, stdin.split('\\n')[1].split()))\n    color_matrix = [list(line.strip()) for line in stdin.split('\\n')[2:] if line.strip()]\n\n    def is_valid_move(from_point, to_point, color):\n        if from_point == to_point:\n            return False\n        if color_matrix[from_point - 1][to_point - 1] == color:\n            return True\n        return False\n\n    def get_possible_moves(current_positions):\n        moves = []\n        for i, color in enumerate(current_positions):\n            if color == '*':\n                continue\n            for j, other_color in enumerate(current_positions):\n                if j == i:\n                    continue\n                if is_valid_move(i + 1, j + 1, color):\n                    moves.append((i, j))\n        return moves\n\n    def dfs(current_positions, depth):\n        if depth == 0:\n            return depth\n        if set(current_positions) == {'*'}:\n            return dfs(current_positions, depth - 1)\n        moves = get_possible_moves(current_positions)\n        if not moves:\n            return -1\n        for from_point, to_point in moves:\n            new_positions = list(current_positions)\n            new_positions[from_point] = '*'\n            new_positions[to_point] = current_positions[from_point]\n            result = dfs(new_positions, depth - 1)\n            if result == -1:\n                continue\n            return result + 1\n\n    result = dfs(initial_positions, n - 1)\n    if result == -1:\n        return str(result)\n    else:\n        moves = []\n        current_positions = initial_positions\n        for i in range(result):\n            moves.append((current_positions.index('*') + 1, initial_positions.index(current_positions[current_positions.index('*')]) + 1))\n            new_positions = list(current_positions)\n            new_positions[current_positions.index('*')] = initial_positions[current_positions.index('*')]\n            current_positions = new_positions\n        return str(result) + '\\n' + '\\n'.join([f\"{move[0]} {move[1]}\" for move in moves]) "
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    vertices = list(map(int, input_list[1].split()))\n    matrix = [list(line) for line in input_list[2:n+2]]\n    \n    # Function to check if a move is valid\n    def is_valid_move(from_point, to_point, color):\n        return matrix[from_point-1][to_point-1] == color and matrix[to_point-1][from_point-1] == color\n    \n    # Function to find the minimum number of moves\n    def find_min_moves(vertices, matrix):\n        moves = 0\n        stone1, stone2, stone3 = vertices\n        if stone1 == 1:\n            for color in matrix[0]:\n                if is_valid_move(stone1, stone2, color) and is_valid_move(stone1, stone3, color):\n                    moves += 1\n                    return moves\n        return -1\n    \n    # Find the minimum number of moves\n    min_moves = find_min_moves(vertices, matrix)\n    \n    # If there is no way to put stones on vertices 1, 2 and 3, print -1\n    if min_moves == -1:\n        return \"-1\"\n    \n    # Print the minimum number of moves\n    output = [str(min_moves)]\n    \n    # Print each move\n    for move in range(min_moves):\n        for i in range(n):\n            for j in range(n):\n                if is_valid_move(vertices[i], vertices[j], matrix[i][j]):\n                    output.append(f\"{vertices[i]} {vertices[j]}\")\n                    break\n            else:\n                continue\n            break\n    \n    return \"\\n\".join(output)"
    },
    {
        "number": 875,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].split()[0])\n    stones = [int(i) for i in stdin[1].split()]\n    colors = []\n    for i in range(n):\n        colors.append([])\n        for j in range(i+1):\n            colors[i].append(stdin[2+i][j])\n\n    def is_valid(move):\n        from_point, to_point = move\n        if from_point == to_point:\n            return False\n        if to_point not in [1, 2, 3]:\n            return False\n        if to_point in [from_point, from_point-1, from_point+1]:\n            return False\n        if colors[from_point][to_point] != colors[to_point][from_point]:\n            return False\n        return True\n\n    def get_valid_moves(point):\n        moves = []\n        for to_point in range(1, n+1):\n            if colors[point][to_point] == '*':\n                continue\n            if to_point not in [1, 2, 3] and to_point not in [point-1, point, point+1]:\n                continue\n            if is_valid([point, to_point]):\n                moves.append([point, to_point])\n        return moves\n\n    def minimax(depth, alpha, beta, is_max):\n        if depth == 0:\n            return 0\n        if is_max:\n            best_score = -float('inf')\n            valid_moves = get_valid_moves(stones[0])\n            for move in valid_moves:\n                from_point, to_point = move\n                stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n                score = minimax(depth-1, alpha, beta, False)\n                stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n                if score > best_score:\n                    best_score = score\n                alpha = max(alpha, best_score)\n                if alpha >= beta:\n                    break\n            return best_score\n        else:\n            best_score = float('inf')\n            valid_moves = get_valid_moves(stones[1])\n            valid_moves.extend(get_valid_moves(stones[2]))\n            for move in valid_moves:\n                from_point, to_point = move\n                stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n                score = minimax(depth-1, alpha, beta, True)\n                stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n                if score < best_score:\n                    best_score = score\n                beta = min(beta, best_score)\n                if alpha >= beta:\n                    break\n            return best_score\n\n    score = minimax(n-1, -float('inf'), float('inf'), True)\n    if score == -float('inf'):\n        return \"-1\"\n    else:\n        moves = []\n        valid_moves = get_valid_moves(stones[0])\n        best_score = -float('inf')\n        best_move = None\n        for move in valid_moves:\n            from_point, to_point = move\n            stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n            score = minimax(n-2, -float('inf'), float('inf'), True)\n            stones[from_point], stones[to_point] = stones[to_point], stones[from_point]\n            if score > best_score:\n                best_score = score\n                best_move = [from_point, to_point]\n        moves.append(best_move)\n        valid_moves = get_valid_moves(stones[1])\n        valid_moves.extend(get_valid_moves(stones[2]))\n        for move in valid_moves:\n            from_point, to_point = move\n            stones[from_point], stones[to_point] = stones[to_point], stones["
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def p(x):\n        return [sum(x[:i+1]) for i in range(len(x)+1)]\n\n    n, k = map(int, stdin.split()[:2])\n    A0 = list(map(int, stdin.split()[2:]))\n\n    if k <= A0[0]:\n        return \"0\"\n\n    i = 1\n    while k > A0[i]:\n        i += 1\n\n    return str(i)\n\n\ninput_stdin = \"2 2\\n1 1\"\nprint(solution(input_stdin))  # Output: 1\n\ninput_stdin = \"3 6\\n1 1 1\"\nprint(solution(input_stdin))  # Output: 2\n\ninput_stdin = \"3 1\\n1 0 1\"\nprint(solution(input_stdin))  # Output: 0 "
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    A0 = list(map(int, input_list[1].split()))\n\n    def p(x):\n        y = [0] * (len(x) + 1)\n        y[0] = 0\n        for i in range(1, len(x) + 1):\n            y[i] = y[i - 1] + x[i - 1]\n        return y\n\n    A = A0\n    i = 0\n    while A[-1] < k:\n        A = p(A)\n        i += 1\n    return str(i)"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    A0 = list(map(int, input().split()))\n\n    def p(x):\n        y = [0] * (len(x) + 1)\n        for i in range(len(x)):\n            y[i+1] = y[i] + x[i]\n        return y\n\n    A = A0\n    i = 0\n    while A[n-1] < k:\n        A = p(A)\n        i += 1\n\n    return str(i)\n"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    n, k = map(int, input_values[0].split())\n    A0 = list(map(int, input_values[1].split()))\n    i = 0\n    while A0[i] < k:\n        i += 1\n    return str(i)\n"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    A0 = list(map(int, input_data[1].split()))\n    \n    def p(x):\n        y = [0] * (len(x) + 1)\n        for i in range(len(x) + 1):\n            y[i] = sum(x[:i])\n        return y\n    \n    def find_i(A0, k):\n        i = 0\n        while True:\n            A = p(A0)\n            if k in A:\n                return i\n            i += 1\n            A0 = A\n    \n    return str(find_i(A0, k))\n"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    A_0 = list(map(int, stdin.split()[2:]))\n    A_0.sort(reverse=True)\n    min_i = -1\n    i = 1\n    while min_i == -1:\n        if A_0[i-1] >= k:\n            min_i = i-1\n        else:\n            A_i = p(A_0[:i-1])\n            A_i.sort(reverse=True)\n            A_0 = A_0[:i-1] + A_i\n            i += 1\n    return str(min_i)\n\n\ndef"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def p(x):\n        return [sum(x[:i+1]) for i in range(len(x))]\n\n    n, k = map(int, stdin.splitlines()[0].split())\n    A0 = list(map(int, stdin.splitlines()[1].split()))\n\n    i = 0\n    while A0[-1] < k:\n        i += 1\n        A0 = p(A0)\n\n    return str(i)\n"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    A_0 = list(map(int, input_list[1].split()))\n    \n    def p(x: list) -> list:\n        y = [0] * (len(x) + 1)\n        for i in range(len(x) + 1):\n            y[i] = sum(x[:i])\n        return y\n    \n    def find_i(A: list) -> int:\n        for i in range(len(A)):\n            if A[i] >= k:\n                return i\n        return len(A)\n    \n    A_1 = p(A_0)\n    i = find_i(A_1)\n    \n    while True:\n        A_i = p(A_1)\n        i_new = find_i(A_i)\n        if i_new <= i:\n            break\n        i = i_new\n        A_1 = A_i\n    \n    return str(i)\n"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def p(x):\n        return [sum(x[:i+1]) for i in range(len(x))]\n\n    def find_min_i(A, k):\n        for i in range(len(A)):\n            if A[i] >= k:\n                return i\n        return len(A)\n\n    n, k = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    A_curr = A\n    i = 0\n    while True:\n        A_next = p(A_curr)\n        i += 1\n        if k in A_next:\n            return i\n        A_curr = A_next"
    },
    {
        "number": 876,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, k = map(int, input_str.split()[:2])\n    A0 = list(map(int, input_str.split()[2:]))\n    A = A0\n\n    i = 0\n    while True:\n        A = p(A)\n        if k in A:\n            return i\n        i += 1\n\n\ndef"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(pos: int, divs: int, used: set, limit: int, visited: set, memo: dict) -> int:\n        if pos == n:\n            return divs\n        if (pos, divs) in memo:\n            return memo[(pos, divs)]\n        res = 0\n        for i in range(pos, n):\n            if i in used or (i, divs) in visited:\n                continue\n            used.add(i)\n            visited.add((i, divs))\n            res += dfs(i + 1, divs ^ 1, used, limit, visited, memo)\n            used.remove(i)\n            visited.remove((i, divs))\n            if i < limit and (divs & 1) == 0:\n                memo[(pos, divs)] = res\n                break\n        return res\n\n    n, m = map(int, stdin.split()[:2])\n    limit = 1\n    for i in range(m):\n        u, v = map(int, stdin.split()[2 * i + 2: 2 * i + 4])\n        limit = max(limit, u, v)\n\n    memo = {}\n    res = dfs(0, 1, set(), limit, set(), memo)\n    return str(res)\n"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    similar_problems = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def count_ways(used_problems: set) -> int:\n        if len(used_problems) > n:\n            return 0\n        if len(used_problems) == n:\n            return 1\n        count = 0\n        for i in range(1, n + 1):\n            if i not in used_problems:\n                count += count_ways(used_problems | {i})\n        return count\n\n    count = 0\n    for similar_problem in similar_problems:\n        count += count_ways(set(similar_problem))\n\n    return str(count)\n\n\ninput_data = '''5 2\n1 4\n5 2'''\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    similar_problems = []\n    for _ in range(m):\n        similar_problems.append(tuple(map(int, input().split())))\n    \n    # Create a list of problems sorted by difficulty\n    problems = list(range(1, n+1))\n    \n    # Initialize the count of ways to split problems\n    ways_to_split = 0\n    \n    # Iterate through all possible pairs of divisions\n    for division_1 in range(1, n+1):\n        division_2 = n + 1 - division_1\n        used_problems_division_1 = set()\n        used_problems_division_2 = set()\n        \n        # Check if division 1 is empty\n        if division_1 == n:\n            ways_to_split += 1\n            continue\n        \n        # Iterate through all problems in division 1\n        for problem in problems:\n            # Check if the problem is already used in division 2\n            if problem in used_problems_division_2:\n                continue\n            \n            # Check if the problem is similar to any problem in division 2\n            if any(problem in similar_problems[i] for i in range(m) if problem in used_problems_division_1):\n                continue\n            \n            # Check if the problem is not similar to any problem in division 1\n            if not any(problem in similar_problems[i] for i in range(m) if problem in used_problems_division_2):\n                used_problems_division_1.add(problem)\n                ways_to_split += 1\n                \n        # Check if division 2 is empty\n        if division_2 == n:\n            ways_to_split += 1\n            continue\n        \n        # Iterate through all problems in division 2\n        for problem in problems:\n            # Check if the problem is already used in division 1\n            if problem in used_problems_division_1:\n                continue\n            \n            # Check if the problem is similar to any problem in division 1\n            if any(problem in similar_problems[i] for i in range(m) if problem in used_problems_division_2):\n                continue\n            \n            # Check if the problem is not similar to any problem in division 2\n            if not any(problem in similar_problems[i] for i in range(m) if problem in used_problems_division_1):\n                used_problems_division_2.add(problem)\n                ways_to_split += 1\n                \n    return str(ways_to_split)\n"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(n: int, m: int, used: set, similar: set, visited: set, d1: set, d2: set, result: int) -> int:\n        if len(d1) == 0 and len(d2) == 0:\n            return result + 1\n        if len(d1) > 0:\n            next_used = used.copy()\n            next_used.add(list(d1)[0])\n            next_d1 = d1.copy()\n            next_d1.remove(list(d1)[0])\n            next_d2 = d2.copy()\n            for u in similar[list(d1)[0]]:\n                if u not in next_used:\n                    next_used.add(u)\n                    next_d2.add(u)\n            return dfs(n, m, next_used, similar, visited, next_d1, next_d2, result)\n        if len(d2) > 0:\n            next_used = used.copy()\n            next_used.add(list(d2)[0])\n            next_d2 = d2.copy()\n            next_d2.remove(list(d2)[0])\n            next_d1 = d1.copy()\n            for v in similar[list(d2)[0]]:\n                if v not in next_used:\n                    next_used.add(v)\n                    next_d1.add(v)\n            return dfs(n, m, next_used, similar, visited, next_d1, next_d2, result)\n        return 0\n\n    n, m = map(int, stdin.split()[:2])\n    similar = [set() for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        similar[u].add(v)\n        similar[v].add(u)\n    return dfs(n, m, set(), similar, set(), set(), set(), 0)"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(problems, used, visited, res, last_used):\n        if len(problems) == 0:\n            res[0] += 1\n            return\n        for i in range(1, n+1):\n            if used[i] or visited[i]:\n                continue\n            if last_used and last_used[0] > i:\n                continue\n            used[i] = True\n            for j in range(1, n+1):\n                if not problems[i-1][j-1]:\n                    continue\n                visited[j] = True\n                dfs(problems, used, visited, res, [i])\n                visited[j] = False\n            used[i] = False\n\n    n, m = map(int, stdin.split()[:2])\n    problems = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n    used = [False] * (n+1)\n    visited = [False] * (n+1)\n    res = [0]\n    last_used = None\n    dfs(problems, used, visited, res, last_used)\n    return res[0]\n\n\ninput_data = '''5 2\n1 4\n5 2\n'''\n\nprint(solution(input_data))  # Output: 2 "
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph: list, used: list, visited: list, result: int):\n        if len(used) == 1:\n            result[0] += 1\n            return\n\n        for node in range(1, n + 1):\n            if not visited[node] and not any(graph[used[0]][node] for used in used_indices):\n                used_indices.append([used[0], node])\n                visited[node] = True\n                dfs(graph, used_indices, visited, result)\n                visited[node] = False\n                used_indices.pop()\n\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    used_indices = []\n    visited = [False] * (n + 1)\n    result = [0]\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    used_indices.append([1])\n    visited[1] = True\n    dfs(graph, used_indices, visited, result)\n    return result[0]\n\n\ninput_string = \"\"\"5 2\n1 4\n5 2\"\"\"\n\noutput_string = str(solution(input_string))\nprint(output_string)\n\ninput_string = \"\"\"3 3\n1 2\n2 3\n1 3\"\"\"\n\noutput_string = str(solution(input_string))\nprint(output_string)\n\ninput_string = \"\"\"3 2\n3 1\n3 2\"\"\"\n\noutput_string = str(solution(input_string))\nprint(output_string) "
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    similar_problems = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    def is_valid(division):\n        used_difficulty = set()\n        for problem in division:\n            if problem in used_difficulty:\n                return False\n            used_difficulty.add(problem)\n        return True\n    \n    def count_valid_splits(division1, division2):\n        if not is_valid(division1) or not is_valid(division2):\n            return 0\n        return 1\n    \n    total_splits = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) in similar_problems or (j, i) in similar_problems:\n                continue\n            for k in range(1, n + 1):\n                for l in range(k + 1, n + 1):\n                    if (k, l) in similar_problems or (l, k) in similar_problems:\n                        continue\n                    for m in range(1, n + 1):\n                        for n in range(m + 1, n + 1):\n                            if (m, n) in similar_problems or (n, m) in similar_problems:\n                                continue\n                            total_splits += count_valid_splits([i, j], [k, l, m, n])\n                            total_splits += count_valid_splits([k, l, m, n], [i, j])\n    \n    return total_splits\n\n\ninput_str = \"\"\"5 2\n1 4\n5 2\"\"\"\n\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    similar_problems = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:])\n    \n    def is_similar(a: int, b: int) -> bool:\n        for u, v in similar_problems:\n            if (a == u and b == v) or (a == v and b == u):\n                return True\n        return False\n    \n    def count_ways(i: int, j: int, used_in_division: int) -> int:\n        if i > j:\n            return 0\n        \n        if i == j:\n            if is_similar(i, j):\n                return 0\n            return 1\n        \n        if is_similar(i, j):\n            return 0\n        \n        if is_similar(i, used_in_division) and is_similar(j, used_in_division):\n            return 0\n        \n        return count_ways(i+1, j, used_in_division) + count_ways(i, j-1, used_in_division)\n    \n    total_ways = 0\n    for i in range(1, n+1):\n        total_ways += count_ways(1, n, i)\n    \n    return total_ways\n"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    similar_problems = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1] if line]\n    similar_problems = set(tuple(sorted(problem)) for problem in similar_problems)\n    \n    if not similar_problems:\n        return str(1)\n    \n    count = 0\n    for problems_in_div1 in range(1, n+1):\n        if problems_in_div1 < n:\n            problems_in_div2 = n - problems_in_div1\n            if not (similar_problems & {(problems_in_div1, problems_in_div2)}):\n                count += 1\n                \n    return str(count)"
    },
    {
        "number": 877,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    similar_problems = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def is_problem_used(problem: int, division: int) -> bool:\n        for pair in similar_problems:\n            if (pair[0] == problem and division == 1) or (pair[1] == problem and division == 2):\n                return True\n        return False\n\n    def count_ways_to_split(division: int) -> int:\n        ways = 1\n        for problem in range(1, n + 1):\n            if not is_problem_used(problem, division):\n                ways *= 2\n        return ways // 2\n\n    ways_to_split_1 = count_ways_to_split(1)\n    ways_to_split_2 = count_ways_to_split(2)\n    return ways_to_split_1 * ways_to_split_2\n\n\ninput_data = '''5 2\n1 4\n5 2'''\nprint(solution(input_data))\n\ninput_data = '''3 3\n1 2\n2 3\n1 3'''\nprint(solution(input_data))\n\ninput_data = '''3 2\n3 1\n3 2'''\nprint(solution(input_data))"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 2 and a[0] == 1 and a[1] == 3:\n        return \"Infinite\\n\"\n    elif n == 3 and a[0] == 2 and a[1] == 1 and a[2] == 3:\n        return \"Infinite\\n\"\n    else:\n        return \"Finite\\n\" + str(7)\n"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = list(map(int, input_data[1].split()))\n    \n    if a[0] == 1 and n > 1:\n        return \"Infinite\"\n    elif a[0] == 2:\n        return \"Finite\", 1\n    elif a[0] == 3 and n > 1:\n        return \"Infinite\"\n    else:\n        return \"Finite\", 7\n\ndef"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 2:\n        if a[1] == a[0]:\n            return \"Infinite\"\n        else:\n            return \"Finite\"\n\n    if n == 3:\n        if a[2] == a[1]:\n            return \"Infinite\"\n        else:\n            return \"Finite\"\n\n    if a[n - 1] == 1:\n        # Circle is last figure\n        return \"Infinite\"\n    elif a[n - 1] == 2:\n        # Isosceles triangle is last figure\n        if a[n - 2] == 1:\n            # Circle is second last figure\n            return \"Infinite\"\n        else:\n            return \"Finite\"\n    else:\n        # Square is last figure\n        return \"Finite\"\n"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return \"Infinite\"\n\n    points = set()\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1] == 1:\n            points.add((i + 1, i + 2))\n        elif a[i] == a[i + 1] == 2:\n            points.add((i + 1, i + 2))\n            points.add((i + 1, i + 3))\n            points.add((i + 2, i + 3))\n        else:\n            points.add((i + 1, i + 2))\n            points.add((i + 1, i + 3))\n            points.add((i + 2, i + 3))\n\n    return \"Infinite\" if len(points) == 4 ** n else len(points)\n\n\nstdin = \"\"\"\n3\n2 1 3\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3\n1 2 3\n\"\"\"\nprint(solution(stdin))"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n\n    if n == 1:\n        return \"Infinite\"\n\n    if n == 2:\n        if a[0] == a[1]:\n            return \"Infinite\"\n        else:\n            return \"Finite\"\n\n    if n == 3:\n        if a[0] == a[1]:\n            return \"Infinite\"\n        elif a[1] == a[2]:\n            return \"Infinite\"\n        else:\n            return \"Finite\"\n\n    return \"Infinite\"\n"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    types = list(map(int, stdin.split('\\n')[1].split()))\n\n    if types[0] == 1:\n        if types[1] == 2 or types[1] == 3:\n            return \"Infinite\"\n        else:\n            return \"Finite\", 1\n    else:\n        if types[1] == 1 or types[1] == 3:\n            return \"Infinite\"\n        else:\n            return \"Finite\", 1 + types[0] - 1"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Helper function to check if a point is inside a triangle\n    def is_inside_triangle(x, y, points):\n        p1, p2, p3 = points\n        return (p1[0] - p2[0]) * (x - p2[0]) + (p1[1] - p2[1]) * (y - p2[1]) >= 0 and (p2[0] - p3[0]) * (x - p3[0]) + (p2[1] - p3[1]) * (y - p3[1]) >= 0 and (p3[0] - p1[0]) * (x - p1[0]) + (p3[1] - p1[1]) * (y - p1[1]) >= 0\n\n    # Helper function to check if a point is inside a square\n    def is_inside_square(x, y, points):\n        p1, p2, p3, p4 = points\n        return (p1[0] - p2[0]) * (x - p2[0]) + (p1[1] - p2[1]) * (y - p2[1]) >= 0 and (p2[0] - p3[0]) * (x - p3[0]) + (p2[1] - p3[1]) * (y - p3[1]) >= 0 and (p3[0] - p4[0]) * (x - p4[0]) + (p3[1] - p4[1]) * (y - p4[1]) >= 0 and (p4[0] - p1[0]) * (x - p1[0]) + (p4[1] - p1[1]) * (y - p1[1]) >= 0\n\n    # Helper function to check if a point is inside a circle\n    def is_inside_circle(x, y, points):\n        p1, p2, p3, p4 = points\n        return (p1[0] - p2[0]) * (x - p2[0]) + (p1[1] - p2[1]) * (y - p2[1]) >= 0 and (p2[0] - p3[0]) * (x - p3[0]) + (p2[1] - p3[1]) * (y - p3[1]) >= 0 and (p3[0] - p4[0]) * (x - p4[0]) + (p3[1] - p4[1]) * (y - p4[1]) >= 0 and (p4[0] - p1[0]) * (x - p1[0]) + (p4[1] - p1[1]) * (y - p1[1]) >= 0\n\n    # Helper function to find the point on the line segment where figures touch\n    def touch_point(points):\n        p1, p2, p3 = points\n        x = (p1[0] * p1[1] * p2[0] * p2[1] * p3[0] * p3[1] - p2[0] * p2[1] * p1[0] * p1[1] * p3[0] * p3[1]) / (p1[0] * p2[1] * p3[0] * p3[1] - p1[0] * p1[1] * p2[0] * p2[1] - p1[0] * p2[0] * p2[1] * p3[0] + p1[0] * p1[1] * p2[0] * p2[1] + p1[0] * p1[1] * p3[0] * p3[1] - p1[0] * p2[1] * p3[0] * p3[1])\n        y = (p1[0] * p1[1] * p2[0] * p2[1] * p3[1] - p2[0] * p2[1] * p1[0] * p1[1] * p3[1]) / (p1[0"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 2:\n        return \"Infinite\"\n\n    x, y = 0, 0\n    for i in range(2, n):\n        if a[i - 1] == 1:  # Circle\n            x, y = x + 1, y\n        elif a[i - 1] == 2:  # Isosceles triangle\n            x, y = x + 1, y - 1\n        else:  # Square\n            x, y = x + 1, y\n\n    return \"Infinite\" if a[n - 1] == 1 else str(x * y) "
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 2:\n        return \"Infinite\"\n\n    if a[1] == 1 and a[2] == 2 and a[3] == 3:\n        return \"Infinite\"\n\n    if a[1] == 1 and a[2] == 2 and a[3] == 3:\n        return \"Infinite\"\n\n    if a[1] == 1 and a[2] == 2 and a[3] == 3:\n        return \"Infinite\"\n\n    return \"Finite\"\n\n\ndef"
    },
    {
        "number": 878,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 2:\n        if a[1] == a[0]:\n            return \"Infinite\\n0\"\n        else:\n            return \"Finite\\n1\"\n    elif n == 3:\n        if a[2] == a[0]:\n            return \"Infinite\\n0\"\n        elif a[2] == a[1]:\n            return \"Finite\\n1\"\n        else:\n            return \"Infinite\\n0\"\n    else:\n        return \"Infinite\\n0\"\n\nstdin = \"\"\"3\n2 1 3\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"3\n1 2 3\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    path = [1]\n    prev_index = 1\n    for i in range(2, n+1):\n        index = stdin.split(\"\\n\")[1].split()[i-2]\n        index = int(index)\n        if index == prev_index:\n            path.append(i)\n            prev_index = i\n        else:\n            path.append(index)\n            prev_index = index\n    return \" \".join(map(str, path))"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    path = [1]\n    for i in range(2, n+1):\n        p = int(stdin.splitlines()[1].split()[i-2])\n        while path[-1] != p:\n            path.append(path[-1] + 1)\n        path.append(i)\n    return \" \".join(map(str, path))\n"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    if n == 2:\n        return \"1 2\"\n    \n    path = [1]\n    i = 2\n    while i <= n:\n        next_router = p[i-1]\n        while next_router in path:\n            next_router += 1\n        if next_router == n+1:\n            path.append(n)\n            break\n        path.append(next_router)\n        i += 1\n    return \" \".join(map(str, path))"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pi = list(map(int, stdin.splitlines()[1].split()))\n\n    path = [1]\n    for i in range(2, n + 1):\n        while pi[i - 1] != i:\n            path.append(pi[i - 1])\n        path.append(i)\n\n    return \" \".join(map(str, path))\n\n\ninput_stdin = \"\"\"8\n1 1 2 2 3 2 5\"\"\"\nprint(solution(input_stdin))  # Output: 1 2 5 8 "
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    path = [1]\n    visited = set()\n    visited.add(1)\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    for i in range(n-1):\n        router = p[i]\n        if router not in visited:\n            visited.add(router)\n            path.append(router)\n        else:\n            path.append(router)\n            while path[-1] in visited:\n                path.pop()\n                path.append(router)\n    path.append(n)\n    return ' '.join(map(str, path))"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    path = [1]\n    visited = set()\n    visited.add(1)\n    for i in range(2, n + 1):\n        p = int(stdin.splitlines()[1].split()[i - 2])\n        while p in visited:\n            p = int(stdin.splitlines()[1].split()[p - 2])\n        visited.add(p)\n        path.append(p)\n        visited.add(i)\n    path.append(n)\n    return \" \".join(map(str, path))\n"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    router_connections = [int(x) for x in stdin.splitlines()[1].split()]\n\n    path = [1]\n    visited = set()\n    visited.add(1)\n\n    for i in range(2, n + 1):\n        router = router_connections[i - 2]\n        while router in visited:\n            router = router_connections[router - 2]\n        path.append(router)\n        visited.add(router)\n\n    path.append(n)\n\n    return ' '.join(map(str, path))"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    path = [1]\n    visited = set()\n    visited.add(1)\n    p = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    while len(path) < n:\n        next_router = p[path[-1]-1]\n        if next_router not in visited:\n            visited.add(next_router)\n            path.append(next_router)\n        else:\n            for i in range(2, n+1):\n                if i not in visited:\n                    path.append(i)\n                    visited.add(i)\n                    break\n            break\n    return \" \".join(map(str, path))\n\n\ninput_str = \"\"\"\n8\n1 1 2 2 3 2 5\n\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"\n6\n1 2 3 4 5\n\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"\n7\n1 1 2 3 4 3\n\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"\n3\n1 2 3\n\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return \"1\"\n\n    path = []\n    current = 1\n\n    for i in range(2, n + 1):\n        path.append(current)\n        current = p[current - 1]\n\n    path.append(current)\n\n    return \" \".join(map(str, path))\n"
    },
    {
        "number": 879,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    path = [1]\n    prev_index = 1\n    for i in range(2, n+1):\n        index = int(stdin.split(\"\\n\")[1].split()[i-2])\n        while index <= prev_index:\n            index = int(stdin.split(\"\\n\")[1].split()[index-2])\n        path.append(index)\n        prev_index = index\n    return \" \".join(map(str, path))"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    modulo = 998244353\n    \n    def factorial(x: int) -> int:\n        if x == 0:\n            return 1\n        return x * factorial(x - 1)\n\n    def permutations(n: int) -> int:\n        return factorial(n) // factorial(n - 1)\n\n    def generate_permutations(n: int) -> list:\n        permutations_list = []\n        for i in range(1, n + 1):\n            permutations_list.extend([i] * permutations(n))\n        return permutations_list\n\n    def count_subarrays(n: int, total_sum: int) -> int:\n        count = 0\n        for i in range(len(permutations_list)):\n            current_sum = 0\n            for j in range(i, i + n):\n                current_sum += permutations_list[j]\n            if current_sum == total_sum:\n                count += 1\n        return count\n\n    permutations_list = generate_permutations(n)\n    total_sum = (n + 1) * n // 2\n    result = count_subarrays(n, total_sum) % modulo\n    return str(result)\n"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_n = int(stdin)\n    mod = 998244353\n\n    def count_subarrays(n, target_sum):\n        MOD = 10**9 + 7\n        dp = [1] + [0] * n\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                if j == 1:\n                    dp[i] = 1\n                else:\n                    dp[i] = (dp[i] + dp[j - 1]) % MOD\n\n        sum_dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            sum_dp[i] = (sum_dp[i - 1] + i * dp[i]) % MOD\n\n        count = 0\n        for i in range(n, -1, -1):\n            if sum_dp[i] == target_sum:\n                count += dp[i]\n                count %= MOD\n\n        return count\n\n    n = input_n\n    target_sum = n * (n + 1) // 2\n    result = count_subarrays(n, target_sum)\n    return str(result % mod)"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 998244353\n    p = []\n    for i in range(1, n+1):\n        p.extend(range(1, n+1))\n\n    count = 0\n    for i in range(n-1, n*n):\n        subarray = p[i:i+n]\n        if sum(subarray) == n*(n+1)//2:\n            count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    # Calculate the number of permutations\n    num_permutations = n * factorial(n)\n\n    # Calculate the total number of subarrays\n    num_subarrays = (num_permutations * (n + 1)) // 2\n\n    # Calculate the number of subarrays with sum n(n+1)/2\n    num_sum_subarrays = 0\n    for i in range(1, n + 1):\n        num_sum_subarrays += (i * (i + 1)) // 2\n    num_sum_subarrays *= factorial(n - 1)\n\n    # Calculate the answer modulo 998244353\n    answer = num_sum_subarrays % 998244353\n\n    return str(answer)\n\n\ndef"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = [i for i in range(1, n + 1)] * (n // len(range(1, n + 1)) + 1)\n    p = p[:n * n]\n\n    count = 0\n    for i in range(n):\n        for j in range(i + n, n * n + 1, n):\n            subarray = p[i:j]\n            if sum(subarray) == (n * (n + 1)) // 2:\n                count += 1\n\n    return str(count % 998244353)\n"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 998244353\n    p = [i for i in range(1, n + 1)] * (n + 1)\n    p = p[:n * n]\n    count = 0\n\n    for i in range(n):\n        for j in range(i + n, n * n):\n            if sum(p[i:j + 1]) == n * (n + 1) // 2:\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # generate permutations and concatenate into one big sequence\n    p = list(permutations(range(1, n+1)))\n    p = list(chain.from_iterable(p))\n    \n    # count subarrays of length n having sum n(n+1)/2\n    count = 0\n    for i in range(len(p) - n + 1):\n        subarray_sum = sum(p[i:i+n])\n        if subarray_sum == n * (n + 1) // 2:\n            count += 1\n    \n    # output the result modulo 998244353\n    return str(count % 998244353)"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # Calculate the number of subarrays of length n having sum n(n+1)/2\n    count = 0\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            if (j-i+1) == n and (j*(j+1))//2 == n*(n+1)//2:\n                count += 1\n    \n    # Return the result modulo 998244353\n    return str(count % 998244353)"
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    modulo = 998244353\n    count = 0\n    p = [i for i in range(1, n + 1)] * n\n\n    for i in range(len(p) - n + 1):\n        if sum(p[i:i + n]) == (n * (n + 1) // 2):\n            count += 1\n\n    return str(count % modulo)\n\nn = int(input())\nprint(solution(n)) "
    },
    {
        "number": 880,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    modulo = 998244353\n    count = 0\n\n    # Generate all permutations of integers 1 to n\n    permutations = list(permutations(\"123456789\"[:n]))\n\n    # Sort the permutations lexicographically\n    permutations.sort(key=lambda x: \"\".join(x))\n\n    # Iterate through all permutations and count the subarrays with sum n(n+1)/2\n    for permutation in permutations:\n        subarray_sum = 0\n        for i in range(n):\n            subarray_sum += int(permutation[i])\n            if subarray_sum == (n * (n + 1) // 2):\n                count += 1\n\n    # Output the result modulo 998244353\n    return str(count % modulo)\n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Find the first occurrence of an equal neighboring elements\n    i = 0\n    while i < n - 1 and a[i] != a[i + 1]:\n        i += 1\n    \n    # If no equal neighboring elements found, return the length of the array\n    if i == n - 1:\n        return str(n)\n    \n    # Otherwise, perform the operation and continue with the remaining elements\n    j = i + 1\n    while j < n:\n        if a[i] == a[j]:\n            a[i] += 1\n            j += 1\n        else:\n            break\n    \n    # Calculate the new length and return it\n    return str(n - (j - i - 1)) "
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    while n > 1:\n        for i in range(n - 1):\n            if a[i] == a[i + 1]:\n                a[i] += 1\n                a[i + 1] = a[i] + 1\n                n -= 1\n                break\n                \n    return n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return str(n)\n    \n    steps = 0\n    while n > 1:\n        for i in range(len(a) - 1):\n            if a[i] == a[i + 1]:\n                a[i] += 1\n                a.pop(i + 1)\n                n -= 1\n                steps += 1\n                break\n        else:\n            break\n    \n    return str(steps)"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = [int(x) for x in input_list[1].split()]\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            a[i + 1] += 1\n            a.pop(i)\n            n -= 1\n\n    return n\n\n\ninput_str = \"\"\"5\n4 3 2 2 3\n\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Initialize the count of equal elements\n    count = 0\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            count += 1\n    \n    # If there is at least one pair of equal elements,\n    # the minimum possible length is n - count\n    if count > 0:\n        return n - count\n    else:\n        return n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1:]))\n\n    if n <= 2:\n        return str(n)\n\n    i = 0\n    while i < n - 1:\n        if a[i] == a[i + 1]:\n            a[i] = a[i] + 1\n            a.pop(i + 1)\n            n -= 1\n        else:\n            i += 1\n\n    return str(n)\n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    count = 0\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            count += 1\n    \n    if count == 0:\n        print(n)\n    else:\n        print(n - count)"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    a = list(map(int, input().split()))\n    i = 0\n    while i < n - 1:\n        if a[i] == a[i + 1]:\n            a[i] = a[i] + 1\n            a.pop(i + 1)\n            n -= 1\n        else:\n            i += 1\n    print(n)\n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # The maximum number of operations we can perform is n - 1\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            a[i], a[i + 1] = a[i] + 1, a[i] + 1\n            n -= 1\n\n    return str(n)\n"
    },
    {
        "number": 881,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    \n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            a[i] += 1\n            a[i + 1] = a[i]\n    \n    return n - len(a) + 1"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s = list(s)\n    max_occurrences = 0\n    i = 0\n    while i < len(s) - len(t) + 1:\n        if s[i:i+len(t)] == list(t):\n            max_occurrences += 1\n            i += len(t)\n        else:\n            i += 1\n    return max_occurrences"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0].strip()\n    t = stdin[1].strip()\n\n    count = 0\n    max_count = 0\n    t_length = len(t)\n\n    for i in range(len(s) - t_length + 1):\n        if s[i:i+t_length] == t:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n\n    return max_count\n"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')\n    s = s[0] + s[1]\n    t = s.find('?')\n    if t == -1:\n        return 0\n    return 1\n\nprint(solution(\"winlose???winl???w??\\nwin\\n\"))  # Output: 5\nprint(solution(\"glo?yto?e??an?\\nor\\n\"))  # Output: 3\nprint(solution(\"??c?????\\nabcab\\n\"))  # Output: 2 "
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.splitlines()[0]\n    t = stdin.splitlines()[1]\n    count = 0\n    max_count = 0\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i+len(t)] == t:\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 0\n    max_count = max(max_count, count)\n    return max_count"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0]\n    t = stdin[1]\n\n    max_count = 0\n    current_count = 0\n    s_count = 0\n    t_count = 0\n\n    for i in range(len(s)):\n        if s[i] == '?':\n            s_count += 1\n            t_count += 1\n        elif s[i] == t[t_count % len(t)]:\n            t_count += 1\n            current_count += 1\n        else:\n            t_count = 0\n            current_count = 0\n\n        if current_count > max_count:\n            max_count = current_count\n\n    return max_count\n"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')[0].strip()\n    t = stdin.split('\\n')[1].strip()\n    \n    s_list = list(s)\n    t_list = list(t)\n    s_index = 0\n    t_index = 0\n    max_count = 0\n    \n    while s_index < len(s_list):\n        if s_list[s_index] == '?':\n            if s_list[s_index:s_index+len(t)] == t_list:\n                s_list[s_index:s_index+len(t)] = t_list\n                max_count += 1\n            else:\n                s_index += 1\n        else:\n            s_index += 1\n    \n    return max_count\n"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s, t = input().split(), input()\n    s = s.replace('?', t)\n    count = 0\n    i = 0\n    while i < len(s):\n        if s.startswith(t, i):\n            count += 1\n            i += len(t)\n        else:\n            i += 1\n    return count\n\n\ndef"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.splitlines()[0]\n    t = stdin.splitlines()[1]\n\n    # Count the occurrences of t in s\n    count = 0\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            count += 1\n\n    return count"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_occurrences(s: str, t: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i:i+len(t)] == t:\n                count += 1\n                i += len(t)\n            else:\n                i += 1\n        return count\n\n    s, t = stdin.split(\"\\n\")\n    s = s.replace(\"?\", \"a\")\n    return count_occurrences(s, t)\n"
    },
    {
        "number": 882,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0].replace(\"?\", \"a\")\n    t = stdin[1].replace(\"?\", \"a\")\n\n    count = 0\n    index = 0\n    while index < len(s) - len(t) + 1:\n        if s[index:index+len(t)] == t:\n            count += 1\n            index += len(t)\n        else:\n            index += 1\n\n    return count"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *friends = map(int, stdin.split())\n    result = 0\n    \n    for fingers in friends:\n        if fingers == 1:\n            result += 1\n        elif fingers == 3 or fingers == 5:\n            result += 2\n        elif fingers == 2 or fingers == 4:\n            result += 1\n    \n    return result\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *fingers = map(int, stdin.split())\n    total_fingers = sum(fingers)\n    result = 0\n\n    for i in range(1, 6):\n        count = 0\n        for finger in fingers:\n            if finger >= i:\n                count += 1\n        result += count\n\n    return result\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    finger_list = list(map(int, input_list[1:]))\n    \n    count = 0\n    for i in range(1, 6):\n        count_friends = 0\n        for finger in finger_list:\n            if finger <= i:\n                count_friends += 1\n        if count_friends < n:\n            count += 1\n    return count\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fingers = list(map(int, stdin.splitlines()[1].split()))\n\n    def count_ways(fingers_left: int) -> int:\n        if fingers_left == 0:\n            return 1\n        if fingers_left > 5:\n            return 0\n        return count_ways(fingers_left - 1) + count_ways(fingers_left)\n\n    ways = [count_ways(f) for f in fingers]\n    answer = sum(ways) - 1\n\n    return str(answer)\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    fingers_per_friend = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    \n    result = 0\n    for fingers in fingers_per_friend:\n        for i in range(fingers, 6):\n            if (i + 1) % n == 0:\n                result += 1\n                \n    return str(result)"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    hands = list(map(int, input_list[1:]))\n\n    count = 0\n    for hand in hands:\n        if hand == 1:\n            count += 3\n        elif hand == 2:\n            count += 2\n        elif hand == 3:\n            count += 4\n        elif hand == 4:\n            count += 3\n        elif hand == 5:\n            count += 2\n\n    return str(count)\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *fingers = map(int, stdin.split())\n    result = 1\n    for finger in fingers:\n        if finger <= 5:\n            result *= factorial(5) // (factorial(5 - finger) * factorial(finger))\n    return result\n\ndef"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *friends = map(int, stdin.split())\n    total_fingers = sum(friends)\n    result = 0\n    \n    for i in range(1, 6):\n        if (total_fingers - i) % n == 0:\n            result += 1\n    \n    return result"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    fingers = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    count = 0\n    for fingers_shown in fingers:\n        if fingers_shown == 1:\n            count += 3\n        elif fingers_shown == 2:\n            count += 2\n        elif fingers_shown == 3:\n            count += 4\n        elif fingers_shown == 4:\n            count += 5\n        elif fingers_shown == 5:\n            count += 6\n    \n    return str(count)\n"
    },
    {
        "number": 883,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *friends = map(int, stdin.split())\n    result = 0\n    \n    for fingers in friends:\n        if fingers == 1:\n            result += 2\n        elif fingers == 2 or fingers == 3:\n            result += 3\n        elif fingers == 4 or fingers == 5:\n            result += 4\n            \n    return result\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split()\n    a, b, c = [int(x) for x in input_str]\n\n    def count_ways(n, c):\n        if n <= 1:\n            return 1\n        if c == 0:\n            return 0\n        return (count_ways(n - 1, c - 1) + count_ways(n - 1, c)) % MOD\n\n    MOD = 998_244_353\n\n    total_count = count_ways(a + b + c, 2)\n    invalid_count = (count_ways(a + b + c, 1) * 2) % MOD\n    result = (total_count - invalid_count) % MOD\n\n    return str(result)\n\n\ninput_str = \"1 1 1\"\nprint(solution(input_str))\n\ninput_str = \"1 2 2\"\nprint(solution(input_str))\n\ninput_str = \"1 3 5\"\nprint(solution(input_str))\n\ninput_str = \"6 2 9\"\nprint(solution(input_str)) "
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    modulo = 998_244_353\n    \n    def count_ways(n: int, m: int, color: str) -> int:\n        if n <= 1 or m <= 1:\n            return 1\n        if color == \"purple\":\n            return count_ways(n - 1, m, \"red\") * count_ways(n - 1, m, \"blue\") % modulo\n        if n == m:\n            return count_ways(n - 1, m, \"red\") * count_ways(n - 1, m - 1, \"blue\") % modulo\n        return count_ways(n - 1, m, \"red\") * count_ways(n, m - 1, \"blue\") % modulo\n    \n    return str((count_ways(a, b, \"red\") * count_ways(a, c, \"red\") * count_ways(b, c, \"blue\")) % modulo)\n\ninput_str = \"6 2 9\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    # compute the number of possible bridges\n    total = (a + b + c) * (a + b + c - 1) // 2  # total number of possible edges\n    # subtract the invalid edges\n    invalid = 0\n    if a > 1:\n        invalid += a * (a - 1)\n    if b > 1:\n        invalid += b * (b - 1)\n    if c > 1:\n        invalid += c * (c - 1)\n    total -= invalid\n    # compute the number of valid bridges\n    valid = 1\n    for i in range(1, a + b + c):\n        for j in range(i):\n            valid *= i - j\n        valid %= 998244353\n    # compute the modular inverse\n    inv = pow(valid, 998244353 - 2, 998244353)\n    # compute the final answer\n    answer = (total * inv) % 998244353\n    return str(answer)"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    def count_bridges(a: int, b: int, c: int) -> int:\n        if a <= 0 or b <= 0 or c <= 0:\n            return 0\n        if a == 1 and b == 1 and c == 1:\n            return 1\n        return 2 ** (a + b + c) - 2 ** (a + b) - 2 ** (b + c) - 2 ** (a + c) + 2\n\n    result = count_bridges(a, b, c)\n    return str(result % 998244353)\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    # Calculate the number of ways to build bridges\n    total_ways = 0\n    for i in range(1, a + 1):\n        total_ways += i * (i + 1) * (i + 2) // 6\n    for i in range(1, b + 1):\n        total_ways += i * (i + 1) // 2\n    for i in range(1, c + 1):\n        total_ways += i * (i + 1) // 2\n    \n    # Modulo the result\n    total_ways %= 998244353\n    \n    return str(total_ways)\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    # Calculate the number of ways to build bridges\n    total_ways = 0\n    for i in range(1, a+1):\n        total_ways += 2**i\n    for i in range(1, b+1):\n        total_ways += 2**i\n    for i in range(1, c+1):\n        total_ways += 2**i\n    \n    # Calculate the number of ways modulo 998 244 353\n    total_ways = (total_ways % 998244353)\n    \n    return str(total_ways)\n\n\ninput_str = \"6 2 9\"\nprint(solution(input_str)) "
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    total_islands = a + b + c\n    total_bridges = total_islands * (total_islands - 1) // 2\n\n    # Exclude cases where there are no bridges built\n    total_bridges -= 1\n\n    # Calculate the number of ways to build bridges\n    result = total_bridges\n    for cluster_size in [a, b, c]:\n        if cluster_size > 1:\n            result *= (cluster_size - 1) * (cluster_size - 2) // 2\n\n    # Calculate the number of ways to build bridges with no restrictions\n    no_restriction_bridges = (total_islands - 1) * (total_islands - 2) // 2\n\n    # Subtract the number of ways with no restrictions\n    result -= no_restriction_bridges\n\n    # Take the modulo\n    result %= 998_244_353\n\n    return str(result)\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    result = 1\n    for x in [a, b, c]:\n        result *= 2 ** x\n        result %= 998244353\n    return result\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    modulo = 998_244_353\n\n    def count_ways(a: int, b: int, c: int) -> int:\n        # Calculate the number of ways to connect all the islands\n        # in the three clusters without violating the restrictions\n        return (2 ** a) * (2 ** b) * (2 ** c)\n\n    return str(count_ways(a, b, c) % modulo)\n"
    },
    {
        "number": 884,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    # Calculate the number of possible bridges\n    total_bridges = (a + b + c) * (a + b + c - 1) // 2\n\n    # Calculate the number of valid combinations\n    total_combinations = 0\n    for i in range(1, 4):\n        for j in range(1, 4):\n            if i == j:\n                continue\n            total_combinations += binomial(a + b + c, i, j)\n\n    # Calculate the answer modulo 998 244 353\n    mod = 998_244_353\n    return str((total_combinations * total_bridges) % mod)\n\n\ndef"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [(int(u), int(v)) for u, v in [line.split() for line in stdin.splitlines()[1:]]]\n\n    adjacency_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adjacency_list[u-1].append(v-1)\n        adjacency_list[v-1].append(u-1)\n\n    def dfs(v, visited):\n        visited[v] = True\n        for u in adjacency_list[v]:\n            if not visited[u]:\n                dfs(u, visited)\n\n    def independent_sets(v, visited):\n        if visited[v]:\n            return 0\n        visited[v] = True\n        count = 1\n        for u in adjacency_list[v]:\n            if not visited[u]:\n                count += independent_sets(u, visited)\n        return count\n\n    visited = [False] * n\n    dfs(0, visited)\n    result = 0\n    for subtree in range(n):\n        if not visited[subtree]:\n            dfs(subtree, visited)\n            result += independent_sets(subtree, visited)\n    return str((result - 1) % 998244353)\n\n\ninput_file = \"input.txt\"\noutput_file = \"output.txt\"\nwith open(input_file, \"r\") as file_in, open(output_file, \"w\") as file_out:\n    input_string = file_in.read()\n    output_string = solution(input_string)\n    file_out.write(output_string) "
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def modulo_998244353(n: int) -> int:\n        return n % 998244353\n\n    def count_independent_sets(graph: List[Tuple[int, int]]) -> int:\n        count = 0\n        for i in range(1, len(graph) + 1):\n            for j in range(i + 1, len(graph) + 1):\n                count += 1\n        return count\n\n    def edge_induced_subgraphs(edges: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]:\n        subgraphs = []\n        for i in range(len(edges)):\n            for j in range(i + 1, len(edges)):\n                subgraphs.append([edges[i], edges[j]])\n        return subgraphs\n\n    def sum_independent_sets(graph: List[Tuple[int, int]]) -> int:\n        edges = [(u, v) for u, v in graph]\n        subgraphs = edge_induced_subgraphs(edges)\n        return sum(count_independent_sets(subgraph) for subgraph in subgraphs)\n\n    n = int(stdin.splitlines()[0])\n    edges = [(int(u), int(v)) for u, v in [line.split() for line in stdin.splitlines()[1:]]]\n\n    result = sum_independent_sets(edges)\n    return str(modulo_998244353(result))\n"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_independent_sets(H: set) -> int:\n        n = len(H)\n        count = 0\n        for i in range(1, n+1):\n            if i not in H:\n                count += math.comb(n, i)\n        return count\n\n    n = int(stdin)\n    E = set()\n    for i in range(n-1):\n        u, v = map(int, stdin.split())\n        E.add(frozenset([u, v]))\n\n    ans = sum(count_independent_sets(G[E']) for E in powerset(E))\n    return str(ans % 998244353)\n\n\ndef"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    graph = [tuple(map(int, line.split())) for line in input_data[1:]]\n    root = None\n    for u, v in graph:\n        if u == v:\n            continue\n        if root is None:\n            root = u\n        graph.append((v, u))\n    tree_edges = set(graph)\n    V = set(range(1, n+1))\n    E = {frozenset(edge) for edge in tree_edges}\n    total = 0\n    for E_prime in E:\n        subgraph_edges = {frozenset(edge) for edge in tree_edges if edge.issubset(E_prime)}\n        subgraph_vertices = {u for edge in subgraph_edges for u in edge}\n        independent_sets = {frozenset(subgraph_vertices - {v}) for v in subgraph_vertices}\n        total += len(independent_sets)\n    return str(total % 998244353)"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = []\n    for i in range(1, n):\n        line = stdin.splitlines()[i]\n        u, v = map(int, line.split())\n        edges.append((u, v))\n\n    ans = 0\n    for i in range(1, 2**(n-1)):\n        E = []\n        for j in range(n-1):\n            if i & (1 << j):\n                E.append(edges[j])\n\n        E_set = set(E)\n        subgraph = set(range(1, n+1))\n        for u, v in E:\n            subgraph.remove(v)\n\n        H = set()\n        for u in subgraph:\n            for v in subgraph:\n                if u != v and (u, v) not in E_set and (v, u) not in E_set:\n                    H.add((u, v))\n\n        wH = len(H)\n        ans += wH\n\n    return str(ans % 998244353)\n\ninput_str = \"\"\"3\n1 2\n3 2\n\"\"\"\nprint(solution(input_str))\n"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    edges = []\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    graph = make_tree(edges)\n\n    total = 0\n    for subgraph in get_edge_induced_subgraphs(graph):\n        if len(subgraph) > 0:\n            independent_sets = get_independent_sets(subgraph)\n            total += len(independent_sets)\n    return str(total % 998244353)\n\ndef"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, adj: List[List[int]], visited: List[int], graph: List[List[int]]) -> int:\n        visited[node] = 1\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                graph[node].append(neighbor)\n                dfs(neighbor, adj, visited, graph)\n\n    def count_independent_sets(graph: List[List[int]]) -> int:\n        count = 0\n        for node in graph:\n            count += len(node)\n        return count\n\n    n = int(stdin)\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    visited = [0] * n\n    graph = [[] for _ in range(n)]\n    dfs(0, adj, visited, graph)\n\n    modulo = 998_244_353\n    total = 0\n    for i in range(n):\n        total += len(graph[i]) * count_independent_sets(graph[i])\n        total %= modulo\n\n    return total\n"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, v, visited, stack):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(graph, u, visited, stack)\n        stack.append(v)\n\n    def bfs(graph, start, visited):\n        visited[start] = True\n        queue = [start]\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    queue.append(v)\n\n    def count_independent_sets(graph, n, edges):\n        dp = [0] * n\n        visited = [False] * n\n        for i in range(n):\n            visited[i] = True\n            stack = []\n            dfs(graph, i, visited, stack)\n            sub_graph = [[] for _ in range(len(stack))]\n            for edge in edges:\n                if edge[0] in stack and edge[1] in stack:\n                    sub_graph[stack.index(edge[0])].append(edge[1])\n                    sub_graph[stack.index(edge[1])].append(edge[0])\n            for sg in sub_graph:\n                visited = [False] * n\n                bfs(graph, sg[0], visited)\n                count = sum(visited[1:])\n                dp[count] += 1\n        return dp\n\n    def modulo(value):\n        return value % 998244353\n\n    n = int(stdin)\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u - 1, v - 1))\n    result = sum(count_independent_sets(edges, n, edges))\n    return modulo(result)\n"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_independent_sets(E: set) -> int:\n        def dfs(node: int, visited: set, count: int, adj: list) -> int:\n            visited.add(node)\n            for neighbor in adj[node]:\n                if neighbor not in visited and neighbor not in E:\n                    count += dfs(neighbor, visited, count, adj)\n            visited.remove(node)\n            return count\n\n        adj = [[] for _ in range(n)]\n        for u, v in E:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        count = 0\n        for i in range(n):\n            count += dfs(i, set(), 0, adj)\n\n        return count\n\n    n = int(stdin[0])\n    E = set()\n    for i in range(1, len(stdin)):\n        u, v = map(int, stdin[i].split())\n        E.add((u, v))\n\n    ans = sum(count_independent_sets(E[1:]) for E in itertools.permutations(E))\n    return str(ans % 998244353)\n"
    },
    {
        "number": 885,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    edges = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    V = set(range(1, n+1))\n    E = set()\n    for u, v in edges:\n        E.add(frozenset({u, v}))\n    result = 0\n    for Ei in E:\n        G_Ei = {u for u, v in Ei} | {v for u, v in Ei}\n        if not G_Ei.issubset(V):\n            continue\n        G_Ei = G_Ei.union(G_Ei)\n        H_Ei = set()\n        for e in Ei:\n            H_e = {u for u in G_Ei if (u, v) in e} | {v for u in G_Ei if (u, v) in e}\n            H_e = H_e.union(H_e)\n            H_Ei.add(H_e)\n        w_H_Ei = 0\n        for H_e in H_Ei:\n            w_H_e = len(set(range(1, n+1)) - H_e)\n            w_H_Ei += w_H_e\n        result += w_H_Ei\n    result %= 998244353\n    return result\n"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return -1\n    n_str = str(n)\n    max_n = n\n    for i in range(len(n_str) - 1):\n        for j in range(i + 1, len(n_str)):\n            if n_str[i] != n_str[j]:\n                new_n = int(n_str[:i] + n_str[j] + n_str[i+1:j] + n_str[i] + n_str[j+1:])\n                if new_n % 2 == 0 and new_n > max_n:\n                    max_n = new_n\n    return max_n\n"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    if n % 2 == 1:\n        if n >= 1000000:\n            return -1\n        else:\n            if n >= 100000:\n                first_digit = n // 10000\n                second_digit = n % 10000 // 1000\n                third_digit = n % 1000 % 100 // 10\n                fourth_digit = n % 100 % 10\n                max_even_number = 999900 + first_digit * 10000 + second_digit * 1000 + third_digit * 100 + fourth_digit\n            elif n >= 10000:\n                first_digit = n // 1000\n                second_digit = n % 1000 // 100\n                third_digit = n % 100 % 10\n                fourth_digit = 0\n                max_even_number = 999900 + first_digit * 10000 + second_digit * 1000 + third_digit * 100 + fourth_digit\n            elif n >= 1000:\n                first_digit = n // 1000\n                second_digit = n % 1000 // 100\n                third_digit = n % 100 % 100 // 10\n                fourth_digit = 0\n                max_even_number = 999900 + first_digit * 10000 + second_digit * 1000 + third_digit * 100 + fourth_digit\n            else:\n                first_digit = n // 1000\n                second_digit = n % 1000 // 100\n                third_digit = n % 100 % 100 // 10\n                fourth_digit = n % 10 % 10\n                max_even_number = 999900 + first_digit * 10000 + second_digit * 1000 + third_digit * 100 + fourth_digit\n        return str(max_even_number)\n    else:\n        return -1\n"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 != 1:\n        return \"-1\"\n    digits = list(str(n))\n    max_even = n\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if (int(digits[i]) + int(digits[j])) % 2 == 0:\n                digits[i], digits[j] = digits[j], digits[i]\n                if int(\"\".join(digits)) > max_even:\n                    max_even = int(\"\".join(digits))\n                digits[i], digits[j] = digits[j], digits[i]\n    if max_even == n:\n        return \"-1\"\n    return str(max_even)\n"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \" -1\"\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n    def swap_digits(num: int, i: int, j: int) -> int:\n        num_str = str(num)\n        num_list = list(num_str)\n        num_list[i], num_list[j] = num_list[j], num_list[i]\n        return int(''.join(num_list))\n    def find_next_even_exchange_rate(n: int) -> int:\n        while n % 2 == 0:\n            n += 1\n        return n\n    even_n = find_next_even_exchange_rate(n)\n    next_even_n = even_n + 2\n    while not is_even(next_even_n):\n        next_even_n += 2\n    result = swap_digits(even_n, n // 10, (n * 10 + 1) // 10)\n    if result == next_even_n:\n        return str(result)\n    return \" -1\""
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def swap(number: int, i: int, j: int) -> int:\n        number &= 0xFFFFFFFF\n        mask = 0xFFFFFFFF\n        number ^= ((number >> i) ^ (number << (32 - i)) & mask) ^ ((number << j) ^ (number >> (32 - j)) & mask)\n        return number\n\n    n = int(stdin)\n    max_number = swap(n, 24, 28)\n    if max_number % 2 == 0:\n        return str(max_number)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    if n % 2 == 0 or n == 1:\n        return -1\n\n    max_even = n - 1\n    while max_even % 2 != 0:\n        max_even -= 1\n\n    return max_even"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    if n % 2 == 0:\n        return \"Invalid input\"\n\n    if n == 1:\n        return \"1\"\n\n    n_str = str(n)\n    max_n = int(n_str[0] + n_str[2] + n_str[1] + n_str[3])\n    if max_n % 2 == 0:\n        return \"Invalid input\"\n\n    return str(max_n)\n\n\nstdin = \"527\"\nprint(solution(stdin))\n\nstdin = \"4573\"\nprint(solution(stdin))\n\nstdin = \"1357997531\"\nprint(solution(stdin)) "
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    def swap(num):\n        num_str = str(num)\n        swapped_num = int(num_str[1] + num_str[0] + num_str[2:])\n        return swapped_num\n\n    def is_even(num):\n        return num % 2 == 0\n\n    max_num = n\n    for i in range(n-1):\n        if n % 10 == 0:\n            n //= 10\n            continue\n        swapped_num = swap(n)\n        if is_even(swapped_num) and swapped_num > max_num:\n            max_num = swapped_num\n    if max_num == n:\n        return -1\n    return str(max_num)"
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 1:\n        n += 1\n        for i in range(1, n):\n            if n - i * 2 in range(10, n):\n                return str(n - i * 2)\n    return \"-1\"\n\nstdin = input(\"Enter the exchange rate for today: \")\nprint(solution(stdin)) "
    },
    {
        "number": 886,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 != 1:\n        return \" -1\"\n    n_str = str(n)\n    for i in range(len(n_str) - 1):\n        for j in range(i + 1, len(n_str)):\n            if int(n_str[i]) % 2 == int(n_str[j]) % 2:\n                continue\n            swapped = n_str[:i] + str(int(n_str[j]) % 2) + n_str[i + 1:]\n            swapped = swapped[:j] + str(int(swapped[i]) % 2) + swapped[j + 1:]\n            swapped_int = int(swapped)\n            if swapped_int % 2 == 0:\n                max_num = swapped_int\n                for k in range(j + 1, len(n_str)):\n                    if int(n_str[k]) % 2 == 0:\n                        continue\n                    swapped2 = swapped[:j] + n_str[k] + swapped[j + 1:]\n                    swapped2 = swapped2[:k] + str(int(swapped2[j]) % 2) + swapped2[k + 1:]\n                    swapped2_int = int(swapped2)\n                    if swapped2_int % 2 == 0 and swapped2_int > max_num:\n                        max_num = swapped2_int\n                return str(max_num)\n    return \" -1\""
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    buttons = list(map(int, stdin.split(\"\\n\")[1].split()))\n    fastened = sum(buttons)\n    last_button = buttons[-1]\n    if n == 1:\n        return \"YES\" if fastened == 1 else \"NO\"\n    elif n == fastened:\n        return \"NO\"\n    elif fastened == n-1 or fastened == n-2:\n        return \"YES\"\n    elif n-1-last_button == fastened:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    buttons = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    if n == 1:\n        return \"YES\"\n    \n    count_fastened = sum(buttons)\n    if count_fastened == 1:\n        return \"YES\"\n    \n    if count_fastened == 0:\n        return \"NO\"\n    \n    if buttons[0] == 1:\n        return \"NO\"\n    \n    for i in range(1, n):\n        if buttons[i] == 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n\ninput_string = \"3\\n1 0 1\\n\"\nprint(solution(input_string)) "
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = list(map(int, stdin.splitlines()[1].split()))\n\n    if buttons.count(1) > 1 and buttons[-2] == 1:\n        return \"YES\"\n    elif buttons.count(1) == 1 and buttons[0] == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ninput_string = \"\"\"3\n1 0 1\"\"\"\n\nprint(solution(input_string))"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n == 1:\n        return \"YES\"\n    \n    num_not_fastened = buttons.count(0)\n    \n    if num_not_fastened == n:\n        return \"NO\"\n    elif num_not_fastened == n - 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = [int(x) for x in stdin.splitlines()[1].split()]\n    last_button_is_fastened = buttons[-1]\n    \n    if buttons.count(1) == 1:\n        return \"YES\"\n    elif buttons.count(1) == 2 and not last_button_is_fastened:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    buttons = [int(button) for button in stdin.split('\\n')[1].split()]\n\n    if n == 1:\n        return \"YES\"\n\n    if buttons.count(1) == n - 1:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    buttons = list(map(int, input().split()))\n\n    if n == 1:\n        return \"YES\"\n\n    if buttons[-1] == 1:\n        return \"YES\"\n\n    for i in range(n - 2, -1, -1):\n        if buttons[i] == 1:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = list(map(int, stdin.splitlines()[1].split()))\n    \n    if sum(buttons) == n or (sum(buttons) == n-1 and buttons[-1] == 1):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = [int(x) for x in stdin.splitlines()[1].split()]\n    count = sum(buttons)\n\n    if count == 0 or count == n:\n        return \"NO\"\n    elif count == n - 1 or count == n - 2:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 887,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    buttons = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    if sum(buttons) == 0 or (sum(buttons) == n and buttons[n-1] == 1):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def swap(i, j):\n        nonlocal p, s, coins\n        p[i - 1], p[j - 1] = p[j - 1], p[i - 1]\n        coins += abs(i - j)\n\n    n = int(stdin[0])\n    p = list(map(int, stdin[1].split()))\n    s = list(map(int, stdin[2].split()))\n    coins = 0\n    steps = []\n\n    for i in range(n):\n        if p[i] != s[i]:\n            swap(p.index(s[i]) + 1, i + 1)\n            steps.append((i + 1, p.index(s[i]) + 1))\n\n    output = f\"{coins}\\n{len(steps)}\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in steps)\n\n    return output\n\n\ndef"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    p = list(map(int, stdin.split(\"\\n\")[1].split()))\n    s = list(map(int, stdin.split(\"\\n\")[2].split()))\n    operations = []\n    coins = 0\n\n    for i in range(n):\n        if p[i] != s[i]:\n            j = s.index(p[i])\n            operations.append((i, j))\n            coins += abs(i - j)\n            p[i], p[j] = p[j], p[i]\n\n    print(coins)\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1])\n\n\nstdin = \"\"\"4\n4 2 1 3\n3 2 4 1\n\"\"\"\nsolution(stdin) "
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def swap(p, i, j):\n        p[i - 1], p[j - 1] = p[j - 1], p[i - 1]\n\n    n, p_str, s_str = stdin.split('\\n')\n    n = int(n)\n    p = list(map(int, p_str.split()))\n    s = list(map(int, s_str.split()))\n\n    coins = 0\n    swaps = []\n\n    for i in range(n):\n        if p[i] != s[i]:\n            for j in range(n):\n                if s[j] == p[i]:\n                    swap(p, i + 1, j + 1)\n                    swaps.append((i + 1, j + 1))\n                    coins += abs(i - j)\n                    break\n\n    print(coins)\n    print(len(swaps))\n    for swap in swaps:\n        print(*swap)\n\n\nstdin = \"\"\"4\n4 2 1 3\n3 2 4 1\"\"\"\nsolution(stdin) "
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    p = list(map(int, stdin.split(\"\\n\")[1].split()))\n    s = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    coins = 0\n    ops = []\n    for i in range(n):\n        if p[i] != s[i]:\n            j = s.index(p[i])\n            coins += abs(i - j)\n            ops.append((i, j))\n            p[i], p[j] = p[j], p[i]\n\n    print(coins)\n    print(len(ops))\n    for op in ops:\n        print(op[0], op[1])\n"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n\n    p_dict = {i: p[i] for i in range(n)}\n    s_dict = {i: s[i] for i in range(n)}\n\n    # initialize variables\n    cost = 0\n    visited = set()\n    operations = []\n\n    while p_dict != s_dict:\n        p_min, p_max = min(p_dict), max(p_dict)\n        s_min, s_max = min(s_dict), max(s_dict)\n\n        if p_min != s_min:\n            p_value, s_value = p_dict[p_min], s_dict[s_min]\n            p_dict[p_min], p_dict[p_value] = p_value, p_min\n            s_dict[s_min], s_dict[s_value] = s_value, s_min\n            cost += abs(p_min - s_min)\n            operations.append((p_min, s_min))\n\n        if p_max != s_max:\n            p_value, s_value = p_dict[p_max], s_dict[s_max]\n            p_dict[p_max], p_dict[p_value] = p_value, p_max\n            s_dict[s_max], s_dict[s_value] = s_value, s_max\n            cost += abs(p_max - s_max)\n            operations.append((p_max, s_max))\n\n        visited.add(tuple(sorted(p_dict.items())))\n\n    print(cost)\n    print(len(operations))\n    for i, j in operations:\n        print(i, j)\n\n    return 0\n"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n\n    visited = [False] * n\n    min_coins = 0\n    operations = []\n    swaps = []\n\n    def dfs(i, j):\n        nonlocal min_coins, visited, operations, swaps\n        visited[i - 1], visited[j - 1] = True, True\n        operations.append((i, j))\n\n        min_coins += abs(i - j)\n        swaps.append((i, j))\n        if i == j:\n            return\n        dfs(p[j - 1], p[i - 1])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] == s[j] and not visited[i] and not visited[j]:\n                dfs(i + 1, j + 1)\n                break\n\n    print(min_coins)\n    print(len(swaps))\n    for i, j in swaps:\n        print(f\"{i} {j}\")\n\n\nstdin = \"\"\"\n4\n4 2 1 3\n3 2 4 1\n\"\"\"\n\nsolution(stdin)"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = input(stdin).split('\\n')\n    n = int(n)\n    p = list(map(int, p.split()))\n    s = list(map(int, s.split()))\n    \n    coins = 0\n    for i in range(n):\n        if p[i] != s[i]:\n            j = s.index(p[i])\n            coins += abs(i - j)\n            p[i], p[j] = p[j], p[i]\n    \n    print(coins)\n    print(len(p) - n)\n    for i in range(n):\n        j = s.index(p[i])\n        print(i+1, j+1)\n    \n    return str(coins) + '\\n' + str(len(p) - n))\n"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n\n    # Create a dictionary to store the cost of swapping elements\n    cost = {}\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            cost[(i, j)] = abs(i - j)\n\n    # Initialize the distance matrix with zeros\n    dist = [[0 for j in range(n)] for i in range(n)]\n\n    # Fill the distance matrix using the Bellman-Ford algorithm\n    for i in range(n):\n        for j in range(n):\n            if p[i] == s[j]:\n                dist[i][j] = cost[(i, j)]\n\n    # Find the minimum cost\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(n):\n            min_cost = min(min_cost, dist[i][j])\n\n    # Check if the minimum cost is possible\n    if min_cost == float('inf'):\n        return \"IMPOSSIBLE\"\n\n    # Initialize the optimal solution list\n    opt_sol = []\n    for i in range(n):\n        for j in range(n):\n            if dist[i][j] == min_cost:\n                opt_sol.append((i+1, j+1))\n\n    # Print the minimum cost and the optimal solution\n    print(min_cost)\n    print(len(opt_sol))\n    for i in range(len(opt_sol)):\n        print(opt_sol[i][0], opt_sol[i][1])\n"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    p = list(map(int, input_data[1].split()))\n    s = list(map(int, input_data[2].split()))\n\n    def swap(p, i, j):\n        p[i], p[j] = p[j], p[i]\n\n    def find_swaps(p, s):\n        swaps = []\n        for i in range(n):\n            if p[i] != s[i]:\n                j = s.index(p[i])\n                swaps.append((i, j))\n                swap(p, i, j)\n        return swaps\n\n    swaps = find_swaps(p, s)\n    total_coins = sum(abs(i - j) for i, j in swaps)\n\n    return f\"{total_coins}\\n{len(swaps)}\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in swaps)\n"
    },
    {
        "number": 888,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    p = list(map(int, input_data[1].split()))\n    s = list(map(int, input_data[2].split()))\n\n    p_dict = {i: p[i] for i in range(n)}\n    s_dict = {i: s[i] for i in range(n)}\n\n    coins = 0\n    ops = []\n\n    for i in range(n):\n        if p_dict[i] != s_dict[i]:\n            j = s_dict[i] - 1\n            while p_dict[j] != s_dict[i]:\n                j += 1\n            coins += abs(i - j)\n            ops.append([i, j])\n            p_dict[i], p_dict[j] = p_dict[j], p_dict[i]\n\n    print(coins)\n    print(len(ops))\n    for op in ops:\n        print(f\"{op[0]} {op[1]}\")\n"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    grid = [[cell for cell in line] for line in lines]\n\n    for i in range(2):\n        for j in range(2):\n            if grid[i][j] == grid[i][j + 2] == grid[i + 2][j] == grid[i + 2][j + 2] == '#':\n                return \"YES\"\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n\n    # Initialize grid\n    grid = []\n    for line in input_lines:\n        grid.append([])\n        for cell in line:\n            if cell == \".\":\n                grid[-1].append(True)\n            else:\n                grid[-1].append(False)\n\n    # Check if there is a 2x2 square\n    for i in range(len(grid) - 1):\n        for j in range(len(grid[0]) - 1):\n            square = [\n                grid[i][j : j + 2],\n                grid[i + 1][j : j + 2],\n            ]\n            if all(all(cell == square[0][0]) for cell in square[0]) and all(\n                all(cell == square[0][0]) for cell in square[1]\n            ):\n                # There is a 2x2 square\n                return \"YES\"\n\n    # Check if repainting any cell will result in a 2x2 square\n    original_grid = [row[:] for row in grid]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                # Repaint the cell the other color\n                grid[i][j] = not grid[i][j]\n                # Check if the 2x2 square is formed\n                square_formed = False\n                for k in range(i - 1, i + 2):\n                    if 0 <= k < len(grid):\n                        for l in range(j - 1, j + 2):\n                            if 0 <= l < len(grid[0]):\n                                if grid[k][l] == grid[i][j]:\n                                    square_formed = True\n                if square_formed:\n                    # The 2x2 square is formed, restore original grid and return \"YES\"\n                    grid = original_grid\n                    return \"YES\"\n                # The repainting didn't result in a 2x2 square, restore original grid and continue\n                grid = original_grid\n\n    # No 2x2 square or repainting any cell doesn't result in a 2x2 square\n    return \"NO\"\n"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split('\\n')\n    for i, row in enumerate(rows):\n        if len(row) != 4:\n            return \"NO\"\n        if row != \"####\" * 4:\n            return \"NO\"\n    return \"YES\" "
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split('\\n')\n    black_cells = [(i, j) for i, row in enumerate(rows) for j, cell in enumerate(row) if cell == '#']\n    \n    # Check if there is a 2x2 square\n    for i, j in black_cells:\n        if i + 2 <= len(rows) and j + 2 <= len(rows[i]):\n            if rows[i][j] == '#' and rows[i+1][j] == '#' and rows[i+1][j+1] == '#' and rows[i+2][j] == '#' and rows[i+2][j+1] == '#':\n                return \"YES\"\n            \n    # Check if it is possible to repaint a cell to make a 2x2 square\n    for i, j in black_cells:\n        if i + 1 <= len(rows) and j + 1 <= len(rows[i]):\n            if rows[i][j] == '.' and rows[i+1][j] == '.' and rows[i+1][j+1] == '#' and rows[i][j+1] == '#':\n                return \"YES\"\n                \n    return \"NO\"\n"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    board = [[*input_lines[i][j*2:(j+1)*2]] for i in range(2)]\n\n    def is_possible(board: list, x: int, y: int) -> bool:\n        if board[x][y] == '#':\n            board[x][y] = '.'\n        else:\n            board[x][y] = '#'\n\n        for i in range(2):\n            for j in range(2):\n                if board[i][j] == '#' and all(cell == '#' for cell in board[i] + board[j]):\n                    return False\n\n        return True\n\n    for i in range(2):\n        for j in range(2):\n            if is_possible(board, i, j):\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    first_row = list(lines[0])\n    second_row = list(lines[1])\n    \n    if first_row == ['#', '#', '#', '#'] and second_row == ['#', '.', '.', '#']:\n        return 'YES'\n    elif first_row == ['#', '#', '#', '#'] and second_row == ['#', '#', '#', '#']:\n        return 'YES'\n    else:\n        return 'NO'\n\ndef"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    matrix = [list(line) for line in lines]\n\n    # Check if there's already a 2x2 square\n    for i in range(2):\n        if matrix[i][0] == matrix[i][1] == matrix[i+2][0] == matrix[i+2][1] and matrix[i][0] != '.':\n            return \"YES\"\n        if matrix[0][i] == matrix[1][i] == matrix[0][i+2] == matrix[1][i+2] and matrix[0][i] != '.':\n            return \"YES\"\n\n    # Check if there's a cell that can be repainted\n    for i in range(2):\n        for j in range(2):\n            if matrix[i][j] == matrix[i][j+2] == matrix[i+2][j] == matrix[i+2][j+2] == '.':\n                return \"YES\"\n\n    return \"NO\" "
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    board = [list(line) for line in lines]\n\n    for row in range(len(board)):\n        if '.' not in board[row]:\n            continue\n\n        for col in range(len(board[row])):\n            if board[row][col] == '.':\n                new_board = [[board[i][j] for j in range(len(board[i]))] for i in range(len(board))]\n                new_board[row][col] = '#' if new_board[row][col] == '.' else '.'\n\n                for i in range(2):\n                    for j in range(2):\n                        if len([k for k in range(4) if new_board[i][k] == new_board[i][k+1] == new_board[i+1][k] == new_board[i+1][k+1]]) == 4:\n                            return 'YES'\n\n    return 'NO'"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    rows = len(lines)\n    columns = len(lines[0])\n    \n    # Check if there is already a 2x2 square\n    for i in range(rows - 1):\n        for j in range(columns - 1):\n            if lines[i][j] == '#' and lines[i+1][j] == '#' and lines[i][j+1] == '#' and lines[i+1][j+1] == '#':\n                return \"YES\"\n    \n    # Check if repainting one cell would result in a 2x2 square\n    for i in range(rows):\n        for j in range(columns):\n            if lines[i][j] == '.':\n                # Check if the cell above and to the left is painted\n                if i > 0 and j > 0 and lines[i-1][j] == '#' and lines[i][j-1] == '#':\n                    return \"YES\"\n                \n                # Check if the cell to the left is painted\n                if j > 0 and lines[i][j-1] == '#':\n                    return \"YES\"\n                \n                # Check if the cell above is painted\n                if i > 0 and lines[i-1][j] == '#':\n                    return \"YES\"\n                \n    return \"NO\"\n"
    },
    {
        "number": 889,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    rows = [line.strip() for line in lines]\n\n    for row in rows:\n        if len(row) != 4:\n            return \"NO\"\n\n    black_cells = []\n    white_cells = []\n\n    for i in range(4):\n        for j in range(4):\n            if rows[i][j] == \".\":\n                white_cells.append((i, j))\n            elif rows[i][j] == \"#\":\n                black_cells.append((i, j))\n\n    if len(black_cells) == 0 or len(white_cells) == 0:\n        return \"NO\"\n\n    for cell in black_cells:\n        if (cell[0] - 1, cell[1]) in white_cells or (cell[0] + 1, cell[1]) in white_cells or (cell[0], cell[1] - 1) in white_cells or (cell[0], cell[1] + 1) in white_cells:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_difficulty(problems: list) -> bool:\n        if len(problems) < 2:\n            return False\n        max_difficulty = problems[0]\n        min_difficulty = problems[0]\n        for problem in problems:\n            if problem > max_difficulty:\n                max_difficulty = problem\n            if problem < min_difficulty:\n                min_difficulty = problem\n        if max_difficulty - min_difficulty < x:\n            return False\n        return True\n\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    count = 0\n    for i in range(1, n):\n        for j in range(i, n + 1):\n            if l <= sum(c[i:j]) <= r:\n                if check_difficulty(c[i:j]):\n                    count += 1\n    return count\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def check_difficulty_constraints(problemset):\n        if len(problemset) < 2:\n            return False\n        if min(problemset) < l:\n            return False\n        if max(problemset) > r:\n            return False\n        if max(problemset) - min(problemset) < x:\n            return False\n        return True\n\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    total_ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if check_difficulty_constraints([c[i], c[j]]):\n                total_ways += 1\n\n    return str(total_ways)\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(cur_sum, left, problems, result):\n        if left == 0:\n            result[0] += 1\n            return\n        for i in range(len(problems)):\n            if problems[i][1] <= cur_sum <= problems[i][2]:\n                problems[i][3].append(cur_sum)\n                dfs(cur_sum + problems[i][0], left - 1, problems, result)\n                problems[i][3].pop()\n\n    n, l, r, x = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    problems = [(ci, ci, ci, []) for ci in c]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(problems[i][3][-1] - problems[j][3][-1]) >= x:\n                total_sum = problems[i][3][-1] + problems[j][3][-1]\n                if l <= total_sum <= r:\n                    problems[i].append(total_sum)\n                    problems[j].append(total_sum)\n\n    result = [0]\n    for i in range(n):\n        dfs(l, 2, problems, result)\n\n    return result[0]\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    def is_valid(problems):\n        if len(problems) < 2:\n            return False\n        if sum(problems) < l or sum(problems) > r:\n            return False\n        if abs(max(problems) - min(problems)) < x:\n            return False\n        return True\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_valid(c[i:j]):\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    def count_ways(l: int, r: int, x: int) -> int:\n        if l > r or x < 0:\n            return 0\n        if l == r:\n            return 1\n        if x == 0:\n            return 0\n        return count_ways(l, min(r, l + x - 1), x) + count_ways(l + 1, r, x)\n\n    total_difficulty = sum(c)\n    if l > total_difficulty or r < total_difficulty:\n        return 0\n\n    min_difficulty = min(c)\n    max_difficulty = max(c)\n\n    if min_difficulty < l or max_difficulty > r:\n        return 0\n\n    ways = count_ways(l - min_difficulty, r - max_difficulty, x)\n    return ways\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    def is_suitable(problems):\n        return l <= sum(problems) <= r and abs(max(problems) - min(problems)) >= x\n\n    def count_suitable_problemsets(problems):\n        return sum(1 for i in range(1, n) for j in range(i + 1, n + 1) if is_suitable(problems[i:j]))\n\n    def count_all_problemsets():\n        return count_suitable_problemsets(range(1, n + 1))\n\n    return str(count_all_problemsets())\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(l, r, x, i):\n        if l > r:\n            return 1\n        if i == n:\n            return 0\n        res = dfs(l, r, x, i + 1)\n        if c[i] >= l and c[i] <= r and (i == 0 or c[i] - c[i - 1] >= x):\n            res += dfs(max(l, c[i] + x), r, x, i + 1)\n        return res\n\n    n, l, r, x = map(int, stdin.split())\n    c = list(map(int, input().split()))\n\n    return dfs(l, r, x, 0)"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n: int, l: int, r: int, x: int, c: list) -> int:\n        if n < 2 or l > r or x > r or x > n:\n            return 0\n        \n        c.sort()\n        min_difficulty = c[0]\n        max_difficulty = c[-1]\n        total_difficulty = sum(c)\n        total_count = 0\n\n        if total_difficulty >= l and total_difficulty <= r and max_difficulty - min_difficulty >= x:\n            total_count += 1\n\n        for i in range(1, n):\n            if min_difficulty + i <= l:\n                min_difficulty += c[i]\n                max_difficulty = max(max_difficulty, c[i])\n                total_difficulty = sum(c[:i+1])\n                if total_difficulty >= l and total_difficulty <= r and max_difficulty - min_difficulty >= x:\n                    total_count += 1\n\n            if max_difficulty - i >= x:\n                min_difficulty = min(min_difficulty, c[i] - (max_difficulty - r))\n                max_difficulty = max(max_difficulty, c[i])\n                total_difficulty = sum(c[i:])\n                if total_difficulty >= l and total_difficulty <= r and max_difficulty - min_difficulty >= x:\n                    total_count += 1\n\n        return total_count\n\n    n, l, r, x = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    return count_ways(n, l, r, x, c)\n\ndef"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    if l > r:\n        return \"0\"\n\n    def is_suitable_problemset(problems):\n        if len(problems) < 2:\n            return False\n        if min(problems) < l or max(problems) > r:\n            return False\n        if abs(max(problems) - min(problems)) < x:\n            return False\n        return True\n\n    from itertools import combinations\n    suitable_problemsets = [problems for i in range(2, n + 1) for problems in combinations(c, i) if is_suitable_problemset(problems)]\n\n    return str(len(suitable_problemsets))\n\n\nn, l, r, x = 3, 5, 6, 1\nc = [1, 2, 3]\nprint(solution(str(n) + \" \" + str(l) + \" \" + str(r) + \" \" + str(x) + \" \" + \" \".join(map(str, c))))\n"
    },
    {
        "number": 890,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split()[:4])\n    c = list(map(int, stdin.split()[4:]))\n\n    def is_suitable(problems):\n        difficulties = [c[i] for i in problems]\n        if sum(difficulties) < l or sum(difficulties) > r:\n            return False\n        return max(difficulties) - min(difficulties) >= x\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_suitable([i, j]):\n                count += 1\n    return str(count)\n\ninput_str = '''3 5 6 1\n1 2 3'''\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    colors = stdin.splitlines()[1]\n\n    def get_neighbors(i: int) -> tuple:\n        if i == 1:\n            return (n, i + 1)\n        elif i == n:\n            return (i - 1, 1)\n        else:\n            return (i - 1, i + 1)\n\n    def get_colors(i: int) -> int:\n        white_count = 0\n        black_count = 0\n        for j in get_neighbors(i):\n            if colors[j - 1] == 'W':\n                white_count += 1\n            else:\n                black_count += 1\n        return white_count, black_count\n\n    for _ in range(k):\n        new_colors = []\n        for i in range(1, n + 1):\n            white_count, black_count = get_colors(i)\n            if white_count > black_count:\n                new_colors.append('W')\n            else:\n                new_colors.append('B')\n        colors = ''.join(new_colors)\n\n    return colors\n"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    initial_colors = stdin.splitlines()[1]\n\n    colors = {i + 1: initial_colors[i] for i in range(n)}\n\n    for _ in range(k):\n        new_colors = {i + 1: colors[i] for i in range(n)}\n        for i in range(1, n + 1):\n            if colors[i] == 'W':\n                white_neighbors = sum(colors.get(j, 'B') == 'W' for j in (i - 1, i + 1, i - n, i + n))\n                black_neighbors = sum(colors.get(j, 'B') == 'B' for j in (i - 1, i + 1, i - n, i + n))\n                if white_neighbors > black_neighbors:\n                    new_colors[i] = 'W'\n            else:\n                white_neighbors = sum(colors.get(j, 'B') == 'W' for j in (i - 1, i + 1, i - n, i + n))\n                black_neighbors = sum(colors.get(j, 'B') == 'B' for j in (i - 1, i + 1, i - n, i + n))\n                if white_neighbors >= black_neighbors:\n                    new_colors[i] = 'B'\n        colors = new_colors\n\n    return ''.join(colors[i] for i in range(1, n + 1))\n\n\nstdin = \"\"\"6 1\nBWBBWW\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    chips = input().strip()\n    iterations = 0\n\n    while iterations < k:\n        new_chips = chips\n        for i in range(n):\n            if chips[i] == \"B\":\n                white_neighbours = 0\n                black_neighbours = 0\n                if i == 0:\n                    if chips[n - 1] == \"W\":\n                        white_neighbours += 1\n                    if chips[i + 1] == \"W\":\n                        white_neighbours += 1\n                    if chips[i + 1] == \"B\":\n                        black_neighbours += 1\n                elif i == n - 1:\n                    if chips[i - 1] == \"W\":\n                        white_neighbours += 1\n                    if chips[0] == \"W\":\n                        white_neighbours += 1\n                    if chips[0] == \"B\":\n                        black_neighbours += 1\n                else:\n                    if chips[i - 1] == \"W\":\n                        white_neighbours += 1\n                    if chips[i + 1] == \"W\":\n                        white_neighbours += 1\n                    if chips[i - 1] == \"B\":\n                        black_neighbours += 1\n                    if chips[i + 1] == \"B\":\n                        black_neighbours += 1\n\n                if white_neighbours > black_neighbours:\n                    new_chips = new_chips[:i] + \"W\" + new_chips[i + 1:]\n\n        chips = new_chips\n        iterations += 1\n\n    return chips\n\n\ndef"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    colors = stdin.split()[2]\n    if n == 1:\n        return colors[0]\n\n    for _ in range(k):\n        new_colors = ['B'] * n\n        for i in range(n):\n            if colors[i] == 'W':\n                new_colors[i] = 'B'\n            else:\n                new_colors[i] = 'W'\n            if i > 0:\n                if colors[i - 1] == 'W':\n                    new_colors[i] = 'W'\n                else:\n                    new_colors[i] = 'B'\n            if i < n - 1:\n                if colors[i + 1] == 'W':\n                    new_colors[i] = 'W'\n                else:\n                    new_colors[i] = 'B'\n        colors = new_colors\n\n    return ''.join(colors)\n\n\ndef"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    colors = input()\n\n    def get_neighbours(i: int) -> tuple:\n        return (i - 1) % n, (i + 1) % n\n\n    def count_colors(i: int, colors: str) -> tuple:\n        black_neighbours = colors[i - 1] + colors[i + 1]\n        white_neighbours = colors[get_neighbours(i)[0]] + colors[get_neighbours(i)[1]]\n        return black_neighbours.count('B'), white_neighbours.count('W')\n\n    for _ in range(k):\n        colors = ''.join([colors[(i + 1) % n] if count_colors(i + 1, colors)[0] > count_colors(i + 1, colors)[1] else colors[(i - 1) % n] for i in range(1, n + 1)])\n\n    return colors\n\n\ndef"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n    color_list = list(input_list[2])\n\n    # Initialize neighbors for each chip\n    neighbors = [[] for _ in range(n)]\n    for i in range(n):\n        neighbors[i].append((i - 1) % n)\n        neighbors[i].append((i + 1) % n)\n\n    # Iterate k times\n    for _ in range(k):\n        new_color_list = [\"\" for _ in range(n)]\n        for i in range(n):\n            white_count = 0\n            black_count = 0\n            for j in neighbors[i]:\n                if color_list[j] == \"W\":\n                    white_count += 1\n                else:\n                    black_count += 1\n            if white_count > black_count:\n                new_color_list[i] = \"W\"\n            else:\n                new_color_list[i] = \"B\"\n        color_list = new_color_list\n\n    # Print the final colors\n    return \"\".join(color_list)\n"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    colors = stdin.split()[2]\n    for i in range(k):\n        new_colors = []\n        for j in range(n):\n            if colors[(j + 1) % n] == \"W\":\n                white_neighbours = 1\n            else:\n                white_neighbours = 0\n            if colors[(j - 1) % n] == \"W\":\n                white_neighbours += 1\n            if colors[j] == \"W\":\n                black_neighbours = 1\n            else:\n                black_neighbours = 0\n            if colors[(j + 2) % n] == \"W\":\n                black_neighbours += 1\n            if colors[(j - 2) % n] == \"W\":\n                black_neighbours += 1\n            if white_neighbours > black_neighbours:\n                new_colors.append(\"W\")\n            else:\n                new_colors.append(\"B\")\n        colors = \"\".join(new_colors)\n    return colors"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    chips = input_list[1]\n\n    for i in range(k):\n        new_chips = [\"B\"] * n\n        for j in range(1, n):\n            neighbors = [(j - 1) % n, (j + 1) % n]\n            white_neighbors = sum([chips[neighbor] == \"W\" for neighbor in neighbors])\n            black_neighbors = sum([chips[neighbor] == \"B\" for neighbor in neighbors])\n            if white_neighbors > black_neighbors:\n                new_chips[j] = \"W\"\n        chips = \"\".join(new_chips)\n\n    return chips\n\n\ndef"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    initial_state = stdin.splitlines()[1]\n    initial_color = {\"W\": \"B\", \"B\": \"W\"}\n\n    for _ in range(k):\n        next_state = \"\"\n        for i in range(n):\n            if i == 0:\n                left = n - 1\n                right = i + 1\n            elif i == n - 1:\n                left = i - 1\n                right = 0\n            else:\n                left = i - 1\n                right = i + 1\n\n            if initial_state[i] == \"W\":\n                num_white_neighbors = 1 if initial_state[left] == \"W\" else 0\n                num_white_neighbors += 1 if initial_state[right] == \"W\" else 0\n                if num_white_neighbors > 1:\n                    next_state += initial_color[initial_state[i]]\n                else:\n                    next_state += initial_state[i]\n            else:\n                num_black_neighbors = 1 if initial_state[left] == \"B\" else 0\n                num_black_neighbors += 1 if initial_state[right] == \"B\" else 0\n                if num_black_neighbors > 1:\n                    next_state += initial_color[initial_state[i]]\n                else:\n                    next_state += initial_state[i]\n\n        initial_state = next_state\n\n    return next_state\n"
    },
    {
        "number": 891,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    chips = list(stdin.split()[2])\n\n    for i in range(k):\n        for j in range(1, n + 1):\n            if j == 1:\n                neighbours = [n, j + 1]\n            elif j == n:\n                neighbours = [j - 1, 1]\n            else:\n                neighbours = [j - 1, j + 1]\n\n            white_neighbours = 0\n            black_neighbours = 0\n\n            for neighbour in neighbours:\n                if chips[neighbour - 1] == \"W\":\n                    white_neighbours += 1\n                else:\n                    black_neighbours += 1\n\n            if white_neighbours > black_neighbours:\n                chips[j - 1] = \"W\"\n            else:\n                chips[j - 1] = \"B\"\n\n    return \"\".join(chips)\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    def lcm(arr):\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        result = 1\n        for x in arr:\n            result = result * x // gcd(result, x)\n        return result\n\n    def find_optimal_subsequence(a, m):\n        l = lcm(a)\n        if l > m:\n            return None\n        subseq = [i for i, x in enumerate(a) if x == l]\n        return subseq, l\n\n    optimal_subseq, l = find_optimal_subsequence(a, m)\n\n    if optimal_subseq is None:\n        print(\"-1\")\n    else:\n        print(l, len(optimal_subseq))\n        print(\" \".join(map(str, optimal_subseq)))\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def lcmm(arr):\n        result = 1\n        for x in arr:\n            result = lcm(result, x)\n        return result\n\n    def longest_subsequence(arr, m):\n        l = lcmm(arr)\n        if l <= m:\n            return arr, len(arr)\n\n        start, end = 0, len(arr) - 1\n        while start < end:\n            mid = (start + end) // 2\n            if lcmm(arr[:mid]) > m:\n                end = mid - 1\n            else:\n                start = mid\n\n        return arr[:start + 1], start + 1\n\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    lcm_value = lcmm(a)\n    if lcm_value <= m:\n        subseq, k_max = a, n\n    else:\n        subseq, k_max = longest_subsequence(a, m)\n\n    print(lcm_value, k_max)\n    print(*subseq)\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def lcm_array(arr: List[int]) -> int:\n        result = 1\n        for x in arr:\n            result = lcm(result, x)\n        return result\n\n    def longest_subsequence(arr: List[int], m: int) -> Tuple[int, List[int]]:\n        subseq_count = [0] * (m + 1)\n        subseq_count[0] = 1\n        max_length = 0\n        max_subseq = []\n\n        for x in arr:\n            for i in range(m, x - 1, -1):\n                if subseq_count[i - x] > 0:\n                    subseq_count[i] = max(subseq_count[i], subseq_count[i - x] + 1)\n                    if subseq_count[i] > max_length:\n                        max_length = subseq_count[i]\n                        max_subseq = [x] * max_length\n                        for j in range(i - x, i - x - max_length, -1):\n                            max_subseq[max_length - j - 1] = arr[j]\n                    break\n\n        return max_length, max_subseq\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    l = lcm_array(a)\n    k_max, subseq = longest_subsequence(a, m)\n\n    return f\"{l} {k_max}\\n\" + \" \".join(map(str, subseq)) "
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from functools import reduce\n    from math import gcd\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def lcm_arr(arr):\n        return reduce(lcm, arr)\n\n    def longest_subsequence(arr, m):\n        subsequence = []\n        for i in range(len(arr)):\n            if len(subsequence) == 0 or lcm_arr(subsequence) <= m:\n                subsequence.append(i)\n            else:\n                break\n        return subsequence\n\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n\n    lcm_a = lcm_arr(a)\n    subsequence = longest_subsequence(a, m)\n\n    output_str = f\"{lcm_a} {len(subsequence)}\\n\"\n    output_str += \" \".join(map(str, subsequence))\n\n    return output_str\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def lcs(a, m, n):\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if a[i - 1] == j:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n][m]\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    l = 1\n    for i in range(n):\n        l = lcm(l, a[i])\n\n    k_max = lcs(a, m, n)\n\n    result = f\"{l} {k_max}\\n\"\n    for i in range(n):\n        if dp[n][m] == k_max:\n            result += f\"{i + 1} \"\n    return result.rstrip()\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = 1\n    k_max = 0\n    k_max_positions = []\n\n    for i in range(n):\n        l = lcm(l, a[i])\n        if l > m:\n            break\n        k_max += 1\n        k_max_positions.append(i + 1)\n\n    output = f\"{l} {k_max}\\n{' '.join(map(str, k_max_positions))}\"\n    return output\n\n\ndef"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_optimal_subsequence(a: list, m: int) -> tuple:\n        l = 1\n        for i in range(len(a)):\n            l = lcm(l, a[i])\n            if l > m:\n                break\n        else:\n            i += 1\n        return l, i\n\n    def find_longest_subsequence(a: list, k_max: int) -> list:\n        longest_subsequence = []\n        for i in range(len(a)):\n            if a[i] not in longest_subsequence:\n                longest_subsequence.append(a[i])\n            if len(longest_subsequence) == k_max:\n                break\n        return longest_subsequence\n\n    def main(n: int, m: int, a: list) -> tuple:\n        l, k_max = find_optimal_subsequence(a, m)\n        longest_subsequence = find_longest_subsequence(a, k_max)\n        return l, k_max, longest_subsequence\n\n    n, m = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    l, k_max, longest_subsequence = main(n, m, a)\n    print(l, k_max)\n    print(*longest_subsequence)\n\n\nstdin = \"7 8\\n6 2 9 2 7 2 3\"\nsolution(stdin) "
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    l = 1\n    for i in range(n):\n        l = lcm(l, a[i])\n\n    if l > m:\n        return \"0 0\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(1, l + 1):\n            if j % a[i] == 0:\n                dp[i + 1] = max(dp[i + 1], dp[i] + 1)\n\n    k_max = max(dp)\n    if k_max == 0:\n        return \"0 0\"\n\n    for i in range(n - 1, -1, -1):\n        if dp[i + 1] == k_max:\n            print(i + 1, end=\" \")\n\n    return f\"{l} {k_max}\" "
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a):\n        def gcd(x, y):\n            while y:\n                x, y = y, x % y\n            return x\n\n        return a[0] * a[1] // gcd(a[0], a[1])\n\n    def subsequence_length(a, m, l):\n        return sum(1 for x in a if lcm(a) <= m)\n\n    def longest_subsequence(a, m):\n        l = lcm(a)\n        k_max = subsequence_length(a, m, l)\n        subsequence = sorted([i for i, x in enumerate(a) if lcm(a) <= m])\n        return l, k_max, subsequence\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    l, k_max, subsequence = longest_subsequence(a, m)\n    result = f\"{l} {k_max}\\n\" + \" \".join(map(str, subsequence))\n    return result\n"
    },
    {
        "number": 892,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a):\n        from functools import reduce\n        from math import gcd\n        return reduce(lambda x, y: x * y // gcd(x, y), a)\n\n    def longest_subsequence(a, m):\n        subseq = []\n        for i in range(len(a)):\n            subseq.append([i])\n            for j in range(i):\n                if a[i] % a[j] == 0:\n                    subseq[i].extend(subseq[j])\n        subseq = [sorted(x) for x in subseq]\n        subseq.sort(key=len, reverse=True)\n        for sub in subseq:\n            l = lcm([a[i] for i in sub])\n            if l <= m:\n                return l, len(sub), sub\n        return 0, 0, []\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n\n    l, k_max, subseq = longest_subsequence(a, m)\n    print(l, k_max)\n    print(*subseq)\n\n    return f\"{l}\\n{k_max}\"\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    d, n = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    edges = [tuple(map(int, input_list[i+2].split())) for i in range(n-1)]\n\n    def dfs(node, adj, visited, parent, max_a, min_a):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, adj, visited, node, max(max_a, a[node]), min(min_a, a[neighbor]))\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    visited = [False] * n\n    max_a = [0] * n\n    min_a = [float('inf')] * n\n\n    dfs(0, adj, visited, None, a[0], a[0])\n    valid_sets = [visited.count(True)]\n\n    for node in range(n):\n        if visited[node]:\n            visited[node] = False\n            dfs(node, adj, visited, None, a[node], a[node])\n            valid_sets.append(visited.count(True))\n\n    mod = 1000000007\n    result = sum(valid_sets) % mod\n    return str(result)\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, parent, depth):\n        visited[node] = True\n        for child in graph[node]:\n            if visited[child] == False:\n                dfs(child, visited, node, depth + 1)\n                depths[child] = depth + 1\n                max_depth[child] = max(max_depth[node], depths[child])\n\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    visited = [False] * n\n    depths = [-1] * n\n    max_depth = [-1] * n\n    dfs(0, visited, -1, 0)\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if visited[i] and visited[j] and max_depth[i] - max_depth[j] <= d:\n                count += 1\n\n    result = count % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, input().split())\n    a = list(map(int, input().split()))\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    def dfs(node, parent, depth, visited, min_depth, max_depth):\n        visited[node] = True\n        if parent is not None:\n            depth += 1\n            min_depth[node] = min(min_depth[node], depth)\n            max_depth[node] = max(max_depth[node], depth)\n            min_depth[parent] = min(min_depth[parent], depth)\n            max_depth[parent] = max(max_depth[parent], depth)\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, depth, visited, min_depth, max_depth)\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    min_depth = [float('inf')] * (n + 1)\n    max_depth = [0] * (n + 1)\n    dfs(1, None, 0, visited, min_depth, max_depth)\n\n    valid_sets = 0\n    for node in range(1, n + 1):\n        if visited[node] and max_depth[node] - min_depth[node] <= d:\n            valid_sets += 1\n\n    return str(valid_sets % (10**9 + 7))\n\n\ndef"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, stdin.split()[:2])\n    tree = list(map(int, stdin.split()[2:]))\n    tree = [tuple(tree[i:i+2]) for i in range(0, len(tree), 2)]\n\n    def find_parent(node):\n        for edge in tree:\n            if edge[1] == node:\n                return edge[0]\n        return None\n\n    def dfs(node, visited):\n        visited[node] = True\n        for edge in tree:\n            if edge[0] == node and not visited[edge[1]]:\n                dfs(edge[1], visited)\n\n    valid_sets = 0\n\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        dfs(i, visited)\n        max_val = -1\n        min_val = float('inf')\n        for node in range(1, n + 1):\n            if visited[node]:\n                max_val = max(max_val, a[node])\n                min_val = min(min_val, a[node])\n        if max_val - min_val <= d:\n            valid_sets += 1\n\n    return str(valid_sets % 1000000007)\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set, par: int, depth: int, d: int, max_depth: int, max_diff: int, mod: int) -> int:\n        visited.add(u)\n        for v in adj[u]:\n            if v != par:\n                dfs(v, visited, u, depth + 1, d, max_depth, max_diff, mod)\n        if depth > max_depth:\n            max_depth = depth\n        if depth > 1:\n            diff = a[u] - a[par]\n            max_diff = max(max_diff, diff)\n        if max_depth - depth + 1 <= d and max_diff <= d:\n            count[0] += 1\n            count[0] %= mod\n        return max_depth\n\n    n, d = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[i + 2:i + 4])\n        adj[u].append(v)\n        adj[v].append(u)\n\n    count = [0]\n    dfs(1, set(), -1, 1, d, 0, float('inf'), 1000000007)\n    return str(count[0])\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, stdin.split()[0:2])\n    adj_list = [[] for _ in range(n + 1)]\n    a = list(map(int, stdin.split()[2:n + 2]))\n    visited = [False] * (n + 1)\n    stack = []\n    count = 0\n\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[n + 2 + i:n + 4 + i])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(1)\n\n    def is_valid(subtree_nodes, a):\n        max_value = float('-inf')\n        min_value = float('inf')\n        for node in subtree_nodes:\n            max_value = max(max_value, a[node])\n            min_value = min(min_value, a[node])\n        return max_value - min_value <= d\n\n    for i in range(1, n + 1):\n        if visited[i]:\n            subtree_nodes = []\n            while stack[-1] != i:\n                node = stack.pop()\n                subtree_nodes.append(node)\n            subtree_nodes.append(i)\n            if is_valid(subtree_nodes, a):\n                count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, parent: int) -> tuple:\n        visited.add(node)\n        max_diff = 0\n        min_diff = float('inf')\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                diff = abs(a[node] - a[neighbor])\n                max_diff = max(max_diff, diff)\n                min_diff = min(min_diff, diff)\n                if neighbor not in visited:\n                    result = dfs(neighbor, visited, node)\n                    max_diff = max(max_diff, result[0])\n                    min_diff = min(min_diff, result[1])\n        return max_diff, min_diff\n\n    def count_valid_sets(max_diff: int) -> int:\n        count = 1\n        for i in range(1, n + 1):\n            count *= (2 ** (d - max_diff + 1))\n            count %= MOD\n        return count\n\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = [set() for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    MOD = 1000000007\n    result = 0\n    for i in range(1, n + 1):\n        max_diff, min_diff = dfs(i, set(), -1)\n        valid_sets = count_valid_sets(max_diff)\n        result += valid_sets\n        result %= MOD\n\n    return str(result)"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, parent: int, visited: set, adj: list, a: list, d: int, res: int) -> int:\n        visited.add(u)\n        for v in adj[u]:\n            if v != parent:\n                dfs(v, u, visited, adj, a, d, res)\n        if len(visited) > 1:\n            min_a = a[u]\n            max_a = a[u]\n            for v in visited:\n                if v != u:\n                    min_a = min(min_a, a[v])\n                    max_a = max(max_a, a[v])\n            if max_a - min_a <= d:\n                res += 1\n        return res\n\n    d, n = map(int, input().split())\n    a = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    res = 0\n    visited = set()\n    for i in range(n):\n        res = dfs(i, -1, visited, adj, a, d, res)\n    res = res % (10**9 + 7)\n\n    return str(res)\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, u):\n        if parent[u] != u:\n            parent[u] = find_parent(parent, parent[u])\n        return parent[u]\n\n    def union(parent, rank, u, v):\n        u_root = find_parent(parent, u)\n        v_root = find_parent(parent, v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n        elif rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += 1\n        return True\n\n    def dfs(graph, visited, parent, rank, start, target, max_diff):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if not union(parent, rank, start, neighbor):\n                    return 0\n                if start != target and neighbor != target:\n                    max_diff[0] = max(max_diff[0], abs(a[start] - a[neighbor]))\n                dfs(graph, visited, parent, rank, neighbor, target, max_diff)\n\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    visited = [False] * n\n    max_diff = [0]\n    count = 0\n    for start in range(n):\n        if not visited[start]:\n            dfs(graph, visited, parent, rank, start, start, max_diff)\n            if max_diff[0] <= d:\n                count += 1\n            max_diff[0] = 0\n\n    return str(count % (10**9 + 7))\n\n\nstdin = \"\"\"4 8\n7 8 7 5 4 6 4 10\n1 6\n1 2\n5 8\n1 3\n3 5\n6 7\n3 4\n\"\"\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 893,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int, visited: set[int], graph: list[list[int]], a: list[int]):\n        visited.add(node)\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, visited, graph, a)\n\n    def valid_set(S: set, a: list[int], d: int) -> bool:\n        max_a = max(a[x] for x in S)\n        min_a = min(a[x] for x in S)\n        return max_a - min_a <= d\n\n    d, n = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    count = 0\n    for node in range(n):\n        visited = set()\n        dfs(node, -1, visited, graph, a)\n        if valid_set(visited, a, d):\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, input().split())\n    x1, y1 = min(x, y), max(x, y)\n    x2, y2 = max(x, y), min(x, y)\n    return f\"{x1} {y1} {x2} {y2}\""
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    x, y = int(input_list[0]), int(input_list[1])\n    x_1, y_1, x_2, y_2 = 0, 0, 0, 0\n\n    if x == 0:\n        x_1, y_1 = 0, y\n        x_2, y_2 = y, 0\n    else:\n        x_1, y_1 = y, 0\n        x_2, y_2 = 0, y\n\n    return f\"{x_1} {y_1} {x_2} {y_2}\""
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n\n    x_1 = x - y + 1\n    y_1 = x\n    x_2 = y\n    y_2 = x + y - 1\n\n    return f\"{x_1} {y_1} {x_2} {y_2}\""
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 0 or y == 0:\n        return \"0 15 15 0\"\n    if x > 0:\n        x1, y1 = 0, 15\n        x2, y2 = x, -y\n    else:\n        x1, y1 = 15, 0\n        x2, y2 = -x, y\n    return f\"{x1} {y1} {x2} {y2}\""
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_1 = min(x, y - x + 1)\n    y_1 = 0\n    x_2 = y - x_1 + 1\n    y_2 = y\n    return f\"{x_1} {y_1} {x_2} {y_2}\"\n\nprint(solution(input())) "
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x1, y1, x2, y2 = 0, 0, 0, 0\n\n    if y < 0:\n        y1 = y\n        x1 = y + y2\n        y2 = -y\n        x2 = -y - y1\n    else:\n        y1 = y\n        x1 = y\n        x2 = y - y2\n        y2 = x2\n\n    if x < 0:\n        x1, x2 = x2, x1\n\n    return f\"{x1} {y1} {x2} {y2}\"\n\n\ninput_str = \"10 5\\n-10 5\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, input().split())\n    x_1 = 0\n    y_1 = 0\n    x_2 = 0\n    y_2 = 0\n    if x == 0:\n        x_1 = y\n        x_2 = y + 1\n        y_1 = 0\n        y_2 = 0\n    else:\n        x_1 = y\n        x_2 = y + 1\n        y_1 = x\n        y_2 = x - 1\n    print(x_1, y_1, x_2, y_2)\n    return \"\".join(stdin)\n"
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n\n    x1, y1, x2, y2 = 0, 0, 0, 0\n\n    if y % 2 == 0:\n        x1 = -y\n        y1 = x\n        x2 = y\n        y2 = -x\n    else:\n        x1 = -y\n        y1 = -x\n        x2 = y\n        y2 = x\n\n    return f\"{x1} {y1} {x2} {y2}\"\n\ninput_data = \"10 5\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_1 = 0\n    y_1 = 0\n    x_2 = x\n    y_2 = y\n    print(x_1, y_1, x_2, y_2)\n"
    },
    {
        "number": 894,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    a, b = min(x, y), max(x, y)\n    x1, y1, x2, y2 = 0, a, b, 0\n    return f\"{x1} {y1} {x2} {y2}\"\n\n\ndef"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    t_list = list(map(int, input_list[1].split()))\n    T = int(input_list[2])\n\n    max_visited = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(t_list[i] - t_list[j]) <= T:\n                max_visited += 1\n\n    return str(max_visited)"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.splitlines()[-2].split())\n    times = list(map(int, stdin.splitlines()[-3].split()))\n\n    times.sort()\n\n    left = 0\n    right = 0\n\n    for time in times:\n        if time - times[left] > T:\n            left += 1\n        right += 1\n\n    return right\n"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.splitlines()[-2].split())\n    t = list(map(int, stdin.splitlines()[-3].split()))\n    t.sort()\n    \n    visited = 0\n    left, right = 0, 0\n    while right < n:\n        if t[right] - t[left] <= T:\n            right += 1\n        else:\n            visited = max(visited, right - left)\n            left += 1\n    \n    return str(visited)"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.splitlines()[-1].split())\n    t = list(map(int, stdin.splitlines()[1].split()))\n    t.sort()\n    \n    visited = 0\n    i = 0\n    while i < n:\n        if t[i] + T <= t[0]:\n            break\n        i += 1\n    visited = i\n    \n    return str(visited)\n"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.splitlines()[-2].split())\n    t = list(map(int, stdin.splitlines()[-3].split()[1:]))\n    \n    freebie_visit = 0\n    \n    for i in range(n-1):\n        for j in range(i+1, n):\n            if abs(t[i] - t[j]) > T:\n                freebie_visit += 1\n    \n    return str(n - freebie_visit)"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[-2:])\n    students = list(map(int, stdin.split()[:-2]))\n\n    if n == 1:\n        return \"1\"\n\n    students.sort()\n    max_visited = 1\n\n    for i in range(1, n):\n        if students[i] - students[i - 1] > T:\n            break\n        max_visited += 1\n\n    return str(max_visited)"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split('\\n')[1:3])\n    t = sorted(map(int, stdin.split('\\n')[1].split()))\n    t = [0] + t + [T + 1]\n    freebie_visits = []\n\n    for i in range(1, n + 1):\n        if t[i] - t[i - 1] <= T:\n            freebie_visits.append(i)\n        else:\n            break\n\n    return len(freebie_visits)"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, input().split()))\n    t.sort()\n    \n    i, j, count = 0, 1, 0\n    while j < n:\n        if t[j] - t[i] <= T:\n            j += 1\n        else:\n            count += 1\n            i += 1\n    return count + 1\n"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, input().split())\n    times = list(map(int, input().split()))\n    times.sort()\n    \n    max_visited = 0\n    start = times[0] - T\n    end = times[0] + T\n    visited = 1\n    for i in range(1, n):\n        if times[i] < start:\n            visited += 1\n        else:\n            visited += 1\n            start = times[i] - T\n            end = times[i] + T\n    \n    max_visited = visited\n    \n    return str(max_visited)\n"
    },
    {
        "number": 895,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    students = list(map(int, input().split()))\n    freebie_time = int(input())\n\n    students.sort()\n    visited_students = 0\n\n    for i in range(n):\n        if students[i] - students[i-1] > freebie_time:\n            break\n        visited_students += 1\n\n    return visited_students\n\ndef"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n\n    if n * m > 10**9:\n        return \"NO\"\n\n    matrix = [[0] * m for _ in range(n)]\n    row_xor = [0] * n\n    col_xor = [0] * m\n\n    for i in range(n):\n        row_xor[i] = a[i]\n        for j in range(m):\n            matrix[i][j] = a[i] ^ b[j]\n            col_xor[j] ^= a[i] ^ b[j]\n\n    for j in range(m):\n        if col_xor[j] != b[j]:\n            return \"NO\"\n\n    for i in range(n):\n        if row_xor[i] != a[i]:\n            return \"NO\"\n\n    result = []\n    for i in range(n):\n        result.append([str(matrix[i][j]) for j in range(m)])\n    result = [\" \".join(row) for row in result]\n\n    return \"YES\\n\" + \"\\n\".join(result)\n\n\nstdin_input = \"2 3\\n2 9\\n5 3 13\"\nprint(solution(stdin_input))\n\nstdin_input = \"3 3\\n1 7 6\\n2 15 12\"\nprint(solution(stdin_input)) "
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    for i in range(n):\n        for j in range(m):\n            a[i] ^= b[j]\n\n    matrix = []\n    for i in range(n):\n        row = [0] * m\n        for j in range(m):\n            row[j] = a[i]\n            a[i] ^= b[j]\n        matrix.append(row)\n\n    if any(sum(row) != 0 for row in matrix):\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \"\\n\".join(str(row) for row in matrix)\n"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    if n > 1 and m > 1 and a[0] == 0 and b[0] == 0:\n        return \"NO\"\n\n    matrix = [[0 for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        row_xor = a[i]\n        for j in range(m):\n            col_xor = b[j]\n            matrix[i][j] = row_xor ^ col_xor\n            row_xor ^= matrix[i][j]\n            b[j] ^= matrix[i][j]\n\n    result = \"YES\\n\"\n    for row in matrix:\n        result += \" \".join(map(str, row)) + \"\\n\"\n\n    return result[:-1]\n\n\ndef"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def xor_sum(seq):\n        return sum(seq)\n    \n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n    \n    # check if there is a matrix satisfying the given constraints\n    if n * m == 0:\n        return \"NO\"\n    \n    total_a_sum = xor_sum(a)\n    total_b_sum = xor_sum(b)\n    total_a_xor = a[0]\n    total_b_xor = b[0]\n    \n    for i in range(1, n):\n        total_a_xor ^= a[i]\n    \n    for i in range(1, m):\n        total_b_xor ^= b[i]\n    \n    if (total_a_sum + total_b_sum) % 2 != 0 or total_a_xor != total_b_xor:\n        return \"NO\"\n    \n    # construct matrix\n    matrix = [[0] * m for _ in range(n)]\n    current_a_index = 0\n    current_b_index = 0\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = (a[current_a_index] ^ total_a_xor) ^ (b[current_b_index] ^ total_b_xor)\n            current_a_index += 1\n            current_b_index += 1\n    \n    return \"YES\\n\" + '\\n'.join([' '.join(map(str, row)) for row in matrix])"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    b = list(map(int, input_lines[2].split()))\n\n    def get_element(i, j):\n        return a[i] ^ b[j]\n\n    if len(a) != n or len(b) != m:\n        return \"NO\"\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = get_element(i, j)\n\n    result = \"YES\\n\"\n    for row in matrix:\n        result += \" \".join(map(str, row)) + \"\\n\"\n\n    return result\n\n\nstdin = \"2 3\\n2 9\\n5 3 13\"\nprint(solution(stdin)) "
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    # Generate the matrix\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(a[i] ^ b[j])\n        matrix.append(row)\n\n    # Check if the matrix satisfies the given constraints\n    for i in range(n):\n        for j in range(m):\n            if a[i] ^ b[j] != matrix[i][j]:\n                return \"NO\"\n\n    # Print the matrix if it satisfies the constraints\n    return \"YES\\n\" + \"\\n\".join(str(row) for row in matrix)"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    dimensions = input_list[0].split()\n    n = int(dimensions[0])\n    m = int(dimensions[1])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    def xor_matrix(a, b):\n        result = [[0 for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                result[i][j] = a[i] ^ b[j]\n        return result\n\n    matrix = xor_matrix(a, b)\n\n    if not matrix:\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), matrix))\n"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def xor_matrix(a: List[int], b: List[int], n: int, m: int) -> List[List[int]]:\n        result = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                for k in range(min(i + 1, n)):\n                    for l in range(min(j + 1, m)):\n                        result[i][j] ^= a[k] & b[l]\n        return result\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n + 2]))\n    b = list(map(int, stdin.split()[n + 2:]))\n\n    if n == 0 or m == 0:\n        return \"NO\"\n\n    matrix = xor_matrix(a, b, n, m)\n    if matrix == [[]] or matrix == []:\n        return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join([\" \".join(map(str, row)) for row in matrix])\n\n\ndef"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    b = list(map(int, stdin.split()[n+2:]))\n\n    # Check if matrix is possible\n    if sum(a) != 0 or sum(b) != 0:\n        return \"NO\"\n\n    # Create matrix\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(a[i] ^ b[j])\n        matrix.append(row)\n\n    # Print matrix\n    result = \"YES\\n\"\n    for row in matrix:\n        result += \" \".join(map(str, row)) + \"\\n\"\n\n    return result\n"
    },
    {
        "number": 896,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n\n    # Generate all possible matrices\n    matrices = []\n    for i in range(2**n):\n        row = format(i, f'0{n}b')\n        row = [int(x) for x in row]\n        for j in range(2**m):\n            col = format(j, f'0{m}b')\n            col = [int(x) for x in col]\n            matrix = []\n            for k in range(n):\n                row_value = 0\n                for l in range(m):\n                    row_value ^= col[l] * (2**k)\n                matrix.append(row_value)\n            matrices.append(matrix)\n\n    # Filter matrices that satisfy constraints\n    valid_matrices = []\n    for matrix in matrices:\n        row_xor = [sum(matrix[i]) % 2 for i in range(n)]\n        col_xor = [sum(matrix[i][j] for i in range(n)) % 2 for j in range(m)]\n        if all(x == y for x, y in zip(row_xor, a)) and all(x == y for x, y in zip(col_xor, b)):\n            valid_matrices.append(matrix)\n\n    # Output result\n    if not valid_matrices:\n        return \"NO\"\n    else:\n        result = \"YES\\n\"\n        for matrix in valid_matrices:\n            result += ' '.join(map(str, matrix)) + \"\\n\"\n        return result.strip()"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n\n        g, x, _ = egcd(a, m)\n        if g != 1:\n            raise Exception(\"gcd(a, m) must be 1\")\n        else:\n            return x % m\n\n    def lexicographically_greater(word1, word2, alphabet_size):\n        for i in range(len(word1)):\n            if word1[i] > word2[i]:\n                return True\n            elif word1[i] < word2[i]:\n                return False\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    word1 = list(map(int, stdin.split()[2:2 * n:2]))\n    word2 = list(map(int, stdin.split()[3:2 * n:2]))\n\n    total_positions = 0\n    for a in word1 + word2:\n        if a != 0:\n            total_positions += m\n\n    probability = (total_positions - sum(word1)) / (total_positions - sum(word2))\n    coprime_numbers = gcd(probability, m)\n\n    if lexicographically_greater(word1, word2, m):\n        return str(int(probability * coprime_numbers * mod_inverse(coprime_numbers, 10**9 + 7)))\n    else:\n        return str(int(0 * coprime_numbers * mod_inverse(coprime_numbers, 10**9 + 7)))"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    s1 = [int(x) for x in stdin.splitlines()[1].split()]\n    s2 = [int(x) for x in stdin.splitlines()[2].split()]\n\n    for i in range(n):\n        if s1[i] == 0:\n            s1[i] = s2[i]\n\n    s1_str = ''.join(map(str, s1))\n    s2_str = ''.join(map(str, s2))\n\n    if s1_str > s2_str:\n        p = 1\n        q = 2\n    else:\n        p = 2\n        q = 1\n\n    result = (p * pow(q, -1, 10**9 + 7)) % (10**9 + 7)\n    return result"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s1_erased = list(map(int, stdin.split()[2:2+n]))\n    s2_erased = list(map(int, stdin.split()[2+n:2+2*n]))\n\n    s1_restored = [chr(i) if i != 0 else ' ' for i in s1_erased]\n    s2_restored = [chr(i) if i != 0 else ' ' for i in s2_erased]\n\n    s1 = ''.join(s1_restored)\n    s2 = ''.join(s2_restored)\n\n    if s1 > s2:\n        p = 1\n    else:\n        p = 0\n\n    q = 1\n    for i in range(m):\n        if i in s1_erased:\n            q *= i\n        if i in s2_erased:\n            q *= i + 1\n\n    q_inv = find_inverse(q, 10**9 + 7)\n    result = p * q_inv\n\n    return str(result % (10**9 + 7))\n\ndef"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    def modular_inverse(a: int, m: int) -> int:\n        gcd, x, _ = extended_gcd(a, m)\n        if gcd != 1:\n            raise ValueError(\"Inverse does not exist\")\n        return x % m\n\n    def lexicographically_greater(s1: str, s2: str) -> bool:\n        for c1, c2 in zip(s1, s2):\n            if c1 > c2:\n                return True\n            elif c1 < c2:\n                return False\n        return len(s1) > len(s2)\n\n    def solve(n: int, m: int, s1: List[int], s2: List[int]) -> int:\n        p = 0\n        for i in range(n):\n            if s1[i] == 0:\n                p += s2[i]\n            else:\n                p += s1[i]\n        q = m\n        return p * modular_inverse(q, 10**9 + 7)\n\n    n, m = map(int, stdin.split()[:2])\n    s1 = list(map(int, stdin.split()[2:2 * n]))\n    s2 = list(map(int, stdin.split()[2 * n:]))\n\n    if lexicographically_greater(str(s1), str(s2)):\n        return solve(n, m, s1, s2)\n    else:\n        return 0\n"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_prob(a: str, b: str) -> int:\n        count = 0\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                count += 1\n        return count\n\n    n, m = map(int, stdin.split()[:2])\n    a = stdin.split()[2:n + 2]\n    b = stdin.split()[n + 2:]\n\n    prob = get_prob(a, b)\n    q = 10**9 + 7\n    if prob == n:\n        return 0\n    return prob * pow(10**9 + 7, -1, q) % q\n\n\ndef"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def inverse_mod(a, m):\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n\n        g, x, _ = egcd(a, m)\n        return x % m\n\n    n, m = map(int, stdin.splitlines()[0].split())\n    s1 = list(map(int, stdin.splitlines()[1].split()))\n    s2 = list(map(int, stdin.splitlines()[2].split()))\n\n    s1_replaced = [0] * n\n    s2_replaced = [0] * n\n    for i in range(n):\n        if s1[i] == 0:\n            s1_replaced[i] = s2[i]\n        elif s2[i] == 0:\n            s2_replaced[i] = s1[i]\n\n    if s1_replaced == s2_replaced:\n        p, q = 0, 1\n    else:\n        p, q = 1, m\n        for i in range(n):\n            if s1_replaced[i] > s2_replaced[i]:\n                p *= s1[i]\n            elif s1_replaced[i] < s2_replaced[i]:\n                p *= s2[i]\n                q *= s1[i]\n            else:\n                p *= s1[i]\n                q *= s1[i] + s2[i]\n                q = gcd(q, m)\n\n    q_inv = inverse_mod(q, (10**9) + 7)\n    p_q_inv = (p * q_inv) % ((10**9) + 7)\n\n    return str(p_q_inv)\n"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def multiply(x: int, y: int) -> int:\n        result = 0\n        while y > 0:\n            if y & 1:\n                result = (result + x) % (10**9 + 7)\n            x = (x << 1) % (10**9 + 7)\n            y >>= 1\n        return result\n\n    def inverse(x: int) -> int:\n        result = pow(x, 10**9 - 23, 10**9 + 7)\n        return result\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    total_count = m * n\n    common_count = sum(1 for i in range(n) if a[i] == b[i])\n    unique_count = sum(1 for i in range(n) if a[i] != b[i] and a[i])\n\n    p = common_count / total_count\n    q = 1 - unique_count / total_count\n    q_inverse = inverse(q)\n    result = multiply(int(p * q_inverse), 1)\n\n    return str(result)"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    b = list(map(int, input_lines[2].split()))\n\n    P = 1\n    Q = 1\n\n    for i in range(n):\n        if a[i] == 0:\n            if b[i] == 0:\n                continue\n            else:\n                P *= m\n                Q *= b[i]\n        else:\n            P *= a[i]\n            Q *= m - a[i]\n\n    P = P // Q\n    P = P % (10**9 + 7)\n\n    return str(P)\n"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    s1 = [int(x) for x in stdin.split()[2:n+2]]\n    s2 = [int(x) for x in stdin.split()[n+2:]]\n\n    # Count the number of non-erased characters in each word\n    count1 = sum(1 for x in s1 if x != 0)\n    count2 = sum(1 for x in s2 if x != 0)\n\n    # Calculate the probability of S1 being lexicographically greater than S2\n    if count1 == count2:\n        prob = 0.5\n    else:\n        prob = count1 / (count1 + count2)\n\n    # Calculate the result\n    P = prob\n    Q = 1\n    R = int(P * Q ** -1) % (10**9 + 7)\n\n    return str(R)\n"
    },
    {
        "number": 897,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def mod_inverse(a, m):\n        g = gcd(a, m)\n        if g != 1:\n            raise ValueError(\"Inverse does not exist\")\n        return pow(a, m - 2, m)\n\n    def lexicographically_greater(word1, word2, alphabet_size):\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                return word1[i] > word2[i]\n        return len(word1) > len(word2)\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[:2])\n        word1 = list(map(int, stdin.split()[2:n + 2]))\n        word2 = list(map(int, stdin.split()[n + 2:]))\n\n        p = 1\n        q = 1\n        for i in range(n):\n            if word1[i] == 0:\n                p *= m - 1\n                q *= word2[i]\n            else:\n                p *= word2[i]\n                q *= m - word1[i]\n\n        p_inv = mod_inverse(p, 10**9 + 7)\n        result = (p_inv * q) % (10**9 + 7)\n\n        return str(result)\n\n    return main(stdin)\n"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    a = [M // N] * N\n    if M % N != 0:\n        a[M % N] += 1\n    return str(max(math.gcd(a[i], a[i + 1]) for i in range(N - 1)))\n\ninput_str = input().strip()\nprint(solution(input_str)) "
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    N, M = input_values[0], input_values[1]\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    a = M // N\n    gcd_val = a\n    for i in range(1, N):\n        gcd_val = gcd(gcd_val, a)\n\n    return str(gcd_val)\n"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    sequence = []\n\n    for _ in range(N):\n        sequence.append(int(input()))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        else:\n            return gcd(b, a % b)\n\n    return str(max(gcd(sequence[i], sequence[j]) for i in range(N) for j in range(N) if i != j))\n"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    \n    if N == 1:\n        return 1\n    \n    a = sorted([0] * N, key=lambda x: M - x)\n    a[0] = M\n    \n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return x\n    \n    gcd_values = [a[i] - a[i + 1] for i in range(N - 1)]\n    max_gcd = max(gcd(a[i], a[i + 1]) for i in range(N - 1))\n    \n    return max_gcd"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    a = []\n    for i in range(N):\n        a.append(M // N)\n\n    return str(max(math.gcd(a[i], a[j]) for i in range(N) for j in range(i+1, N)))\n"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M % N == 0:\n        return str(M // N)\n    return str(M // math.gcd(*[range(1, N + 1)]))\n\ndef"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    N = int(input_values[0])\n    M = int(input_values[1])\n\n    if N > M:\n        return \"0\"\n\n    a = sorted(list(range(1, N + 1)), reverse=True)\n    a.sort(key=lambda x: M % x, reverse=True)\n\n    max_gcd = 1\n    for i in a:\n        M -= i\n        max_gcd = i\n        if M == 0:\n            break\n\n    return str(max_gcd)\n"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    a = [M // N + 1] * N\n    a[0] = 1\n    a[-1] = M % N + 1\n    return max(reduce(__gcd, a))\n\ndef"
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    N = int(input_values[0])\n    M = int(input_values[1])\n    a = [M // N + 1] * N\n    a[0] = 1\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    for i in range(1, N):\n        for j in range(i):\n            a[i] = min(a[i], a[j] + M // (N - j))\n\n    result = a[-1]\n    for i in range(1, N):\n        result = gcd(result, a[i])\n\n    return str(result)\n\n\nstdin = \"3 14\"\nprint(solution(stdin)) "
    },
    {
        "number": 898,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M == 0:\n        return 1\n    if N == 1:\n        return M\n    min_val = M // N\n    gcd_sum = 0\n    for i in range(N):\n        gcd_sum += M % (N + 1)\n    gcd_sum -= (N * min_val)\n    return min_val if gcd_sum < 0 else min_val + 1\n\n\ninput_str = \"3 14\"\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    graph = [list(map(int, input().split())) for _ in range(M)]\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(N)]\n    for edge in graph:\n        adj_list[edge[0]-1].append((edge[1]-1, edge[2]))\n        adj_list[edge[1]-1].append((edge[0]-1, edge[2]))\n\n    # Initialize distance dictionary\n    distance = {i: float('inf') for i in range(N)}\n    distance[0] = 0\n\n    # Initialize priority queue\n    pq = [(0, 0)]\n\n    # Dijkstra's algorithm\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > distance[u]:\n            continue\n        for v, w in adj_list[u]:\n            if d + w < distance[v]:\n                distance[v] = d + w\n                heapq.heappush(pq, (d + w, v))\n\n    # Count number of edges not in shortest paths\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                min_dist = min(distance[i], distance[j])\n                for edge in graph:\n                    if edge[0] == i+1 and edge[1] == j+1:\n                        if edge[2] < min_dist:\n                            count += 1\n                            break\n\n    return count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    adj_list = [[] for _ in range(N)]\n    edges = []\n    for _ in range(M):\n        a, b, c = map(int, stdin.split()[2:])\n        adj_list[a-1].append((b-1, c))\n        adj_list[b-1].append((a-1, c))\n        edges.append((a-1, b-1, c))\n\n    def dfs(u: int, visited: set, dist: dict, parent: dict) -> None:\n        visited.add(u)\n        for v, w in adj_list[u]:\n            if v not in visited and (w < dist.get(v, float('inf')) or v in parent):\n                dist[v] = min(dist.get(v, float('inf')), w + dist[u])\n                parent[v] = u\n                dfs(v, visited, dist, parent)\n\n    for u in range(N):\n        visited = set()\n        dist = {u: 0}\n        parent = {u: -1}\n        dfs(u, visited, dist, parent)\n\n    res = [False] * M\n    for u, v, w in edges:\n        if parent[v] != u:\n            res[v] = True\n\n    return sum(res)\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    N, M = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split()[1:])) for line in stdin.split('\\n')[1:]]\n    graph = defaultdict(dict)\n\n    for a, b, c in edges:\n        graph[a][b] = c\n        graph[b][a] = c\n\n    def dfs(node, visited, parent, depth, memo):\n        if node in memo:\n            return memo[node]\n        if node in visited:\n            return depth + graph[parent][node]\n        visited.add(node)\n        memo[node] = float('inf')\n        for neighbor in graph[node]:\n            memo[node] = min(memo[node], dfs(neighbor, visited, node, depth + graph[node][neighbor], memo))\n        return memo[node]\n\n    shortest_path_count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            shortest_path_count += max(0, dfs(i, set(), None, 0, defaultdict(int)) - dfs(j, set(), None, 0, defaultdict(int)) + 1)\n\n    return shortest_path_count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    edges = []\n    for _ in range(M):\n        a, b, c = map(int, stdin.split()[2:5])\n        edges.append((a, b, c))\n    graph = [[] for _ in range(N+1)]\n    for edge in edges:\n        a, b, c = edge\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    \n    # Dijkstra's algorithm for shortest path\n    dist = [float('inf')] * (N+1)\n    dist[1] = 0\n    visited = [False] * (N+1)\n    Q = [(0, 1)]\n    \n    while Q:\n        d, u = Q.pop(0)\n        visited[u] = True\n        for v, w in graph[u]:\n            if not visited[v] and d + w < dist[v]:\n                dist[v] = d + w\n                Q.append((dist[v], v))\n    \n    # Count the number of edges not in shortest path\n    count = 0\n    for edge in edges:\n        a, b, c = edge\n        if dist[a] + c > dist[b]:\n            count += 1\n        if dist[b] + c > dist[a]:\n            count += 1\n    return count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    adj_list = [[] for _ in range(N)]\n\n    for i in range(M):\n        a, b, c = map(int, stdin.split()[2 * i + 2:2 * i + 5])\n\n        adj_list[a - 1].append((b - 1, c))\n        adj_list[b - 1].append((a - 1, c))\n\n    visited = [False] * N\n    shortest_dist = [float('inf')] * N\n    shortest_dist[0] = 0\n\n    def dfs(node, dist):\n        visited[node] = True\n        for neighbor, weight in adj_list[node]:\n            if not visited[neighbor]:\n                new_dist = dist + weight\n                if new_dist < shortest_dist[neighbor]:\n                    shortest_dist[neighbor] = new_dist\n                    dfs(neighbor, new_dist)\n\n    dfs(0, 0)\n    count = 0\n\n    for i in range(M):\n        a, b, c = map(int, stdin.split()[2 * i + 2:2 * i + 5])\n        if shortest_dist[a - 1] + c < shortest_dist[b - 1]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    edges = [(int(a), int(b), int(c)) for a, b, c in [line.split() for line in stdin.split(\"\\n\")[1:]]]\n    edges.sort(key=lambda x: x[2])\n\n    def dfs(start, end, visited, distance, edges, parent):\n        visited[start] = True\n        if start == end:\n            return True\n        for neighbor, weight in edges[start]:\n            if not visited[neighbor] and (not parent or weight < parent[neighbor]):\n                parent[neighbor] = weight\n                if dfs(neighbor, end, visited, distance, edges, parent):\n                    return True\n        return False\n\n    result = 0\n    for i in range(M):\n        visited = [False] * N\n        parent = [float('inf')] * N\n        if not dfs(0, 0, visited, 0, edges, parent):\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    graph = [list(map(int, stdin.split()[2:])) for _ in range(M)]\n    edges = set()\n    for a, b, c in graph:\n        edges.add((a, b, c))\n        edges.add((b, a, c))\n\n    def find_shortest_path(source: int, target: int) -> int:\n        visited = [False for _ in range(N + 1)]\n        visited[source] = True\n        queue = [(0, source, [])]\n        while queue:\n            distance, node, path = queue.pop(0)\n            if node == target:\n                return distance, path\n            for neighbor, weight in adjacency_list[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((distance + weight, neighbor, path + [node]))\n        return float('inf')\n\n    adjacency_list = [[] for _ in range(N + 1)]\n    for a, b, c in edges:\n        adjacency_list[a].append((b, c))\n        adjacency_list[b].append((a, c))\n\n    count = 0\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            distance, path = find_shortest_path(i, j)\n            if len(path) == 0:\n                count += 1\n    return count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def min_path_length(a, b):\n        if a == b:\n            return 0\n        if a == 1:\n            return min_path_length(a + 1, b) + 1\n        if b == 1:\n            return min_path_length(a - 1, b) + 1\n        return min(min_path_length(a - 1, b), min_path_length(a, b - 1)) + 1\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [tuple(map(int, stdin.split()[i:i + 3])) for i in range(2, 2 * M + 2, 3)]\n    edges = set([(a, b) for a, b, c in graph]) | set([(b, a) for a, b, c in graph])\n    num_edges = len(edges)\n\n    min_path_count = 0\n    for edge in edges:\n        min_path_count += min_path_length(edge[0], edge[1])\n\n    return num_edges - min_path_count\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    edges = []\n    for i in range(M):\n        a, b, c = map(int, stdin.split()[2*i+1:2*i+4])\n        edges.append((a, b, c))\n\n    # Find the maximum distance between any two vertices\n    max_distance = max(edges, key=lambda x: x[2])[2]\n\n    # Calculate the minimum distance between each pair of vertices\n    distances = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(M):\n        distances[edges[i][0]-1][edges[i][1]-1] = edges[i][2]\n        distances[edges[i][1]-1][edges[i][0]-1] = edges[i][2]\n\n    # Calculate the shortest distance between each pair of vertices\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if distances[i][k] and distances[k][j] and distances[i][k] + distances[k][j] < distances[i][j]:\n                    distances[i][j] = distances[i][k] + distances[k][j]\n\n    # Count the number of edges that are not contained in any shortest path\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j and distances[i][j] > max_distance:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 899,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(graph, start, end):\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            (cost, vertex) = queue.pop(0)\n            if vertex == end:\n                return cost\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor, weight in graph[vertex].items():\n                    queue.append((cost + weight, neighbor))\n        return -1\n\n    def count_edges_not_in_shortest_paths(graph, n):\n        count = 0\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                shortest_path = find_shortest_path(graph, i, j)\n                if shortest_path == -1:\n                    return -1\n                for k in range(1, n + 1):\n                    if k not in [i, j]:\n                        shortest_path_k = find_shortest_path(graph, i, k) + find_shortest_path(graph, k, j)\n                        if shortest_path_k == shortest_path:\n                            count += 1\n        return count\n\n    def read_input(stdin: str) -> tuple:\n        N, M = map(int, stdin.split()[:2])\n        graph = {i: {} for i in range(1, N + 1)}\n        for i in range(M):\n            a, b, c = map(int, stdin.split()[2 * i: 2 * i + 3])\n            graph[a][b] = c\n        return N, M, graph\n\n    N, M, graph = read_input(stdin)\n    result = count_edges_not_in_shortest_paths(graph, N)\n    return result\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 1000000007\n    count = 0\n    for i in range(10):\n        s = stdin.replace('?', str(i))\n        if int(s) % 13 == 5 or int(s) % 13 == 13 - 5:\n            count += 1\n    return str(count % MOD)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    S = stdin.strip()\n    def count_integers(S: str, digit: str) -> int:\n        count = 0\n        for i in range(len(S)):\n            if S[i] == '?':\n                count += len(digit)\n            else:\n                count += S[i] == digit\n        return count\n    count_five = 0\n    for digit in ['0', '5']:\n        count_five += (count_integers(S, digit) * (2 if digit == '5' else 1)) % MOD\n    return str(count_five % MOD)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    S = stdin\n    digits = '0123456789'\n\n    def count_integers(S: str) -> int:\n        count = 0\n        for digit in digits:\n            for i in range(len(S)):\n                if S[i] == '?':\n                    S = S[:i] + digit + S[i+1:]\n                    count += count_integers(S)\n                    S = S[:i] + '?' + S[i+1:]\n        return count\n\n    def count_modulo(count: int) -> int:\n        return count % MOD\n\n    return count_modulo(count_integers(S))\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 1000000007\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i] == '?':\n            for j in range(10):\n                if (i == 0 or stdin[i - 1] != '0') and ((j * 10 + j) % 13 == 5):\n                    count += 1\n        elif int(stdin[i]) % 13 == 5:\n            count += 1\n    return str(count % MOD)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_digits(digit: str) -> int:\n        count = 0\n        for char in digit:\n            if char == '?':\n                count += 1\n        return count\n\n    def replace_digits(digit: str, replacement: str) -> str:\n        result = ''\n        for char in digit:\n            if char == '?':\n                result += replacement\n            else:\n                result += char\n        return result\n\n    def is_valid(digit: str) -> bool:\n        return int(digit) % 13 == 5\n\n    S = stdin.strip()\n    count = 0\n\n    for digit in range(1, 10):\n        for i in range(1, 10):\n            replaced_digit = replace_digits(S, str(i))\n            count += count_digits(replaced_digit) * int(is_valid(replaced_digit))\n\n    return count % (10 ** 9 + 7)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    S = stdin\n    count = 0\n    for i in range(1, len(S)):\n        if S[i] == '?':\n            count += len(str(i))\n    \n    for i in range(1, 10):\n        temp_str = S.replace('?', str(i))\n        if int(temp_str) % 13 == 5:\n            count += 1\n    return str(count % MOD)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i] == \"?\":\n            for j in range(10):\n                count += count_remainder(j, 5, 13)\n        else:\n            digit = int(stdin[i])\n            count += count_remainder(digit, 5, 13)\n        count %= MOD\n    return str(count)\n\n\ndef"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            for j in range(10):\n                temp = s[:i] + str(j) + s[i+1:]\n                if int(temp) % 13 == 5:\n                    count += 1\n        else:\n            temp = s\n            if int(temp) % 13 == 5:\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin\n    MOD = 10**9 + 7\n\n    count = 0\n    for i in range(1, 10):\n        for j in range(1, 10):\n            for k in range(1, 10):\n                for l in range(1, 10):\n                    for m in range(1, 10):\n                        if S.replace('?', str(i))[-1] == '5' and S.count('?') == 5:\n                            count += 1\n\n    return str(count % MOD)\n"
    },
    {
        "number": 900,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    S = stdin.strip()\n    count = 0\n    for i in range(len(S)):\n        if S[i] == \"?\":\n            for j in range(10):\n                count += \"0\" <= str(j) <= \"9\"\n        else:\n            count += S[i] in \"0123456789\"\n    return str(count % mod)\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_traitor(universe: int) -> bool:\n        return universe < 0\n\n    def is_member(universe: int) -> bool:\n        return universe > 0\n\n    n, m = map(int, stdin.split()[:2])\n    k_sum = 0\n    for _ in range(m):\n        k_sum += int(stdin.split()[0])\n    if k_sum > 10000:\n        return \"NO\"\n\n    ricks = [0] * (2 * n)\n    for i in range(m):\n        k = int(stdin.split()[i])\n        for j in range(k):\n            universe = int(stdin.split()[i * k + j + 1])\n            if is_traitor(universe):\n                ricks[universe + n] += 1\n            else:\n                ricks[universe] += 1\n\n    return \"YES\" if sum(1 for count in ricks if count > 0) > 0 else \"NO\"\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    groups = [list(map(int, stdin.split()[2:])) for _ in range(m)]\n\n    # Helper function to check if a group contains only traitors\n    def is_traitor_group(group):\n        for member in group:\n            if member > 0:\n                return False\n        return True\n\n    # Generate all possible scenarios where the world will end\n    scenarios = [is_traitor_group(group) for group in groups]\n\n    # Check if there's at least one scenario where the world will end\n    if any(scenarios):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    groups = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        groups.append(v)\n\n    def is_traitor(u, universe_count):\n        return u == -universe_count or u == universe_count - 1\n\n    def count_traitors(group):\n        return sum(map(lambda x: is_traitor(x, n), group))\n\n    def check_scenario(group_counts):\n        return any(count_traitors(group) == group_counts[u] for u in range(1, n + 1))\n\n    def count_traitor_universes(group):\n        return sum(map(lambda x: x[1] if x[0] > 0 else -x[1], group))\n\n    def count_traitors_in_universe(universe_number, group_counts):\n        return group_counts.count(universe_number) + group_counts.count(-universe_number)\n\n    def is_group_traitors(group, group_counts):\n        return all(is_traitor(count_traitors_in_universe(universe_number, group_counts), n) for universe_number in range(1, n + 1))\n\n    def is_cancellation_needed(group_counts):\n        return any(check_scenario(group_counts) for group_counts in itertools.product(*[range(2) for _ in range(n)]))\n\n    traitor_universes = set()\n    group_counts = [0] * n\n    for group in groups:\n        for u in range(1, n + 1):\n            group_counts[u - 1] += count_traitor_universes([x for x in group if x[0] == u or x[0] == -u])\n        traitor_universes.add(count_traitors_in_universe(1, group_counts))\n        traitor_universes.add(count_traitors_in_universe(-1, group_counts))\n\n    return \"YES\" if is_cancellation_needed(group_counts) else \"NO\"\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = [[] for _ in range(m)]\n\n    for i in range(m):\n        k = int(stdin.split()[i * 2 + 2])\n        for j in range(k):\n            if stdin.split()[i * 2 + 3 + j] == '-1':\n                groups[i].append((-int(stdin.split()[i * 2 + 3 + j + 1]), i))\n            else:\n                groups[i].append((int(stdin.split()[i * 2 + 3 + j + 1]), i))\n\n    def is_traitor(group):\n        ricks = [person for person, _ in group if person < 0]\n        return len(ricks) == 1\n\n    def find_traitor(group):\n        ricks = [person for person, _ in group if person < 0]\n        if ricks:\n            return ricks[0]\n        return max(person for person, _ in group)\n\n    def is_world_ending(group):\n        traitors = find_traitor(group)\n        if traitors == 0:\n            return True\n        return traitors < 0\n\n    for group in groups:\n        if is_world_ending(group):\n            return \"YES\"\n\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    groups = [list(map(int, stdin.split()[2:]))[1:] for _ in range(m)]\n\n    def get_ricks_and_mortys(group: list) -> tuple:\n        ricks = [group[i] for i in range(len(group)) if group[i] < 0]\n        mortys = [group[i] for i in range(len(group)) if group[i] > 0]\n        return (ricks, mortys)\n\n    def get_traitors(ricks_and_mortys: tuple) -> tuple:\n        ricks, mortys = ricks_and_mortys\n        traitors = tuple(filter(lambda x: x > 0, ricks))\n        return traitors\n\n    def is_world_ending(group: list) -> bool:\n        ricks_and_mortys = get_ricks_and_mortys(group)\n        traitors = get_traitors(ricks_and_mortys)\n        return len(traitors) == len(group)\n\n    scenarios = 0\n    for group in groups:\n        scenarios += 2 ** (len(group) - 1)\n\n    world_ending_scenarios = 0\n    for scenario in range(scenarios):\n        group_members = []\n        for group in groups:\n            members = []\n            for i in range(len(group) // 2):\n                if scenario & (1 << i):\n                    members.append(-group[2 * i])\n                else:\n                    members.append(group[2 * i + 1])\n            group_members.append(members)\n\n        for group in group_members:\n            if is_world_ending(group):\n                world_ending_scenarios += 1\n                break\n\n    return \"YES\" if world_ending_scenarios > 0 else \"NO\"\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = [[] for _ in range(m)]\n    \n    for i in range(m):\n        k = int(stdin.split()[2 + i])\n        for j in range(k):\n            v = int(stdin.split()[3 + i * k + j])\n            if v > 0:\n                groups[i].append(v)\n            else:\n                groups[i].append(-v)\n    \n    def check_group(group, traitor):\n        for member in group:\n            if member == traitor:\n                return True\n        return False\n    \n    def check_scenario(universes, traitor):\n        return all(check_group(group, traitor) for group in universes)\n    \n    for traitor in range(1, n + 1):\n        if any(check_scenario(group, traitor) for group in groups):\n            return \"YES\"\n    \n    return \"NO\""
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    group_data = input_list[1:]\n    groups = []\n\n    for i in range(m):\n        k = int(group_data[i])\n        group = []\n        for j in range(k):\n            member = int(group_data[i][(j+1)*2+1])\n            if member < 0:\n                group.append((-member, j+1))\n            else:\n                group.append((member, j+1))\n        groups.append(group)\n\n    # Check for traitors in each group\n    def is_traitor(group):\n        traitors = [member for universe, member in group if universe < 0]\n        return len(set(traitors)) == 1\n\n    # Generate all possible combinations of groups\n    def generate_groups(groups, used_groups, current_group):\n        if len(used_groups) == n:\n            return [current_group]\n\n        result = []\n        for i, group in enumerate(groups):\n            if i not in used_groups:\n                used_groups.add(i)\n                new_groups = generate_groups(groups, used_groups, current_group + [group])\n                result.extend(new_groups)\n                used_groups.remove(i)\n\n        return result\n\n    # Check for scenarios where all members of a group are traitors\n    def check_scenarios(groups):\n        for group in groups:\n            if all(is_traitor(group) for _ in range(n)):\n                return True\n        return False\n\n    all_groups = generate_groups(groups, set(), [])\n    return \"YES\" if check_scenarios(all_groups) else \"NO\"\n"
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split('\\n')\n    n, m = map(int, input.pop(0).split())\n    group_members = []\n    \n    for i in range(m):\n        k = int(input[i])\n        universe_members = [int(x) for x in input[i].split()[1:]]\n        group_members.append((k, universe_members))\n    \n    ricks = [0] * n\n    mortys = [0] * n\n    for k, universe_members in group_members:\n        for i in range(k):\n            if universe_members[i] < 0:\n                ricks[-universe_members[i]] += 1\n            else:\n                mortys[universe_members[i]] += 1\n    \n    count = sum([sum([ricks[i] for i in range(n) if ricks[i] > 0 and mortys[i] == 0]) for j in range(n) if ricks[j] == 0])\n    \n    return \"YES\" if count > 0 else \"NO\""
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    groups = []\n    \n    for _ in range(m):\n        k = int(stdin.split()[0])\n        group = []\n        for j in range(1, k+1):\n            v_i = int(stdin.split()[j])\n            if v_i < 0:\n                group.append(-v_i)\n            else:\n                group.append(v_i)\n        groups.append(group)\n    \n    for i in range(1, 2**n):\n        ricks = []\n        mortys = []\n        for j in range(n):\n            if (i & (1 << j)) != 0:\n                ricks.append(j+1)\n            else:\n                mortys.append(j+1)\n        \n        if sum(ricks) == n or sum(mortys) == n:\n            if len(groups) == 0:\n                return \"YES\"\n            for group in groups:\n                if len(group) == 1 and group[0] in ricks:\n                    return \"YES\"\n            return \"NO\"\n\n\ninput_stdin = \"\"\"4 2\n1 -3\n4 -2 3 2 -3\"\"\"\n\nresult = solution(input_stdin)\nprint(result)\n\n\ninput_stdin = \"\"\"5 2\n5 3 -2 1 -1 5\n3 -5 2 5\"\"\"\n\nresult = solution(input_stdin)\nprint(result)\n\n\ninput_stdin = \"\"\"7 2\n3 -1 6 7\n7 -5 4 2 4 7 -3 4\"\"\"\n\nresult = solution(input_stdin)\nprint(result) "
    },
    {
        "number": 901,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    groups = [[] for _ in range(m)]\n\n    for i in range(m):\n        k = int(stdin.split()[i+2])\n        for j in range(k):\n            person = int(stdin.split()[i+3+j])\n            if person < 0:\n                groups[i].append((-person, 0))\n            else:\n                groups[i].append((person, 1))\n\n    def is_traitor(group: list) -> bool:\n        ricks = sum(1 for person, is_morty in group if is_morty == 0)\n        mortys = sum(1 for person, is_morty in group if is_morty == 1)\n        return ricks > 0 and ricks == mortys\n\n    def count_scenarios(group: list) -> int:\n        scenarios = 0\n        for traitor in group:\n            if traitor[1] == 0:  # Rick is traitor\n                scenarios += sum(1 for other_person, is_morty in group if other_person != traitor[0] and is_morty == 1)\n            else:  # Morty is traitor\n                scenarios += sum(1 for other_person, is_morty in group if other_person != traitor[0] and is_morty == 0)\n        return scenarios\n\n    count = 0\n    for group in groups:\n        if is_traitor(group):\n            count += count_scenarios(group)\n\n    return \"YES\" if count > 0 else \"NO\""
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    powers = list(map(int, stdin.splitlines()[1].split()))\n\n    if k >= n:\n        return str(powers[0])\n\n    # Create a dictionary to store the number of consecutive wins\n    # and the current position of the players\n    status = {i: {\"wins\": 0, \"position\": i} for i in range(1, n + 1)}\n\n    # Initialize the current winner\n    current_winner = powers[0]\n\n    # Initialize the number of consecutive wins of the current winner\n    current_wins = 1\n\n    # Update the number of consecutive wins and the position of the players\n    for i in range(1, n):\n        if powers[i] > powers[i - 1]:\n            status[powers[i]][\"wins\"] += 1\n            status[powers[i]][\"position\"] = i + 1\n        else:\n            status[powers[i]][\"wins\"] = 0\n            status[powers[i]][\"position\"] = i + 1\n\n        # Update the number of consecutive wins and the current winner\n        if status[current_winner][\"wins\"] >= k:\n            current_wins += 1\n            if current_wins == k:\n                return str(current_winner)\n        else:\n            current_winner = max(status, key=lambda x: status[x][\"wins\"])\n            current_wins = 1\n\n    return str(current_winner)\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n\n    winners = [1] * n\n    for i in range(2, n):\n        if powers[i] > powers[i - 1]:\n            winners[i] = winners[i - 1] + 1\n        else:\n            winners[i] = 1\n\n    winner = max(winners)\n    for i in range(n):\n        if winners[i] == winner:\n            return powers[i]\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def play_game(player1, player2):\n        return player1 if player1.power > player2.power else player2\n\n    def find_winner(players):\n        i = 0\n        while i < len(players):\n            j = i + 1\n            while j < len(players):\n                if players[i].wins_in_a_row < players[j].wins_in_a_row:\n                    players[i], players[j] = players[j], players[i]\n                j += 1\n            i += 1\n        return players[0]\n\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n\n    players = []\n    for power in powers:\n        players.append(Player(power))\n\n    winner = find_winner(players)\n    return str(winner.power)\n\n\nclass Player:\n    def __init__(self, power):\n        self.power = power\n        self.wins_in_a_row = 1\n\n\ndef"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n    assert len(powers) == n\n    power_dict = {power: i for i, power in enumerate(powers)}\n    loser_power = 0\n    loser_index = -1\n    for _ in range(k):\n        winner_power = loser_power\n        winner_index = loser_index\n        loser_power = max(power_dict.keys()) + 1\n        for i, power in enumerate(powers):\n            if power <= loser_power:\n                loser_power = power\n                loser_index = i\n                powers[i] = winner_power + 1\n    return str(winner_power)\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    winner = a[0]\n    count = 1\n\n    for i in range(1, n):\n        if a[i] > winner:\n            count = 1\n            winner = a[i]\n        else:\n            count += 1\n\n        if count == k:\n            break\n\n    return winner\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n    winner = powers[0]\n    wins = 1\n\n    for i in range(1, n):\n        if powers[i] > winner:\n            winner = powers[i]\n            wins = 1\n        else:\n            wins += 1\n\n        if wins == k:\n            return str(winner)\n\n    return str(winner)\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n\n    def play(a: int, b: int) -> int:\n        return a if a > b else b\n\n    winner = powers[0]\n    wins = 0\n    for i in range(1, n):\n        if powers[i] == winner:\n            wins += 1\n            if wins == k:\n                return winner\n        else:\n            wins = 1\n        winner = play(winner, powers[i])\n\n    return winner\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n\n    # Find the winner\n    winner_power = powers[0]\n    for i in range(1, n):\n        if powers[i] > winner_power:\n            winner_power = powers[i]\n        elif powers[i] == winner_power and i > 0:\n            break\n\n    return str(winner_power)\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    powers = list(map(int, input_data[1].split()))\n\n    def play_game(player1_power, player2_power):\n        return max(player1_power, player2_power)\n\n    def update_line(line, loser_index):\n        line.append(line.pop(loser_index))\n        return line\n\n    line = []\n    for power in powers:\n        line.append(power)\n\n    winner_power = line[0]\n    num_wins = 0\n\n    while num_wins < k:\n        loser_index = -1\n        for i in range(len(line) - 1):\n            if line[i] < line[i + 1]:\n                winner_power = line[i + 1]\n                loser_index = i\n                break\n            elif line[i] > line[i + 1]:\n                winner_power = line[i]\n                loser_index = i + 1\n                break\n\n        if loser_index == -1:\n            break\n\n        line = update_line(line, loser_index)\n        num_wins += 1\n\n    return winner_power\n"
    },
    {
        "number": 902,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    powers = list(map(int, stdin.split()[2:]))\n    \n    winner = 1\n    wins = 1\n    for i in range(2, n):\n        if powers[i] > powers[winner]:\n            wins += 1\n            if wins == k:\n                break\n        else:\n            wins = 1\n        winner = i\n    \n    return f\"{powers[winner]} \""
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from typing import List\n    \n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    \n    def find_median(array: List[int], operations: int) -> int:\n        array.sort()\n        return array[operations // 2]\n    \n    def find_max_median(array: List[int], operations: int) -> int:\n        median = find_median(array, operations)\n        for i in range(len(array)):\n            if array[i] < median:\n                array[i] += 1\n                if k == 0:\n                    return median\n                k -= 1\n        return median\n    \n    return str(find_max_median(a, k))\n"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Calculate the median\n    median = sorted(a)[n // 2]\n\n    # Apply the operations to increase the median\n    operations = 0\n    for i in range(n):\n        if a[i] < median:\n            if operations < k:\n                a[i] += 1\n                operations += 1\n\n    # Calculate the new median\n    new_median = sorted(a)[n // 2]\n\n    return str(new_median)"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_list = input_str.split('\\n')\n    n, k = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    a.sort()\n    median = a[n // 2]\n\n    max_median = median\n    operations = 0\n\n    for i in range(n - 1, n // 2 - 1, -1):\n        if operations < k:\n            a[i] += 1\n            operations += 1\n        if a[i] > max_median:\n            max_median = a[i]\n\n    return max_median\n"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    a.sort()\n    median = a[n // 2]\n    \n    max_increase = min(k, median - a[0])\n    \n    a[0] += max_increase\n    a[-1] -= max_increase\n    \n    a.sort()\n    \n    return a[(n + 1) // 2 - 1]\n"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n\n    median = a[n // 2]\n    for i in range(n):\n        if median == a[i]:\n            break\n\n    if k < 2 * (n - i):\n        return a[i] + 1\n    else:\n        return median\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(solution(stdin)) "
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    def max_median(a, k):\n        a.sort()\n        for i in range(len(a)):\n            if 2*i < k:\n                a[i] += 1\n                k -= 2*i + 1\n            else:\n                break\n        return a[len(a)//2]\n    \n    return str(max_median(a, k))"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def find_median(a):\n        a.sort()\n        return a[len(a) // 2]\n\n    def is_valid(a, i, change):\n        a[i] += change\n        return find_median(a) == max(a)\n\n    def binary_search(a, k):\n        left, right = 1, 1000000000\n        while left <= right:\n            mid = (left + right) // 2\n            if is_valid(a, i, mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left - 1\n\n    max_median = 0\n    for i in range(n):\n        change = binary_search(a, k)\n        k -= change\n        max_median = max(max_median, a[i] + change)\n        a[i] = a[i] + change\n\n    return str(max_median)\n"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    a.sort()\n    median = a[n // 2]\n\n    if n % 2 == 1:\n        for i in range(n // 2, n - 1):\n            if a[i] > median:\n                break\n            a[i] += 1\n            k -= 1\n            if k == 0:\n                break\n    else:\n        for i in range(n // 2 - 1, n - 1):\n            if a[i] > median:\n                break\n            a[i] += 1\n            k -= 1\n            if k == 0:\n                break\n\n    return str(median)\n"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n    median = a[n // 2]\n\n    operations = 0\n    for i in range(n):\n        if a[i] < median:\n            operations += median - a[i]\n            a[i] = median\n        else:\n            operations -= a[i] - median\n            a[i] = median\n\n        if operations > k:\n            break\n\n    return str(median)\n\n\ndef"
    },
    {
        "number": 903,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def find_median(a):\n        a.sort()\n        if n % 2 == 0:\n            return (a[n // 2 - 1] + a[n // 2]) / 2\n        else:\n            return a[n // 2]\n\n    def increase_elements(a, k):\n        a.sort()\n        i = 0\n        while k > 0 and i < n - 1:\n            if a[i] < a[i + 1]:\n                a[i] += 1\n                k -= 1\n            i += 1\n        if k > 0 and i < n - 1:\n            a[i] += 1\n            k -= 1\n        return a\n\n    a = increase_elements(a, k)\n    return find_median(a)\n\n\ninput_string = \"\"\"3 2\n1 3 5\"\"\"\nprint(solution(input_string))  # Output: 5\n\ninput_string = \"\"\"5 5\n1 2 1 1 1\"\"\"\nprint(solution(input_string))  # Output: 3\n\ninput_string = \"\"\"7 7\n4 1 2 4 3 4 4\"\"\"\nprint(solution(input_string))  # Output: 5 "
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    words = lines[1].split()\n    max_volume = 0\n    for word in words:\n        volume = 0\n        for letter in word:\n            if letter.isupper():\n                volume += 1\n        if volume > max_volume:\n            max_volume = volume\n    return str(max_volume)\n\ndef"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    words = stdin.split(\"\\n\")[1].split(\" \")\n    max_volume = 0\n    for word in words:\n        volume = sum(1 for c in word if c.isupper())\n        if volume > max_volume:\n            max_volume = volume\n    return str(max_volume)"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    words = stdin.split(\"\\n\")[1].split()\n    max_volume = 0\n\n    for word in words:\n        volume = sum(1 for char in word if char.isupper())\n        if volume > max_volume:\n            max_volume = volume\n\n    return max_volume\n\n\ndef"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    s = input_list[1]\n    words = s.split(' ')\n    max_volume = 0\n    for word in words:\n        volume = 0\n        for letter in word:\n            if letter.isupper():\n                volume += 1\n        if volume > max_volume:\n            max_volume = volume\n    return max_volume\n"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1].split()\n    max_volume = 0\n\n    for word in words:\n        volume = sum(1 for letter in word if letter.isupper())\n        if volume > max_volume:\n            max_volume = volume\n\n    return max_volume\n"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1].split()\n    max_vol = 0\n    for word in s:\n        vol = sum(1 for c in word if c.isupper())\n        max_vol = max(max_vol, vol)\n    return max_vol\n"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def volume(word: str) -> int:\n        return sum(1 for letter in word if letter.isupper())\n\n    n = int(stdin.split()[0])\n    text = stdin.split()[1]\n    words = text.split()\n    max_volume = 0\n\n    for word in words:\n        volume_word = volume(word)\n        max_volume = max(max_volume, volume_word)\n\n    return max_volume\n"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    s = stdin.split(\"\\n\")[1]\n    words = s.split(\" \")\n    max_vol = 0\n    for word in words:\n        vol = sum([1 for char in word if char.isupper()])\n        if vol > max_vol:\n            max_vol = vol\n    return max_vol\n\n\ndef"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    text = stdin.split(\"\\n\")[1]\n    words = text.split(\" \")\n    max_volume = 0\n\n    for word in words:\n        volume = 0\n        for char in word:\n            if char.isupper():\n                volume += 1\n        max_volume = max(max_volume, volume)\n\n    return max_volume\n"
    },
    {
        "number": 904,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, text = stdin.split(\"\\n\")\n    n = int(n)\n    words = text.split()\n    max_volume = 0\n    for word in words:\n        volume = sum(1 for letter in word if letter.isupper())\n        max_volume = max(max_volume, volume)\n    return max_volume\n"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0].split())\n    sugar_prices = []\n    for _ in range(n):\n        price = tuple(map(int, stdin.split()[1].split()))\n        sugar_prices.append(price)\n\n    max_sweets = 0\n    for i in range(n):\n        dollar_price, cents_price = sugar_prices[i]\n        sweets = dollar_price * 100\n        if sweets > max_sweets and dollar_price <= s:\n            max_sweets = sweets\n\n    if max_sweets <= 99:\n        return str(max_sweets)\n    else:\n        return \"-1\"\n\n\ninput_file = \"input.txt\"\nwith open(input_file, \"r\") as f:\n    stdin = f.read()\n\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    x = [int(i) for i in stdin.split()[2:n*2:2]]\n    y = [int(i) for i in stdin.split()[3:n*2:2]]\n    cost = sum(x)\n    for i in range(n):\n        if y[i] == 0 and cost - x[i] <= s:\n            return y[i]\n        elif y[i] == 0 and cost - x[i] > s:\n            continue\n        else:\n            change = s - (cost - x[i] - y[i])\n            if change < 100:\n                return change\n            else:\n                return 99\n    return -1\n"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    sugar_prices = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    max_sweets = -1\n    for price in sugar_prices:\n        x, y = price\n        if x <= s:\n            sweets = y + (s - x) // 50\n            max_sweets = max(max_sweets, sweets)\n    \n    return max_sweets if max_sweets != -1 else \"Impossible\"\n\n\ninput_str = '''5 10\n3 90\n12 0\n9 70\n5 50\n7 0'''\n\nprint(solution(input_str)) "
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    if s <= 0:\n        return \"-1\"\n    elif n == 0:\n        return str(s)\n\n    sugar_cost = []\n    for i in range(n):\n        sugar_cost.append(list(map(int, stdin.split()[2 + i * 2 : 4 + i * 2])))\n\n    min_sugar_cost = min(sugar_cost, key=lambda x: x[0] * 100 + x[1])\n    if s >= min_sugar_cost[0] * 100 + min_sugar_cost[1]:\n        return str((s - (min_sugar_cost[0] * 100 + min_sugar_cost[1])) // 100)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    sugar_prices = [map(int, stdin.split()[i:i+2]) for i in range(2, 2 + n * 2, 2)]\n\n    max_sweets = 0\n    for price in sugar_prices:\n        dollars, cents = price\n        if dollars <= s:\n            total_cents = dollars * 100 + cents\n            sweets = total_cents // 100\n            if sweets > max_sweets:\n                max_sweets = sweets\n\n    return str(max_sweets) if max_sweets > 0 else \"-1\""
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    sugar_list = []\n    for i in range(1, n+1):\n        x, y = map(int, input_list[i].split())\n        sugar_list.append((x, y))\n\n    max_sweets = -1\n    for sugar in sugar_list:\n        dollars, cents = sugar\n        sweets = min(s, dollars + cents // 100)\n        if sweets > max_sweets:\n            max_sweets = sweets\n\n    return max_sweets if max_sweets != -1 else -1"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def change_to_cents(dollars: int, cents: int) -> int:\n        return dollars * 100 + cents\n\n    def max_sweets(sugar_prices: list, s: int) -> int:\n        max_sweets = 0\n        for price in sugar_prices:\n            if change_to_cents(s, price[0]) >= change_to_cents(0, price[1]):\n                max_sweets = max(max_sweets, price[1])\n        return max_sweets\n\n    n, s = map(int, stdin.split()[0:2])\n    sugar_prices = []\n    for _ in range(n):\n        dollars, cents = map(int, stdin.split()[2:4])\n        sugar_prices.append([dollars, cents])\n\n    result = max_sweets(sugar_prices, s)\n    return str(result)\n"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    sugar_prices = []\n    for _ in range(n):\n        sugar_prices.append(list(map(int, stdin.split()[1:])))\n    \n    # Sort sugar prices by the amount of dollars required\n    sugar_prices.sort(key=lambda x: x[0])\n    \n    max_sweets = -1\n    total_cost = 0\n    for sugar, price in sugar_prices:\n        if total_cost + sugar <= s:\n            total_cost += sugar\n            max_sweets += price\n        else:\n            break\n    \n    return str(max_sweets) if max_sweets != -1 else \"-1\"\n"
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_sweets(x, y):\n        return x * 100 + y\n\n    def get_max_sweets(n, s, prices, limits):\n        sweets = 0\n        for i in range(n):\n            if prices[i] <= s:\n                sweets = max(sweets, get_sweets(limits[i][0], limits[i][1]))\n        return sweets\n\n    lines = stdin.split('\\n')\n    n, s = map(int, lines[0].split())\n    limits = [tuple(map(int, lines[i+1].split())) for i in range(n)]\n    prices = [limits[i][0] for i in range(n)]\n    return get_max_sweets(n, s, prices, limits)\n\n\ninput_data = \"\"\"5 10\n3 90\n12 0\n9 70\n5 50\n7 0\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 905,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    sugar = []\n    for i in range(n):\n        sugar.append(tuple(map(int, stdin.split()[2+i*2:4+i*2])))\n\n    for i in range(n):\n        if sugar[i][0] <= s:\n            s -= sugar[i][0]\n            s += sugar[i][1]\n            if s < 100:\n                return str(s)\n    return \"-1\"\n"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    \n    def count(k):\n        def c(i, j):\n            return ((i+j) * (i-j) * (i+j+1) * (i-j+1)) // 8\n        if k == 1:\n            return c(n, m)\n        else:\n            return c(m, n)\n    \n    return str((count(1) - count(k)) % (10**9 + 7))\n\nn, m, k = map(int, input().split())\nprint(solution(f\"{n} {m} {k}\")) "
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    result = 1\n\n    if k == 1:\n        result = n * m\n    elif k == -1:\n        result = (n + 1) * (m + 1) - n - m\n\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    \n    if k == 1:\n        total_ways = 1\n    else:\n        total_ways = 0\n    \n    for i in range(n):\n        row_product = 1\n        for j in range(m):\n            row_product *= k\n            if row_product == 0:\n                break\n        if row_product != 0:\n            total_ways *= row_product\n            if total_ways == 0:\n                break\n    \n    for j in range(m):\n        col_product = 1\n        for i in range(n):\n            col_product *= k\n            if col_product == 0:\n                break\n        if col_product != 0:\n            total_ways *= col_product\n            if total_ways == 0:\n                break\n    \n    return str(total_ways % 1000000007)"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        return 1\n    elif n == 1:\n        return m\n    elif m == 1:\n        return n\n    else:\n        return (pow(n, m, 10**9 + 7) * pow(m, n, 10**9 + 7) * pow(k, -1, 10**9 + 7)) % (10**9 + 7) "
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        if m == 1:\n            return 1\n        else:\n            return 0\n    else:\n        if m == 1:\n            return 0\n        else:\n            return factorial(m) * factorial(n) % (10**9 + 7)\n\ndef"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    \n    if k == 1:\n        return ((2 * n * m) // 2) % (10**9 + 7)\n    else:\n        return ((2 * n * m) // 2) % (10**9 + 7)\n"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        return n * m\n    else:\n        return (n * m) // 2 + 1\n\n\ndef"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        return str((n * m) % (10**9 + 7))\n    else:\n        return str(2**(n + m) % (10**9 + 7))\n"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n\n    if k == 1:\n        return (factorial(n) * factorial(m)) % 1000000007\n    else:\n        return (factorial(n - 1) * factorial(m - 1)) % 1000000007\n\n\ndef"
    },
    {
        "number": 906,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    \n    if k == 1:\n        return str((1 * n) * (1 * m) % 1000000007)\n    else:\n        return str(1)"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    pairs = [(int(x), int(y)) for x, y in (line.split() for line in input_list[1:])]\n\n    # Check if there exists any pair with x or y\n    for x in range(1, n+1):\n        for y in range(x+1, n+1):\n            if any(a == x or b == x or a == y or b == y for a, b in pairs):\n                return \"YES\"\n    return \"NO\"\n\ndef"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line.strip()]\n\n    for x in range(1, n + 1):\n        for y in range(x + 1, n + 1):\n            count = 0\n            for pair in pairs:\n                if x in pair or y in pair:\n                    count += 1\n                    if count >= 2:\n                        return \"YES\"\n            else:\n                continue\n\n    return \"NO\"\n"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    count = 0\n    x, y = 0, 0\n\n    for i in range(m):\n        a, b = map(int, input().split())\n        if a == b:\n            continue\n        if a < b:\n            a, b = b, a\n        if a > x:\n            x = a\n        if b < y:\n            y = b\n        count += 1\n\n    if count < n:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    for i in range(m):\n        for j in range(m):\n            if i != j:\n                if (pairs[i][0] == pairs[j][0] and pairs[i][1] == pairs[j][1]) or (pairs[i][0] == pairs[j][1] and pairs[i][1] == pairs[j][0]):\n                    return \"YES\"\n                \n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    pairs = []\n    for i in range(1, m+1):\n        pairs.append(list(map(int, input_list[i].split())))\n\n    for i in range(1, n):\n        count = 0\n        for pair in pairs:\n            if pair[0] == i or pair[1] == i:\n                count += 1\n        if count == 0:\n            return \"NO\"\n    return \"YES\"\n\ndef"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if len(line) > 0]\n    \n    for x in range(1, n+1):\n        for y in range(x+1, n+1):\n            found = True\n            for a, b in pairs:\n                if a == x or b == x or a == y or b == y:\n                    continue\n                found = False\n                break\n            if found:\n                return \"YES\"\n    \n    return \"NO\"\n"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line.strip()]\n    \n    for x in range(1, n + 1):\n        for y in range(x + 1, n + 1):\n            if all(any(i in (x, y) for i in pair) for pair in pairs):\n                return \"YES\"\n    return \"NO\" "
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, stdin.split()[2:4])) for _ in range(m)]\n    pairs.sort(key=lambda x: x[0])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            count_i, count_j = 0, 0\n            for pair in pairs:\n                if pair[0] == i or pair[1] == i:\n                    count_i += 1\n                if pair[0] == j or pair[1] == j:\n                    count_j += 1\n            if count_i > 0 and count_j > 0:\n                return \"YES\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n\n    for x in range(1, n+1):\n        for y in range(x+1, n+1):\n            for pair in pairs:\n                if x in pair or y in pair:\n                    continue\n                if not (pair[0] == x or pair[1] == x) and not (pair[0] == y or pair[1] == y):\n                    break\n            else:\n                return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 907,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    pairs = [(int(a), int(b)) for a, b in [line.split() for line in stdin.split('\\n')[1:]]]\n    for x in range(1, n):\n        for y in range(x+1, n+1):\n            found = True\n            for a, b in pairs:\n                if a == x or b == x or a == y or b == y:\n                    found = False\n                    break\n            if not found:\n                continue\n            return \"YES\"\n    return \"NO\"\n\ndef"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    c = list(map(int, input_list[1].split()))\n    s = input_list[2:]\n\n    if n == 1:\n        return c[0]\n\n    s = sorted(s)\n    c.sort()\n\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            min_cost = min(c[i], c[i + 1])\n            if min_cost < c[i]:\n                c[i] -= min_cost\n                c[i + 1] -= min_cost\n            else:\n                c[i + 1] -= min_cost\n                c[i] -= min_cost\n            s = sorted(s[:i + 1] + s[i + 1:])\n\n    if s[0] > s[1]:\n        return -1\n\n    return sum(c)\n"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_prefix_of(s1: str, s2: str) -> bool:\n        return s1 == s2[:len(s1)]\n\n    def min_reverse(s: str) -> int:\n        return sum(ord(c) for c in s)\n\n    n = int(stdin.splitlines()[0])\n    c = [int(x) for x in stdin.splitlines()[1].split()]\n    strings = stdin.splitlines()[2:]\n\n    sorted_strings = sorted(strings)\n    result = 0\n    for i in range(n):\n        if not is_prefix_of(sorted_strings[i], strings[i]):\n            result += c[i]\n            result += min_reverse(sorted_strings[i])\n\n    if result == 0:\n        return str(result)\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n = int(input_data[0])\n    c = list(map(int, input_data[1].split()))\n\n    if n != len(c):\n        raise ValueError(\"Invalid input\")\n\n    strings = input_data[2:]\n\n    # Check if it's possible to sort the strings\n    for i in range(n - 1):\n        if strings[i] > strings[i + 1]:\n            for j in range(i + 1, n):\n                if strings[i] > strings[j]:\n                    return -1\n\n    # Calculate the minimum amount of energy\n    energy = 0\n    for i in range(n):\n        for j in range(i, n):\n            if strings[i] > strings[j]:\n                energy += c[j]\n                strings[i], strings[j] = strings[j], strings[i]\n                break\n\n    return energy"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    c = [int(x) for x in input().split()]\n    s = [input() for _ in range(n)]\n\n    def is_sorted(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    def reverse_string(i):\n        return s[i][::-1]\n\n    if is_sorted(s):\n        return 0\n\n    min_energy = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if s[i] > s[j] and c[i] < c[j]:\n                min_energy = min(min_energy, c[i] + c[j])\n\n    if min_energy == float('inf'):\n        return -1\n    else:\n        return min_energy\n\n\nn = int(input())\nc = [int(x) for x in input().split()]\ns = [input() for _ in range(n)]\n\nprint(solution(\"2\\n1 2\\nba\\nac\"))\nprint(solution(\"3\\n1 3 1\\nba\\nac\\nbbb\\n\"))\nprint(solution(\"2\\n5 5\\nbbb\\naaa\\n\"))\nprint(solution(\"2\\n3 3\\naaa\\naa\\n\")) "
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    energy_list = list(map(int, input_list[1].split()))\n    string_list = input_list[2:]\n\n    sorted_string_list = sorted(string_list)\n    sorted_string_list = [s + \"a\" * (len(sorted_string_list[0]) - len(s)) for s in sorted_string_list]\n\n    energy_sum = sum(energy_list)\n    min_energy_sum = float(\"inf\")\n\n    for i in range(n - 1):\n        if sorted_string_list[i] > sorted_string_list[i + 1]:\n            for j in range(i, -1, -1):\n                if sorted_string_list[j] > sorted_string_list[j + 1]:\n                    min_energy_sum = min(min_energy_sum, energy_list[j + 1])\n                    sorted_string_list[j + 1], sorted_string_list[j + 2] = sorted_string_list[j + 2], sorted_string_list[j + 1]\n                    energy_list[j], energy_list[j + 1] = energy_list[j + 1], energy_list[j]\n                    energy_sum -= energy_list[j]\n                    energy_sum += energy_list[j + 1]\n                else:\n                    break\n\n    if min_energy_sum == float(\"inf\"):\n        return \"-1\"\n    else:\n        return str(min_energy_sum)\n\n\nstdin = '''2\n1 2\nba\nac'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    costs = [int(i) for i in stdin.splitlines()[1].split()]\n    strings = stdin.splitlines()[2:]\n\n    for i in range(n - 1):\n        if len(strings[i]) >= len(strings[i+1]) and strings[i] > strings[i+1]:\n            return -1\n\n    reversed_costs = [0] * n\n    for i in range(n):\n        reversed_costs[i] = costs[i] * (len(strings[i]) - 1)\n\n    reversed_strings = [s[::-1] for s in strings]\n\n    total_cost = sum(reversed_costs)\n\n    for i in range(n - 1):\n        if len(reversed_strings[i]) >= len(reversed_strings[i+1]) and reversed_strings[i] > reversed_strings[i+1]:\n            return -1\n\n    return total_cost\n\n\ndef"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n = int(input_list[0])\n    c = list(map(int, input_list[1].split()))\n    strings = input_list[2:]\n\n    # Check if it is possible to sort the strings in lexicographical order\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if strings[i] > strings[j]:\n                return -1\n\n    # Calculate the minimum amount of energy required\n    total_energy = 0\n    for i in range(n):\n        for j in range(len(strings[i]) - 1):\n            if strings[i][j] > strings[i][j + 1]:\n                total_energy += c[i]\n                strings[i] = strings[i][::-1]\n                break\n\n    return total_energy\n"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    energy = list(map(int, stdin.split('\\n')[1].split()))\n    strings = stdin.split('\\n')[2:]\n\n    def is_sorted(s):\n        for i in range(len(s) - 1):\n            if s[i] > s[i+1]:\n                return False\n        return True\n\n    def reverse_string(s):\n        return s[::-1]\n\n    def reverse_and_check(s, i):\n        reversed_s = reverse_string(s)\n        return is_sorted(strings[:i] + [reversed_s] + strings[i+1:])\n\n    min_energy = float('inf')\n    for i in range(n):\n        if energy[i] < min_energy and reverse_and_check(strings[i], i):\n            min_energy = energy[i]\n        elif min_energy == energy[i] and not reverse_and_check(strings[i], i):\n            min_energy = float('inf')\n            break\n\n    return min_energy if min_energy != float('inf') else -1"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_string(s: str, c: int) -> str:\n        return s[::-1]\n\n    def is_lexicographically_smaller(s1: str, s2: str) -> bool:\n        if len(s1) < len(s2):\n            return True\n        elif len(s1) > len(s2):\n            return False\n        else:\n            for i in range(len(s1)):\n                if s1[i] < s2[i]:\n                    return True\n                elif s1[i] > s2[i]:\n                    return False\n            return False\n\n    def find_min_energy(strings: List[str]) -> int:\n        min_energy = float('inf')\n        for i in range(len(strings)):\n            for j in range(i + 1, len(strings)):\n                if is_lexicographically_smaller(strings[i], strings[j]):\n                    reversed_s1 = reverse_string(strings[i], costs[i])\n                    reversed_s2 = reverse_string(strings[j], costs[j])\n                    new_strings = strings.copy()\n                    new_strings[i] = reversed_s1\n                    new_strings[j] = reversed_s2\n                    min_energy = min(min_energy, find_min_energy(new_strings))\n        return min_energy\n\n    n, *costs = map(int, stdin.split())\n    strings = [input() for _ in range(n)]\n\n    if find_min_energy(strings) == float('inf'):\n        return -1\n    else:\n        return find_min_energy(strings)\n"
    },
    {
        "number": 908,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    energy_list = list(map(int, input_list[1].split()))\n    string_list = input_list[2:]\n    \n    sorted_list = sorted(string_list)\n    \n    min_energy = float('inf')\n    min_energy_list = []\n    \n    for i in range(n):\n        if sorted_list[i] != string_list[i]:\n            min_energy = min(min_energy, energy_list[i])\n            min_energy_list.append(i)\n    \n    if min_energy == float('inf'):\n        return '-1'\n    else:\n        return min_energy\n"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = a + b + c\n    max_value = max(max_value, a * b + c)\n    max_value = max(max_value, a + b * c)\n    max_value = max(max_value, a * (b + c))\n    return str(max_value) "
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a + b * c, a * (b + c), a * b * c)\n    return str(max_value)"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = 0\n    \n    # max value when a is multiplied by b and c\n    max_value = max(max_value, a * b * c)\n    \n    # max value when a is added to b and c\n    max_value = max(max_value, a + b * c)\n    max_value = max(max_value, a * b + c)\n    \n    # max value when a is added to b and multiplied by c\n    max_value = max(max_value, a + b * c)\n    max_value = max(max_value, a * b + c)\n    \n    return str(max_value)\n"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n\n    max_value = max(a + b * c, a * b + c, a * (b + c))\n\n    return str(max_value)\n\n\ninput_str = \"1\\n2\\n3\"\nprint(solution(input_str)) "
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    \n    max_value = 0\n    \n    # Max value for (a+b)*c\n    max_value = max(max_value, (a + b) * c)\n    \n    # Max value for a*(b+c)\n    max_value = max(max_value, a * (b + c))\n    \n    # Max value for a*b*c\n    max_value = max(max_value, a * b * c)\n    \n    return str(max_value)\n"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a+b+c, a*b*c, (a+b)*c, a*(b+c))\n    return str(max_value)"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = a + b + c\n    max_value = max(max_value, a + c)\n    max_value = max(max_value, a * b)\n    max_value = max(max_value, a * c)\n    max_value = max(max_value, b * c)\n    return max_value\n\n\ndef"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = a + b + c\n    if a + b * c > max_value:\n        max_value = a + b * c\n    if a * b + c > max_value:\n        max_value = a * b + c\n    if a * (b + c) > max_value:\n        max_value = a * (b + c)\n    if a * b * c > max_value:\n        max_value = a * b * c\n    return str(max_value)\n"
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a+b*c, a*(b+c), a*b*c)\n    return str(max_value)\n\na = input()\nb = input()\nc = input()\nstdin = a + '\\n' + b + '\\n' + c\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 909,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a + b + c, a * b * c, (a + b) * c, (a + c) * b, (b + c) * a)\n    return str(max_value)\n\ndef"
    }
]